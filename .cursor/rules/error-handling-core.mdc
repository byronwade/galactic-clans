# Core Error Handling System

This rule establishes mandatory error handling patterns for the Galactic Clans gaming system to ensure rapid issue identification and resolution.

## Error Classification System

All errors must be classified using these categories:

```typescript
enum ErrorSeverity {
    CRITICAL = "CRITICAL",    // Game-breaking, requires immediate fallback
    HIGH = "HIGH",           // Major feature broken, affects gameplay
    MEDIUM = "MEDIUM",       // Minor feature issue, game continues
    LOW = "LOW",            // Cosmetic or performance issues
    DEBUG = "DEBUG"         // Development-only information
}

enum ErrorCategory {
    GRAPHICS = "GRAPHICS",
    AUDIO = "AUDIO", 
    NETWORK = "NETWORK",
    AI = "AI",
    PHYSICS = "PHYSICS",
    UI = "UI",
    WORLD = "WORLD",
    COMBAT = "COMBAT",
    RESOURCES = "RESOURCES",
    INPUT = "INPUT",
    PERFORMANCE = "PERFORMANCE"
}
```

## Mandatory Error Handling Pattern

Every function that can fail MUST follow this pattern:

```typescript
try {
    // Core functionality
    const result = riskyOperation();
    
    // Validation checkpoint
    if (!isValidResult(result)) {
        throw new GameError(ErrorCategory.CATEGORY, ErrorSeverity.MEDIUM, 
            "Result validation failed", { result, expected: "valid result" });
    }
    
    return result;
} catch (error) {
    // Detailed error logging with context
    console.error(`ğŸš¨ [${ErrorCategory.CATEGORY}:${ErrorSeverity.HIGH}] Operation failed in ${functionName}:
        âŒ Error: ${error.message}
        ğŸ“ Location: ${this.constructor.name}.${functionName}()
        ğŸ” Context: ${JSON.stringify(context, null, 2)}
        ğŸ“Š System State: ${this.getSystemState()}
        ğŸ• Timestamp: ${new Date().toISOString()}
        ğŸ“‹ Stack: ${error.stack}`);
    
    // Execute fallback strategy
    return this.executeFallback(error, context);
}
```

## Fallback Strategy Requirements

Every critical system component MUST implement these fallback methods:

```typescript
interface ErrorRecoverable {
    executeFallback(error: Error, context: any): any;
    getSystemState(): string;
    validateState(): boolean;
    resetToSafeState(): void;
    getHealthStatus(): SystemHealth;
}

interface SystemHealth {
    status: 'healthy' | 'degraded' | 'critical' | 'failed';
    issues: string[];
    performance: number; // 0-100
    lastError?: Error;
    recoverySuggestions: string[];
}
```

## Required Error Context Information

Every error log MUST include:

1. **ğŸ¯ Exact Location**: Class name, method name, line number
2. **ğŸ” Input Parameters**: All function arguments (sanitized)
3. **ğŸ“Š System State**: Current state of the component
4. **ğŸŒ Global Context**: Game state, player state, active scene
5. **ğŸ“ˆ Performance Metrics**: FPS, memory usage, active objects
6. **ğŸ• Timing**: Precise timestamp and execution duration
7. **ğŸ”„ Recovery Actions**: What fallbacks were attempted
8. **ğŸ‘¤ User Impact**: How this affects the player experience

## Gaming-Specific Error Monitoring

### Performance Monitoring
```typescript
// Monitor FPS drops
if (currentFPS < targetFPS * 0.8) {
    console.warn(`ğŸ® [PERFORMANCE:MEDIUM] FPS drop detected:
        Current: ${currentFPS}fps, Target: ${targetFPS}fps
        Scene Objects: ${scene.children.length}
        Memory: ${performance.memory?.usedJSHeapSize || 'unknown'}
        Active Systems: ${this.getActiveSystemsList()}
        Suggested Actions: ${this.getPerformanceRecoveryActions()}`);
}
```

### Graphics Error Recovery
```typescript
// Renderer failure fallback
try {
    renderer.render(scene, camera);
} catch (error) {
    console.error(`ğŸ¨ [GRAPHICS:CRITICAL] Render failure:
        Error: ${error.message}
        Scene Objects: ${scene.children.length}
        Camera: ${camera.position.toArray()}
        Canvas: ${canvas.width}x${canvas.height}
        WebGL Context: ${this.checkWebGLContext()}
        Recovery: Attempting canvas recreation...`);
    
    this.recreateCanvas();
    this.fallbackToSimpleRenderer();
}
```

## Error Persistence and Analytics

All errors must be:
1. **Logged to console** with full context
2. **Stored locally** for session analysis
3. **Tracked with metrics** for pattern detection
4. **Categorized by impact** on user experience

## Validation Requirements

Every public method MUST validate:
- Input parameters
- System state before execution
- Result validity after execution
- Resource availability
- Performance impact

Example validation pattern:
```typescript
public startCombat(attacker: Unit, defender: Unit): CombatResult {
    // Pre-execution validation
    this.validateInputs({ attacker, defender });
    this.validateSystemState(['combat', 'ai', 'physics']);
    this.validateResources(['cpu', 'memory']);
    
    try {
        const result = this.executeCombat(attacker, defender);
        
        // Post-execution validation
        this.validateResult(result);
        this.validateSystemState(['combat', 'ai', 'physics']);
        
        return result;
    } catch (error) {
        return this.handleCombatError(error, { attacker, defender });
    }
}
```

This comprehensive error handling system ensures that any issue in the gaming system can be quickly identified, understood, and resolved with minimal impact on player experience.
description:
globs:
alwaysApply: true
---

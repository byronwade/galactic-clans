# Galaxy Generation Smart Systems

This rule ensures smart, scalable galaxy generation with optimal performance and consistent design patterns across all cosmic scales.

## 🌌 Galaxy-Level Generation Rules

### **Streaming and LOD (Level of Detail)**
All galaxy generation MUST implement proper streaming and LOD systems:

```typescript
// MANDATORY: Use LOD distances for performance
private lodDistances = {
    high: 100,      // Full detail - all surface features visible
    medium: 500,    // Medium detail - major features only  
    low: 2000,      // Low detail - basic planet shapes
    minimal: 10000, // Point cloud - stars as dots only
};

// MANDATORY: Implement distance-based quality switching
public updateLOD(cameraPosition: THREE.Vector3): void {
    for (const system of this.starSystems.values()) {
        const distance = cameraPosition.distanceTo(system.position);
        
        if (distance < this.lodDistances.high) {
            system.setDetailLevel(DetailLevel.HIGH);
        } else if (distance < this.lodDistances.medium) {
            system.setDetailLevel(DetailLevel.MEDIUM);
        } else if (distance < this.lodDistances.low) {
            system.setDetailLevel(DetailLevel.LOW);
        } else {
            system.setDetailLevel(DetailLevel.MINIMAL);
        }
    }
}
```

### **Generation Queue Management**
NEVER generate everything at once - use smart queuing:

```typescript
// MANDATORY: Limit concurrent generation
private maxConcurrentGenerations = 3;
private generationQueue: string[] = [];
private isGenerating = false;

// MANDATORY: Cache generated content
private generationCache = new Map<string, Planet[]>();
private maxCacheSize = 100; // Prevent memory bloat

// MANDATORY: Priority-based generation
public requestGeneration(systemId: string, priority: GenerationPriority): void {
    if (priority === GenerationPriority.IMMEDIATE) {
        this.generationQueue.unshift(systemId);
    } else {
        this.generationQueue.push(systemId);
    }
    this.processGenerationQueue();
}
```

### **Advanced Low-Poly Galaxy Generation**
Use mathematically accurate spiral galaxy algorithms with low-poly aesthetics:

```typescript
// MANDATORY: Bruno Simon inspired galaxy generation with Delaunay triangulation
export interface GalaxyGenerationConfig {
    starCount: number;           // Number of star systems
    galaxyRadius: number;        // Maximum radius
    branches: number;            // Number of spiral arms (2-6 typical)
    spinFactor: number;          // How tightly arms spiral (-5 to 5)
    randomness: number;          // Scatter amount (0.0 to 2.0)
    randomnessPower: number;     // Bias towards center (1-10)
    insideColor: THREE.Color;    // Core color
    outsideColor: THREE.Color;   // Outer edge color
    lowPolyMode: boolean;        // Enable triangulation for low-poly look
}

class AdvancedGalaxyGenerator {
    private config: GalaxyGenerationConfig;
    private delaunayTriangles: Triangle[] = [];
    
    // MANDATORY: Generate realistic spiral galaxy structure
    public generateGalaxyPoints(): GalaxyPoint[] {
        const points: GalaxyPoint[] = [];
        
        for (let i = 0; i < this.config.starCount; i++) {
            // Random radius with realistic distribution
            const radius = Math.random() * this.config.galaxyRadius;
            
            // Assign to spiral arm
            const branchAngle = (i % this.config.branches) / this.config.branches * Math.PI * 2;
            
            // Add spiral spin based on distance from center
            const spinAngle = radius * this.config.spinFactor;
            
            // Calculate base position
            let x = Math.cos(branchAngle + spinAngle) * radius;
            let y = (Math.random() - 0.5) * this.config.galaxyRadius * 0.1; // Galaxy thickness
            let z = Math.sin(branchAngle + spinAngle) * radius;
            
            // Add controlled randomness using power function
            const randomX = Math.pow(Math.random(), this.config.randomnessPower) * 
                           this.config.randomness * (Math.random() < 0.5 ? -1 : 1);
            const randomY = Math.pow(Math.random(), this.config.randomnessPower) * 
                           this.config.randomness * (Math.random() < 0.5 ? -1 : 1);
            const randomZ = Math.pow(Math.random(), this.config.randomnessPower) * 
                           this.config.randomness * (Math.random() < 0.5 ? -1 : 1);
            
            x += randomX;
            y += randomY;
            z += randomZ;
            
            // Color interpolation from core to edge
            const colorMixRatio = radius / this.config.galaxyRadius;
            const color = this.config.insideColor.clone().lerp(this.config.outsideColor, colorMixRatio);
            
            points.push({
                position: new THREE.Vector3(x, y, z),
                color,
                radius,
                systemId: `system_${i}`,
                branch: i % this.config.branches
            });
        }
        
        return points;
    }
    
    // MANDATORY: Low-poly triangulation for performance and aesthetics
    public generateLowPolyMesh(points: GalaxyPoint[]): THREE.Mesh {
        if (!this.config.lowPolyMode) {
            return this.generatePointCloud(points);
        }
        
        // Project to 2D for Delaunay triangulation
        const points2D = points.map(p => [p.position.x, p.position.z]);
        
        // Create triangulation (using Delaunay algorithm)
        const triangulation = this.delaunayTriangulate(points2D);
        
        // Convert triangles back to 3D mesh
        const geometry = new THREE.BufferGeometry();
        const vertices: number[] = [];
        const colors: number[] = [];
        
        for (const triangle of triangulation) {
            // Add triangle vertices
            for (const pointIndex of triangle.indices) {
                const point = points[pointIndex];
                vertices.push(point.position.x, point.position.y, point.position.z);
                colors.push(point.color.r, point.color.g, point.color.b);
            }
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.computeVertexNormals();
        
        const material = new THREE.MeshLambertMaterial({
            vertexColors: true,
            flatShading: true,      // REQUIRED: Low-poly aesthetic
            transparent: true,
            opacity: 0.8
        });
        
        return new THREE.Mesh(geometry, material);
    }
    
    // MANDATORY: Multiple galaxy variants
    public generateVariant(variantSeed: number): GalaxyVariant {
        const seededRandom = this.createSeededRandom(variantSeed);
        
        return {
            branches: 2 + Math.floor(seededRandom() * 4),           // 2-6 arms
            spinFactor: -3 + seededRandom() * 6,                    // -3 to 3
            randomness: 0.1 + seededRandom() * 0.4,                 // 0.1 to 0.5
            insideColor: this.generateRandomColor(seededRandom, 'warm'),
            outsideColor: this.generateRandomColor(seededRandom, 'cool'),
            morphology: this.selectGalaxyType(seededRandom)         // Spiral, Elliptical, Irregular
        };
    }
}
```

### **Galaxy Visual Integration**
Ensure seamless integration with existing planet and UI systems:

```typescript
// MANDATORY: Consistent visual theme with planets
export class GalaxyVisualIntegrator {
    // Colors must match planet biome palettes
    private readonly GALAXY_PALETTES = {
        temperate: {
            inside: new THREE.Color(0x7cfc00),   // Bright green core
            outside: new THREE.Color(0x1e90ff)   // Blue edge (matches water)
        },
        volcanic: {
            inside: new THREE.Color(0xff4500),   // Orange red core
            outside: new THREE.Color(0x330000)   // Dark red edge
        },
        arctic: {
            inside: new THREE.Color(0xe8f4f8),   // Ice white core
            outside: new THREE.Color(0x40e0d0)   // Cyan edge
        },
        cosmic: {
            inside: new THREE.Color(0xffd700),   // Golden core
            outside: new THREE.Color(0x4b0082)   // Indigo edge
        }
    };
    
    // MANDATORY: Match galaxy generation with UI state
    public integrateWithMainMenu(galaxyRenderer: AdvancedGalaxyGenerator): void {
        // Use same themes as menu planet
        const menuPlanetBiome = MainMenuSystem.getCurrentPlanetBiome();
        const palette = this.GALAXY_PALETTES[menuPlanetBiome] || this.GALAXY_PALETTES.cosmic;
        
        galaxyRenderer.updateConfig({
            insideColor: palette.inside,
            outsideColor: palette.outside,
            lowPolyMode: true,           // Always low-poly for consistency
            starCount: this.getOptimalStarCount()
        });
    }
    
    // MANDATORY: Performance-based star count
    private getOptimalStarCount(): number {
        const performanceLevel = PerformanceMonitor.getCurrentQuality();
        const starCounts = {
            [QualityLevel.ULTRA]: 50000,
            [QualityLevel.HIGH]: 25000,
            [QualityLevel.MEDIUM]: 15000,
            [QualityLevel.LOW]: 8000,
            [QualityLevel.MINIMAL]: 3000
        };
        
        return starCounts[performanceLevel];
    }
}
```

### **Delaunay Triangulation Implementation**
```typescript
// MANDATORY: Efficient triangulation for low-poly aesthetics
export class DelaunayTriangulator {
    // Use Bowyer-Watson algorithm for consistent triangulation
    public triangulate(points: Point2D[]): Triangle[] {
        if (points.length < 3) return [];
        
        // Create super-triangle containing all points
        const superTriangle = this.createSuperTriangle(points);
        const triangles: Triangle[] = [superTriangle];
        
        // Add points one by one
        for (const point of points) {
            const badTriangles = this.findBadTriangles(point, triangles);
            const polygon = this.findHoleBoundary(badTriangles);
            
            // Remove bad triangles
            this.removeBadTriangles(badTriangles, triangles);
            
            // Add new triangles
            for (const edge of polygon) {
                const newTriangle = new Triangle(edge.start, edge.end, point);
                triangles.push(newTriangle);
            }
        }
        
        // Remove triangles containing super-triangle vertices
        return this.removeSuperTriangleReferences(triangles, superTriangle);
    }
    
    // MANDATORY: Optimize for performance
    private findBadTriangles(point: Point2D, triangles: Triangle[]): Triangle[] {
        return triangles.filter(triangle => 
            this.isPointInCircumcircle(point, triangle) && 
            this.isValidTriangle(triangle)
        );
    }
}
```

## 🌟 Star System Generation Rules

### **Hierarchical Generation**
Generate systems in proper hierarchy: Star → Planets → Moons → Surface Features

```typescript
// MANDATORY: Generate in proper order
public async generateStarSystem(systemId: string): Promise<StarSystem> {
    const system = new StarSystem(systemId);
    
    // 1. Generate central star first
    system.star = await this.generateStar(system.seed);
    
    // 2. Generate planets based on star type
    system.planets = await this.generatePlanets(system.star);
    
    // 3. Generate moons for appropriate planets
    for (const planet of system.planets) {
        if (planet.canHaveMoons()) {
            planet.moons = await this.generateMoons(planet);
        }
    }
    
    // 4. Generate surface features based on detail level
    if (system.detailLevel >= DetailLevel.MEDIUM) {
        await this.generateSurfaceFeatures(system);
    }
    
    return system;
}
```

### **Realistic Orbital Mechanics**
ALWAYS use physics-based orbital positioning:

```typescript
// MANDATORY: Use realistic orbital distances
private calculatePlanetPosition(starMass: number, planetIndex: number): THREE.Vector3 {
    // Titius-Bode law approximation for realistic spacing
    const baseDistance = 0.4 + (0.3 * Math.pow(2, planetIndex));
    const orbitRadius = baseDistance * this.orbitScaleFactor;
    
    // Add orbital eccentricity and inclination
    const eccentricity = this.random() * 0.2; // 0-20% eccentricity
    const inclination = (this.random() - 0.5) * 10; // ±5 degrees
    
    return this.calculateOrbitalPosition(orbitRadius, eccentricity, inclination);
}
```

## 🪐 Planet Generation Rules

### **Biome-Consistent Design**
ALL planets must use the integrated biome system for design consistency:

```typescript
// MANDATORY: Use biome-based generation
public async generatePlanet(config: PlanetConfig): Promise<Planet> {
    // Determine biome based on star type and orbital position
    const biome = this.calculateBiome(config.starType, config.orbitalDistance);
    
    // Use consistent biome configuration
    const biomeConfig = BiomeManager.getBiomeConfig(biome);
    
    // Generate planet with biome-appropriate features
    const planet = await this.createPlanetMesh(config.radius, biome);
    
    // Add biome-specific surface features
    await this.addSurfaceFeatures(planet, biomeConfig);
    
    return planet;
}

// MANDATORY: Consistent biome feature counts
private getBiomeFeatureCounts(biome: PlanetBiome): FeatureCounts {
    const baseConfig = {
        [PlanetBiome.TEMPERATE]: { trees: 15, rocks: 8, lakes: 3 },
        [PlanetBiome.TROPICAL]: { trees: 25, rocks: 5, lakes: 2 },
        [PlanetBiome.DESERT]: { trees: 2, rocks: 12, lakes: 0 },
        [PlanetBiome.ARCTIC]: { trees: 3, rocks: 8, lakes: 1 },
        [PlanetBiome.VOLCANIC]: { trees: 1, rocks: 15, lakes: 0 },
        [PlanetBiome.OCEAN]: { trees: 5, rocks: 3, lakes: 8 }
    };
    
    return baseConfig[biome] || baseConfig[PlanetBiome.TEMPERATE];
}
```

### **Detail Level Management**
Switch between planet rendering modes based on distance and performance:

```typescript
// MANDATORY: Support multiple detail levels
public async renderPlanet(config: PlanetRenderConfig): Promise<PlanetRenderResult> {
    switch (config.detailLevel) {
        case DetailLevel.LITTLE_PLANET:
            return await this.renderLittlePlanet(config);
            
        case DetailLevel.HIGH:
            return await this.renderDetailedPlanet(config);
            
        case DetailLevel.MEDIUM:
            return await this.renderStandardPlanet(config);
            
        case DetailLevel.LOW:
            return await this.renderSimplePlanet(config);
            
        case DetailLevel.MINIMAL:
            return await this.renderPointPlanet(config);
            
        default:
            return await this.renderStandardPlanet(config);
    }
}
```

## 🎨 Design Consistency Rules

### **Visual Theme Integration**
ALL generated content must follow the established visual theme:

```typescript
// MANDATORY: Use consistent material system
private getMaterialSystem(): MaterialSystem {
    return {
        // Low-poly aesthetic materials
        planetMaterials: {
            [PlanetBiome.TEMPERATE]: new THREE.MeshLambertMaterial({ 
                color: 0x4a7c59, 
                flatShading: true 
            }),
            [PlanetBiome.DESERT]: new THREE.MeshLambertMaterial({ 
                color: 0xd2b48c, 
                flatShading: true 
            })
            // ... other biomes
        },
        
        // Consistent feature materials
        featureMaterials: {
            trees: new THREE.MeshLambertMaterial({ color: 0x228b22, flatShading: true }),
            rocks: new THREE.MeshLambertMaterial({ color: 0x696969, flatShading: true }),
            water: new THREE.MeshLambertMaterial({ 
                color: 0x1e90ff, 
                transparent: true, 
                opacity: 0.8 
            })
        }
    };
}
```

### **Performance Budgets**
NEVER exceed performance budgets:

```typescript
// MANDATORY: Respect performance limits
private performanceBudgets = {
    maxTrianglesPerPlanet: {
        [DetailLevel.HIGH]: 5000,
        [DetailLevel.MEDIUM]: 1000,
        [DetailLevel.LOW]: 200,
        [DetailLevel.MINIMAL]: 20
    },
    maxFeaturesPerPlanet: {
        [DetailLevel.HIGH]: 100,
        [DetailLevel.MEDIUM]: 25,
        [DetailLevel.LOW]: 5,
        [DetailLevel.MINIMAL]: 0
    },
    maxGenerationTimeMs: 16 // One frame budget
};

// MANDATORY: Monitor and enforce budgets
private validatePerformanceBudget(planet: Planet): boolean {
    const triangleCount = this.countTriangles(planet);
    const budget = this.performanceBudgets.maxTrianglesPerPlanet[planet.detailLevel];
    
    if (triangleCount > budget) {
        console.warn(`🚨 [PERFORMANCE] Planet exceeds triangle budget: ${triangleCount}/${budget}`);
        return false;
    }
    
    return true;
}
```

## 🔄 Generation Lifecycle

### **Smart Cleanup**
Implement automatic cleanup to prevent memory leaks:

```typescript
// MANDATORY: Cleanup unused content
private performPeriodicCleanup(): void {
    const now = Date.now();
    const maxAge = 30000; // 30 seconds
    
    // Clean up old cache entries
    for (const [key, entry] of this.generationCache.entries()) {
        if (now - entry.lastAccessed > maxAge) {
            this.cleanupCacheEntry(key);
            this.generationCache.delete(key);
        }
    }
    
    // Dispose of distant planet geometries
    for (const system of this.starSystems.values()) {
        if (system.distanceFromCamera > this.lodDistances.low) {
            system.unloadDetailedGeometry();
        }
    }
}
```

### **Error Recovery**
Handle generation failures gracefully:

```typescript
// MANDATORY: Implement fallback generation
private async generateWithFallback<T>(
    generator: () => Promise<T>, 
    fallback: () => T,
    context: string
): Promise<T> {
    try {
        return await generator();
    } catch (error) {
        console.warn(`🔄 [GENERATION] ${context} failed, using fallback:`, error);
        return fallback();
    }
}
```

## 📊 Quality Assurance

### **Generation Validation**
ALWAYS validate generated content:

```typescript
// MANDATORY: Validate all generated content
private validateGeneration(system: StarSystem): ValidationResult {
    const errors: string[] = [];
    
    // Validate star
    if (!system.star || system.star.mass <= 0) {
        errors.push("Invalid star configuration");
    }
    
    // Validate planets
    for (const planet of system.planets) {
        if (planet.radius <= 0) {
            errors.push(`Invalid planet radius: ${planet.radius}`);
        }
        
        if (!this.isValidBiome(planet.biome)) {
            errors.push(`Invalid biome: ${planet.biome}`);
        }
    }
    
    return {
        isValid: errors.length === 0,
        errors
    };
}
```

This rule ensures that all galaxy, solar system, and planet generation follows consistent patterns, maintains optimal performance, and creates a cohesive visual experience throughout the game.
description:
globs:
alwaysApply: true
---
 
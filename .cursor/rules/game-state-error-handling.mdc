---
alwaysApply: true
---

# Game State Error Handling

Comprehensive error handling for game state management, save/load operations, player data, and world state integrity.

## Game State Error Categories

```typescript
enum GameStateErrorType {
    SAVE_CORRUPTION = "SAVE_CORRUPTION",
    LOAD_FAILURE = "LOAD_FAILURE",
    STATE_DESYNC = "STATE_DESYNC", 
    DATA_VALIDATION = "DATA_VALIDATION",
    PERSISTENCE_FAILURE = "PERSISTENCE_FAILURE",
    WORLD_STATE_INVALID = "WORLD_STATE_INVALID",
    PLAYER_DATA_CORRUPT = "PLAYER_DATA_CORRUPT",
    INVENTORY_MISMATCH = "INVENTORY_MISMATCH",
    PROGRESS_ROLLBACK = "PROGRESS_ROLLBACK"
}

enum GameStateErrorSeverity {
    DATA_LOSS = "DATA_LOSS",          // Potential permanent data loss
    CORRUPTION_DETECTED = "CORRUPTION_DETECTED", // Data integrity compromised  
    SYNC_FAILURE = "SYNC_FAILURE",    // State synchronization failed
    MINOR_INCONSISTENCY = "MINOR_INCONSISTENCY" // Small data inconsistencies
}
```

## Save/Load Error Handling

All save and load operations MUST implement validation and recovery:

```typescript
class GameStateManager {
    private maxBackups = 5;
    private validationChecks: ((state: GameState) => boolean)[] = [];
    private saveRetryAttempts = 3;
    private loadFallbackChain: string[] = [];

    public async saveGameState(state: GameState): Promise<void> {
        const startTime = performance.now();
        let attempts = 0;
        
        try {
            while (attempts < this.saveRetryAttempts) {
                attempts++;
                
                // Validate state before saving
                this.validateGameState(state);
                
                // Create backup of current save
                await this.createBackup();
                
                // Attempt save with integrity checks
                const saveData = this.serializeGameState(state);
                const checksum = this.calculateChecksum(saveData);
                
                await this.writeToStorage(saveData, checksum);
                
                // Verify save integrity
                const verification = await this.verifySaveIntegrity(checksum);
                if (verification.isValid) {
                    const duration = performance.now() - startTime;
                    if (attempts > 1) {
                        console.warn(`💾 [STATE:MEDIUM] Save required ${attempts} attempts:
                            Duration: ${duration.toFixed(2)}ms
                            State Size: ${JSON.stringify(saveData).length} bytes
                            Checksum: ${checksum.substring(0, 8)}...`);
                    }
                    return;
                }
                
                console.warn(`💾 [STATE:MEDIUM] Save verification failed on attempt ${attempts}, retrying...`);
            }
            
            throw new Error(`Failed to save game state after ${attempts} attempts`);
            
        } catch (error) {
            this.handleSaveError(error, state, startTime, attempts);
        }
    }

    private handleSaveError(error: Error, state: GameState, startTime: number, attempts: number): void {
        const duration = performance.now() - startTime;
        
        console.error(`💾 [STATE:HIGH] Game state save failed:
            ❌ Error: ${error.message}
            🎮 Player: ${state.playerId}
            📊 State: ${this.summarizeGameState(state)}
            🔄 Attempts: ${attempts}/${this.saveRetryAttempts}
            ⏱️ Duration: ${duration.toFixed(2)}ms
            💽 Storage: ${this.getStorageInfo()}
            🛡️ Fallback: Creating emergency backup...`);
        
        // Execute emergency backup
        this.createEmergencyBackup(state);
    }

    public async loadGameState(playerId: string): Promise<GameState> {
        const startTime = performance.now();
        
        try {
            // Build fallback chain: main save -> backups -> defaults
            this.buildLoadFallbackChain(playerId);
            
            for (const saveFile of this.loadFallbackChain) {
                try {
                    const gameState = await this.attemptLoad(saveFile);
                    
                    // Validate loaded state
                    this.validateGameState(gameState);
                    
                    // Check for corruption indicators
                    const corruptionCheck = this.checkForCorruption(gameState);
                    if (corruptionCheck.hasCorruption) {
                        console.warn(`💾 [STATE:MEDIUM] Corruption detected in ${saveFile}:
                            Issues: ${corruptionCheck.issues.join(', ')}
                            Severity: ${corruptionCheck.severity}
                            Continuing to next fallback...`);
                        continue;
                    }
                    
                    // Successful load
                    const duration = performance.now() - startTime;
                    if (saveFile !== this.loadFallbackChain[0]) {
                        console.warn(`💾 [STATE:HIGH] Loaded from fallback: ${saveFile} (${duration.toFixed(2)}ms)`);
                    }
                    
                    return gameState;
                    
                } catch (loadError) {
                    console.warn(`💾 [STATE:MEDIUM] Failed to load ${saveFile}: ${loadError.message}`);
                    continue;
                }
            }
            
            throw new Error('All load attempts failed - no valid save data found');
            
        } catch (error) {
            return this.handleLoadError(error, playerId, startTime);
        }
    }

    private handleLoadError(error: Error, playerId: string, startTime: number): GameState {
        const duration = performance.now() - startTime;
        
        console.error(`💾 [STATE:CRITICAL] Game state load completely failed:
            ❌ Error: ${error.message}
            🎮 Player: ${playerId}
            📁 Fallback Chain: ${this.loadFallbackChain.join(' -> ')}
            ⏱️ Duration: ${duration.toFixed(2)}ms
            💽 Storage Available: ${this.checkStorageAvailability()}
            🛡️ Fallback: Creating new game state...`);
        
        // Ultimate fallback: create new game state
        return this.createNewGameState(playerId);
    }

    private validateGameState(state: GameState): void {
        if (!state || typeof state !== 'object') {
            throw new Error('Invalid game state object');
        }
        
        if (!state.playerId || !state.timestamp) {
            throw new Error('Missing required game state fields');
        }
        
        // Check state version compatibility
        if (!this.isVersionCompatible(state.version)) {
            throw new Error(`Incompatible save version: ${state.version}`);
        }
        
        // Run custom validation checks
        for (const validator of this.validationChecks) {
            if (!validator(state)) {
                throw new Error('Game state failed custom validation');
            }
        }
        
        // Validate critical game data
        this.validatePlayerData(state.player);
        this.validateWorldData(state.world);
        this.validateInventoryData(state.inventory);
    }

    private validatePlayerData(player: PlayerData): void {
        if (!player) throw new Error('Missing player data');
        
        if (player.level < 1 || player.level > 1000) {
            throw new Error(`Invalid player level: ${player.level}`);
        }
        
        if (player.experience < 0) {
            throw new Error(`Invalid experience: ${player.experience}`);
        }
        
        if (!player.position || !this.isValidPosition(player.position)) {
            throw new Error('Invalid player position');
        }
    }

    private validateWorldData(world: WorldData): void {
        if (!world) throw new Error('Missing world data');
        
        if (!world.seed || world.seed <= 0) {
            throw new Error(`Invalid world seed: ${world.seed}`);
        }
        
        if (!world.systems || !Array.isArray(world.systems)) {
            throw new Error('Invalid solar systems data');
        }
        
        // Validate each solar system
        for (const system of world.systems) {
            this.validateSolarSystem(system);
        }
    }

    private validateInventoryData(inventory: InventoryData): void {
        if (!inventory) throw new Error('Missing inventory data');
        
        if (!inventory.items || !Array.isArray(inventory.items)) {
            throw new Error('Invalid inventory items');
        }
        
        // Check for duplicate items
        const itemIds = inventory.items.map(item => item.id);
        if (new Set(itemIds).size !== itemIds.length) {
            throw new Error('Duplicate items detected in inventory');
        }
        
        // Validate item quantities
        for (const item of inventory.items) {
            if (item.quantity < 0 || item.quantity > 999999) {
                throw new Error(`Invalid item quantity: ${item.quantity} for item ${item.id}`);
            }
        }
    }

    private checkForCorruption(state: GameState): CorruptionReport {
        const issues: string[] = [];
        let severity: GameStateErrorSeverity = GameStateErrorSeverity.MINOR_INCONSISTENCY;
        
        // Check for data inconsistencies
        if (state.player.experience > this.getMaxExperienceForLevel(state.player.level)) {
            issues.push('Experience exceeds level requirement');
            severity = GameStateErrorSeverity.CORRUPTION_DETECTED;
        }
        
        // Check inventory weight vs capacity
        const totalWeight = this.calculateInventoryWeight(state.inventory);
        if (totalWeight > state.player.carryCapacity * 1.5) {
            issues.push('Inventory weight exceeds capacity');
            severity = GameStateErrorSeverity.CORRUPTION_DETECTED;
        }
        
        // Check world consistency
        const worldIssues = this.validateWorldConsistency(state.world);
        if (worldIssues.length > 0) {
            issues.push(...worldIssues);
            severity = GameStateErrorSeverity.CORRUPTION_DETECTED;
        }
        
        // Check for impossible timestamps
        if (state.timestamp > Date.now() + 86400000) { // 24 hours in future
            issues.push('Future timestamp detected');
            severity = GameStateErrorSeverity.CORRUPTION_DETECTED;
        }
        
        return {
            hasCorruption: issues.length > 0,
            issues,
            severity
        };
    }

    private createEmergencyBackup(state: GameState): void {
        try {
            const emergencyData = {
                ...state,
                isEmergencyBackup: true,
                emergencyTimestamp: Date.now()
            };
            
            const backupKey = `emergency_${state.playerId}_${Date.now()}`;
            localStorage.setItem(backupKey, JSON.stringify(emergencyData));
            
            console.warn(`💾 [STATE:HIGH] Emergency backup created: ${backupKey}`);
        } catch (error) {
            console.error(`💾 [STATE:CRITICAL] Emergency backup failed: ${error.message}`);
        }
    }

    private createNewGameState(playerId: string): GameState {
        return {
            playerId,
            version: this.getCurrentSaveVersion(),
            timestamp: Date.now(),
            player: this.createDefaultPlayer(),
            world: this.createDefaultWorld(),
            inventory: this.createDefaultInventory(),
            isNewGame: true
        };
    }
}
```

## State Synchronization Error Handling

Handle multiplayer state synchronization with conflict resolution:

```typescript
class StateSynchronizationManager {
    private syncTimeout = 5000; // ms
    private maxSyncRetries = 3;
    private conflictResolutionStrategies = new Map<string, ConflictResolver>();

    public async synchronizeState(localState: GameState, remoteState: GameState): Promise<GameState> {
        const startTime = performance.now();
        
        try {
            // Detect conflicts
            const conflicts = this.detectStateConflicts(localState, remoteState);
            
            if (conflicts.length === 0) {
                // No conflicts, merge states
                return this.mergeStates(localState, remoteState);
            }
            
            // Resolve conflicts
            const resolvedState = await this.resolveConflicts(localState, remoteState, conflicts);
            
            // Validate resolved state
            this.validateResolvedState(resolvedState, localState, remoteState);
            
            const duration = performance.now() - startTime;
            console.log(`🔄 [STATE:DEBUG] State synchronized: ${conflicts.length} conflicts resolved (${duration.toFixed(2)}ms)`);
            
            return resolvedState;
            
        } catch (error) {
            return this.handleSyncError(error, localState, remoteState, startTime);
        }
    }

    private detectStateConflicts(local: GameState, remote: GameState): StateConflict[] {
        const conflicts: StateConflict[] = [];
        
        // Check timestamp conflicts
        if (Math.abs(local.timestamp - remote.timestamp) > 60000) { // 1 minute
            conflicts.push({
                type: 'TIMESTAMP_MISMATCH',
                field: 'timestamp',
                localValue: local.timestamp,
                remoteValue: remote.timestamp,
                severity: 'HIGH'
            });
        }
        
        // Check player data conflicts
        if (local.player.level !== remote.player.level) {
            conflicts.push({
                type: 'PLAYER_LEVEL_CONFLICT',
                field: 'player.level',
                localValue: local.player.level,
                remoteValue: remote.player.level,
                severity: 'MEDIUM'
            });
        }
        
        // Check inventory conflicts
        const inventoryConflicts = this.detectInventoryConflicts(local.inventory, remote.inventory);
        conflicts.push(...inventoryConflicts);
        
        return conflicts;
    }

    private async resolveConflicts(local: GameState, remote: GameState, conflicts: StateConflict[]): Promise<GameState> {
        let resolvedState = { ...local };
        
        for (const conflict of conflicts) {
            const resolver = this.conflictResolutionStrategies.get(conflict.type);
            if (!resolver) {
                console.warn(`🔄 [STATE:MEDIUM] No resolver for conflict type: ${conflict.type}, using default`);
                resolvedState = this.applyDefaultResolution(resolvedState, conflict, remote);
                continue;
            }
            
            try {
                const resolution = await resolver.resolve(conflict, local, remote);
                resolvedState = this.applyResolution(resolvedState, resolution);
            } catch (error) {
                console.error(`🔄 [STATE:HIGH] Conflict resolution failed for ${conflict.type}: ${error.message}`);
                resolvedState = this.applyDefaultResolution(resolvedState, conflict, remote);
            }
        }
        
        return resolvedState;
    }

    private handleSyncError(error: Error, local: GameState, remote: GameState, startTime: number): GameState {
        const duration = performance.now() - startTime;
        
        console.error(`🔄 [STATE:CRITICAL] State synchronization failed:
            ❌ Error: ${error.message}
            🎮 Player: ${local.playerId}
            📊 Local: ${this.summarizeGameState(local)}
            🌐 Remote: ${this.summarizeGameState(remote)}
            ⏱️ Duration: ${duration.toFixed(2)}ms
            🛡️ Fallback: Using local state with conflict markers...`);
        
        // Fallback: use local state but mark as having sync issues
        return {
            ...local,
            hasSyncIssues: true,
            lastSyncError: error.message,
            lastSyncAttempt: Date.now()
        };
    }
}
```

## Data Recovery and Rollback

Implement automatic data recovery and rollback mechanisms:

```typescript
class DataRecoveryManager {
    private maxRecoveryAttempts = 5;
    private rollbackPoints: RollbackPoint[] = [];
    private recoveryStrategies: RecoveryStrategy[] = [];

    public async recoverCorruptedData(corruptedState: GameState): Promise<GameState> {
        console.warn(`🔧 [STATE:HIGH] Attempting data recovery for player ${corruptedState.playerId}...`);
        
        for (let attempt = 1; attempt <= this.maxRecoveryAttempts; attempt++) {
            try {
                // Try different recovery strategies
                for (const strategy of this.recoveryStrategies) {
                    const recoveredState = await strategy.recover(corruptedState);
                    
                    if (this.validateRecoveredState(recoveredState)) {
                        console.log(`🔧 [STATE:MEDIUM] Data recovered using strategy: ${strategy.name} (attempt ${attempt})`);
                        return recoveredState;
                    }
                }
                
                // If strategies fail, try rollback to previous point
                const rollbackState = await this.rollbackToLastValidState(corruptedState.playerId);
                if (rollbackState) {
                    return rollbackState;
                }
                
            } catch (error) {
                console.warn(`🔧 [STATE:MEDIUM] Recovery attempt ${attempt} failed: ${error.message}`);
            }
        }
        
        throw new Error('All data recovery attempts failed');
    }

    private async rollbackToLastValidState(playerId: string): Promise<GameState | null> {
        const validRollbacks = this.rollbackPoints
            .filter(point => point.playerId === playerId && point.isValid)
            .sort((a, b) => b.timestamp - a.timestamp);
        
        for (const rollback of validRollbacks) {
            try {
                const state = await this.loadRollbackPoint(rollback);
                if (this.validateRecoveredState(state)) {
                    console.warn(`🔧 [STATE:HIGH] Rolled back to checkpoint: ${new Date(rollback.timestamp).toISOString()}`);
                    return state;
                }
            } catch (error) {
                console.warn(`🔧 [STATE:MEDIUM] Rollback point corrupted: ${rollback.id}`);
                rollback.isValid = false;
            }
        }
        
        return null;
    }

    public createRollbackPoint(state: GameState, reason: string): void {
        try {
            const rollbackPoint: RollbackPoint = {
                id: crypto.randomUUID(),
                playerId: state.playerId,
                timestamp: Date.now(),
                reason,
                checksum: this.calculateStateChecksum(state),
                isValid: true
            };
            
            // Store rollback data
            this.storeRollbackData(rollbackPoint, state);
            this.rollbackPoints.push(rollbackPoint);
            
            // Cleanup old rollback points
            this.cleanupOldRollbacks(state.playerId);
            
        } catch (error) {
            console.error(`🔧 [STATE:MEDIUM] Failed to create rollback point: ${error.message}`);
        }
    }
}
```

## Game State Performance Monitoring

Monitor game state operations for performance and integrity:

```typescript
class GameStateMonitor {
    private stateMetrics = new Map<string, StateMetrics>();
    private performanceThresholds = {
        saveTime: 1000, // ms
        loadTime: 2000, // ms
        syncTime: 500,  // ms
        stateSize: 1024 * 1024 // 1MB
    };

    public monitorStateOperation(operation: string, duration: number, dataSize: number, playerId: string): void {
        const metrics = this.getOrCreateMetrics(playerId);
        
        // Update metrics
        metrics.operations.push({
            type: operation,
            duration,
            dataSize,
            timestamp: Date.now()
        });
        
        // Keep only recent operations
        if (metrics.operations.length > 100) {
            metrics.operations.shift();
        }
        
        // Check for performance issues
        this.checkPerformanceThresholds(operation, duration, dataSize, playerId);
        
        // Update averages
        this.updateMetricsAverages(metrics);
    }

    private checkPerformanceThresholds(operation: string, duration: number, dataSize: number, playerId: string): void {
        const issues: string[] = [];
        
        if (operation === 'save' && duration > this.performanceThresholds.saveTime) {
            issues.push(`Slow save operation: ${duration}ms`);
        }
        
        if (operation === 'load' && duration > this.performanceThresholds.loadTime) {
            issues.push(`Slow load operation: ${duration}ms`);
        }
        
        if (dataSize > this.performanceThresholds.stateSize) {
            issues.push(`Large state size: ${(dataSize / 1024 / 1024).toFixed(2)}MB`);
        }
        
        if (issues.length > 0) {
            console.warn(`💾 [STATE:PERFORMANCE] Performance issues detected:
                Player: ${playerId}
                Operation: ${operation}
                Issues: ${issues.join(', ')}
                Duration: ${duration}ms
                Size: ${(dataSize / 1024).toFixed(2)}KB
                Action: ${this.getOptimizationSuggestion(operation, issues)}`);
        }
    }

    private getOptimizationSuggestion(operation: string, issues: string[]): string {
        if (issues.some(i => i.includes('Large state'))) {
            return 'Consider state compression or data pruning';
        }
        
        if (issues.some(i => i.includes('Slow'))) {
            return 'Optimize serialization or storage method';
        }
        
        return 'Monitor continued performance';
    }
}
```

This comprehensive game state error handling system ensures data integrity, provides robust recovery mechanisms, and maintains optimal performance for save/load operations with detailed monitoring and fallback strategies.
# Game State Error Handling

Comprehensive error handling for game state management, save/load operations, player data, and world state integrity.

## Game State Error Categories

```typescript
enum GameStateErrorType {
    SAVE_CORRUPTION = "SAVE_CORRUPTION",
    LOAD_FAILURE = "LOAD_FAILURE",
    STATE_DESYNC = "STATE_DESYNC", 
    DATA_VALIDATION = "DATA_VALIDATION",
    PERSISTENCE_FAILURE = "PERSISTENCE_FAILURE",
    WORLD_STATE_INVALID = "WORLD_STATE_INVALID",
    PLAYER_DATA_CORRUPT = "PLAYER_DATA_CORRUPT",
    INVENTORY_MISMATCH = "INVENTORY_MISMATCH",
    PROGRESS_ROLLBACK = "PROGRESS_ROLLBACK"
}

enum GameStateErrorSeverity {
    DATA_LOSS = "DATA_LOSS",          // Potential permanent data loss
    CORRUPTION_DETECTED = "CORRUPTION_DETECTED", // Data integrity compromised  
    SYNC_FAILURE = "SYNC_FAILURE",    // State synchronization failed
    MINOR_INCONSISTENCY = "MINOR_INCONSISTENCY" // Small data inconsistencies
}
```

## Save/Load Error Handling

All save and load operations MUST implement validation and recovery:

```typescript
class GameStateManager {
    private maxBackups = 5;
    private validationChecks: ((state: GameState) => boolean)[] = [];
    private saveRetryAttempts = 3;
    private loadFallbackChain: string[] = [];

    public async saveGameState(state: GameState): Promise<void> {
        const startTime = performance.now();
        let attempts = 0;
        
        try {
            while (attempts < this.saveRetryAttempts) {
                attempts++;
                
                // Validate state before saving
                this.validateGameState(state);
                
                // Create backup of current save
                await this.createBackup();
                
                // Attempt save with integrity checks
                const saveData = this.serializeGameState(state);
                const checksum = this.calculateChecksum(saveData);
                
                await this.writeToStorage(saveData, checksum);
                
                // Verify save integrity
                const verification = await this.verifySaveIntegrity(checksum);
                if (verification.isValid) {
                    const duration = performance.now() - startTime;
                    if (attempts > 1) {
                        console.warn(`💾 [STATE:MEDIUM] Save required ${attempts} attempts:
                            Duration: ${duration.toFixed(2)}ms
                            State Size: ${JSON.stringify(saveData).length} bytes
                            Checksum: ${checksum.substring(0, 8)}...`);
                    }
                    return;
                }
                
                console.warn(`💾 [STATE:MEDIUM] Save verification failed on attempt ${attempts}, retrying...`);
            }
            
            throw new Error(`Failed to save game state after ${attempts} attempts`);
            
        } catch (error) {
            this.handleSaveError(error, state, startTime, attempts);
        }
    }

    private handleSaveError(error: Error, state: GameState, startTime: number, attempts: number): void {
        const duration = performance.now() - startTime;
        
        console.error(`💾 [STATE:HIGH] Game state save failed:
            ❌ Error: ${error.message}
            🎮 Player: ${state.playerId}
            📊 State: ${this.summarizeGameState(state)}
            🔄 Attempts: ${attempts}/${this.saveRetryAttempts}
            ⏱️ Duration: ${duration.toFixed(2)}ms
            💽 Storage: ${this.getStorageInfo()}
            🛡️ Fallback: Creating emergency backup...`);
        
        // Execute emergency backup
        this.createEmergencyBackup(state);
    }

    public async loadGameState(playerId: string): Promise<GameState> {
        const startTime = performance.now();
        
        try {
            // Build fallback chain: main save -> backups -> defaults
            this.buildLoadFallbackChain(playerId);
            
            for (const saveFile of this.loadFallbackChain) {
                try {
                    const gameState = await this.attemptLoad(saveFile);
                    
                    // Validate loaded state
                    this.validateGameState(gameState);
                    
                    // Check for corruption indicators
                    const corruptionCheck = this.checkForCorruption(gameState);
                    if (corruptionCheck.hasCorruption) {
                        console.warn(`💾 [STATE:MEDIUM] Corruption detected in ${saveFile}:
                            Issues: ${corruptionCheck.issues.join(', ')}
                            Severity: ${corruptionCheck.severity}
                            Continuing to next fallback...`);
                        continue;
                    }
                    
                    // Successful load
                    const duration = performance.now() - startTime;
                    if (saveFile !== this.loadFallbackChain[0]) {
                        console.warn(`💾 [STATE:HIGH] Loaded from fallback: ${saveFile} (${duration.toFixed(2)}ms)`);
                    }
                    
                    return gameState;
                    
                } catch (loadError) {
                    console.warn(`💾 [STATE:MEDIUM] Failed to load ${saveFile}: ${loadError.message}`);
                    continue;
                }
            }
            
            throw new Error('All load attempts failed - no valid save data found');
            
        } catch (error) {
            return this.handleLoadError(error, playerId, startTime);
        }
    }

    private handleLoadError(error: Error, playerId: string, startTime: number): GameState {
        const duration = performance.now() - startTime;
        
        console.error(`💾 [STATE:CRITICAL] Game state load completely failed:
            ❌ Error: ${error.message}
            🎮 Player: ${playerId}
            📁 Fallback Chain: ${this.loadFallbackChain.join(' -> ')}
            ⏱️ Duration: ${duration.toFixed(2)}ms
            💽 Storage Available: ${this.checkStorageAvailability()}
            🛡️ Fallback: Creating new game state...`);
        
        // Ultimate fallback: create new game state
        return this.createNewGameState(playerId);
    }

    private validateGameState(state: GameState): void {
        if (!state || typeof state !== 'object') {
            throw new Error('Invalid game state object');
        }
        
        if (!state.playerId || !state.timestamp) {
            throw new Error('Missing required game state fields');
        }
        
        // Check state version compatibility
        if (!this.isVersionCompatible(state.version)) {
            throw new Error(`Incompatible save version: ${state.version}`);
        }
        
        // Run custom validation checks
        for (const validator of this.validationChecks) {
            if (!validator(state)) {
                throw new Error('Game state failed custom validation');
            }
        }
        
        // Validate critical game data
        this.validatePlayerData(state.player);
        this.validateWorldData(state.world);
        this.validateInventoryData(state.inventory);
    }

    private validatePlayerData(player: PlayerData): void {
        if (!player) throw new Error('Missing player data');
        
        if (player.level < 1 || player.level > 1000) {
            throw new Error(`Invalid player level: ${player.level}`);
        }
        
        if (player.experience < 0) {
            throw new Error(`Invalid experience: ${player.experience}`);
        }
        
        if (!player.position || !this.isValidPosition(player.position)) {
            throw new Error('Invalid player position');
        }
    }

    private validateWorldData(world: WorldData): void {
        if (!world) throw new Error('Missing world data');
        
        if (!world.seed || world.seed <= 0) {
            throw new Error(`Invalid world seed: ${world.seed}`);
        }
        
        if (!world.systems || !Array.isArray(world.systems)) {
            throw new Error('Invalid solar systems data');
        }
        
        // Validate each solar system
        for (const system of world.systems) {
            this.validateSolarSystem(system);
        }
    }

    private validateInventoryData(inventory: InventoryData): void {
        if (!inventory) throw new Error('Missing inventory data');
        
        if (!inventory.items || !Array.isArray(inventory.items)) {
            throw new Error('Invalid inventory items');
        }
        
        // Check for duplicate items
        const itemIds = inventory.items.map(item => item.id);
        if (new Set(itemIds).size !== itemIds.length) {
            throw new Error('Duplicate items detected in inventory');
        }
        
        // Validate item quantities
        for (const item of inventory.items) {
            if (item.quantity < 0 || item.quantity > 999999) {
                throw new Error(`Invalid item quantity: ${item.quantity} for item ${item.id}`);
            }
        }
    }

    private checkForCorruption(state: GameState): CorruptionReport {
        const issues: string[] = [];
        let severity: GameStateErrorSeverity = GameStateErrorSeverity.MINOR_INCONSISTENCY;
        
        // Check for data inconsistencies
        if (state.player.experience > this.getMaxExperienceForLevel(state.player.level)) {
            issues.push('Experience exceeds level requirement');
            severity = GameStateErrorSeverity.CORRUPTION_DETECTED;
        }
        
        // Check inventory weight vs capacity
        const totalWeight = this.calculateInventoryWeight(state.inventory);
        if (totalWeight > state.player.carryCapacity * 1.5) {
            issues.push('Inventory weight exceeds capacity');
            severity = GameStateErrorSeverity.CORRUPTION_DETECTED;
        }
        
        // Check world consistency
        const worldIssues = this.validateWorldConsistency(state.world);
        if (worldIssues.length > 0) {
            issues.push(...worldIssues);
            severity = GameStateErrorSeverity.CORRUPTION_DETECTED;
        }
        
        // Check for impossible timestamps
        if (state.timestamp > Date.now() + 86400000) { // 24 hours in future
            issues.push('Future timestamp detected');
            severity = GameStateErrorSeverity.CORRUPTION_DETECTED;
        }
        
        return {
            hasCorruption: issues.length > 0,
            issues,
            severity
        };
    }

    private createEmergencyBackup(state: GameState): void {
        try {
            const emergencyData = {
                ...state,
                isEmergencyBackup: true,
                emergencyTimestamp: Date.now()
            };
            
            const backupKey = `emergency_${state.playerId}_${Date.now()}`;
            localStorage.setItem(backupKey, JSON.stringify(emergencyData));
            
            console.warn(`💾 [STATE:HIGH] Emergency backup created: ${backupKey}`);
        } catch (error) {
            console.error(`💾 [STATE:CRITICAL] Emergency backup failed: ${error.message}`);
        }
    }

    private createNewGameState(playerId: string): GameState {
        return {
            playerId,
            version: this.getCurrentSaveVersion(),
            timestamp: Date.now(),
            player: this.createDefaultPlayer(),
            world: this.createDefaultWorld(),
            inventory: this.createDefaultInventory(),
            isNewGame: true
        };
    }
}
```

## State Synchronization Error Handling

Handle multiplayer state synchronization with conflict resolution:

```typescript
class StateSynchronizationManager {
    private syncTimeout = 5000; // ms
    private maxSyncRetries = 3;
    private conflictResolutionStrategies = new Map<string, ConflictResolver>();

    public async synchronizeState(localState: GameState, remoteState: GameState): Promise<GameState> {
        const startTime = performance.now();
        
        try {
            // Detect conflicts
            const conflicts = this.detectStateConflicts(localState, remoteState);
            
            if (conflicts.length === 0) {
                // No conflicts, merge states
                return this.mergeStates(localState, remoteState);
            }
            
            // Resolve conflicts
            const resolvedState = await this.resolveConflicts(localState, remoteState, conflicts);
            
            // Validate resolved state
            this.validateResolvedState(resolvedState, localState, remoteState);
            
            const duration = performance.now() - startTime;
            console.log(`🔄 [STATE:DEBUG] State synchronized: ${conflicts.length} conflicts resolved (${duration.toFixed(2)}ms)`);
            
            return resolvedState;
            
        } catch (error) {
            return this.handleSyncError(error, localState, remoteState, startTime);
        }
    }

    private detectStateConflicts(local: GameState, remote: GameState): StateConflict[] {
        const conflicts: StateConflict[] = [];
        
        // Check timestamp conflicts
        if (Math.abs(local.timestamp - remote.timestamp) > 60000) { // 1 minute
            conflicts.push({
                type: 'TIMESTAMP_MISMATCH',
                field: 'timestamp',
                localValue: local.timestamp,
                remoteValue: remote.timestamp,
                severity: 'HIGH'
            });
        }
        
        // Check player data conflicts
        if (local.player.level !== remote.player.level) {
            conflicts.push({
                type: 'PLAYER_LEVEL_CONFLICT',
                field: 'player.level',
                localValue: local.player.level,
                remoteValue: remote.player.level,
                severity: 'MEDIUM'
            });
        }
        
        // Check inventory conflicts
        const inventoryConflicts = this.detectInventoryConflicts(local.inventory, remote.inventory);
        conflicts.push(...inventoryConflicts);
        
        return conflicts;
    }

    private async resolveConflicts(local: GameState, remote: GameState, conflicts: StateConflict[]): Promise<GameState> {
        let resolvedState = { ...local };
        
        for (const conflict of conflicts) {
            const resolver = this.conflictResolutionStrategies.get(conflict.type);
            if (!resolver) {
                console.warn(`🔄 [STATE:MEDIUM] No resolver for conflict type: ${conflict.type}, using default`);
                resolvedState = this.applyDefaultResolution(resolvedState, conflict, remote);
                continue;
            }
            
            try {
                const resolution = await resolver.resolve(conflict, local, remote);
                resolvedState = this.applyResolution(resolvedState, resolution);
            } catch (error) {
                console.error(`🔄 [STATE:HIGH] Conflict resolution failed for ${conflict.type}: ${error.message}`);
                resolvedState = this.applyDefaultResolution(resolvedState, conflict, remote);
            }
        }
        
        return resolvedState;
    }

    private handleSyncError(error: Error, local: GameState, remote: GameState, startTime: number): GameState {
        const duration = performance.now() - startTime;
        
        console.error(`🔄 [STATE:CRITICAL] State synchronization failed:
            ❌ Error: ${error.message}
            🎮 Player: ${local.playerId}
            📊 Local: ${this.summarizeGameState(local)}
            🌐 Remote: ${this.summarizeGameState(remote)}
            ⏱️ Duration: ${duration.toFixed(2)}ms
            🛡️ Fallback: Using local state with conflict markers...`);
        
        // Fallback: use local state but mark as having sync issues
        return {
            ...local,
            hasSyncIssues: true,
            lastSyncError: error.message,
            lastSyncAttempt: Date.now()
        };
    }
}
```

## Data Recovery and Rollback

Implement automatic data recovery and rollback mechanisms:

```typescript
class DataRecoveryManager {
    private maxRecoveryAttempts = 5;
    private rollbackPoints: RollbackPoint[] = [];
    private recoveryStrategies: RecoveryStrategy[] = [];

    public async recoverCorruptedData(corruptedState: GameState): Promise<GameState> {
        console.warn(`🔧 [STATE:HIGH] Attempting data recovery for player ${corruptedState.playerId}...`);
        
        for (let attempt = 1; attempt <= this.maxRecoveryAttempts; attempt++) {
            try {
                // Try different recovery strategies
                for (const strategy of this.recoveryStrategies) {
                    const recoveredState = await strategy.recover(corruptedState);
                    
                    if (this.validateRecoveredState(recoveredState)) {
                        console.log(`🔧 [STATE:MEDIUM] Data recovered using strategy: ${strategy.name} (attempt ${attempt})`);
                        return recoveredState;
                    }
                }
                
                // If strategies fail, try rollback to previous point
                const rollbackState = await this.rollbackToLastValidState(corruptedState.playerId);
                if (rollbackState) {
                    return rollbackState;
                }
                
            } catch (error) {
                console.warn(`🔧 [STATE:MEDIUM] Recovery attempt ${attempt} failed: ${error.message}`);
            }
        }
        
        throw new Error('All data recovery attempts failed');
    }

    private async rollbackToLastValidState(playerId: string): Promise<GameState | null> {
        const validRollbacks = this.rollbackPoints
            .filter(point => point.playerId === playerId && point.isValid)
            .sort((a, b) => b.timestamp - a.timestamp);
        
        for (const rollback of validRollbacks) {
            try {
                const state = await this.loadRollbackPoint(rollback);
                if (this.validateRecoveredState(state)) {
                    console.warn(`🔧 [STATE:HIGH] Rolled back to checkpoint: ${new Date(rollback.timestamp).toISOString()}`);
                    return state;
                }
            } catch (error) {
                console.warn(`🔧 [STATE:MEDIUM] Rollback point corrupted: ${rollback.id}`);
                rollback.isValid = false;
            }
        }
        
        return null;
    }

    public createRollbackPoint(state: GameState, reason: string): void {
        try {
            const rollbackPoint: RollbackPoint = {
                id: crypto.randomUUID(),
                playerId: state.playerId,
                timestamp: Date.now(),
                reason,
                checksum: this.calculateStateChecksum(state),
                isValid: true
            };
            
            // Store rollback data
            this.storeRollbackData(rollbackPoint, state);
            this.rollbackPoints.push(rollbackPoint);
            
            // Cleanup old rollback points
            this.cleanupOldRollbacks(state.playerId);
            
        } catch (error) {
            console.error(`🔧 [STATE:MEDIUM] Failed to create rollback point: ${error.message}`);
        }
    }
}
```

## Game State Performance Monitoring

Monitor game state operations for performance and integrity:

```typescript
class GameStateMonitor {
    private stateMetrics = new Map<string, StateMetrics>();
    private performanceThresholds = {
        saveTime: 1000, // ms
        loadTime: 2000, // ms
        syncTime: 500,  // ms
        stateSize: 1024 * 1024 // 1MB
    };

    public monitorStateOperation(operation: string, duration: number, dataSize: number, playerId: string): void {
        const metrics = this.getOrCreateMetrics(playerId);
        
        // Update metrics
        metrics.operations.push({
            type: operation,
            duration,
            dataSize,
            timestamp: Date.now()
        });
        
        // Keep only recent operations
        if (metrics.operations.length > 100) {
            metrics.operations.shift();
        }
        
        // Check for performance issues
        this.checkPerformanceThresholds(operation, duration, dataSize, playerId);
        
        // Update averages
        this.updateMetricsAverages(metrics);
    }

    private checkPerformanceThresholds(operation: string, duration: number, dataSize: number, playerId: string): void {
        const issues: string[] = [];
        
        if (operation === 'save' && duration > this.performanceThresholds.saveTime) {
            issues.push(`Slow save operation: ${duration}ms`);
        }
        
        if (operation === 'load' && duration > this.performanceThresholds.loadTime) {
            issues.push(`Slow load operation: ${duration}ms`);
        }
        
        if (dataSize > this.performanceThresholds.stateSize) {
            issues.push(`Large state size: ${(dataSize / 1024 / 1024).toFixed(2)}MB`);
        }
        
        if (issues.length > 0) {
            console.warn(`💾 [STATE:PERFORMANCE] Performance issues detected:
                Player: ${playerId}
                Operation: ${operation}
                Issues: ${issues.join(', ')}
                Duration: ${duration}ms
                Size: ${(dataSize / 1024).toFixed(2)}KB
                Action: ${this.getOptimizationSuggestion(operation, issues)}`);
        }
    }

    private getOptimizationSuggestion(operation: string, issues: string[]): string {
        if (issues.some(i => i.includes('Large state'))) {
            return 'Consider state compression or data pruning';
        }
        
        if (issues.some(i => i.includes('Slow'))) {
            return 'Optimize serialization or storage method';
        }
        
        return 'Monitor continued performance';
    }
}
```

This comprehensive game state error handling system ensures data integrity, provides robust recovery mechanisms, and maintains optimal performance for save/load operations with detailed monitoring and fallback strategies.

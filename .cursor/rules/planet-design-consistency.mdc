# Planet Design Consistency Standards

This rule ensures all planets maintain consistent design language, proper biome integration, and seamless switching between detail levels for a cohesive visual experience.

## üåç Unified Planet System Architecture

### **Single Planet Renderer Pattern**
ALL planet generation must go through the unified `PlanetRenderer` system:

```typescript
// MANDATORY: Use centralized planet rendering
export class PlanetRenderer implements ErrorRecoverable {
    private littlePlanetGenerator: LittlePlanetGenerator;
    private standardPlanetGenerator: StandardPlanetGenerator;
    
    public async renderPlanet(config: PlanetRenderConfig): Promise<PlanetRenderResult> {
        // NEVER bypass this central system
        if (config.detailLevel === DetailLevel.LITTLE_PLANET) {
            return await this.renderLittlePlanet(config);
        } else {
            return await this.renderStandardPlanet(config);
        }
    }
}

// FORBIDDEN: Direct planet generation without PlanetRenderer
// ‚ùå const planet = new THREE.Mesh(geometry, material);
// ‚úÖ const result = await planetRenderer.renderPlanet(config);
```

### **Biome-First Design Philosophy**
Every planet feature must be driven by its biome:

```typescript
// MANDATORY: Biome determines all visual characteristics
public enum PlanetBiome {
    TEMPERATE = "temperate",  // üå≤ Green forests, lakes, moderate features
    TROPICAL = "tropical",    // üå¥ Dense jungle, vibrant colors, high vegetation  
    DESERT = "desert",        // üèúÔ∏è Cacti, sand, minimal water, warm colors
    ARCTIC = "arctic",        // ‚ùÑÔ∏è Ice, snow, crystals, cold colors
    VOLCANIC = "volcanic",    // üåã Lava, dark rock, minimal vegetation
    OCEAN = "ocean",          // üåä Water dominant, islands, aquatic features
    BARREN = "barren"         // ü™® Rocky, minimal features, neutral colors
}

// MANDATORY: Consistent biome color palettes
private getBiomeColorPalette(biome: PlanetBiome): ColorPalette {
    const palettes = {
        [PlanetBiome.TEMPERATE]: {
            primary: 0x4a7c59,     // Forest green
            secondary: 0x8fbc8f,   // Light green
            accent: 0x1e90ff,      // Water blue
            surface: 0x6b8e23      // Olive green
        },
        [PlanetBiome.TROPICAL]: {
            primary: 0x228b22,     // Jungle green  
            secondary: 0x32cd32,   // Lime green
            accent: 0xff69b4,      // Flower pink
            surface: 0x2e8b57      // Sea green
        },
        [PlanetBiome.DESERT]: {
            primary: 0xd2b48c,     // Sandy tan
            secondary: 0xdaa520,   // Golden rod
            accent: 0xff4500,      // Orange red
            surface: 0xf4a460      // Sandy brown
        }
        // ... continue for all biomes
    };
    
    return palettes[biome];
}
```

## üé® Visual Consistency Standards

### **Material System Uniformity**
All planets must use the same material approach for consistency:

```typescript
// MANDATORY: Flat shading for low-poly aesthetic
private createConsistentMaterial(color: number, options?: MaterialOptions): THREE.Material {
    return new THREE.MeshLambertMaterial({
        color,
        flatShading: true,           // REQUIRED: Maintains low-poly look
        transparent: options?.transparent || false,
        opacity: options?.opacity || 1.0,
        ...options
    });
}

// FORBIDDEN: Different material types for planets
// ‚ùå new THREE.MeshStandardMaterial()   // Too realistic
// ‚ùå new THREE.MeshBasicMaterial()      // Too simple
// ‚úÖ new THREE.MeshLambertMaterial()    // Perfect for our style
```

### **Feature Consistency Across Detail Levels**
Features must maintain visual consistency regardless of detail level:

```typescript
// MANDATORY: Consistent feature appearance
public generateTree(biome: PlanetBiome, detailLevel: DetailLevel): THREE.Group {
    const tree = new THREE.Group();
    const palette = this.getBiomeColorPalette(biome);
    
    // Trunk (consistent across all detail levels)
    const trunkMaterial = this.createConsistentMaterial(0x8b4513); // Brown
    let trunkGeometry: THREE.BufferGeometry;
    
    switch (detailLevel) {
        case DetailLevel.HIGH:
            trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1, 8);
            break;
        case DetailLevel.MEDIUM:
            trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1, 6);
            break;
        default:
            trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1, 4);
    }
    
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    
    // Leaves (biome-specific but consistent shape)
    const leafMaterial = this.createConsistentMaterial(palette.primary);
    const leafGeometry = new THREE.SphereGeometry(0.8, 8, 6);
    const leaves = new THREE.Mesh(leafGeometry, leafMaterial);
    leaves.position.y = 1;
    
    tree.add(trunk);
    tree.add(leaves);
    
    return tree;
}
```

### **Scale and Proportion Standards**
Maintain consistent proportions across all planet features:

```typescript
// MANDATORY: Standardized feature scales
private readonly FEATURE_SCALES = {
    trees: {
        height: { min: 0.8, max: 1.5 },
        radius: { min: 0.6, max: 1.0 }
    },
    rocks: {
        height: { min: 0.3, max: 0.8 },
        radius: { min: 0.4, max: 0.7 }
    },
    lakes: {
        radius: { min: 1.0, max: 2.0 },
        depth: 0.1
    },
    mountains: {
        height: { min: 1.5, max: 3.0 },
        baseRadius: { min: 1.0, max: 1.5 }
    }
};

// MANDATORY: Apply consistent scaling
private scaleFeature(feature: THREE.Object3D, type: FeatureType, randomFactor: number): void {
    const scale = this.FEATURE_SCALES[type];
    const height = scale.height.min + (scale.height.max - scale.height.min) * randomFactor;
    const radius = scale.radius.min + (scale.radius.max - scale.radius.min) * randomFactor;
    
    feature.scale.set(radius, height, radius);
}
```

## üîÑ Seamless Detail Level Transitions

### **Unified Configuration Interface**
All planet types must support the same configuration interface:

```typescript
// MANDATORY: Universal planet configuration
export interface PlanetRenderConfig {
    id: string;
    name: string;
    type: PlanetType;
    radius: number;
    biome: PlanetBiome;             // REQUIRED: Every planet has a biome
    position: THREE.Vector3;
    seed: number;                   // REQUIRED: Deterministic generation
    detailLevel: DetailLevel;       // REQUIRED: Performance scaling
    atmosphere: boolean;
    rings: boolean;
    moons: number;
}

// FORBIDDEN: Different config interfaces for different planet types
// ‚ùå LittlePlanetConfig vs StandardPlanetConfig
// ‚úÖ Single PlanetRenderConfig for all types
```

### **Feature Density Management**
Adjust feature count based on detail level while maintaining biome characteristics:

```typescript
// MANDATORY: Detail-level adjusted feature counts
private getFeatureCountForDetailLevel(
    biomeBaseCounts: FeatureCounts, 
    detailLevel: DetailLevel
): FeatureCounts {
    const multipliers = {
        [DetailLevel.LITTLE_PLANET]: 1.0,   // Full detail for showcase
        [DetailLevel.HIGH]: 1.0,            // Full detail
        [DetailLevel.MEDIUM]: 0.6,          // Reduced detail
        [DetailLevel.LOW]: 0.3,             // Minimal detail
        [DetailLevel.MINIMAL]: 0.0          // No surface features
    };
    
    const multiplier = multipliers[detailLevel];
    
    return {
        trees: Math.floor(biomeBaseCounts.trees * multiplier),
        rocks: Math.floor(biomeBaseCounts.rocks * multiplier),
        lakes: Math.floor(biomeBaseCounts.lakes * multiplier),
        mountains: Math.floor(biomeBaseCounts.mountains * multiplier)
    };
}
```

## üéØ Quality Assurance Standards

### **Visual Validation**
ALWAYS validate that planets match their biome expectations:

```typescript
// MANDATORY: Biome visual validation
private validatePlanetVisuals(planet: PlanetRenderResult, config: PlanetRenderConfig): ValidationResult {
    const errors: string[] = [];
    
    // Check biome color consistency
    const expectedPalette = this.getBiomeColorPalette(config.biome);
    if (!this.validateColorPalette(planet, expectedPalette)) {
        errors.push(`Planet colors don't match ${config.biome} biome`);
    }
    
    // Check feature appropriateness
    const features = planet.features;
    if (config.biome === PlanetBiome.DESERT && features.lakes.length > 0) {
        errors.push("Desert biome should not have lakes");
    }
    
    if (config.biome === PlanetBiome.TROPICAL && features.trees.length < 10) {
        errors.push("Tropical biome should have abundant vegetation");
    }
    
    // Check material consistency
    for (const feature of features) {
        if (!this.hasFlatShading(feature.material)) {
            errors.push("Feature material must use flat shading");
        }
    }
    
    return {
        isValid: errors.length === 0,
        errors
    };
}
```

### **Performance Validation**
Ensure planets meet performance requirements:

```typescript
// MANDATORY: Performance budget validation
private validatePerformanceBudget(planet: PlanetRenderResult, detailLevel: DetailLevel): boolean {
    const triangleCount = this.countTriangles(planet.group);
    const featureCount = planet.features.length;
    
    const budgets = {
        [DetailLevel.LITTLE_PLANET]: { triangles: 2000, features: 50 },
        [DetailLevel.HIGH]: { triangles: 5000, features: 100 },
        [DetailLevel.MEDIUM]: { triangles: 1000, features: 25 },
        [DetailLevel.LOW]: { triangles: 200, features: 5 },
        [DetailLevel.MINIMAL]: { triangles: 20, features: 0 }
    };
    
    const budget = budgets[detailLevel];
    
    if (triangleCount > budget.triangles) {
        console.error(`üö® Triangle budget exceeded: ${triangleCount}/${budget.triangles}`);
        return false;
    }
    
    if (featureCount > budget.features) {
        console.error(`üö® Feature budget exceeded: ${featureCount}/${budget.features}`);
        return false;
    }
    
    return true;
}
```

## üîß Integration Requirements

### **Menu System Integration**
Main menu planets must use the same system as in-game planets:

```typescript
// MANDATORY: Menu uses same planet system
private async createMenuPlanet(): Promise<void> {
    // Use the SAME PlanetRenderer as in-game planets
    const planetConfig: PlanetRenderConfig = {
        id: 'menu-planet',
        name: 'Menu World',
        type: PlanetType.TERRESTRIAL,
        radius: 2,
        biome: this.getRandomBiome(),           // Random for variety
        position: new THREE.Vector3(0, 0, 0),
        seed: Math.random() * 100000,
        detailLevel: DetailLevel.LITTLE_PLANET, // Always little planet in menu
        atmosphere: true,
        rings: false,
        moons: Math.floor(Math.random() * 2)
    };
    
    // MUST use the same renderer
    const planetResult = await this.planetRenderer.renderPlanet(planetConfig);
    this.planetGroup = planetResult.group;
}
```

### **Galaxy View Integration**
Galaxy view must seamlessly transition between detail levels:

```typescript
// MANDATORY: Smooth LOD transitions in galaxy view
public updatePlanetDetailLevel(planetId: string, newDetailLevel: DetailLevel): void {
    const planet = this.planets.get(planetId);
    if (!planet || planet.currentDetailLevel === newDetailLevel) return;
    
    // Fade out current representation
    this.fadeOut(planet.mesh).then(() => {
        // Re-render at new detail level
        return this.planetRenderer.renderPlanet({
            ...planet.config,
            detailLevel: newDetailLevel
        });
    }).then((newPlanetResult) => {
        // Replace with new representation
        this.scene.remove(planet.mesh);
        this.scene.add(newPlanetResult.group);
        planet.mesh = newPlanetResult.group;
        planet.currentDetailLevel = newDetailLevel;
        
        // Fade in new representation
        this.fadeIn(planet.mesh);
    });
}
```

## üìã Development Checklist

When creating any planet-related feature, ensure:

### ‚úÖ **Design Consistency**
- [ ] Uses PlanetRenderer system (never direct mesh creation)
- [ ] Implements proper biome-based generation
- [ ] Uses flat shading materials for low-poly aesthetic
- [ ] Maintains consistent color palettes per biome
- [ ] Follows standardized feature scales and proportions

### ‚úÖ **Performance Standards**
- [ ] Respects triangle and feature budgets per detail level
- [ ] Implements proper LOD scaling
- [ ] Uses object pooling for frequently generated features
- [ ] Includes performance validation and monitoring

### ‚úÖ **Integration Requirements**
- [ ] Compatible with all detail levels (LITTLE_PLANET, HIGH, MEDIUM, LOW, MINIMAL)
- [ ] Uses universal PlanetRenderConfig interface
- [ ] Integrates seamlessly with galaxy view LOD system
- [ ] Maintains visual consistency across all game contexts

### ‚úÖ **Quality Assurance**
- [ ] Includes visual validation for biome appropriateness
- [ ] Implements error recovery and fallback generation
- [ ] Provides deterministic generation with seeds
- [ ] Includes comprehensive testing for all biomes and detail levels

This rule ensures that every planet, whether in the main menu, galaxy view, or detailed planet view, maintains the same high-quality, consistent visual language while providing optimal performance across all platforms and viewing distances.
description:
globs:
alwaysApply: true
---

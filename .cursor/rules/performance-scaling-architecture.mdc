# Performance Scaling & Smart Architecture

This rule ensures all game systems implement intelligent performance scaling, proper resource management, and smart architecture patterns for optimal scalability from small star systems to massive galaxies.

## üéØ Performance Budget Management

### **System-Wide Performance Budgets**
ALL systems must respect strict performance budgets:

```typescript
// MANDATORY: Global performance budget enforcement
export class PerformanceBudgetManager {
    private static readonly BUDGETS = {
        galaxy: {
            maxVisibleSystems: 1000,
            maxTrianglesPerSystem: 500,
            maxGenerationTimeMs: 33,     // Two frame budget
            maxMemoryMB: 256
        },
        solarSystem: {
            maxVisiblePlanets: 20,
            maxTrianglesPerPlanet: 2000,
            maxGenerationTimeMs: 16,     // One frame budget  
            maxMemoryMB: 64
        },
        planet: {
            maxSurfaceFeatures: 100,
            maxTrianglesPerFeature: 50,
            maxGenerationTimeMs: 8,      // Half frame budget
            maxMemoryMB: 32
        }
    };

    // MANDATORY: Budget validation before generation
    public static validateBudget(system: string, metrics: PerformanceMetrics): boolean {
        const budget = this.BUDGETS[system];
        
        if (metrics.triangles > budget.maxTrianglesPerPlanet) {
            console.error(`üö® [BUDGET] ${system} exceeds triangle budget: ${metrics.triangles}/${budget.maxTrianglesPerPlanet}`);
            return false;
        }
        
        if (metrics.generationTime > budget.maxGenerationTimeMs) {
            console.error(`üö® [BUDGET] ${system} exceeds time budget: ${metrics.generationTime}ms/${budget.maxGenerationTimeMs}ms`);
            return false;
        }
        
        return true;
    }
}
```

### **Dynamic Quality Scaling**
Implement automatic quality adjustment based on performance:

```typescript
// MANDATORY: Real-time quality scaling
export class DynamicQualityManager {
    private currentQuality: QualityLevel = QualityLevel.HIGH;
    private performanceHistory: number[] = [];
    private qualityLocked = false;

    public updateQuality(currentFPS: number, frameTime: number): void {
        if (this.qualityLocked) return;

        this.performanceHistory.push(currentFPS);
        if (this.performanceHistory.length > 60) {
            this.performanceHistory.shift();
        }

        const avgFPS = this.performanceHistory.reduce((a, b) => a + b, 0) / this.performanceHistory.length;

        // Aggressive quality reduction for poor performance
        if (avgFPS < 30 && this.currentQuality > QualityLevel.LOW) {
            this.reduceQuality();
            console.warn(`üìâ [QUALITY] Reduced to ${this.currentQuality} due to low FPS: ${avgFPS.toFixed(1)}`);
        }
        // Conservative quality increase for good performance
        else if (avgFPS > 55 && frameTime < 12 && this.currentQuality < QualityLevel.ULTRA) {
            this.increaseQuality();
            console.log(`üìà [QUALITY] Increased to ${this.currentQuality} due to good performance`);
        }
    }

    // MANDATORY: Apply quality settings to all systems
    private applyQualitySettings(): void {
        const settings = this.getQualitySettings(this.currentQuality);
        
        // Update galaxy settings
        GalaxyRenderer.setLODDistances(settings.galaxy.lodDistances);
        GalaxyRenderer.setMaxVisibleSystems(settings.galaxy.maxSystems);
        
        // Update planet settings  
        PlanetRenderer.setMaxFeatures(settings.planet.maxFeatures);
        PlanetRenderer.setGeometryDetail(settings.planet.geometryDetail);
        
        // Update effects settings
        EffectsManager.setParticleCount(settings.effects.particleCount);
        EffectsManager.setBloomIntensity(settings.effects.bloomIntensity);
    }
}
```

## üåå Smart Galaxy Architecture

### **Hierarchical Level-of-Detail (LOD)**
Implement cascading LOD from galaxy ‚Üí solar system ‚Üí planet ‚Üí surface:

```typescript
// MANDATORY: Hierarchical LOD management
export class HierarchicalLODManager {
    private cameraPosition: THREE.Vector3 = new THREE.Vector3();
    private lodLevels = new Map<string, LODLevel>();

    public updateLOD(camera: THREE.Camera): void {
        this.cameraPosition.copy(camera.position);

        // Update galaxy-level LOD
        for (const [systemId, system] of this.galaxy.systems) {
            const distance = this.cameraPosition.distanceTo(system.position);
            const newLOD = this.calculateSystemLOD(distance);
            
            if (system.currentLOD !== newLOD) {
                this.transitionSystemLOD(system, newLOD);
            }
        }
    }

    private calculateSystemLOD(distance: number): SystemLOD {
        if (distance < 50) return SystemLOD.PLANET_DETAIL;      // Show planet surfaces
        if (distance < 200) return SystemLOD.PLANET_GEOMETRY;   // Show planet shapes
        if (distance < 1000) return SystemLOD.PLANET_POINTS;    // Show planet dots
        if (distance < 5000) return SystemLOD.SYSTEM_ICON;      // Show system icon
        return SystemLOD.SYSTEM_POINT;                          // Show system dot
    }

    // MANDATORY: Smooth LOD transitions
    private async transitionSystemLOD(system: StarSystem, newLOD: SystemLOD): Promise<void> {
        // Fade out current representation
        await this.fadeOut(system.currentMesh);
        
        // Generate new representation
        const newMesh = await this.generateSystemAtLOD(system, newLOD);
        
        // Replace and fade in
        this.scene.remove(system.currentMesh);
        this.scene.add(newMesh);
        system.currentMesh = newMesh;
        system.currentLOD = newLOD;
        
        await this.fadeIn(newMesh);
    }
}
```

### **Streaming and Culling**
Only load and render what's visible or needed:

```typescript
// MANDATORY: Frustum culling and streaming
export class SmartStreamingManager {
    private frustum = new THREE.Frustum();
    private loadedRegions = new Set<string>();
    private streamingQueue: StreamingRequest[] = [];

    public updateStreaming(camera: THREE.Camera): void {
        // Update frustum from camera
        this.frustum.setFromProjectionMatrix(
            new THREE.Matrix4().multiplyMatrices(
                camera.projectionMatrix,
                camera.matrixWorldInverse
            )
        );

        // Frustum culling for galaxies
        for (const [systemId, system] of this.galaxy.systems) {
            const isVisible = this.frustum.containsPoint(system.position);
            
            if (isVisible && !system.isLoaded) {
                this.requestSystemLoad(systemId, StreamingPriority.HIGH);
            } else if (!isVisible && system.isLoaded) {
                this.requestSystemUnload(systemId, StreamingPriority.LOW);
            }
        }

        // Process streaming queue
        this.processStreamingQueue();
    }

    // MANDATORY: Priority-based streaming
    private processStreamingQueue(): void {
        // Sort by priority and distance
        this.streamingQueue.sort((a, b) => {
            if (a.priority !== b.priority) {
                return b.priority - a.priority;
            }
            return a.distance - b.distance;
        });

        // Process up to 3 requests per frame
        const maxProcessPerFrame = 3;
        const requests = this.streamingQueue.splice(0, maxProcessPerFrame);
        
        for (const request of requests) {
            if (request.type === 'load') {
                this.loadSystemAsync(request.systemId);
            } else {
                this.unloadSystemAsync(request.systemId);
            }
        }
    }
}
```

## ü™ê Smart Planet Generation

### **Procedural Generation Pipeline**
Use modular, cacheable generation pipeline:

```typescript
// MANDATORY: Modular generation pipeline  
export class ProceduralGenerationPipeline {
    private generators = new Map<string, PipelineStage>();
    private cache = new LRUCache<string, GenerationResult>(1000);

    constructor() {
        this.setupPipeline();
    }

    private setupPipeline(): void {
        // MANDATORY: Register generation stages in dependency order
        this.registerStage('terrain', new TerrainGenerator(), []);
        this.registerStage('biome', new BiomeGenerator(), ['terrain']);
        this.registerStage('features', new FeatureGenerator(), ['terrain', 'biome']);
        this.registerStage('atmosphere', new AtmosphereGenerator(), ['terrain']);
        this.registerStage('lighting', new LightingGenerator(), ['atmosphere']);
    }

    // MANDATORY: Cached generation with dependency tracking
    public async generatePlanet(config: PlanetConfig): Promise<PlanetResult> {
        const cacheKey = this.generateCacheKey(config);
        
        // Check cache first
        const cached = this.cache.get(cacheKey);
        if (cached && this.isCacheValid(cached, config)) {
            return cached.clone();
        }

        // Generate with dependency resolution
        const result = await this.executeGenerationPipeline(config);
        
        // Cache result
        this.cache.set(cacheKey, result);
        
        return result;
    }

    // MANDATORY: Incremental generation for performance
    private async executeGenerationPipeline(config: PlanetConfig): Promise<PlanetResult> {
        const context = new GenerationContext(config);
        const executionPlan = this.createExecutionPlan(config.requiredStages);

        for (const stage of executionPlan) {
            const startTime = performance.now();
            
            try {
                await stage.execute(context);
                
                const duration = performance.now() - startTime;
                if (duration > 8) { // Half frame budget
                    console.warn(`‚è±Ô∏è [GENERATION] Slow stage ${stage.name}: ${duration.toFixed(2)}ms`);
                }
            } catch (error) {
                console.error(`üí• [GENERATION] Stage ${stage.name} failed:`, error);
                await this.executeRecoveryStrategy(stage, context, error);
            }
        }

        return context.getResult();
    }
}
```

### **Memory-Efficient Feature Management**
Use object pooling and smart cleanup for planet features:

```typescript
// MANDATORY: Object pooling for planet features
export class FeaturePoolManager {
    private pools = new Map<FeatureType, ObjectPool<THREE.Object3D>>();
    private activeFeatures = new Map<string, PooledFeature[]>();
    
    constructor() {
        this.initializePools();
    }

    private initializePools(): void {
        // Create pools for each feature type
        this.pools.set(FeatureType.TREE, new ObjectPool(
            () => this.createTreeTemplate(),
            (tree) => this.resetTree(tree),
            50  // Initial pool size
        ));
        
        this.pools.set(FeatureType.ROCK, new ObjectPool(
            () => this.createRockTemplate(),
            (rock) => this.resetRock(rock),
            30
        ));
        
        this.pools.set(FeatureType.LAKE, new ObjectPool(
            () => this.createLakeTemplate(),
            (lake) => this.resetLake(lake),
            10
        ));
    }

    // MANDATORY: Efficient feature allocation and deallocation
    public generateFeatures(planetId: string, config: FeatureConfig): THREE.Object3D[] {
        const features: THREE.Object3D[] = [];
        const pooledFeatures: PooledFeature[] = [];

        // Generate trees
        for (let i = 0; i < config.treeCount; i++) {
            const tree = this.pools.get(FeatureType.TREE)!.acquire();
            this.configureTree(tree, config.biome);
            features.push(tree);
            pooledFeatures.push({ type: FeatureType.TREE, object: tree });
        }

        // Store for later cleanup
        this.activeFeatures.set(planetId, pooledFeatures);

        return features;
    }

    // MANDATORY: Clean up features when planet is unloaded
    public cleanupPlanetFeatures(planetId: string): void {
        const features = this.activeFeatures.get(planetId);
        if (!features) return;

        for (const feature of features) {
            const pool = this.pools.get(feature.type);
            if (pool) {
                pool.release(feature.object);
            }
        }

        this.activeFeatures.delete(planetId);
        console.log(`üßπ [CLEANUP] Released ${features.length} features for planet ${planetId}`);
    }
}
```

## üìä Performance Monitoring & Analytics

### **Real-Time Performance Metrics**
Monitor all aspects of generation and rendering:

```typescript
// MANDATORY: Comprehensive performance monitoring
export class PerformanceAnalytics {
    private metrics = {
        galaxy: new PerformanceTracker('galaxy'),
        solarSystem: new PerformanceTracker('solarSystem'),
        planet: new PerformanceTracker('planet'),
        rendering: new PerformanceTracker('rendering')
    };

    public startMeasurement(system: string, operation: string): StopFunction {
        const tracker = this.metrics[system];
        if (!tracker) {
            console.warn(`Unknown performance system: ${system}`);
            return () => {};
        }

        return tracker.startMeasurement(operation);
    }

    // MANDATORY: Performance bottleneck detection
    public analyzePerformance(): PerformanceReport {
        const report: PerformanceReport = {
            bottlenecks: [],
            recommendations: [],
            overallHealth: 'good'
        };

        for (const [systemName, tracker] of Object.entries(this.metrics)) {
            const analysis = tracker.getAnalysis();
            
            // Detect bottlenecks
            if (analysis.averageTime > this.getThreshold(systemName)) {
                report.bottlenecks.push({
                    system: systemName,
                    operation: analysis.slowestOperation,
                    avgTime: analysis.averageTime,
                    maxTime: analysis.maxTime
                });
            }

            // Generate recommendations
            if (analysis.memoryUsage > this.getMemoryThreshold(systemName)) {
                report.recommendations.push(
                    `Reduce memory usage in ${systemName}: ${analysis.memoryUsage}MB > ${this.getMemoryThreshold(systemName)}MB`
                );
            }
        }

        // Overall health assessment
        if (report.bottlenecks.length > 3) {
            report.overallHealth = 'poor';
        } else if (report.bottlenecks.length > 1) {
            report.overallHealth = 'fair';
        }

        return report;
    }

    // MANDATORY: Automatic optimization suggestions
    public getOptimizationSuggestions(): OptimizationSuggestion[] {
        const suggestions: OptimizationSuggestion[] = [];
        
        // Analyze galaxy performance
        const galaxyMetrics = this.metrics.galaxy.getMetrics();
        if (galaxyMetrics.generationTime > 50) {
            suggestions.push({
                system: 'galaxy',
                type: 'reduce_generation_complexity',
                description: 'Reduce galaxy generation complexity or use LOD',
                impact: 'high',
                effort: 'medium'
            });
        }

        // Analyze planet performance
        const planetMetrics = this.metrics.planet.getMetrics();
        if (planetMetrics.triangleCount > 10000) {
            suggestions.push({
                system: 'planet',
                type: 'implement_geometry_lod',
                description: 'Implement geometric level-of-detail for planets',
                impact: 'high',
                effort: 'low'
            });
        }

        return suggestions;
    }
}
```

## üîß Architecture Patterns

### **Plugin-Based System Architecture**
Design systems to be modular and extensible:

```typescript
// MANDATORY: Plugin-based architecture for all major systems
export abstract class SystemPlugin {
    abstract readonly name: string;
    abstract readonly version: string;
    abstract readonly dependencies: string[];

    abstract initialize(context: SystemContext): Promise<void>;
    abstract update(deltaTime: number): void;
    abstract dispose(): void;
}

export class PluginManager {
    private plugins = new Map<string, SystemPlugin>();
    private loadOrder: string[] = [];

    // MANDATORY: Dependency-aware plugin loading
    public async loadPlugin(plugin: SystemPlugin): Promise<void> {
        // Check dependencies
        for (const dependency of plugin.dependencies) {
            if (!this.plugins.has(dependency)) {
                throw new Error(`Plugin ${plugin.name} requires ${dependency} but it's not loaded`);
            }
        }

        // Initialize plugin
        await plugin.initialize(this.createSystemContext());
        this.plugins.set(plugin.name, plugin);
        this.loadOrder.push(plugin.name);

        console.log(`üîå [PLUGIN] Loaded ${plugin.name} v${plugin.version}`);
    }

    // MANDATORY: Update plugins in dependency order
    public update(deltaTime: number): void {
        for (const pluginName of this.loadOrder) {
            const plugin = this.plugins.get(pluginName);
            if (plugin) {
                try {
                    plugin.update(deltaTime);
                } catch (error) {
                    console.error(`üí• [PLUGIN] ${pluginName} update failed:`, error);
                }
            }
        }
    }
}

// Example: Galaxy Generation Plugin
export class GalaxyGenerationPlugin extends SystemPlugin {
    readonly name = 'galaxy-generation';
    readonly version = '1.0.0';
    readonly dependencies = ['performance-monitor', 'object-pool'];

    async initialize(context: SystemContext): Promise<void> {
        this.setupGalaxyGeneration(context);
    }

    update(deltaTime: number): void {
        this.processGenerationQueue(deltaTime);
    }

    dispose(): void {
        this.cleanupResources();
    }
}
```

## üìè Scaling Guidelines

### **Performance Scaling Rules**
Clear guidelines for different system scales:

```typescript
// MANDATORY: Scale-appropriate performance targets
export const PERFORMANCE_TARGETS = {
    single_planet: {
        maxTriangles: 5000,
        maxFeatures: 100,
        generationTime: 16,    // 1 frame
        memoryMB: 32
    },
    solar_system: {
        maxTriangles: 20000,   // All planets combined
        maxFeatures: 500,      // All features combined
        generationTime: 33,    // 2 frames
        memoryMB: 128
    },
    galaxy_sector: {
        maxTriangles: 100000,  // Visible systems
        maxFeatures: 2000,     // Visible features
        generationTime: 100,   // 6 frames
        memoryMB: 512
    },
    full_galaxy: {
        maxTriangles: 200000,  // Total budget
        maxFeatures: 5000,     // Total budget
        generationTime: 200,   // 12 frames initial load
        memoryMB: 1024
    }
};

// MANDATORY: Validate performance targets during development
export function validatePerformanceTarget(
    scale: keyof typeof PERFORMANCE_TARGETS,
    metrics: PerformanceMetrics
): ValidationResult {
    const target = PERFORMANCE_TARGETS[scale];
    const violations: string[] = [];

    if (metrics.triangles > target.maxTriangles) {
        violations.push(`Triangle count: ${metrics.triangles} > ${target.maxTriangles}`);
    }

    if (metrics.features > target.maxFeatures) {
        violations.push(`Feature count: ${metrics.features} > ${target.maxFeatures}`);
    }

    if (metrics.generationTime > target.generationTime) {
        violations.push(`Generation time: ${metrics.generationTime}ms > ${target.generationTime}ms`);
    }

    return {
        isValid: violations.length === 0,
        violations,
        scale,
        recommendations: violations.length > 0 ? 
            [`Consider reducing complexity for ${scale} scale`] : []
    };
}
```

This comprehensive rule ensures that all game systems scale intelligently from individual planets to massive galaxies while maintaining optimal performance and consistent user experience across all scales.
description:
globs:
alwaysApply: true
---

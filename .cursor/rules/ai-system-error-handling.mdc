---
alwaysApply: true
description: "Error handling for AI systems, decision-making, pathfinding, and NPC behavior"
---

# AI System Error Handling

Specialized error handling for AI systems, NPC behavior, pathfinding, and decision-making algorithms.

## AI Error Categories

```typescript
enum AIErrorType {
    DECISION_TIMEOUT = "DECISION_TIMEOUT",
    PATHFINDING_FAILURE = "PATHFINDING_FAILURE",
    BEHAVIOR_TREE_ERROR = "BEHAVIOR_TREE_ERROR",
    STATE_MACHINE_INVALID = "STATE_MACHINE_INVALID",
    GOAL_UNREACHABLE = "GOAL_UNREACHABLE",
    RESOURCE_EXHAUSTION = "RESOURCE_EXHAUSTION",
    INFINITE_LOOP = "INFINITE_LOOP",
    INVALID_TARGET = "INVALID_TARGET",
    AI_DEADLOCK = "AI_DEADLOCK"
}

enum AIErrorSeverity {
    GAME_BREAKING = "GAME_BREAKING",    // AI completely fails, breaks gameplay
    BEHAVIOR_BROKEN = "BEHAVIOR_BROKEN", // AI behavior broken, but game continues
    PERFORMANCE_IMPACT = "PERFORMANCE_IMPACT", // AI slow, affects performance
    MINOR_GLITCH = "MINOR_GLITCH"      // Minor AI issues, barely noticeable
}
```

## AI Decision Error Handling

All AI decision-making MUST implement timeout and fallback mechanisms:

```typescript
class AIDecisionMaker {
    private decisionTimeout = 100; // ms
    private maxDecisionAttempts = 3;

    public makeDecision(context: AIContext): AIDecision {
        const startTime = performance.now();
        let attempts = 0;
        
        try {
            while (attempts < this.maxDecisionAttempts) {
                attempts++;
                
                // Check for timeout
                if (performance.now() - startTime > this.decisionTimeout) {
                    throw new Error(`Decision timeout after ${this.decisionTimeout}ms`);
                }
                
                const decision = this.processDecision(context, attempts);
                
                // Validate decision
                if (this.validateDecision(decision, context)) {
                    if (attempts > 1) {
                        console.warn(`🤖 [AI:MEDIUM] Decision required ${attempts} attempts:
                            Context: ${this.summarizeContext(context)}
                            Decision: ${decision.type}
                            Duration: ${(performance.now() - startTime).toFixed(2)}ms`);
                    }
                    return decision;
                }
                
                console.warn(`🤖 [AI:MEDIUM] Invalid decision on attempt ${attempts}, retrying...`);
            }
            
            throw new Error(`Failed to make valid decision after ${attempts} attempts`);
            
        } catch (error) {
            return this.handleDecisionError(error, context, startTime, attempts);
        }
    }

    private handleDecisionError(error: Error, context: AIContext, startTime: number, attempts: number): AIDecision {
        const duration = performance.now() - startTime;
        
        console.error(`🤖 [AI:HIGH] Decision making failed:
            ❌ Error: ${error.message}
            🎯 Entity: ${context.entityId}
            📊 Context: ${this.summarizeContext(context)}
            🔄 Attempts: ${attempts}/${this.maxDecisionAttempts}
            ⏱️ Duration: ${duration.toFixed(2)}ms
            🧠 State: ${this.getAIState(context.entityId)}
            🛡️ Fallback: Using default behavior...`);
        
        // Execute fallback decision
        return this.getDefaultDecision(context);
    }

    private validateDecision(decision: AIDecision, context: AIContext): boolean {
        // Check if decision is executable
        if (!this.canExecuteDecision(decision, context)) {
            return false;
        }
        
        // Check for resource requirements
        if (!this.hasRequiredResources(decision, context)) {
            return false;
        }
        
        // Check for conflicts with other AI entities
        if (this.hasDecisionConflicts(decision, context)) {
            return false;
        }
        
        return true;
    }
}
```

## Pathfinding Error Recovery

Implement robust pathfinding with multiple fallback strategies:

```typescript
class AIPathfinder {
    private maxPathfindingTime = 50; // ms
    private maxPathLength = 1000; // nodes

    public findPath(start: Vector3, goal: Vector3, options: PathfindingOptions): Path | null {
        const startTime = performance.now();
        
        try {
            // Validate inputs
            this.validatePathfindingInputs(start, goal);
            
            // Primary pathfinding algorithm
            let path = this.aStarPathfinding(start, goal, options);
            
            if (!path) {
                // Fallback 1: Simplified pathfinding
                console.warn(`🤖 [AI:MEDIUM] Primary pathfinding failed, trying simplified approach:
                    Start: ${start.toArray()}
                    Goal: ${goal.toArray()}
                    Distance: ${start.distanceTo(goal).toFixed(2)}
                    Obstacles: ${this.countObstacles(start, goal)}`);
                
                path = this.simplifiedPathfinding(start, goal);
            }
            
            if (!path) {
                // Fallback 2: Direct line with obstacle avoidance
                console.warn(`🤖 [AI:MEDIUM] Simplified pathfinding failed, using direct navigation...`);
                path = this.directNavigation(start, goal);
            }
            
            // Validate path
            if (path && this.validatePath(path)) {
                const duration = performance.now() - startTime;
                if (duration > this.maxPathfindingTime * 0.8) {
                    console.warn(`🤖 [AI:PERFORMANCE] Slow pathfinding detected:
                        Duration: ${duration.toFixed(2)}ms
                        Path Length: ${path.nodes.length}
                        Complexity: ${this.calculatePathComplexity(path)}`);
                }
                return path;
            }
            
            throw new Error('All pathfinding methods failed');
            
        } catch (error) {
            return this.handlePathfindingError(error, start, goal, startTime);
        }
    }

    private handlePathfindingError(error: Error, start: Vector3, goal: Vector3, startTime: number): Path | null {
        const duration = performance.now() - startTime;
        
        console.error(`🤖 [AI:HIGH] Pathfinding completely failed:
            ❌ Error: ${error.message}
            🎯 Start: ${start.toArray()}
            🏁 Goal: ${goal.toArray()}
            📏 Distance: ${start.distanceTo(goal).toFixed(2)}
            ⏱️ Duration: ${duration.toFixed(2)}ms
            🗺️ World State: ${this.getWorldState()}
            🛡️ Fallback: Entity will remain stationary`);
        
        // Ultimate fallback: return null, entity stays in place
        return null;
    }

    private validatePath(path: Path): boolean {
        if (!path || !path.nodes || path.nodes.length === 0) {
            return false;
        }
        
        if (path.nodes.length > this.maxPathLength) {
            console.warn(`🤖 [AI:MEDIUM] Path too long: ${path.nodes.length} nodes`);
            return false;
        }
        
        // Check for path validity
        for (let i = 0; i < path.nodes.length - 1; i++) {
            if (!this.isValidPathSegment(path.nodes[i], path.nodes[i + 1])) {
                console.warn(`🤖 [AI:MEDIUM] Invalid path segment at index ${i}`);
                return false;
            }
        }
        
        return true;
    }
}
```

## AI State Machine Error Handling

Robust state machine with error recovery:

```typescript
class AIStateMachine {
    private stateTransitionTimeout = 1000; // ms
    private maxConsecutiveFailures = 3;
    private stateFailures = new Map<string, number>();

    public transitionToState(newState: string, context: AIContext): boolean {
        const currentState = this.currentState;
        const startTime = performance.now();
        
        try {
            // Validate state transition
            if (!this.isValidTransition(currentState, newState)) {
                throw new Error(`Invalid state transition: ${currentState} -> ${newState}`);
            }
            
            // Execute state exit logic
            this.executeStateExit(currentState, context);
            
            // Perform transition
            this.currentState = newState;
            
            // Execute state entry logic
            this.executeStateEntry(newState, context);
            
            // Validate new state
            if (!this.validateCurrentState(context)) {
                throw new Error(`State validation failed for: ${newState}`);
            }
            
            // Reset failure count for successful transition
            this.stateFailures.set(newState, 0);
            
            const duration = performance.now() - startTime;
            console.log(`🤖 [AI:DEBUG] State transition: ${currentState} -> ${newState} (${duration.toFixed(2)}ms)`);
            
            return true;
            
        } catch (error) {
            return this.handleStateTransitionError(error, currentState, newState, context, startTime);
        }
    }

    private handleStateTransitionError(
        error: Error, 
        fromState: string, 
        toState: string, 
        context: AIContext, 
        startTime: number
    ): boolean {
        const duration = performance.now() - startTime;
        const failures = (this.stateFailures.get(toState) || 0) + 1;
        this.stateFailures.set(toState, failures);
        
        console.error(`🤖 [AI:HIGH] State transition failed:
            ❌ Error: ${error.message}
            🔄 Transition: ${fromState} -> ${toState}
            🎯 Entity: ${context.entityId}
            📊 Context: ${this.summarizeContext(context)}
            🔢 Failures: ${failures}/${this.maxConsecutiveFailures}
            ⏱️ Duration: ${duration.toFixed(2)}ms
            🛡️ Recovery: ${this.getRecoveryStrategy(failures, toState)}`);
        
        if (failures >= this.maxConsecutiveFailures) {
            console.error(`🤖 [AI:CRITICAL] Max state failures reached for ${toState} - forcing safe state`);
            this.forceSafeState(context);
            return false;
        }
        
        // Try to revert to previous state
        return this.revertToPreviousState(context);
    }

    private forceSafeState(context: AIContext): void {
        try {
            this.currentState = 'idle';
            this.executeStateEntry('idle', context);
            console.warn(`🤖 [AI:MEDIUM] Forced transition to safe state: idle`);
        } catch (error) {
            console.error(`🤖 [AI:CRITICAL] Failed to transition to safe state: ${error.message}`);
            // Ultimate fallback: disable AI for this entity
            this.disableAI(context.entityId);
        }
    }
}
```

## AI Performance Monitoring

Monitor AI performance and adjust behavior:

```typescript
class AIPerformanceMonitor {
    private performanceMetrics = new Map<string, AIMetrics>();
    private performanceThresholds = {
        decisionTime: 50, // ms
        pathfindingTime: 100, // ms
        updateFrequency: 60 // fps
    };

    public monitorAIPerformance(): void {
        setInterval(() => {
            for (const [entityId, metrics] of this.performanceMetrics) {
                this.analyzeAIPerformance(entityId, metrics);
            }
        }, 5000); // Check every 5 seconds
    }

    private analyzeAIPerformance(entityId: string, metrics: AIMetrics): void {
        const issues: string[] = [];
        
        if (metrics.averageDecisionTime > this.performanceThresholds.decisionTime) {
            issues.push(`Slow decisions (${metrics.averageDecisionTime.toFixed(2)}ms)`);
        }
        
        if (metrics.pathfindingFailureRate > 0.1) {
            issues.push(`High pathfinding failures (${(metrics.pathfindingFailureRate * 100).toFixed(1)}%)`);
        }
        
        if (metrics.stateTransitionErrors > 5) {
            issues.push(`State transition errors (${metrics.stateTransitionErrors})`);
        }
        
        if (issues.length > 0) {
            console.warn(`🤖 [AI:PERFORMANCE] Performance issues detected:
                Entity: ${entityId}
                Issues: ${issues.join(', ')}
                Decisions/sec: ${metrics.decisionsPerSecond.toFixed(2)}
                CPU Usage: ${metrics.cpuUsage.toFixed(2)}%
                Action: ${this.getPerformanceAction(issues.length)}`);
            
            this.optimizeAIPerformance(entityId, issues);
        }
    }

    private optimizeAIPerformance(entityId: string, issues: string[]): void {
        if (issues.length > 2) {
            // Reduce AI update frequency
            this.reduceAIUpdateFrequency(entityId);
        }
        
        if (issues.includes('Slow decisions')) {
            // Simplify decision-making process
            this.simplifyDecisionMaking(entityId);
        }
        
        if (issues.includes('High pathfinding failures')) {
            // Use simpler pathfinding
            this.enableSimplePathfinding(entityId);
        }
    }
}
```

This comprehensive AI error handling system ensures stable AI behavior with detailed performance monitoring and multiple fallback strategies for rapid issue identification and resolution.
# AI System Error Handling

Specialized error handling for AI systems, NPC behavior, pathfinding, and decision-making algorithms.

## AI Error Categories

```typescript
enum AIErrorType {
    DECISION_TIMEOUT = "DECISION_TIMEOUT",
    PATHFINDING_FAILURE = "PATHFINDING_FAILURE",
    BEHAVIOR_TREE_ERROR = "BEHAVIOR_TREE_ERROR",
    STATE_MACHINE_INVALID = "STATE_MACHINE_INVALID",
    GOAL_UNREACHABLE = "GOAL_UNREACHABLE",
    RESOURCE_EXHAUSTION = "RESOURCE_EXHAUSTION",
    INFINITE_LOOP = "INFINITE_LOOP",
    INVALID_TARGET = "INVALID_TARGET",
    AI_DEADLOCK = "AI_DEADLOCK"
}

enum AIErrorSeverity {
    GAME_BREAKING = "GAME_BREAKING",    // AI completely fails, breaks gameplay
    BEHAVIOR_BROKEN = "BEHAVIOR_BROKEN", // AI behavior broken, but game continues
    PERFORMANCE_IMPACT = "PERFORMANCE_IMPACT", // AI slow, affects performance
    MINOR_GLITCH = "MINOR_GLITCH"      // Minor AI issues, barely noticeable
}
```

## AI Decision Error Handling

All AI decision-making MUST implement timeout and fallback mechanisms:

```typescript
class AIDecisionMaker {
    private decisionTimeout = 100; // ms
    private maxDecisionAttempts = 3;

    public makeDecision(context: AIContext): AIDecision {
        const startTime = performance.now();
        let attempts = 0;
        
        try {
            while (attempts < this.maxDecisionAttempts) {
                attempts++;
                
                // Check for timeout
                if (performance.now() - startTime > this.decisionTimeout) {
                    throw new Error(`Decision timeout after ${this.decisionTimeout}ms`);
                }
                
                const decision = this.processDecision(context, attempts);
                
                // Validate decision
                if (this.validateDecision(decision, context)) {
                    if (attempts > 1) {
                        console.warn(`🤖 [AI:MEDIUM] Decision required ${attempts} attempts:
                            Context: ${this.summarizeContext(context)}
                            Decision: ${decision.type}
                            Duration: ${(performance.now() - startTime).toFixed(2)}ms`);
                    }
                    return decision;
                }
                
                console.warn(`🤖 [AI:MEDIUM] Invalid decision on attempt ${attempts}, retrying...`);
            }
            
            throw new Error(`Failed to make valid decision after ${attempts} attempts`);
            
        } catch (error) {
            return this.handleDecisionError(error, context, startTime, attempts);
        }
    }

    private handleDecisionError(error: Error, context: AIContext, startTime: number, attempts: number): AIDecision {
        const duration = performance.now() - startTime;
        
        console.error(`🤖 [AI:HIGH] Decision making failed:
            ❌ Error: ${error.message}
            🎯 Entity: ${context.entityId}
            📊 Context: ${this.summarizeContext(context)}
            🔄 Attempts: ${attempts}/${this.maxDecisionAttempts}
            ⏱️ Duration: ${duration.toFixed(2)}ms
            🧠 State: ${this.getAIState(context.entityId)}
            🛡️ Fallback: Using default behavior...`);
        
        // Execute fallback decision
        return this.getDefaultDecision(context);
    }

    private validateDecision(decision: AIDecision, context: AIContext): boolean {
        // Check if decision is executable
        if (!this.canExecuteDecision(decision, context)) {
            return false;
        }
        
        // Check for resource requirements
        if (!this.hasRequiredResources(decision, context)) {
            return false;
        }
        
        // Check for conflicts with other AI entities
        if (this.hasDecisionConflicts(decision, context)) {
            return false;
        }
        
        return true;
    }
}
```

## Pathfinding Error Recovery

Implement robust pathfinding with multiple fallback strategies:

```typescript
class AIPathfinder {
    private maxPathfindingTime = 50; // ms
    private maxPathLength = 1000; // nodes

    public findPath(start: Vector3, goal: Vector3, options: PathfindingOptions): Path | null {
        const startTime = performance.now();
        
        try {
            // Validate inputs
            this.validatePathfindingInputs(start, goal);
            
            // Primary pathfinding algorithm
            let path = this.aStarPathfinding(start, goal, options);
            
            if (!path) {
                // Fallback 1: Simplified pathfinding
                console.warn(`🤖 [AI:MEDIUM] Primary pathfinding failed, trying simplified approach:
                    Start: ${start.toArray()}
                    Goal: ${goal.toArray()}
                    Distance: ${start.distanceTo(goal).toFixed(2)}
                    Obstacles: ${this.countObstacles(start, goal)}`);
                
                path = this.simplifiedPathfinding(start, goal);
            }
            
            if (!path) {
                // Fallback 2: Direct line with obstacle avoidance
                console.warn(`🤖 [AI:MEDIUM] Simplified pathfinding failed, using direct navigation...`);
                path = this.directNavigation(start, goal);
            }
            
            // Validate path
            if (path && this.validatePath(path)) {
                const duration = performance.now() - startTime;
                if (duration > this.maxPathfindingTime * 0.8) {
                    console.warn(`🤖 [AI:PERFORMANCE] Slow pathfinding detected:
                        Duration: ${duration.toFixed(2)}ms
                        Path Length: ${path.nodes.length}
                        Complexity: ${this.calculatePathComplexity(path)}`);
                }
                return path;
            }
            
            throw new Error('All pathfinding methods failed');
            
        } catch (error) {
            return this.handlePathfindingError(error, start, goal, startTime);
        }
    }

    private handlePathfindingError(error: Error, start: Vector3, goal: Vector3, startTime: number): Path | null {
        const duration = performance.now() - startTime;
        
        console.error(`🤖 [AI:HIGH] Pathfinding completely failed:
            ❌ Error: ${error.message}
            🎯 Start: ${start.toArray()}
            🏁 Goal: ${goal.toArray()}
            📏 Distance: ${start.distanceTo(goal).toFixed(2)}
            ⏱️ Duration: ${duration.toFixed(2)}ms
            🗺️ World State: ${this.getWorldState()}
            🛡️ Fallback: Entity will remain stationary`);
        
        // Ultimate fallback: return null, entity stays in place
        return null;
    }

    private validatePath(path: Path): boolean {
        if (!path || !path.nodes || path.nodes.length === 0) {
            return false;
        }
        
        if (path.nodes.length > this.maxPathLength) {
            console.warn(`🤖 [AI:MEDIUM] Path too long: ${path.nodes.length} nodes`);
            return false;
        }
        
        // Check for path validity
        for (let i = 0; i < path.nodes.length - 1; i++) {
            if (!this.isValidPathSegment(path.nodes[i], path.nodes[i + 1])) {
                console.warn(`🤖 [AI:MEDIUM] Invalid path segment at index ${i}`);
                return false;
            }
        }
        
        return true;
    }
}
```

## AI State Machine Error Handling

Robust state machine with error recovery:

```typescript
class AIStateMachine {
    private stateTransitionTimeout = 1000; // ms
    private maxConsecutiveFailures = 3;
    private stateFailures = new Map<string, number>();

    public transitionToState(newState: string, context: AIContext): boolean {
        const currentState = this.currentState;
        const startTime = performance.now();
        
        try {
            // Validate state transition
            if (!this.isValidTransition(currentState, newState)) {
                throw new Error(`Invalid state transition: ${currentState} -> ${newState}`);
            }
            
            // Execute state exit logic
            this.executeStateExit(currentState, context);
            
            // Perform transition
            this.currentState = newState;
            
            // Execute state entry logic
            this.executeStateEntry(newState, context);
            
            // Validate new state
            if (!this.validateCurrentState(context)) {
                throw new Error(`State validation failed for: ${newState}`);
            }
            
            // Reset failure count for successful transition
            this.stateFailures.set(newState, 0);
            
            const duration = performance.now() - startTime;
            console.log(`🤖 [AI:DEBUG] State transition: ${currentState} -> ${newState} (${duration.toFixed(2)}ms)`);
            
            return true;
            
        } catch (error) {
            return this.handleStateTransitionError(error, currentState, newState, context, startTime);
        }
    }

    private handleStateTransitionError(
        error: Error, 
        fromState: string, 
        toState: string, 
        context: AIContext, 
        startTime: number
    ): boolean {
        const duration = performance.now() - startTime;
        const failures = (this.stateFailures.get(toState) || 0) + 1;
        this.stateFailures.set(toState, failures);
        
        console.error(`🤖 [AI:HIGH] State transition failed:
            ❌ Error: ${error.message}
            🔄 Transition: ${fromState} -> ${toState}
            🎯 Entity: ${context.entityId}
            📊 Context: ${this.summarizeContext(context)}
            🔢 Failures: ${failures}/${this.maxConsecutiveFailures}
            ⏱️ Duration: ${duration.toFixed(2)}ms
            🛡️ Recovery: ${this.getRecoveryStrategy(failures, toState)}`);
        
        if (failures >= this.maxConsecutiveFailures) {
            console.error(`🤖 [AI:CRITICAL] Max state failures reached for ${toState} - forcing safe state`);
            this.forceSafeState(context);
            return false;
        }
        
        // Try to revert to previous state
        return this.revertToPreviousState(context);
    }

    private forceSafeState(context: AIContext): void {
        try {
            this.currentState = 'idle';
            this.executeStateEntry('idle', context);
            console.warn(`🤖 [AI:MEDIUM] Forced transition to safe state: idle`);
        } catch (error) {
            console.error(`🤖 [AI:CRITICAL] Failed to transition to safe state: ${error.message}`);
            // Ultimate fallback: disable AI for this entity
            this.disableAI(context.entityId);
        }
    }
}
```

## AI Performance Monitoring

Monitor AI performance and adjust behavior:

```typescript
class AIPerformanceMonitor {
    private performanceMetrics = new Map<string, AIMetrics>();
    private performanceThresholds = {
        decisionTime: 50, // ms
        pathfindingTime: 100, // ms
        updateFrequency: 60 // fps
    };

    public monitorAIPerformance(): void {
        setInterval(() => {
            for (const [entityId, metrics] of this.performanceMetrics) {
                this.analyzeAIPerformance(entityId, metrics);
            }
        }, 5000); // Check every 5 seconds
    }

    private analyzeAIPerformance(entityId: string, metrics: AIMetrics): void {
        const issues: string[] = [];
        
        if (metrics.averageDecisionTime > this.performanceThresholds.decisionTime) {
            issues.push(`Slow decisions (${metrics.averageDecisionTime.toFixed(2)}ms)`);
        }
        
        if (metrics.pathfindingFailureRate > 0.1) {
            issues.push(`High pathfinding failures (${(metrics.pathfindingFailureRate * 100).toFixed(1)}%)`);
        }
        
        if (metrics.stateTransitionErrors > 5) {
            issues.push(`State transition errors (${metrics.stateTransitionErrors})`);
        }
        
        if (issues.length > 0) {
            console.warn(`🤖 [AI:PERFORMANCE] Performance issues detected:
                Entity: ${entityId}
                Issues: ${issues.join(', ')}
                Decisions/sec: ${metrics.decisionsPerSecond.toFixed(2)}
                CPU Usage: ${metrics.cpuUsage.toFixed(2)}%
                Action: ${this.getPerformanceAction(issues.length)}`);
            
            this.optimizeAIPerformance(entityId, issues);
        }
    }

    private optimizeAIPerformance(entityId: string, issues: string[]): void {
        if (issues.length > 2) {
            // Reduce AI update frequency
            this.reduceAIUpdateFrequency(entityId);
        }
        
        if (issues.includes('Slow decisions')) {
            // Simplify decision-making process
            this.simplifyDecisionMaking(entityId);
        }
        
        if (issues.includes('High pathfinding failures')) {
            // Use simpler pathfinding
            this.enableSimplePathfinding(entityId);
        }
    }
}
```

This comprehensive AI error handling system ensures stable AI behavior with detailed performance monitoring and multiple fallback strategies for rapid issue identification and resolution.

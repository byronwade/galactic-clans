"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_generators_planet-generator_tsx",{

/***/ "(app-pages-browser)/./src/shared/procgen/planet/planet-renderer.ts":
/*!******************************************************!*\
  !*** ./src/shared/procgen/planet/planet-renderer.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlanetRenderer: () => (/* binding */ PlanetRenderer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _planet_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./planet-types */ \"(app-pages-browser)/./src/shared/procgen/planet/planet-types.ts\");\n/**\n * @file planet-renderer.ts\n * @description Enhanced planet renderer with comprehensive planet type support\n * @version 4.0.0\n * @author Galactic Clans Development Team\n *\n * @purpose Renders scientifically accurate planets using the comprehensive planet type\n * system with enhanced visual features and performance optimizations.\n */ \n\n// Default configuration\nconst DEFAULT_CONFIG = {\n    radius: 3.0,\n    seed: Date.now(),\n    starDistance: 1.0,\n    starType: \"G\",\n    detailLevel: 2,\n    featureDensity: 0.7,\n    colorVariation: 0.8,\n    enableLOD: true,\n    maxFeatures: 50,\n    renderDistance: 100,\n    enableAtmosphere: true,\n    enableRings: true,\n    enableMoons: true,\n    enableSpecialEffects: true,\n    enableAdvancedLighting: true,\n    ambientIntensity: 0.4,\n    sunIntensity: 1.5\n};\nclass PlanetRenderer {\n    /**\n\t * Render a planet with the specified configuration\n\t */ async renderPlanet() {\n        let config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        if (this.isDisposed) {\n            throw new Error(\"PlanetRenderer has been disposed\");\n        }\n        const startTime = performance.now();\n        const finalConfig = {\n            ...DEFAULT_CONFIG,\n            ...config\n        };\n        try {\n            // Generate cache key\n            const cacheKey = this.generateCacheKey(finalConfig);\n            // Check cache first\n            const cachedMesh = this.renderCache.get(cacheKey);\n            if (cachedMesh && finalConfig.enableLOD) {\n                return this.createCachedResult(cachedMesh, finalConfig, startTime);\n            }\n            // Create new generator with seed\n            this.generator = new EnhancedPlanetGenerator(finalConfig.seed);\n            // Generate planet\n            const planetResult = this.generator.generatePlanet(finalConfig.planetClass, finalConfig.starDistance || 1.0, finalConfig.starType || \"G\");\n            // Apply render configuration overrides\n            this.applyRenderConfigOverrides(planetResult.config, finalConfig);\n            // Enhance the mesh with additional rendering features\n            await this.enhanceMeshForRendering(planetResult.mesh, planetResult.config, planetResult.planetType, finalConfig);\n            // Setup advanced lighting if enabled\n            if (finalConfig.enableAdvancedLighting) {\n                this.setupAdvancedLighting(planetResult.mesh, finalConfig);\n            }\n            // Cache the result\n            if (finalConfig.enableLOD) {\n                this.renderCache.set(cacheKey, planetResult.mesh.clone());\n                this.cleanupCache();\n            }\n            // Calculate render metadata\n            const metadata = this.calculateRenderMetadata(planetResult.mesh, startTime);\n            this.lastRenderTime = performance.now() - startTime;\n            return {\n                mesh: planetResult.mesh,\n                config: planetResult.config,\n                planetType: planetResult.planetType,\n                statistics: planetResult.statistics,\n                metadata\n            };\n        } catch (error) {\n            console.error(\"Planet rendering failed:\", error);\n            // Fallback to simple planet\n            return this.renderFallbackPlanet(finalConfig, startTime);\n        }\n    }\n    /**\n\t * Render a planet by specific type\n\t */ async renderPlanetByType(planetClass) {\n        let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        return this.renderPlanet({\n            ...config,\n            planetClass\n        });\n    }\n    /**\n\t * Render multiple planets for a solar system\n\t */ async renderSolarSystemPlanets(planetCount) {\n        let starType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"G\";\n        const planets = [];\n        for(let i = 0; i < planetCount; i++){\n            const distance = 0.5 + i * 0.8; // AU from star\n            const config = {\n                starDistance: distance,\n                starType,\n                seed: Date.now() + i * 1000,\n                detailLevel: Math.max(1, 4 - i)\n            };\n            // Select appropriate planet type based on distance\n            config.planetClass = this.selectPlanetTypeByDistance(distance, starType);\n            const planet = await this.renderPlanet(config);\n            planets.push(planet);\n        }\n        return planets;\n    }\n    /**\n\t * Get all available planet types\n\t */ getAvailablePlanetTypes() {\n        return Array.from(_planet_types__WEBPACK_IMPORTED_MODULE_0__.PLANET_TYPES.keys());\n    }\n    /**\n\t * Get planet type information\n\t */ getPlanetTypeInfo(planetClass) {\n        return (0,_planet_types__WEBPACK_IMPORTED_MODULE_0__.getPlanetTypeByClass)(planetClass);\n    }\n    /**\n\t * Update planet quality based on performance\n\t */ updateQuality(qualityLevel) {\n        // Quality level 0-5, where 5 is highest quality\n        const quality = Math.max(0, Math.min(5, qualityLevel));\n        // Update default configuration based on quality\n        DEFAULT_CONFIG.detailLevel = Math.max(1, Math.floor(quality + 1));\n        DEFAULT_CONFIG.featureDensity = 0.3 + quality * 0.1;\n        DEFAULT_CONFIG.maxFeatures = 20 + quality * 10;\n        DEFAULT_CONFIG.enableSpecialEffects = quality >= 3;\n        DEFAULT_CONFIG.enableAdvancedLighting = quality >= 4;\n    }\n    /**\n\t * Dispose of resources\n\t */ dispose() {\n        if (this.isDisposed) return;\n        // Clear cache and dispose meshes\n        for (const mesh of this.renderCache.values()){\n            this.disposeMesh(mesh);\n        }\n        this.renderCache.clear();\n        this.isDisposed = true;\n    }\n    // Private Methods\n    generateCacheKey(config) {\n        const keyParts = [\n            config.planetClass || \"random\",\n            config.seed || 0,\n            config.radius || 3,\n            config.detailLevel || 2,\n            config.starDistance || 1,\n            config.featureDensity || 0.7\n        ];\n        return keyParts.join(\"|\");\n    }\n    createCachedResult(mesh, config, startTime) {\n        const clonedMesh = mesh.clone();\n        // Create minimal metadata for cached result\n        const metadata = {\n            renderTime: performance.now() - startTime,\n            polyCount: this.calculatePolyCount(clonedMesh),\n            textureCount: 1,\n            featureCount: clonedMesh.children.length,\n            memoryUsage: 0,\n            qualityLevel: \"cached\"\n        };\n        return {\n            mesh: clonedMesh,\n            config: {},\n            planetType: {},\n            statistics: {},\n            metadata\n        };\n    }\n    applyRenderConfigOverrides(planetConfig, renderConfig) {\n        if (renderConfig.radius !== undefined) {\n            planetConfig.radius = renderConfig.radius;\n        }\n        if (renderConfig.featureDensity !== undefined) {\n            planetConfig.featureDensity = renderConfig.featureDensity;\n        }\n        if (renderConfig.colorVariation !== undefined) {\n            planetConfig.colorVariation = renderConfig.colorVariation;\n        }\n        // Override features based on render config\n        if (renderConfig.enableAtmosphere !== undefined) {\n            planetConfig.features.clouds = renderConfig.enableAtmosphere;\n        }\n        if (renderConfig.enableRings !== undefined) {\n            planetConfig.features.rings = renderConfig.enableRings;\n        }\n        if (renderConfig.enableMoons !== undefined && !renderConfig.enableMoons) {\n            planetConfig.features.moons = 0;\n        }\n    }\n    async enhanceMeshForRendering(mesh, config, planetType, renderConfig) {\n        // Apply LOD if enabled\n        if (renderConfig.enableLOD) {\n            this.applyLOD(mesh, renderConfig.renderDistance || 100);\n        }\n        // Limit features if necessary\n        if (renderConfig.maxFeatures && mesh.children.length > renderConfig.maxFeatures) {\n            this.limitFeatures(mesh, renderConfig.maxFeatures);\n        }\n        // Add advanced visual effects\n        if (renderConfig.enableSpecialEffects) {\n            await this.addAdvancedEffects(mesh, config, planetType);\n        }\n        // Optimize for performance\n        this.optimizeMeshForPerformance(mesh);\n    }\n    applyLOD(mesh, renderDistance) {\n        mesh.children.forEach((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_1__.Mesh) {\n                // Create LOD versions\n                const lod = new three__WEBPACK_IMPORTED_MODULE_1__.LOD();\n                // High detail (close)\n                lod.addLevel(child, 0);\n                // Medium detail\n                const mediumGeometry = this.simplifyGeometry(child.geometry, 0.5);\n                const mediumMesh = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(mediumGeometry, child.material);\n                lod.addLevel(mediumMesh, renderDistance * 0.3);\n                // Low detail (far)\n                const lowGeometry = this.simplifyGeometry(child.geometry, 0.2);\n                const lowMesh = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(lowGeometry, child.material);\n                lod.addLevel(lowMesh, renderDistance * 0.7);\n                // Replace original mesh with LOD\n                const parent = child.parent;\n                if (parent) {\n                    parent.remove(child);\n                    parent.add(lod);\n                }\n            }\n        });\n    }\n    simplifyGeometry(geometry, factor) {\n        // Simple geometry simplification\n        const positions = geometry.attributes.position.array;\n        const simplified = new Float32Array(Math.floor(positions.length * factor));\n        for(let i = 0; i < simplified.length; i += 3){\n            const sourceIndex = Math.floor(i / factor) * 3;\n            simplified[i] = positions[sourceIndex];\n            simplified[i + 1] = positions[sourceIndex + 1];\n            simplified[i + 2] = positions[sourceIndex + 2];\n        }\n        const simplifiedGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry();\n        simplifiedGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_1__.BufferAttribute(simplified, 3));\n        simplifiedGeometry.computeVertexNormals();\n        return simplifiedGeometry;\n    }\n    limitFeatures(mesh, maxFeatures) {\n        while(mesh.children.length > maxFeatures){\n            const randomIndex = Math.floor(Math.random() * mesh.children.length);\n            const child = mesh.children[randomIndex];\n            mesh.remove(child);\n            this.disposeMesh(child);\n        }\n    }\n    async addAdvancedEffects(mesh, config, planetType) {\n        // Add particle effects for certain planet types\n        if (planetType.class === _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.LAVA_WORLD) {\n            this.addLavaParticles(mesh);\n        }\n        if (planetType.class === _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.GAS_GIANT) {\n            this.addAtmosphericStorms(mesh);\n        }\n        if (planetType.class === _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.ICE_GIANT) {\n            this.addIceShimmers(mesh);\n        }\n        // Add aurora effects for planets with magnetic fields\n        if (config.magneticField > 5) {\n            this.addAuroraEffect(mesh);\n        }\n    }\n    addLavaParticles(mesh) {\n        const particleCount = 100;\n        const particles = new three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry();\n        const positions = new Float32Array(particleCount * 3);\n        for(let i = 0; i < particleCount; i++){\n            positions[i * 3] = (Math.random() - 0.5) * 10;\n            positions[i * 3 + 1] = Math.random() * 5;\n            positions[i * 3 + 2] = (Math.random() - 0.5) * 10;\n        }\n        particles.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_1__.BufferAttribute(positions, 3));\n        const particleMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.PointsMaterial({\n            color: 0xff4500,\n            size: 0.1,\n            transparent: true,\n            opacity: 0.7\n        });\n        const particleSystem = new three__WEBPACK_IMPORTED_MODULE_1__.Points(particles, particleMaterial);\n        mesh.add(particleSystem);\n    }\n    addAtmosphericStorms(mesh) {\n        // Add storm spiral patterns\n        const stormGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.RingGeometry(2, 4, 8);\n        const stormMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            color: 0x4169e1,\n            transparent: true,\n            opacity: 0.3,\n            side: three__WEBPACK_IMPORTED_MODULE_1__.DoubleSide\n        });\n        for(let i = 0; i < 3; i++){\n            const storm = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(stormGeometry, stormMaterial);\n            storm.position.set((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8);\n            storm.rotation.x = Math.random() * Math.PI;\n            storm.rotation.y = Math.random() * Math.PI;\n            mesh.add(storm);\n        }\n    }\n    addIceShimmers(mesh) {\n        const shimmerGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry(1, 16, 16);\n        const shimmerMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            color: 0x87ceeb,\n            transparent: true,\n            opacity: 0.2,\n            side: three__WEBPACK_IMPORTED_MODULE_1__.BackSide\n        });\n        const shimmer = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(shimmerGeometry, shimmerMaterial);\n        mesh.add(shimmer);\n    }\n    addAuroraEffect(mesh) {\n        const auroraGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.RingGeometry(3, 5, 32);\n        const auroraMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            color: 0x00ff7f,\n            transparent: true,\n            opacity: 0.4,\n            side: three__WEBPACK_IMPORTED_MODULE_1__.DoubleSide\n        });\n        const aurora = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(auroraGeometry, auroraMaterial);\n        aurora.rotation.x = Math.PI / 2;\n        mesh.add(aurora);\n    }\n    optimizeMeshForPerformance(mesh) {\n        mesh.traverse((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_1__.Mesh) {\n                // Enable frustum culling\n                child.frustumCulled = true;\n                // Merge geometries where possible\n                if (child.geometry instanceof three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry) {\n                    child.geometry.computeBoundingSphere();\n                    child.geometry.computeBoundingBox();\n                }\n                // Optimize materials\n                if (child.material instanceof three__WEBPACK_IMPORTED_MODULE_1__.Material) {\n                    child.material.precision = \"mediump\";\n                }\n            }\n        });\n    }\n    setupAdvancedLighting(mesh, config) {\n        // This would typically be handled by the scene, but we can add object-specific lighting\n        // Add ambient light for atmosphere\n        const ambientLight = new three__WEBPACK_IMPORTED_MODULE_1__.AmbientLight(0x404040, config.ambientIntensity || 0.4);\n        mesh.add(ambientLight);\n        // Add directional light for sun\n        const sunLight = new three__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(0xffffff, config.sunIntensity || 1.5);\n        sunLight.position.set(10, 10, 10);\n        sunLight.castShadow = true;\n        mesh.add(sunLight);\n        // Add subtle rim lighting\n        const rimLight = new three__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(0x87ceeb, 0.3);\n        rimLight.position.set(-10, 5, -10);\n        mesh.add(rimLight);\n    }\n    selectPlanetTypeByDistance(distance, starType) {\n        // Select planet type based on distance from star\n        if (distance < 0.5) {\n            return Math.random() < 0.7 ? _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.LAVA_WORLD : _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.IRON_WORLD;\n        } else if (distance < 1.5) {\n            return Math.random() < 0.6 ? _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.TERRESTRIAL : _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.SUPER_EARTH;\n        } else if (distance < 3.0) {\n            return Math.random() < 0.4 ? _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.OCEAN_WORLD : _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.TERRESTRIAL;\n        } else if (distance < 8.0) {\n            return Math.random() < 0.7 ? _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.GAS_GIANT : _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.ICE_GIANT;\n        } else {\n            return Math.random() < 0.8 ? _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.ICE_GIANT : _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.DWARF_PLANET;\n        }\n    }\n    renderFallbackPlanet(config, startTime) {\n        var _geometry_faces;\n        // Create a simple fallback planet\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_1__.IcosahedronGeometry(config.radius || 3, 1);\n        const material = new three__WEBPACK_IMPORTED_MODULE_1__.MeshPhongMaterial({\n            color: 0x888888\n        });\n        const mesh = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(geometry, material);\n        const group = new three__WEBPACK_IMPORTED_MODULE_1__.Group();\n        group.add(mesh);\n        const metadata = {\n            renderTime: performance.now() - startTime,\n            polyCount: ((_geometry_faces = geometry.faces) === null || _geometry_faces === void 0 ? void 0 : _geometry_faces.length) || 20,\n            textureCount: 0,\n            featureCount: 1,\n            memoryUsage: 0,\n            qualityLevel: \"fallback\"\n        };\n        return {\n            mesh: group,\n            config: {},\n            planetType: {},\n            statistics: {},\n            metadata\n        };\n    }\n    calculateRenderMetadata(mesh, startTime) {\n        let polyCount = 0;\n        let textureCount = 0;\n        let memoryUsage = 0;\n        mesh.traverse((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_1__.Mesh) {\n                if (child.geometry instanceof three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry) {\n                    const positions = child.geometry.attributes.position;\n                    if (positions) {\n                        polyCount += positions.count / 3;\n                    }\n                }\n                if (child.material instanceof three__WEBPACK_IMPORTED_MODULE_1__.Material) {\n                    textureCount++;\n                    // Estimate memory usage (very rough)\n                    memoryUsage += 1024; // 1KB per material estimate\n                }\n            }\n        });\n        return {\n            renderTime: performance.now() - startTime,\n            polyCount: Math.floor(polyCount),\n            textureCount,\n            featureCount: mesh.children.length,\n            memoryUsage,\n            qualityLevel: this.determineQualityLevel(polyCount, textureCount)\n        };\n    }\n    determineQualityLevel(polyCount, textureCount) {\n        if (polyCount > 10000) return \"ultra\";\n        if (polyCount > 5000) return \"high\";\n        if (polyCount > 2000) return \"medium\";\n        if (polyCount > 500) return \"low\";\n        return \"minimal\";\n    }\n    calculatePolyCount(mesh) {\n        let count = 0;\n        mesh.traverse((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_1__.Mesh && child.geometry instanceof three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry) {\n                const positions = child.geometry.attributes.position;\n                if (positions) {\n                    count += positions.count / 3;\n                }\n            }\n        });\n        return Math.floor(count);\n    }\n    disposeMesh(object) {\n        object.traverse((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_1__.Mesh) {\n                if (child.geometry) {\n                    child.geometry.dispose();\n                }\n                if (child.material) {\n                    if (Array.isArray(child.material)) {\n                        child.material.forEach((material)=>material.dispose());\n                    } else {\n                        child.material.dispose();\n                    }\n                }\n            }\n        });\n    }\n    cleanupCache() {\n        // Keep cache size reasonable\n        if (this.renderCache.size > 10) {\n            const firstKey = this.renderCache.keys().next().value;\n            const mesh = this.renderCache.get(firstKey);\n            if (mesh) {\n                this.disposeMesh(mesh);\n            }\n            this.renderCache.delete(firstKey);\n        }\n    }\n    // Public utility methods\n    /**\n\t * Get performance statistics\n\t */ getPerformanceStats() {\n        return {\n            lastRenderTime: this.lastRenderTime,\n            cacheSize: this.renderCache.size\n        };\n    }\n    /**\n\t * Clear render cache\n\t */ clearCache() {\n        for (const mesh of this.renderCache.values()){\n            this.disposeMesh(mesh);\n        }\n        this.renderCache.clear();\n    }\n    /**\n\t * Preload common planet types\n\t */ async preloadCommonTypes() {\n        const commonTypes = [\n            _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.TERRESTRIAL,\n            _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.GAS_GIANT,\n            _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.ICE_GIANT,\n            _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.OCEAN_WORLD\n        ];\n        const promises = commonTypes.map((type)=>this.renderPlanet({\n                planetClass: type,\n                detailLevel: 1,\n                enableSpecialEffects: false\n            }));\n        await Promise.all(promises);\n    }\n    constructor(){\n        this.isDisposed = false;\n        this.renderCache = new Map();\n        this.lastRenderTime = 0;\n    // Initialize renderer\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zaGFyZWQvcHJvY2dlbi9wbGFuZXQvcGxhbmV0LXJlbmRlcmVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7OztDQVFDLEdBRThCO0FBQ2tGO0FBb0NqSCx3QkFBd0I7QUFDeEIsTUFBTUksaUJBQXFDO0lBQzFDQyxRQUFRO0lBQ1JDLE1BQU1DLEtBQUtDLEdBQUc7SUFDZEMsY0FBYztJQUNkQyxVQUFVO0lBQ1ZDLGFBQWE7SUFDYkMsZ0JBQWdCO0lBQ2hCQyxnQkFBZ0I7SUFDaEJDLFdBQVc7SUFDWEMsYUFBYTtJQUNiQyxnQkFBZ0I7SUFDaEJDLGtCQUFrQjtJQUNsQkMsYUFBYTtJQUNiQyxhQUFhO0lBQ2JDLHNCQUFzQjtJQUN0QkMsd0JBQXdCO0lBQ3hCQyxrQkFBa0I7SUFDbEJDLGNBQWM7QUFDZjtBQW9DTyxNQUFNQztJQVNaOztFQUVDLEdBQ0QsTUFBYUMsZUFBMkU7WUFBOURDLFNBQUFBLGlFQUE2QixDQUFDO1FBQ3ZELElBQUksSUFBSSxDQUFDQyxVQUFVLEVBQUU7WUFDcEIsTUFBTSxJQUFJQyxNQUFNO1FBQ2pCO1FBRUEsTUFBTUMsWUFBWUMsWUFBWXRCLEdBQUc7UUFDakMsTUFBTXVCLGNBQWM7WUFBRSxHQUFHM0IsY0FBYztZQUFFLEdBQUdzQixNQUFNO1FBQUM7UUFFbkQsSUFBSTtZQUNILHFCQUFxQjtZQUNyQixNQUFNTSxXQUFXLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNGO1lBRXZDLG9CQUFvQjtZQUNwQixNQUFNRyxhQUFhLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxHQUFHLENBQUNKO1lBQ3hDLElBQUlFLGNBQWNILFlBQVlqQixTQUFTLEVBQUU7Z0JBQ3hDLE9BQU8sSUFBSSxDQUFDdUIsa0JBQWtCLENBQUNILFlBQVlILGFBQWFGO1lBQ3pEO1lBRUEsaUNBQWlDO1lBQ2pDLElBQUksQ0FBQ1MsU0FBUyxHQUFHLElBQUlDLHdCQUF3QlIsWUFBWXpCLElBQUk7WUFFN0Qsa0JBQWtC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LENBQUM7Z0JBQ2pCaUIsYUFBYXlLO2dCQUNieE0sYUFBYTtnQkFDYlMsc0JBQXNCO1lBQ3ZCO1FBR0QsTUFBTWdNLFFBQVFDLEdBQUcsQ0FBQ0o7SUFDbkI7SUF4akJBLGFBQWM7YUFKTnRMLGFBQXNCO2FBQ3RCUSxjQUF3QyxJQUFJbUw7YUFDNUNqSyxpQkFBeUI7SUFHaEMsc0JBQXNCO0lBQ3ZCO0FBdWpCRCIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvc3JjL3NoYXJlZC9wcm9jZ2VuL3BsYW5ldC9wbGFuZXQtcmVuZGVyZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBwbGFuZXQtcmVuZGVyZXIudHNcbiAqIEBkZXNjcmlwdGlvbiBFbmhhbmNlZCBwbGFuZXQgcmVuZGVyZXIgd2l0aCBjb21wcmVoZW5zaXZlIHBsYW5ldCB0eXBlIHN1cHBvcnRcbiAqIEB2ZXJzaW9uIDQuMC4wXG4gKiBAYXV0aG9yIEdhbGFjdGljIENsYW5zIERldmVsb3BtZW50IFRlYW1cbiAqXG4gKiBAcHVycG9zZSBSZW5kZXJzIHNjaWVudGlmaWNhbGx5IGFjY3VyYXRlIHBsYW5ldHMgdXNpbmcgdGhlIGNvbXByZWhlbnNpdmUgcGxhbmV0IHR5cGVcbiAqIHN5c3RlbSB3aXRoIGVuaGFuY2VkIHZpc3VhbCBmZWF0dXJlcyBhbmQgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9ucy5cbiAqL1xuXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IFBsYW5ldENsYXNzLCBCaW9tZVR5cGUsIGdldFBsYW5ldFR5cGVCeUNsYXNzLCBnZXRSYW5kb21QbGFuZXRUeXBlLCBQTEFORVRfVFlQRVMgfSBmcm9tIFwiLi9wbGFuZXQtdHlwZXNcIjtcbmltcG9ydCB0eXBlIHsgUGxhbmV0VHlwZURlZmluaXRpb24gfSBmcm9tIFwiLi9wbGFuZXQtdHlwZXNcIjtcblxuLy8gUGxhbmV0IFJlbmRlcmluZyBDb25maWd1cmF0aW9uXG5leHBvcnQgaW50ZXJmYWNlIFBsYW5ldFJlbmRlckNvbmZpZyB7XG5cdC8vIEJhc2ljIFByb3BlcnRpZXNcblx0cGxhbmV0Q2xhc3M/OiBQbGFuZXRDbGFzcztcblx0cmFkaXVzPzogbnVtYmVyO1xuXHRzZWVkPzogbnVtYmVyO1xuXG5cdC8vIE9yYml0YWwgUHJvcGVydGllc1xuXHRzdGFyRGlzdGFuY2U/OiBudW1iZXI7XG5cdHN0YXJUeXBlPzogc3RyaW5nO1xuXG5cdC8vIFZpc3VhbCBRdWFsaXR5XG5cdGRldGFpbExldmVsPzogbnVtYmVyO1xuXHRmZWF0dXJlRGVuc2l0eT86IG51bWJlcjtcblx0Y29sb3JWYXJpYXRpb24/OiBudW1iZXI7XG5cblx0Ly8gUGVyZm9ybWFuY2UgT3B0aW9uc1xuXHRlbmFibGVMT0Q/OiBib29sZWFuO1xuXHRtYXhGZWF0dXJlcz86IG51bWJlcjtcblx0cmVuZGVyRGlzdGFuY2U/OiBudW1iZXI7XG5cblx0Ly8gU3BlY2lhbCBGZWF0dXJlc1xuXHRlbmFibGVBdG1vc3BoZXJlPzogYm9vbGVhbjtcblx0ZW5hYmxlUmluZ3M/OiBib29sZWFuO1xuXHRlbmFibGVNb29ucz86IGJvb2xlYW47XG5cdGVuYWJsZVNwZWNpYWxFZmZlY3RzPzogYm9vbGVhbjtcblxuXHQvLyBMaWdodGluZ1xuXHRlbmFibGVBZHZhbmNlZExpZ2h0aW5nPzogYm9vbGVhbjtcblx0YW1iaWVudEludGVuc2l0eT86IG51bWJlcjtcblx0c3VuSW50ZW5zaXR5PzogbnVtYmVyO1xufVxuXG4vLyBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbmNvbnN0IERFRkFVTFRfQ09ORklHOiBQbGFuZXRSZW5kZXJDb25maWcgPSB7XG5cdHJhZGl1czogMy4wLFxuXHRzZWVkOiBEYXRlLm5vdygpLFxuXHRzdGFyRGlzdGFuY2U6IDEuMCxcblx0c3RhclR5cGU6IFwiR1wiLFxuXHRkZXRhaWxMZXZlbDogMixcblx0ZmVhdHVyZURlbnNpdHk6IDAuNyxcblx0Y29sb3JWYXJpYXRpb246IDAuOCxcblx0ZW5hYmxlTE9EOiB0cnVlLFxuXHRtYXhGZWF0dXJlczogNTAsXG5cdHJlbmRlckRpc3RhbmNlOiAxMDAsXG5cdGVuYWJsZUF0bW9zcGhlcmU6IHRydWUsXG5cdGVuYWJsZVJpbmdzOiB0cnVlLFxuXHRlbmFibGVNb29uczogdHJ1ZSxcblx0ZW5hYmxlU3BlY2lhbEVmZmVjdHM6IHRydWUsXG5cdGVuYWJsZUFkdmFuY2VkTGlnaHRpbmc6IHRydWUsXG5cdGFtYmllbnRJbnRlbnNpdHk6IDAuNCxcblx0c3VuSW50ZW5zaXR5OiAxLjUsXG59O1xuXG4vLyBFbmhhbmNlZCBQbGFuZXQgQ29uZmlndXJhdGlvbiAoaW50ZWdyYXRlZCBmcm9tIGRlbGV0ZWQgZmlsZXMpXG5leHBvcnQgaW50ZXJmYWNlIEVuaGFuY2VkUGxhbmV0Q29uZmlnIHtcblx0cmFkaXVzOiBudW1iZXI7XG5cdHNlZWQ6IG51bWJlcjtcblx0ZGV0YWlsTGV2ZWw6IG51bWJlcjtcblx0ZmVhdHVyZURlbnNpdHk6IG51bWJlcjtcblx0Y29sb3JWYXJpYXRpb246IG51bWJlcjtcblx0ZW5hYmxlQXRtb3NwaGVyZTogYm9vbGVhbjtcblx0ZW5hYmxlUmluZ3M6IGJvb2xlYW47XG5cdGVuYWJsZU1vb25zOiBib29sZWFuO1xuXHRlbmFibGVTcGVjaWFsRWZmZWN0czogYm9vbGVhbjtcblx0YW1iaWVudEludGVuc2l0eTogbnVtYmVyO1xuXHRzdW5JbnRlbnNpdHk6IG51bWJlcjtcbn1cblxuLy8gUGxhbmV0IFJlbmRlciBSZXN1bHRcbmV4cG9ydCBpbnRlcmZhY2UgUGxhbmV0UmVuZGVyUmVzdWx0IHtcblx0bWVzaDogVEhSRUUuR3JvdXA7XG5cdGNvbmZpZzogRW5oYW5jZWRQbGFuZXRDb25maWc7XG5cdHBsYW5ldFR5cGU6IFBsYW5ldFR5cGVEZWZpbml0aW9uO1xuXHRzdGF0aXN0aWNzOiBhbnk7XG5cdG1ldGFkYXRhOiBQbGFuZXRSZW5kZXJNZXRhZGF0YTtcbn1cblxuLy8gUmVuZGVyIE1ldGFkYXRhXG5leHBvcnQgaW50ZXJmYWNlIFBsYW5ldFJlbmRlck1ldGFkYXRhIHtcblx0cmVuZGVyVGltZTogbnVtYmVyO1xuXHRwb2x5Q291bnQ6IG51bWJlcjtcblx0dGV4dHVyZUNvdW50OiBudW1iZXI7XG5cdGZlYXR1cmVDb3VudDogbnVtYmVyO1xuXHRtZW1vcnlVc2FnZTogbnVtYmVyO1xuXHRxdWFsaXR5TGV2ZWw6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFBsYW5ldFJlbmRlcmVyIHtcblx0cHJpdmF0ZSBpc0Rpc3Bvc2VkOiBib29sZWFuID0gZmFsc2U7XG5cdHByaXZhdGUgcmVuZGVyQ2FjaGU6IE1hcDxzdHJpbmcsIFRIUkVFLkdyb3VwPiA9IG5ldyBNYXAoKTtcblx0cHJpdmF0ZSBsYXN0UmVuZGVyVGltZTogbnVtYmVyID0gMDtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHQvLyBJbml0aWFsaXplIHJlbmRlcmVyXG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVyIGEgcGxhbmV0IHdpdGggdGhlIHNwZWNpZmllZCBjb25maWd1cmF0aW9uXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgcmVuZGVyUGxhbmV0KGNvbmZpZzogUGxhbmV0UmVuZGVyQ29uZmlnID0ge30pOiBQcm9taXNlPFBsYW5ldFJlbmRlclJlc3VsdD4ge1xuXHRcdGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBsYW5ldFJlbmRlcmVyIGhhcyBiZWVuIGRpc3Bvc2VkXCIpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdGNvbnN0IGZpbmFsQ29uZmlnID0geyAuLi5ERUZBVUxUX0NPTkZJRywgLi4uY29uZmlnIH07XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gR2VuZXJhdGUgY2FjaGUga2V5XG5cdFx0XHRjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2VuZXJhdGVDYWNoZUtleShmaW5hbENvbmZpZyk7XG5cblx0XHRcdC8vIENoZWNrIGNhY2hlIGZpcnN0XG5cdFx0XHRjb25zdCBjYWNoZWRNZXNoID0gdGhpcy5yZW5kZXJDYWNoZS5nZXQoY2FjaGVLZXkpO1xuXHRcdFx0aWYgKGNhY2hlZE1lc2ggJiYgZmluYWxDb25maWcuZW5hYmxlTE9EKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUNhY2hlZFJlc3VsdChjYWNoZWRNZXNoLCBmaW5hbENvbmZpZywgc3RhcnRUaW1lKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ3JlYXRlIG5ldyBnZW5lcmF0b3Igd2l0aCBzZWVkXG5cdFx0XHR0aGlzLmdlbmVyYXRvciA9IG5ldyBFbmhhbmNlZFBsYW5ldEdlbmVyYXRvcihmaW5hbENvbmZpZy5zZWVkKTtcblxuXHRcdFx0Ly8gR2VuZXJhdGUgcGxhbmV0XG5cdFx0XHRjb25zdCBwbGFuZXRSZXN1bHQgPSB0aGlzLmdlbmVyYXRvci5nZW5lcmF0ZVBsYW5ldChmaW5hbENvbmZpZy5wbGFuZXRDbGFzcywgZmluYWxDb25maWcuc3RhckRpc3RhbmNlIHx8IDEuMCwgZmluYWxDb25maWcuc3RhclR5cGUgfHwgXCJHXCIpO1xuXG5cdFx0XHQvLyBBcHBseSByZW5kZXIgY29uZmlndXJhdGlvbiBvdmVycmlkZXNcblx0XHRcdHRoaXMuYXBwbHlSZW5kZXJDb25maWdPdmVycmlkZXMocGxhbmV0UmVzdWx0LmNvbmZpZywgZmluYWxDb25maWcpO1xuXG5cdFx0XHQvLyBFbmhhbmNlIHRoZSBtZXNoIHdpdGggYWRkaXRpb25hbCByZW5kZXJpbmcgZmVhdHVyZXNcblx0XHRcdGF3YWl0IHRoaXMuZW5oYW5jZU1lc2hGb3JSZW5kZXJpbmcocGxhbmV0UmVzdWx0Lm1lc2gsIHBsYW5ldFJlc3VsdC5jb25maWcsIHBsYW5ldFJlc3VsdC5wbGFuZXRUeXBlLCBmaW5hbENvbmZpZyk7XG5cblx0XHRcdC8vIFNldHVwIGFkdmFuY2VkIGxpZ2h0aW5nIGlmIGVuYWJsZWRcblx0XHRcdGlmIChmaW5hbENvbmZpZy5lbmFibGVBZHZhbmNlZExpZ2h0aW5nKSB7XG5cdFx0XHRcdHRoaXMuc2V0dXBBZHZhbmNlZExpZ2h0aW5nKHBsYW5ldFJlc3VsdC5tZXNoLCBmaW5hbENvbmZpZyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhY2hlIHRoZSByZXN1bHRcblx0XHRcdGlmIChmaW5hbENvbmZpZy5lbmFibGVMT0QpIHtcblx0XHRcdFx0dGhpcy5yZW5kZXJDYWNoZS5zZXQoY2FjaGVLZXksIHBsYW5ldFJlc3VsdC5tZXNoLmNsb25lKCkpO1xuXHRcdFx0XHR0aGlzLmNsZWFudXBDYWNoZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxjdWxhdGUgcmVuZGVyIG1ldGFkYXRhXG5cdFx0XHRjb25zdCBtZXRhZGF0YSA9IHRoaXMuY2FsY3VsYXRlUmVuZGVyTWV0YWRhdGEocGxhbmV0UmVzdWx0Lm1lc2gsIHN0YXJ0VGltZSk7XG5cblx0XHRcdHRoaXMubGFzdFJlbmRlclRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bWVzaDogcGxhbmV0UmVzdWx0Lm1lc2gsXG5cdFx0XHRcdGNvbmZpZzogcGxhbmV0UmVzdWx0LmNvbmZpZyxcblx0XHRcdFx0cGxhbmV0VHlwZTogcGxhbmV0UmVzdWx0LnBsYW5ldFR5cGUsXG5cdFx0XHRcdHN0YXRpc3RpY3M6IHBsYW5ldFJlc3VsdC5zdGF0aXN0aWNzLFxuXHRcdFx0XHRtZXRhZGF0YSxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJQbGFuZXQgcmVuZGVyaW5nIGZhaWxlZDpcIiwgZXJyb3IpO1xuXG5cdFx0XHQvLyBGYWxsYmFjayB0byBzaW1wbGUgcGxhbmV0XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJGYWxsYmFja1BsYW5ldChmaW5hbENvbmZpZywgc3RhcnRUaW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVyIGEgcGxhbmV0IGJ5IHNwZWNpZmljIHR5cGVcblx0ICovXG5cdHB1YmxpYyBhc3luYyByZW5kZXJQbGFuZXRCeVR5cGUocGxhbmV0Q2xhc3M6IFBsYW5ldENsYXNzLCBjb25maWc6IFBsYW5ldFJlbmRlckNvbmZpZyA9IHt9KTogUHJvbWlzZTxQbGFuZXRSZW5kZXJSZXN1bHQ+IHtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJQbGFuZXQoeyAuLi5jb25maWcsIHBsYW5ldENsYXNzIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbmRlciBtdWx0aXBsZSBwbGFuZXRzIGZvciBhIHNvbGFyIHN5c3RlbVxuXHQgKi9cblx0cHVibGljIGFzeW5jIHJlbmRlclNvbGFyU3lzdGVtUGxhbmV0cyhwbGFuZXRDb3VudDogbnVtYmVyLCBzdGFyVHlwZTogc3RyaW5nID0gXCJHXCIpOiBQcm9taXNlPFBsYW5ldFJlbmRlclJlc3VsdFtdPiB7XG5cdFx0Y29uc3QgcGxhbmV0czogUGxhbmV0UmVuZGVyUmVzdWx0W10gPSBbXTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGxhbmV0Q291bnQ7IGkrKykge1xuXHRcdFx0Y29uc3QgZGlzdGFuY2UgPSAwLjUgKyBpICogMC44OyAvLyBBVSBmcm9tIHN0YXJcblx0XHRcdGNvbnN0IGNvbmZpZzogUGxhbmV0UmVuZGVyQ29uZmlnID0ge1xuXHRcdFx0XHRzdGFyRGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRzdGFyVHlwZSxcblx0XHRcdFx0c2VlZDogRGF0ZS5ub3coKSArIGkgKiAxMDAwLFxuXHRcdFx0XHRkZXRhaWxMZXZlbDogTWF0aC5tYXgoMSwgNCAtIGkpLCAvLyBDbG9zZXIgcGxhbmV0cyBnZXQgbW9yZSBkZXRhaWxcblx0XHRcdH07XG5cblx0XHRcdC8vIFNlbGVjdCBhcHByb3ByaWF0ZSBwbGFuZXQgdHlwZSBiYXNlZCBvbiBkaXN0YW5jZVxuXHRcdFx0Y29uZmlnLnBsYW5ldENsYXNzID0gdGhpcy5zZWxlY3RQbGFuZXRUeXBlQnlEaXN0YW5jZShkaXN0YW5jZSwgc3RhclR5cGUpO1xuXG5cdFx0XHRjb25zdCBwbGFuZXQgPSBhd2FpdCB0aGlzLnJlbmRlclBsYW5ldChjb25maWcpO1xuXHRcdFx0cGxhbmV0cy5wdXNoKHBsYW5ldCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBsYW5ldHM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGFsbCBhdmFpbGFibGUgcGxhbmV0IHR5cGVzXG5cdCAqL1xuXHRwdWJsaWMgZ2V0QXZhaWxhYmxlUGxhbmV0VHlwZXMoKTogUGxhbmV0Q2xhc3NbXSB7XG5cdFx0cmV0dXJuIEFycmF5LmZyb20oUExBTkVUX1RZUEVTLmtleXMoKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHBsYW5ldCB0eXBlIGluZm9ybWF0aW9uXG5cdCAqL1xuXHRwdWJsaWMgZ2V0UGxhbmV0VHlwZUluZm8ocGxhbmV0Q2xhc3M6IFBsYW5ldENsYXNzKTogUGxhbmV0VHlwZURlZmluaXRpb24gfCB1bmRlZmluZWQge1xuXHRcdHJldHVybiBnZXRQbGFuZXRUeXBlQnlDbGFzcyhwbGFuZXRDbGFzcyk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHBsYW5ldCBxdWFsaXR5IGJhc2VkIG9uIHBlcmZvcm1hbmNlXG5cdCAqL1xuXHRwdWJsaWMgdXBkYXRlUXVhbGl0eShxdWFsaXR5TGV2ZWw6IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIFF1YWxpdHkgbGV2ZWwgMC01LCB3aGVyZSA1IGlzIGhpZ2hlc3QgcXVhbGl0eVxuXHRcdGNvbnN0IHF1YWxpdHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbig1LCBxdWFsaXR5TGV2ZWwpKTtcblxuXHRcdC8vIFVwZGF0ZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYmFzZWQgb24gcXVhbGl0eVxuXHRcdERFRkFVTFRfQ09ORklHLmRldGFpbExldmVsID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihxdWFsaXR5ICsgMSkpO1xuXHRcdERFRkFVTFRfQ09ORklHLmZlYXR1cmVEZW5zaXR5ID0gMC4zICsgcXVhbGl0eSAqIDAuMTtcblx0XHRERUZBVUxUX0NPTkZJRy5tYXhGZWF0dXJlcyA9IDIwICsgcXVhbGl0eSAqIDEwO1xuXHRcdERFRkFVTFRfQ09ORklHLmVuYWJsZVNwZWNpYWxFZmZlY3RzID0gcXVhbGl0eSA+PSAzO1xuXHRcdERFRkFVTFRfQ09ORklHLmVuYWJsZUFkdmFuY2VkTGlnaHRpbmcgPSBxdWFsaXR5ID49IDQ7XG5cdH1cblxuXHQvKipcblx0ICogRGlzcG9zZSBvZiByZXNvdXJjZXNcblx0ICovXG5cdHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xuXHRcdGlmICh0aGlzLmlzRGlzcG9zZWQpIHJldHVybjtcblxuXHRcdC8vIENsZWFyIGNhY2hlIGFuZCBkaXNwb3NlIG1lc2hlc1xuXHRcdGZvciAoY29uc3QgbWVzaCBvZiB0aGlzLnJlbmRlckNhY2hlLnZhbHVlcygpKSB7XG5cdFx0XHR0aGlzLmRpc3Bvc2VNZXNoKG1lc2gpO1xuXHRcdH1cblx0XHR0aGlzLnJlbmRlckNhY2hlLmNsZWFyKCk7XG5cblx0XHR0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuXHR9XG5cblx0Ly8gUHJpdmF0ZSBNZXRob2RzXG5cblx0cHJpdmF0ZSBnZW5lcmF0ZUNhY2hlS2V5KGNvbmZpZzogUGxhbmV0UmVuZGVyQ29uZmlnKTogc3RyaW5nIHtcblx0XHRjb25zdCBrZXlQYXJ0cyA9IFtjb25maWcucGxhbmV0Q2xhc3MgfHwgXCJyYW5kb21cIiwgY29uZmlnLnNlZWQgfHwgMCwgY29uZmlnLnJhZGl1cyB8fCAzLCBjb25maWcuZGV0YWlsTGV2ZWwgfHwgMiwgY29uZmlnLnN0YXJEaXN0YW5jZSB8fCAxLCBjb25maWcuZmVhdHVyZURlbnNpdHkgfHwgMC43XTtcblxuXHRcdHJldHVybiBrZXlQYXJ0cy5qb2luKFwifFwiKTtcblx0fVxuXG5cdHByaXZhdGUgY3JlYXRlQ2FjaGVkUmVzdWx0KG1lc2g6IFRIUkVFLkdyb3VwLCBjb25maWc6IFBsYW5ldFJlbmRlckNvbmZpZywgc3RhcnRUaW1lOiBudW1iZXIpOiBQbGFuZXRSZW5kZXJSZXN1bHQge1xuXHRcdGNvbnN0IGNsb25lZE1lc2ggPSBtZXNoLmNsb25lKCk7XG5cblx0XHQvLyBDcmVhdGUgbWluaW1hbCBtZXRhZGF0YSBmb3IgY2FjaGVkIHJlc3VsdFxuXHRcdGNvbnN0IG1ldGFkYXRhOiBQbGFuZXRSZW5kZXJNZXRhZGF0YSA9IHtcblx0XHRcdHJlbmRlclRpbWU6IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lLFxuXHRcdFx0cG9seUNvdW50OiB0aGlzLmNhbGN1bGF0ZVBvbHlDb3VudChjbG9uZWRNZXNoKSxcblx0XHRcdHRleHR1cmVDb3VudDogMSxcblx0XHRcdGZlYXR1cmVDb3VudDogY2xvbmVkTWVzaC5jaGlsZHJlbi5sZW5ndGgsXG5cdFx0XHRtZW1vcnlVc2FnZTogMCxcblx0XHRcdHF1YWxpdHlMZXZlbDogXCJjYWNoZWRcIixcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG1lc2g6IGNsb25lZE1lc2gsXG5cdFx0XHRjb25maWc6IHt9IGFzIEVuaGFuY2VkUGxhbmV0Q29uZmlnLCAvLyBNaW5pbWFsIGNvbmZpZyBmb3IgY2FjaGVkXG5cdFx0XHRwbGFuZXRUeXBlOiB7fSBhcyBQbGFuZXRUeXBlRGVmaW5pdGlvbixcblx0XHRcdHN0YXRpc3RpY3M6IHt9LFxuXHRcdFx0bWV0YWRhdGEsXG5cdFx0fTtcblx0fVxuXG5cdHByaXZhdGUgYXBwbHlSZW5kZXJDb25maWdPdmVycmlkZXMocGxhbmV0Q29uZmlnOiBFbmhhbmNlZFBsYW5ldENvbmZpZywgcmVuZGVyQ29uZmlnOiBQbGFuZXRSZW5kZXJDb25maWcpOiB2b2lkIHtcblx0XHRpZiAocmVuZGVyQ29uZmlnLnJhZGl1cyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRwbGFuZXRDb25maWcucmFkaXVzID0gcmVuZGVyQ29uZmlnLnJhZGl1cztcblx0XHR9XG5cblx0XHRpZiAocmVuZGVyQ29uZmlnLmZlYXR1cmVEZW5zaXR5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHBsYW5ldENvbmZpZy5mZWF0dXJlRGVuc2l0eSA9IHJlbmRlckNvbmZpZy5mZWF0dXJlRGVuc2l0eTtcblx0XHR9XG5cblx0XHRpZiAocmVuZGVyQ29uZmlnLmNvbG9yVmFyaWF0aW9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHBsYW5ldENvbmZpZy5jb2xvclZhcmlhdGlvbiA9IHJlbmRlckNvbmZpZy5jb2xvclZhcmlhdGlvbjtcblx0XHR9XG5cblx0XHQvLyBPdmVycmlkZSBmZWF0dXJlcyBiYXNlZCBvbiByZW5kZXIgY29uZmlnXG5cdFx0aWYgKHJlbmRlckNvbmZpZy5lbmFibGVBdG1vc3BoZXJlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHBsYW5ldENvbmZpZy5mZWF0dXJlcy5jbG91ZHMgPSByZW5kZXJDb25maWcuZW5hYmxlQXRtb3NwaGVyZTtcblx0XHR9XG5cblx0XHRpZiAocmVuZGVyQ29uZmlnLmVuYWJsZVJpbmdzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHBsYW5ldENvbmZpZy5mZWF0dXJlcy5yaW5ncyA9IHJlbmRlckNvbmZpZy5lbmFibGVSaW5ncztcblx0XHR9XG5cblx0XHRpZiAocmVuZGVyQ29uZmlnLmVuYWJsZU1vb25zICE9PSB1bmRlZmluZWQgJiYgIXJlbmRlckNvbmZpZy5lbmFibGVNb29ucykge1xuXHRcdFx0cGxhbmV0Q29uZmlnLmZlYXR1cmVzLm1vb25zID0gMDtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGVuaGFuY2VNZXNoRm9yUmVuZGVyaW5nKG1lc2g6IFRIUkVFLkdyb3VwLCBjb25maWc6IEVuaGFuY2VkUGxhbmV0Q29uZmlnLCBwbGFuZXRUeXBlOiBQbGFuZXRUeXBlRGVmaW5pdGlvbiwgcmVuZGVyQ29uZmlnOiBQbGFuZXRSZW5kZXJDb25maWcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHQvLyBBcHBseSBMT0QgaWYgZW5hYmxlZFxuXHRcdGlmIChyZW5kZXJDb25maWcuZW5hYmxlTE9EKSB7XG5cdFx0XHR0aGlzLmFwcGx5TE9EKG1lc2gsIHJlbmRlckNvbmZpZy5yZW5kZXJEaXN0YW5jZSB8fCAxMDApO1xuXHRcdH1cblxuXHRcdC8vIExpbWl0IGZlYXR1cmVzIGlmIG5lY2Vzc2FyeVxuXHRcdGlmIChyZW5kZXJDb25maWcubWF4RmVhdHVyZXMgJiYgbWVzaC5jaGlsZHJlbi5sZW5ndGggPiByZW5kZXJDb25maWcubWF4RmVhdHVyZXMpIHtcblx0XHRcdHRoaXMubGltaXRGZWF0dXJlcyhtZXNoLCByZW5kZXJDb25maWcubWF4RmVhdHVyZXMpO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBhZHZhbmNlZCB2aXN1YWwgZWZmZWN0c1xuXHRcdGlmIChyZW5kZXJDb25maWcuZW5hYmxlU3BlY2lhbEVmZmVjdHMpIHtcblx0XHRcdGF3YWl0IHRoaXMuYWRkQWR2YW5jZWRFZmZlY3RzKG1lc2gsIGNvbmZpZywgcGxhbmV0VHlwZSk7XG5cdFx0fVxuXG5cdFx0Ly8gT3B0aW1pemUgZm9yIHBlcmZvcm1hbmNlXG5cdFx0dGhpcy5vcHRpbWl6ZU1lc2hGb3JQZXJmb3JtYW5jZShtZXNoKTtcblx0fVxuXG5cdHByaXZhdGUgYXBwbHlMT0QobWVzaDogVEhSRUUuR3JvdXAsIHJlbmRlckRpc3RhbmNlOiBudW1iZXIpOiB2b2lkIHtcblx0XHRtZXNoLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG5cdFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG5cdFx0XHRcdC8vIENyZWF0ZSBMT0QgdmVyc2lvbnNcblx0XHRcdFx0Y29uc3QgbG9kID0gbmV3IFRIUkVFLkxPRCgpO1xuXG5cdFx0XHRcdC8vIEhpZ2ggZGV0YWlsIChjbG9zZSlcblx0XHRcdFx0bG9kLmFkZExldmVsKGNoaWxkLCAwKTtcblxuXHRcdFx0XHQvLyBNZWRpdW0gZGV0YWlsXG5cdFx0XHRcdGNvbnN0IG1lZGl1bUdlb21ldHJ5ID0gdGhpcy5zaW1wbGlmeUdlb21ldHJ5KGNoaWxkLmdlb21ldHJ5IGFzIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LCAwLjUpO1xuXHRcdFx0XHRjb25zdCBtZWRpdW1NZXNoID0gbmV3IFRIUkVFLk1lc2gobWVkaXVtR2VvbWV0cnksIGNoaWxkLm1hdGVyaWFsKTtcblx0XHRcdFx0bG9kLmFkZExldmVsKG1lZGl1bU1lc2gsIHJlbmRlckRpc3RhbmNlICogMC4zKTtcblxuXHRcdFx0XHQvLyBMb3cgZGV0YWlsIChmYXIpXG5cdFx0XHRcdGNvbnN0IGxvd0dlb21ldHJ5ID0gdGhpcy5zaW1wbGlmeUdlb21ldHJ5KGNoaWxkLmdlb21ldHJ5IGFzIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LCAwLjIpO1xuXHRcdFx0XHRjb25zdCBsb3dNZXNoID0gbmV3IFRIUkVFLk1lc2gobG93R2VvbWV0cnksIGNoaWxkLm1hdGVyaWFsKTtcblx0XHRcdFx0bG9kLmFkZExldmVsKGxvd01lc2gsIHJlbmRlckRpc3RhbmNlICogMC43KTtcblxuXHRcdFx0XHQvLyBSZXBsYWNlIG9yaWdpbmFsIG1lc2ggd2l0aCBMT0Rcblx0XHRcdFx0Y29uc3QgcGFyZW50ID0gY2hpbGQucGFyZW50O1xuXHRcdFx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlbW92ZShjaGlsZCk7XG5cdFx0XHRcdFx0cGFyZW50LmFkZChsb2QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIHNpbXBsaWZ5R2VvbWV0cnkoZ2VvbWV0cnk6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5LCBmYWN0b3I6IG51bWJlcik6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5IHtcblx0XHQvLyBTaW1wbGUgZ2VvbWV0cnkgc2ltcGxpZmljYXRpb25cblx0XHRjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXHRcdGNvbnN0IHNpbXBsaWZpZWQgPSBuZXcgRmxvYXQzMkFycmF5KE1hdGguZmxvb3IocG9zaXRpb25zLmxlbmd0aCAqIGZhY3RvcikpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzaW1wbGlmaWVkLmxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHRjb25zdCBzb3VyY2VJbmRleCA9IE1hdGguZmxvb3IoaSAvIGZhY3RvcikgKiAzO1xuXHRcdFx0c2ltcGxpZmllZFtpXSA9IHBvc2l0aW9uc1tzb3VyY2VJbmRleF07XG5cdFx0XHRzaW1wbGlmaWVkW2kgKyAxXSA9IHBvc2l0aW9uc1tzb3VyY2VJbmRleCArIDFdO1xuXHRcdFx0c2ltcGxpZmllZFtpICsgMl0gPSBwb3NpdGlvbnNbc291cmNlSW5kZXggKyAyXTtcblx0XHR9XG5cblx0XHRjb25zdCBzaW1wbGlmaWVkR2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRzaW1wbGlmaWVkR2VvbWV0cnkuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShzaW1wbGlmaWVkLCAzKSk7XG5cdFx0c2ltcGxpZmllZEdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0XHRyZXR1cm4gc2ltcGxpZmllZEdlb21ldHJ5O1xuXHR9XG5cblx0cHJpdmF0ZSBsaW1pdEZlYXR1cmVzKG1lc2g6IFRIUkVFLkdyb3VwLCBtYXhGZWF0dXJlczogbnVtYmVyKTogdm9pZCB7XG5cdFx0d2hpbGUgKG1lc2guY2hpbGRyZW4ubGVuZ3RoID4gbWF4RmVhdHVyZXMpIHtcblx0XHRcdGNvbnN0IHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWVzaC5jaGlsZHJlbi5sZW5ndGgpO1xuXHRcdFx0Y29uc3QgY2hpbGQgPSBtZXNoLmNoaWxkcmVuW3JhbmRvbUluZGV4XTtcblx0XHRcdG1lc2gucmVtb3ZlKGNoaWxkKTtcblx0XHRcdHRoaXMuZGlzcG9zZU1lc2goY2hpbGQpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgYWRkQWR2YW5jZWRFZmZlY3RzKG1lc2g6IFRIUkVFLkdyb3VwLCBjb25maWc6IEVuaGFuY2VkUGxhbmV0Q29uZmlnLCBwbGFuZXRUeXBlOiBQbGFuZXRUeXBlRGVmaW5pdGlvbik6IFByb21pc2U8dm9pZD4ge1xuXHRcdC8vIEFkZCBwYXJ0aWNsZSBlZmZlY3RzIGZvciBjZXJ0YWluIHBsYW5ldCB0eXBlc1xuXHRcdGlmIChwbGFuZXRUeXBlLmNsYXNzID09PSBQbGFuZXRDbGFzcy5MQVZBX1dPUkxEKSB7XG5cdFx0XHR0aGlzLmFkZExhdmFQYXJ0aWNsZXMobWVzaCk7XG5cdFx0fVxuXG5cdFx0aWYgKHBsYW5ldFR5cGUuY2xhc3MgPT09IFBsYW5ldENsYXNzLkdBU19HSUFOVCkge1xuXHRcdFx0dGhpcy5hZGRBdG1vc3BoZXJpY1N0b3JtcyhtZXNoKTtcblx0XHR9XG5cblx0XHRpZiAocGxhbmV0VHlwZS5jbGFzcyA9PT0gUGxhbmV0Q2xhc3MuSUNFX0dJQU5UKSB7XG5cdFx0XHR0aGlzLmFkZEljZVNoaW1tZXJzKG1lc2gpO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBhdXJvcmEgZWZmZWN0cyBmb3IgcGxhbmV0cyB3aXRoIG1hZ25ldGljIGZpZWxkc1xuXHRcdGlmIChjb25maWcubWFnbmV0aWNGaWVsZCA+IDUpIHtcblx0XHRcdHRoaXMuYWRkQXVyb3JhRWZmZWN0KG1lc2gpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYWRkTGF2YVBhcnRpY2xlcyhtZXNoOiBUSFJFRS5Hcm91cCk6IHZvaWQge1xuXHRcdGNvbnN0IHBhcnRpY2xlQ291bnQgPSAxMDA7XG5cdFx0Y29uc3QgcGFydGljbGVzID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Y29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShwYXJ0aWNsZUNvdW50ICogMyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2xlQ291bnQ7IGkrKykge1xuXHRcdFx0cG9zaXRpb25zW2kgKiAzXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDEwO1xuXHRcdFx0cG9zaXRpb25zW2kgKiAzICsgMV0gPSBNYXRoLnJhbmRvbSgpICogNTtcblx0XHRcdHBvc2l0aW9uc1tpICogMyArIDJdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMTA7XG5cdFx0fVxuXG5cdFx0cGFydGljbGVzLnNldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSk7XG5cblx0XHRjb25zdCBwYXJ0aWNsZU1hdGVyaWFsID0gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKHtcblx0XHRcdGNvbG9yOiAweGZmNDUwMCxcblx0XHRcdHNpemU6IDAuMSxcblx0XHRcdHRyYW5zcGFyZW50OiB0cnVlLFxuXHRcdFx0b3BhY2l0eTogMC43LFxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgcGFydGljbGVTeXN0ZW0gPSBuZXcgVEhSRUUuUG9pbnRzKHBhcnRpY2xlcywgcGFydGljbGVNYXRlcmlhbCk7XG5cdFx0bWVzaC5hZGQocGFydGljbGVTeXN0ZW0pO1xuXHR9XG5cblx0cHJpdmF0ZSBhZGRBdG1vc3BoZXJpY1N0b3JtcyhtZXNoOiBUSFJFRS5Hcm91cCk6IHZvaWQge1xuXHRcdC8vIEFkZCBzdG9ybSBzcGlyYWwgcGF0dGVybnNcblx0XHRjb25zdCBzdG9ybUdlb21ldHJ5ID0gbmV3IFRIUkVFLlJpbmdHZW9tZXRyeSgyLCA0LCA4KTtcblx0XHRjb25zdCBzdG9ybU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdGNvbG9yOiAweDQxNjllMSxcblx0XHRcdHRyYW5zcGFyZW50OiB0cnVlLFxuXHRcdFx0b3BhY2l0eTogMC4zLFxuXHRcdFx0c2lkZTogVEhSRUUuRG91YmxlU2lkZSxcblx0XHR9KTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRjb25zdCBzdG9ybSA9IG5ldyBUSFJFRS5NZXNoKHN0b3JtR2VvbWV0cnksIHN0b3JtTWF0ZXJpYWwpO1xuXHRcdFx0c3Rvcm0ucG9zaXRpb24uc2V0KChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDgsIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDgsIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDgpO1xuXHRcdFx0c3Rvcm0ucm90YXRpb24ueCA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJO1xuXHRcdFx0c3Rvcm0ucm90YXRpb24ueSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJO1xuXHRcdFx0bWVzaC5hZGQoc3Rvcm0pO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYWRkSWNlU2hpbW1lcnMobWVzaDogVEhSRUUuR3JvdXApOiB2b2lkIHtcblx0XHRjb25zdCBzaGltbWVyR2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMSwgMTYsIDE2KTtcblx0XHRjb25zdCBzaGltbWVyTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0Y29sb3I6IDB4ODdjZWViLFxuXHRcdFx0dHJhbnNwYXJlbnQ6IHRydWUsXG5cdFx0XHRvcGFjaXR5OiAwLjIsXG5cdFx0XHRzaWRlOiBUSFJFRS5CYWNrU2lkZSxcblx0XHR9KTtcblxuXHRcdGNvbnN0IHNoaW1tZXIgPSBuZXcgVEhSRUUuTWVzaChzaGltbWVyR2VvbWV0cnksIHNoaW1tZXJNYXRlcmlhbCk7XG5cdFx0bWVzaC5hZGQoc2hpbW1lcik7XG5cdH1cblxuXHRwcml2YXRlIGFkZEF1cm9yYUVmZmVjdChtZXNoOiBUSFJFRS5Hcm91cCk6IHZvaWQge1xuXHRcdGNvbnN0IGF1cm9yYUdlb21ldHJ5ID0gbmV3IFRIUkVFLlJpbmdHZW9tZXRyeSgzLCA1LCAzMik7XG5cdFx0Y29uc3QgYXVyb3JhTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0Y29sb3I6IDB4MDBmZjdmLFxuXHRcdFx0dHJhbnNwYXJlbnQ6IHRydWUsXG5cdFx0XHRvcGFjaXR5OiAwLjQsXG5cdFx0XHRzaWRlOiBUSFJFRS5Eb3VibGVTaWRlLFxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgYXVyb3JhID0gbmV3IFRIUkVFLk1lc2goYXVyb3JhR2VvbWV0cnksIGF1cm9yYU1hdGVyaWFsKTtcblx0XHRhdXJvcmEucm90YXRpb24ueCA9IE1hdGguUEkgLyAyO1xuXHRcdG1lc2guYWRkKGF1cm9yYSk7XG5cdH1cblxuXHRwcml2YXRlIG9wdGltaXplTWVzaEZvclBlcmZvcm1hbmNlKG1lc2g6IFRIUkVFLkdyb3VwKTogdm9pZCB7XG5cdFx0bWVzaC50cmF2ZXJzZSgoY2hpbGQpID0+IHtcblx0XHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcblx0XHRcdFx0Ly8gRW5hYmxlIGZydXN0dW0gY3VsbGluZ1xuXHRcdFx0XHRjaGlsZC5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBNZXJnZSBnZW9tZXRyaWVzIHdoZXJlIHBvc3NpYmxlXG5cdFx0XHRcdGlmIChjaGlsZC5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5KSB7XG5cdFx0XHRcdFx0Y2hpbGQuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cdFx0XHRcdFx0Y2hpbGQuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPcHRpbWl6ZSBtYXRlcmlhbHNcblx0XHRcdFx0aWYgKGNoaWxkLm1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWF0ZXJpYWwpIHtcblx0XHRcdFx0XHRjaGlsZC5tYXRlcmlhbC5wcmVjaXNpb24gPSBcIm1lZGl1bXBcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBzZXR1cEFkdmFuY2VkTGlnaHRpbmcobWVzaDogVEhSRUUuR3JvdXAsIGNvbmZpZzogUGxhbmV0UmVuZGVyQ29uZmlnKTogdm9pZCB7XG5cdFx0Ly8gVGhpcyB3b3VsZCB0eXBpY2FsbHkgYmUgaGFuZGxlZCBieSB0aGUgc2NlbmUsIGJ1dCB3ZSBjYW4gYWRkIG9iamVjdC1zcGVjaWZpYyBsaWdodGluZ1xuXG5cdFx0Ly8gQWRkIGFtYmllbnQgbGlnaHQgZm9yIGF0bW9zcGhlcmVcblx0XHRjb25zdCBhbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4NDA0MDQwLCBjb25maWcuYW1iaWVudEludGVuc2l0eSB8fCAwLjQpO1xuXHRcdG1lc2guYWRkKGFtYmllbnRMaWdodCk7XG5cblx0XHQvLyBBZGQgZGlyZWN0aW9uYWwgbGlnaHQgZm9yIHN1blxuXHRcdGNvbnN0IHN1bkxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIGNvbmZpZy5zdW5JbnRlbnNpdHkgfHwgMS41KTtcblx0XHRzdW5MaWdodC5wb3NpdGlvbi5zZXQoMTAsIDEwLCAxMCk7XG5cdFx0c3VuTGlnaHQuY2FzdFNoYWRvdyA9IHRydWU7XG5cdFx0bWVzaC5hZGQoc3VuTGlnaHQpO1xuXG5cdFx0Ly8gQWRkIHN1YnRsZSByaW0gbGlnaHRpbmdcblx0XHRjb25zdCByaW1MaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ODdjZWViLCAwLjMpO1xuXHRcdHJpbUxpZ2h0LnBvc2l0aW9uLnNldCgtMTAsIDUsIC0xMCk7XG5cdFx0bWVzaC5hZGQocmltTGlnaHQpO1xuXHR9XG5cblx0cHJpdmF0ZSBzZWxlY3RQbGFuZXRUeXBlQnlEaXN0YW5jZShkaXN0YW5jZTogbnVtYmVyLCBzdGFyVHlwZTogc3RyaW5nKTogUGxhbmV0Q2xhc3Mge1xuXHRcdC8vIFNlbGVjdCBwbGFuZXQgdHlwZSBiYXNlZCBvbiBkaXN0YW5jZSBmcm9tIHN0YXJcblx0XHRpZiAoZGlzdGFuY2UgPCAwLjUpIHtcblx0XHRcdHJldHVybiBNYXRoLnJhbmRvbSgpIDwgMC43ID8gUGxhbmV0Q2xhc3MuTEFWQV9XT1JMRCA6IFBsYW5ldENsYXNzLklST05fV09STEQ7XG5cdFx0fSBlbHNlIGlmIChkaXN0YW5jZSA8IDEuNSkge1xuXHRcdFx0cmV0dXJuIE1hdGgucmFuZG9tKCkgPCAwLjYgPyBQbGFuZXRDbGFzcy5URVJSRVNUUklBTCA6IFBsYW5ldENsYXNzLlNVUEVSX0VBUlRIO1xuXHRcdH0gZWxzZSBpZiAoZGlzdGFuY2UgPCAzLjApIHtcblx0XHRcdHJldHVybiBNYXRoLnJhbmRvbSgpIDwgMC40ID8gUGxhbmV0Q2xhc3MuT0NFQU5fV09STEQgOiBQbGFuZXRDbGFzcy5URVJSRVNUUklBTDtcblx0XHR9IGVsc2UgaWYgKGRpc3RhbmNlIDwgOC4wKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5yYW5kb20oKSA8IDAuNyA/IFBsYW5ldENsYXNzLkdBU19HSUFOVCA6IFBsYW5ldENsYXNzLklDRV9HSUFOVDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIE1hdGgucmFuZG9tKCkgPCAwLjggPyBQbGFuZXRDbGFzcy5JQ0VfR0lBTlQgOiBQbGFuZXRDbGFzcy5EV0FSRl9QTEFORVQ7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSByZW5kZXJGYWxsYmFja1BsYW5ldChjb25maWc6IFBsYW5ldFJlbmRlckNvbmZpZywgc3RhcnRUaW1lOiBudW1iZXIpOiBQbGFuZXRSZW5kZXJSZXN1bHQge1xuXHRcdC8vIENyZWF0ZSBhIHNpbXBsZSBmYWxsYmFjayBwbGFuZXRcblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KGNvbmZpZy5yYWRpdXMgfHwgMywgMSk7XG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoeyBjb2xvcjogMHg4ODg4ODggfSk7XG5cdFx0Y29uc3QgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cblx0XHRjb25zdCBncm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuXHRcdGdyb3VwLmFkZChtZXNoKTtcblxuXHRcdGNvbnN0IG1ldGFkYXRhOiBQbGFuZXRSZW5kZXJNZXRhZGF0YSA9IHtcblx0XHRcdHJlbmRlclRpbWU6IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lLFxuXHRcdFx0cG9seUNvdW50OiBnZW9tZXRyeS5mYWNlcz8ubGVuZ3RoIHx8IDIwLFxuXHRcdFx0dGV4dHVyZUNvdW50OiAwLFxuXHRcdFx0ZmVhdHVyZUNvdW50OiAxLFxuXHRcdFx0bWVtb3J5VXNhZ2U6IDAsXG5cdFx0XHRxdWFsaXR5TGV2ZWw6IFwiZmFsbGJhY2tcIixcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG1lc2g6IGdyb3VwLFxuXHRcdFx0Y29uZmlnOiB7fSBhcyBFbmhhbmNlZFBsYW5ldENvbmZpZyxcblx0XHRcdHBsYW5ldFR5cGU6IHt9IGFzIFBsYW5ldFR5cGVEZWZpbml0aW9uLFxuXHRcdFx0c3RhdGlzdGljczoge30sXG5cdFx0XHRtZXRhZGF0YSxcblx0XHR9O1xuXHR9XG5cblx0cHJpdmF0ZSBjYWxjdWxhdGVSZW5kZXJNZXRhZGF0YShtZXNoOiBUSFJFRS5Hcm91cCwgc3RhcnRUaW1lOiBudW1iZXIpOiBQbGFuZXRSZW5kZXJNZXRhZGF0YSB7XG5cdFx0bGV0IHBvbHlDb3VudCA9IDA7XG5cdFx0bGV0IHRleHR1cmVDb3VudCA9IDA7XG5cdFx0bGV0IG1lbW9yeVVzYWdlID0gMDtcblxuXHRcdG1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG5cdFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG5cdFx0XHRcdGlmIChjaGlsZC5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5KSB7XG5cdFx0XHRcdFx0Y29uc3QgcG9zaXRpb25zID0gY2hpbGQuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdFx0XHRpZiAocG9zaXRpb25zKSB7XG5cdFx0XHRcdFx0XHRwb2x5Q291bnQgKz0gcG9zaXRpb25zLmNvdW50IC8gMztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY2hpbGQubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NYXRlcmlhbCkge1xuXHRcdFx0XHRcdHRleHR1cmVDb3VudCsrO1xuXHRcdFx0XHRcdC8vIEVzdGltYXRlIG1lbW9yeSB1c2FnZSAodmVyeSByb3VnaClcblx0XHRcdFx0XHRtZW1vcnlVc2FnZSArPSAxMDI0OyAvLyAxS0IgcGVyIG1hdGVyaWFsIGVzdGltYXRlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRyZW5kZXJUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSxcblx0XHRcdHBvbHlDb3VudDogTWF0aC5mbG9vcihwb2x5Q291bnQpLFxuXHRcdFx0dGV4dHVyZUNvdW50LFxuXHRcdFx0ZmVhdHVyZUNvdW50OiBtZXNoLmNoaWxkcmVuLmxlbmd0aCxcblx0XHRcdG1lbW9yeVVzYWdlLFxuXHRcdFx0cXVhbGl0eUxldmVsOiB0aGlzLmRldGVybWluZVF1YWxpdHlMZXZlbChwb2x5Q291bnQsIHRleHR1cmVDb3VudCksXG5cdFx0fTtcblx0fVxuXG5cdHByaXZhdGUgZGV0ZXJtaW5lUXVhbGl0eUxldmVsKHBvbHlDb3VudDogbnVtYmVyLCB0ZXh0dXJlQ291bnQ6IG51bWJlcik6IHN0cmluZyB7XG5cdFx0aWYgKHBvbHlDb3VudCA+IDEwMDAwKSByZXR1cm4gXCJ1bHRyYVwiO1xuXHRcdGlmIChwb2x5Q291bnQgPiA1MDAwKSByZXR1cm4gXCJoaWdoXCI7XG5cdFx0aWYgKHBvbHlDb3VudCA+IDIwMDApIHJldHVybiBcIm1lZGl1bVwiO1xuXHRcdGlmIChwb2x5Q291bnQgPiA1MDApIHJldHVybiBcImxvd1wiO1xuXHRcdHJldHVybiBcIm1pbmltYWxcIjtcblx0fVxuXG5cdHByaXZhdGUgY2FsY3VsYXRlUG9seUNvdW50KG1lc2g6IFRIUkVFLkdyb3VwKTogbnVtYmVyIHtcblx0XHRsZXQgY291bnQgPSAwO1xuXHRcdG1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG5cdFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICYmIGNoaWxkLmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkpIHtcblx0XHRcdFx0Y29uc3QgcG9zaXRpb25zID0gY2hpbGQuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdFx0aWYgKHBvc2l0aW9ucykge1xuXHRcdFx0XHRcdGNvdW50ICs9IHBvc2l0aW9ucy5jb3VudCAvIDM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihjb3VudCk7XG5cdH1cblxuXHRwcml2YXRlIGRpc3Bvc2VNZXNoKG9iamVjdDogVEhSRUUuT2JqZWN0M0QpOiB2b2lkIHtcblx0XHRvYmplY3QudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG5cdFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG5cdFx0XHRcdGlmIChjaGlsZC5nZW9tZXRyeSkge1xuXHRcdFx0XHRcdGNoaWxkLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2hpbGQubWF0ZXJpYWwpIHtcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZC5tYXRlcmlhbCkpIHtcblx0XHRcdFx0XHRcdGNoaWxkLm1hdGVyaWFsLmZvckVhY2goKG1hdGVyaWFsKSA9PiBtYXRlcmlhbC5kaXNwb3NlKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjaGlsZC5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIGNsZWFudXBDYWNoZSgpOiB2b2lkIHtcblx0XHQvLyBLZWVwIGNhY2hlIHNpemUgcmVhc29uYWJsZVxuXHRcdGlmICh0aGlzLnJlbmRlckNhY2hlLnNpemUgPiAxMCkge1xuXHRcdFx0Y29uc3QgZmlyc3RLZXkgPSB0aGlzLnJlbmRlckNhY2hlLmtleXMoKS5uZXh0KCkudmFsdWU7XG5cdFx0XHRjb25zdCBtZXNoID0gdGhpcy5yZW5kZXJDYWNoZS5nZXQoZmlyc3RLZXkpO1xuXHRcdFx0aWYgKG1lc2gpIHtcblx0XHRcdFx0dGhpcy5kaXNwb3NlTWVzaChtZXNoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMucmVuZGVyQ2FjaGUuZGVsZXRlKGZpcnN0S2V5KTtcblx0XHR9XG5cdH1cblxuXHQvLyBQdWJsaWMgdXRpbGl0eSBtZXRob2RzXG5cblx0LyoqXG5cdCAqIEdldCBwZXJmb3JtYW5jZSBzdGF0aXN0aWNzXG5cdCAqL1xuXHRwdWJsaWMgZ2V0UGVyZm9ybWFuY2VTdGF0cygpOiB7IGxhc3RSZW5kZXJUaW1lOiBudW1iZXI7IGNhY2hlU2l6ZTogbnVtYmVyIH0ge1xuXHRcdHJldHVybiB7XG5cdFx0XHRsYXN0UmVuZGVyVGltZTogdGhpcy5sYXN0UmVuZGVyVGltZSxcblx0XHRcdGNhY2hlU2l6ZTogdGhpcy5yZW5kZXJDYWNoZS5zaXplLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXIgcmVuZGVyIGNhY2hlXG5cdCAqL1xuXHRwdWJsaWMgY2xlYXJDYWNoZSgpOiB2b2lkIHtcblx0XHRmb3IgKGNvbnN0IG1lc2ggb2YgdGhpcy5yZW5kZXJDYWNoZS52YWx1ZXMoKSkge1xuXHRcdFx0dGhpcy5kaXNwb3NlTWVzaChtZXNoKTtcblx0XHR9XG5cdFx0dGhpcy5yZW5kZXJDYWNoZS5jbGVhcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByZWxvYWQgY29tbW9uIHBsYW5ldCB0eXBlc1xuXHQgKi9cblx0cHVibGljIGFzeW5jIHByZWxvYWRDb21tb25UeXBlcygpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBjb21tb25UeXBlcyA9IFtQbGFuZXRDbGFzcy5URVJSRVNUUklBTCwgUGxhbmV0Q2xhc3MuR0FTX0dJQU5ULCBQbGFuZXRDbGFzcy5JQ0VfR0lBTlQsIFBsYW5ldENsYXNzLk9DRUFOX1dPUkxEXTtcblxuXHRcdGNvbnN0IHByb21pc2VzID0gY29tbW9uVHlwZXMubWFwKCh0eXBlKSA9PlxuXHRcdFx0dGhpcy5yZW5kZXJQbGFuZXQoe1xuXHRcdFx0XHRwbGFuZXRDbGFzczogdHlwZSxcblx0XHRcdFx0ZGV0YWlsTGV2ZWw6IDEsXG5cdFx0XHRcdGVuYWJsZVNwZWNpYWxFZmZlY3RzOiBmYWxzZSxcblx0XHRcdH0pXG5cdFx0KTtcblxuXHRcdGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblx0fVxufVxuIl0sIm5hbWVzIjpbIlRIUkVFIiwiUGxhbmV0Q2xhc3MiLCJnZXRQbGFuZXRUeXBlQnlDbGFzcyIsIlBMQU5FVF9UWVBFUyIsIkRFRkFVTFRfQ09ORklHIiwicmFkaXVzIiwic2VlZCIsIkRhdGUiLCJub3ciLCJzdGFyRGlzdGFuY2UiLCJzdGFyVHlwZSIsImRldGFpbExldmVsIiwiZmVhdHVyZURlbnNpdHkiLCJjb2xvclZhcmlhdGlvbiIsImVuYWJsZUxPRCIsIm1heEZlYXR1cmVzIiwicmVuZGVyRGlzdGFuY2UiLCJlbmFibGVBdG1vc3BoZXJlIiwiZW5hYmxlUmluZ3MiLCJlbmFibGVNb29ucyIsImVuYWJsZVNwZWNpYWxFZmZlY3RzIiwiZW5hYmxlQWR2YW5jZWRMaWdodGluZyIsImFtYmllbnRJbnRlbnNpdHkiLCJzdW5JbnRlbnNpdHkiLCJQbGFuZXRSZW5kZXJlciIsInJlbmRlclBsYW5ldCIsImNvbmZpZyIsImlzRGlzcG9zZWQiLCJFcnJvciIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwiZmluYWxDb25maWciLCJjYWNoZUtleSIsImdlbmVyYXRlQ2FjaGVLZXkiLCJjYWNoZWRNZXNoIiwicmVuZGVyQ2FjaGUiLCJnZXQiLCJjcmVhdGVDYWNoZWRSZXN1bHQiLCJnZW5lcmF0b3IiLCJFbmhhbmNlZFBsYW5ldEdlbmVyYXRvciIsInBsYW5ldFJlc3VsdCIsImdlbmVyYXRlUGxhbmV0IiwicGxhbmV0Q2xhc3MiLCJhcHBseVJlbmRlckNvbmZpZ092ZXJyaWRlcyIsImVuaGFuY2VNZXNoRm9yUmVuZGVyaW5nIiwibWVzaCIsInBsYW5ldFR5cGUiLCJzZXR1cEFkdmFuY2VkTGlnaHRpbmciLCJzZXQiLCJjbG9uZSIsImNsZWFudXBDYWNoZSIsIm1ldGFkYXRhIiwiY2FsY3VsYXRlUmVuZGVyTWV0YWRhdGEiLCJsYXN0UmVuZGVyVGltZSIsInN0YXRpc3RpY3MiLCJlcnJvciIsImNvbnNvbGUiLCJyZW5kZXJGYWxsYmFja1BsYW5ldCIsInJlbmRlclBsYW5ldEJ5VHlwZSIsInJlbmRlclNvbGFyU3lzdGVtUGxhbmV0cyIsInBsYW5ldENvdW50IiwicGxhbmV0cyIsImkiLCJkaXN0YW5jZSIsIk1hdGgiLCJtYXgiLCJzZWxlY3RQbGFuZXRUeXBlQnlEaXN0YW5jZSIsInBsYW5ldCIsInB1c2giLCJnZXRBdmFpbGFibGVQbGFuZXRUeXBlcyIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJnZXRQbGFuZXRUeXBlSW5mbyIsInVwZGF0ZVF1YWxpdHkiLCJxdWFsaXR5TGV2ZWwiLCJxdWFsaXR5IiwibWluIiwiZmxvb3IiLCJkaXNwb3NlIiwidmFsdWVzIiwiZGlzcG9zZU1lc2giLCJjbGVhciIsImtleVBhcnRzIiwiam9pbiIsImNsb25lZE1lc2giLCJyZW5kZXJUaW1lIiwicG9seUNvdW50IiwiY2FsY3VsYXRlUG9seUNvdW50IiwidGV4dHVyZUNvdW50IiwiZmVhdHVyZUNvdW50IiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJtZW1vcnlVc2FnZSIsInBsYW5ldENvbmZpZyIsInJlbmRlckNvbmZpZyIsInVuZGVmaW5lZCIsImZlYXR1cmVzIiwiY2xvdWRzIiwicmluZ3MiLCJtb29ucyIsImFwcGx5TE9EIiwibGltaXRGZWF0dXJlcyIsImFkZEFkdmFuY2VkRWZmZWN0cyIsIm9wdGltaXplTWVzaEZvclBlcmZvcm1hbmNlIiwiZm9yRWFjaCIsImNoaWxkIiwiTWVzaCIsImxvZCIsIkxPRCIsImFkZExldmVsIiwibWVkaXVtR2VvbWV0cnkiLCJzaW1wbGlmeUdlb21ldHJ5IiwiZ2VvbWV0cnkiLCJtZWRpdW1NZXNoIiwibWF0ZXJpYWwiLCJsb3dHZW9tZXRyeSIsImxvd01lc2giLCJwYXJlbnQiLCJyZW1vdmUiLCJhZGQiLCJmYWN0b3IiLCJwb3NpdGlvbnMiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJhcnJheSIsInNpbXBsaWZpZWQiLCJGbG9hdDMyQXJyYXkiLCJzb3VyY2VJbmRleCIsInNpbXBsaWZpZWRHZW9tZXRyeSIsIkJ1ZmZlckdlb21ldHJ5Iiwic2V0QXR0cmlidXRlIiwiQnVmZmVyQXR0cmlidXRlIiwiY29tcHV0ZVZlcnRleE5vcm1hbHMiLCJyYW5kb21JbmRleCIsInJhbmRvbSIsImNsYXNzIiwiTEFWQV9XT1JMRCIsImFkZExhdmFQYXJ0aWNsZXMiLCJHQVNfR0lBTlQiLCJhZGRBdG1vc3BoZXJpY1N0b3JtcyIsIklDRV9HSUFOVCIsImFkZEljZVNoaW1tZXJzIiwibWFnbmV0aWNGaWVsZCIsImFkZEF1cm9yYUVmZmVjdCIsInBhcnRpY2xlQ291bnQiLCJwYXJ0aWNsZXMiLCJwYXJ0aWNsZU1hdGVyaWFsIiwiUG9pbnRzTWF0ZXJpYWwiLCJjb2xvciIsInNpemUiLCJ0cmFuc3BhcmVudCIsIm9wYWNpdHkiLCJwYXJ0aWNsZVN5c3RlbSIsIlBvaW50cyIsInN0b3JtR2VvbWV0cnkiLCJSaW5nR2VvbWV0cnkiLCJzdG9ybU1hdGVyaWFsIiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJzaWRlIiwiRG91YmxlU2lkZSIsInN0b3JtIiwicm90YXRpb24iLCJ4IiwiUEkiLCJ5Iiwic2hpbW1lckdlb21ldHJ5IiwiU3BoZXJlR2VvbWV0cnkiLCJzaGltbWVyTWF0ZXJpYWwiLCJCYWNrU2lkZSIsInNoaW1tZXIiLCJhdXJvcmFHZW9tZXRyeSIsImF1cm9yYU1hdGVyaWFsIiwiYXVyb3JhIiwidHJhdmVyc2UiLCJmcnVzdHVtQ3VsbGVkIiwiY29tcHV0ZUJvdW5kaW5nU3BoZXJlIiwiY29tcHV0ZUJvdW5kaW5nQm94IiwiTWF0ZXJpYWwiLCJwcmVjaXNpb24iLCJhbWJpZW50TGlnaHQiLCJBbWJpZW50TGlnaHQiLCJzdW5MaWdodCIsIkRpcmVjdGlvbmFsTGlnaHQiLCJjYXN0U2hhZG93IiwicmltTGlnaHQiLCJJUk9OX1dPUkxEIiwiVEVSUkVTVFJJQUwiLCJTVVBFUl9FQVJUSCIsIk9DRUFOX1dPUkxEIiwiRFdBUkZfUExBTkVUIiwiSWNvc2FoZWRyb25HZW9tZXRyeSIsIk1lc2hQaG9uZ01hdGVyaWFsIiwiZ3JvdXAiLCJHcm91cCIsImZhY2VzIiwiY291bnQiLCJkZXRlcm1pbmVRdWFsaXR5TGV2ZWwiLCJvYmplY3QiLCJpc0FycmF5IiwiZmlyc3RLZXkiLCJuZXh0IiwidmFsdWUiLCJkZWxldGUiLCJnZXRQZXJmb3JtYW5jZVN0YXRzIiwiY2FjaGVTaXplIiwiY2xlYXJDYWNoZSIsInByZWxvYWRDb21tb25UeXBlcyIsImNvbW1vblR5cGVzIiwicHJvbWlzZXMiLCJtYXAiLCJ0eXBlIiwiUHJvbWlzZSIsImFsbCIsIk1hcCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/shared/procgen/planet/planet-renderer.ts\n"));

/***/ })

});
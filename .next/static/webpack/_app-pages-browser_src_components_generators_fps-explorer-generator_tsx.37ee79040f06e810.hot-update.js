"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_generators_fps-explorer-generator_tsx",{

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASCII: () => (/* binding */ eo),\n/* harmony export */   Autofocus: () => (/* binding */ ht),\n/* harmony export */   Bloom: () => (/* binding */ wt),\n/* harmony export */   BrightnessContrast: () => (/* binding */ St),\n/* harmony export */   ChromaticAberration: () => (/* binding */ yt),\n/* harmony export */   ColorAverage: () => (/* binding */ Pt),\n/* harmony export */   ColorDepth: () => (/* binding */ bt),\n/* harmony export */   Depth: () => (/* binding */ Et),\n/* harmony export */   DepthOfField: () => (/* binding */ ce),\n/* harmony export */   DotScreen: () => (/* binding */ Rt),\n/* harmony export */   EffectComposer: () => (/* binding */ dt),\n/* harmony export */   EffectComposerContext: () => (/* binding */ D),\n/* harmony export */   FXAA: () => (/* binding */ Nt),\n/* harmony export */   Glitch: () => (/* binding */ Ut),\n/* harmony export */   GodRays: () => (/* binding */ Ct),\n/* harmony export */   Grid: () => (/* binding */ zt),\n/* harmony export */   HueSaturation: () => (/* binding */ Tt),\n/* harmony export */   LUT: () => (/* binding */ Zt),\n/* harmony export */   LensFlare: () => (/* binding */ gt),\n/* harmony export */   LensFlareEffect: () => (/* binding */ fe),\n/* harmony export */   N8AO: () => (/* binding */ ao),\n/* harmony export */   Noise: () => (/* binding */ At),\n/* harmony export */   Outline: () => (/* binding */ Bt),\n/* harmony export */   Pixelation: () => (/* binding */ Vt),\n/* harmony export */   Ramp: () => (/* binding */ Ot),\n/* harmony export */   RampEffect: () => (/* binding */ pe),\n/* harmony export */   RampType: () => (/* binding */ ue),\n/* harmony export */   SMAA: () => (/* binding */ Lt),\n/* harmony export */   SSAO: () => (/* binding */ It),\n/* harmony export */   Scanline: () => (/* binding */ Ft),\n/* harmony export */   Select: () => (/* binding */ mt),\n/* harmony export */   Selection: () => (/* binding */ pt),\n/* harmony export */   SelectiveBloom: () => (/* binding */ kt),\n/* harmony export */   Sepia: () => (/* binding */ Gt),\n/* harmony export */   ShockWave: () => (/* binding */ Ht),\n/* harmony export */   Texture: () => (/* binding */ Wt),\n/* harmony export */   TiltShift: () => (/* binding */ $t),\n/* harmony export */   TiltShift2: () => (/* binding */ Yt),\n/* harmony export */   TiltShiftEffect: () => (/* binding */ me),\n/* harmony export */   ToneMapping: () => (/* binding */ Xt),\n/* harmony export */   Vignette: () => (/* binding */ qt),\n/* harmony export */   WaterEffect: () => (/* binding */ oo),\n/* harmony export */   WaterEffectImpl: () => (/* binding */ de),\n/* harmony export */   resolveRef: () => (/* binding */ k),\n/* harmony export */   selectionContext: () => (/* binding */ H),\n/* harmony export */   useVector2: () => (/* binding */ Z),\n/* harmony export */   wrapEffect: () => (/* binding */ P)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var postprocessing__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! postprocessing */ \"(app-pages-browser)/./node_modules/postprocessing/build/index.js\");\n/* harmony import */ var maath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! maath */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/maath.esm.js\");\n/* harmony import */ var n8ao__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! n8ao */ \"(app-pages-browser)/./node_modules/n8ao/dist/N8AO.js\");\nconst H=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);function pt({children:e,enabled:t=!0}){const[o,r]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]),a=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({selected:o,select:r,enabled:t}),[o,r,t]);return /*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(H.Provider,{value:a,children:e})}function mt({enabled:e=!1,children:t,...o}){const r=(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null),a=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(H);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{if(a&&e){let n=!1;const i=[];if(r.current.traverse(s=>{s.type===\"Mesh\"&&i.push(s),a.selected.indexOf(s)===-1&&(n=!0)}),n)return a.select(s=>[...s,...i]),()=>{a.select(s=>s.filter(l=>!i.includes(l)))}}},[e,t,a]),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"group\",{ref:r,...o,children:t})}const D=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null),ie=e=>(e.getAttributes()&2)===2,dt=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({children:e,camera:t,scene:o,resolutionScale:r,enabled:a=!0,renderPriority:n=1,autoClear:i=!0,depthBuffer:s,enableNormalPass:l,stencilBuffer:p,multisampling:_=8,frameBufferType:S=three__WEBPACK_IMPORTED_MODULE_4__.HalfFloatType},g)=>{const{gl:d,scene:m,camera:v,size:x}=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)(),f=o||m,u=t||v,[c,U,b]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{const C=new postprocessing__WEBPACK_IMPORTED_MODULE_6__.EffectComposer(d,{depthBuffer:s,stencilBuffer:p,multisampling:_,frameBufferType:S});C.addPass(new postprocessing__WEBPACK_IMPORTED_MODULE_6__.RenderPass(f,u));let R=null,E=null;return l&&(E=new postprocessing__WEBPACK_IMPORTED_MODULE_6__.NormalPass(f,u),E.enabled=!1,C.addPass(E),r!==void 0&&(R=new postprocessing__WEBPACK_IMPORTED_MODULE_6__.DepthDownsamplingPass({normalBuffer:E.texture,resolutionScale:r}),R.enabled=!1,C.addPass(R))),[C,E,R]},[u,d,s,p,_,S,f,l,r]);(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>c?.setSize(x.width,x.height),[c,x]),(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.D)((C,R)=>{if(a){const E=d.autoClear;d.autoClear=i,p&&!i&&d.clearStencil(),c.render(R),d.autoClear=E}},a?n:0);const F=(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);(0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{const C=[],R=F.current.__r3f;if(R&&c){const E=R.children;for(let T=0;T<E.length;T++){const N=E[T].object;if(N instanceof postprocessing__WEBPACK_IMPORTED_MODULE_6__.Effect){const q=[N];if(!ie(N)){let G=null;for(;(G=E[T+1]?.object)instanceof postprocessing__WEBPACK_IMPORTED_MODULE_6__.Effect&&!ie(G);)q.push(G),T++}const $=new postprocessing__WEBPACK_IMPORTED_MODULE_6__.EffectPass(u,...q);C.push($)}else N instanceof postprocessing__WEBPACK_IMPORTED_MODULE_6__.Pass&&C.push(N)}for(const T of C)c?.addPass(T);U&&(U.enabled=!0),b&&(b.enabled=!0)}return()=>{for(const E of C)c?.removePass(E);U&&(U.enabled=!1),b&&(b.enabled=!1)}},[c,e,u,U,b]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{const C=d.toneMapping;return d.toneMapping=three__WEBPACK_IMPORTED_MODULE_4__.NoToneMapping,()=>{d.toneMapping=C}},[d]);const X=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({composer:c,normalPass:U,downSamplingPass:b,resolutionScale:r,camera:u,scene:f}),[c,U,b,r,u,f]);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(g,()=>c,[c]),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(D.Provider,{value:X,children:/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"group\",{ref:F,children:e})})})),k=e=>typeof e==\"object\"&&e!=null&&\"current\"in e?e.current:e;let vt=0;const le=/*@__PURE__*/new WeakMap,P=(e,t)=>function({blendFunction:o=t?.blendFunction,opacity:r=t?.opacity,...a}){let n=le.get(e);if(!n){const l=`@react-three/postprocessing/${e.name}-${vt++}`;(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.e)({[l]:e}),le.set(e,n=l)}const i=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)(l=>l.camera),s=react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>[...t?.args??[],...a.args??[{...t,...a}]],[JSON.stringify(a)]);return /*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(n,{camera:i,\"blendMode-blendFunction\":o,\"blendMode-opacity-value\":r,...a,args:s})},Z=(e,t)=>{const o=e[t];return react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>typeof o==\"number\"?new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(o,o):o?new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(...o):new three__WEBPACK_IMPORTED_MODULE_4__.Vector2,[o])},ce=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function({blendFunction:e,worldFocusDistance:t,worldFocusRange:o,focusDistance:r,focusRange:a,focalLength:n,bokehScale:i,resolutionScale:s,resolutionX:l,resolutionY:p,width:_,height:S,target:g,depthTexture:d,...m},v){const{camera:x}=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(D),f=g!=null,u=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{const c=new postprocessing__WEBPACK_IMPORTED_MODULE_6__.DepthOfFieldEffect(x,{blendFunction:e,worldFocusDistance:t,worldFocusRange:o,focusDistance:r,focusRange:a,focalLength:n,bokehScale:i,resolutionScale:s,resolutionX:l,resolutionY:p,width:_,height:S});f&&(c.target=new three__WEBPACK_IMPORTED_MODULE_4__.Vector3),d&&c.setDepthTexture(d.texture,d.packing);const U=c.maskPass;return U.maskFunction=postprocessing__WEBPACK_IMPORTED_MODULE_6__.MaskFunction.MULTIPLY_RGB_SET_ALPHA,c},[x,e,t,o,r,a,n,i,s,l,p,_,S,f,d]);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>()=>{u.dispose()},[u]),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{...m,ref:v,object:u,target:g})}),ht=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({target:e=void 0,mouse:t=!1,debug:o=void 0,manual:r=!1,smoothTime:a=.25,...n},i)=>{const s=(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null),l=(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null),p=(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null),_=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)(({scene:b})=>b),S=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)(({pointer:b})=>b),{composer:g,camera:d}=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(D),[m]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>new postprocessing__WEBPACK_IMPORTED_MODULE_6__.DepthPickingPass),[v]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>new postprocessing__WEBPACK_IMPORTED_MODULE_6__.CopyPass);(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>(g.addPass(m),g.addPass(v),()=>{g.removePass(m),g.removePass(v)}),[g,m,v]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>()=>{m.dispose(),v.dispose()},[m,v]);const[x]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0,0,0)),[f]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0,0,0)),u=(0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async(b,F)=>(f.x=b,f.y=F,f.z=await m.readDepth(f),f.z=f.z*2-1,1-f.z>1e-7?f.unproject(d):!1),[f,m,d]),c=(0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async(b,F=!0)=>{if(e)x.set(...e);else{const{x:X,y:C}=t?S:{x:0,y:0},R=await u(X,C);R&&x.copy(R)}F&&s.current?.target&&(a>0&&b>0?maath__WEBPACK_IMPORTED_MODULE_2__.easing.damp3(s.current.target,x,a,b):s.current.target.copy(x))},[e,x,t,u,a,S]);(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.D)(async(b,F)=>{r||c(F),l.current&&l.current.position.copy(x),p.current&&s.current?.target&&p.current.position.copy(s.current.target)});const U=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({dofRef:s,hitpoint:x,update:c}),[x,c]);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(i,()=>U,[U]),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment,{children:[o?(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.o)(/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment,{children:[/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"mesh\",{ref:l,children:[/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"sphereGeometry\",{args:[o,16,16]}),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"meshBasicMaterial\",{color:\"#00ff00\",opacity:1,transparent:!0,depthWrite:!1})]}),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"mesh\",{ref:p,children:[/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"sphereGeometry\",{args:[o/2,16,16]}),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"meshBasicMaterial\",{color:\"#00ff00\",opacity:.5,transparent:!0,depthWrite:!1})]})]}),_):null,/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ce,{ref:s,...n,target:x})]})}),_t={fragmentShader:`\n    uniform float time;\n    uniform vec2 lensPosition;\n    uniform vec2 screenRes;\n    uniform vec3 colorGain;\n    uniform float starPoints;\n    uniform float glareSize;\n    uniform float flareSize;\n    uniform float flareSpeed;\n    uniform float flareShape;\n    uniform float haloScale;\n    uniform float opacity;\n    uniform bool animated;\n    uniform bool anamorphic;\n    uniform bool enabled;\n    uniform bool secondaryGhosts;\n    uniform bool starBurst;\n    uniform float ghostScale;\n    uniform bool aditionalStreaks;\n    uniform sampler2D lensDirtTexture;\n    vec2 vTexCoord;\n    \n    float rand(float n){return fract(sin(n) * 43758.5453123);}\n\n    float noise(float p){\n      float fl = floor(p);\n      float fc = fract(p);\n      return mix(rand(fl),rand(fl + 1.0), fc);\n    }\n\n    vec3 hsv2rgb(vec3 c)\n    {\n      vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\n      return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);\n    }\n\n    float saturate(float x)\n    {\n      return clamp(x, 0.,1.);\n    }\n\n    vec2 rotateUV(vec2 uv, float rotation)\n    {\n      return vec2(\n          cos(rotation) * uv.x + sin(rotation) * uv.y,\n          cos(rotation) * uv.y - sin(rotation) * uv.x\n      );\n    }\n\n    // Based on https://www.shadertoy.com/view/XtKfRV\n    vec3 drawflare(vec2 p, float intensity, float rnd, float speed, int id)\n    {\n      float flarehueoffset = (1. / 32.) * float(id) * 0.1;\n      float lingrad = distance(vec2(0.), p);\n      float expgrad = 1. / exp(lingrad * (fract(rnd) * 0.66 + 0.33));\n      vec3 colgrad = hsv2rgb(vec3( fract( (expgrad * 8.) + speed * flareSpeed + flarehueoffset), pow(1.-abs(expgrad*2.-1.), 0.45), 20.0 * expgrad * intensity)); //rainbow spectrum effect\n\n      float internalStarPoints;\n\n      if(anamorphic){\n        internalStarPoints = 1.0;\n      } else{\n        internalStarPoints = starPoints;\n      }\n      \n      float blades = length(p * flareShape * sin(internalStarPoints * atan(p.x, p.y)));\n      \n      float comp = pow(1.-saturate(blades), ( anamorphic ? 100. : 12.));\n      comp += saturate(expgrad-0.9) * 3.;\n      comp = pow(comp * expgrad, 8. + (1.-intensity) * 5.);\n      \n      if(flareSpeed > 0.0){\n        return vec3(comp) * colgrad;\n      } else{\n        return vec3(comp) * flareSize * 15.;\n      }\n    }\n\n    float dist(vec3 a, vec3 b) { return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z); }\n\n    vec3 saturate(vec3 x)\n    {\n      return clamp(x, vec3(0.0), vec3(1.0));\n    }\n\n    // Based on https://www.shadertoy.com/view/XtKfRV\n    float glare(vec2 uv, vec2 pos, float size)\n    {\n      vec2 main;\n\n      if(animated){\n        main = rotateUV(uv-pos, time * 0.1);      \n      } else{\n        main = uv-pos;     \n      }\n      \n      float ang = atan(main.y, main.x) * (anamorphic ? 1.0 : starPoints);\n      float dist = length(main); \n      dist = pow(dist, .9);\n      \n      float f0 = 1.0/(length(uv-pos)*(1.0/size*16.0)+.2);\n\n      return f0+f0*(sin((ang))*.2 +.3);\n    }\n\n    float sdHex(vec2 p){\n      p = abs(p);\n      vec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);\n      return dot(step(q.xy,q.yx), 1.0-q.yx);\n    }\n\n    //Based on https://www.shadertoy.com/view/dllSRX\n    float fpow(float x, float k){\n      return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n    }\n\n    vec3 renderhex(vec2 uv, vec2 p, float s, vec3 col){\n      uv -= p;\n      if (abs(uv.x) < 0.2*s && abs(uv.y) < 0.2*s){\n          return mix(vec3(0),mix(vec3(0),col,0.1 + fpow(length(uv/s),0.1)*10.0),smoothstep(0.0,0.1,sdHex(uv*20.0/s)));\n      }\n      return vec3(0);\n    }\n\n    // Based on https://www.shadertoy.com/view/4sX3Rs\n    vec3 LensFlare(vec2 uv, vec2 pos)\n    {\n      vec2 main = uv-pos;\n      vec2 uvd = uv*(length(uv));\n      \n      float ang = atan(main.x,main.y);\n      \n      float f0 = .3/(length(uv-pos)*16.0+1.0);\n      \n      f0 = f0*(sin(noise(sin(ang*3.9-(animated ? time : 0.0) * 0.3) * starPoints))*.2 );\n      \n      float f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n      float f2 = max(.9/(10.0+32.0*pow(length(uvd+0.99*pos),2.0)),.0)*0.35;\n      float f22 = max(.9/(11.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*0.23;\n      float f23 = max(.9/(12.0+32.0*pow(length(uvd+0.95*pos),2.0)),.0)*0.6;\n      \n      vec2 uvx = mix(uv,uvd, 0.1);\n      \n      float f4 = max(0.01-pow(length(uvx+0.4*pos),2.9),.0)*4.02;\n      float f42 = max(0.0-pow(length(uvx+0.45*pos),2.9),.0)*4.1;\n      float f43 = max(0.01-pow(length(uvx+0.5*pos),2.9),.0)*4.6;\n      \n      uvx = mix(uv,uvd,-.4);\n      \n      float f5 = max(0.01-pow(length(uvx+0.1*pos),5.5),.0)*2.0;\n      float f52 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n      float f53 = max(0.01-pow(length(uvx+0.1*pos),5.5),.0)*2.0;\n      \n      uvx = mix(uv,uvd, 2.1);\n      \n      float f6 = max(0.01-pow(length(uvx-0.3*pos),1.61),.0)*3.159;\n      float f62 = max(0.01-pow(length(uvx-0.325*pos),1.614),.0)*3.14;\n      float f63 = max(0.01-pow(length(uvx-0.389*pos),1.623),.0)*3.12;\n      \n      vec3 c = vec3(glare(uv,pos, glareSize));\n\n      vec2 prot;\n\n      if(animated){\n        prot = rotateUV(uv - pos, (time * 0.1));  \n      } else if(anamorphic){\n        prot = rotateUV(uv - pos, 1.570796);     \n      } else {\n        prot = uv - pos;\n      }\n\n      c += drawflare(prot, (anamorphic ? flareSize * 10. : flareSize), 0.1, time, 1);\n      \n      c.r+=f1+f2+f4+f5+f6; c.g+=f1+f22+f42+f52+f62; c.b+=f1+f23+f43+f53+f63;\n      c = c*1.3 * vec3(length(uvd)+.09);\n      c+=vec3(f0);\n      \n      return c;\n    }\n\n    vec3 cc(vec3 color, float factor,float factor2)\n    {\n      float w = color.x+color.y+color.z;\n      return mix(color,vec3(w)*factor,w*factor2);\n    }    \n\n    float rnd(vec2 p)\n    {\n      float f = fract(sin(dot(p, vec2(12.1234, 72.8392) )*45123.2));\n      return f;   \n    }\n\n    float rnd(float w)\n    {\n      float f = fract(sin(w)*1000.);\n      return f;   \n    }\n\n    float regShape(vec2 p, int N)\n    {\n      float f;\n      \n      float a=atan(p.x,p.y)+.2;\n      float b=6.28319/float(N);\n      f=smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy)* 2.0  -ghostScale);\n          \n      return f;\n    }\n\n    // Based on https://www.shadertoy.com/view/Xlc3D2\n    vec3 circle(vec2 p, float size, float decay, vec3 color, vec3 color2, float dist, vec2 position)\n    {\n      float l = length(p + position*(dist*2.))+size/2.;\n      float l2 = length(p + position*(dist*4.))+size/3.;\n      \n      float c = max(0.01-pow(length(p + position*dist), size*ghostScale), 0.0)*10.;\n      float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*20.), 0.0)*3.;\n      float c2 =  max(0.09/pow(length(p-position*dist/.5)*1., .95), 0.0)/20.;\n      float s = max(0.02-pow(regShape(p*5. + position*dist*5. + decay, 6) , 1.), 0.0)*1.5;\n      \n      color = cos(vec3(0.44, .24, .2)*16. + dist/8.)*0.5+.5;\n      vec3 f = c*color;\n      f += c1*color;\n      f += c2*color;  \n      f +=  s*color;\n      return f;\n    }\n\n    vec4 getLensColor(float x){\n      return vec4(vec3(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(vec3(0., 0., 0.),\n        vec3(0., 0., 0.), smoothstep(0.0, 0.063, x)),\n        vec3(0., 0., 0.), smoothstep(0.063, 0.125, x)),\n        vec3(0.0, 0., 0.), smoothstep(0.125, 0.188, x)),\n        vec3(0.188, 0.131, 0.116), smoothstep(0.188, 0.227, x)),\n        vec3(0.31, 0.204, 0.537), smoothstep(0.227, 0.251, x)),\n        vec3(0.192, 0.106, 0.286), smoothstep(0.251, 0.314, x)),\n        vec3(0.102, 0.008, 0.341), smoothstep(0.314, 0.392, x)),\n        vec3(0.086, 0.0, 0.141), smoothstep(0.392, 0.502, x)),\n        vec3(1.0, 0.31, 0.0), smoothstep(0.502, 0.604, x)),\n        vec3(.1, 0.1, 0.1), smoothstep(0.604, 0.643, x)),\n        vec3(1.0, 0.929, 0.0), smoothstep(0.643, 0.761, x)),\n        vec3(1.0, 0.086, 0.424), smoothstep(0.761, 0.847, x)),\n        vec3(1.0, 0.49, 0.0), smoothstep(0.847, 0.89, x)),\n        vec3(0.945, 0.275, 0.475), smoothstep(0.89, 0.941, x)),\n        vec3(0.251, 0.275, 0.796), smoothstep(0.941, 1.0, x))),\n      1.0);\n    }\n\n    float dirtNoise(vec2 p){\n      vec2 f = fract(p);\n      f = (f * f) * (3.0 - (2.0 * f));    \n      float n = dot(floor(p), vec2(1.0, 157.0));\n      vec4 a = fract(sin(vec4(n + 0.0, n + 1.0, n + 157.0, n + 158.0)) * 43758.5453123);\n      return mix(mix(a.x, a.y, f.x), mix(a.z, a.w, f.x), f.y);\n    } \n\n    float fbm(vec2 p){\n      const mat2 m = mat2(0.80, -0.60, 0.60, 0.80);\n      float f = 0.0;\n      f += 0.5000*dirtNoise(p); p = m*p*2.02;\n      f += 0.2500*dirtNoise(p); p = m*p*2.03;\n      f += 0.1250*dirtNoise(p); p = m*p*2.01;\n      f += 0.0625*dirtNoise(p);\n      return f/0.9375;\n    }\n\n    vec4 getLensStar(vec2 p){\n      vec2 pp = (p - vec2(0.5)) * 2.0;\n      float a = atan(pp.y, pp.x);\n      vec4 cp = vec4(sin(a * 1.0), length(pp), sin(a * 13.0), sin(a * 53.0));\n      float d = sin(clamp(pow(length(vec2(0.5) - p) * 0.5 + haloScale /2., 5.0), 0.0, 1.0) * 3.14159);\n      vec3 c = vec3(d) * vec3(fbm(cp.xy * 16.0) * fbm(cp.zw * 9.0) * max(max(max(max(0.5, sin(a * 1.0)), sin(a * 3.0) * 0.8), sin(a * 7.0) * 0.8), sin(a * 9.0) * 10.6));\n      c *= vec3(mix(2.0, (sin(length(pp.xy) * 256.0) * 0.5) + 0.5, sin((clamp((length(pp.xy) - 0.875) / 0.1, 0.0, 1.0) + 0.0) * 2.0 * 3.14159) * 1.5) + 0.5) * 0.3275;\n      return vec4(vec3(c * 1.0), d);\t\n    }\n\n    vec4 getLensDirt(vec2 p){\n      p.xy += vec2(fbm(p.yx * 3.0), fbm(p.yx * 2.0)) * 0.0825;\n      vec3 o = vec3(mix(0.125, 0.25, max(max(smoothstep(0.1, 0.0, length(p - vec2(0.25))),\n                                            smoothstep(0.4, 0.0, length(p - vec2(0.75)))),\n                                            smoothstep(0.8, 0.0, length(p - vec2(0.875, 0.125))))));\n      o += vec3(max(fbm(p * 1.0) - 0.5, 0.0)) * 0.5;\n      o += vec3(max(fbm(p * 2.0) - 0.5, 0.0)) * 0.5;\n      o += vec3(max(fbm(p * 4.0) - 0.5, 0.0)) * 0.25;\n      o += vec3(max(fbm(p * 8.0) - 0.75, 0.0)) * 1.0;\n      o += vec3(max(fbm(p * 16.0) - 0.75, 0.0)) * 0.75;\n      o += vec3(max(fbm(p * 64.0) - 0.75, 0.0)) * 0.5;\n      return vec4(clamp(o, vec3(0.15), vec3(1.0)), 1.0);\t\n    }\n\n    vec4 textureLimited(sampler2D tex, vec2 texCoord){\n      if(((texCoord.x < 0.) || (texCoord.y < 0.)) || ((texCoord.x > 1.) || (texCoord.y > 1.))){\n        return vec4(0.0);\n      }else{\n        return texture(tex, texCoord); \n      }\n    }\n\n    vec4 textureDistorted(sampler2D tex, vec2 texCoord, vec2 direction, vec3 distortion) {\n      return vec4(textureLimited(tex, (texCoord + (direction * distortion.r))).r,\n                  textureLimited(tex, (texCoord + (direction * distortion.g))).g,\n                  textureLimited(tex, (texCoord + (direction * distortion.b))).b,\n                  1.0);\n    }\n\n    // Based on https://www.shadertoy.com/view/4sK3W3\n    vec4 getStartBurst(){\n      vec2 aspectTexCoord = vec2(1.0) - (((vTexCoord - vec2(0.5)) * vec2(1.0)) + vec2(0.5)); \n      vec2 texCoord = vec2(1.0) - vTexCoord; \n      vec2 ghostVec = (vec2(0.5) - texCoord) * 0.3 - lensPosition;\n      vec2 ghostVecAspectNormalized = normalize(ghostVec * vec2(1.0)) * vec2(1.0);\n      vec2 haloVec = normalize(ghostVec) * 0.6;\n      vec2 haloVecAspectNormalized = ghostVecAspectNormalized * 0.6;\n      vec2 texelSize = vec2(1.0) / vec2(screenRes.xy);\n      vec3 distortion = vec3(-(texelSize.x * 1.5), 0.2, texelSize.x * 1.5);\n      vec4 c = vec4(0.0);\n      for (int i = 0; i < 8; i++) {\n        vec2 offset = texCoord + (ghostVec * float(i));\n        c += textureDistorted(lensDirtTexture, offset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - offset) / length(vec2(0.5)))), 10.0);\n      }                       \n      vec2 haloOffset = texCoord + haloVecAspectNormalized; \n      return (c * getLensColor((length(vec2(0.5) - aspectTexCoord) / length(vec2(haloScale))))) + \n            (textureDistorted(lensDirtTexture, haloOffset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - haloOffset) / length(vec2(0.5)))), 10.0));\n    } \n\n    void mainImage(vec4 inputColor, vec2 uv, out vec4 outputColor)\n    {\n      vec2 myUV = uv -0.5;\n      myUV.y *= screenRes.y/screenRes.x;\n      vec2 finalLensPosition = lensPosition * 0.5;\n      finalLensPosition.y *= screenRes.y/screenRes.x;\n      \n      //First Lens flare pass\n      vec3 finalColor = LensFlare(myUV, finalLensPosition) * 20.0 * colorGain / 256.;\n\n      //Aditional streaks\n      if(aditionalStreaks){\n        vec3 circColor = vec3(0.9, 0.2, 0.1);\n        vec3 circColor2 = vec3(0.3, 0.1, 0.9);\n\n        for(float i=0.;i<10.;i++){\n          finalColor += circle(myUV, pow(rnd(i*2000.)*2.8, .1)+1.41, 0.0, circColor+i , circColor2+i, rnd(i*20.)*3.+0.2-.5, lensPosition);\n        }\n      }\n\n      //Alternative ghosts\n      if(secondaryGhosts){\n        vec3 altGhosts = vec3(0);\n        altGhosts += renderhex(myUV, -lensPosition*0.25, ghostScale * 1.4, vec3(0.25,0.35,0));\n        altGhosts += renderhex(myUV, lensPosition*0.25, ghostScale * 0.5, vec3(1,0.5,0.5));\n        altGhosts += renderhex(myUV, lensPosition*0.1, ghostScale * 1.6, vec3(1,1,1));\n        altGhosts += renderhex(myUV, lensPosition*1.8, ghostScale * 2.0, vec3(0,0.5,0.75));\n        altGhosts += renderhex(myUV, lensPosition*1.25, ghostScale * 0.8, vec3(1,1,0.5));\n        altGhosts += renderhex(myUV, -lensPosition*1.25, ghostScale * 5.0, vec3(0.5,0.5,0.25));\n        \n        //Circular ghosts\n        altGhosts += fpow(1.0 - abs(distance(lensPosition*0.8,myUV) - 0.7),0.985)*colorGain / 2100.;\n        finalColor += altGhosts;\n      }\n      \n\n      //Starburst                     \n      if(starBurst){\n        vTexCoord = myUV + 0.5;\n        vec4 lensMod = getLensDirt(myUV);\n        float tooBright = 1.0 - (clamp(0.5, 0.0, 0.5) * 2.0); \n        float tooDark = clamp(0.5 - 0.5, 0.0, 0.5) * 2.0;\n        lensMod += mix(lensMod, pow(lensMod * 2.0, vec4(2.0)) * 0.5, tooBright);\n        float lensStarRotationAngle = ((myUV.x + myUV.y)) * (1.0 / 6.0);\n        vec2 lensStarTexCoord = (mat2(cos(lensStarRotationAngle), -sin(lensStarRotationAngle), sin(lensStarRotationAngle), cos(lensStarRotationAngle)) * vTexCoord);\n        lensMod += getLensStar(lensStarTexCoord) * 2.;\n        \n        finalColor += clamp((lensMod.rgb * getStartBurst().rgb ), 0.01, 1.0);\n      }\n\n      //Final composed output\n      if(enabled){\n        outputColor = vec4(mix(finalColor, vec3(.0), opacity) + inputColor.rgb, inputColor.a);\n      } else {\n        outputColor = vec4(inputColor);\n      }\n    }\n  `};class fe extends postprocessing__WEBPACK_IMPORTED_MODULE_6__.Effect{constructor({blendFunction:t,enabled:o,glareSize:r,lensPosition:a,screenRes:n,starPoints:i,flareSize:s,flareSpeed:l,flareShape:p,animated:_,anamorphic:S,colorGain:g,lensDirtTexture:d,haloScale:m,secondaryGhosts:v,aditionalStreaks:x,ghostScale:f,opacity:u,starBurst:c}){super(\"LensFlareEffect\",_t.fragmentShader,{blendFunction:t,uniforms:/*@__PURE__*/new Map([[\"enabled\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(o)],[\"glareSize\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(r)],[\"lensPosition\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(a)],[\"time\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(0)],[\"screenRes\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(n)],[\"starPoints\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(i)],[\"flareSize\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(s)],[\"flareSpeed\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(l)],[\"flareShape\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(p)],[\"animated\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(_)],[\"anamorphic\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(S)],[\"colorGain\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(g)],[\"lensDirtTexture\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(d)],[\"haloScale\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(m)],[\"secondaryGhosts\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(v)],[\"aditionalStreaks\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(x)],[\"ghostScale\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(f)],[\"starBurst\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(c)],[\"opacity\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(u)]])})}update(t,o,r){const a=this.uniforms.get(\"time\");a&&(a.value+=r)}}const xt=/*@__PURE__*/P(fe),gt=({smoothTime:e=.07,blendFunction:t=23,enabled:o=!0,glareSize:r=.2,lensPosition:a=new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(-25,6,-60),screenRes:n=new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(0,0),starPoints:i=6,flareSize:s=.01,flareSpeed:l=.01,flareShape:p=.01,animated:_=!0,anamorphic:S=!1,colorGain:g=new three__WEBPACK_IMPORTED_MODULE_4__.Color(20,20,20),lensDirtTexture:d=null,haloScale:m=.5,secondaryGhosts:v=!0,aditionalStreaks:x=!0,ghostScale:f=0,opacity:u=1,starBurst:c=!1})=>{const U=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)(({viewport:T})=>T),b=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)(({raycaster:T})=>T),{scene:F,camera:X}=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(D),[C]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector2),[R]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector3),E=(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);return (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.D)((T,N)=>{if(!E?.current)return;const q=E.current.uniforms.get(\"lensPosition\"),$=E.current.uniforms.get(\"opacity\");if(!q||!$)return;let G=1;if(R.copy(a).project(X),R.z>1)return;q.value.x=R.x,q.value.y=R.y,C.x=R.x,C.y=R.y,b.setFromCamera(C,X);const ve=b.intersectObjects(F.children,!0),{object:I}=ve[0]||{};I&&(I.userData?.lensflare===\"no-occlusion\"?G=0:I instanceof three__WEBPACK_IMPORTED_MODULE_4__.Mesh&&(I.material.uniforms?._transmission?.value>.2||I.material._transmission&&I.material._transmission>.2?G=.2:I.material.transparent&&(G=I.material.opacity))),maath__WEBPACK_IMPORTED_MODULE_2__.easing.damp($,\"value\",G,e,N)}),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{if(!E?.current)return;const T=E.current.uniforms.get(\"screenRes\");T&&(T.value.x=U.width,T.value.y=U.height)},[U]),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(xt,{ref:E,blendFunction:t,enabled:o,glareSize:r,lensPosition:a,screenRes:n,starPoints:i,flareSize:s,flareSpeed:l,flareShape:p,animated:_,anamorphic:S,colorGain:g,lensDirtTexture:d,haloScale:m,secondaryGhosts:v,aditionalStreaks:x,ghostScale:f,opacity:u,starBurst:c})},wt=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.BloomEffect,{blendFunction:0}),St=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.BrightnessContrastEffect),yt=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.ChromaticAberrationEffect),Pt=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function({blendFunction:e=23},t){const o=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new postprocessing__WEBPACK_IMPORTED_MODULE_6__.ColorAverageEffect(e),[e]);return /*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{ref:t,object:o,dispose:null})}),bt=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.ColorDepthEffect),Et=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.DepthEffect),Rt=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.DotScreenEffect),Ut=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function({active:e=!0,...t},o){const r=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)(p=>p.invalidate),a=Z(t,\"delay\"),n=Z(t,\"duration\"),i=Z(t,\"strength\"),s=Z(t,\"chromaticAberrationOffset\"),l=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new postprocessing__WEBPACK_IMPORTED_MODULE_6__.GlitchEffect({...t,delay:a,duration:n,strength:i,chromaticAberrationOffset:s}),[a,n,t,i,s]);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{l.mode=e?t.mode||postprocessing__WEBPACK_IMPORTED_MODULE_6__.GlitchMode.SPORADIC:postprocessing__WEBPACK_IMPORTED_MODULE_6__.GlitchMode.DISABLED,r()},[e,l,r,t.mode]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>()=>{l.dispose?.()},[l]),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{ref:o,object:l,dispose:null})}),Ct=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function(e,t){const{camera:o}=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(D),r=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new postprocessing__WEBPACK_IMPORTED_MODULE_6__.GodRaysEffect(o,k(e.sun),e),[o,e]);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>void(r.lightSource=k(e.sun)),[r,e.sun]),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{ref:t,object:r,dispose:null})}),zt=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function({size:e,...t},o){const r=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)(n=>n.invalidate),a=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new postprocessing__WEBPACK_IMPORTED_MODULE_6__.GridEffect(t),[t]);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{e&&a.setSize(e.width,e.height),r()},[a,e,r]),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{ref:o,object:a,dispose:null})}),Tt=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.HueSaturationEffect),At=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.NoiseEffect,{blendFunction:5}),Bt=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function({selection:e=[],selectionLayer:t=10,blendFunction:o,patternTexture:r,edgeStrength:a,pulseSpeed:n,visibleEdgeColor:i,hiddenEdgeColor:s,width:l,height:p,kernelSize:_,blur:S,xRay:g,...d},m){const v=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)(U=>U.invalidate),{scene:x,camera:f}=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(D),u=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new postprocessing__WEBPACK_IMPORTED_MODULE_6__.OutlineEffect(x,f,{blendFunction:o,patternTexture:r,edgeStrength:a,pulseSpeed:n,visibleEdgeColor:i,hiddenEdgeColor:s,width:l,height:p,kernelSize:_,blur:S,xRay:g,...d}),[o,S,f,a,p,s,_,r,n,x,i,l,g]),c=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(H);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{if(!c&&e)return u.selection.set(Array.isArray(e)?e.map(k):[k(e)]),v(),()=>{u.selection.clear(),v()}},[u,e,c,v]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{u.selectionLayer=t,v()},[u,v,t]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(void 0),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{if(c&&c.enabled&&c.selected?.length)return u.selection.set(c.selected),v(),()=>{u.selection.clear(),v()}},[c,u.selection,v]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>()=>{u.dispose()},[u]),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{ref:m,object:u})}),Vt=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function({granularity:e=5},t){const o=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new postprocessing__WEBPACK_IMPORTED_MODULE_6__.PixelationEffect(e),[e]);return /*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{ref:t,object:o,dispose:null})}),Ft=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.ScanlineEffect,{blendFunction:24,density:1.25}),Mt=(e,t)=>e.layers.enable(t.selection.layer),Dt=(e,t)=>e.layers.disable(t.selection.layer),kt=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function({selection:e=[],selectionLayer:t=10,lights:o=[],inverted:r=!1,ignoreBackground:a=!1,luminanceThreshold:n,luminanceSmoothing:i,intensity:s,width:l,height:p,kernelSize:_,mipmapBlur:S,...g},d){o.length===0&&console.warn(\"SelectiveBloom requires lights to work.\");const m=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)(c=>c.invalidate),{scene:v,camera:x}=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(D),f=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{const c=new postprocessing__WEBPACK_IMPORTED_MODULE_6__.SelectiveBloomEffect(v,x,{blendFunction:0,luminanceThreshold:n,luminanceSmoothing:i,intensity:s,width:l,height:p,kernelSize:_,mipmapBlur:S,...g});return c.inverted=r,c.ignoreBackground=a,c},[v,x,n,i,s,l,p,_,S,r,a,g]),u=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(H);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{if(!u&&e)return f.selection.set(Array.isArray(e)?e.map(k):[k(e)]),m(),()=>{f.selection.clear(),m()}},[f,e,u,m]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{f.selection.layer=t,m()},[f,m,t]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{if(o&&o.length>0)return o.forEach(c=>Mt(k(c),f)),m(),()=>{o.forEach(c=>Dt(k(c),f)),m()}},[f,m,o,t]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{if(u&&u.enabled&&u.selected?.length)return f.selection.set(u.selected),m(),()=>{f.selection.clear(),m()}},[u,f.selection,m]),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{ref:d,object:f,dispose:null})}),Gt=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.SepiaEffect),It=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function(e,t){const{camera:o,normalPass:r,downSamplingPass:a,resolutionScale:n}=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(D),i=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>r===null&&a===null?(console.error(\"Please enable the NormalPass in the EffectComposer in order to use SSAO.\"),{}):new postprocessing__WEBPACK_IMPORTED_MODULE_6__.SSAOEffect(o,r&&!a?r.texture:null,{blendFunction:21,samples:30,rings:4,distanceThreshold:1,distanceFalloff:0,rangeThreshold:.5,rangeFalloff:.1,luminanceInfluence:.9,radius:20,bias:.5,intensity:1,color:void 0,normalDepthBuffer:a?a.texture:null,resolutionScale:n??1,depthAwareUpsampling:!0,...e}),[o,a,r,n]);return /*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{ref:t,object:i,dispose:null})}),Lt=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.SMAAEffect),Nt=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.FXAAEffect),jt={fragmentShader:`\n    uniform int rampType;\n\n    uniform vec2 rampStart;\n    uniform vec2 rampEnd;\n\n    uniform vec4 startColor;\n    uniform vec4 endColor;\n\n    uniform float rampBias;\n    uniform float rampGain;\n\n    uniform bool rampMask;\n    uniform bool rampInvert;\n\n    float getBias(float time, float bias) {\n      return time / (((1.0 / bias) - 2.0) * (1.0 - time) + 1.0);\n    }\n\n    float getGain(float time, float gain) {\n      if (time < 0.5)\n        return getBias(time * 2.0, gain) / 2.0;\n      else\n        return getBias(time * 2.0 - 1.0, 1.0 - gain) / 2.0 + 0.5;\n    }\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n      vec2 centerPixel = uv * resolution;\n      vec2 startPixel = rampStart * resolution;\n      vec2 endPixel = rampEnd * resolution;\n\n      float rampAlpha;\n\n      if (rampType == 1) {\n        vec2 fuv = centerPixel / resolution.y;\n        vec2 suv = startPixel / resolution.y;\n        vec2 euv = endPixel / resolution.y;\n\n        float radius = length(suv - euv);\n        float falloff = length(fuv - suv);\n        rampAlpha = smoothstep(0.0, radius, falloff);\n      } else {\n        float radius = length(startPixel - endPixel);\n        vec2 direction = normalize(vec2(endPixel.x - startPixel.x, -(startPixel.y - endPixel.y)));\n\n        float fade = dot(centerPixel - startPixel, direction);\n        if (rampType == 2) fade = abs(fade);\n\n        rampAlpha = smoothstep(0.0, 1.0, fade / radius);\n      }\n\n      rampAlpha = abs((rampInvert ? 1.0 : 0.0) - getBias(rampAlpha, rampBias) * getGain(rampAlpha, rampGain));\n\n      if (rampMask) {\n        vec4 inputBuff = texture2D(inputBuffer, uv);\n        outputColor = mix(inputBuff, inputColor, rampAlpha);\n      } else {\n        outputColor = mix(startColor, endColor, rampAlpha);\n      }\n    }\n  `};var ue=/*@__PURE__*/(e=>(e[e.Linear=0]=\"Linear\",e[e.Radial=1]=\"Radial\",e[e.MirroredLinear=2]=\"MirroredLinear\",e))(ue||{});class pe extends postprocessing__WEBPACK_IMPORTED_MODULE_6__.Effect{constructor({rampType:t=0,rampStart:o=[.5,.5],rampEnd:r=[1,1],startColor:a=[0,0,0,1],endColor:n=[1,1,1,1],rampBias:i=.5,rampGain:s=.5,rampMask:l=!1,rampInvert:p=!1,..._}={}){super(\"RampEffect\",jt.fragmentShader,{..._,uniforms:/*@__PURE__*/new Map([[\"rampType\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(t)],[\"rampStart\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(o)],[\"rampEnd\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(r)],[\"startColor\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(a)],[\"endColor\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(n)],[\"rampBias\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(i)],[\"rampGain\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(s)],[\"rampMask\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(l)],[\"rampInvert\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(p)]])})}}const Ot=/*@__PURE__*/P(pe),Wt=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function({textureSrc:e,texture:t,opacity:o=1,...r},a){const n=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.G)(three__WEBPACK_IMPORTED_MODULE_4__.TextureLoader,e);(0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{n.colorSpace=three__WEBPACK_IMPORTED_MODULE_4__.SRGBColorSpace,n.wrapS=n.wrapT=three__WEBPACK_IMPORTED_MODULE_4__.RepeatWrapping},[n]);const i=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new postprocessing__WEBPACK_IMPORTED_MODULE_6__.TextureEffect({...r,texture:n||t}),[r,n,t]);return /*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{ref:a,object:i,\"blendMode-opacity-value\":o,dispose:null})}),Xt=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.ToneMappingEffect),qt=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.VignetteEffect),Ht=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.ShockWaveEffect),Zt=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function({lut:e,tetrahedralInterpolation:t,...o},r){const a=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new postprocessing__WEBPACK_IMPORTED_MODULE_6__.LUT3DEffect(e,o),[e,o]),n=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)(i=>i.invalidate);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{t&&(a.tetrahedralInterpolation=t),e&&(a.lut=e),n()},[a,n,e,t]),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{ref:r,object:a,dispose:null})}),$t=/*@__PURE__*/P(postprocessing__WEBPACK_IMPORTED_MODULE_6__.TiltShiftEffect,{blendFunction:0}),Kt={fragmentShader:`\n\n    // original shader by Evan Wallace\n\n    #define MAX_ITERATIONS 100\n\n    uniform float blur;\n    uniform float taper;\n    uniform vec2 start;\n    uniform vec2 end;\n    uniform vec2 direction;\n    uniform int samples;\n\n    float random(vec3 scale, float seed) {\n        /* use the fragment position for a different seed per-pixel */\n        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n    }\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec4 color = vec4(0.0);\n        float total = 0.0;\n        vec2 startPixel = vec2(start.x * resolution.x, start.y * resolution.y);\n        vec2 endPixel = vec2(end.x * resolution.x, end.y * resolution.y);\n        float f_samples = float(samples);\n        float half_samples = f_samples / 2.0;\n\n        // use screen diagonal to normalize blur radii\n        float maxScreenDistance = distance(vec2(0.0), resolution); // diagonal distance\n        float gradientRadius = taper * (maxScreenDistance);\n        float blurRadius = blur * (maxScreenDistance / 16.0);\n\n        /* randomize the lookup values to hide the fixed number of samples */\n        float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n        vec2 normal = normalize(vec2(startPixel.y - endPixel.y, endPixel.x - startPixel.x));\n        float radius = smoothstep(0.0, 1.0, abs(dot(uv * resolution - startPixel, normal)) / gradientRadius) * blurRadius;\n\n        #pragma unroll_loop_start\n        for (int i = 0; i <= MAX_ITERATIONS; i++) {\n            if (i >= samples) { break; } // return early if over sample count\n            float f_i = float(i);\n            float s_i = -half_samples + f_i;\n            float percent = (s_i + offset - 0.5) / half_samples;\n            float weight = 1.0 - abs(percent);\n            vec4 sample_i = texture2D(inputBuffer, uv + normalize(direction) / resolution * percent * radius);\n            /* switch to pre-multiplied alpha to correctly blur transparent images */\n            sample_i.rgb *= sample_i.a;\n            color += sample_i * weight;\n            total += weight;\n        }\n        #pragma unroll_loop_end\n\n        outputColor = color / total;\n\n        /* switch back from pre-multiplied alpha */\n        outputColor.rgb /= outputColor.a + 0.00001;\n    }\n    `};class me extends postprocessing__WEBPACK_IMPORTED_MODULE_6__.Effect{constructor({blendFunction:t=23,blur:o=.15,taper:r=.5,start:a=[.5,0],end:n=[.5,1],samples:i=10,direction:s=[1,1]}={}){super(\"TiltShiftEffect\",Kt.fragmentShader,{blendFunction:t,attributes:2,uniforms:/*@__PURE__*/new Map([[\"blur\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(o)],[\"taper\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(r)],[\"start\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(a)],[\"end\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(n)],[\"samples\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(i)],[\"direction\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(s)]])})}}const Yt=/*@__PURE__*/P(me,{blendFunction:23}),Jt=`\nuniform sampler2D uCharacters;\nuniform float uCharactersCount;\nuniform float uCellSize;\nuniform bool uInvert;\nuniform vec3 uColor;\n\nconst vec2 SIZE = vec2(16.);\n\nvec3 greyscale(vec3 color, float strength) {\n    float g = dot(color, vec3(0.299, 0.587, 0.114));\n    return mix(color, vec3(g), strength);\n}\n\nvec3 greyscale(vec3 color) {\n    return greyscale(color, 1.0);\n}\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n    vec2 cell = resolution / uCellSize;\n    vec2 grid = 1.0 / cell;\n    vec2 pixelizedUV = grid * (0.5 + floor(uv / grid));\n    vec4 pixelized = texture2D(inputBuffer, pixelizedUV);\n    float greyscaled = greyscale(pixelized.rgb).r;\n\n    if (uInvert) {\n        greyscaled = 1.0 - greyscaled;\n    }\n\n    float characterIndex = floor((uCharactersCount - 1.0) * greyscaled);\n    vec2 characterPosition = vec2(mod(characterIndex, SIZE.x), floor(characterIndex / SIZE.y));\n    vec2 offset = vec2(characterPosition.x, -characterPosition.y) / SIZE;\n    vec2 charUV = mod(uv * (cell / SIZE), 1.0 / SIZE) - vec2(0., 1.0 / SIZE) + offset;\n    vec4 asciiCharacter = texture2D(uCharacters, charUV);\n\n    asciiCharacter.rgb = uColor * asciiCharacter.r;\n    asciiCharacter.a = pixelized.a;\n    outputColor = asciiCharacter;\n}\n`;class Qt extends postprocessing__WEBPACK_IMPORTED_MODULE_6__.Effect{constructor({font:t=\"arial\",characters:o=\" .:,'-^=*+?!|0#X%WM@\",fontSize:r=54,cellSize:a=16,color:n=\"#ffffff\",invert:i=!1}={}){const s=/*@__PURE__*/new Map([[\"uCharacters\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(new three__WEBPACK_IMPORTED_MODULE_4__.Texture)],[\"uCellSize\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(a)],[\"uCharactersCount\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(o.length)],[\"uColor\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(new three__WEBPACK_IMPORTED_MODULE_4__.Color(n))],[\"uInvert\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(i)]]);super(\"ASCIIEffect\",Jt,{uniforms:s});const l=this.uniforms.get(\"uCharacters\");l&&(l.value=this.createCharactersTexture(o,t,r))}createCharactersTexture(t,o,r){const a=document.createElement(\"canvas\"),n=1024,i=16,s=n/i;a.width=a.height=n;const l=new three__WEBPACK_IMPORTED_MODULE_4__.CanvasTexture(a,void 0,three__WEBPACK_IMPORTED_MODULE_4__.RepeatWrapping,three__WEBPACK_IMPORTED_MODULE_4__.RepeatWrapping,three__WEBPACK_IMPORTED_MODULE_4__.NearestFilter,three__WEBPACK_IMPORTED_MODULE_4__.NearestFilter),p=a.getContext(\"2d\");if(!p)throw new Error(\"Context not available\");p.clearRect(0,0,n,n),p.font=`${r}px ${o}`,p.textAlign=\"center\",p.textBaseline=\"middle\",p.fillStyle=\"#fff\";for(let _=0;_<t.length;_++){const S=t[_],g=_%i,d=Math.floor(_/i);p.fillText(S,g*s+s/2,d*s+s/2)}return l.needsUpdate=!0,l}}const eo=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({font:e=\"arial\",characters:t=\" .:,'-^=*+?!|0#X%WM@\",fontSize:o=54,cellSize:r=16,color:a=\"#ffffff\",invert:n=!1},i)=>{const s=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new Qt({characters:t,font:e,fontSize:o,cellSize:r,color:a,invert:n}),[t,o,r,a,n,e]);return /*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{ref:i,object:s})}),to={fragmentShader:`\n    uniform float factor;\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n      vec2 vUv = uv;\n      float frequency = 6.0 * factor;\n      float amplitude = 0.015 * factor;\n      float x = vUv.y * frequency + time * 0.7; \n      float y = vUv.x * frequency + time * 0.3;\n      vUv.x += cos(x + y) * amplitude * cos(y);\n      vUv.y += sin(x - y) * amplitude * cos(y);\n      vec4 rgba = texture(inputBuffer, vUv);\n      outputColor = rgba;\n    }\n  `};class de extends postprocessing__WEBPACK_IMPORTED_MODULE_6__.Effect{constructor({blendFunction:t=23,factor:o=0}={}){super(\"WaterEffect\",to.fragmentShader,{blendFunction:t,attributes:2,uniforms:/*@__PURE__*/new Map([[\"factor\",new three__WEBPACK_IMPORTED_MODULE_4__.Uniform(o)]])})}}const oo=/*@__PURE__*/P(de,{blendFunction:23}),ao=/*@__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({halfRes:e,screenSpaceRadius:t,quality:o,depthAwareUpsampling:r=!0,aoRadius:a=5,aoSamples:n=16,denoiseSamples:i=4,denoiseRadius:s=12,distanceFalloff:l=1,intensity:p=1,color:_,renderMode:S=0},g)=>{const{camera:d,scene:m}=(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)(),v=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new n8ao__WEBPACK_IMPORTED_MODULE_3__.N8AOPostPass(m,d),[d,m]);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.s)(v.configuration,{color:_,aoRadius:a,distanceFalloff:l,intensity:p,aoSamples:n,denoiseSamples:i,denoiseRadius:s,screenSpaceRadius:t,renderMode:S,halfRes:e,depthAwareUpsampling:r})},[t,_,a,l,p,n,i,s,S,e,r,v]),(0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{o&&v.setQualityMode(o.charAt(0).toUpperCase()+o.slice(1))},[v,o]),/*@__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"primitive\",{ref:g,object:v})});\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3NpbmcvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaytDLHFCQUFxQixvREFBRSxPQUFPLGFBQWEsd0JBQXdCLEVBQUUsV0FBVywrQ0FBQyxPQUFPLDhDQUFDLE9BQU8sOEJBQThCLFdBQVcsb0JBQW9CLHNEQUFDLGFBQWEsbUJBQW1CLEVBQUUsYUFBYSw2QkFBNkIsRUFBRSxRQUFRLDZDQUFDLFNBQVMsaURBQUMsSUFBSSxPQUFPLGdEQUFDLE1BQU0sU0FBUyxTQUFTLFdBQVcsMEJBQTBCLDhEQUE4RCx5Q0FBeUMsMkNBQTJDLHVCQUF1QixzREFBQyxVQUFVLHNCQUFzQixFQUFFLHFCQUFxQixvREFBRSx1REFBdUQsMkNBQUUsY0FBYyxpREFBQyxHQUFHLGtMQUFrTCxnREFBRSxDQUFDLE1BQU0sTUFBTSw2QkFBNkIsQ0FBQyxxREFBQyx5QkFBeUIsOENBQUMsTUFBTSxZQUFZLDBEQUFFLElBQUksZ0VBQWdFLEVBQUUsY0FBYyxzREFBRSxPQUFPLGtCQUFrQixpQkFBaUIsc0RBQUUsbURBQW1ELGlFQUFFLEVBQUUseUNBQXlDLHNDQUFzQyxzQkFBc0IsZ0RBQUMseUNBQXlDLHFEQUFDLFNBQVMsTUFBTSxvQkFBb0IsaUVBQWlFLFFBQVEsUUFBUSw2Q0FBQyxPQUFPLHNEQUFDLE1BQU0sNkJBQTZCLFNBQVMsbUJBQW1CLFlBQVksV0FBVyxLQUFLLG9CQUFvQixnQkFBZ0Isa0RBQUMsRUFBRSxZQUFZLFdBQVcsV0FBVyxLQUFLLDZCQUE2QixrREFBQyxTQUFTLGVBQWUsWUFBWSxzREFBRSxTQUFTLFVBQVUsa0JBQWtCLGdEQUFFLFlBQVksK0JBQStCLG9DQUFvQyxXQUFXLGtDQUFrQyxxQ0FBcUMsY0FBYyxnREFBQyxNQUFNLHNCQUFzQixxQkFBcUIs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MEVBQTBFLDBDQUFDLE9BQU8sR0FBRyw0QkFBNEIsaUJBQWlCLGtCQUFrQixpREFBQyxHQUFHLDZMQUE2TCxNQUFNLE1BQU0saUJBQWlCLENBQUMscURBQUMsS0FBSyw4Q0FBQyxTQUFTLDhDQUFFLGFBQWEsT0FBTyxzREFBQyxNQUFNLHFEQUFFLGtCQUFrQixnS0FBZ0ssRUFBRSw0QkFBNEIsc0RBQUMsTUFBTSwwREFBMEQscUJBQXFCLHNEQUFDLGNBQWMsZUFBZSxFQUFFLEVBQXF3QjtBQUM1bEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3NpbmcvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7anN4IGFzIHcsanN4cyBhcyBLLEZyYWdtZW50IGFzIFF9ZnJvbVwicmVhY3QvanN4LXJ1bnRpbWVcIjtpbXBvcnQgZWUse2NyZWF0ZUNvbnRleHQgYXMgdGUsdXNlU3RhdGUgYXMgaix1c2VNZW1vIGFzIHosdXNlUmVmIGFzIE8sdXNlQ29udGV4dCBhcyBNLHVzZUVmZmVjdCBhcyBBLG1lbW8gYXMgaGUsZm9yd2FyZFJlZiBhcyBCLHVzZUxheW91dEVmZmVjdCBhcyBMLHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgb2UsdXNlQ2FsbGJhY2sgYXMgYWV9ZnJvbVwicmVhY3RcIjtpbXBvcnQqYXMgaCBmcm9tXCJ0aHJlZVwiO2ltcG9ydHtOb1RvbmVNYXBwaW5nIGFzIF9lLEhhbGZGbG9hdFR5cGUgYXMgeGUsVmVjdG9yMyBhcyBnZSxVbmlmb3JtIGFzIHksVGV4dHVyZUxvYWRlciBhcyB3ZSxTUkdCQ29sb3JTcGFjZSBhcyBTZSxSZXBlYXRXcmFwcGluZyBhcyBZLFRleHR1cmUgYXMgeWUsQ29sb3IgYXMgUGUsQ2FudmFzVGV4dHVyZSBhcyBiZSxOZWFyZXN0RmlsdGVyIGFzIHJlfWZyb21cInRocmVlXCI7aW1wb3J0e3VzZVRocmVlIGFzIFYsdXNlRnJhbWUgYXMgSixleHRlbmQgYXMgRWUsY3JlYXRlUG9ydGFsIGFzIFJlLHVzZUxvYWRlciBhcyBVZSxhcHBseVByb3BzIGFzIENlfWZyb21cIkByZWFjdC10aHJlZS9maWJlclwiO2ltcG9ydHtFZmZlY3RDb21wb3NlciBhcyB6ZSxSZW5kZXJQYXNzIGFzIFRlLE5vcm1hbFBhc3MgYXMgQWUsRGVwdGhEb3duc2FtcGxpbmdQYXNzIGFzIEJlLEVmZmVjdCBhcyBXLEVmZmVjdFBhc3MgYXMgVmUsUGFzcyBhcyBGZSxEZXB0aE9mRmllbGRFZmZlY3QgYXMgTWUsTWFza0Z1bmN0aW9uIGFzIERlLERlcHRoUGlja2luZ1Bhc3MgYXMga2UsQ29weVBhc3MgYXMgR2UsQmxvb21FZmZlY3QgYXMgSWUsQnJpZ2h0bmVzc0NvbnRyYXN0RWZmZWN0IGFzIExlLENocm9tYXRpY0FiZXJyYXRpb25FZmZlY3QgYXMgTmUsQ29sb3JBdmVyYWdlRWZmZWN0IGFzIGplLENvbG9yRGVwdGhFZmZlY3QgYXMgT2UsRGVwdGhFZmZlY3QgYXMgV2UsRG90U2NyZWVuRWZmZWN0IGFzIFhlLEdsaXRjaEVmZmVjdCBhcyBxZSxHbGl0Y2hNb2RlIGFzIG5lLEdvZFJheXNFZmZlY3QgYXMgSGUsR3JpZEVmZmVjdCBhcyBaZSxIdWVTYXR1cmF0aW9uRWZmZWN0IGFzICRlLE5vaXNlRWZmZWN0IGFzIEtlLE91dGxpbmVFZmZlY3QgYXMgWWUsUGl4ZWxhdGlvbkVmZmVjdCBhcyBKZSxTY2FubGluZUVmZmVjdCBhcyBRZSxTZWxlY3RpdmVCbG9vbUVmZmVjdCBhcyBldCxTZXBpYUVmZmVjdCBhcyB0dCxTU0FPRWZmZWN0IGFzIG90LFNNQUFFZmZlY3QgYXMgYXQsRlhBQUVmZmVjdCBhcyBydCxUZXh0dXJlRWZmZWN0IGFzIG50LFRvbmVNYXBwaW5nRWZmZWN0IGFzIHN0LFZpZ25ldHRlRWZmZWN0IGFzIGl0LFNob2NrV2F2ZUVmZmVjdCBhcyBsdCxMVVQzREVmZmVjdCBhcyBjdCxUaWx0U2hpZnRFZmZlY3QgYXMgZnR9ZnJvbVwicG9zdHByb2Nlc3NpbmdcIjtpbXBvcnR7ZWFzaW5nIGFzIHNlfWZyb21cIm1hYXRoXCI7aW1wb3J0e044QU9Qb3N0UGFzcyBhcyB1dH1mcm9tXCJuOGFvXCI7Y29uc3QgSD0vKkBfX1BVUkVfXyovdGUobnVsbCk7ZnVuY3Rpb24gcHQoe2NoaWxkcmVuOmUsZW5hYmxlZDp0PSEwfSl7Y29uc3RbbyxyXT1qKFtdKSxhPXooKCk9Pih7c2VsZWN0ZWQ6byxzZWxlY3Q6cixlbmFibGVkOnR9KSxbbyxyLHRdKTtyZXR1cm4gLypAX19QVVJFX18qL3coSC5Qcm92aWRlcix7dmFsdWU6YSxjaGlsZHJlbjplfSl9ZnVuY3Rpb24gbXQoe2VuYWJsZWQ6ZT0hMSxjaGlsZHJlbjp0LC4uLm99KXtjb25zdCByPU8obnVsbCksYT1NKEgpO3JldHVybiBBKCgpPT57aWYoYSYmZSl7bGV0IG49ITE7Y29uc3QgaT1bXTtpZihyLmN1cnJlbnQudHJhdmVyc2Uocz0+e3MudHlwZT09PVwiTWVzaFwiJiZpLnB1c2gocyksYS5zZWxlY3RlZC5pbmRleE9mKHMpPT09LTEmJihuPSEwKX0pLG4pcmV0dXJuIGEuc2VsZWN0KHM9PlsuLi5zLC4uLmldKSwoKT0+e2Euc2VsZWN0KHM9PnMuZmlsdGVyKGw9PiFpLmluY2x1ZGVzKGwpKSl9fX0sW2UsdCxhXSksLypAX19QVVJFX18qL3coXCJncm91cFwiLHtyZWY6ciwuLi5vLGNoaWxkcmVuOnR9KX1jb25zdCBEPS8qQF9fUFVSRV9fKi90ZShudWxsKSxpZT1lPT4oZS5nZXRBdHRyaWJ1dGVzKCkmMik9PT0yLGR0PS8qQF9fUFVSRV9fKi9oZSgvKkBfX1BVUkVfXyovQigoe2NoaWxkcmVuOmUsY2FtZXJhOnQsc2NlbmU6byxyZXNvbHV0aW9uU2NhbGU6cixlbmFibGVkOmE9ITAscmVuZGVyUHJpb3JpdHk6bj0xLGF1dG9DbGVhcjppPSEwLGRlcHRoQnVmZmVyOnMsZW5hYmxlTm9ybWFsUGFzczpsLHN0ZW5jaWxCdWZmZXI6cCxtdWx0aXNhbXBsaW5nOl89OCxmcmFtZUJ1ZmZlclR5cGU6Uz14ZX0sZyk9Pntjb25zdHtnbDpkLHNjZW5lOm0sY2FtZXJhOnYsc2l6ZTp4fT1WKCksZj1vfHxtLHU9dHx8dixbYyxVLGJdPXooKCk9Pntjb25zdCBDPW5ldyB6ZShkLHtkZXB0aEJ1ZmZlcjpzLHN0ZW5jaWxCdWZmZXI6cCxtdWx0aXNhbXBsaW5nOl8sZnJhbWVCdWZmZXJUeXBlOlN9KTtDLmFkZFBhc3MobmV3IFRlKGYsdSkpO2xldCBSPW51bGwsRT1udWxsO3JldHVybiBsJiYoRT1uZXcgQWUoZix1KSxFLmVuYWJsZWQ9ITEsQy5hZGRQYXNzKEUpLHIhPT12b2lkIDAmJihSPW5ldyBCZSh7bm9ybWFsQnVmZmVyOkUudGV4dHVyZSxyZXNvbHV0aW9uU2NhbGU6cn0pLFIuZW5hYmxlZD0hMSxDLmFkZFBhc3MoUikpKSxbQyxFLFJdfSxbdSxkLHMscCxfLFMsZixsLHJdKTtBKCgpPT5jPy5zZXRTaXplKHgud2lkdGgseC5oZWlnaHQpLFtjLHhdKSxKKChDLFIpPT57aWYoYSl7Y29uc3QgRT1kLmF1dG9DbGVhcjtkLmF1dG9DbGVhcj1pLHAmJiFpJiZkLmNsZWFyU3RlbmNpbCgpLGMucmVuZGVyKFIpLGQuYXV0b0NsZWFyPUV9fSxhP246MCk7Y29uc3QgRj1PKG51bGwpO0woKCk9Pntjb25zdCBDPVtdLFI9Ri5jdXJyZW50Ll9fcjNmO2lmKFImJmMpe2NvbnN0IEU9Ui5jaGlsZHJlbjtmb3IobGV0IFQ9MDtUPEUubGVuZ3RoO1QrKyl7Y29uc3QgTj1FW1RdLm9iamVjdDtpZihOIGluc3RhbmNlb2YgVyl7Y29uc3QgcT1bTl07aWYoIWllKE4pKXtsZXQgRz1udWxsO2Zvcig7KEc9RVtUKzFdPy5vYmplY3QpaW5zdGFuY2VvZiBXJiYhaWUoRyk7KXEucHVzaChHKSxUKyt9Y29uc3QgJD1uZXcgVmUodSwuLi5xKTtDLnB1c2goJCl9ZWxzZSBOIGluc3RhbmNlb2YgRmUmJkMucHVzaChOKX1mb3IoY29uc3QgVCBvZiBDKWM/LmFkZFBhc3MoVCk7VSYmKFUuZW5hYmxlZD0hMCksYiYmKGIuZW5hYmxlZD0hMCl9cmV0dXJuKCk9Pntmb3IoY29uc3QgRSBvZiBDKWM/LnJlbW92ZVBhc3MoRSk7VSYmKFUuZW5hYmxlZD0hMSksYiYmKGIuZW5hYmxlZD0hMSl9fSxbYyxlLHUsVSxiXSksQSgoKT0+e2NvbnN0IEM9ZC50b25lTWFwcGluZztyZXR1cm4gZC50b25lTWFwcGluZz1fZSwoKT0+e2QudG9uZU1hcHBpbmc9Q319LFtkXSk7Y29uc3QgWD16KCgpPT4oe2NvbXBvc2VyOmMsbm9ybWFsUGFzczpVLGRvd25TYW1wbGluZ1Bhc3M6YixyZXNvbHV0aW9uU2NhbGU6cixjYW1lcmE6dSxzY2VuZTpmfSksW2MsVSxiLHIsdSxmXSk7cmV0dXJuIG9lKGcsKCk9PmMsW2NdKSwvKkBfX1BVUkVfXyovdyhELlByb3ZpZGVyLHt2YWx1ZTpYLGNoaWxkcmVuOi8qQF9fUFVSRV9fKi93KFwiZ3JvdXBcIix7cmVmOkYsY2hpbGRyZW46ZX0pfSl9KSksaz1lPT50eXBlb2YgZT09XCJvYmplY3RcIiYmZSE9bnVsbCYmXCJjdXJyZW50XCJpbiBlP2UuY3VycmVudDplO2xldCB2dD0wO2NvbnN0IGxlPS8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCxQPShlLHQpPT5mdW5jdGlvbih7YmxlbmRGdW5jdGlvbjpvPXQ/LmJsZW5kRnVuY3Rpb24sb3BhY2l0eTpyPXQ/Lm9wYWNpdHksLi4uYX0pe2xldCBuPWxlLmdldChlKTtpZighbil7Y29uc3QgbD1gQHJlYWN0LXRocmVlL3Bvc3Rwcm9jZXNzaW5nLyR7ZS5uYW1lfS0ke3Z0Kyt9YDtFZSh7W2xdOmV9KSxsZS5zZXQoZSxuPWwpfWNvbnN0IGk9VihsPT5sLmNhbWVyYSkscz1lZS51c2VNZW1vKCgpPT5bLi4udD8uYXJncz8/W10sLi4uYS5hcmdzPz9bey4uLnQsLi4uYX1dXSxbSlNPTi5zdHJpbmdpZnkoYSldKTtyZXR1cm4gLypAX19QVVJFX18qL3cobix7Y2FtZXJhOmksXCJibGVuZE1vZGUtYmxlbmRGdW5jdGlvblwiOm8sXCJibGVuZE1vZGUtb3BhY2l0eS12YWx1ZVwiOnIsLi4uYSxhcmdzOnN9KX0sWj0oZSx0KT0+e2NvbnN0IG89ZVt0XTtyZXR1cm4gZWUudXNlTWVtbygoKT0+dHlwZW9mIG89PVwibnVtYmVyXCI/bmV3IGguVmVjdG9yMihvLG8pOm8/bmV3IGguVmVjdG9yMiguLi5vKTpuZXcgaC5WZWN0b3IyLFtvXSl9LGNlPS8qQF9fUFVSRV9fKi9CKGZ1bmN0aW9uKHtibGVuZEZ1bmN0aW9uOmUsd29ybGRGb2N1c0Rpc3RhbmNlOnQsd29ybGRGb2N1c1JhbmdlOm8sZm9jdXNEaXN0YW5jZTpyLGZvY3VzUmFuZ2U6YSxmb2NhbExlbmd0aDpuLGJva2VoU2NhbGU6aSxyZXNvbHV0aW9uU2NhbGU6cyxyZXNvbHV0aW9uWDpsLHJlc29sdXRpb25ZOnAsd2lkdGg6XyxoZWlnaHQ6Uyx0YXJnZXQ6ZyxkZXB0aFRleHR1cmU6ZCwuLi5tfSx2KXtjb25zdHtjYW1lcmE6eH09TShEKSxmPWchPW51bGwsdT16KCgpPT57Y29uc3QgYz1uZXcgTWUoeCx7YmxlbmRGdW5jdGlvbjplLHdvcmxkRm9jdXNEaXN0YW5jZTp0LHdvcmxkRm9jdXNSYW5nZTpvLGZvY3VzRGlzdGFuY2U6cixmb2N1c1JhbmdlOmEsZm9jYWxMZW5ndGg6bixib2tlaFNjYWxlOmkscmVzb2x1dGlvblNjYWxlOnMscmVzb2x1dGlvblg6bCxyZXNvbHV0aW9uWTpwLHdpZHRoOl8saGVpZ2h0OlN9KTtmJiYoYy50YXJnZXQ9bmV3IGdlKSxkJiZjLnNldERlcHRoVGV4dHVyZShkLnRleHR1cmUsZC5wYWNraW5nKTtjb25zdCBVPWMubWFza1Bhc3M7cmV0dXJuIFUubWFza0Z1bmN0aW9uPURlLk1VTFRJUExZX1JHQl9TRVRfQUxQSEEsY30sW3gsZSx0LG8scixhLG4saSxzLGwscCxfLFMsZixkXSk7cmV0dXJuIEEoKCk9PigpPT57dS5kaXNwb3NlKCl9LFt1XSksLypAX19QVVJFX18qL3coXCJwcmltaXRpdmVcIix7Li4ubSxyZWY6dixvYmplY3Q6dSx0YXJnZXQ6Z30pfSksaHQ9LypAX19QVVJFX18qL0IoKHt0YXJnZXQ6ZT12b2lkIDAsbW91c2U6dD0hMSxkZWJ1ZzpvPXZvaWQgMCxtYW51YWw6cj0hMSxzbW9vdGhUaW1lOmE9LjI1LC4uLm59LGkpPT57Y29uc3Qgcz1PKG51bGwpLGw9TyhudWxsKSxwPU8obnVsbCksXz1WKCh7c2NlbmU6Yn0pPT5iKSxTPVYoKHtwb2ludGVyOmJ9KT0+Yikse2NvbXBvc2VyOmcsY2FtZXJhOmR9PU0oRCksW21dPWooKCk9Pm5ldyBrZSksW3ZdPWooKCk9Pm5ldyBHZSk7QSgoKT0+KGcuYWRkUGFzcyhtKSxnLmFkZFBhc3ModiksKCk9PntnLnJlbW92ZVBhc3MobSksZy5yZW1vdmVQYXNzKHYpfSksW2csbSx2XSksQSgoKT0+KCk9PnttLmRpc3Bvc2UoKSx2LmRpc3Bvc2UoKX0sW20sdl0pO2NvbnN0W3hdPWooKCk9Pm5ldyBoLlZlY3RvcjMoMCwwLDApKSxbZl09aigoKT0+bmV3IGguVmVjdG9yMygwLDAsMCkpLHU9YWUoYXN5bmMoYixGKT0+KGYueD1iLGYueT1GLGYuej1hd2FpdCBtLnJlYWREZXB0aChmKSxmLno9Zi56KjItMSwxLWYuej4xZS03P2YudW5wcm9qZWN0KGQpOiExKSxbZixtLGRdKSxjPWFlKGFzeW5jKGIsRj0hMCk9PntpZihlKXguc2V0KC4uLmUpO2Vsc2V7Y29uc3R7eDpYLHk6Q309dD9TOnt4OjAseTowfSxSPWF3YWl0IHUoWCxDKTtSJiZ4LmNvcHkoUil9RiYmcy5jdXJyZW50Py50YXJnZXQmJihhPjAmJmI+MD9zZS5kYW1wMyhzLmN1cnJlbnQudGFyZ2V0LHgsYSxiKTpzLmN1cnJlbnQudGFyZ2V0LmNvcHkoeCkpfSxbZSx4LHQsdSxhLFNdKTtKKGFzeW5jKGIsRik9PntyfHxjKEYpLGwuY3VycmVudCYmbC5jdXJyZW50LnBvc2l0aW9uLmNvcHkoeCkscC5jdXJyZW50JiZzLmN1cnJlbnQ/LnRhcmdldCYmcC5jdXJyZW50LnBvc2l0aW9uLmNvcHkocy5jdXJyZW50LnRhcmdldCl9KTtjb25zdCBVPXooKCk9Pih7ZG9mUmVmOnMsaGl0cG9pbnQ6eCx1cGRhdGU6Y30pLFt4LGNdKTtyZXR1cm4gb2UoaSwoKT0+VSxbVV0pLC8qQF9fUFVSRV9fKi9LKFEse2NoaWxkcmVuOltvP1JlKC8qQF9fUFVSRV9fKi9LKFEse2NoaWxkcmVuOlsvKkBfX1BVUkVfXyovSyhcIm1lc2hcIix7cmVmOmwsY2hpbGRyZW46Wy8qQF9fUFVSRV9fKi93KFwic3BoZXJlR2VvbWV0cnlcIix7YXJnczpbbywxNiwxNl19KSwvKkBfX1BVUkVfXyovdyhcIm1lc2hCYXNpY01hdGVyaWFsXCIse2NvbG9yOlwiIzAwZmYwMFwiLG9wYWNpdHk6MSx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExfSldfSksLypAX19QVVJFX18qL0soXCJtZXNoXCIse3JlZjpwLGNoaWxkcmVuOlsvKkBfX1BVUkVfXyovdyhcInNwaGVyZUdlb21ldHJ5XCIse2FyZ3M6W28vMiwxNiwxNl19KSwvKkBfX1BVUkVfXyovdyhcIm1lc2hCYXNpY01hdGVyaWFsXCIse2NvbG9yOlwiIzAwZmYwMFwiLG9wYWNpdHk6LjUsdHJhbnNwYXJlbnQ6ITAsZGVwdGhXcml0ZTohMX0pXX0pXX0pLF8pOm51bGwsLypAX19QVVJFX18qL3coY2Use3JlZjpzLC4uLm4sdGFyZ2V0Onh9KV19KX0pLF90PXtmcmFnbWVudFNoYWRlcjpgXG4gICAgdW5pZm9ybSBmbG9hdCB0aW1lO1xuICAgIHVuaWZvcm0gdmVjMiBsZW5zUG9zaXRpb247XG4gICAgdW5pZm9ybSB2ZWMyIHNjcmVlblJlcztcbiAgICB1bmlmb3JtIHZlYzMgY29sb3JHYWluO1xuICAgIHVuaWZvcm0gZmxvYXQgc3RhclBvaW50cztcbiAgICB1bmlmb3JtIGZsb2F0IGdsYXJlU2l6ZTtcbiAgICB1bmlmb3JtIGZsb2F0IGZsYXJlU2l6ZTtcbiAgICB1bmlmb3JtIGZsb2F0IGZsYXJlU3BlZWQ7XG4gICAgdW5pZm9ybSBmbG9hdCBmbGFyZVNoYXBlO1xuICAgIHVuaWZvcm0gZmxvYXQgaGFsb1NjYWxlO1xuICAgIHVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbiAgICB1bmlmb3JtIGJvb2wgYW5pbWF0ZWQ7XG4gICAgdW5pZm9ybSBib29sIGFuYW1vcnBoaWM7XG4gICAgdW5pZm9ybSBib29sIGVuYWJsZWQ7XG4gICAgdW5pZm9ybSBib29sIHNlY29uZGFyeUdob3N0cztcbiAgICB1bmlmb3JtIGJvb2wgc3RhckJ1cnN0O1xuICAgIHVuaWZvcm0gZmxvYXQgZ2hvc3RTY2FsZTtcbiAgICB1bmlmb3JtIGJvb2wgYWRpdGlvbmFsU3RyZWFrcztcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBsZW5zRGlydFRleHR1cmU7XG4gICAgdmVjMiB2VGV4Q29vcmQ7XG4gICAgXG4gICAgZmxvYXQgcmFuZChmbG9hdCBuKXtyZXR1cm4gZnJhY3Qoc2luKG4pICogNDM3NTguNTQ1MzEyMyk7fVxuXG4gICAgZmxvYXQgbm9pc2UoZmxvYXQgcCl7XG4gICAgICBmbG9hdCBmbCA9IGZsb29yKHApO1xuICAgICAgZmxvYXQgZmMgPSBmcmFjdChwKTtcbiAgICAgIHJldHVybiBtaXgocmFuZChmbCkscmFuZChmbCArIDEuMCksIGZjKTtcbiAgICB9XG5cbiAgICB2ZWMzIGhzdjJyZ2IodmVjMyBjKVxuICAgIHtcbiAgICAgIHZlYzQgayA9IHZlYzQoMS4wLCAyLjAgLyAzLjAsIDEuMCAvIDMuMCwgMy4wKTtcbiAgICAgIHZlYzMgcCA9IGFicyhmcmFjdChjLnh4eCArIGsueHl6KSAqIDYuMCAtIGsud3d3KTtcbiAgICAgIHJldHVybiBjLnogKiBtaXgoay54eHgsIGNsYW1wKHAgLSBrLnh4eCwgMC4wLCAxLjApLCBjLnkpO1xuICAgIH1cblxuICAgIGZsb2F0IHNhdHVyYXRlKGZsb2F0IHgpXG4gICAge1xuICAgICAgcmV0dXJuIGNsYW1wKHgsIDAuLDEuKTtcbiAgICB9XG5cbiAgICB2ZWMyIHJvdGF0ZVVWKHZlYzIgdXYsIGZsb2F0IHJvdGF0aW9uKVxuICAgIHtcbiAgICAgIHJldHVybiB2ZWMyKFxuICAgICAgICAgIGNvcyhyb3RhdGlvbikgKiB1di54ICsgc2luKHJvdGF0aW9uKSAqIHV2LnksXG4gICAgICAgICAgY29zKHJvdGF0aW9uKSAqIHV2LnkgLSBzaW4ocm90YXRpb24pICogdXYueFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBCYXNlZCBvbiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvWHRLZlJWXG4gICAgdmVjMyBkcmF3ZmxhcmUodmVjMiBwLCBmbG9hdCBpbnRlbnNpdHksIGZsb2F0IHJuZCwgZmxvYXQgc3BlZWQsIGludCBpZClcbiAgICB7XG4gICAgICBmbG9hdCBmbGFyZWh1ZW9mZnNldCA9ICgxLiAvIDMyLikgKiBmbG9hdChpZCkgKiAwLjE7XG4gICAgICBmbG9hdCBsaW5ncmFkID0gZGlzdGFuY2UodmVjMigwLiksIHApO1xuICAgICAgZmxvYXQgZXhwZ3JhZCA9IDEuIC8gZXhwKGxpbmdyYWQgKiAoZnJhY3Qocm5kKSAqIDAuNjYgKyAwLjMzKSk7XG4gICAgICB2ZWMzIGNvbGdyYWQgPSBoc3YycmdiKHZlYzMoIGZyYWN0KCAoZXhwZ3JhZCAqIDguKSArIHNwZWVkICogZmxhcmVTcGVlZCArIGZsYXJlaHVlb2Zmc2V0KSwgcG93KDEuLWFicyhleHBncmFkKjIuLTEuKSwgMC40NSksIDIwLjAgKiBleHBncmFkICogaW50ZW5zaXR5KSk7IC8vcmFpbmJvdyBzcGVjdHJ1bSBlZmZlY3RcblxuICAgICAgZmxvYXQgaW50ZXJuYWxTdGFyUG9pbnRzO1xuXG4gICAgICBpZihhbmFtb3JwaGljKXtcbiAgICAgICAgaW50ZXJuYWxTdGFyUG9pbnRzID0gMS4wO1xuICAgICAgfSBlbHNle1xuICAgICAgICBpbnRlcm5hbFN0YXJQb2ludHMgPSBzdGFyUG9pbnRzO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmbG9hdCBibGFkZXMgPSBsZW5ndGgocCAqIGZsYXJlU2hhcGUgKiBzaW4oaW50ZXJuYWxTdGFyUG9pbnRzICogYXRhbihwLngsIHAueSkpKTtcbiAgICAgIFxuICAgICAgZmxvYXQgY29tcCA9IHBvdygxLi1zYXR1cmF0ZShibGFkZXMpLCAoIGFuYW1vcnBoaWMgPyAxMDAuIDogMTIuKSk7XG4gICAgICBjb21wICs9IHNhdHVyYXRlKGV4cGdyYWQtMC45KSAqIDMuO1xuICAgICAgY29tcCA9IHBvdyhjb21wICogZXhwZ3JhZCwgOC4gKyAoMS4taW50ZW5zaXR5KSAqIDUuKTtcbiAgICAgIFxuICAgICAgaWYoZmxhcmVTcGVlZCA+IDAuMCl7XG4gICAgICAgIHJldHVybiB2ZWMzKGNvbXApICogY29sZ3JhZDtcbiAgICAgIH0gZWxzZXtcbiAgICAgICAgcmV0dXJuIHZlYzMoY29tcCkgKiBmbGFyZVNpemUgKiAxNS47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmxvYXQgZGlzdCh2ZWMzIGEsIHZlYzMgYikgeyByZXR1cm4gYWJzKGEueCAtIGIueCkgKyBhYnMoYS55IC0gYi55KSArIGFicyhhLnogLSBiLnopOyB9XG5cbiAgICB2ZWMzIHNhdHVyYXRlKHZlYzMgeClcbiAgICB7XG4gICAgICByZXR1cm4gY2xhbXAoeCwgdmVjMygwLjApLCB2ZWMzKDEuMCkpO1xuICAgIH1cblxuICAgIC8vIEJhc2VkIG9uIGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9YdEtmUlZcbiAgICBmbG9hdCBnbGFyZSh2ZWMyIHV2LCB2ZWMyIHBvcywgZmxvYXQgc2l6ZSlcbiAgICB7XG4gICAgICB2ZWMyIG1haW47XG5cbiAgICAgIGlmKGFuaW1hdGVkKXtcbiAgICAgICAgbWFpbiA9IHJvdGF0ZVVWKHV2LXBvcywgdGltZSAqIDAuMSk7ICAgICAgXG4gICAgICB9IGVsc2V7XG4gICAgICAgIG1haW4gPSB1di1wb3M7ICAgICBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZmxvYXQgYW5nID0gYXRhbihtYWluLnksIG1haW4ueCkgKiAoYW5hbW9ycGhpYyA/IDEuMCA6IHN0YXJQb2ludHMpO1xuICAgICAgZmxvYXQgZGlzdCA9IGxlbmd0aChtYWluKTsgXG4gICAgICBkaXN0ID0gcG93KGRpc3QsIC45KTtcbiAgICAgIFxuICAgICAgZmxvYXQgZjAgPSAxLjAvKGxlbmd0aCh1di1wb3MpKigxLjAvc2l6ZSoxNi4wKSsuMik7XG5cbiAgICAgIHJldHVybiBmMCtmMCooc2luKChhbmcpKSouMiArLjMpO1xuICAgIH1cblxuICAgIGZsb2F0IHNkSGV4KHZlYzIgcCl7XG4gICAgICBwID0gYWJzKHApO1xuICAgICAgdmVjMiBxID0gdmVjMihwLngqMi4wKjAuNTc3MzUwMywgcC55ICsgcC54KjAuNTc3MzUwMyk7XG4gICAgICByZXR1cm4gZG90KHN0ZXAocS54eSxxLnl4KSwgMS4wLXEueXgpO1xuICAgIH1cblxuICAgIC8vQmFzZWQgb24gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L2RsbFNSWFxuICAgIGZsb2F0IGZwb3coZmxvYXQgeCwgZmxvYXQgayl7XG4gICAgICByZXR1cm4geCA+IGsgPyBwb3coKHgtaykvKDEuMC1rKSwyLjApIDogMC4wO1xuICAgIH1cblxuICAgIHZlYzMgcmVuZGVyaGV4KHZlYzIgdXYsIHZlYzIgcCwgZmxvYXQgcywgdmVjMyBjb2wpe1xuICAgICAgdXYgLT0gcDtcbiAgICAgIGlmIChhYnModXYueCkgPCAwLjIqcyAmJiBhYnModXYueSkgPCAwLjIqcyl7XG4gICAgICAgICAgcmV0dXJuIG1peCh2ZWMzKDApLG1peCh2ZWMzKDApLGNvbCwwLjEgKyBmcG93KGxlbmd0aCh1di9zKSwwLjEpKjEwLjApLHNtb290aHN0ZXAoMC4wLDAuMSxzZEhleCh1dioyMC4wL3MpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmVjMygwKTtcbiAgICB9XG5cbiAgICAvLyBCYXNlZCBvbiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvNHNYM1JzXG4gICAgdmVjMyBMZW5zRmxhcmUodmVjMiB1diwgdmVjMiBwb3MpXG4gICAge1xuICAgICAgdmVjMiBtYWluID0gdXYtcG9zO1xuICAgICAgdmVjMiB1dmQgPSB1dioobGVuZ3RoKHV2KSk7XG4gICAgICBcbiAgICAgIGZsb2F0IGFuZyA9IGF0YW4obWFpbi54LG1haW4ueSk7XG4gICAgICBcbiAgICAgIGZsb2F0IGYwID0gLjMvKGxlbmd0aCh1di1wb3MpKjE2LjArMS4wKTtcbiAgICAgIFxuICAgICAgZjAgPSBmMCooc2luKG5vaXNlKHNpbihhbmcqMy45LShhbmltYXRlZCA/IHRpbWUgOiAwLjApICogMC4zKSAqIHN0YXJQb2ludHMpKSouMiApO1xuICAgICAgXG4gICAgICBmbG9hdCBmMSA9IG1heCgwLjAxLXBvdyhsZW5ndGgodXYrMS4yKnBvcyksMS45KSwuMCkqNy4wO1xuXG4gICAgICBmbG9hdCBmMiA9IG1heCguOS8oMTAuMCszMi4wKnBvdyhsZW5ndGgodXZkKzAuOTkqcG9zKSwyLjApKSwuMCkqMC4zNTtcbiAgICAgIGZsb2F0IGYyMiA9IG1heCguOS8oMTEuMCszMi4wKnBvdyhsZW5ndGgodXZkKzAuODUqcG9zKSwyLjApKSwuMCkqMC4yMztcbiAgICAgIGZsb2F0IGYyMyA9IG1heCguOS8oMTIuMCszMi4wKnBvdyhsZW5ndGgodXZkKzAuOTUqcG9zKSwyLjApKSwuMCkqMC42O1xuICAgICAgXG4gICAgICB2ZWMyIHV2eCA9IG1peCh1dix1dmQsIDAuMSk7XG4gICAgICBcbiAgICAgIGZsb2F0IGY0ID0gbWF4KDAuMDEtcG93KGxlbmd0aCh1dngrMC40KnBvcyksMi45KSwuMCkqNC4wMjtcbiAgICAgIGZsb2F0IGY0MiA9IG1heCgwLjAtcG93KGxlbmd0aCh1dngrMC40NSpwb3MpLDIuOSksLjApKjQuMTtcbiAgICAgIGZsb2F0IGY0MyA9IG1heCgwLjAxLXBvdyhsZW5ndGgodXZ4KzAuNSpwb3MpLDIuOSksLjApKjQuNjtcbiAgICAgIFxuICAgICAgdXZ4ID0gbWl4KHV2LHV2ZCwtLjQpO1xuICAgICAgXG4gICAgICBmbG9hdCBmNSA9IG1heCgwLjAxLXBvdyhsZW5ndGgodXZ4KzAuMSpwb3MpLDUuNSksLjApKjIuMDtcbiAgICAgIGZsb2F0IGY1MiA9IG1heCgwLjAxLXBvdyhsZW5ndGgodXZ4KzAuMipwb3MpLDUuNSksLjApKjIuMDtcbiAgICAgIGZsb2F0IGY1MyA9IG1heCgwLjAxLXBvdyhsZW5ndGgodXZ4KzAuMSpwb3MpLDUuNSksLjApKjIuMDtcbiAgICAgIFxuICAgICAgdXZ4ID0gbWl4KHV2LHV2ZCwgMi4xKTtcbiAgICAgIFxuICAgICAgZmxvYXQgZjYgPSBtYXgoMC4wMS1wb3cobGVuZ3RoKHV2eC0wLjMqcG9zKSwxLjYxKSwuMCkqMy4xNTk7XG4gICAgICBmbG9hdCBmNjIgPSBtYXgoMC4wMS1wb3cobGVuZ3RoKHV2eC0wLjMyNSpwb3MpLDEuNjE0KSwuMCkqMy4xNDtcbiAgICAgIGZsb2F0IGY2MyA9IG1heCgwLjAxLXBvdyhsZW5ndGgodXZ4LTAuMzg5KnBvcyksMS42MjMpLC4wKSozLjEyO1xuICAgICAgXG4gICAgICB2ZWMzIGMgPSB2ZWMzKGdsYXJlKHV2LHBvcywgZ2xhcmVTaXplKSk7XG5cbiAgICAgIHZlYzIgcHJvdDtcblxuICAgICAgaWYoYW5pbWF0ZWQpe1xuICAgICAgICBwcm90ID0gcm90YXRlVVYodXYgLSBwb3MsICh0aW1lICogMC4xKSk7ICBcbiAgICAgIH0gZWxzZSBpZihhbmFtb3JwaGljKXtcbiAgICAgICAgcHJvdCA9IHJvdGF0ZVVWKHV2IC0gcG9zLCAxLjU3MDc5Nik7ICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3QgPSB1diAtIHBvcztcbiAgICAgIH1cblxuICAgICAgYyArPSBkcmF3ZmxhcmUocHJvdCwgKGFuYW1vcnBoaWMgPyBmbGFyZVNpemUgKiAxMC4gOiBmbGFyZVNpemUpLCAwLjEsIHRpbWUsIDEpO1xuICAgICAgXG4gICAgICBjLnIrPWYxK2YyK2Y0K2Y1K2Y2OyBjLmcrPWYxK2YyMitmNDIrZjUyK2Y2MjsgYy5iKz1mMStmMjMrZjQzK2Y1MytmNjM7XG4gICAgICBjID0gYyoxLjMgKiB2ZWMzKGxlbmd0aCh1dmQpKy4wOSk7XG4gICAgICBjKz12ZWMzKGYwKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgdmVjMyBjYyh2ZWMzIGNvbG9yLCBmbG9hdCBmYWN0b3IsZmxvYXQgZmFjdG9yMilcbiAgICB7XG4gICAgICBmbG9hdCB3ID0gY29sb3IueCtjb2xvci55K2NvbG9yLno7XG4gICAgICByZXR1cm4gbWl4KGNvbG9yLHZlYzModykqZmFjdG9yLHcqZmFjdG9yMik7XG4gICAgfSAgICBcblxuICAgIGZsb2F0IHJuZCh2ZWMyIHApXG4gICAge1xuICAgICAgZmxvYXQgZiA9IGZyYWN0KHNpbihkb3QocCwgdmVjMigxMi4xMjM0LCA3Mi44MzkyKSApKjQ1MTIzLjIpKTtcbiAgICAgIHJldHVybiBmOyAgIFxuICAgIH1cblxuICAgIGZsb2F0IHJuZChmbG9hdCB3KVxuICAgIHtcbiAgICAgIGZsb2F0IGYgPSBmcmFjdChzaW4odykqMTAwMC4pO1xuICAgICAgcmV0dXJuIGY7ICAgXG4gICAgfVxuXG4gICAgZmxvYXQgcmVnU2hhcGUodmVjMiBwLCBpbnQgTilcbiAgICB7XG4gICAgICBmbG9hdCBmO1xuICAgICAgXG4gICAgICBmbG9hdCBhPWF0YW4ocC54LHAueSkrLjI7XG4gICAgICBmbG9hdCBiPTYuMjgzMTkvZmxvYXQoTik7XG4gICAgICBmPXNtb290aHN0ZXAoLjUsLjUxLCBjb3MoZmxvb3IoLjUrYS9iKSpiLWEpKmxlbmd0aChwLnh5KSogMi4wICAtZ2hvc3RTY2FsZSk7XG4gICAgICAgICAgXG4gICAgICByZXR1cm4gZjtcbiAgICB9XG5cbiAgICAvLyBCYXNlZCBvbiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvWGxjM0QyXG4gICAgdmVjMyBjaXJjbGUodmVjMiBwLCBmbG9hdCBzaXplLCBmbG9hdCBkZWNheSwgdmVjMyBjb2xvciwgdmVjMyBjb2xvcjIsIGZsb2F0IGRpc3QsIHZlYzIgcG9zaXRpb24pXG4gICAge1xuICAgICAgZmxvYXQgbCA9IGxlbmd0aChwICsgcG9zaXRpb24qKGRpc3QqMi4pKStzaXplLzIuO1xuICAgICAgZmxvYXQgbDIgPSBsZW5ndGgocCArIHBvc2l0aW9uKihkaXN0KjQuKSkrc2l6ZS8zLjtcbiAgICAgIFxuICAgICAgZmxvYXQgYyA9IG1heCgwLjAxLXBvdyhsZW5ndGgocCArIHBvc2l0aW9uKmRpc3QpLCBzaXplKmdob3N0U2NhbGUpLCAwLjApKjEwLjtcbiAgICAgIGZsb2F0IGMxID0gbWF4KDAuMDAxLXBvdyhsLTAuMywgMS4vNDAuKStzaW4obCoyMC4pLCAwLjApKjMuO1xuICAgICAgZmxvYXQgYzIgPSAgbWF4KDAuMDkvcG93KGxlbmd0aChwLXBvc2l0aW9uKmRpc3QvLjUpKjEuLCAuOTUpLCAwLjApLzIwLjtcbiAgICAgIGZsb2F0IHMgPSBtYXgoMC4wMi1wb3cocmVnU2hhcGUocCo1LiArIHBvc2l0aW9uKmRpc3QqNS4gKyBkZWNheSwgNikgLCAxLiksIDAuMCkqMS41O1xuICAgICAgXG4gICAgICBjb2xvciA9IGNvcyh2ZWMzKDAuNDQsIC4yNCwgLjIpKjE2LiArIGRpc3QvOC4pKjAuNSsuNTtcbiAgICAgIHZlYzMgZiA9IGMqY29sb3I7XG4gICAgICBmICs9IGMxKmNvbG9yO1xuICAgICAgZiArPSBjMipjb2xvcjsgIFxuICAgICAgZiArPSAgcypjb2xvcjtcbiAgICAgIHJldHVybiBmO1xuICAgIH1cblxuICAgIHZlYzQgZ2V0TGVuc0NvbG9yKGZsb2F0IHgpe1xuICAgICAgcmV0dXJuIHZlYzQodmVjMyhtaXgobWl4KG1peChtaXgobWl4KG1peChtaXgobWl4KG1peChtaXgobWl4KG1peChtaXgobWl4KG1peCh2ZWMzKDAuLCAwLiwgMC4pLFxuICAgICAgICB2ZWMzKDAuLCAwLiwgMC4pLCBzbW9vdGhzdGVwKDAuMCwgMC4wNjMsIHgpKSxcbiAgICAgICAgdmVjMygwLiwgMC4sIDAuKSwgc21vb3Roc3RlcCgwLjA2MywgMC4xMjUsIHgpKSxcbiAgICAgICAgdmVjMygwLjAsIDAuLCAwLiksIHNtb290aHN0ZXAoMC4xMjUsIDAuMTg4LCB4KSksXG4gICAgICAgIHZlYzMoMC4xODgsIDAuMTMxLCAwLjExNiksIHNtb290aHN0ZXAoMC4xODgsIDAuMjI3LCB4KSksXG4gICAgICAgIHZlYzMoMC4zMSwgMC4yMDQsIDAuNTM3KSwgc21vb3Roc3RlcCgwLjIyNywgMC4yNTEsIHgpKSxcbiAgICAgICAgdmVjMygwLjE5MiwgMC4xMDYsIDAuMjg2KSwgc21vb3Roc3RlcCgwLjI1MSwgMC4zMTQsIHgpKSxcbiAgICAgICAgdmVjMygwLjEwMiwgMC4wMDgsIDAuMzQxKSwgc21vb3Roc3RlcCgwLjMxNCwgMC4zOTIsIHgpKSxcbiAgICAgICAgdmVjMygwLjA4NiwgMC4wLCAwLjE0MSksIHNtb290aHN0ZXAoMC4zOTIsIDAuNTAyLCB4KSksXG4gICAgICAgIHZlYzMoMS4wLCAwLjMxLCAwLjApLCBzbW9vdGhzdGVwKDAuNTAyLCAwLjYwNCwgeCkpLFxuICAgICAgICB2ZWMzKC4xLCAwLjEsIDAuMSksIHNtb290aHN0ZXAoMC42MDQsIDAuNjQzLCB4KSksXG4gICAgICAgIHZlYzMoMS4wLCAwLjkyOSwgMC4wKSwgc21vb3Roc3RlcCgwLjY0MywgMC43NjEsIHgpKSxcbiAgICAgICAgdmVjMygxLjAsIDAuMDg2LCAwLjQyNCksIHNtb290aHN0ZXAoMC43NjEsIDAuODQ3LCB4KSksXG4gICAgICAgIHZlYzMoMS4wLCAwLjQ5LCAwLjApLCBzbW9vdGhzdGVwKDAuODQ3LCAwLjg5LCB4KSksXG4gICAgICAgIHZlYzMoMC45NDUsIDAuMjc1LCAwLjQ3NSksIHNtb290aHN0ZXAoMC44OSwgMC45NDEsIHgpKSxcbiAgICAgICAgdmVjMygwLjI1MSwgMC4yNzUsIDAuNzk2KSwgc21vb3Roc3RlcCgwLjk0MSwgMS4wLCB4KSkpLFxuICAgICAgMS4wKTtcbiAgICB9XG5cbiAgICBmbG9hdCBkaXJ0Tm9pc2UodmVjMiBwKXtcbiAgICAgIHZlYzIgZiA9IGZyYWN0KHApO1xuICAgICAgZiA9IChmICogZikgKiAoMy4wIC0gKDIuMCAqIGYpKTsgICAgXG4gICAgICBmbG9hdCBuID0gZG90KGZsb29yKHApLCB2ZWMyKDEuMCwgMTU3LjApKTtcbiAgICAgIHZlYzQgYSA9IGZyYWN0KHNpbih2ZWM0KG4gKyAwLjAsIG4gKyAxLjAsIG4gKyAxNTcuMCwgbiArIDE1OC4wKSkgKiA0Mzc1OC41NDUzMTIzKTtcbiAgICAgIHJldHVybiBtaXgobWl4KGEueCwgYS55LCBmLngpLCBtaXgoYS56LCBhLncsIGYueCksIGYueSk7XG4gICAgfSBcblxuICAgIGZsb2F0IGZibSh2ZWMyIHApe1xuICAgICAgY29uc3QgbWF0MiBtID0gbWF0MigwLjgwLCAtMC42MCwgMC42MCwgMC44MCk7XG4gICAgICBmbG9hdCBmID0gMC4wO1xuICAgICAgZiArPSAwLjUwMDAqZGlydE5vaXNlKHApOyBwID0gbSpwKjIuMDI7XG4gICAgICBmICs9IDAuMjUwMCpkaXJ0Tm9pc2UocCk7IHAgPSBtKnAqMi4wMztcbiAgICAgIGYgKz0gMC4xMjUwKmRpcnROb2lzZShwKTsgcCA9IG0qcCoyLjAxO1xuICAgICAgZiArPSAwLjA2MjUqZGlydE5vaXNlKHApO1xuICAgICAgcmV0dXJuIGYvMC45Mzc1O1xuICAgIH1cblxuICAgIHZlYzQgZ2V0TGVuc1N0YXIodmVjMiBwKXtcbiAgICAgIHZlYzIgcHAgPSAocCAtIHZlYzIoMC41KSkgKiAyLjA7XG4gICAgICBmbG9hdCBhID0gYXRhbihwcC55LCBwcC54KTtcbiAgICAgIHZlYzQgY3AgPSB2ZWM0KHNpbihhICogMS4wKSwgbGVuZ3RoKHBwKSwgc2luKGEgKiAxMy4wKSwgc2luKGEgKiA1My4wKSk7XG4gICAgICBmbG9hdCBkID0gc2luKGNsYW1wKHBvdyhsZW5ndGgodmVjMigwLjUpIC0gcCkgKiAwLjUgKyBoYWxvU2NhbGUgLzIuLCA1LjApLCAwLjAsIDEuMCkgKiAzLjE0MTU5KTtcbiAgICAgIHZlYzMgYyA9IHZlYzMoZCkgKiB2ZWMzKGZibShjcC54eSAqIDE2LjApICogZmJtKGNwLnp3ICogOS4wKSAqIG1heChtYXgobWF4KG1heCgwLjUsIHNpbihhICogMS4wKSksIHNpbihhICogMy4wKSAqIDAuOCksIHNpbihhICogNy4wKSAqIDAuOCksIHNpbihhICogOS4wKSAqIDEwLjYpKTtcbiAgICAgIGMgKj0gdmVjMyhtaXgoMi4wLCAoc2luKGxlbmd0aChwcC54eSkgKiAyNTYuMCkgKiAwLjUpICsgMC41LCBzaW4oKGNsYW1wKChsZW5ndGgocHAueHkpIC0gMC44NzUpIC8gMC4xLCAwLjAsIDEuMCkgKyAwLjApICogMi4wICogMy4xNDE1OSkgKiAxLjUpICsgMC41KSAqIDAuMzI3NTtcbiAgICAgIHJldHVybiB2ZWM0KHZlYzMoYyAqIDEuMCksIGQpO1x0XG4gICAgfVxuXG4gICAgdmVjNCBnZXRMZW5zRGlydCh2ZWMyIHApe1xuICAgICAgcC54eSArPSB2ZWMyKGZibShwLnl4ICogMy4wKSwgZmJtKHAueXggKiAyLjApKSAqIDAuMDgyNTtcbiAgICAgIHZlYzMgbyA9IHZlYzMobWl4KDAuMTI1LCAwLjI1LCBtYXgobWF4KHNtb290aHN0ZXAoMC4xLCAwLjAsIGxlbmd0aChwIC0gdmVjMigwLjI1KSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhzdGVwKDAuNCwgMC4wLCBsZW5ndGgocCAtIHZlYzIoMC43NSkpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aHN0ZXAoMC44LCAwLjAsIGxlbmd0aChwIC0gdmVjMigwLjg3NSwgMC4xMjUpKSkpKSk7XG4gICAgICBvICs9IHZlYzMobWF4KGZibShwICogMS4wKSAtIDAuNSwgMC4wKSkgKiAwLjU7XG4gICAgICBvICs9IHZlYzMobWF4KGZibShwICogMi4wKSAtIDAuNSwgMC4wKSkgKiAwLjU7XG4gICAgICBvICs9IHZlYzMobWF4KGZibShwICogNC4wKSAtIDAuNSwgMC4wKSkgKiAwLjI1O1xuICAgICAgbyArPSB2ZWMzKG1heChmYm0ocCAqIDguMCkgLSAwLjc1LCAwLjApKSAqIDEuMDtcbiAgICAgIG8gKz0gdmVjMyhtYXgoZmJtKHAgKiAxNi4wKSAtIDAuNzUsIDAuMCkpICogMC43NTtcbiAgICAgIG8gKz0gdmVjMyhtYXgoZmJtKHAgKiA2NC4wKSAtIDAuNzUsIDAuMCkpICogMC41O1xuICAgICAgcmV0dXJuIHZlYzQoY2xhbXAobywgdmVjMygwLjE1KSwgdmVjMygxLjApKSwgMS4wKTtcdFxuICAgIH1cblxuICAgIHZlYzQgdGV4dHVyZUxpbWl0ZWQoc2FtcGxlcjJEIHRleCwgdmVjMiB0ZXhDb29yZCl7XG4gICAgICBpZigoKHRleENvb3JkLnggPCAwLikgfHwgKHRleENvb3JkLnkgPCAwLikpIHx8ICgodGV4Q29vcmQueCA+IDEuKSB8fCAodGV4Q29vcmQueSA+IDEuKSkpe1xuICAgICAgICByZXR1cm4gdmVjNCgwLjApO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlKHRleCwgdGV4Q29vcmQpOyBcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2ZWM0IHRleHR1cmVEaXN0b3J0ZWQoc2FtcGxlcjJEIHRleCwgdmVjMiB0ZXhDb29yZCwgdmVjMiBkaXJlY3Rpb24sIHZlYzMgZGlzdG9ydGlvbikge1xuICAgICAgcmV0dXJuIHZlYzQodGV4dHVyZUxpbWl0ZWQodGV4LCAodGV4Q29vcmQgKyAoZGlyZWN0aW9uICogZGlzdG9ydGlvbi5yKSkpLnIsXG4gICAgICAgICAgICAgICAgICB0ZXh0dXJlTGltaXRlZCh0ZXgsICh0ZXhDb29yZCArIChkaXJlY3Rpb24gKiBkaXN0b3J0aW9uLmcpKSkuZyxcbiAgICAgICAgICAgICAgICAgIHRleHR1cmVMaW1pdGVkKHRleCwgKHRleENvb3JkICsgKGRpcmVjdGlvbiAqIGRpc3RvcnRpb24uYikpKS5iLFxuICAgICAgICAgICAgICAgICAgMS4wKTtcbiAgICB9XG5cbiAgICAvLyBCYXNlZCBvbiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvNHNLM1czXG4gICAgdmVjNCBnZXRTdGFydEJ1cnN0KCl7XG4gICAgICB2ZWMyIGFzcGVjdFRleENvb3JkID0gdmVjMigxLjApIC0gKCgodlRleENvb3JkIC0gdmVjMigwLjUpKSAqIHZlYzIoMS4wKSkgKyB2ZWMyKDAuNSkpOyBcbiAgICAgIHZlYzIgdGV4Q29vcmQgPSB2ZWMyKDEuMCkgLSB2VGV4Q29vcmQ7IFxuICAgICAgdmVjMiBnaG9zdFZlYyA9ICh2ZWMyKDAuNSkgLSB0ZXhDb29yZCkgKiAwLjMgLSBsZW5zUG9zaXRpb247XG4gICAgICB2ZWMyIGdob3N0VmVjQXNwZWN0Tm9ybWFsaXplZCA9IG5vcm1hbGl6ZShnaG9zdFZlYyAqIHZlYzIoMS4wKSkgKiB2ZWMyKDEuMCk7XG4gICAgICB2ZWMyIGhhbG9WZWMgPSBub3JtYWxpemUoZ2hvc3RWZWMpICogMC42O1xuICAgICAgdmVjMiBoYWxvVmVjQXNwZWN0Tm9ybWFsaXplZCA9IGdob3N0VmVjQXNwZWN0Tm9ybWFsaXplZCAqIDAuNjtcbiAgICAgIHZlYzIgdGV4ZWxTaXplID0gdmVjMigxLjApIC8gdmVjMihzY3JlZW5SZXMueHkpO1xuICAgICAgdmVjMyBkaXN0b3J0aW9uID0gdmVjMygtKHRleGVsU2l6ZS54ICogMS41KSwgMC4yLCB0ZXhlbFNpemUueCAqIDEuNSk7XG4gICAgICB2ZWM0IGMgPSB2ZWM0KDAuMCk7XG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICB2ZWMyIG9mZnNldCA9IHRleENvb3JkICsgKGdob3N0VmVjICogZmxvYXQoaSkpO1xuICAgICAgICBjICs9IHRleHR1cmVEaXN0b3J0ZWQobGVuc0RpcnRUZXh0dXJlLCBvZmZzZXQsIGdob3N0VmVjQXNwZWN0Tm9ybWFsaXplZCwgZGlzdG9ydGlvbikgKiBwb3cobWF4KDAuMCwgMS4wIC0gKGxlbmd0aCh2ZWMyKDAuNSkgLSBvZmZzZXQpIC8gbGVuZ3RoKHZlYzIoMC41KSkpKSwgMTAuMCk7XG4gICAgICB9ICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgIHZlYzIgaGFsb09mZnNldCA9IHRleENvb3JkICsgaGFsb1ZlY0FzcGVjdE5vcm1hbGl6ZWQ7IFxuICAgICAgcmV0dXJuIChjICogZ2V0TGVuc0NvbG9yKChsZW5ndGgodmVjMigwLjUpIC0gYXNwZWN0VGV4Q29vcmQpIC8gbGVuZ3RoKHZlYzIoaGFsb1NjYWxlKSkpKSkgKyBcbiAgICAgICAgICAgICh0ZXh0dXJlRGlzdG9ydGVkKGxlbnNEaXJ0VGV4dHVyZSwgaGFsb09mZnNldCwgZ2hvc3RWZWNBc3BlY3ROb3JtYWxpemVkLCBkaXN0b3J0aW9uKSAqIHBvdyhtYXgoMC4wLCAxLjAgLSAobGVuZ3RoKHZlYzIoMC41KSAtIGhhbG9PZmZzZXQpIC8gbGVuZ3RoKHZlYzIoMC41KSkpKSwgMTAuMCkpO1xuICAgIH0gXG5cbiAgICB2b2lkIG1haW5JbWFnZSh2ZWM0IGlucHV0Q29sb3IsIHZlYzIgdXYsIG91dCB2ZWM0IG91dHB1dENvbG9yKVxuICAgIHtcbiAgICAgIHZlYzIgbXlVViA9IHV2IC0wLjU7XG4gICAgICBteVVWLnkgKj0gc2NyZWVuUmVzLnkvc2NyZWVuUmVzLng7XG4gICAgICB2ZWMyIGZpbmFsTGVuc1Bvc2l0aW9uID0gbGVuc1Bvc2l0aW9uICogMC41O1xuICAgICAgZmluYWxMZW5zUG9zaXRpb24ueSAqPSBzY3JlZW5SZXMueS9zY3JlZW5SZXMueDtcbiAgICAgIFxuICAgICAgLy9GaXJzdCBMZW5zIGZsYXJlIHBhc3NcbiAgICAgIHZlYzMgZmluYWxDb2xvciA9IExlbnNGbGFyZShteVVWLCBmaW5hbExlbnNQb3NpdGlvbikgKiAyMC4wICogY29sb3JHYWluIC8gMjU2LjtcblxuICAgICAgLy9BZGl0aW9uYWwgc3RyZWFrc1xuICAgICAgaWYoYWRpdGlvbmFsU3RyZWFrcyl7XG4gICAgICAgIHZlYzMgY2lyY0NvbG9yID0gdmVjMygwLjksIDAuMiwgMC4xKTtcbiAgICAgICAgdmVjMyBjaXJjQ29sb3IyID0gdmVjMygwLjMsIDAuMSwgMC45KTtcblxuICAgICAgICBmb3IoZmxvYXQgaT0wLjtpPDEwLjtpKyspe1xuICAgICAgICAgIGZpbmFsQ29sb3IgKz0gY2lyY2xlKG15VVYsIHBvdyhybmQoaSoyMDAwLikqMi44LCAuMSkrMS40MSwgMC4wLCBjaXJjQ29sb3IraSAsIGNpcmNDb2xvcjIraSwgcm5kKGkqMjAuKSozLiswLjItLjUsIGxlbnNQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9BbHRlcm5hdGl2ZSBnaG9zdHNcbiAgICAgIGlmKHNlY29uZGFyeUdob3N0cyl7XG4gICAgICAgIHZlYzMgYWx0R2hvc3RzID0gdmVjMygwKTtcbiAgICAgICAgYWx0R2hvc3RzICs9IHJlbmRlcmhleChteVVWLCAtbGVuc1Bvc2l0aW9uKjAuMjUsIGdob3N0U2NhbGUgKiAxLjQsIHZlYzMoMC4yNSwwLjM1LDApKTtcbiAgICAgICAgYWx0R2hvc3RzICs9IHJlbmRlcmhleChteVVWLCBsZW5zUG9zaXRpb24qMC4yNSwgZ2hvc3RTY2FsZSAqIDAuNSwgdmVjMygxLDAuNSwwLjUpKTtcbiAgICAgICAgYWx0R2hvc3RzICs9IHJlbmRlcmhleChteVVWLCBsZW5zUG9zaXRpb24qMC4xLCBnaG9zdFNjYWxlICogMS42LCB2ZWMzKDEsMSwxKSk7XG4gICAgICAgIGFsdEdob3N0cyArPSByZW5kZXJoZXgobXlVViwgbGVuc1Bvc2l0aW9uKjEuOCwgZ2hvc3RTY2FsZSAqIDIuMCwgdmVjMygwLDAuNSwwLjc1KSk7XG4gICAgICAgIGFsdEdob3N0cyArPSByZW5kZXJoZXgobXlVViwgbGVuc1Bvc2l0aW9uKjEuMjUsIGdob3N0U2NhbGUgKiAwLjgsIHZlYzMoMSwxLDAuNSkpO1xuICAgICAgICBhbHRHaG9zdHMgKz0gcmVuZGVyaGV4KG15VVYsIC1sZW5zUG9zaXRpb24qMS4yNSwgZ2hvc3RTY2FsZSAqIDUuMCwgdmVjMygwLjUsMC41LDAuMjUpKTtcbiAgICAgICAgXG4gICAgICAgIC8vQ2lyY3VsYXIgZ2hvc3RzXG4gICAgICAgIGFsdEdob3N0cyArPSBmcG93KDEuMCAtIGFicyhkaXN0YW5jZShsZW5zUG9zaXRpb24qMC44LG15VVYpIC0gMC43KSwwLjk4NSkqY29sb3JHYWluIC8gMjEwMC47XG4gICAgICAgIGZpbmFsQ29sb3IgKz0gYWx0R2hvc3RzO1xuICAgICAgfVxuICAgICAgXG5cbiAgICAgIC8vU3RhcmJ1cnN0ICAgICAgICAgICAgICAgICAgICAgXG4gICAgICBpZihzdGFyQnVyc3Qpe1xuICAgICAgICB2VGV4Q29vcmQgPSBteVVWICsgMC41O1xuICAgICAgICB2ZWM0IGxlbnNNb2QgPSBnZXRMZW5zRGlydChteVVWKTtcbiAgICAgICAgZmxvYXQgdG9vQnJpZ2h0ID0gMS4wIC0gKGNsYW1wKDAuNSwgMC4wLCAwLjUpICogMi4wKTsgXG4gICAgICAgIGZsb2F0IHRvb0RhcmsgPSBjbGFtcCgwLjUgLSAwLjUsIDAuMCwgMC41KSAqIDIuMDtcbiAgICAgICAgbGVuc01vZCArPSBtaXgobGVuc01vZCwgcG93KGxlbnNNb2QgKiAyLjAsIHZlYzQoMi4wKSkgKiAwLjUsIHRvb0JyaWdodCk7XG4gICAgICAgIGZsb2F0IGxlbnNTdGFyUm90YXRpb25BbmdsZSA9ICgobXlVVi54ICsgbXlVVi55KSkgKiAoMS4wIC8gNi4wKTtcbiAgICAgICAgdmVjMiBsZW5zU3RhclRleENvb3JkID0gKG1hdDIoY29zKGxlbnNTdGFyUm90YXRpb25BbmdsZSksIC1zaW4obGVuc1N0YXJSb3RhdGlvbkFuZ2xlKSwgc2luKGxlbnNTdGFyUm90YXRpb25BbmdsZSksIGNvcyhsZW5zU3RhclJvdGF0aW9uQW5nbGUpKSAqIHZUZXhDb29yZCk7XG4gICAgICAgIGxlbnNNb2QgKz0gZ2V0TGVuc1N0YXIobGVuc1N0YXJUZXhDb29yZCkgKiAyLjtcbiAgICAgICAgXG4gICAgICAgIGZpbmFsQ29sb3IgKz0gY2xhbXAoKGxlbnNNb2QucmdiICogZ2V0U3RhcnRCdXJzdCgpLnJnYiApLCAwLjAxLCAxLjApO1xuICAgICAgfVxuXG4gICAgICAvL0ZpbmFsIGNvbXBvc2VkIG91dHB1dFxuICAgICAgaWYoZW5hYmxlZCl7XG4gICAgICAgIG91dHB1dENvbG9yID0gdmVjNChtaXgoZmluYWxDb2xvciwgdmVjMyguMCksIG9wYWNpdHkpICsgaW5wdXRDb2xvci5yZ2IsIGlucHV0Q29sb3IuYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXRDb2xvciA9IHZlYzQoaW5wdXRDb2xvcik7XG4gICAgICB9XG4gICAgfVxuICBgfTtjbGFzcyBmZSBleHRlbmRzIFd7Y29uc3RydWN0b3Ioe2JsZW5kRnVuY3Rpb246dCxlbmFibGVkOm8sZ2xhcmVTaXplOnIsbGVuc1Bvc2l0aW9uOmEsc2NyZWVuUmVzOm4sc3RhclBvaW50czppLGZsYXJlU2l6ZTpzLGZsYXJlU3BlZWQ6bCxmbGFyZVNoYXBlOnAsYW5pbWF0ZWQ6XyxhbmFtb3JwaGljOlMsY29sb3JHYWluOmcsbGVuc0RpcnRUZXh0dXJlOmQsaGFsb1NjYWxlOm0sc2Vjb25kYXJ5R2hvc3RzOnYsYWRpdGlvbmFsU3RyZWFrczp4LGdob3N0U2NhbGU6ZixvcGFjaXR5OnUsc3RhckJ1cnN0OmN9KXtzdXBlcihcIkxlbnNGbGFyZUVmZmVjdFwiLF90LmZyYWdtZW50U2hhZGVyLHtibGVuZEZ1bmN0aW9uOnQsdW5pZm9ybXM6LypAX19QVVJFX18qL25ldyBNYXAoW1tcImVuYWJsZWRcIixuZXcgaC5Vbmlmb3JtKG8pXSxbXCJnbGFyZVNpemVcIixuZXcgaC5Vbmlmb3JtKHIpXSxbXCJsZW5zUG9zaXRpb25cIixuZXcgaC5Vbmlmb3JtKGEpXSxbXCJ0aW1lXCIsbmV3IGguVW5pZm9ybSgwKV0sW1wic2NyZWVuUmVzXCIsbmV3IGguVW5pZm9ybShuKV0sW1wic3RhclBvaW50c1wiLG5ldyBoLlVuaWZvcm0oaSldLFtcImZsYXJlU2l6ZVwiLG5ldyBoLlVuaWZvcm0ocyldLFtcImZsYXJlU3BlZWRcIixuZXcgaC5Vbmlmb3JtKGwpXSxbXCJmbGFyZVNoYXBlXCIsbmV3IGguVW5pZm9ybShwKV0sW1wiYW5pbWF0ZWRcIixuZXcgaC5Vbmlmb3JtKF8pXSxbXCJhbmFtb3JwaGljXCIsbmV3IGguVW5pZm9ybShTKV0sW1wiY29sb3JHYWluXCIsbmV3IGguVW5pZm9ybShnKV0sW1wibGVuc0RpcnRUZXh0dXJlXCIsbmV3IGguVW5pZm9ybShkKV0sW1wiaGFsb1NjYWxlXCIsbmV3IGguVW5pZm9ybShtKV0sW1wic2Vjb25kYXJ5R2hvc3RzXCIsbmV3IGguVW5pZm9ybSh2KV0sW1wiYWRpdGlvbmFsU3RyZWFrc1wiLG5ldyBoLlVuaWZvcm0oeCldLFtcImdob3N0U2NhbGVcIixuZXcgaC5Vbmlmb3JtKGYpXSxbXCJzdGFyQnVyc3RcIixuZXcgaC5Vbmlmb3JtKGMpXSxbXCJvcGFjaXR5XCIsbmV3IGguVW5pZm9ybSh1KV1dKX0pfXVwZGF0ZSh0LG8scil7Y29uc3QgYT10aGlzLnVuaWZvcm1zLmdldChcInRpbWVcIik7YSYmKGEudmFsdWUrPXIpfX1jb25zdCB4dD0vKkBfX1BVUkVfXyovUChmZSksZ3Q9KHtzbW9vdGhUaW1lOmU9LjA3LGJsZW5kRnVuY3Rpb246dD0yMyxlbmFibGVkOm89ITAsZ2xhcmVTaXplOnI9LjIsbGVuc1Bvc2l0aW9uOmE9bmV3IGguVmVjdG9yMygtMjUsNiwtNjApLHNjcmVlblJlczpuPW5ldyBoLlZlY3RvcjIoMCwwKSxzdGFyUG9pbnRzOmk9NixmbGFyZVNpemU6cz0uMDEsZmxhcmVTcGVlZDpsPS4wMSxmbGFyZVNoYXBlOnA9LjAxLGFuaW1hdGVkOl89ITAsYW5hbW9ycGhpYzpTPSExLGNvbG9yR2FpbjpnPW5ldyBoLkNvbG9yKDIwLDIwLDIwKSxsZW5zRGlydFRleHR1cmU6ZD1udWxsLGhhbG9TY2FsZTptPS41LHNlY29uZGFyeUdob3N0czp2PSEwLGFkaXRpb25hbFN0cmVha3M6eD0hMCxnaG9zdFNjYWxlOmY9MCxvcGFjaXR5OnU9MSxzdGFyQnVyc3Q6Yz0hMX0pPT57Y29uc3QgVT1WKCh7dmlld3BvcnQ6VH0pPT5UKSxiPVYoKHtyYXljYXN0ZXI6VH0pPT5UKSx7c2NlbmU6RixjYW1lcmE6WH09TShEKSxbQ109aigoKT0+bmV3IGguVmVjdG9yMiksW1JdPWooKCk9Pm5ldyBoLlZlY3RvcjMpLEU9TyhudWxsKTtyZXR1cm4gSigoVCxOKT0+e2lmKCFFPy5jdXJyZW50KXJldHVybjtjb25zdCBxPUUuY3VycmVudC51bmlmb3Jtcy5nZXQoXCJsZW5zUG9zaXRpb25cIiksJD1FLmN1cnJlbnQudW5pZm9ybXMuZ2V0KFwib3BhY2l0eVwiKTtpZighcXx8ISQpcmV0dXJuO2xldCBHPTE7aWYoUi5jb3B5KGEpLnByb2plY3QoWCksUi56PjEpcmV0dXJuO3EudmFsdWUueD1SLngscS52YWx1ZS55PVIueSxDLng9Ui54LEMueT1SLnksYi5zZXRGcm9tQ2FtZXJhKEMsWCk7Y29uc3QgdmU9Yi5pbnRlcnNlY3RPYmplY3RzKEYuY2hpbGRyZW4sITApLHtvYmplY3Q6SX09dmVbMF18fHt9O0kmJihJLnVzZXJEYXRhPy5sZW5zZmxhcmU9PT1cIm5vLW9jY2x1c2lvblwiP0c9MDpJIGluc3RhbmNlb2YgaC5NZXNoJiYoSS5tYXRlcmlhbC51bmlmb3Jtcz8uX3RyYW5zbWlzc2lvbj8udmFsdWU+LjJ8fEkubWF0ZXJpYWwuX3RyYW5zbWlzc2lvbiYmSS5tYXRlcmlhbC5fdHJhbnNtaXNzaW9uPi4yP0c9LjI6SS5tYXRlcmlhbC50cmFuc3BhcmVudCYmKEc9SS5tYXRlcmlhbC5vcGFjaXR5KSkpLHNlLmRhbXAoJCxcInZhbHVlXCIsRyxlLE4pfSksQSgoKT0+e2lmKCFFPy5jdXJyZW50KXJldHVybjtjb25zdCBUPUUuY3VycmVudC51bmlmb3Jtcy5nZXQoXCJzY3JlZW5SZXNcIik7VCYmKFQudmFsdWUueD1VLndpZHRoLFQudmFsdWUueT1VLmhlaWdodCl9LFtVXSksLypAX19QVVJFX18qL3coeHQse3JlZjpFLGJsZW5kRnVuY3Rpb246dCxlbmFibGVkOm8sZ2xhcmVTaXplOnIsbGVuc1Bvc2l0aW9uOmEsc2NyZWVuUmVzOm4sc3RhclBvaW50czppLGZsYXJlU2l6ZTpzLGZsYXJlU3BlZWQ6bCxmbGFyZVNoYXBlOnAsYW5pbWF0ZWQ6XyxhbmFtb3JwaGljOlMsY29sb3JHYWluOmcsbGVuc0RpcnRUZXh0dXJlOmQsaGFsb1NjYWxlOm0sc2Vjb25kYXJ5R2hvc3RzOnYsYWRpdGlvbmFsU3RyZWFrczp4LGdob3N0U2NhbGU6ZixvcGFjaXR5OnUsc3RhckJ1cnN0OmN9KX0sd3Q9LypAX19QVVJFX18qL1AoSWUse2JsZW5kRnVuY3Rpb246MH0pLFN0PS8qQF9fUFVSRV9fKi9QKExlKSx5dD0vKkBfX1BVUkVfXyovUChOZSksUHQ9LypAX19QVVJFX18qL0IoZnVuY3Rpb24oe2JsZW5kRnVuY3Rpb246ZT0yM30sdCl7Y29uc3Qgbz16KCgpPT5uZXcgamUoZSksW2VdKTtyZXR1cm4gLypAX19QVVJFX18qL3coXCJwcmltaXRpdmVcIix7cmVmOnQsb2JqZWN0Om8sZGlzcG9zZTpudWxsfSl9KSxidD0vKkBfX1BVUkVfXyovUChPZSksRXQ9LypAX19QVVJFX18qL1AoV2UpLFJ0PS8qQF9fUFVSRV9fKi9QKFhlKSxVdD0vKkBfX1BVUkVfXyovQihmdW5jdGlvbih7YWN0aXZlOmU9ITAsLi4udH0sbyl7Y29uc3Qgcj1WKHA9PnAuaW52YWxpZGF0ZSksYT1aKHQsXCJkZWxheVwiKSxuPVoodCxcImR1cmF0aW9uXCIpLGk9Wih0LFwic3RyZW5ndGhcIikscz1aKHQsXCJjaHJvbWF0aWNBYmVycmF0aW9uT2Zmc2V0XCIpLGw9eigoKT0+bmV3IHFlKHsuLi50LGRlbGF5OmEsZHVyYXRpb246bixzdHJlbmd0aDppLGNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQ6c30pLFthLG4sdCxpLHNdKTtyZXR1cm4gTCgoKT0+e2wubW9kZT1lP3QubW9kZXx8bmUuU1BPUkFESUM6bmUuRElTQUJMRUQscigpfSxbZSxsLHIsdC5tb2RlXSksQSgoKT0+KCk9PntsLmRpc3Bvc2U/LigpfSxbbF0pLC8qQF9fUFVSRV9fKi93KFwicHJpbWl0aXZlXCIse3JlZjpvLG9iamVjdDpsLGRpc3Bvc2U6bnVsbH0pfSksQ3Q9LypAX19QVVJFX18qL0IoZnVuY3Rpb24oZSx0KXtjb25zdHtjYW1lcmE6b309TShEKSxyPXooKCk9Pm5ldyBIZShvLGsoZS5zdW4pLGUpLFtvLGVdKTtyZXR1cm4gTCgoKT0+dm9pZChyLmxpZ2h0U291cmNlPWsoZS5zdW4pKSxbcixlLnN1bl0pLC8qQF9fUFVSRV9fKi93KFwicHJpbWl0aXZlXCIse3JlZjp0LG9iamVjdDpyLGRpc3Bvc2U6bnVsbH0pfSksenQ9LypAX19QVVJFX18qL0IoZnVuY3Rpb24oe3NpemU6ZSwuLi50fSxvKXtjb25zdCByPVYobj0+bi5pbnZhbGlkYXRlKSxhPXooKCk9Pm5ldyBaZSh0KSxbdF0pO3JldHVybiBMKCgpPT57ZSYmYS5zZXRTaXplKGUud2lkdGgsZS5oZWlnaHQpLHIoKX0sW2EsZSxyXSksLypAX19QVVJFX18qL3coXCJwcmltaXRpdmVcIix7cmVmOm8sb2JqZWN0OmEsZGlzcG9zZTpudWxsfSl9KSxUdD0vKkBfX1BVUkVfXyovUCgkZSksQXQ9LypAX19QVVJFX18qL1AoS2Use2JsZW5kRnVuY3Rpb246NX0pLEJ0PS8qQF9fUFVSRV9fKi9CKGZ1bmN0aW9uKHtzZWxlY3Rpb246ZT1bXSxzZWxlY3Rpb25MYXllcjp0PTEwLGJsZW5kRnVuY3Rpb246byxwYXR0ZXJuVGV4dHVyZTpyLGVkZ2VTdHJlbmd0aDphLHB1bHNlU3BlZWQ6bix2aXNpYmxlRWRnZUNvbG9yOmksaGlkZGVuRWRnZUNvbG9yOnMsd2lkdGg6bCxoZWlnaHQ6cCxrZXJuZWxTaXplOl8sYmx1cjpTLHhSYXk6ZywuLi5kfSxtKXtjb25zdCB2PVYoVT0+VS5pbnZhbGlkYXRlKSx7c2NlbmU6eCxjYW1lcmE6Zn09TShEKSx1PXooKCk9Pm5ldyBZZSh4LGYse2JsZW5kRnVuY3Rpb246byxwYXR0ZXJuVGV4dHVyZTpyLGVkZ2VTdHJlbmd0aDphLHB1bHNlU3BlZWQ6bix2aXNpYmxlRWRnZUNvbG9yOmksaGlkZGVuRWRnZUNvbG9yOnMsd2lkdGg6bCxoZWlnaHQ6cCxrZXJuZWxTaXplOl8sYmx1cjpTLHhSYXk6ZywuLi5kfSksW28sUyxmLGEscCxzLF8scixuLHgsaSxsLGddKSxjPU0oSCk7cmV0dXJuIEEoKCk9PntpZighYyYmZSlyZXR1cm4gdS5zZWxlY3Rpb24uc2V0KEFycmF5LmlzQXJyYXkoZSk/ZS5tYXAoayk6W2soZSldKSx2KCksKCk9Pnt1LnNlbGVjdGlvbi5jbGVhcigpLHYoKX19LFt1LGUsYyx2XSksQSgoKT0+e3Uuc2VsZWN0aW9uTGF5ZXI9dCx2KCl9LFt1LHYsdF0pLE8odm9pZCAwKSxBKCgpPT57aWYoYyYmYy5lbmFibGVkJiZjLnNlbGVjdGVkPy5sZW5ndGgpcmV0dXJuIHUuc2VsZWN0aW9uLnNldChjLnNlbGVjdGVkKSx2KCksKCk9Pnt1LnNlbGVjdGlvbi5jbGVhcigpLHYoKX19LFtjLHUuc2VsZWN0aW9uLHZdKSxBKCgpPT4oKT0+e3UuZGlzcG9zZSgpfSxbdV0pLC8qQF9fUFVSRV9fKi93KFwicHJpbWl0aXZlXCIse3JlZjptLG9iamVjdDp1fSl9KSxWdD0vKkBfX1BVUkVfXyovQihmdW5jdGlvbih7Z3JhbnVsYXJpdHk6ZT01fSx0KXtjb25zdCBvPXooKCk9Pm5ldyBKZShlKSxbZV0pO3JldHVybiAvKkBfX1BVUkVfXyovdyhcInByaW1pdGl2ZVwiLHtyZWY6dCxvYmplY3Q6byxkaXNwb3NlOm51bGx9KX0pLEZ0PS8qQF9fUFVSRV9fKi9QKFFlLHtibGVuZEZ1bmN0aW9uOjI0LGRlbnNpdHk6MS4yNX0pLE10PShlLHQpPT5lLmxheWVycy5lbmFibGUodC5zZWxlY3Rpb24ubGF5ZXIpLER0PShlLHQpPT5lLmxheWVycy5kaXNhYmxlKHQuc2VsZWN0aW9uLmxheWVyKSxrdD0vKkBfX1BVUkVfXyovQihmdW5jdGlvbih7c2VsZWN0aW9uOmU9W10sc2VsZWN0aW9uTGF5ZXI6dD0xMCxsaWdodHM6bz1bXSxpbnZlcnRlZDpyPSExLGlnbm9yZUJhY2tncm91bmQ6YT0hMSxsdW1pbmFuY2VUaHJlc2hvbGQ6bixsdW1pbmFuY2VTbW9vdGhpbmc6aSxpbnRlbnNpdHk6cyx3aWR0aDpsLGhlaWdodDpwLGtlcm5lbFNpemU6XyxtaXBtYXBCbHVyOlMsLi4uZ30sZCl7by5sZW5ndGg9PT0wJiZjb25zb2xlLndhcm4oXCJTZWxlY3RpdmVCbG9vbSByZXF1aXJlcyBsaWdodHMgdG8gd29yay5cIik7Y29uc3QgbT1WKGM9PmMuaW52YWxpZGF0ZSkse3NjZW5lOnYsY2FtZXJhOnh9PU0oRCksZj16KCgpPT57Y29uc3QgYz1uZXcgZXQodix4LHtibGVuZEZ1bmN0aW9uOjAsbHVtaW5hbmNlVGhyZXNob2xkOm4sbHVtaW5hbmNlU21vb3RoaW5nOmksaW50ZW5zaXR5OnMsd2lkdGg6bCxoZWlnaHQ6cCxrZXJuZWxTaXplOl8sbWlwbWFwQmx1cjpTLC4uLmd9KTtyZXR1cm4gYy5pbnZlcnRlZD1yLGMuaWdub3JlQmFja2dyb3VuZD1hLGN9LFt2LHgsbixpLHMsbCxwLF8sUyxyLGEsZ10pLHU9TShIKTtyZXR1cm4gQSgoKT0+e2lmKCF1JiZlKXJldHVybiBmLnNlbGVjdGlvbi5zZXQoQXJyYXkuaXNBcnJheShlKT9lLm1hcChrKTpbayhlKV0pLG0oKSwoKT0+e2Yuc2VsZWN0aW9uLmNsZWFyKCksbSgpfX0sW2YsZSx1LG1dKSxBKCgpPT57Zi5zZWxlY3Rpb24ubGF5ZXI9dCxtKCl9LFtmLG0sdF0pLEEoKCk9PntpZihvJiZvLmxlbmd0aD4wKXJldHVybiBvLmZvckVhY2goYz0+TXQoayhjKSxmKSksbSgpLCgpPT57by5mb3JFYWNoKGM9PkR0KGsoYyksZikpLG0oKX19LFtmLG0sbyx0XSksQSgoKT0+e2lmKHUmJnUuZW5hYmxlZCYmdS5zZWxlY3RlZD8ubGVuZ3RoKXJldHVybiBmLnNlbGVjdGlvbi5zZXQodS5zZWxlY3RlZCksbSgpLCgpPT57Zi5zZWxlY3Rpb24uY2xlYXIoKSxtKCl9fSxbdSxmLnNlbGVjdGlvbixtXSksLypAX19QVVJFX18qL3coXCJwcmltaXRpdmVcIix7cmVmOmQsb2JqZWN0OmYsZGlzcG9zZTpudWxsfSl9KSxHdD0vKkBfX1BVUkVfXyovUCh0dCksSXQ9LypAX19QVVJFX18qL0IoZnVuY3Rpb24oZSx0KXtjb25zdHtjYW1lcmE6byxub3JtYWxQYXNzOnIsZG93blNhbXBsaW5nUGFzczphLHJlc29sdXRpb25TY2FsZTpufT1NKEQpLGk9eigoKT0+cj09PW51bGwmJmE9PT1udWxsPyhjb25zb2xlLmVycm9yKFwiUGxlYXNlIGVuYWJsZSB0aGUgTm9ybWFsUGFzcyBpbiB0aGUgRWZmZWN0Q29tcG9zZXIgaW4gb3JkZXIgdG8gdXNlIFNTQU8uXCIpLHt9KTpuZXcgb3QobyxyJiYhYT9yLnRleHR1cmU6bnVsbCx7YmxlbmRGdW5jdGlvbjoyMSxzYW1wbGVzOjMwLHJpbmdzOjQsZGlzdGFuY2VUaHJlc2hvbGQ6MSxkaXN0YW5jZUZhbGxvZmY6MCxyYW5nZVRocmVzaG9sZDouNSxyYW5nZUZhbGxvZmY6LjEsbHVtaW5hbmNlSW5mbHVlbmNlOi45LHJhZGl1czoyMCxiaWFzOi41LGludGVuc2l0eToxLGNvbG9yOnZvaWQgMCxub3JtYWxEZXB0aEJ1ZmZlcjphP2EudGV4dHVyZTpudWxsLHJlc29sdXRpb25TY2FsZTpuPz8xLGRlcHRoQXdhcmVVcHNhbXBsaW5nOiEwLC4uLmV9KSxbbyxhLHIsbl0pO3JldHVybiAvKkBfX1BVUkVfXyovdyhcInByaW1pdGl2ZVwiLHtyZWY6dCxvYmplY3Q6aSxkaXNwb3NlOm51bGx9KX0pLEx0PS8qQF9fUFVSRV9fKi9QKGF0KSxOdD0vKkBfX1BVUkVfXyovUChydCksanQ9e2ZyYWdtZW50U2hhZGVyOmBcbiAgICB1bmlmb3JtIGludCByYW1wVHlwZTtcblxuICAgIHVuaWZvcm0gdmVjMiByYW1wU3RhcnQ7XG4gICAgdW5pZm9ybSB2ZWMyIHJhbXBFbmQ7XG5cbiAgICB1bmlmb3JtIHZlYzQgc3RhcnRDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzQgZW5kQ29sb3I7XG5cbiAgICB1bmlmb3JtIGZsb2F0IHJhbXBCaWFzO1xuICAgIHVuaWZvcm0gZmxvYXQgcmFtcEdhaW47XG5cbiAgICB1bmlmb3JtIGJvb2wgcmFtcE1hc2s7XG4gICAgdW5pZm9ybSBib29sIHJhbXBJbnZlcnQ7XG5cbiAgICBmbG9hdCBnZXRCaWFzKGZsb2F0IHRpbWUsIGZsb2F0IGJpYXMpIHtcbiAgICAgIHJldHVybiB0aW1lIC8gKCgoMS4wIC8gYmlhcykgLSAyLjApICogKDEuMCAtIHRpbWUpICsgMS4wKTtcbiAgICB9XG5cbiAgICBmbG9hdCBnZXRHYWluKGZsb2F0IHRpbWUsIGZsb2F0IGdhaW4pIHtcbiAgICAgIGlmICh0aW1lIDwgMC41KVxuICAgICAgICByZXR1cm4gZ2V0Qmlhcyh0aW1lICogMi4wLCBnYWluKSAvIDIuMDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGdldEJpYXModGltZSAqIDIuMCAtIDEuMCwgMS4wIC0gZ2FpbikgLyAyLjAgKyAwLjU7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLCBjb25zdCBpbiB2ZWMyIHV2LCBvdXQgdmVjNCBvdXRwdXRDb2xvcikge1xuICAgICAgdmVjMiBjZW50ZXJQaXhlbCA9IHV2ICogcmVzb2x1dGlvbjtcbiAgICAgIHZlYzIgc3RhcnRQaXhlbCA9IHJhbXBTdGFydCAqIHJlc29sdXRpb247XG4gICAgICB2ZWMyIGVuZFBpeGVsID0gcmFtcEVuZCAqIHJlc29sdXRpb247XG5cbiAgICAgIGZsb2F0IHJhbXBBbHBoYTtcblxuICAgICAgaWYgKHJhbXBUeXBlID09IDEpIHtcbiAgICAgICAgdmVjMiBmdXYgPSBjZW50ZXJQaXhlbCAvIHJlc29sdXRpb24ueTtcbiAgICAgICAgdmVjMiBzdXYgPSBzdGFydFBpeGVsIC8gcmVzb2x1dGlvbi55O1xuICAgICAgICB2ZWMyIGV1diA9IGVuZFBpeGVsIC8gcmVzb2x1dGlvbi55O1xuXG4gICAgICAgIGZsb2F0IHJhZGl1cyA9IGxlbmd0aChzdXYgLSBldXYpO1xuICAgICAgICBmbG9hdCBmYWxsb2ZmID0gbGVuZ3RoKGZ1diAtIHN1dik7XG4gICAgICAgIHJhbXBBbHBoYSA9IHNtb290aHN0ZXAoMC4wLCByYWRpdXMsIGZhbGxvZmYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxvYXQgcmFkaXVzID0gbGVuZ3RoKHN0YXJ0UGl4ZWwgLSBlbmRQaXhlbCk7XG4gICAgICAgIHZlYzIgZGlyZWN0aW9uID0gbm9ybWFsaXplKHZlYzIoZW5kUGl4ZWwueCAtIHN0YXJ0UGl4ZWwueCwgLShzdGFydFBpeGVsLnkgLSBlbmRQaXhlbC55KSkpO1xuXG4gICAgICAgIGZsb2F0IGZhZGUgPSBkb3QoY2VudGVyUGl4ZWwgLSBzdGFydFBpeGVsLCBkaXJlY3Rpb24pO1xuICAgICAgICBpZiAocmFtcFR5cGUgPT0gMikgZmFkZSA9IGFicyhmYWRlKTtcblxuICAgICAgICByYW1wQWxwaGEgPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCBmYWRlIC8gcmFkaXVzKTtcbiAgICAgIH1cblxuICAgICAgcmFtcEFscGhhID0gYWJzKChyYW1wSW52ZXJ0ID8gMS4wIDogMC4wKSAtIGdldEJpYXMocmFtcEFscGhhLCByYW1wQmlhcykgKiBnZXRHYWluKHJhbXBBbHBoYSwgcmFtcEdhaW4pKTtcblxuICAgICAgaWYgKHJhbXBNYXNrKSB7XG4gICAgICAgIHZlYzQgaW5wdXRCdWZmID0gdGV4dHVyZTJEKGlucHV0QnVmZmVyLCB1dik7XG4gICAgICAgIG91dHB1dENvbG9yID0gbWl4KGlucHV0QnVmZiwgaW5wdXRDb2xvciwgcmFtcEFscGhhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dENvbG9yID0gbWl4KHN0YXJ0Q29sb3IsIGVuZENvbG9yLCByYW1wQWxwaGEpO1xuICAgICAgfVxuICAgIH1cbiAgYH07dmFyIHVlPS8qQF9fUFVSRV9fKi8oZT0+KGVbZS5MaW5lYXI9MF09XCJMaW5lYXJcIixlW2UuUmFkaWFsPTFdPVwiUmFkaWFsXCIsZVtlLk1pcnJvcmVkTGluZWFyPTJdPVwiTWlycm9yZWRMaW5lYXJcIixlKSkodWV8fHt9KTtjbGFzcyBwZSBleHRlbmRzIFd7Y29uc3RydWN0b3Ioe3JhbXBUeXBlOnQ9MCxyYW1wU3RhcnQ6bz1bLjUsLjVdLHJhbXBFbmQ6cj1bMSwxXSxzdGFydENvbG9yOmE9WzAsMCwwLDFdLGVuZENvbG9yOm49WzEsMSwxLDFdLHJhbXBCaWFzOmk9LjUscmFtcEdhaW46cz0uNSxyYW1wTWFzazpsPSExLHJhbXBJbnZlcnQ6cD0hMSwuLi5ffT17fSl7c3VwZXIoXCJSYW1wRWZmZWN0XCIsanQuZnJhZ21lbnRTaGFkZXIsey4uLl8sdW5pZm9ybXM6LypAX19QVVJFX18qL25ldyBNYXAoW1tcInJhbXBUeXBlXCIsbmV3IHkodCldLFtcInJhbXBTdGFydFwiLG5ldyB5KG8pXSxbXCJyYW1wRW5kXCIsbmV3IHkocildLFtcInN0YXJ0Q29sb3JcIixuZXcgeShhKV0sW1wiZW5kQ29sb3JcIixuZXcgeShuKV0sW1wicmFtcEJpYXNcIixuZXcgeShpKV0sW1wicmFtcEdhaW5cIixuZXcgeShzKV0sW1wicmFtcE1hc2tcIixuZXcgeShsKV0sW1wicmFtcEludmVydFwiLG5ldyB5KHApXV0pfSl9fWNvbnN0IE90PS8qQF9fUFVSRV9fKi9QKHBlKSxXdD0vKkBfX1BVUkVfXyovQihmdW5jdGlvbih7dGV4dHVyZVNyYzplLHRleHR1cmU6dCxvcGFjaXR5Om89MSwuLi5yfSxhKXtjb25zdCBuPVVlKHdlLGUpO0woKCk9PntuLmNvbG9yU3BhY2U9U2Usbi53cmFwUz1uLndyYXBUPVl9LFtuXSk7Y29uc3QgaT16KCgpPT5uZXcgbnQoey4uLnIsdGV4dHVyZTpufHx0fSksW3Isbix0XSk7cmV0dXJuIC8qQF9fUFVSRV9fKi93KFwicHJpbWl0aXZlXCIse3JlZjphLG9iamVjdDppLFwiYmxlbmRNb2RlLW9wYWNpdHktdmFsdWVcIjpvLGRpc3Bvc2U6bnVsbH0pfSksWHQ9LypAX19QVVJFX18qL1Aoc3QpLHF0PS8qQF9fUFVSRV9fKi9QKGl0KSxIdD0vKkBfX1BVUkVfXyovUChsdCksWnQ9LypAX19QVVJFX18qL0IoZnVuY3Rpb24oe2x1dDplLHRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbjp0LC4uLm99LHIpe2NvbnN0IGE9eigoKT0+bmV3IGN0KGUsbyksW2Usb10pLG49VihpPT5pLmludmFsaWRhdGUpO3JldHVybiBMKCgpPT57dCYmKGEudGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uPXQpLGUmJihhLmx1dD1lKSxuKCl9LFthLG4sZSx0XSksLypAX19QVVJFX18qL3coXCJwcmltaXRpdmVcIix7cmVmOnIsb2JqZWN0OmEsZGlzcG9zZTpudWxsfSl9KSwkdD0vKkBfX1BVUkVfXyovUChmdCx7YmxlbmRGdW5jdGlvbjowfSksS3Q9e2ZyYWdtZW50U2hhZGVyOmBcblxuICAgIC8vIG9yaWdpbmFsIHNoYWRlciBieSBFdmFuIFdhbGxhY2VcblxuICAgICNkZWZpbmUgTUFYX0lURVJBVElPTlMgMTAwXG5cbiAgICB1bmlmb3JtIGZsb2F0IGJsdXI7XG4gICAgdW5pZm9ybSBmbG9hdCB0YXBlcjtcbiAgICB1bmlmb3JtIHZlYzIgc3RhcnQ7XG4gICAgdW5pZm9ybSB2ZWMyIGVuZDtcbiAgICB1bmlmb3JtIHZlYzIgZGlyZWN0aW9uO1xuICAgIHVuaWZvcm0gaW50IHNhbXBsZXM7XG5cbiAgICBmbG9hdCByYW5kb20odmVjMyBzY2FsZSwgZmxvYXQgc2VlZCkge1xuICAgICAgICAvKiB1c2UgdGhlIGZyYWdtZW50IHBvc2l0aW9uIGZvciBhIGRpZmZlcmVudCBzZWVkIHBlci1waXhlbCAqL1xuICAgICAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChnbF9GcmFnQ29vcmQueHl6ICsgc2VlZCwgc2NhbGUpKSAqIDQzNzU4LjU0NTMgKyBzZWVkKTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsIGNvbnN0IGluIHZlYzIgdXYsIG91dCB2ZWM0IG91dHB1dENvbG9yKSB7XG4gICAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XG4gICAgICAgIGZsb2F0IHRvdGFsID0gMC4wO1xuICAgICAgICB2ZWMyIHN0YXJ0UGl4ZWwgPSB2ZWMyKHN0YXJ0LnggKiByZXNvbHV0aW9uLngsIHN0YXJ0LnkgKiByZXNvbHV0aW9uLnkpO1xuICAgICAgICB2ZWMyIGVuZFBpeGVsID0gdmVjMihlbmQueCAqIHJlc29sdXRpb24ueCwgZW5kLnkgKiByZXNvbHV0aW9uLnkpO1xuICAgICAgICBmbG9hdCBmX3NhbXBsZXMgPSBmbG9hdChzYW1wbGVzKTtcbiAgICAgICAgZmxvYXQgaGFsZl9zYW1wbGVzID0gZl9zYW1wbGVzIC8gMi4wO1xuXG4gICAgICAgIC8vIHVzZSBzY3JlZW4gZGlhZ29uYWwgdG8gbm9ybWFsaXplIGJsdXIgcmFkaWlcbiAgICAgICAgZmxvYXQgbWF4U2NyZWVuRGlzdGFuY2UgPSBkaXN0YW5jZSh2ZWMyKDAuMCksIHJlc29sdXRpb24pOyAvLyBkaWFnb25hbCBkaXN0YW5jZVxuICAgICAgICBmbG9hdCBncmFkaWVudFJhZGl1cyA9IHRhcGVyICogKG1heFNjcmVlbkRpc3RhbmNlKTtcbiAgICAgICAgZmxvYXQgYmx1clJhZGl1cyA9IGJsdXIgKiAobWF4U2NyZWVuRGlzdGFuY2UgLyAxNi4wKTtcblxuICAgICAgICAvKiByYW5kb21pemUgdGhlIGxvb2t1cCB2YWx1ZXMgdG8gaGlkZSB0aGUgZml4ZWQgbnVtYmVyIG9mIHNhbXBsZXMgKi9cbiAgICAgICAgZmxvYXQgb2Zmc2V0ID0gcmFuZG9tKHZlYzMoMTIuOTg5OCwgNzguMjMzLCAxNTEuNzE4MiksIDAuMCk7XG4gICAgICAgIHZlYzIgbm9ybWFsID0gbm9ybWFsaXplKHZlYzIoc3RhcnRQaXhlbC55IC0gZW5kUGl4ZWwueSwgZW5kUGl4ZWwueCAtIHN0YXJ0UGl4ZWwueCkpO1xuICAgICAgICBmbG9hdCByYWRpdXMgPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCBhYnMoZG90KHV2ICogcmVzb2x1dGlvbiAtIHN0YXJ0UGl4ZWwsIG5vcm1hbCkpIC8gZ3JhZGllbnRSYWRpdXMpICogYmx1clJhZGl1cztcblxuICAgICAgICAjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDw9IE1BWF9JVEVSQVRJT05TOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID49IHNhbXBsZXMpIHsgYnJlYWs7IH0gLy8gcmV0dXJuIGVhcmx5IGlmIG92ZXIgc2FtcGxlIGNvdW50XG4gICAgICAgICAgICBmbG9hdCBmX2kgPSBmbG9hdChpKTtcbiAgICAgICAgICAgIGZsb2F0IHNfaSA9IC1oYWxmX3NhbXBsZXMgKyBmX2k7XG4gICAgICAgICAgICBmbG9hdCBwZXJjZW50ID0gKHNfaSArIG9mZnNldCAtIDAuNSkgLyBoYWxmX3NhbXBsZXM7XG4gICAgICAgICAgICBmbG9hdCB3ZWlnaHQgPSAxLjAgLSBhYnMocGVyY2VudCk7XG4gICAgICAgICAgICB2ZWM0IHNhbXBsZV9pID0gdGV4dHVyZTJEKGlucHV0QnVmZmVyLCB1diArIG5vcm1hbGl6ZShkaXJlY3Rpb24pIC8gcmVzb2x1dGlvbiAqIHBlcmNlbnQgKiByYWRpdXMpO1xuICAgICAgICAgICAgLyogc3dpdGNoIHRvIHByZS1tdWx0aXBsaWVkIGFscGhhIHRvIGNvcnJlY3RseSBibHVyIHRyYW5zcGFyZW50IGltYWdlcyAqL1xuICAgICAgICAgICAgc2FtcGxlX2kucmdiICo9IHNhbXBsZV9pLmE7XG4gICAgICAgICAgICBjb2xvciArPSBzYW1wbGVfaSAqIHdlaWdodDtcbiAgICAgICAgICAgIHRvdGFsICs9IHdlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxuXG4gICAgICAgIG91dHB1dENvbG9yID0gY29sb3IgLyB0b3RhbDtcblxuICAgICAgICAvKiBzd2l0Y2ggYmFjayBmcm9tIHByZS1tdWx0aXBsaWVkIGFscGhhICovXG4gICAgICAgIG91dHB1dENvbG9yLnJnYiAvPSBvdXRwdXRDb2xvci5hICsgMC4wMDAwMTtcbiAgICB9XG4gICAgYH07Y2xhc3MgbWUgZXh0ZW5kcyBXe2NvbnN0cnVjdG9yKHtibGVuZEZ1bmN0aW9uOnQ9MjMsYmx1cjpvPS4xNSx0YXBlcjpyPS41LHN0YXJ0OmE9Wy41LDBdLGVuZDpuPVsuNSwxXSxzYW1wbGVzOmk9MTAsZGlyZWN0aW9uOnM9WzEsMV19PXt9KXtzdXBlcihcIlRpbHRTaGlmdEVmZmVjdFwiLEt0LmZyYWdtZW50U2hhZGVyLHtibGVuZEZ1bmN0aW9uOnQsYXR0cmlidXRlczoyLHVuaWZvcm1zOi8qQF9fUFVSRV9fKi9uZXcgTWFwKFtbXCJibHVyXCIsbmV3IHkobyldLFtcInRhcGVyXCIsbmV3IHkocildLFtcInN0YXJ0XCIsbmV3IHkoYSldLFtcImVuZFwiLG5ldyB5KG4pXSxbXCJzYW1wbGVzXCIsbmV3IHkoaSldLFtcImRpcmVjdGlvblwiLG5ldyB5KHMpXV0pfSl9fWNvbnN0IFl0PS8qQF9fUFVSRV9fKi9QKG1lLHtibGVuZEZ1bmN0aW9uOjIzfSksSnQ9YFxudW5pZm9ybSBzYW1wbGVyMkQgdUNoYXJhY3RlcnM7XG51bmlmb3JtIGZsb2F0IHVDaGFyYWN0ZXJzQ291bnQ7XG51bmlmb3JtIGZsb2F0IHVDZWxsU2l6ZTtcbnVuaWZvcm0gYm9vbCB1SW52ZXJ0O1xudW5pZm9ybSB2ZWMzIHVDb2xvcjtcblxuY29uc3QgdmVjMiBTSVpFID0gdmVjMigxNi4pO1xuXG52ZWMzIGdyZXlzY2FsZSh2ZWMzIGNvbG9yLCBmbG9hdCBzdHJlbmd0aCkge1xuICAgIGZsb2F0IGcgPSBkb3QoY29sb3IsIHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCkpO1xuICAgIHJldHVybiBtaXgoY29sb3IsIHZlYzMoZyksIHN0cmVuZ3RoKTtcbn1cblxudmVjMyBncmV5c2NhbGUodmVjMyBjb2xvcikge1xuICAgIHJldHVybiBncmV5c2NhbGUoY29sb3IsIDEuMCk7XG59XG5cbnZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvciwgY29uc3QgaW4gdmVjMiB1diwgb3V0IHZlYzQgb3V0cHV0Q29sb3IpIHtcbiAgICB2ZWMyIGNlbGwgPSByZXNvbHV0aW9uIC8gdUNlbGxTaXplO1xuICAgIHZlYzIgZ3JpZCA9IDEuMCAvIGNlbGw7XG4gICAgdmVjMiBwaXhlbGl6ZWRVViA9IGdyaWQgKiAoMC41ICsgZmxvb3IodXYgLyBncmlkKSk7XG4gICAgdmVjNCBwaXhlbGl6ZWQgPSB0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsIHBpeGVsaXplZFVWKTtcbiAgICBmbG9hdCBncmV5c2NhbGVkID0gZ3JleXNjYWxlKHBpeGVsaXplZC5yZ2IpLnI7XG5cbiAgICBpZiAodUludmVydCkge1xuICAgICAgICBncmV5c2NhbGVkID0gMS4wIC0gZ3JleXNjYWxlZDtcbiAgICB9XG5cbiAgICBmbG9hdCBjaGFyYWN0ZXJJbmRleCA9IGZsb29yKCh1Q2hhcmFjdGVyc0NvdW50IC0gMS4wKSAqIGdyZXlzY2FsZWQpO1xuICAgIHZlYzIgY2hhcmFjdGVyUG9zaXRpb24gPSB2ZWMyKG1vZChjaGFyYWN0ZXJJbmRleCwgU0laRS54KSwgZmxvb3IoY2hhcmFjdGVySW5kZXggLyBTSVpFLnkpKTtcbiAgICB2ZWMyIG9mZnNldCA9IHZlYzIoY2hhcmFjdGVyUG9zaXRpb24ueCwgLWNoYXJhY3RlclBvc2l0aW9uLnkpIC8gU0laRTtcbiAgICB2ZWMyIGNoYXJVViA9IG1vZCh1diAqIChjZWxsIC8gU0laRSksIDEuMCAvIFNJWkUpIC0gdmVjMigwLiwgMS4wIC8gU0laRSkgKyBvZmZzZXQ7XG4gICAgdmVjNCBhc2NpaUNoYXJhY3RlciA9IHRleHR1cmUyRCh1Q2hhcmFjdGVycywgY2hhclVWKTtcblxuICAgIGFzY2lpQ2hhcmFjdGVyLnJnYiA9IHVDb2xvciAqIGFzY2lpQ2hhcmFjdGVyLnI7XG4gICAgYXNjaWlDaGFyYWN0ZXIuYSA9IHBpeGVsaXplZC5hO1xuICAgIG91dHB1dENvbG9yID0gYXNjaWlDaGFyYWN0ZXI7XG59XG5gO2NsYXNzIFF0IGV4dGVuZHMgV3tjb25zdHJ1Y3Rvcih7Zm9udDp0PVwiYXJpYWxcIixjaGFyYWN0ZXJzOm89XCIgLjosJy1ePSorPyF8MCNYJVdNQFwiLGZvbnRTaXplOnI9NTQsY2VsbFNpemU6YT0xNixjb2xvcjpuPVwiI2ZmZmZmZlwiLGludmVydDppPSExfT17fSl7Y29uc3Qgcz0vKkBfX1BVUkVfXyovbmV3IE1hcChbW1widUNoYXJhY3RlcnNcIixuZXcgeShuZXcgeWUpXSxbXCJ1Q2VsbFNpemVcIixuZXcgeShhKV0sW1widUNoYXJhY3RlcnNDb3VudFwiLG5ldyB5KG8ubGVuZ3RoKV0sW1widUNvbG9yXCIsbmV3IHkobmV3IFBlKG4pKV0sW1widUludmVydFwiLG5ldyB5KGkpXV0pO3N1cGVyKFwiQVNDSUlFZmZlY3RcIixKdCx7dW5pZm9ybXM6c30pO2NvbnN0IGw9dGhpcy51bmlmb3Jtcy5nZXQoXCJ1Q2hhcmFjdGVyc1wiKTtsJiYobC52YWx1ZT10aGlzLmNyZWF0ZUNoYXJhY3RlcnNUZXh0dXJlKG8sdCxyKSl9Y3JlYXRlQ2hhcmFjdGVyc1RleHR1cmUodCxvLHIpe2NvbnN0IGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxuPTEwMjQsaT0xNixzPW4vaTthLndpZHRoPWEuaGVpZ2h0PW47Y29uc3QgbD1uZXcgYmUoYSx2b2lkIDAsWSxZLHJlLHJlKSxwPWEuZ2V0Q29udGV4dChcIjJkXCIpO2lmKCFwKXRocm93IG5ldyBFcnJvcihcIkNvbnRleHQgbm90IGF2YWlsYWJsZVwiKTtwLmNsZWFyUmVjdCgwLDAsbixuKSxwLmZvbnQ9YCR7cn1weCAke299YCxwLnRleHRBbGlnbj1cImNlbnRlclwiLHAudGV4dEJhc2VsaW5lPVwibWlkZGxlXCIscC5maWxsU3R5bGU9XCIjZmZmXCI7Zm9yKGxldCBfPTA7Xzx0Lmxlbmd0aDtfKyspe2NvbnN0IFM9dFtfXSxnPV8laSxkPU1hdGguZmxvb3IoXy9pKTtwLmZpbGxUZXh0KFMsZypzK3MvMixkKnMrcy8yKX1yZXR1cm4gbC5uZWVkc1VwZGF0ZT0hMCxsfX1jb25zdCBlbz0vKkBfX1BVUkVfXyovQigoe2ZvbnQ6ZT1cImFyaWFsXCIsY2hhcmFjdGVyczp0PVwiIC46LCctXj0qKz8hfDAjWCVXTUBcIixmb250U2l6ZTpvPTU0LGNlbGxTaXplOnI9MTYsY29sb3I6YT1cIiNmZmZmZmZcIixpbnZlcnQ6bj0hMX0saSk9Pntjb25zdCBzPXooKCk9Pm5ldyBRdCh7Y2hhcmFjdGVyczp0LGZvbnQ6ZSxmb250U2l6ZTpvLGNlbGxTaXplOnIsY29sb3I6YSxpbnZlcnQ6bn0pLFt0LG8scixhLG4sZV0pO3JldHVybiAvKkBfX1BVUkVfXyovdyhcInByaW1pdGl2ZVwiLHtyZWY6aSxvYmplY3Q6c30pfSksdG89e2ZyYWdtZW50U2hhZGVyOmBcbiAgICB1bmlmb3JtIGZsb2F0IGZhY3RvcjtcblxuICAgIHZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvciwgY29uc3QgaW4gdmVjMiB1diwgb3V0IHZlYzQgb3V0cHV0Q29sb3IpIHtcbiAgICAgIHZlYzIgdlV2ID0gdXY7XG4gICAgICBmbG9hdCBmcmVxdWVuY3kgPSA2LjAgKiBmYWN0b3I7XG4gICAgICBmbG9hdCBhbXBsaXR1ZGUgPSAwLjAxNSAqIGZhY3RvcjtcbiAgICAgIGZsb2F0IHggPSB2VXYueSAqIGZyZXF1ZW5jeSArIHRpbWUgKiAwLjc7IFxuICAgICAgZmxvYXQgeSA9IHZVdi54ICogZnJlcXVlbmN5ICsgdGltZSAqIDAuMztcbiAgICAgIHZVdi54ICs9IGNvcyh4ICsgeSkgKiBhbXBsaXR1ZGUgKiBjb3MoeSk7XG4gICAgICB2VXYueSArPSBzaW4oeCAtIHkpICogYW1wbGl0dWRlICogY29zKHkpO1xuICAgICAgdmVjNCByZ2JhID0gdGV4dHVyZShpbnB1dEJ1ZmZlciwgdlV2KTtcbiAgICAgIG91dHB1dENvbG9yID0gcmdiYTtcbiAgICB9XG4gIGB9O2NsYXNzIGRlIGV4dGVuZHMgV3tjb25zdHJ1Y3Rvcih7YmxlbmRGdW5jdGlvbjp0PTIzLGZhY3RvcjpvPTB9PXt9KXtzdXBlcihcIldhdGVyRWZmZWN0XCIsdG8uZnJhZ21lbnRTaGFkZXIse2JsZW5kRnVuY3Rpb246dCxhdHRyaWJ1dGVzOjIsdW5pZm9ybXM6LypAX19QVVJFX18qL25ldyBNYXAoW1tcImZhY3RvclwiLG5ldyB5KG8pXV0pfSl9fWNvbnN0IG9vPS8qQF9fUFVSRV9fKi9QKGRlLHtibGVuZEZ1bmN0aW9uOjIzfSksYW89LypAX19QVVJFX18qL0IoKHtoYWxmUmVzOmUsc2NyZWVuU3BhY2VSYWRpdXM6dCxxdWFsaXR5Om8sZGVwdGhBd2FyZVVwc2FtcGxpbmc6cj0hMCxhb1JhZGl1czphPTUsYW9TYW1wbGVzOm49MTYsZGVub2lzZVNhbXBsZXM6aT00LGRlbm9pc2VSYWRpdXM6cz0xMixkaXN0YW5jZUZhbGxvZmY6bD0xLGludGVuc2l0eTpwPTEsY29sb3I6XyxyZW5kZXJNb2RlOlM9MH0sZyk9Pntjb25zdHtjYW1lcmE6ZCxzY2VuZTptfT1WKCksdj16KCgpPT5uZXcgdXQobSxkKSxbZCxtXSk7cmV0dXJuIEwoKCk9PntDZSh2LmNvbmZpZ3VyYXRpb24se2NvbG9yOl8sYW9SYWRpdXM6YSxkaXN0YW5jZUZhbGxvZmY6bCxpbnRlbnNpdHk6cCxhb1NhbXBsZXM6bixkZW5vaXNlU2FtcGxlczppLGRlbm9pc2VSYWRpdXM6cyxzY3JlZW5TcGFjZVJhZGl1czp0LHJlbmRlck1vZGU6UyxoYWxmUmVzOmUsZGVwdGhBd2FyZVVwc2FtcGxpbmc6cn0pfSxbdCxfLGEsbCxwLG4saSxzLFMsZSxyLHZdKSxMKCgpPT57byYmdi5zZXRRdWFsaXR5TW9kZShvLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK28uc2xpY2UoMSkpfSxbdixvXSksLypAX19QVVJFX18qL3coXCJwcmltaXRpdmVcIix7cmVmOmcsb2JqZWN0OnZ9KX0pO2V4cG9ydHtlbyBhcyBBU0NJSSxodCBhcyBBdXRvZm9jdXMsd3QgYXMgQmxvb20sU3QgYXMgQnJpZ2h0bmVzc0NvbnRyYXN0LHl0IGFzIENocm9tYXRpY0FiZXJyYXRpb24sUHQgYXMgQ29sb3JBdmVyYWdlLGJ0IGFzIENvbG9yRGVwdGgsRXQgYXMgRGVwdGgsY2UgYXMgRGVwdGhPZkZpZWxkLFJ0IGFzIERvdFNjcmVlbixkdCBhcyBFZmZlY3RDb21wb3NlcixEIGFzIEVmZmVjdENvbXBvc2VyQ29udGV4dCxOdCBhcyBGWEFBLFV0IGFzIEdsaXRjaCxDdCBhcyBHb2RSYXlzLHp0IGFzIEdyaWQsVHQgYXMgSHVlU2F0dXJhdGlvbixadCBhcyBMVVQsZ3QgYXMgTGVuc0ZsYXJlLGZlIGFzIExlbnNGbGFyZUVmZmVjdCxhbyBhcyBOOEFPLEF0IGFzIE5vaXNlLEJ0IGFzIE91dGxpbmUsVnQgYXMgUGl4ZWxhdGlvbixPdCBhcyBSYW1wLHBlIGFzIFJhbXBFZmZlY3QsdWUgYXMgUmFtcFR5cGUsTHQgYXMgU01BQSxJdCBhcyBTU0FPLEZ0IGFzIFNjYW5saW5lLG10IGFzIFNlbGVjdCxwdCBhcyBTZWxlY3Rpb24sa3QgYXMgU2VsZWN0aXZlQmxvb20sR3QgYXMgU2VwaWEsSHQgYXMgU2hvY2tXYXZlLFd0IGFzIFRleHR1cmUsJHQgYXMgVGlsdFNoaWZ0LFl0IGFzIFRpbHRTaGlmdDIsbWUgYXMgVGlsdFNoaWZ0RWZmZWN0LFh0IGFzIFRvbmVNYXBwaW5nLHF0IGFzIFZpZ25ldHRlLG9vIGFzIFdhdGVyRWZmZWN0LGRlIGFzIFdhdGVyRWZmZWN0SW1wbCxrIGFzIHJlc29sdmVSZWYsSCBhcyBzZWxlY3Rpb25Db250ZXh0LFogYXMgdXNlVmVjdG9yMixQIGFzIHdyYXBFZmZlY3R9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/buffer-d2a4726c.esm.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/buffer-d2a4726c.esm.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ addAxis),\n/* harmony export */   b: () => (/* binding */ buffer),\n/* harmony export */   c: () => (/* binding */ reduce),\n/* harmony export */   d: () => (/* binding */ center),\n/* harmony export */   e: () => (/* binding */ expand),\n/* harmony export */   f: () => (/* binding */ sort),\n/* harmony export */   l: () => (/* binding */ lerp),\n/* harmony export */   m: () => (/* binding */ map),\n/* harmony export */   r: () => (/* binding */ rotate),\n/* harmony export */   s: () => (/* binding */ swizzle),\n/* harmony export */   t: () => (/* binding */ translate)\n/* harmony export */ });\n/* harmony import */ var _objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objectSpread2-284232a6.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/objectSpread2-284232a6.esm.js\");\n/* harmony import */ var _triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./triangle-b62b9067.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/triangle-b62b9067.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc-7d870b3c.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/misc-7d870b3c.esm.js\");\n/* harmony import */ var _vector2_d2bf51f1_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vector2-d2bf51f1.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/vector2-d2bf51f1.esm.js\");\n/* harmony import */ var _vector3_0a088b7f_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vector3-0a088b7f.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/vector3-0a088b7f.esm.js\");\n\n\n\n\n\n\n\nfunction swizzle(buffer) {\n  var stride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  var swizzle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"xyz\";\n  var o = {\n    x: 0,\n    y: 0,\n    z: 0\n  };\n\n  for (var _i = 0; _i < buffer.length; _i += stride) {\n    o.x = buffer[_i];\n    o.y = buffer[_i + 1];\n    o.z = buffer[_i + 2];\n\n    var _swizzle$split = swizzle.split(\"\"),\n        _swizzle$split2 = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(_swizzle$split, 3),\n        x = _swizzle$split2[0],\n        y = _swizzle$split2[1],\n        z = _swizzle$split2[2]; // TODO Fix this ugly type\n\n\n    buffer[_i] = o[x];\n    buffer[_i + 1] = o[y];\n\n    if (stride === 3) {\n      buffer[_i + 2] = o[z];\n    }\n  }\n\n  return buffer;\n}\n/**\n * @param buffer A stride 2 points buffer\n * @param valueGenerator A function that returns the value of the z axis at index i\n * @returns\n */\n\nfunction addAxis(buffer, size) {\n  var valueGenerator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n    return Math.random();\n  };\n  var newSize = size + 1;\n  var newBuffer = new Float32Array(buffer.length / size * newSize);\n\n  for (var _i2 = 0; _i2 < buffer.length; _i2 += size) {\n    var _j = _i2 / size * newSize;\n\n    newBuffer[_j] = buffer[_i2];\n    newBuffer[_j + 1] = buffer[_i2 + 1];\n\n    if (size === 2) {\n      newBuffer[_j + 2] = valueGenerator(_j);\n    }\n\n    if (size === 3) {\n      newBuffer[_j + 2] = buffer[_i2 + 2];\n      newBuffer[_j + 3] = valueGenerator(_j);\n    }\n  }\n\n  return newBuffer;\n}\n/**\n * Lerps bufferA and bufferB into final\n *\n * @param bufferA\n * @param bufferB\n * @param final\n * @param t\n */\n\nfunction lerp(bufferA, bufferB, _final, t) {\n  for (var _i3 = 0; _i3 < bufferA.length; _i3++) {\n    _final[_i3] = (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(bufferA[_i3], bufferB[_i3], t);\n  }\n} // TODO add stride\n// TODO Fix types & vectors\n\n/**\n *\n * Translate all points in the passed buffer by the passed translactionVector.\n *\n * @param buffer\n * @param translationVector\n * @returns\n */\n\nfunction translate(buffer, translationVector) {\n  var stride = translationVector.length;\n\n  for (var _i4 = 0; _i4 < buffer.length; _i4 += stride) {\n    buffer[_i4] += translationVector[0];\n    buffer[_i4 + 1] += translationVector[1];\n    buffer[_i4 + 2] += translationVector[2];\n  }\n\n  return buffer;\n} // TODO add stride\n// TODO remove quaternion & vector3 dependencies\n\nfunction rotate(buffer, rotation) {\n  var defaultRotation = {\n    center: [0, 0, 0],\n    q: new three__WEBPACK_IMPORTED_MODULE_5__.Quaternion().identity()\n  };\n  var v = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n\n  var _defaultRotation$rota = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultRotation), rotation),\n      q = _defaultRotation$rota.q,\n      center = _defaultRotation$rota.center;\n\n  for (var _i5 = 0; _i5 < buffer.length; _i5 += 3) {\n    v.set(buffer[_i5] - center[0], buffer[_i5 + 1] - center[1], buffer[_i5 + 2] - center[2]);\n    v.applyQuaternion(q);\n    buffer[_i5] = v.x + center[0];\n    buffer[_i5 + 1] = v.y + center[1];\n    buffer[_i5 + 2] = v.z + center[1];\n  }\n\n  return buffer;\n}\nfunction map(buffer, stride, callback) {\n  for (var _i6 = 0, _j2 = 0; _i6 < buffer.length; _i6 += stride, _j2++) {\n    if (stride === 3) {\n      var res = callback([buffer[_i6], buffer[_i6 + 1], buffer[_i6 + 2]], _j2);\n      buffer.set(res, _i6);\n    } else {\n      buffer.set(callback([buffer[_i6], buffer[_i6 + 1]], _j2), _i6);\n    }\n  }\n\n  return buffer;\n}\n/**\n * Reduces passed buffer\n */\n\nfunction reduce(b, stride, callback, acc) {\n  for (var _i7 = 0, _j3 = 0; _i7 < b.length; _i7 += stride, _j3++) {\n    if (stride === 2) {\n      acc = callback(acc, [b[_i7], b[_i7 + 1]], _j3);\n    } else {\n      acc = callback(acc, [b[_i7], b[_i7 + 1], b[_i7 + 2]], _j3);\n    }\n  }\n\n  return acc;\n}\nfunction expand(b, stride, opts) {\n  var defaultExpandOptions = {\n    center: [0, 0, 0]\n  };\n\n  var _defaultExpandOptions = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultExpandOptions), opts),\n      center = _defaultExpandOptions.center,\n      distance = _defaultExpandOptions.distance;\n\n  for (var _i8 = 0; _i8 < b.length; _i8 += stride) {\n    /**\n     * 1. translate to origin (subtract the scaling center)\n     * 2. scale by the correct amount (multiply by a constant)\n     * 2. translate from origin (add the scaling center)\n     */\n    b[_i8] = (b[_i8] - center[0]) * (1 + distance) + center[0];\n    b[_i8 + 1] = (b[_i8 + 1] - center[1]) * (1 + distance) + center[1];\n\n    if (stride === 3) {\n      b[_i8 + 2] = (b[_i8 + 2] - center[1]) * (1 + distance) + center[2];\n    }\n  }\n\n  return b;\n}\nfunction center(myBuffer, stride) {\n  return reduce(myBuffer, stride, function (acc, point) {\n    if (stride === 3) {\n      // some type hacking is necessary to avoid type errors going from [n, n] => [n, n, n]\n      // but it's not an actual problem, as this path would always get a v3\n      acc = (0,_vector3_0a088b7f_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(acc, point);\n    } else {\n      acc = (0,_vector2_d2bf51f1_esm_js__WEBPACK_IMPORTED_MODULE_3__.a)(acc, point);\n    }\n\n    return acc;\n  }, (0,_vector2_d2bf51f1_esm_js__WEBPACK_IMPORTED_MODULE_3__.z)());\n}\nfunction sort(myBuffer, stride, callback) {\n  // 1. make an array of the correct size\n  var indices = Int16Array.from({\n    length: myBuffer.length / stride\n  }, function (_, i) {\n    return i;\n  }); // 2. sort the indices array\n\n  indices.sort(function (a, b) {\n    var pa = myBuffer.slice(a * stride, a * stride + stride);\n    var pb = myBuffer.slice(b * stride, b * stride + stride);\n    return callback(pa, pb);\n  }); // 3. make a copy of the original array to fetch indices from\n\n  var prevBuffer = myBuffer.slice(0); // 4. mutate the passed array\n\n  for (var _i9 = 0; _i9 < indices.length; _i9++) {\n    var _j4 = indices[_i9];\n    myBuffer.set(prevBuffer.slice(_j4 * stride, _j4 * stride + stride), _i9 * 3);\n  }\n\n  return myBuffer;\n}\n\nvar buffer = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  swizzle: swizzle,\n  addAxis: addAxis,\n  lerp: lerp,\n  translate: translate,\n  rotate: rotate,\n  map: map,\n  reduce: reduce,\n  expand: expand,\n  center: center,\n  sort: sort\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvYnVmZmVyLWQyYTQ3MjZjLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRTtBQUNMO0FBQ3JCO0FBQ1M7QUFDYTtBQUNiOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDREQUFjO0FBQ3hDO0FBQ0E7QUFDQSxnQ0FBZ0M7OztBQUdoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDLGtCQUFrQix3REFBTTtBQUN4QjtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZDQUFVO0FBQ3JCO0FBQ0EsY0FBYywwQ0FBTzs7QUFFckIsOEJBQThCLGlFQUFjLENBQUMsaUVBQWMsR0FBRztBQUM5RDtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLGlFQUFjLENBQUMsaUVBQWMsR0FBRztBQUM5RDtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJEQUFHO0FBQ2YsTUFBTTtBQUNOLFlBQVksMkRBQUs7QUFDakI7O0FBRUE7QUFDQSxHQUFHLEVBQUUsMkRBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOLHNDQUFzQzs7QUFFdEMsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVzSiIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9wb3N0cHJvY2Vzc2luZy9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9idWZmZXItZDJhNDcyNmMuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF8gYXMgX29iamVjdFNwcmVhZDIgfSBmcm9tICcuL29iamVjdFNwcmVhZDItMjg0MjMyYTYuZXNtLmpzJztcbmltcG9ydCB7IF8gYXMgX3NsaWNlZFRvQXJyYXkgfSBmcm9tICcuL3RyaWFuZ2xlLWI2MmI5MDY3LmVzbS5qcyc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uLCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgbCBhcyBsZXJwJDEgfSBmcm9tICcuL21pc2MtN2Q4NzBiM2MuZXNtLmpzJztcbmltcG9ydCB7IHogYXMgemVybywgYSBhcyBhZGQkMSB9IGZyb20gJy4vdmVjdG9yMi1kMmJmNTFmMS5lc20uanMnO1xuaW1wb3J0IHsgYSBhcyBhZGQgfSBmcm9tICcuL3ZlY3RvcjMtMGEwODhiN2YuZXNtLmpzJztcblxuZnVuY3Rpb24gc3dpenpsZShidWZmZXIpIHtcbiAgdmFyIHN0cmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMztcbiAgdmFyIHN3aXp6bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwieHl6XCI7XG4gIHZhciBvID0ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB6OiAwXG4gIH07XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJ1ZmZlci5sZW5ndGg7IF9pICs9IHN0cmlkZSkge1xuICAgIG8ueCA9IGJ1ZmZlcltfaV07XG4gICAgby55ID0gYnVmZmVyW19pICsgMV07XG4gICAgby56ID0gYnVmZmVyW19pICsgMl07XG5cbiAgICB2YXIgX3N3aXp6bGUkc3BsaXQgPSBzd2l6emxlLnNwbGl0KFwiXCIpLFxuICAgICAgICBfc3dpenpsZSRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfc3dpenpsZSRzcGxpdCwgMyksXG4gICAgICAgIHggPSBfc3dpenpsZSRzcGxpdDJbMF0sXG4gICAgICAgIHkgPSBfc3dpenpsZSRzcGxpdDJbMV0sXG4gICAgICAgIHogPSBfc3dpenpsZSRzcGxpdDJbMl07IC8vIFRPRE8gRml4IHRoaXMgdWdseSB0eXBlXG5cblxuICAgIGJ1ZmZlcltfaV0gPSBvW3hdO1xuICAgIGJ1ZmZlcltfaSArIDFdID0gb1t5XTtcblxuICAgIGlmIChzdHJpZGUgPT09IDMpIHtcbiAgICAgIGJ1ZmZlcltfaSArIDJdID0gb1t6XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufVxuLyoqXG4gKiBAcGFyYW0gYnVmZmVyIEEgc3RyaWRlIDIgcG9pbnRzIGJ1ZmZlclxuICogQHBhcmFtIHZhbHVlR2VuZXJhdG9yIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgeiBheGlzIGF0IGluZGV4IGlcbiAqIEByZXR1cm5zXG4gKi9cblxuZnVuY3Rpb24gYWRkQXhpcyhidWZmZXIsIHNpemUpIHtcbiAgdmFyIHZhbHVlR2VuZXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG4gIH07XG4gIHZhciBuZXdTaXplID0gc2l6ZSArIDE7XG4gIHZhciBuZXdCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlci5sZW5ndGggLyBzaXplICogbmV3U2l6ZSk7XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYnVmZmVyLmxlbmd0aDsgX2kyICs9IHNpemUpIHtcbiAgICB2YXIgX2ogPSBfaTIgLyBzaXplICogbmV3U2l6ZTtcblxuICAgIG5ld0J1ZmZlcltfal0gPSBidWZmZXJbX2kyXTtcbiAgICBuZXdCdWZmZXJbX2ogKyAxXSA9IGJ1ZmZlcltfaTIgKyAxXTtcblxuICAgIGlmIChzaXplID09PSAyKSB7XG4gICAgICBuZXdCdWZmZXJbX2ogKyAyXSA9IHZhbHVlR2VuZXJhdG9yKF9qKTtcbiAgICB9XG5cbiAgICBpZiAoc2l6ZSA9PT0gMykge1xuICAgICAgbmV3QnVmZmVyW19qICsgMl0gPSBidWZmZXJbX2kyICsgMl07XG4gICAgICBuZXdCdWZmZXJbX2ogKyAzXSA9IHZhbHVlR2VuZXJhdG9yKF9qKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmZmVyO1xufVxuLyoqXG4gKiBMZXJwcyBidWZmZXJBIGFuZCBidWZmZXJCIGludG8gZmluYWxcbiAqXG4gKiBAcGFyYW0gYnVmZmVyQVxuICogQHBhcmFtIGJ1ZmZlckJcbiAqIEBwYXJhbSBmaW5hbFxuICogQHBhcmFtIHRcbiAqL1xuXG5mdW5jdGlvbiBsZXJwKGJ1ZmZlckEsIGJ1ZmZlckIsIF9maW5hbCwgdCkge1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBidWZmZXJBLmxlbmd0aDsgX2kzKyspIHtcbiAgICBfZmluYWxbX2kzXSA9IGxlcnAkMShidWZmZXJBW19pM10sIGJ1ZmZlckJbX2kzXSwgdCk7XG4gIH1cbn0gLy8gVE9ETyBhZGQgc3RyaWRlXG4vLyBUT0RPIEZpeCB0eXBlcyAmIHZlY3RvcnNcblxuLyoqXG4gKlxuICogVHJhbnNsYXRlIGFsbCBwb2ludHMgaW4gdGhlIHBhc3NlZCBidWZmZXIgYnkgdGhlIHBhc3NlZCB0cmFuc2xhY3Rpb25WZWN0b3IuXG4gKlxuICogQHBhcmFtIGJ1ZmZlclxuICogQHBhcmFtIHRyYW5zbGF0aW9uVmVjdG9yXG4gKiBAcmV0dXJuc1xuICovXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShidWZmZXIsIHRyYW5zbGF0aW9uVmVjdG9yKSB7XG4gIHZhciBzdHJpZGUgPSB0cmFuc2xhdGlvblZlY3Rvci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgYnVmZmVyLmxlbmd0aDsgX2k0ICs9IHN0cmlkZSkge1xuICAgIGJ1ZmZlcltfaTRdICs9IHRyYW5zbGF0aW9uVmVjdG9yWzBdO1xuICAgIGJ1ZmZlcltfaTQgKyAxXSArPSB0cmFuc2xhdGlvblZlY3RvclsxXTtcbiAgICBidWZmZXJbX2k0ICsgMl0gKz0gdHJhbnNsYXRpb25WZWN0b3JbMl07XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufSAvLyBUT0RPIGFkZCBzdHJpZGVcbi8vIFRPRE8gcmVtb3ZlIHF1YXRlcm5pb24gJiB2ZWN0b3IzIGRlcGVuZGVuY2llc1xuXG5mdW5jdGlvbiByb3RhdGUoYnVmZmVyLCByb3RhdGlvbikge1xuICB2YXIgZGVmYXVsdFJvdGF0aW9uID0ge1xuICAgIGNlbnRlcjogWzAsIDAsIDBdLFxuICAgIHE6IG5ldyBRdWF0ZXJuaW9uKCkuaWRlbnRpdHkoKVxuICB9O1xuICB2YXIgdiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgdmFyIF9kZWZhdWx0Um90YXRpb24kcm90YSA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0Um90YXRpb24pLCByb3RhdGlvbiksXG4gICAgICBxID0gX2RlZmF1bHRSb3RhdGlvbiRyb3RhLnEsXG4gICAgICBjZW50ZXIgPSBfZGVmYXVsdFJvdGF0aW9uJHJvdGEuY2VudGVyO1xuXG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGJ1ZmZlci5sZW5ndGg7IF9pNSArPSAzKSB7XG4gICAgdi5zZXQoYnVmZmVyW19pNV0gLSBjZW50ZXJbMF0sIGJ1ZmZlcltfaTUgKyAxXSAtIGNlbnRlclsxXSwgYnVmZmVyW19pNSArIDJdIC0gY2VudGVyWzJdKTtcbiAgICB2LmFwcGx5UXVhdGVybmlvbihxKTtcbiAgICBidWZmZXJbX2k1XSA9IHYueCArIGNlbnRlclswXTtcbiAgICBidWZmZXJbX2k1ICsgMV0gPSB2LnkgKyBjZW50ZXJbMV07XG4gICAgYnVmZmVyW19pNSArIDJdID0gdi56ICsgY2VudGVyWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIG1hcChidWZmZXIsIHN0cmlkZSwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgX2k2ID0gMCwgX2oyID0gMDsgX2k2IDwgYnVmZmVyLmxlbmd0aDsgX2k2ICs9IHN0cmlkZSwgX2oyKyspIHtcbiAgICBpZiAoc3RyaWRlID09PSAzKSB7XG4gICAgICB2YXIgcmVzID0gY2FsbGJhY2soW2J1ZmZlcltfaTZdLCBidWZmZXJbX2k2ICsgMV0sIGJ1ZmZlcltfaTYgKyAyXV0sIF9qMik7XG4gICAgICBidWZmZXIuc2V0KHJlcywgX2k2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyLnNldChjYWxsYmFjayhbYnVmZmVyW19pNl0sIGJ1ZmZlcltfaTYgKyAxXV0sIF9qMiksIF9pNik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbi8qKlxuICogUmVkdWNlcyBwYXNzZWQgYnVmZmVyXG4gKi9cblxuZnVuY3Rpb24gcmVkdWNlKGIsIHN0cmlkZSwgY2FsbGJhY2ssIGFjYykge1xuICBmb3IgKHZhciBfaTcgPSAwLCBfajMgPSAwOyBfaTcgPCBiLmxlbmd0aDsgX2k3ICs9IHN0cmlkZSwgX2ozKyspIHtcbiAgICBpZiAoc3RyaWRlID09PSAyKSB7XG4gICAgICBhY2MgPSBjYWxsYmFjayhhY2MsIFtiW19pN10sIGJbX2k3ICsgMV1dLCBfajMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2MgPSBjYWxsYmFjayhhY2MsIFtiW19pN10sIGJbX2k3ICsgMV0sIGJbX2k3ICsgMl1dLCBfajMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhY2M7XG59XG5mdW5jdGlvbiBleHBhbmQoYiwgc3RyaWRlLCBvcHRzKSB7XG4gIHZhciBkZWZhdWx0RXhwYW5kT3B0aW9ucyA9IHtcbiAgICBjZW50ZXI6IFswLCAwLCAwXVxuICB9O1xuXG4gIHZhciBfZGVmYXVsdEV4cGFuZE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdEV4cGFuZE9wdGlvbnMpLCBvcHRzKSxcbiAgICAgIGNlbnRlciA9IF9kZWZhdWx0RXhwYW5kT3B0aW9ucy5jZW50ZXIsXG4gICAgICBkaXN0YW5jZSA9IF9kZWZhdWx0RXhwYW5kT3B0aW9ucy5kaXN0YW5jZTtcblxuICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBiLmxlbmd0aDsgX2k4ICs9IHN0cmlkZSkge1xuICAgIC8qKlxuICAgICAqIDEuIHRyYW5zbGF0ZSB0byBvcmlnaW4gKHN1YnRyYWN0IHRoZSBzY2FsaW5nIGNlbnRlcilcbiAgICAgKiAyLiBzY2FsZSBieSB0aGUgY29ycmVjdCBhbW91bnQgKG11bHRpcGx5IGJ5IGEgY29uc3RhbnQpXG4gICAgICogMi4gdHJhbnNsYXRlIGZyb20gb3JpZ2luIChhZGQgdGhlIHNjYWxpbmcgY2VudGVyKVxuICAgICAqL1xuICAgIGJbX2k4XSA9IChiW19pOF0gLSBjZW50ZXJbMF0pICogKDEgKyBkaXN0YW5jZSkgKyBjZW50ZXJbMF07XG4gICAgYltfaTggKyAxXSA9IChiW19pOCArIDFdIC0gY2VudGVyWzFdKSAqICgxICsgZGlzdGFuY2UpICsgY2VudGVyWzFdO1xuXG4gICAgaWYgKHN0cmlkZSA9PT0gMykge1xuICAgICAgYltfaTggKyAyXSA9IChiW19pOCArIDJdIC0gY2VudGVyWzFdKSAqICgxICsgZGlzdGFuY2UpICsgY2VudGVyWzJdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBiO1xufVxuZnVuY3Rpb24gY2VudGVyKG15QnVmZmVyLCBzdHJpZGUpIHtcbiAgcmV0dXJuIHJlZHVjZShteUJ1ZmZlciwgc3RyaWRlLCBmdW5jdGlvbiAoYWNjLCBwb2ludCkge1xuICAgIGlmIChzdHJpZGUgPT09IDMpIHtcbiAgICAgIC8vIHNvbWUgdHlwZSBoYWNraW5nIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCB0eXBlIGVycm9ycyBnb2luZyBmcm9tIFtuLCBuXSA9PiBbbiwgbiwgbl1cbiAgICAgIC8vIGJ1dCBpdCdzIG5vdCBhbiBhY3R1YWwgcHJvYmxlbSwgYXMgdGhpcyBwYXRoIHdvdWxkIGFsd2F5cyBnZXQgYSB2M1xuICAgICAgYWNjID0gYWRkKGFjYywgcG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2MgPSBhZGQkMShhY2MsIHBvaW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB6ZXJvKCkpO1xufVxuZnVuY3Rpb24gc29ydChteUJ1ZmZlciwgc3RyaWRlLCBjYWxsYmFjaykge1xuICAvLyAxLiBtYWtlIGFuIGFycmF5IG9mIHRoZSBjb3JyZWN0IHNpemVcbiAgdmFyIGluZGljZXMgPSBJbnQxNkFycmF5LmZyb20oe1xuICAgIGxlbmd0aDogbXlCdWZmZXIubGVuZ3RoIC8gc3RyaWRlXG4gIH0sIGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgcmV0dXJuIGk7XG4gIH0pOyAvLyAyLiBzb3J0IHRoZSBpbmRpY2VzIGFycmF5XG5cbiAgaW5kaWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHBhID0gbXlCdWZmZXIuc2xpY2UoYSAqIHN0cmlkZSwgYSAqIHN0cmlkZSArIHN0cmlkZSk7XG4gICAgdmFyIHBiID0gbXlCdWZmZXIuc2xpY2UoYiAqIHN0cmlkZSwgYiAqIHN0cmlkZSArIHN0cmlkZSk7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHBhLCBwYik7XG4gIH0pOyAvLyAzLiBtYWtlIGEgY29weSBvZiB0aGUgb3JpZ2luYWwgYXJyYXkgdG8gZmV0Y2ggaW5kaWNlcyBmcm9tXG5cbiAgdmFyIHByZXZCdWZmZXIgPSBteUJ1ZmZlci5zbGljZSgwKTsgLy8gNC4gbXV0YXRlIHRoZSBwYXNzZWQgYXJyYXlcblxuICBmb3IgKHZhciBfaTkgPSAwOyBfaTkgPCBpbmRpY2VzLmxlbmd0aDsgX2k5KyspIHtcbiAgICB2YXIgX2o0ID0gaW5kaWNlc1tfaTldO1xuICAgIG15QnVmZmVyLnNldChwcmV2QnVmZmVyLnNsaWNlKF9qNCAqIHN0cmlkZSwgX2o0ICogc3RyaWRlICsgc3RyaWRlKSwgX2k5ICogMyk7XG4gIH1cblxuICByZXR1cm4gbXlCdWZmZXI7XG59XG5cbnZhciBidWZmZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc3dpenpsZTogc3dpenpsZSxcbiAgYWRkQXhpczogYWRkQXhpcyxcbiAgbGVycDogbGVycCxcbiAgdHJhbnNsYXRlOiB0cmFuc2xhdGUsXG4gIHJvdGF0ZTogcm90YXRlLFxuICBtYXA6IG1hcCxcbiAgcmVkdWNlOiByZWR1Y2UsXG4gIGV4cGFuZDogZXhwYW5kLFxuICBjZW50ZXI6IGNlbnRlcixcbiAgc29ydDogc29ydFxufSk7XG5cbmV4cG9ydCB7IGFkZEF4aXMgYXMgYSwgYnVmZmVyIGFzIGIsIHJlZHVjZSBhcyBjLCBjZW50ZXIgYXMgZCwgZXhwYW5kIGFzIGUsIHNvcnQgYXMgZiwgbGVycCBhcyBsLCBtYXAgYXMgbSwgcm90YXRlIGFzIHIsIHN3aXp6bGUgYXMgcywgdHJhbnNsYXRlIGFzIHQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/buffer-d2a4726c.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/classCallCheck-9098b006.esm.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/classCallCheck-9098b006.esm.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _classCallCheck)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvY2xhc3NDYWxsQ2hlY2stOTA5OGIwMDYuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnQyIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9wb3N0cHJvY2Vzc2luZy9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9jbGFzc0NhbGxDaGVjay05MDk4YjAwNi5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZXhwb3J0IHsgX2NsYXNzQ2FsbENoZWNrIGFzIF8gfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/classCallCheck-9098b006.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/easing-3be59c6d.esm.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/easing-3be59c6d.esm.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ exp),\n/* harmony export */   b: () => (/* binding */ dampAngle),\n/* harmony export */   c: () => (/* binding */ damp2),\n/* harmony export */   d: () => (/* binding */ damp),\n/* harmony export */   e: () => (/* binding */ easing),\n/* harmony export */   f: () => (/* binding */ damp3),\n/* harmony export */   g: () => (/* binding */ damp4),\n/* harmony export */   h: () => (/* binding */ dampE),\n/* harmony export */   i: () => (/* binding */ dampC),\n/* harmony export */   j: () => (/* binding */ dampQ),\n/* harmony export */   k: () => (/* binding */ dampS),\n/* harmony export */   l: () => (/* binding */ dampM),\n/* harmony export */   r: () => (/* binding */ rsqw)\n/* harmony export */ });\n/* harmony import */ var _triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./triangle-b62b9067.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/triangle-b62b9067.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc-7d870b3c.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/misc-7d870b3c.esm.js\");\n\n\n\n\n/**\n * Rounded square wave easing\n */\n\nvar rsqw = function rsqw(t) {\n  var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.01;\n  var a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var f = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1 / (2 * Math.PI);\n  return a / Math.atan(1 / delta) * Math.atan(Math.sin(2 * Math.PI * t * f) / delta);\n};\n/**\n * Exponential easing\n */\n\nvar exp = function exp(t) {\n  return 1 / (1 + t + 0.48 * t * t + 0.235 * t * t * t);\n};\n/**\n * Damp, based on Game Programming Gems 4 Chapter 1.10\n *   Return value indicates whether the animation is still running.\n */\n\nfunction damp(\n/** The object */\ncurrent,\n/** The key to animate */\nprop,\n/** To goal value */\ntarget) {\n  var smoothTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.25;\n  var delta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.01;\n  var maxSpeed = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n  var easing = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : exp;\n  var eps = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0.001;\n  var vel = \"velocity_\" + prop;\n  if (current.__damp === undefined) current.__damp = {};\n  if (current.__damp[vel] === undefined) current.__damp[vel] = 0;\n\n  if (Math.abs(current[prop] - target) <= eps) {\n    current[prop] = target;\n    return false;\n  }\n\n  smoothTime = Math.max(0.0001, smoothTime);\n  var omega = 2 / smoothTime;\n  var t = easing(omega * delta);\n  var change = current[prop] - target;\n  var originalTo = target; // Clamp maximum maxSpeed\n\n  var maxChange = maxSpeed * smoothTime;\n  change = Math.min(Math.max(change, -maxChange), maxChange);\n  target = current[prop] - change;\n  var temp = (current.__damp[vel] + omega * change) * delta;\n  current.__damp[vel] = (current.__damp[vel] - omega * temp) * t;\n  var output = target + (change + temp) * t; // Prevent overshooting\n\n  if (originalTo - current[prop] > 0.0 === output > originalTo) {\n    output = originalTo;\n    current.__damp[vel] = (output - originalTo) / delta;\n  }\n\n  current[prop] = output;\n  return true;\n}\n/**\n * DampAngle, based on Game Programming Gems 4 Chapter 1.10\n */\n\nfunction dampAngle(current, prop, target, smoothTime, delta, maxSpeed, easing, eps) {\n  return damp(current, prop, current[prop] + (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(current[prop], target), smoothTime, delta, maxSpeed, easing, eps);\n}\n/**\n * Vector2D Damp\n */\n\nvar v2d = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();\nvar a2, b2;\nfunction damp2(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (typeof target === \"number\") v2d.setScalar(target);else if (Array.isArray(target)) v2d.set(target[0], target[1]);else v2d.copy(target);\n  a2 = damp(current, \"x\", v2d.x, smoothTime, delta, maxSpeed, easing, eps);\n  b2 = damp(current, \"y\", v2d.y, smoothTime, delta, maxSpeed, easing, eps);\n  return a2 || b2;\n}\n/**\n * Vector3D Damp\n */\n\nvar v3d = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nvar a3, b3, c3;\nfunction damp3(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (typeof target === \"number\") v3d.setScalar(target);else if (Array.isArray(target)) v3d.set(target[0], target[1], target[2]);else v3d.copy(target);\n  a3 = damp(current, \"x\", v3d.x, smoothTime, delta, maxSpeed, easing, eps);\n  b3 = damp(current, \"y\", v3d.y, smoothTime, delta, maxSpeed, easing, eps);\n  c3 = damp(current, \"z\", v3d.z, smoothTime, delta, maxSpeed, easing, eps);\n  return a3 || b3 || c3;\n}\n/**\n * Vector4D Damp\n */\n\nvar v4d = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Vector4();\nvar a4, b4, c4, d4;\nfunction damp4(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (typeof target === \"number\") v4d.setScalar(target);else if (Array.isArray(target)) v4d.set(target[0], target[1], target[2], target[3]);else v4d.copy(target);\n  a4 = damp(current, \"x\", v4d.x, smoothTime, delta, maxSpeed, easing, eps);\n  b4 = damp(current, \"y\", v4d.y, smoothTime, delta, maxSpeed, easing, eps);\n  c4 = damp(current, \"z\", v4d.z, smoothTime, delta, maxSpeed, easing, eps);\n  d4 = damp(current, \"w\", v4d.w, smoothTime, delta, maxSpeed, easing, eps);\n  return a4 || b4 || c4 || d4;\n}\n/**\n * Euler Damp\n */\n\nvar rot = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Euler();\nvar aE, bE, cE;\nfunction dampE(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (Array.isArray(target)) rot.set(target[0], target[1], target[2], target[3]);else rot.copy(target);\n  aE = dampAngle(current, \"x\", rot.x, smoothTime, delta, maxSpeed, easing, eps);\n  bE = dampAngle(current, \"y\", rot.y, smoothTime, delta, maxSpeed, easing, eps);\n  cE = dampAngle(current, \"z\", rot.z, smoothTime, delta, maxSpeed, easing, eps);\n  return aE || bE || cE;\n}\n/**\n * Color Damp\n */\n\nvar col = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Color();\nvar aC, bC, cC;\nfunction dampC(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (target instanceof three__WEBPACK_IMPORTED_MODULE_2__.Color) col.copy(target);else if (Array.isArray(target)) col.setRGB(target[0], target[1], target[2]);else col.set(target);\n  aC = damp(current, \"r\", col.r, smoothTime, delta, maxSpeed, easing, eps);\n  bC = damp(current, \"g\", col.g, smoothTime, delta, maxSpeed, easing, eps);\n  cC = damp(current, \"b\", col.b, smoothTime, delta, maxSpeed, easing, eps);\n  return aC || bC || cC;\n}\n/**\n * Quaternion Damp\n * https://gist.github.com/maxattack/4c7b4de00f5c1b95a33b\n * Copyright 2016 Max Kaufmann (max.kaufmann@gmail.com)\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nvar qt = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\nvar v4result = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Vector4();\nvar v4velocity = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Vector4();\nvar v4error = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Vector4();\nvar aQ, bQ, cQ, dQ;\nfunction dampQ(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  var cur = current;\n  if (Array.isArray(target)) qt.set(target[0], target[1], target[2], target[3]);else qt.copy(target);\n  var multi = current.dot(qt) > 0 ? 1 : -1;\n  qt.x *= multi;\n  qt.y *= multi;\n  qt.z *= multi;\n  qt.w *= multi;\n  aQ = damp(current, \"x\", qt.x, smoothTime, delta, maxSpeed, easing, eps);\n  bQ = damp(current, \"y\", qt.y, smoothTime, delta, maxSpeed, easing, eps);\n  cQ = damp(current, \"z\", qt.z, smoothTime, delta, maxSpeed, easing, eps);\n  dQ = damp(current, \"w\", qt.w, smoothTime, delta, maxSpeed, easing, eps); // smooth damp (nlerp approx)\n\n  v4result.set(current.x, current.y, current.z, current.w).normalize();\n  v4velocity.set(cur.__damp.velocity_x, cur.__damp.velocity_y, cur.__damp.velocity_z, cur.__damp.velocity_w); // ensure deriv is tangent\n\n  v4error.copy(v4result).multiplyScalar(v4velocity.dot(v4result) / v4result.dot(v4result));\n  cur.__damp.velocity_x -= v4error.x;\n  cur.__damp.velocity_y -= v4error.y;\n  cur.__damp.velocity_z -= v4error.z;\n  cur.__damp.velocity_w -= v4error.w;\n  current.set(v4result.x, v4result.y, v4result.z, v4result.w);\n  return aQ || bQ || cQ || dQ;\n}\n/**\n * Spherical Damp\n */\n\nvar spherical = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Spherical();\nvar aS, bS, cS;\nfunction dampS(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (Array.isArray(target)) spherical.set(target[0], target[1], target[2]);else spherical.copy(target);\n  aS = damp(current, \"radius\", spherical.radius, smoothTime, delta, maxSpeed, easing, eps);\n  bS = dampAngle(current, \"phi\", spherical.phi, smoothTime, delta, maxSpeed, easing, eps);\n  cS = dampAngle(current, \"theta\", spherical.theta, smoothTime, delta, maxSpeed, easing, eps);\n  return aS || bS || cS;\n}\n/**\n * Matrix4 Damp\n */\n\nvar mat = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\nvar mPos = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nvar mRot = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\nvar mSca = /*@__PURE__*/new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nvar aM, bM, cM;\nfunction dampM(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  var cur = current;\n\n  if (cur.__damp === undefined) {\n    cur.__damp = {\n      position: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(),\n      rotation: new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion(),\n      scale: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n    };\n    current.decompose(cur.__damp.position, cur.__damp.rotation, cur.__damp.scale);\n  }\n\n  if (Array.isArray(target)) mat.set.apply(mat, (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(target));else mat.copy(target);\n  mat.decompose(mPos, mRot, mSca);\n  aM = damp3(cur.__damp.position, mPos, smoothTime, delta, maxSpeed, easing, eps);\n  bM = dampQ(cur.__damp.rotation, mRot, smoothTime, delta, maxSpeed, easing, eps);\n  cM = damp3(cur.__damp.scale, mSca, smoothTime, delta, maxSpeed, easing, eps);\n  current.compose(cur.__damp.position, cur.__damp.rotation, cur.__damp.scale);\n  return aM || bM || cM;\n}\n\nvar easing = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  rsqw: rsqw,\n  exp: exp,\n  damp: damp,\n  dampAngle: dampAngle,\n  damp2: damp2,\n  damp3: damp3,\n  damp4: damp4,\n  dampE: dampE,\n  dampC: dampC,\n  dampQ: dampQ,\n  dampS: dampS,\n  dampM: dampM\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvZWFzaW5nLTNiZTU5YzZkLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFFO0FBQzJCO0FBQ3ZDOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLHdEQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiwwQ0FBTztBQUNsQztBQUNBO0FBQ0Esd0RBQXdELDhEQUE4RDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMENBQU87QUFDbEM7QUFDQTtBQUNBLHdEQUF3RCx5RUFBeUU7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMENBQU87QUFDbEM7QUFDQTtBQUNBLHdEQUF3RCxvRkFBb0Y7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQix3Q0FBSztBQUNoQztBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHdDQUFLO0FBQ2hDO0FBQ0E7QUFDQSx3QkFBd0Isd0NBQUssbUJBQW1CLDRFQUE0RTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsNkNBQVU7QUFDcEMsZ0NBQWdDLDBDQUFPO0FBQ3ZDLGtDQUFrQywwQ0FBTztBQUN6QywrQkFBK0IsMENBQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0EsOEdBQThHOztBQUU5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyw0Q0FBUztBQUMxQztBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDBDQUFPO0FBQ2xDLDRCQUE0QiwwQ0FBTztBQUNuQyw0QkFBNEIsNkNBQVU7QUFDdEMsNEJBQTRCLDBDQUFPO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLDBDQUFPO0FBQzNCLG9CQUFvQiw2Q0FBVTtBQUM5QixpQkFBaUIsMENBQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCw0REFBa0IsVUFBVTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFc0siLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvZWFzaW5nLTNiZTU5YzZkLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhIGFzIF90b0NvbnN1bWFibGVBcnJheSB9IGZyb20gJy4vdHJpYW5nbGUtYjYyYjkwNjcuZXNtLmpzJztcbmltcG9ydCB7IENvbG9yLCBWZWN0b3IzLCBRdWF0ZXJuaW9uLCBWZWN0b3IyLCBWZWN0b3I0LCBFdWxlciwgU3BoZXJpY2FsLCBNYXRyaXg0IH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgZCBhcyBkZWx0YUFuZ2xlIH0gZnJvbSAnLi9taXNjLTdkODcwYjNjLmVzbS5qcyc7XG5cbi8qKlxuICogUm91bmRlZCBzcXVhcmUgd2F2ZSBlYXNpbmdcbiAqL1xuXG52YXIgcnNxdyA9IGZ1bmN0aW9uIHJzcXcodCkge1xuICB2YXIgZGVsdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDAuMDE7XG4gIHZhciBhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICB2YXIgZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMSAvICgyICogTWF0aC5QSSk7XG4gIHJldHVybiBhIC8gTWF0aC5hdGFuKDEgLyBkZWx0YSkgKiBNYXRoLmF0YW4oTWF0aC5zaW4oMiAqIE1hdGguUEkgKiB0ICogZikgLyBkZWx0YSk7XG59O1xuLyoqXG4gKiBFeHBvbmVudGlhbCBlYXNpbmdcbiAqL1xuXG52YXIgZXhwID0gZnVuY3Rpb24gZXhwKHQpIHtcbiAgcmV0dXJuIDEgLyAoMSArIHQgKyAwLjQ4ICogdCAqIHQgKyAwLjIzNSAqIHQgKiB0ICogdCk7XG59O1xuLyoqXG4gKiBEYW1wLCBiYXNlZCBvbiBHYW1lIFByb2dyYW1taW5nIEdlbXMgNCBDaGFwdGVyIDEuMTBcbiAqICAgUmV0dXJuIHZhbHVlIGluZGljYXRlcyB3aGV0aGVyIHRoZSBhbmltYXRpb24gaXMgc3RpbGwgcnVubmluZy5cbiAqL1xuXG5mdW5jdGlvbiBkYW1wKFxuLyoqIFRoZSBvYmplY3QgKi9cbmN1cnJlbnQsXG4vKiogVGhlIGtleSB0byBhbmltYXRlICovXG5wcm9wLFxuLyoqIFRvIGdvYWwgdmFsdWUgKi9cbnRhcmdldCkge1xuICB2YXIgc21vb3RoVGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMC4yNTtcbiAgdmFyIGRlbHRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAwLjAxO1xuICB2YXIgbWF4U3BlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IEluZmluaXR5O1xuICB2YXIgZWFzaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBleHA7XG4gIHZhciBlcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNyAmJiBhcmd1bWVudHNbN10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s3XSA6IDAuMDAxO1xuICB2YXIgdmVsID0gXCJ2ZWxvY2l0eV9cIiArIHByb3A7XG4gIGlmIChjdXJyZW50Ll9fZGFtcCA9PT0gdW5kZWZpbmVkKSBjdXJyZW50Ll9fZGFtcCA9IHt9O1xuICBpZiAoY3VycmVudC5fX2RhbXBbdmVsXSA9PT0gdW5kZWZpbmVkKSBjdXJyZW50Ll9fZGFtcFt2ZWxdID0gMDtcblxuICBpZiAoTWF0aC5hYnMoY3VycmVudFtwcm9wXSAtIHRhcmdldCkgPD0gZXBzKSB7XG4gICAgY3VycmVudFtwcm9wXSA9IHRhcmdldDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzbW9vdGhUaW1lID0gTWF0aC5tYXgoMC4wMDAxLCBzbW9vdGhUaW1lKTtcbiAgdmFyIG9tZWdhID0gMiAvIHNtb290aFRpbWU7XG4gIHZhciB0ID0gZWFzaW5nKG9tZWdhICogZGVsdGEpO1xuICB2YXIgY2hhbmdlID0gY3VycmVudFtwcm9wXSAtIHRhcmdldDtcbiAgdmFyIG9yaWdpbmFsVG8gPSB0YXJnZXQ7IC8vIENsYW1wIG1heGltdW0gbWF4U3BlZWRcblxuICB2YXIgbWF4Q2hhbmdlID0gbWF4U3BlZWQgKiBzbW9vdGhUaW1lO1xuICBjaGFuZ2UgPSBNYXRoLm1pbihNYXRoLm1heChjaGFuZ2UsIC1tYXhDaGFuZ2UpLCBtYXhDaGFuZ2UpO1xuICB0YXJnZXQgPSBjdXJyZW50W3Byb3BdIC0gY2hhbmdlO1xuICB2YXIgdGVtcCA9IChjdXJyZW50Ll9fZGFtcFt2ZWxdICsgb21lZ2EgKiBjaGFuZ2UpICogZGVsdGE7XG4gIGN1cnJlbnQuX19kYW1wW3ZlbF0gPSAoY3VycmVudC5fX2RhbXBbdmVsXSAtIG9tZWdhICogdGVtcCkgKiB0O1xuICB2YXIgb3V0cHV0ID0gdGFyZ2V0ICsgKGNoYW5nZSArIHRlbXApICogdDsgLy8gUHJldmVudCBvdmVyc2hvb3RpbmdcblxuICBpZiAob3JpZ2luYWxUbyAtIGN1cnJlbnRbcHJvcF0gPiAwLjAgPT09IG91dHB1dCA+IG9yaWdpbmFsVG8pIHtcbiAgICBvdXRwdXQgPSBvcmlnaW5hbFRvO1xuICAgIGN1cnJlbnQuX19kYW1wW3ZlbF0gPSAob3V0cHV0IC0gb3JpZ2luYWxUbykgLyBkZWx0YTtcbiAgfVxuXG4gIGN1cnJlbnRbcHJvcF0gPSBvdXRwdXQ7XG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBEYW1wQW5nbGUsIGJhc2VkIG9uIEdhbWUgUHJvZ3JhbW1pbmcgR2VtcyA0IENoYXB0ZXIgMS4xMFxuICovXG5cbmZ1bmN0aW9uIGRhbXBBbmdsZShjdXJyZW50LCBwcm9wLCB0YXJnZXQsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpIHtcbiAgcmV0dXJuIGRhbXAoY3VycmVudCwgcHJvcCwgY3VycmVudFtwcm9wXSArIGRlbHRhQW5nbGUoY3VycmVudFtwcm9wXSwgdGFyZ2V0KSwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG59XG4vKipcbiAqIFZlY3RvcjJEIERhbXBcbiAqL1xuXG52YXIgdjJkID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG52YXIgYTIsIGIyO1xuZnVuY3Rpb24gZGFtcDIoY3VycmVudCwgdGFyZ2V0LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKSB7XG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcIm51bWJlclwiKSB2MmQuc2V0U2NhbGFyKHRhcmdldCk7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB2MmQuc2V0KHRhcmdldFswXSwgdGFyZ2V0WzFdKTtlbHNlIHYyZC5jb3B5KHRhcmdldCk7XG4gIGEyID0gZGFtcChjdXJyZW50LCBcInhcIiwgdjJkLngsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICBiMiA9IGRhbXAoY3VycmVudCwgXCJ5XCIsIHYyZC55LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgcmV0dXJuIGEyIHx8IGIyO1xufVxuLyoqXG4gKiBWZWN0b3IzRCBEYW1wXG4gKi9cblxudmFyIHYzZCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xudmFyIGEzLCBiMywgYzM7XG5mdW5jdGlvbiBkYW1wMyhjdXJyZW50LCB0YXJnZXQsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpIHtcbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwibnVtYmVyXCIpIHYzZC5zZXRTY2FsYXIodGFyZ2V0KTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHYzZC5zZXQodGFyZ2V0WzBdLCB0YXJnZXRbMV0sIHRhcmdldFsyXSk7ZWxzZSB2M2QuY29weSh0YXJnZXQpO1xuICBhMyA9IGRhbXAoY3VycmVudCwgXCJ4XCIsIHYzZC54LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgYjMgPSBkYW1wKGN1cnJlbnQsIFwieVwiLCB2M2QueSwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGMzID0gZGFtcChjdXJyZW50LCBcInpcIiwgdjNkLnosIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICByZXR1cm4gYTMgfHwgYjMgfHwgYzM7XG59XG4vKipcbiAqIFZlY3RvcjREIERhbXBcbiAqL1xuXG52YXIgdjRkID0gLypAX19QVVJFX18qL25ldyBWZWN0b3I0KCk7XG52YXIgYTQsIGI0LCBjNCwgZDQ7XG5mdW5jdGlvbiBkYW1wNChjdXJyZW50LCB0YXJnZXQsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpIHtcbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwibnVtYmVyXCIpIHY0ZC5zZXRTY2FsYXIodGFyZ2V0KTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHY0ZC5zZXQodGFyZ2V0WzBdLCB0YXJnZXRbMV0sIHRhcmdldFsyXSwgdGFyZ2V0WzNdKTtlbHNlIHY0ZC5jb3B5KHRhcmdldCk7XG4gIGE0ID0gZGFtcChjdXJyZW50LCBcInhcIiwgdjRkLngsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICBiNCA9IGRhbXAoY3VycmVudCwgXCJ5XCIsIHY0ZC55LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgYzQgPSBkYW1wKGN1cnJlbnQsIFwielwiLCB2NGQueiwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGQ0ID0gZGFtcChjdXJyZW50LCBcIndcIiwgdjRkLncsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICByZXR1cm4gYTQgfHwgYjQgfHwgYzQgfHwgZDQ7XG59XG4vKipcbiAqIEV1bGVyIERhbXBcbiAqL1xuXG52YXIgcm90ID0gLypAX19QVVJFX18qL25ldyBFdWxlcigpO1xudmFyIGFFLCBiRSwgY0U7XG5mdW5jdGlvbiBkYW1wRShjdXJyZW50LCB0YXJnZXQsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkgcm90LnNldCh0YXJnZXRbMF0sIHRhcmdldFsxXSwgdGFyZ2V0WzJdLCB0YXJnZXRbM10pO2Vsc2Ugcm90LmNvcHkodGFyZ2V0KTtcbiAgYUUgPSBkYW1wQW5nbGUoY3VycmVudCwgXCJ4XCIsIHJvdC54LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgYkUgPSBkYW1wQW5nbGUoY3VycmVudCwgXCJ5XCIsIHJvdC55LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgY0UgPSBkYW1wQW5nbGUoY3VycmVudCwgXCJ6XCIsIHJvdC56LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgcmV0dXJuIGFFIHx8IGJFIHx8IGNFO1xufVxuLyoqXG4gKiBDb2xvciBEYW1wXG4gKi9cblxudmFyIGNvbCA9IC8qQF9fUFVSRV9fKi9uZXcgQ29sb3IoKTtcbnZhciBhQywgYkMsIGNDO1xuZnVuY3Rpb24gZGFtcEMoY3VycmVudCwgdGFyZ2V0LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKSB7XG4gIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBDb2xvcikgY29sLmNvcHkodGFyZ2V0KTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIGNvbC5zZXRSR0IodGFyZ2V0WzBdLCB0YXJnZXRbMV0sIHRhcmdldFsyXSk7ZWxzZSBjb2wuc2V0KHRhcmdldCk7XG4gIGFDID0gZGFtcChjdXJyZW50LCBcInJcIiwgY29sLnIsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICBiQyA9IGRhbXAoY3VycmVudCwgXCJnXCIsIGNvbC5nLCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKTtcbiAgY0MgPSBkYW1wKGN1cnJlbnQsIFwiYlwiLCBjb2wuYiwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIHJldHVybiBhQyB8fCBiQyB8fCBjQztcbn1cbi8qKlxuICogUXVhdGVybmlvbiBEYW1wXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tYXhhdHRhY2svNGM3YjRkZTAwZjVjMWI5NWEzM2JcbiAqIENvcHlyaWdodCAyMDE2IE1heCBLYXVmbWFubiAobWF4LmthdWZtYW5uQGdtYWlsLmNvbSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbnZhciBxdCA9IC8qQF9fUFVSRV9fKi9uZXcgUXVhdGVybmlvbigpO1xudmFyIHY0cmVzdWx0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3I0KCk7XG52YXIgdjR2ZWxvY2l0eSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yNCgpO1xudmFyIHY0ZXJyb3IgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjQoKTtcbnZhciBhUSwgYlEsIGNRLCBkUTtcbmZ1bmN0aW9uIGRhbXBRKGN1cnJlbnQsIHRhcmdldCwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcykge1xuICB2YXIgY3VyID0gY3VycmVudDtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkgcXQuc2V0KHRhcmdldFswXSwgdGFyZ2V0WzFdLCB0YXJnZXRbMl0sIHRhcmdldFszXSk7ZWxzZSBxdC5jb3B5KHRhcmdldCk7XG4gIHZhciBtdWx0aSA9IGN1cnJlbnQuZG90KHF0KSA+IDAgPyAxIDogLTE7XG4gIHF0LnggKj0gbXVsdGk7XG4gIHF0LnkgKj0gbXVsdGk7XG4gIHF0LnogKj0gbXVsdGk7XG4gIHF0LncgKj0gbXVsdGk7XG4gIGFRID0gZGFtcChjdXJyZW50LCBcInhcIiwgcXQueCwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGJRID0gZGFtcChjdXJyZW50LCBcInlcIiwgcXQueSwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGNRID0gZGFtcChjdXJyZW50LCBcInpcIiwgcXQueiwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGRRID0gZGFtcChjdXJyZW50LCBcIndcIiwgcXQudywgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7IC8vIHNtb290aCBkYW1wIChubGVycCBhcHByb3gpXG5cbiAgdjRyZXN1bHQuc2V0KGN1cnJlbnQueCwgY3VycmVudC55LCBjdXJyZW50LnosIGN1cnJlbnQudykubm9ybWFsaXplKCk7XG4gIHY0dmVsb2NpdHkuc2V0KGN1ci5fX2RhbXAudmVsb2NpdHlfeCwgY3VyLl9fZGFtcC52ZWxvY2l0eV95LCBjdXIuX19kYW1wLnZlbG9jaXR5X3osIGN1ci5fX2RhbXAudmVsb2NpdHlfdyk7IC8vIGVuc3VyZSBkZXJpdiBpcyB0YW5nZW50XG5cbiAgdjRlcnJvci5jb3B5KHY0cmVzdWx0KS5tdWx0aXBseVNjYWxhcih2NHZlbG9jaXR5LmRvdCh2NHJlc3VsdCkgLyB2NHJlc3VsdC5kb3QodjRyZXN1bHQpKTtcbiAgY3VyLl9fZGFtcC52ZWxvY2l0eV94IC09IHY0ZXJyb3IueDtcbiAgY3VyLl9fZGFtcC52ZWxvY2l0eV95IC09IHY0ZXJyb3IueTtcbiAgY3VyLl9fZGFtcC52ZWxvY2l0eV96IC09IHY0ZXJyb3IuejtcbiAgY3VyLl9fZGFtcC52ZWxvY2l0eV93IC09IHY0ZXJyb3IudztcbiAgY3VycmVudC5zZXQodjRyZXN1bHQueCwgdjRyZXN1bHQueSwgdjRyZXN1bHQueiwgdjRyZXN1bHQudyk7XG4gIHJldHVybiBhUSB8fCBiUSB8fCBjUSB8fCBkUTtcbn1cbi8qKlxuICogU3BoZXJpY2FsIERhbXBcbiAqL1xuXG52YXIgc3BoZXJpY2FsID0gLypAX19QVVJFX18qL25ldyBTcGhlcmljYWwoKTtcbnZhciBhUywgYlMsIGNTO1xuZnVuY3Rpb24gZGFtcFMoY3VycmVudCwgdGFyZ2V0LCBzbW9vdGhUaW1lLCBkZWx0YSwgbWF4U3BlZWQsIGVhc2luZywgZXBzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHNwaGVyaWNhbC5zZXQodGFyZ2V0WzBdLCB0YXJnZXRbMV0sIHRhcmdldFsyXSk7ZWxzZSBzcGhlcmljYWwuY29weSh0YXJnZXQpO1xuICBhUyA9IGRhbXAoY3VycmVudCwgXCJyYWRpdXNcIiwgc3BoZXJpY2FsLnJhZGl1cywgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGJTID0gZGFtcEFuZ2xlKGN1cnJlbnQsIFwicGhpXCIsIHNwaGVyaWNhbC5waGksIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpO1xuICBjUyA9IGRhbXBBbmdsZShjdXJyZW50LCBcInRoZXRhXCIsIHNwaGVyaWNhbC50aGV0YSwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIHJldHVybiBhUyB8fCBiUyB8fCBjUztcbn1cbi8qKlxuICogTWF0cml4NCBEYW1wXG4gKi9cblxudmFyIG1hdCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xudmFyIG1Qb3MgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcbnZhciBtUm90ID0gLypAX19QVVJFX18qL25ldyBRdWF0ZXJuaW9uKCk7XG52YXIgbVNjYSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xudmFyIGFNLCBiTSwgY007XG5mdW5jdGlvbiBkYW1wTShjdXJyZW50LCB0YXJnZXQsIHNtb290aFRpbWUsIGRlbHRhLCBtYXhTcGVlZCwgZWFzaW5nLCBlcHMpIHtcbiAgdmFyIGN1ciA9IGN1cnJlbnQ7XG5cbiAgaWYgKGN1ci5fX2RhbXAgPT09IHVuZGVmaW5lZCkge1xuICAgIGN1ci5fX2RhbXAgPSB7XG4gICAgICBwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcbiAgICAgIHJvdGF0aW9uOiBuZXcgUXVhdGVybmlvbigpLFxuICAgICAgc2NhbGU6IG5ldyBWZWN0b3IzKClcbiAgICB9O1xuICAgIGN1cnJlbnQuZGVjb21wb3NlKGN1ci5fX2RhbXAucG9zaXRpb24sIGN1ci5fX2RhbXAucm90YXRpb24sIGN1ci5fX2RhbXAuc2NhbGUpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkgbWF0LnNldC5hcHBseShtYXQsIF90b0NvbnN1bWFibGVBcnJheSh0YXJnZXQpKTtlbHNlIG1hdC5jb3B5KHRhcmdldCk7XG4gIG1hdC5kZWNvbXBvc2UobVBvcywgbVJvdCwgbVNjYSk7XG4gIGFNID0gZGFtcDMoY3VyLl9fZGFtcC5wb3NpdGlvbiwgbVBvcywgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGJNID0gZGFtcFEoY3VyLl9fZGFtcC5yb3RhdGlvbiwgbVJvdCwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGNNID0gZGFtcDMoY3VyLl9fZGFtcC5zY2FsZSwgbVNjYSwgc21vb3RoVGltZSwgZGVsdGEsIG1heFNwZWVkLCBlYXNpbmcsIGVwcyk7XG4gIGN1cnJlbnQuY29tcG9zZShjdXIuX19kYW1wLnBvc2l0aW9uLCBjdXIuX19kYW1wLnJvdGF0aW9uLCBjdXIuX19kYW1wLnNjYWxlKTtcbiAgcmV0dXJuIGFNIHx8IGJNIHx8IGNNO1xufVxuXG52YXIgZWFzaW5nID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHJzcXc6IHJzcXcsXG4gIGV4cDogZXhwLFxuICBkYW1wOiBkYW1wLFxuICBkYW1wQW5nbGU6IGRhbXBBbmdsZSxcbiAgZGFtcDI6IGRhbXAyLFxuICBkYW1wMzogZGFtcDMsXG4gIGRhbXA0OiBkYW1wNCxcbiAgZGFtcEU6IGRhbXBFLFxuICBkYW1wQzogZGFtcEMsXG4gIGRhbXBROiBkYW1wUSxcbiAgZGFtcFM6IGRhbXBTLFxuICBkYW1wTTogZGFtcE1cbn0pO1xuXG5leHBvcnQgeyBleHAgYXMgYSwgZGFtcEFuZ2xlIGFzIGIsIGRhbXAyIGFzIGMsIGRhbXAgYXMgZCwgZWFzaW5nIGFzIGUsIGRhbXAzIGFzIGYsIGRhbXA0IGFzIGcsIGRhbXBFIGFzIGgsIGRhbXBDIGFzIGksIGRhbXBRIGFzIGosIGRhbXBTIGFzIGssIGRhbXBNIGFzIGwsIHJzcXcgYXMgciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/easing-3be59c6d.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/geometry-982366ff.esm.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/geometry-982366ff.esm.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   R: () => (/* binding */ RoundedPlaneGeometry),\n/* harmony export */   a: () => (/* binding */ applySphereUV),\n/* harmony export */   b: () => (/* binding */ applyBoxUV),\n/* harmony export */   g: () => (/* binding */ geometry)\n/* harmony export */ });\n/* harmony import */ var _classCallCheck_9098b006_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classCallCheck-9098b006.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/classCallCheck-9098b006.esm.js\");\n/* harmony import */ var _isNativeReflectConstruct_5594d075_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNativeReflectConstruct-5594d075.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/isNativeReflectConstruct-5594d075.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\n\n\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) (0,_isNativeReflectConstruct_5594d075_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = (0,_isNativeReflectConstruct_5594d075_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar RoundedPlaneGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  _inherits(RoundedPlaneGeometry, _THREE$BufferGeometry);\n\n  var _super = _createSuper(RoundedPlaneGeometry);\n\n  function RoundedPlaneGeometry() {\n    var _this;\n\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.2;\n    var segments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 16;\n\n    (0,_classCallCheck_9098b006_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(this, RoundedPlaneGeometry);\n\n    _this = _super.call(this); // helper const's\n\n    var wi = width / 2 - radius; // inner width\n\n    var hi = height / 2 - radius; // inner height\n\n    var ul = radius / width; // u left\n\n    var ur = (width - radius) / width; // u right\n\n    var vl = radius / height; // v low\n\n    var vh = (height - radius) / height; // v high\n\n    var positions = [wi, hi, 0, -wi, hi, 0, -wi, -hi, 0, wi, -hi, 0];\n    var uvs = [ur, vh, ul, vh, ul, vl, ur, vl];\n    var n = [3 * (segments + 1) + 3, 3 * (segments + 1) + 4, segments + 4, segments + 5, 2 * (segments + 1) + 4, 2, 1, 2 * (segments + 1) + 3, 3, 4 * (segments + 1) + 3, 4, 0];\n    var indices = [n[0], n[1], n[2], n[0], n[2], n[3], n[4], n[5], n[6], n[4], n[6], n[7], n[8], n[9], n[10], n[8], n[10], n[11]];\n    var phi, cos, sin, xc, yc, uc, vc, idx;\n\n    for (var i = 0; i < 4; i++) {\n      xc = i < 1 || i > 2 ? wi : -wi;\n      yc = i < 2 ? hi : -hi;\n      uc = i < 1 || i > 2 ? ur : ul;\n      vc = i < 2 ? vh : vl;\n\n      for (var j = 0; j <= segments; j++) {\n        phi = Math.PI / 2 * (i + j / segments);\n        cos = Math.cos(phi);\n        sin = Math.sin(phi);\n        positions.push(xc + radius * cos, yc + radius * sin, 0);\n        uvs.push(uc + ul * cos, vc + vl * sin);\n\n        if (j < segments) {\n          idx = (segments + 1) * i + j + 4;\n          indices.push(i, idx, idx + 1);\n        }\n      }\n    }\n\n    _this.setIndex(new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(new Uint32Array(indices), 1));\n\n    _this.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(new Float32Array(positions), 3));\n\n    _this.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(new Float32Array(uvs), 2));\n\n    return _this;\n  }\n\n  return RoundedPlaneGeometry;\n}(three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry); // Author: https://stackoverflow.com/users/268905/knee-cola\n// https://stackoverflow.com/questions/20774648/three-js-generate-uv-coordinate\n\nfunction applySphereUV(bufferGeometry) {\n  var uvs = [];\n  var vertices = [];\n\n  for (var i = 0; i < bufferGeometry.attributes.position.array.length / 3; i++) {\n    var x = bufferGeometry.attributes.position.array[i * 3 + 0];\n    var y = bufferGeometry.attributes.position.array[i * 3 + 1];\n    var z = bufferGeometry.attributes.position.array[i * 3 + 2];\n    vertices.push(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z));\n  }\n\n  var polarVertices = vertices.map(cartesian2polar);\n\n  for (var _i = 0; _i < polarVertices.length / 3; _i++) {\n    var tri = new three__WEBPACK_IMPORTED_MODULE_2__.Triangle(vertices[_i * 3 + 0], vertices[_i * 3 + 1], vertices[_i * 3 + 2]);\n    var normal = tri.getNormal(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n\n    for (var f = 0; f < 3; f++) {\n      var vertex = polarVertices[_i * 3 + f];\n\n      if (vertex.theta === 0 && (vertex.phi === 0 || vertex.phi === Math.PI)) {\n        var alignedVertice = vertex.phi === 0 ? _i * 3 + 1 : _i * 3 + 0;\n        vertex = {\n          r: vertex.r,\n          phi: vertex.phi,\n          theta: polarVertices[alignedVertice].theta\n        };\n      }\n\n      if (vertex.theta === Math.PI && cartesian2polar(normal).theta < Math.PI / 2) {\n        vertex.theta = -Math.PI;\n      }\n\n      var canvasPoint = polar2canvas(vertex);\n      uvs.push(1 - canvasPoint.x, 1 - canvasPoint.y);\n    }\n  }\n\n  if (bufferGeometry.attributes.uv) delete bufferGeometry.attributes.uv;\n  bufferGeometry.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(uvs, 2));\n  bufferGeometry.attributes.uv.needsUpdate = true;\n  return bufferGeometry;\n}\n\nfunction cartesian2polar(position) {\n  var r = Math.sqrt(position.x * position.x + position.z * position.z + position.y * position.y);\n  return {\n    r: r,\n    phi: Math.acos(position.y / r),\n    theta: Math.atan2(position.z, position.x)\n  };\n}\n\nfunction polar2canvas(polarPoint) {\n  return {\n    y: polarPoint.phi / Math.PI,\n    x: (polarPoint.theta + Math.PI) / (2 * Math.PI)\n  };\n} // Author: Alex Khoroshylov (https://stackoverflow.com/users/8742287/alex-khoroshylov)\n// https://stackoverflow.com/questions/20774648/three-js-generate-uv-coordinate\n\n\nfunction applyBoxUV(bufferGeometry) {\n  bufferGeometry.computeBoundingBox();\n  var bboxSize = bufferGeometry.boundingBox.getSize(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n  var boxSize = Math.min(bboxSize.x, bboxSize.y, bboxSize.z);\n  var boxGeometry = new three__WEBPACK_IMPORTED_MODULE_2__.BoxGeometry(boxSize, boxSize, boxSize);\n  var cube = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(boxGeometry);\n  cube.rotation.set(0, 0, 0);\n  cube.updateWorldMatrix(true, false);\n  var transformMatrix = cube.matrix.clone().invert();\n  var uvBbox = new three__WEBPACK_IMPORTED_MODULE_2__.Box3(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(-boxSize / 2, -boxSize / 2, -boxSize / 2), new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(boxSize / 2, boxSize / 2, boxSize / 2));\n\n  _applyBoxUV(bufferGeometry, transformMatrix, uvBbox, boxSize);\n\n  bufferGeometry.attributes.uv.needsUpdate = true;\n  return bufferGeometry;\n}\n\nfunction _applyBoxUV(geom, transformMatrix, bbox, bbox_max_size) {\n  var coords = [];\n  coords.length = 2 * geom.attributes.position.array.length / 3; //maps 3 verts of 1 face on the better side of the cube\n  //side of the cube can be XY, XZ or YZ\n\n  var makeUVs = function makeUVs(v0, v1, v2) {\n    //pre-rotate the model so that cube sides match world axis\n    v0.applyMatrix4(transformMatrix);\n    v1.applyMatrix4(transformMatrix);\n    v2.applyMatrix4(transformMatrix); //get normal of the face, to know into which cube side it maps better\n\n    var n = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    n.crossVectors(v1.clone().sub(v0), v1.clone().sub(v2)).normalize();\n    n.x = Math.abs(n.x);\n    n.y = Math.abs(n.y);\n    n.z = Math.abs(n.z);\n    var uv0 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();\n    var uv1 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();\n    var uv2 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(); // xz mapping\n\n    if (n.y > n.x && n.y > n.z) {\n      uv0.x = (v0.x - bbox.min.x) / bbox_max_size;\n      uv0.y = (bbox.max.z - v0.z) / bbox_max_size;\n      uv1.x = (v1.x - bbox.min.x) / bbox_max_size;\n      uv1.y = (bbox.max.z - v1.z) / bbox_max_size;\n      uv2.x = (v2.x - bbox.min.x) / bbox_max_size;\n      uv2.y = (bbox.max.z - v2.z) / bbox_max_size;\n    } else if (n.x > n.y && n.x > n.z) {\n      uv0.x = (v0.z - bbox.min.z) / bbox_max_size;\n      uv0.y = (v0.y - bbox.min.y) / bbox_max_size;\n      uv1.x = (v1.z - bbox.min.z) / bbox_max_size;\n      uv1.y = (v1.y - bbox.min.y) / bbox_max_size;\n      uv2.x = (v2.z - bbox.min.z) / bbox_max_size;\n      uv2.y = (v2.y - bbox.min.y) / bbox_max_size;\n    } else if (n.z > n.y && n.z > n.x) {\n      uv0.x = (v0.x - bbox.min.x) / bbox_max_size;\n      uv0.y = (v0.y - bbox.min.y) / bbox_max_size;\n      uv1.x = (v1.x - bbox.min.x) / bbox_max_size;\n      uv1.y = (v1.y - bbox.min.y) / bbox_max_size;\n      uv2.x = (v2.x - bbox.min.x) / bbox_max_size;\n      uv2.y = (v2.y - bbox.min.y) / bbox_max_size;\n    }\n\n    return {\n      uv0: uv0,\n      uv1: uv1,\n      uv2: uv2\n    };\n  };\n\n  if (geom.index) {\n    // is it indexed buffer geometry?\n    for (var vi = 0; vi < geom.index.array.length; vi += 3) {\n      var idx0 = geom.index.array[vi];\n      var idx1 = geom.index.array[vi + 1];\n      var idx2 = geom.index.array[vi + 2];\n      var vx0 = geom.attributes.position.array[3 * idx0];\n      var vy0 = geom.attributes.position.array[3 * idx0 + 1];\n      var vz0 = geom.attributes.position.array[3 * idx0 + 2];\n      var vx1 = geom.attributes.position.array[3 * idx1];\n      var vy1 = geom.attributes.position.array[3 * idx1 + 1];\n      var vz1 = geom.attributes.position.array[3 * idx1 + 2];\n      var vx2 = geom.attributes.position.array[3 * idx2];\n      var vy2 = geom.attributes.position.array[3 * idx2 + 1];\n      var vz2 = geom.attributes.position.array[3 * idx2 + 2];\n      var v0 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(vx0, vy0, vz0);\n      var v1 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(vx1, vy1, vz1);\n      var v2 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(vx2, vy2, vz2);\n      var uvs = makeUVs(v0, v1, v2);\n      coords[2 * idx0] = uvs.uv0.x;\n      coords[2 * idx0 + 1] = uvs.uv0.y;\n      coords[2 * idx1] = uvs.uv1.x;\n      coords[2 * idx1 + 1] = uvs.uv1.y;\n      coords[2 * idx2] = uvs.uv2.x;\n      coords[2 * idx2 + 1] = uvs.uv2.y;\n    }\n  } else {\n    for (var _vi = 0; _vi < geom.attributes.position.array.length; _vi += 9) {\n      var _vx = geom.attributes.position.array[_vi];\n      var _vy = geom.attributes.position.array[_vi + 1];\n      var _vz = geom.attributes.position.array[_vi + 2];\n      var _vx2 = geom.attributes.position.array[_vi + 3];\n      var _vy2 = geom.attributes.position.array[_vi + 4];\n      var _vz2 = geom.attributes.position.array[_vi + 5];\n      var _vx3 = geom.attributes.position.array[_vi + 6];\n      var _vy3 = geom.attributes.position.array[_vi + 7];\n      var _vz3 = geom.attributes.position.array[_vi + 8];\n\n      var _v = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(_vx, _vy, _vz);\n\n      var _v2 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(_vx2, _vy2, _vz2);\n\n      var _v3 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(_vx3, _vy3, _vz3);\n\n      var _uvs = makeUVs(_v, _v2, _v3);\n\n      var _idx = _vi / 3;\n\n      var _idx2 = _idx + 1;\n\n      var _idx3 = _idx + 2;\n\n      coords[2 * _idx] = _uvs.uv0.x;\n      coords[2 * _idx + 1] = _uvs.uv0.y;\n      coords[2 * _idx2] = _uvs.uv1.x;\n      coords[2 * _idx2 + 1] = _uvs.uv1.y;\n      coords[2 * _idx3] = _uvs.uv2.x;\n      coords[2 * _idx3 + 1] = _uvs.uv2.y;\n    }\n  }\n\n  if (geom.attributes.uv) delete geom.attributes.uv;\n  geom.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(coords, 2));\n}\n\nvar geometry = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  RoundedPlaneGeometry: RoundedPlaneGeometry,\n  applySphereUV: applySphereUV,\n  applyBoxUV: applyBoxUV\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvZ2VvbWV0cnktOTgyMzY2ZmYuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBd0U7QUFDMEM7QUFDbkY7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsNEVBQWU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyw0RUFBeUI7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxrRUFBZTs7QUFFbkIsK0JBQStCOztBQUUvQixpQ0FBaUM7O0FBRWpDLGtDQUFrQzs7QUFFbEMsNkJBQTZCOztBQUU3Qix1Q0FBdUM7O0FBRXZDLDhCQUE4Qjs7QUFFOUIseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixrREFBcUI7O0FBRTVDLHVDQUF1QyxrREFBcUI7O0FBRTVELGlDQUFpQyxrREFBcUI7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLENBQUMsaURBQW9CLEdBQUc7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix5REFBeUQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBDQUFhO0FBQ25DOztBQUVBOztBQUVBLG1CQUFtQiwrQkFBK0I7QUFDbEQsa0JBQWtCLDJDQUFjO0FBQ2hDLG1DQUFtQywwQ0FBYTs7QUFFaEQsb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MseURBQTRCO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQSx3REFBd0QsMENBQWE7QUFDckU7QUFDQSx3QkFBd0IsOENBQWlCO0FBQ3pDLGlCQUFpQix1Q0FBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUNBQVUsS0FBSywwQ0FBYSxnREFBZ0QsMENBQWE7O0FBRTVHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QyxnQkFBZ0IsMENBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMENBQWE7QUFDL0Isa0JBQWtCLDBDQUFhO0FBQy9CLGtCQUFrQiwwQ0FBYSxJQUFJOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBYTtBQUNoQyxtQkFBbUIsMENBQWE7QUFDaEMsbUJBQW1CLDBDQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0JBQXNCLDZDQUE2QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDBDQUFhOztBQUVoQyxvQkFBb0IsMENBQWE7O0FBRWpDLG9CQUFvQiwwQ0FBYTs7QUFFakM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qix5REFBNEI7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRXdGIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL3Bvc3Rwcm9jZXNzaW5nL25vZGVfbW9kdWxlcy9tYWF0aC9kaXN0L2dlb21ldHJ5LTk4MjM2NmZmLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfIGFzIF9jbGFzc0NhbGxDaGVjayB9IGZyb20gJy4vY2xhc3NDYWxsQ2hlY2stOTA5OGIwMDYuZXNtLmpzJztcbmltcG9ydCB7IF8gYXMgX3NldFByb3RvdHlwZU9mLCBhIGFzIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgfSBmcm9tICcuL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC01NTk0ZDA3NS5lc20uanMnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbnZhciBSb3VuZGVkUGxhbmVHZW9tZXRyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RIUkVFJEJ1ZmZlckdlb21ldHJ5KSB7XG4gIF9pbmhlcml0cyhSb3VuZGVkUGxhbmVHZW9tZXRyeSwgX1RIUkVFJEJ1ZmZlckdlb21ldHJ5KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJvdW5kZWRQbGFuZUdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBSb3VuZGVkUGxhbmVHZW9tZXRyeSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDI7XG4gICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwLjI7XG4gICAgdmFyIHNlZ21lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxNjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3VuZGVkUGxhbmVHZW9tZXRyeSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpOyAvLyBoZWxwZXIgY29uc3Qnc1xuXG4gICAgdmFyIHdpID0gd2lkdGggLyAyIC0gcmFkaXVzOyAvLyBpbm5lciB3aWR0aFxuXG4gICAgdmFyIGhpID0gaGVpZ2h0IC8gMiAtIHJhZGl1czsgLy8gaW5uZXIgaGVpZ2h0XG5cbiAgICB2YXIgdWwgPSByYWRpdXMgLyB3aWR0aDsgLy8gdSBsZWZ0XG5cbiAgICB2YXIgdXIgPSAod2lkdGggLSByYWRpdXMpIC8gd2lkdGg7IC8vIHUgcmlnaHRcblxuICAgIHZhciB2bCA9IHJhZGl1cyAvIGhlaWdodDsgLy8gdiBsb3dcblxuICAgIHZhciB2aCA9IChoZWlnaHQgLSByYWRpdXMpIC8gaGVpZ2h0OyAvLyB2IGhpZ2hcblxuICAgIHZhciBwb3NpdGlvbnMgPSBbd2ksIGhpLCAwLCAtd2ksIGhpLCAwLCAtd2ksIC1oaSwgMCwgd2ksIC1oaSwgMF07XG4gICAgdmFyIHV2cyA9IFt1ciwgdmgsIHVsLCB2aCwgdWwsIHZsLCB1ciwgdmxdO1xuICAgIHZhciBuID0gWzMgKiAoc2VnbWVudHMgKyAxKSArIDMsIDMgKiAoc2VnbWVudHMgKyAxKSArIDQsIHNlZ21lbnRzICsgNCwgc2VnbWVudHMgKyA1LCAyICogKHNlZ21lbnRzICsgMSkgKyA0LCAyLCAxLCAyICogKHNlZ21lbnRzICsgMSkgKyAzLCAzLCA0ICogKHNlZ21lbnRzICsgMSkgKyAzLCA0LCAwXTtcbiAgICB2YXIgaW5kaWNlcyA9IFtuWzBdLCBuWzFdLCBuWzJdLCBuWzBdLCBuWzJdLCBuWzNdLCBuWzRdLCBuWzVdLCBuWzZdLCBuWzRdLCBuWzZdLCBuWzddLCBuWzhdLCBuWzldLCBuWzEwXSwgbls4XSwgblsxMF0sIG5bMTFdXTtcbiAgICB2YXIgcGhpLCBjb3MsIHNpbiwgeGMsIHljLCB1YywgdmMsIGlkeDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICB4YyA9IGkgPCAxIHx8IGkgPiAyID8gd2kgOiAtd2k7XG4gICAgICB5YyA9IGkgPCAyID8gaGkgOiAtaGk7XG4gICAgICB1YyA9IGkgPCAxIHx8IGkgPiAyID8gdXIgOiB1bDtcbiAgICAgIHZjID0gaSA8IDIgPyB2aCA6IHZsO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBzZWdtZW50czsgaisrKSB7XG4gICAgICAgIHBoaSA9IE1hdGguUEkgLyAyICogKGkgKyBqIC8gc2VnbWVudHMpO1xuICAgICAgICBjb3MgPSBNYXRoLmNvcyhwaGkpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbihwaGkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaCh4YyArIHJhZGl1cyAqIGNvcywgeWMgKyByYWRpdXMgKiBzaW4sIDApO1xuICAgICAgICB1dnMucHVzaCh1YyArIHVsICogY29zLCB2YyArIHZsICogc2luKTtcblxuICAgICAgICBpZiAoaiA8IHNlZ21lbnRzKSB7XG4gICAgICAgICAgaWR4ID0gKHNlZ21lbnRzICsgMSkgKiBpICsgaiArIDQ7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGksIGlkeCwgaWR4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpcy5zZXRJbmRleChuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKG5ldyBVaW50MzJBcnJheShpbmRpY2VzKSwgMSkpO1xuXG4gICAgX3RoaXMuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucyksIDMpKTtcblxuICAgIF90aGlzLnNldEF0dHJpYnV0ZShcInV2XCIsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSh1dnMpLCAyKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gUm91bmRlZFBsYW5lR2VvbWV0cnk7XG59KFRIUkVFLkJ1ZmZlckdlb21ldHJ5KTsgLy8gQXV0aG9yOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3VzZXJzLzI2ODkwNS9rbmVlLWNvbGFcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwNzc0NjQ4L3RocmVlLWpzLWdlbmVyYXRlLXV2LWNvb3JkaW5hdGVcblxuZnVuY3Rpb24gYXBwbHlTcGhlcmVVVihidWZmZXJHZW9tZXRyeSkge1xuICB2YXIgdXZzID0gW107XG4gIHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheS5sZW5ndGggLyAzOyBpKyspIHtcbiAgICB2YXIgeCA9IGJ1ZmZlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSAqIDMgKyAwXTtcbiAgICB2YXIgeSA9IGJ1ZmZlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSAqIDMgKyAxXTtcbiAgICB2YXIgeiA9IGJ1ZmZlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSAqIDMgKyAyXTtcbiAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKHgsIHksIHopKTtcbiAgfVxuXG4gIHZhciBwb2xhclZlcnRpY2VzID0gdmVydGljZXMubWFwKGNhcnRlc2lhbjJwb2xhcik7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBvbGFyVmVydGljZXMubGVuZ3RoIC8gMzsgX2krKykge1xuICAgIHZhciB0cmkgPSBuZXcgVEhSRUUuVHJpYW5nbGUodmVydGljZXNbX2kgKiAzICsgMF0sIHZlcnRpY2VzW19pICogMyArIDFdLCB2ZXJ0aWNlc1tfaSAqIDMgKyAyXSk7XG4gICAgdmFyIG5vcm1hbCA9IHRyaS5nZXROb3JtYWwobmV3IFRIUkVFLlZlY3RvcjMoKSk7XG5cbiAgICBmb3IgKHZhciBmID0gMDsgZiA8IDM7IGYrKykge1xuICAgICAgdmFyIHZlcnRleCA9IHBvbGFyVmVydGljZXNbX2kgKiAzICsgZl07XG5cbiAgICAgIGlmICh2ZXJ0ZXgudGhldGEgPT09IDAgJiYgKHZlcnRleC5waGkgPT09IDAgfHwgdmVydGV4LnBoaSA9PT0gTWF0aC5QSSkpIHtcbiAgICAgICAgdmFyIGFsaWduZWRWZXJ0aWNlID0gdmVydGV4LnBoaSA9PT0gMCA/IF9pICogMyArIDEgOiBfaSAqIDMgKyAwO1xuICAgICAgICB2ZXJ0ZXggPSB7XG4gICAgICAgICAgcjogdmVydGV4LnIsXG4gICAgICAgICAgcGhpOiB2ZXJ0ZXgucGhpLFxuICAgICAgICAgIHRoZXRhOiBwb2xhclZlcnRpY2VzW2FsaWduZWRWZXJ0aWNlXS50aGV0YVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodmVydGV4LnRoZXRhID09PSBNYXRoLlBJICYmIGNhcnRlc2lhbjJwb2xhcihub3JtYWwpLnRoZXRhIDwgTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgdmVydGV4LnRoZXRhID0gLU1hdGguUEk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW52YXNQb2ludCA9IHBvbGFyMmNhbnZhcyh2ZXJ0ZXgpO1xuICAgICAgdXZzLnB1c2goMSAtIGNhbnZhc1BvaW50LngsIDEgLSBjYW52YXNQb2ludC55KTtcbiAgICB9XG4gIH1cblxuICBpZiAoYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcy51dikgZGVsZXRlIGJ1ZmZlckdlb21ldHJ5LmF0dHJpYnV0ZXMudXY7XG4gIGJ1ZmZlckdlb21ldHJ5LnNldEF0dHJpYnV0ZShcInV2XCIsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuICBidWZmZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnV2Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgcmV0dXJuIGJ1ZmZlckdlb21ldHJ5O1xufVxuXG5mdW5jdGlvbiBjYXJ0ZXNpYW4ycG9sYXIocG9zaXRpb24pIHtcbiAgdmFyIHIgPSBNYXRoLnNxcnQocG9zaXRpb24ueCAqIHBvc2l0aW9uLnggKyBwb3NpdGlvbi56ICogcG9zaXRpb24ueiArIHBvc2l0aW9uLnkgKiBwb3NpdGlvbi55KTtcbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIHBoaTogTWF0aC5hY29zKHBvc2l0aW9uLnkgLyByKSxcbiAgICB0aGV0YTogTWF0aC5hdGFuMihwb3NpdGlvbi56LCBwb3NpdGlvbi54KVxuICB9O1xufVxuXG5mdW5jdGlvbiBwb2xhcjJjYW52YXMocG9sYXJQb2ludCkge1xuICByZXR1cm4ge1xuICAgIHk6IHBvbGFyUG9pbnQucGhpIC8gTWF0aC5QSSxcbiAgICB4OiAocG9sYXJQb2ludC50aGV0YSArIE1hdGguUEkpIC8gKDIgKiBNYXRoLlBJKVxuICB9O1xufSAvLyBBdXRob3I6IEFsZXggS2hvcm9zaHlsb3YgKGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vdXNlcnMvODc0MjI4Ny9hbGV4LWtob3Jvc2h5bG92KVxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjA3NzQ2NDgvdGhyZWUtanMtZ2VuZXJhdGUtdXYtY29vcmRpbmF0ZVxuXG5cbmZ1bmN0aW9uIGFwcGx5Qm94VVYoYnVmZmVyR2VvbWV0cnkpIHtcbiAgYnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gIHZhciBiYm94U2l6ZSA9IGJ1ZmZlckdlb21ldHJ5LmJvdW5kaW5nQm94LmdldFNpemUobmV3IFRIUkVFLlZlY3RvcjMoKSk7XG4gIHZhciBib3hTaXplID0gTWF0aC5taW4oYmJveFNpemUueCwgYmJveFNpemUueSwgYmJveFNpemUueik7XG4gIHZhciBib3hHZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShib3hTaXplLCBib3hTaXplLCBib3hTaXplKTtcbiAgdmFyIGN1YmUgPSBuZXcgVEhSRUUuTWVzaChib3hHZW9tZXRyeSk7XG4gIGN1YmUucm90YXRpb24uc2V0KDAsIDAsIDApO1xuICBjdWJlLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgdmFyIHRyYW5zZm9ybU1hdHJpeCA9IGN1YmUubWF0cml4LmNsb25lKCkuaW52ZXJ0KCk7XG4gIHZhciB1dkJib3ggPSBuZXcgVEhSRUUuQm94MyhuZXcgVEhSRUUuVmVjdG9yMygtYm94U2l6ZSAvIDIsIC1ib3hTaXplIC8gMiwgLWJveFNpemUgLyAyKSwgbmV3IFRIUkVFLlZlY3RvcjMoYm94U2l6ZSAvIDIsIGJveFNpemUgLyAyLCBib3hTaXplIC8gMikpO1xuXG4gIF9hcHBseUJveFVWKGJ1ZmZlckdlb21ldHJ5LCB0cmFuc2Zvcm1NYXRyaXgsIHV2QmJveCwgYm94U2l6ZSk7XG5cbiAgYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcy51di5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIHJldHVybiBidWZmZXJHZW9tZXRyeTtcbn1cblxuZnVuY3Rpb24gX2FwcGx5Qm94VVYoZ2VvbSwgdHJhbnNmb3JtTWF0cml4LCBiYm94LCBiYm94X21heF9zaXplKSB7XG4gIHZhciBjb29yZHMgPSBbXTtcbiAgY29vcmRzLmxlbmd0aCA9IDIgKiBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkubGVuZ3RoIC8gMzsgLy9tYXBzIDMgdmVydHMgb2YgMSBmYWNlIG9uIHRoZSBiZXR0ZXIgc2lkZSBvZiB0aGUgY3ViZVxuICAvL3NpZGUgb2YgdGhlIGN1YmUgY2FuIGJlIFhZLCBYWiBvciBZWlxuXG4gIHZhciBtYWtlVVZzID0gZnVuY3Rpb24gbWFrZVVWcyh2MCwgdjEsIHYyKSB7XG4gICAgLy9wcmUtcm90YXRlIHRoZSBtb2RlbCBzbyB0aGF0IGN1YmUgc2lkZXMgbWF0Y2ggd29ybGQgYXhpc1xuICAgIHYwLmFwcGx5TWF0cml4NCh0cmFuc2Zvcm1NYXRyaXgpO1xuICAgIHYxLmFwcGx5TWF0cml4NCh0cmFuc2Zvcm1NYXRyaXgpO1xuICAgIHYyLmFwcGx5TWF0cml4NCh0cmFuc2Zvcm1NYXRyaXgpOyAvL2dldCBub3JtYWwgb2YgdGhlIGZhY2UsIHRvIGtub3cgaW50byB3aGljaCBjdWJlIHNpZGUgaXQgbWFwcyBiZXR0ZXJcblxuICAgIHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBuLmNyb3NzVmVjdG9ycyh2MS5jbG9uZSgpLnN1Yih2MCksIHYxLmNsb25lKCkuc3ViKHYyKSkubm9ybWFsaXplKCk7XG4gICAgbi54ID0gTWF0aC5hYnMobi54KTtcbiAgICBuLnkgPSBNYXRoLmFicyhuLnkpO1xuICAgIG4ueiA9IE1hdGguYWJzKG4ueik7XG4gICAgdmFyIHV2MCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgdmFyIHV2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgdmFyIHV2MiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7IC8vIHh6IG1hcHBpbmdcblxuICAgIGlmIChuLnkgPiBuLnggJiYgbi55ID4gbi56KSB7XG4gICAgICB1djAueCA9ICh2MC54IC0gYmJveC5taW4ueCkgLyBiYm94X21heF9zaXplO1xuICAgICAgdXYwLnkgPSAoYmJveC5tYXgueiAtIHYwLnopIC8gYmJveF9tYXhfc2l6ZTtcbiAgICAgIHV2MS54ID0gKHYxLnggLSBiYm94Lm1pbi54KSAvIGJib3hfbWF4X3NpemU7XG4gICAgICB1djEueSA9IChiYm94Lm1heC56IC0gdjEueikgLyBiYm94X21heF9zaXplO1xuICAgICAgdXYyLnggPSAodjIueCAtIGJib3gubWluLngpIC8gYmJveF9tYXhfc2l6ZTtcbiAgICAgIHV2Mi55ID0gKGJib3gubWF4LnogLSB2Mi56KSAvIGJib3hfbWF4X3NpemU7XG4gICAgfSBlbHNlIGlmIChuLnggPiBuLnkgJiYgbi54ID4gbi56KSB7XG4gICAgICB1djAueCA9ICh2MC56IC0gYmJveC5taW4ueikgLyBiYm94X21heF9zaXplO1xuICAgICAgdXYwLnkgPSAodjAueSAtIGJib3gubWluLnkpIC8gYmJveF9tYXhfc2l6ZTtcbiAgICAgIHV2MS54ID0gKHYxLnogLSBiYm94Lm1pbi56KSAvIGJib3hfbWF4X3NpemU7XG4gICAgICB1djEueSA9ICh2MS55IC0gYmJveC5taW4ueSkgLyBiYm94X21heF9zaXplO1xuICAgICAgdXYyLnggPSAodjIueiAtIGJib3gubWluLnopIC8gYmJveF9tYXhfc2l6ZTtcbiAgICAgIHV2Mi55ID0gKHYyLnkgLSBiYm94Lm1pbi55KSAvIGJib3hfbWF4X3NpemU7XG4gICAgfSBlbHNlIGlmIChuLnogPiBuLnkgJiYgbi56ID4gbi54KSB7XG4gICAgICB1djAueCA9ICh2MC54IC0gYmJveC5taW4ueCkgLyBiYm94X21heF9zaXplO1xuICAgICAgdXYwLnkgPSAodjAueSAtIGJib3gubWluLnkpIC8gYmJveF9tYXhfc2l6ZTtcbiAgICAgIHV2MS54ID0gKHYxLnggLSBiYm94Lm1pbi54KSAvIGJib3hfbWF4X3NpemU7XG4gICAgICB1djEueSA9ICh2MS55IC0gYmJveC5taW4ueSkgLyBiYm94X21heF9zaXplO1xuICAgICAgdXYyLnggPSAodjIueCAtIGJib3gubWluLngpIC8gYmJveF9tYXhfc2l6ZTtcbiAgICAgIHV2Mi55ID0gKHYyLnkgLSBiYm94Lm1pbi55KSAvIGJib3hfbWF4X3NpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHV2MDogdXYwLFxuICAgICAgdXYxOiB1djEsXG4gICAgICB1djI6IHV2MlxuICAgIH07XG4gIH07XG5cbiAgaWYgKGdlb20uaW5kZXgpIHtcbiAgICAvLyBpcyBpdCBpbmRleGVkIGJ1ZmZlciBnZW9tZXRyeT9cbiAgICBmb3IgKHZhciB2aSA9IDA7IHZpIDwgZ2VvbS5pbmRleC5hcnJheS5sZW5ndGg7IHZpICs9IDMpIHtcbiAgICAgIHZhciBpZHgwID0gZ2VvbS5pbmRleC5hcnJheVt2aV07XG4gICAgICB2YXIgaWR4MSA9IGdlb20uaW5kZXguYXJyYXlbdmkgKyAxXTtcbiAgICAgIHZhciBpZHgyID0gZ2VvbS5pbmRleC5hcnJheVt2aSArIDJdO1xuICAgICAgdmFyIHZ4MCA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVszICogaWR4MF07XG4gICAgICB2YXIgdnkwID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5WzMgKiBpZHgwICsgMV07XG4gICAgICB2YXIgdnowID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5WzMgKiBpZHgwICsgMl07XG4gICAgICB2YXIgdngxID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5WzMgKiBpZHgxXTtcbiAgICAgIHZhciB2eTEgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbMyAqIGlkeDEgKyAxXTtcbiAgICAgIHZhciB2ejEgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbMyAqIGlkeDEgKyAyXTtcbiAgICAgIHZhciB2eDIgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbMyAqIGlkeDJdO1xuICAgICAgdmFyIHZ5MiA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVszICogaWR4MiArIDFdO1xuICAgICAgdmFyIHZ6MiA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVszICogaWR4MiArIDJdO1xuICAgICAgdmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjModngwLCB2eTAsIHZ6MCk7XG4gICAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyh2eDEsIHZ5MSwgdnoxKTtcbiAgICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKHZ4MiwgdnkyLCB2ejIpO1xuICAgICAgdmFyIHV2cyA9IG1ha2VVVnModjAsIHYxLCB2Mik7XG4gICAgICBjb29yZHNbMiAqIGlkeDBdID0gdXZzLnV2MC54O1xuICAgICAgY29vcmRzWzIgKiBpZHgwICsgMV0gPSB1dnMudXYwLnk7XG4gICAgICBjb29yZHNbMiAqIGlkeDFdID0gdXZzLnV2MS54O1xuICAgICAgY29vcmRzWzIgKiBpZHgxICsgMV0gPSB1dnMudXYxLnk7XG4gICAgICBjb29yZHNbMiAqIGlkeDJdID0gdXZzLnV2Mi54O1xuICAgICAgY29vcmRzWzIgKiBpZHgyICsgMV0gPSB1dnMudXYyLnk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIF92aSA9IDA7IF92aSA8IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheS5sZW5ndGg7IF92aSArPSA5KSB7XG4gICAgICB2YXIgX3Z4ID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W192aV07XG4gICAgICB2YXIgX3Z5ID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W192aSArIDFdO1xuICAgICAgdmFyIF92eiA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtfdmkgKyAyXTtcbiAgICAgIHZhciBfdngyID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W192aSArIDNdO1xuICAgICAgdmFyIF92eTIgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbX3ZpICsgNF07XG4gICAgICB2YXIgX3Z6MiA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtfdmkgKyA1XTtcbiAgICAgIHZhciBfdngzID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W192aSArIDZdO1xuICAgICAgdmFyIF92eTMgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbX3ZpICsgN107XG4gICAgICB2YXIgX3Z6MyA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtfdmkgKyA4XTtcblxuICAgICAgdmFyIF92ID0gbmV3IFRIUkVFLlZlY3RvcjMoX3Z4LCBfdnksIF92eik7XG5cbiAgICAgIHZhciBfdjIgPSBuZXcgVEhSRUUuVmVjdG9yMyhfdngyLCBfdnkyLCBfdnoyKTtcblxuICAgICAgdmFyIF92MyA9IG5ldyBUSFJFRS5WZWN0b3IzKF92eDMsIF92eTMsIF92ejMpO1xuXG4gICAgICB2YXIgX3V2cyA9IG1ha2VVVnMoX3YsIF92MiwgX3YzKTtcblxuICAgICAgdmFyIF9pZHggPSBfdmkgLyAzO1xuXG4gICAgICB2YXIgX2lkeDIgPSBfaWR4ICsgMTtcblxuICAgICAgdmFyIF9pZHgzID0gX2lkeCArIDI7XG5cbiAgICAgIGNvb3Jkc1syICogX2lkeF0gPSBfdXZzLnV2MC54O1xuICAgICAgY29vcmRzWzIgKiBfaWR4ICsgMV0gPSBfdXZzLnV2MC55O1xuICAgICAgY29vcmRzWzIgKiBfaWR4Ml0gPSBfdXZzLnV2MS54O1xuICAgICAgY29vcmRzWzIgKiBfaWR4MiArIDFdID0gX3V2cy51djEueTtcbiAgICAgIGNvb3Jkc1syICogX2lkeDNdID0gX3V2cy51djIueDtcbiAgICAgIGNvb3Jkc1syICogX2lkeDMgKyAxXSA9IF91dnMudXYyLnk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGdlb20uYXR0cmlidXRlcy51dikgZGVsZXRlIGdlb20uYXR0cmlidXRlcy51djtcbiAgZ2VvbS5zZXRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjb29yZHMsIDIpKTtcbn1cblxudmFyIGdlb21ldHJ5ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFJvdW5kZWRQbGFuZUdlb21ldHJ5OiBSb3VuZGVkUGxhbmVHZW9tZXRyeSxcbiAgYXBwbHlTcGhlcmVVVjogYXBwbHlTcGhlcmVVVixcbiAgYXBwbHlCb3hVVjogYXBwbHlCb3hVVlxufSk7XG5cbmV4cG9ydCB7IFJvdW5kZWRQbGFuZUdlb21ldHJ5IGFzIFIsIGFwcGx5U3BoZXJlVVYgYXMgYSwgYXBwbHlCb3hVViBhcyBiLCBnZW9tZXRyeSBhcyBnIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/geometry-982366ff.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/index-43782085.esm.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/index-43782085.esm.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   G: () => (/* binding */ Generator),\n/* harmony export */   a: () => (/* binding */ inSphere),\n/* harmony export */   b: () => (/* binding */ inCircle),\n/* harmony export */   c: () => (/* binding */ onCircle),\n/* harmony export */   d: () => (/* binding */ inRect),\n/* harmony export */   e: () => (/* binding */ onRect),\n/* harmony export */   f: () => (/* binding */ inBox),\n/* harmony export */   g: () => (/* binding */ onBox),\n/* harmony export */   i: () => (/* binding */ index),\n/* harmony export */   n: () => (/* binding */ noise),\n/* harmony export */   o: () => (/* binding */ onSphere)\n/* harmony export */ });\n/* harmony import */ var _objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objectSpread2-284232a6.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/objectSpread2-284232a6.esm.js\");\n/* harmony import */ var _classCallCheck_9098b006_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classCallCheck-9098b006.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/classCallCheck-9098b006.esm.js\");\n/* harmony import */ var _misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc-7d870b3c.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/misc-7d870b3c.esm.js\");\n\n\n\n\n/*\n * A speed-improved perlin and simplex noise algorithms for 2D.\n *\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n * Converted to Javascript by Joseph Gentle.\n *\n * Version 2012-03-09\n *\n * This code was placed in the public domain by its original author,\n * Stefan Gustavson. You may use it as you see fit, but\n * attribution is appreciated.\n *\n */\n\nvar Grad = function Grad(x, y, z) {\n  var _this = this;\n\n  (0,_classCallCheck_9098b006_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(this, Grad);\n\n  (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"dot2\", function (x, y) {\n    return _this.x * x + _this.y * y;\n  });\n\n  (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"dot3\", function (x, y, z) {\n    return _this.x * x + _this.y * y + _this.z * z;\n  });\n\n  this.x = x;\n  this.y = y;\n  this.z = z;\n};\n\nvar grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\nvar p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]; // To remove the need for index wrapping, double the permutation table length\n\nvar perm = new Array(512);\nvar gradP = new Array(512); // This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\n\nvar seed = function seed(_seed) {\n  if (_seed > 0 && _seed < 1) {\n    // Scale the seed out\n    _seed *= 65536;\n  }\n\n  _seed = Math.floor(_seed);\n\n  if (_seed < 256) {\n    _seed |= _seed << 8;\n  }\n\n  for (var i = 0; i < 256; i++) {\n    var v;\n\n    if (i & 1) {\n      v = p[i] ^ _seed & 255;\n    } else {\n      v = p[i] ^ _seed >> 8 & 255;\n    }\n\n    perm[i] = perm[i + 256] = v;\n    gradP[i] = gradP[i + 256] = grad3[v % 12];\n  }\n};\nseed(0);\n/*\n  for(var i=0; i<256; i++) {\n    perm[i] = perm[i + 256] = p[i];\n    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\n  }*/\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\n\nvar F2 = 0.5 * (Math.sqrt(3) - 1);\nvar G2 = (3 - Math.sqrt(3)) / 6;\nvar F3 = 1 / 3;\nvar G3 = 1 / 6; // 2D simplex noise\n\nvar simplex2 = function simplex2(xin, yin) {\n  var n0, n1, n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n\n  var s = (xin + yin) * F2; // Hairy factor for 2D\n\n  var i = Math.floor(xin + s);\n  var j = Math.floor(yin + s);\n  var t = (i + j) * G2;\n  var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\n  var y0 = yin - j + t; // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n\n  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\n  if (x0 > y0) {\n    // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n    i1 = 1;\n    j1 = 0;\n  } else {\n    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n    i1 = 0;\n    j1 = 1;\n  } // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n\n\n  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\n  var y1 = y0 - j1 + G2;\n  var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n\n  var y2 = y0 - 1 + 2 * G2; // Work out the hashed gradient indices of the three simplex corners\n\n  i &= 255;\n  j &= 255;\n  var gi0 = gradP[i + perm[j]];\n  var gi1 = gradP[i + i1 + perm[j + j1]];\n  var gi2 = gradP[i + 1 + perm[j + 1]]; // Calculate the contribution from the three corners\n\n  var t0 = 0.5 - x0 * x0 - y0 * y0;\n\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient\n  }\n\n  var t1 = 0.5 - x1 * x1 - y1 * y1;\n\n  if (t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot2(x1, y1);\n  }\n\n  var t2 = 0.5 - x2 * x2 - y2 * y2;\n\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot2(x2, y2);\n  } // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n\n\n  return 70 * (n0 + n1 + n2);\n}; // 3D simplex noise\n\nvar simplex3 = function simplex3(xin, yin, zin) {\n  var n0, n1, n2, n3; // Noise contributions from the four corners\n  // Skew the input space to determine which simplex cell we're in\n\n  var s = (xin + yin + zin) * F3; // Hairy factor for 2D\n\n  var i = Math.floor(xin + s);\n  var j = Math.floor(yin + s);\n  var k = Math.floor(zin + s);\n  var t = (i + j + k) * G3;\n  var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\n  var y0 = yin - j + t;\n  var z0 = zin - k + t; // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n  // Determine which simplex we are in.\n\n  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\n  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\n  if (x0 >= y0) {\n    if (y0 >= z0) {\n      i1 = 1;\n      j1 = 0;\n      k1 = 0;\n      i2 = 1;\n      j2 = 1;\n      k2 = 0;\n    } else if (x0 >= z0) {\n      i1 = 1;\n      j1 = 0;\n      k1 = 0;\n      i2 = 1;\n      j2 = 0;\n      k2 = 1;\n    } else {\n      i1 = 0;\n      j1 = 0;\n      k1 = 1;\n      i2 = 1;\n      j2 = 0;\n      k2 = 1;\n    }\n  } else {\n    if (y0 < z0) {\n      i1 = 0;\n      j1 = 0;\n      k1 = 1;\n      i2 = 0;\n      j2 = 1;\n      k2 = 1;\n    } else if (x0 < z0) {\n      i1 = 0;\n      j1 = 1;\n      k1 = 0;\n      i2 = 0;\n      j2 = 1;\n      k2 = 1;\n    } else {\n      i1 = 0;\n      j1 = 1;\n      k1 = 0;\n      i2 = 1;\n      j2 = 1;\n      k2 = 0;\n    }\n  } // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n  // c = 1/6.\n\n\n  var x1 = x0 - i1 + G3; // Offsets for second corner\n\n  var y1 = y0 - j1 + G3;\n  var z1 = z0 - k1 + G3;\n  var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n\n  var y2 = y0 - j2 + 2 * G3;\n  var z2 = z0 - k2 + 2 * G3;\n  var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n\n  var y3 = y0 - 1 + 3 * G3;\n  var z3 = z0 - 1 + 3 * G3; // Work out the hashed gradient indices of the four simplex corners\n\n  i &= 255;\n  j &= 255;\n  k &= 255;\n  var gi0 = gradP[i + perm[j + perm[k]]];\n  var gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];\n  var gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];\n  var gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]]; // Calculate the contribution from the four corners\n\n  var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot3(x0, y0, z0); // (x,y) of grad3 used for 2D gradient\n  }\n\n  var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n\n  if (t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n  }\n\n  var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n  }\n\n  var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n\n  if (t3 < 0) {\n    n3 = 0;\n  } else {\n    t3 *= t3;\n    n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n  } // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n\n\n  return 32 * (n0 + n1 + n2 + n3);\n}; // ##### Perlin noise stuff\n// 2D Perlin Noise\n\nvar perlin2 = function perlin2(x, y) {\n  // Find unit grid cell containing point\n  var X = Math.floor(x),\n      Y = Math.floor(y); // Get relative xy coordinates of point within that cell\n\n  x = x - X;\n  y = y - Y; // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n\n  X = X & 255;\n  Y = Y & 255; // Calculate noise contributions from each of the four corners\n\n  var n00 = gradP[X + perm[Y]].dot2(x, y);\n  var n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);\n  var n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);\n  var n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1); // Compute the fade curve value for x\n\n  var u = (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(x); // Interpolate the four results\n\n  return (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)((0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(n00, n10, u), (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(n01, n11, u), (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(y));\n}; // 3D Perlin Noise\n\nvar perlin3 = function perlin3(x, y, z) {\n  // Find unit grid cell containing point\n  var X = Math.floor(x),\n      Y = Math.floor(y),\n      Z = Math.floor(z); // Get relative xyz coordinates of point within that cell\n\n  x = x - X;\n  y = y - Y;\n  z = z - Z; // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n\n  X = X & 255;\n  Y = Y & 255;\n  Z = Z & 255; // Calculate noise contributions from each of the eight corners\n\n  var n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);\n  var n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);\n  var n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);\n  var n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);\n  var n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);\n  var n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);\n  var n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);\n  var n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(x - 1, y - 1, z - 1); // Compute the fade curve value for x, y, z\n\n  var u = (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(x);\n  var v = (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(y);\n  var w = (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(z); // Interpolate\n\n  return (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)((0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)((0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(n000, n100, u), (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(n001, n101, u), w), (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)((0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(n010, n110, u), (0,_misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_2__.l)(n011, n111, u), w), v);\n};\n\nvar noise = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  seed: seed,\n  simplex2: simplex2,\n  simplex3: simplex3,\n  perlin2: perlin2,\n  perlin3: perlin3\n});\n\nvar TAU = Math.PI * 2; // Credits @kchapelier https://github.com/kchapelier/wavefunctioncollapse/blob/master/example/lcg.js#L22-L30\n\nfunction normalizeSeed(seed) {\n  if (typeof seed === \"number\") {\n    seed = Math.abs(seed);\n  } else if (typeof seed === \"string\") {\n    var string = seed;\n    seed = 0;\n\n    for (var i = 0; i < string.length; i++) {\n      seed = (seed + (i + 1) * (string.charCodeAt(i) % 96)) % 2147483647;\n    }\n  }\n\n  if (seed === 0) {\n    seed = 311;\n  }\n\n  return seed;\n}\n\nfunction lcgRandom(seed) {\n  var state = normalizeSeed(seed);\n  return function () {\n    var result = state * 48271 % 2147483647;\n    state = result;\n    return result / 2147483647;\n  };\n}\n\nvar Generator = function Generator(_seed) {\n  var _this = this;\n\n  (0,_classCallCheck_9098b006_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(this, Generator);\n\n  (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"seed\", 0);\n\n  (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"init\", function (seed) {\n    _this.seed = seed;\n    _this.value = lcgRandom(seed);\n  });\n\n  (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"value\", lcgRandom(this.seed));\n\n  this.init(_seed);\n};\nvar defaultGen = new Generator(Math.random());\n/***\n * [3D] Sphere\n */\n\nvar defaultSphere = {\n  radius: 1,\n  center: [0, 0, 0]\n}; // random on surface of sphere\n// - https://twitter.com/fermatslibrary/status/1430932503578226688\n// - https://mathworld.wolfram.com/SpherePointPicking.html\n\nfunction onSphere(buffer, sphere) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultSphere$sphere = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultSphere), sphere),\n      radius = _defaultSphere$sphere.radius,\n      center = _defaultSphere$sphere.center;\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    var u = rng.value();\n    var v = rng.value();\n    var theta = Math.acos(2 * v - 1);\n    var phi = TAU * u;\n    buffer[i] = Math.sin(theta) * Math.cos(phi) * radius + center[0];\n    buffer[i + 1] = Math.sin(theta) * Math.sin(phi) * radius + center[1];\n    buffer[i + 2] = Math.cos(theta) * radius + center[2];\n  }\n\n  return buffer;\n} // from \"Another Method\" https://datagenetics.com/blog/january32020/index.html\n\nfunction inSphere(buffer, sphere) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultSphere$sphere2 = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultSphere), sphere),\n      radius = _defaultSphere$sphere2.radius,\n      center = _defaultSphere$sphere2.center;\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    var u = Math.pow(rng.value(), 1 / 3);\n    var x = rng.value() * 2 - 1;\n    var y = rng.value() * 2 - 1;\n    var z = rng.value() * 2 - 1;\n    var mag = Math.sqrt(x * x + y * y + z * z);\n    x = u * x / mag;\n    y = u * y / mag;\n    z = u * z / mag;\n    buffer[i] = x * radius + center[0];\n    buffer[i + 1] = y * radius + center[1];\n    buffer[i + 2] = z * radius + center[2];\n  }\n\n  return buffer;\n}\n/***\n * [2D] Circle\n */\n\nvar defaultCircle = {\n  radius: 1,\n  center: [0, 0]\n}; // random circle https://stackoverflow.com/a/50746409\n\nfunction inCircle(buffer, circle) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultCircle$circle = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultCircle), circle),\n      radius = _defaultCircle$circle.radius,\n      center = _defaultCircle$circle.center;\n\n  for (var i = 0; i < buffer.length; i += 2) {\n    var r = radius * Math.sqrt(rng.value());\n    var theta = rng.value() * TAU;\n    buffer[i] = Math.sin(theta) * r + center[0];\n    buffer[i + 1] = Math.cos(theta) * r + center[1];\n  }\n\n  return buffer;\n}\nfunction onCircle(buffer, circle) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultCircle$circle2 = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultCircle), circle),\n      radius = _defaultCircle$circle2.radius,\n      center = _defaultCircle$circle2.center;\n\n  for (var i = 0; i < buffer.length; i += 2) {\n    var theta = rng.value() * TAU;\n    buffer[i] = Math.sin(theta) * radius + center[0];\n    buffer[i + 1] = Math.cos(theta) * radius + center[1];\n  }\n\n  return buffer;\n}\n/**\n * [2D] Plane\n */\n\nvar defaultRect = {\n  sides: 1,\n  center: [0, 0]\n};\nfunction inRect(buffer, rect) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultRect$rect = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultRect), rect),\n      sides = _defaultRect$rect.sides,\n      center = _defaultRect$rect.center;\n\n  var sideX = typeof sides === \"number\" ? sides : sides[0];\n  var sideY = typeof sides === \"number\" ? sides : sides[1];\n\n  for (var i = 0; i < buffer.length; i += 2) {\n    buffer[i] = (rng.value() - 0.5) * sideX + center[0];\n    buffer[i + 1] = (rng.value() - 0.5) * sideY + center[1];\n  }\n\n  return buffer;\n}\nfunction onRect(buffer, rect) {\n  return buffer;\n}\n/***\n * [3D] Box\n */\n\nfunction inBox(buffer, box) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultBox$box = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultBox), box),\n      sides = _defaultBox$box.sides,\n      center = _defaultBox$box.center;\n\n  var sideX = typeof sides === \"number\" ? sides : sides[0];\n  var sideY = typeof sides === \"number\" ? sides : sides[1];\n  var sideZ = typeof sides === \"number\" ? sides : sides[2];\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    buffer[i] = (rng.value() - 0.5) * sideX + center[0];\n    buffer[i + 1] = (rng.value() - 0.5) * sideY + center[1];\n    buffer[i + 2] = (rng.value() - 0.5) * sideZ + center[2];\n  }\n\n  return buffer;\n}\nvar defaultBox = {\n  sides: 1,\n  center: [0, 0, 0]\n};\nfunction onBox(buffer, box) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultBox$box2 = (0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultBox), box),\n      sides = _defaultBox$box2.sides,\n      center = _defaultBox$box2.center;\n\n  var sideX = typeof sides === \"number\" ? sides : sides[0];\n  var sideY = typeof sides === \"number\" ? sides : sides[1];\n  var sideZ = typeof sides === \"number\" ? sides : sides[2];\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    buffer[i] = (rng.value() - 0.5) * sideX + center[0];\n    buffer[i + 1] = (rng.value() - 0.5) * sideY + center[1];\n    buffer[i + 2] = (rng.value() - 0.5) * sideZ + center[2];\n  }\n\n  return buffer;\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Generator: Generator,\n  onSphere: onSphere,\n  inSphere: inSphere,\n  inCircle: inCircle,\n  onCircle: onCircle,\n  inRect: inRect,\n  onRect: onRect,\n  inBox: inBox,\n  onBox: onBox,\n  noise: noise\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvaW5kZXgtNDM3ODIwODUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRGO0FBQ3BCO0FBQ1Y7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUUsa0VBQWU7O0FBRWpCLEVBQUUsaUVBQWU7QUFDakI7QUFDQSxHQUFHOztBQUVILEVBQUUsaUVBQWU7QUFDakI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNHBDQUE0cEM7O0FBRTVwQztBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEIsd0JBQXdCO0FBQ3hCOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBLHlCQUF5Qjs7QUFFekI7QUFDQSw0QkFBNEI7O0FBRTVCLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFK0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvaW5kZXgtNDM3ODIwODUuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGEgYXMgX2RlZmluZVByb3BlcnR5LCBfIGFzIF9vYmplY3RTcHJlYWQyIH0gZnJvbSAnLi9vYmplY3RTcHJlYWQyLTI4NDIzMmE2LmVzbS5qcyc7XG5pbXBvcnQgeyBfIGFzIF9jbGFzc0NhbGxDaGVjayB9IGZyb20gJy4vY2xhc3NDYWxsQ2hlY2stOTA5OGIwMDYuZXNtLmpzJztcbmltcG9ydCB7IGwgYXMgbGVycCwgZiBhcyBmYWRlIH0gZnJvbSAnLi9taXNjLTdkODcwYjNjLmVzbS5qcyc7XG5cbi8qXG4gKiBBIHNwZWVkLWltcHJvdmVkIHBlcmxpbiBhbmQgc2ltcGxleCBub2lzZSBhbGdvcml0aG1zIGZvciAyRC5cbiAqXG4gKiBCYXNlZCBvbiBleGFtcGxlIGNvZGUgYnkgU3RlZmFuIEd1c3RhdnNvbiAoc3RlZ3VAaXRuLmxpdS5zZSkuXG4gKiBPcHRpbWlzYXRpb25zIGJ5IFBldGVyIEVhc3RtYW4gKHBlYXN0bWFuQGRyaXp6bGUuc3RhbmZvcmQuZWR1KS5cbiAqIEJldHRlciByYW5rIG9yZGVyaW5nIG1ldGhvZCBieSBTdGVmYW4gR3VzdGF2c29uIGluIDIwMTIuXG4gKiBDb252ZXJ0ZWQgdG8gSmF2YXNjcmlwdCBieSBKb3NlcGggR2VudGxlLlxuICpcbiAqIFZlcnNpb24gMjAxMi0wMy0wOVxuICpcbiAqIFRoaXMgY29kZSB3YXMgcGxhY2VkIGluIHRoZSBwdWJsaWMgZG9tYWluIGJ5IGl0cyBvcmlnaW5hbCBhdXRob3IsXG4gKiBTdGVmYW4gR3VzdGF2c29uLiBZb3UgbWF5IHVzZSBpdCBhcyB5b3Ugc2VlIGZpdCwgYnV0XG4gKiBhdHRyaWJ1dGlvbiBpcyBhcHByZWNpYXRlZC5cbiAqXG4gKi9cblxudmFyIEdyYWQgPSBmdW5jdGlvbiBHcmFkKHgsIHksIHopIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JhZCk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZG90MlwiLCBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiBfdGhpcy54ICogeCArIF90aGlzLnkgKiB5O1xuICB9KTtcblxuICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb3QzXCIsIGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgcmV0dXJuIF90aGlzLnggKiB4ICsgX3RoaXMueSAqIHkgKyBfdGhpcy56ICogejtcbiAgfSk7XG5cbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbiAgdGhpcy56ID0gejtcbn07XG5cbnZhciBncmFkMyA9IFtuZXcgR3JhZCgxLCAxLCAwKSwgbmV3IEdyYWQoLTEsIDEsIDApLCBuZXcgR3JhZCgxLCAtMSwgMCksIG5ldyBHcmFkKC0xLCAtMSwgMCksIG5ldyBHcmFkKDEsIDAsIDEpLCBuZXcgR3JhZCgtMSwgMCwgMSksIG5ldyBHcmFkKDEsIDAsIC0xKSwgbmV3IEdyYWQoLTEsIDAsIC0xKSwgbmV3IEdyYWQoMCwgMSwgMSksIG5ldyBHcmFkKDAsIC0xLCAxKSwgbmV3IEdyYWQoMCwgMSwgLTEpLCBuZXcgR3JhZCgwLCAtMSwgLTEpXTtcbnZhciBwID0gWzE1MSwgMTYwLCAxMzcsIDkxLCA5MCwgMTUsIDEzMSwgMTMsIDIwMSwgOTUsIDk2LCA1MywgMTk0LCAyMzMsIDcsIDIyNSwgMTQwLCAzNiwgMTAzLCAzMCwgNjksIDE0MiwgOCwgOTksIDM3LCAyNDAsIDIxLCAxMCwgMjMsIDE5MCwgNiwgMTQ4LCAyNDcsIDEyMCwgMjM0LCA3NSwgMCwgMjYsIDE5NywgNjIsIDk0LCAyNTIsIDIxOSwgMjAzLCAxMTcsIDM1LCAxMSwgMzIsIDU3LCAxNzcsIDMzLCA4OCwgMjM3LCAxNDksIDU2LCA4NywgMTc0LCAyMCwgMTI1LCAxMzYsIDE3MSwgMTY4LCA2OCwgMTc1LCA3NCwgMTY1LCA3MSwgMTM0LCAxMzksIDQ4LCAyNywgMTY2LCA3NywgMTQ2LCAxNTgsIDIzMSwgODMsIDExMSwgMjI5LCAxMjIsIDYwLCAyMTEsIDEzMywgMjMwLCAyMjAsIDEwNSwgOTIsIDQxLCA1NSwgNDYsIDI0NSwgNDAsIDI0NCwgMTAyLCAxNDMsIDU0LCA2NSwgMjUsIDYzLCAxNjEsIDEsIDIxNiwgODAsIDczLCAyMDksIDc2LCAxMzIsIDE4NywgMjA4LCA4OSwgMTgsIDE2OSwgMjAwLCAxOTYsIDEzNSwgMTMwLCAxMTYsIDE4OCwgMTU5LCA4NiwgMTY0LCAxMDAsIDEwOSwgMTk4LCAxNzMsIDE4NiwgMywgNjQsIDUyLCAyMTcsIDIyNiwgMjUwLCAxMjQsIDEyMywgNSwgMjAyLCAzOCwgMTQ3LCAxMTgsIDEyNiwgMjU1LCA4MiwgODUsIDIxMiwgMjA3LCAyMDYsIDU5LCAyMjcsIDQ3LCAxNiwgNTgsIDE3LCAxODIsIDE4OSwgMjgsIDQyLCAyMjMsIDE4MywgMTcwLCAyMTMsIDExOSwgMjQ4LCAxNTIsIDIsIDQ0LCAxNTQsIDE2MywgNzAsIDIyMSwgMTUzLCAxMDEsIDE1NSwgMTY3LCA0MywgMTcyLCA5LCAxMjksIDIyLCAzOSwgMjUzLCAxOSwgOTgsIDEwOCwgMTEwLCA3OSwgMTEzLCAyMjQsIDIzMiwgMTc4LCAxODUsIDExMiwgMTA0LCAyMTgsIDI0NiwgOTcsIDIyOCwgMjUxLCAzNCwgMjQyLCAxOTMsIDIzOCwgMjEwLCAxNDQsIDEyLCAxOTEsIDE3OSwgMTYyLCAyNDEsIDgxLCA1MSwgMTQ1LCAyMzUsIDI0OSwgMTQsIDIzOSwgMTA3LCA0OSwgMTkyLCAyMTQsIDMxLCAxODEsIDE5OSwgMTA2LCAxNTcsIDE4NCwgODQsIDIwNCwgMTc2LCAxMTUsIDEyMSwgNTAsIDQ1LCAxMjcsIDQsIDE1MCwgMjU0LCAxMzgsIDIzNiwgMjA1LCA5MywgMjIyLCAxMTQsIDY3LCAyOSwgMjQsIDcyLCAyNDMsIDE0MSwgMTI4LCAxOTUsIDc4LCA2NiwgMjE1LCA2MSwgMTU2LCAxODBdOyAvLyBUbyByZW1vdmUgdGhlIG5lZWQgZm9yIGluZGV4IHdyYXBwaW5nLCBkb3VibGUgdGhlIHBlcm11dGF0aW9uIHRhYmxlIGxlbmd0aFxuXG52YXIgcGVybSA9IG5ldyBBcnJheSg1MTIpO1xudmFyIGdyYWRQID0gbmV3IEFycmF5KDUxMik7IC8vIFRoaXMgaXNuJ3QgYSB2ZXJ5IGdvb2Qgc2VlZGluZyBmdW5jdGlvbiwgYnV0IGl0IHdvcmtzIG9rLiBJdCBzdXBwb3J0cyAyXjE2XG4vLyBkaWZmZXJlbnQgc2VlZCB2YWx1ZXMuIFdyaXRlIHNvbWV0aGluZyBiZXR0ZXIgaWYgeW91IG5lZWQgbW9yZSBzZWVkcy5cblxudmFyIHNlZWQgPSBmdW5jdGlvbiBzZWVkKF9zZWVkKSB7XG4gIGlmIChfc2VlZCA+IDAgJiYgX3NlZWQgPCAxKSB7XG4gICAgLy8gU2NhbGUgdGhlIHNlZWQgb3V0XG4gICAgX3NlZWQgKj0gNjU1MzY7XG4gIH1cblxuICBfc2VlZCA9IE1hdGguZmxvb3IoX3NlZWQpO1xuXG4gIGlmIChfc2VlZCA8IDI1Nikge1xuICAgIF9zZWVkIHw9IF9zZWVkIDw8IDg7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgdmFyIHY7XG5cbiAgICBpZiAoaSAmIDEpIHtcbiAgICAgIHYgPSBwW2ldIF4gX3NlZWQgJiAyNTU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHYgPSBwW2ldIF4gX3NlZWQgPj4gOCAmIDI1NTtcbiAgICB9XG5cbiAgICBwZXJtW2ldID0gcGVybVtpICsgMjU2XSA9IHY7XG4gICAgZ3JhZFBbaV0gPSBncmFkUFtpICsgMjU2XSA9IGdyYWQzW3YgJSAxMl07XG4gIH1cbn07XG5zZWVkKDApO1xuLypcbiAgZm9yKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgICBwZXJtW2ldID0gcGVybVtpICsgMjU2XSA9IHBbaV07XG4gICAgZ3JhZFBbaV0gPSBncmFkUFtpICsgMjU2XSA9IGdyYWQzW3Blcm1baV0gJSAxMl07XG4gIH0qL1xuLy8gU2tld2luZyBhbmQgdW5za2V3aW5nIGZhY3RvcnMgZm9yIDIsIDMsIGFuZCA0IGRpbWVuc2lvbnNcblxudmFyIEYyID0gMC41ICogKE1hdGguc3FydCgzKSAtIDEpO1xudmFyIEcyID0gKDMgLSBNYXRoLnNxcnQoMykpIC8gNjtcbnZhciBGMyA9IDEgLyAzO1xudmFyIEczID0gMSAvIDY7IC8vIDJEIHNpbXBsZXggbm9pc2VcblxudmFyIHNpbXBsZXgyID0gZnVuY3Rpb24gc2ltcGxleDIoeGluLCB5aW4pIHtcbiAgdmFyIG4wLCBuMSwgbjI7IC8vIE5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgdGhyZWUgY29ybmVyc1xuICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG5cbiAgdmFyIHMgPSAoeGluICsgeWluKSAqIEYyOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXG5cbiAgdmFyIGkgPSBNYXRoLmZsb29yKHhpbiArIHMpO1xuICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XG4gIHZhciB0ID0gKGkgKyBqKSAqIEcyO1xuICB2YXIgeDAgPSB4aW4gLSBpICsgdDsgLy8gVGhlIHgseSBkaXN0YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW4sIHVuc2tld2VkLlxuXG4gIHZhciB5MCA9IHlpbiAtIGogKyB0OyAvLyBGb3IgdGhlIDJEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlLlxuICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXG5cbiAgdmFyIGkxLCBqMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIChtaWRkbGUpIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGopIGNvb3Jkc1xuXG4gIGlmICh4MCA+IHkwKSB7XG4gICAgLy8gbG93ZXIgdHJpYW5nbGUsIFhZIG9yZGVyOiAoMCwwKS0+KDEsMCktPigxLDEpXG4gICAgaTEgPSAxO1xuICAgIGoxID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cHBlciB0cmlhbmdsZSwgWVggb3JkZXI6ICgwLDApLT4oMCwxKS0+KDEsMSlcbiAgICBpMSA9IDA7XG4gICAgajEgPSAxO1xuICB9IC8vIEEgc3RlcCBvZiAoMSwwKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYykgaW4gKHgseSksIGFuZFxuICAvLyBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMpIGluICh4LHkpLCB3aGVyZVxuICAvLyBjID0gKDMtc3FydCgzKSkvNlxuXG5cbiAgdmFyIHgxID0geDAgLSBpMSArIEcyOyAvLyBPZmZzZXRzIGZvciBtaWRkbGUgY29ybmVyIGluICh4LHkpIHVuc2tld2VkIGNvb3Jkc1xuXG4gIHZhciB5MSA9IHkwIC0gajEgKyBHMjtcbiAgdmFyIHgyID0geDAgLSAxICsgMiAqIEcyOyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcblxuICB2YXIgeTIgPSB5MCAtIDEgKyAyICogRzI7IC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgdGhyZWUgc2ltcGxleCBjb3JuZXJzXG5cbiAgaSAmPSAyNTU7XG4gIGogJj0gMjU1O1xuICB2YXIgZ2kwID0gZ3JhZFBbaSArIHBlcm1bal1dO1xuICB2YXIgZ2kxID0gZ3JhZFBbaSArIGkxICsgcGVybVtqICsgajFdXTtcbiAgdmFyIGdpMiA9IGdyYWRQW2kgKyAxICsgcGVybVtqICsgMV1dOyAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXG5cbiAgdmFyIHQwID0gMC41IC0geDAgKiB4MCAtIHkwICogeTA7XG5cbiAgaWYgKHQwIDwgMCkge1xuICAgIG4wID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MCAqPSB0MDtcbiAgICBuMCA9IHQwICogdDAgKiBnaTAuZG90Mih4MCwgeTApOyAvLyAoeCx5KSBvZiBncmFkMyB1c2VkIGZvciAyRCBncmFkaWVudFxuICB9XG5cbiAgdmFyIHQxID0gMC41IC0geDEgKiB4MSAtIHkxICogeTE7XG5cbiAgaWYgKHQxIDwgMCkge1xuICAgIG4xID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MSAqPSB0MTtcbiAgICBuMSA9IHQxICogdDEgKiBnaTEuZG90Mih4MSwgeTEpO1xuICB9XG5cbiAgdmFyIHQyID0gMC41IC0geDIgKiB4MiAtIHkyICogeTI7XG5cbiAgaWYgKHQyIDwgMCkge1xuICAgIG4yID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MiAqPSB0MjtcbiAgICBuMiA9IHQyICogdDIgKiBnaTIuZG90Mih4MiwgeTIpO1xuICB9IC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgaW50ZXJ2YWwgWy0xLDFdLlxuXG5cbiAgcmV0dXJuIDcwICogKG4wICsgbjEgKyBuMik7XG59OyAvLyAzRCBzaW1wbGV4IG5vaXNlXG5cbnZhciBzaW1wbGV4MyA9IGZ1bmN0aW9uIHNpbXBsZXgzKHhpbiwgeWluLCB6aW4pIHtcbiAgdmFyIG4wLCBuMSwgbjIsIG4zOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIGZvdXIgY29ybmVyc1xuICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG5cbiAgdmFyIHMgPSAoeGluICsgeWluICsgemluKSAqIEYzOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXG5cbiAgdmFyIGkgPSBNYXRoLmZsb29yKHhpbiArIHMpO1xuICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XG4gIHZhciBrID0gTWF0aC5mbG9vcih6aW4gKyBzKTtcbiAgdmFyIHQgPSAoaSArIGogKyBrKSAqIEczO1xuICB2YXIgeDAgPSB4aW4gLSBpICsgdDsgLy8gVGhlIHgseSBkaXN0YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW4sIHVuc2tld2VkLlxuXG4gIHZhciB5MCA9IHlpbiAtIGogKyB0O1xuICB2YXIgejAgPSB6aW4gLSBrICsgdDsgLy8gRm9yIHRoZSAzRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhIHNsaWdodGx5IGlycmVndWxhciB0ZXRyYWhlZHJvbi5cbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLlxuXG4gIHZhciBpMSwgajEsIGsxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcblxuICB2YXIgaTIsIGoyLCBrMjsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcblxuICBpZiAoeDAgPj0geTApIHtcbiAgICBpZiAoeTAgPj0gejApIHtcbiAgICAgIGkxID0gMTtcbiAgICAgIGoxID0gMDtcbiAgICAgIGsxID0gMDtcbiAgICAgIGkyID0gMTtcbiAgICAgIGoyID0gMTtcbiAgICAgIGsyID0gMDtcbiAgICB9IGVsc2UgaWYgKHgwID49IHowKSB7XG4gICAgICBpMSA9IDE7XG4gICAgICBqMSA9IDA7XG4gICAgICBrMSA9IDA7XG4gICAgICBpMiA9IDE7XG4gICAgICBqMiA9IDA7XG4gICAgICBrMiA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkxID0gMDtcbiAgICAgIGoxID0gMDtcbiAgICAgIGsxID0gMTtcbiAgICAgIGkyID0gMTtcbiAgICAgIGoyID0gMDtcbiAgICAgIGsyID0gMTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHkwIDwgejApIHtcbiAgICAgIGkxID0gMDtcbiAgICAgIGoxID0gMDtcbiAgICAgIGsxID0gMTtcbiAgICAgIGkyID0gMDtcbiAgICAgIGoyID0gMTtcbiAgICAgIGsyID0gMTtcbiAgICB9IGVsc2UgaWYgKHgwIDwgejApIHtcbiAgICAgIGkxID0gMDtcbiAgICAgIGoxID0gMTtcbiAgICAgIGsxID0gMDtcbiAgICAgIGkyID0gMDtcbiAgICAgIGoyID0gMTtcbiAgICAgIGsyID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaTEgPSAwO1xuICAgICAgajEgPSAxO1xuICAgICAgazEgPSAwO1xuICAgICAgaTIgPSAxO1xuICAgICAgajIgPSAxO1xuICAgICAgazIgPSAwO1xuICAgIH1cbiAgfSAvLyBBIHN0ZXAgb2YgKDEsMCwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jLC1jKSBpbiAoeCx5LHopLFxuICAvLyBhIHN0ZXAgb2YgKDAsMSwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jLC1jKSBpbiAoeCx5LHopLCBhbmRcbiAgLy8gYSBzdGVwIG9mICgwLDAsMSkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKC1jLC1jLDEtYykgaW4gKHgseSx6KSwgd2hlcmVcbiAgLy8gYyA9IDEvNi5cblxuXG4gIHZhciB4MSA9IHgwIC0gaTEgKyBHMzsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lclxuXG4gIHZhciB5MSA9IHkwIC0gajEgKyBHMztcbiAgdmFyIHoxID0gejAgLSBrMSArIEczO1xuICB2YXIgeDIgPSB4MCAtIGkyICsgMiAqIEczOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXJcblxuICB2YXIgeTIgPSB5MCAtIGoyICsgMiAqIEczO1xuICB2YXIgejIgPSB6MCAtIGsyICsgMiAqIEczO1xuICB2YXIgeDMgPSB4MCAtIDEgKyAzICogRzM7IC8vIE9mZnNldHMgZm9yIGZvdXJ0aCBjb3JuZXJcblxuICB2YXIgeTMgPSB5MCAtIDEgKyAzICogRzM7XG4gIHZhciB6MyA9IHowIC0gMSArIDMgKiBHMzsgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmb3VyIHNpbXBsZXggY29ybmVyc1xuXG4gIGkgJj0gMjU1O1xuICBqICY9IDI1NTtcbiAgayAmPSAyNTU7XG4gIHZhciBnaTAgPSBncmFkUFtpICsgcGVybVtqICsgcGVybVtrXV1dO1xuICB2YXIgZ2kxID0gZ3JhZFBbaSArIGkxICsgcGVybVtqICsgajEgKyBwZXJtW2sgKyBrMV1dXTtcbiAgdmFyIGdpMiA9IGdyYWRQW2kgKyBpMiArIHBlcm1baiArIGoyICsgcGVybVtrICsgazJdXV07XG4gIHZhciBnaTMgPSBncmFkUFtpICsgMSArIHBlcm1baiArIDEgKyBwZXJtW2sgKyAxXV1dOyAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBmb3VyIGNvcm5lcnNcblxuICB2YXIgdDAgPSAwLjYgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejA7XG5cbiAgaWYgKHQwIDwgMCkge1xuICAgIG4wID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MCAqPSB0MDtcbiAgICBuMCA9IHQwICogdDAgKiBnaTAuZG90Myh4MCwgeTAsIHowKTsgLy8gKHgseSkgb2YgZ3JhZDMgdXNlZCBmb3IgMkQgZ3JhZGllbnRcbiAgfVxuXG4gIHZhciB0MSA9IDAuNiAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MTtcblxuICBpZiAodDEgPCAwKSB7XG4gICAgbjEgPSAwO1xuICB9IGVsc2Uge1xuICAgIHQxICo9IHQxO1xuICAgIG4xID0gdDEgKiB0MSAqIGdpMS5kb3QzKHgxLCB5MSwgejEpO1xuICB9XG5cbiAgdmFyIHQyID0gMC42IC0geDIgKiB4MiAtIHkyICogeTIgLSB6MiAqIHoyO1xuXG4gIGlmICh0MiA8IDApIHtcbiAgICBuMiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdDIgKj0gdDI7XG4gICAgbjIgPSB0MiAqIHQyICogZ2kyLmRvdDMoeDIsIHkyLCB6Mik7XG4gIH1cblxuICB2YXIgdDMgPSAwLjYgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejM7XG5cbiAgaWYgKHQzIDwgMCkge1xuICAgIG4zID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0MyAqPSB0MztcbiAgICBuMyA9IHQzICogdDMgKiBnaTMuZG90Myh4MywgeTMsIHozKTtcbiAgfSAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuXG4gIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHJldHVybiB2YWx1ZXMgaW4gdGhlIGludGVydmFsIFstMSwxXS5cblxuXG4gIHJldHVybiAzMiAqIChuMCArIG4xICsgbjIgKyBuMyk7XG59OyAvLyAjIyMjIyBQZXJsaW4gbm9pc2Ugc3R1ZmZcbi8vIDJEIFBlcmxpbiBOb2lzZVxuXG52YXIgcGVybGluMiA9IGZ1bmN0aW9uIHBlcmxpbjIoeCwgeSkge1xuICAvLyBGaW5kIHVuaXQgZ3JpZCBjZWxsIGNvbnRhaW5pbmcgcG9pbnRcbiAgdmFyIFggPSBNYXRoLmZsb29yKHgpLFxuICAgICAgWSA9IE1hdGguZmxvb3IoeSk7IC8vIEdldCByZWxhdGl2ZSB4eSBjb29yZGluYXRlcyBvZiBwb2ludCB3aXRoaW4gdGhhdCBjZWxsXG5cbiAgeCA9IHggLSBYO1xuICB5ID0geSAtIFk7IC8vIFdyYXAgdGhlIGludGVnZXIgY2VsbHMgYXQgMjU1IChzbWFsbGVyIGludGVnZXIgcGVyaW9kIGNhbiBiZSBpbnRyb2R1Y2VkIGhlcmUpXG5cbiAgWCA9IFggJiAyNTU7XG4gIFkgPSBZICYgMjU1OyAvLyBDYWxjdWxhdGUgbm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggb2YgdGhlIGZvdXIgY29ybmVyc1xuXG4gIHZhciBuMDAgPSBncmFkUFtYICsgcGVybVtZXV0uZG90Mih4LCB5KTtcbiAgdmFyIG4wMSA9IGdyYWRQW1ggKyBwZXJtW1kgKyAxXV0uZG90Mih4LCB5IC0gMSk7XG4gIHZhciBuMTAgPSBncmFkUFtYICsgMSArIHBlcm1bWV1dLmRvdDIoeCAtIDEsIHkpO1xuICB2YXIgbjExID0gZ3JhZFBbWCArIDEgKyBwZXJtW1kgKyAxXV0uZG90Mih4IC0gMSwgeSAtIDEpOyAvLyBDb21wdXRlIHRoZSBmYWRlIGN1cnZlIHZhbHVlIGZvciB4XG5cbiAgdmFyIHUgPSBmYWRlKHgpOyAvLyBJbnRlcnBvbGF0ZSB0aGUgZm91ciByZXN1bHRzXG5cbiAgcmV0dXJuIGxlcnAobGVycChuMDAsIG4xMCwgdSksIGxlcnAobjAxLCBuMTEsIHUpLCBmYWRlKHkpKTtcbn07IC8vIDNEIFBlcmxpbiBOb2lzZVxuXG52YXIgcGVybGluMyA9IGZ1bmN0aW9uIHBlcmxpbjMoeCwgeSwgeikge1xuICAvLyBGaW5kIHVuaXQgZ3JpZCBjZWxsIGNvbnRhaW5pbmcgcG9pbnRcbiAgdmFyIFggPSBNYXRoLmZsb29yKHgpLFxuICAgICAgWSA9IE1hdGguZmxvb3IoeSksXG4gICAgICBaID0gTWF0aC5mbG9vcih6KTsgLy8gR2V0IHJlbGF0aXZlIHh5eiBjb29yZGluYXRlcyBvZiBwb2ludCB3aXRoaW4gdGhhdCBjZWxsXG5cbiAgeCA9IHggLSBYO1xuICB5ID0geSAtIFk7XG4gIHogPSB6IC0gWjsgLy8gV3JhcCB0aGUgaW50ZWdlciBjZWxscyBhdCAyNTUgKHNtYWxsZXIgaW50ZWdlciBwZXJpb2QgY2FuIGJlIGludHJvZHVjZWQgaGVyZSlcblxuICBYID0gWCAmIDI1NTtcbiAgWSA9IFkgJiAyNTU7XG4gIFogPSBaICYgMjU1OyAvLyBDYWxjdWxhdGUgbm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggb2YgdGhlIGVpZ2h0IGNvcm5lcnNcblxuICB2YXIgbjAwMCA9IGdyYWRQW1ggKyBwZXJtW1kgKyBwZXJtW1pdXV0uZG90Myh4LCB5LCB6KTtcbiAgdmFyIG4wMDEgPSBncmFkUFtYICsgcGVybVtZICsgcGVybVtaICsgMV1dXS5kb3QzKHgsIHksIHogLSAxKTtcbiAgdmFyIG4wMTAgPSBncmFkUFtYICsgcGVybVtZICsgMSArIHBlcm1bWl1dXS5kb3QzKHgsIHkgLSAxLCB6KTtcbiAgdmFyIG4wMTEgPSBncmFkUFtYICsgcGVybVtZICsgMSArIHBlcm1bWiArIDFdXV0uZG90Myh4LCB5IC0gMSwgeiAtIDEpO1xuICB2YXIgbjEwMCA9IGdyYWRQW1ggKyAxICsgcGVybVtZICsgcGVybVtaXV1dLmRvdDMoeCAtIDEsIHksIHopO1xuICB2YXIgbjEwMSA9IGdyYWRQW1ggKyAxICsgcGVybVtZICsgcGVybVtaICsgMV1dXS5kb3QzKHggLSAxLCB5LCB6IC0gMSk7XG4gIHZhciBuMTEwID0gZ3JhZFBbWCArIDEgKyBwZXJtW1kgKyAxICsgcGVybVtaXV1dLmRvdDMoeCAtIDEsIHkgLSAxLCB6KTtcbiAgdmFyIG4xMTEgPSBncmFkUFtYICsgMSArIHBlcm1bWSArIDEgKyBwZXJtW1ogKyAxXV1dLmRvdDMoeCAtIDEsIHkgLSAxLCB6IC0gMSk7IC8vIENvbXB1dGUgdGhlIGZhZGUgY3VydmUgdmFsdWUgZm9yIHgsIHksIHpcblxuICB2YXIgdSA9IGZhZGUoeCk7XG4gIHZhciB2ID0gZmFkZSh5KTtcbiAgdmFyIHcgPSBmYWRlKHopOyAvLyBJbnRlcnBvbGF0ZVxuXG4gIHJldHVybiBsZXJwKGxlcnAobGVycChuMDAwLCBuMTAwLCB1KSwgbGVycChuMDAxLCBuMTAxLCB1KSwgdyksIGxlcnAobGVycChuMDEwLCBuMTEwLCB1KSwgbGVycChuMDExLCBuMTExLCB1KSwgdyksIHYpO1xufTtcblxudmFyIG5vaXNlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHNlZWQ6IHNlZWQsXG4gIHNpbXBsZXgyOiBzaW1wbGV4MixcbiAgc2ltcGxleDM6IHNpbXBsZXgzLFxuICBwZXJsaW4yOiBwZXJsaW4yLFxuICBwZXJsaW4zOiBwZXJsaW4zXG59KTtcblxudmFyIFRBVSA9IE1hdGguUEkgKiAyOyAvLyBDcmVkaXRzIEBrY2hhcGVsaWVyIGh0dHBzOi8vZ2l0aHViLmNvbS9rY2hhcGVsaWVyL3dhdmVmdW5jdGlvbmNvbGxhcHNlL2Jsb2IvbWFzdGVyL2V4YW1wbGUvbGNnLmpzI0wyMi1MMzBcblxuZnVuY3Rpb24gbm9ybWFsaXplU2VlZChzZWVkKSB7XG4gIGlmICh0eXBlb2Ygc2VlZCA9PT0gXCJudW1iZXJcIikge1xuICAgIHNlZWQgPSBNYXRoLmFicyhzZWVkKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhciBzdHJpbmcgPSBzZWVkO1xuICAgIHNlZWQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlZWQgPSAoc2VlZCArIChpICsgMSkgKiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgJSA5NikpICUgMjE0NzQ4MzY0NztcbiAgICB9XG4gIH1cblxuICBpZiAoc2VlZCA9PT0gMCkge1xuICAgIHNlZWQgPSAzMTE7XG4gIH1cblxuICByZXR1cm4gc2VlZDtcbn1cblxuZnVuY3Rpb24gbGNnUmFuZG9tKHNlZWQpIHtcbiAgdmFyIHN0YXRlID0gbm9ybWFsaXplU2VlZChzZWVkKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gc3RhdGUgKiA0ODI3MSAlIDIxNDc0ODM2NDc7XG4gICAgc3RhdGUgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdCAvIDIxNDc0ODM2NDc7XG4gIH07XG59XG5cbnZhciBHZW5lcmF0b3IgPSBmdW5jdGlvbiBHZW5lcmF0b3IoX3NlZWQpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2VuZXJhdG9yKTtcblxuICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZWVkXCIsIDApO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaXRcIiwgZnVuY3Rpb24gKHNlZWQpIHtcbiAgICBfdGhpcy5zZWVkID0gc2VlZDtcbiAgICBfdGhpcy52YWx1ZSA9IGxjZ1JhbmRvbShzZWVkKTtcbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgbGNnUmFuZG9tKHRoaXMuc2VlZCkpO1xuXG4gIHRoaXMuaW5pdChfc2VlZCk7XG59O1xudmFyIGRlZmF1bHRHZW4gPSBuZXcgR2VuZXJhdG9yKE1hdGgucmFuZG9tKCkpO1xuLyoqKlxuICogWzNEXSBTcGhlcmVcbiAqL1xuXG52YXIgZGVmYXVsdFNwaGVyZSA9IHtcbiAgcmFkaXVzOiAxLFxuICBjZW50ZXI6IFswLCAwLCAwXVxufTsgLy8gcmFuZG9tIG9uIHN1cmZhY2Ugb2Ygc3BoZXJlXG4vLyAtIGh0dHBzOi8vdHdpdHRlci5jb20vZmVybWF0c2xpYnJhcnkvc3RhdHVzLzE0MzA5MzI1MDM1NzgyMjY2ODhcbi8vIC0gaHR0cHM6Ly9tYXRod29ybGQud29sZnJhbS5jb20vU3BoZXJlUG9pbnRQaWNraW5nLmh0bWxcblxuZnVuY3Rpb24gb25TcGhlcmUoYnVmZmVyLCBzcGhlcmUpIHtcbiAgdmFyIHJuZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZGVmYXVsdEdlbjtcblxuICB2YXIgX2RlZmF1bHRTcGhlcmUkc3BoZXJlID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRTcGhlcmUpLCBzcGhlcmUpLFxuICAgICAgcmFkaXVzID0gX2RlZmF1bHRTcGhlcmUkc3BoZXJlLnJhZGl1cyxcbiAgICAgIGNlbnRlciA9IF9kZWZhdWx0U3BoZXJlJHNwaGVyZS5jZW50ZXI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICB2YXIgdSA9IHJuZy52YWx1ZSgpO1xuICAgIHZhciB2ID0gcm5nLnZhbHVlKCk7XG4gICAgdmFyIHRoZXRhID0gTWF0aC5hY29zKDIgKiB2IC0gMSk7XG4gICAgdmFyIHBoaSA9IFRBVSAqIHU7XG4gICAgYnVmZmVyW2ldID0gTWF0aC5zaW4odGhldGEpICogTWF0aC5jb3MocGhpKSAqIHJhZGl1cyArIGNlbnRlclswXTtcbiAgICBidWZmZXJbaSArIDFdID0gTWF0aC5zaW4odGhldGEpICogTWF0aC5zaW4ocGhpKSAqIHJhZGl1cyArIGNlbnRlclsxXTtcbiAgICBidWZmZXJbaSArIDJdID0gTWF0aC5jb3ModGhldGEpICogcmFkaXVzICsgY2VudGVyWzJdO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn0gLy8gZnJvbSBcIkFub3RoZXIgTWV0aG9kXCIgaHR0cHM6Ly9kYXRhZ2VuZXRpY3MuY29tL2Jsb2cvamFudWFyeTMyMDIwL2luZGV4Lmh0bWxcblxuZnVuY3Rpb24gaW5TcGhlcmUoYnVmZmVyLCBzcGhlcmUpIHtcbiAgdmFyIHJuZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZGVmYXVsdEdlbjtcblxuICB2YXIgX2RlZmF1bHRTcGhlcmUkc3BoZXJlMiA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0U3BoZXJlKSwgc3BoZXJlKSxcbiAgICAgIHJhZGl1cyA9IF9kZWZhdWx0U3BoZXJlJHNwaGVyZTIucmFkaXVzLFxuICAgICAgY2VudGVyID0gX2RlZmF1bHRTcGhlcmUkc3BoZXJlMi5jZW50ZXI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICB2YXIgdSA9IE1hdGgucG93KHJuZy52YWx1ZSgpLCAxIC8gMyk7XG4gICAgdmFyIHggPSBybmcudmFsdWUoKSAqIDIgLSAxO1xuICAgIHZhciB5ID0gcm5nLnZhbHVlKCkgKiAyIC0gMTtcbiAgICB2YXIgeiA9IHJuZy52YWx1ZSgpICogMiAtIDE7XG4gICAgdmFyIG1hZyA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICAgIHggPSB1ICogeCAvIG1hZztcbiAgICB5ID0gdSAqIHkgLyBtYWc7XG4gICAgeiA9IHUgKiB6IC8gbWFnO1xuICAgIGJ1ZmZlcltpXSA9IHggKiByYWRpdXMgKyBjZW50ZXJbMF07XG4gICAgYnVmZmVyW2kgKyAxXSA9IHkgKiByYWRpdXMgKyBjZW50ZXJbMV07XG4gICAgYnVmZmVyW2kgKyAyXSA9IHogKiByYWRpdXMgKyBjZW50ZXJbMl07XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufVxuLyoqKlxuICogWzJEXSBDaXJjbGVcbiAqL1xuXG52YXIgZGVmYXVsdENpcmNsZSA9IHtcbiAgcmFkaXVzOiAxLFxuICBjZW50ZXI6IFswLCAwXVxufTsgLy8gcmFuZG9tIGNpcmNsZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTA3NDY0MDlcblxuZnVuY3Rpb24gaW5DaXJjbGUoYnVmZmVyLCBjaXJjbGUpIHtcbiAgdmFyIHJuZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZGVmYXVsdEdlbjtcblxuICB2YXIgX2RlZmF1bHRDaXJjbGUkY2lyY2xlID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRDaXJjbGUpLCBjaXJjbGUpLFxuICAgICAgcmFkaXVzID0gX2RlZmF1bHRDaXJjbGUkY2lyY2xlLnJhZGl1cyxcbiAgICAgIGNlbnRlciA9IF9kZWZhdWx0Q2lyY2xlJGNpcmNsZS5jZW50ZXI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgciA9IHJhZGl1cyAqIE1hdGguc3FydChybmcudmFsdWUoKSk7XG4gICAgdmFyIHRoZXRhID0gcm5nLnZhbHVlKCkgKiBUQVU7XG4gICAgYnVmZmVyW2ldID0gTWF0aC5zaW4odGhldGEpICogciArIGNlbnRlclswXTtcbiAgICBidWZmZXJbaSArIDFdID0gTWF0aC5jb3ModGhldGEpICogciArIGNlbnRlclsxXTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBvbkNpcmNsZShidWZmZXIsIGNpcmNsZSkge1xuICB2YXIgcm5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBkZWZhdWx0R2VuO1xuXG4gIHZhciBfZGVmYXVsdENpcmNsZSRjaXJjbGUyID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRDaXJjbGUpLCBjaXJjbGUpLFxuICAgICAgcmFkaXVzID0gX2RlZmF1bHRDaXJjbGUkY2lyY2xlMi5yYWRpdXMsXG4gICAgICBjZW50ZXIgPSBfZGVmYXVsdENpcmNsZSRjaXJjbGUyLmNlbnRlcjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB0aGV0YSA9IHJuZy52YWx1ZSgpICogVEFVO1xuICAgIGJ1ZmZlcltpXSA9IE1hdGguc2luKHRoZXRhKSAqIHJhZGl1cyArIGNlbnRlclswXTtcbiAgICBidWZmZXJbaSArIDFdID0gTWF0aC5jb3ModGhldGEpICogcmFkaXVzICsgY2VudGVyWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbi8qKlxuICogWzJEXSBQbGFuZVxuICovXG5cbnZhciBkZWZhdWx0UmVjdCA9IHtcbiAgc2lkZXM6IDEsXG4gIGNlbnRlcjogWzAsIDBdXG59O1xuZnVuY3Rpb24gaW5SZWN0KGJ1ZmZlciwgcmVjdCkge1xuICB2YXIgcm5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBkZWZhdWx0R2VuO1xuXG4gIHZhciBfZGVmYXVsdFJlY3QkcmVjdCA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0UmVjdCksIHJlY3QpLFxuICAgICAgc2lkZXMgPSBfZGVmYXVsdFJlY3QkcmVjdC5zaWRlcyxcbiAgICAgIGNlbnRlciA9IF9kZWZhdWx0UmVjdCRyZWN0LmNlbnRlcjtcblxuICB2YXIgc2lkZVggPSB0eXBlb2Ygc2lkZXMgPT09IFwibnVtYmVyXCIgPyBzaWRlcyA6IHNpZGVzWzBdO1xuICB2YXIgc2lkZVkgPSB0eXBlb2Ygc2lkZXMgPT09IFwibnVtYmVyXCIgPyBzaWRlcyA6IHNpZGVzWzFdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgYnVmZmVyW2ldID0gKHJuZy52YWx1ZSgpIC0gMC41KSAqIHNpZGVYICsgY2VudGVyWzBdO1xuICAgIGJ1ZmZlcltpICsgMV0gPSAocm5nLnZhbHVlKCkgLSAwLjUpICogc2lkZVkgKyBjZW50ZXJbMV07XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufVxuZnVuY3Rpb24gb25SZWN0KGJ1ZmZlciwgcmVjdCkge1xuICByZXR1cm4gYnVmZmVyO1xufVxuLyoqKlxuICogWzNEXSBCb3hcbiAqL1xuXG5mdW5jdGlvbiBpbkJveChidWZmZXIsIGJveCkge1xuICB2YXIgcm5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBkZWZhdWx0R2VuO1xuXG4gIHZhciBfZGVmYXVsdEJveCRib3ggPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdEJveCksIGJveCksXG4gICAgICBzaWRlcyA9IF9kZWZhdWx0Qm94JGJveC5zaWRlcyxcbiAgICAgIGNlbnRlciA9IF9kZWZhdWx0Qm94JGJveC5jZW50ZXI7XG5cbiAgdmFyIHNpZGVYID0gdHlwZW9mIHNpZGVzID09PSBcIm51bWJlclwiID8gc2lkZXMgOiBzaWRlc1swXTtcbiAgdmFyIHNpZGVZID0gdHlwZW9mIHNpZGVzID09PSBcIm51bWJlclwiID8gc2lkZXMgOiBzaWRlc1sxXTtcbiAgdmFyIHNpZGVaID0gdHlwZW9mIHNpZGVzID09PSBcIm51bWJlclwiID8gc2lkZXMgOiBzaWRlc1syXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMykge1xuICAgIGJ1ZmZlcltpXSA9IChybmcudmFsdWUoKSAtIDAuNSkgKiBzaWRlWCArIGNlbnRlclswXTtcbiAgICBidWZmZXJbaSArIDFdID0gKHJuZy52YWx1ZSgpIC0gMC41KSAqIHNpZGVZICsgY2VudGVyWzFdO1xuICAgIGJ1ZmZlcltpICsgMl0gPSAocm5nLnZhbHVlKCkgLSAwLjUpICogc2lkZVogKyBjZW50ZXJbMl07XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufVxudmFyIGRlZmF1bHRCb3ggPSB7XG4gIHNpZGVzOiAxLFxuICBjZW50ZXI6IFswLCAwLCAwXVxufTtcbmZ1bmN0aW9uIG9uQm94KGJ1ZmZlciwgYm94KSB7XG4gIHZhciBybmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGRlZmF1bHRHZW47XG5cbiAgdmFyIF9kZWZhdWx0Qm94JGJveDIgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdEJveCksIGJveCksXG4gICAgICBzaWRlcyA9IF9kZWZhdWx0Qm94JGJveDIuc2lkZXMsXG4gICAgICBjZW50ZXIgPSBfZGVmYXVsdEJveCRib3gyLmNlbnRlcjtcblxuICB2YXIgc2lkZVggPSB0eXBlb2Ygc2lkZXMgPT09IFwibnVtYmVyXCIgPyBzaWRlcyA6IHNpZGVzWzBdO1xuICB2YXIgc2lkZVkgPSB0eXBlb2Ygc2lkZXMgPT09IFwibnVtYmVyXCIgPyBzaWRlcyA6IHNpZGVzWzFdO1xuICB2YXIgc2lkZVogPSB0eXBlb2Ygc2lkZXMgPT09IFwibnVtYmVyXCIgPyBzaWRlcyA6IHNpZGVzWzJdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgYnVmZmVyW2ldID0gKHJuZy52YWx1ZSgpIC0gMC41KSAqIHNpZGVYICsgY2VudGVyWzBdO1xuICAgIGJ1ZmZlcltpICsgMV0gPSAocm5nLnZhbHVlKCkgLSAwLjUpICogc2lkZVkgKyBjZW50ZXJbMV07XG4gICAgYnVmZmVyW2kgKyAyXSA9IChybmcudmFsdWUoKSAtIDAuNSkgKiBzaWRlWiArIGNlbnRlclsyXTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59XG5cbnZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBHZW5lcmF0b3I6IEdlbmVyYXRvcixcbiAgb25TcGhlcmU6IG9uU3BoZXJlLFxuICBpblNwaGVyZTogaW5TcGhlcmUsXG4gIGluQ2lyY2xlOiBpbkNpcmNsZSxcbiAgb25DaXJjbGU6IG9uQ2lyY2xlLFxuICBpblJlY3Q6IGluUmVjdCxcbiAgb25SZWN0OiBvblJlY3QsXG4gIGluQm94OiBpbkJveCxcbiAgb25Cb3g6IG9uQm94LFxuICBub2lzZTogbm9pc2Vcbn0pO1xuXG5leHBvcnQgeyBHZW5lcmF0b3IgYXMgRywgaW5TcGhlcmUgYXMgYSwgaW5DaXJjbGUgYXMgYiwgb25DaXJjbGUgYXMgYywgaW5SZWN0IGFzIGQsIG9uUmVjdCBhcyBlLCBpbkJveCBhcyBmLCBvbkJveCBhcyBnLCBpbmRleCBhcyBpLCBub2lzZSBhcyBuLCBvblNwaGVyZSBhcyBvIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/index-43782085.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/isNativeReflectConstruct-5594d075.esm.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/isNativeReflectConstruct-5594d075.esm.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _setPrototypeOf),\n/* harmony export */   a: () => (/* binding */ _isNativeReflectConstruct)\n/* harmony export */ });\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LTU1OTRkMDc1LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRWdFIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL3Bvc3Rwcm9jZXNzaW5nL25vZGVfbW9kdWxlcy9tYWF0aC9kaXN0L2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC01NTk0ZDA3NS5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgeyBfc2V0UHJvdG90eXBlT2YgYXMgXywgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCBhcyBhIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/isNativeReflectConstruct-5594d075.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/maath.esm.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/maath.esm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buffer: () => (/* reexport safe */ _buffer_d2a4726c_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   easing: () => (/* reexport safe */ _easing_3be59c6d_esm_js__WEBPACK_IMPORTED_MODULE_2__.e),\n/* harmony export */   geometry: () => (/* reexport safe */ _geometry_982366ff_esm_js__WEBPACK_IMPORTED_MODULE_3__.g),\n/* harmony export */   matrix: () => (/* reexport safe */ _matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_4__.m),\n/* harmony export */   misc: () => (/* reexport safe */ _misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_5__.m),\n/* harmony export */   random: () => (/* reexport safe */ _index_43782085_esm_js__WEBPACK_IMPORTED_MODULE_1__.i),\n/* harmony export */   three: () => (/* reexport safe */ _three_eb2ad8c0_esm_js__WEBPACK_IMPORTED_MODULE_6__.t),\n/* harmony export */   triangle: () => (/* reexport safe */ _triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_7__.t),\n/* harmony export */   vector2: () => (/* reexport safe */ _vector2_d2bf51f1_esm_js__WEBPACK_IMPORTED_MODULE_8__.v),\n/* harmony export */   vector3: () => (/* reexport safe */ _vector3_0a088b7f_esm_js__WEBPACK_IMPORTED_MODULE_9__.v)\n/* harmony export */ });\n/* harmony import */ var _buffer_d2a4726c_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer-d2a4726c.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/buffer-d2a4726c.esm.js\");\n/* harmony import */ var _index_43782085_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-43782085.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/index-43782085.esm.js\");\n/* harmony import */ var _easing_3be59c6d_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./easing-3be59c6d.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/easing-3be59c6d.esm.js\");\n/* harmony import */ var _geometry_982366ff_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry-982366ff.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/geometry-982366ff.esm.js\");\n/* harmony import */ var _matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./matrix-baa530bf.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/matrix-baa530bf.esm.js\");\n/* harmony import */ var _misc_7d870b3c_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./misc-7d870b3c.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/misc-7d870b3c.esm.js\");\n/* harmony import */ var _three_eb2ad8c0_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./three-eb2ad8c0.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/three-eb2ad8c0.esm.js\");\n/* harmony import */ var _triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./triangle-b62b9067.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/triangle-b62b9067.esm.js\");\n/* harmony import */ var _vector2_d2bf51f1_esm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vector2-d2bf51f1.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/vector2-d2bf51f1.esm.js\");\n/* harmony import */ var _vector3_0a088b7f_esm_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vector3-0a088b7f.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/vector3-0a088b7f.esm.js\");\n/* harmony import */ var _objectSpread2_284232a6_esm_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./objectSpread2-284232a6.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/objectSpread2-284232a6.esm.js\");\n/* harmony import */ var _classCallCheck_9098b006_esm_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./classCallCheck-9098b006.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/classCallCheck-9098b006.esm.js\");\n/* harmony import */ var _isNativeReflectConstruct_5594d075_esm_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./isNativeReflectConstruct-5594d075.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/isNativeReflectConstruct-5594d075.esm.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvbWFhdGguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ0Q7QUFDQztBQUNJO0FBQ0o7QUFDSjtBQUNFO0FBQ007QUFDRjtBQUNBO0FBQ2hCO0FBQzFCO0FBQzJCO0FBQ1UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvbWFhdGguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGIgYXMgYnVmZmVyIH0gZnJvbSAnLi9idWZmZXItZDJhNDcyNmMuZXNtLmpzJztcbmV4cG9ydCB7IGkgYXMgcmFuZG9tIH0gZnJvbSAnLi9pbmRleC00Mzc4MjA4NS5lc20uanMnO1xuZXhwb3J0IHsgZSBhcyBlYXNpbmcgfSBmcm9tICcuL2Vhc2luZy0zYmU1OWM2ZC5lc20uanMnO1xuZXhwb3J0IHsgZyBhcyBnZW9tZXRyeSB9IGZyb20gJy4vZ2VvbWV0cnktOTgyMzY2ZmYuZXNtLmpzJztcbmV4cG9ydCB7IG0gYXMgbWF0cml4IH0gZnJvbSAnLi9tYXRyaXgtYmFhNTMwYmYuZXNtLmpzJztcbmV4cG9ydCB7IG0gYXMgbWlzYyB9IGZyb20gJy4vbWlzYy03ZDg3MGIzYy5lc20uanMnO1xuZXhwb3J0IHsgdCBhcyB0aHJlZSB9IGZyb20gJy4vdGhyZWUtZWIyYWQ4YzAuZXNtLmpzJztcbmV4cG9ydCB7IHQgYXMgdHJpYW5nbGUgfSBmcm9tICcuL3RyaWFuZ2xlLWI2MmI5MDY3LmVzbS5qcyc7XG5leHBvcnQgeyB2IGFzIHZlY3RvcjIgfSBmcm9tICcuL3ZlY3RvcjItZDJiZjUxZjEuZXNtLmpzJztcbmV4cG9ydCB7IHYgYXMgdmVjdG9yMyB9IGZyb20gJy4vdmVjdG9yMy0wYTA4OGI3Zi5lc20uanMnO1xuaW1wb3J0ICcuL29iamVjdFNwcmVhZDItMjg0MjMyYTYuZXNtLmpzJztcbmltcG9ydCAndGhyZWUnO1xuaW1wb3J0ICcuL2NsYXNzQ2FsbENoZWNrLTkwOThiMDA2LmVzbS5qcyc7XG5pbXBvcnQgJy4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LTU1OTRkMDc1LmVzbS5qcyc7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/maath.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/matrix-baa530bf.esm.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/matrix-baa530bf.esm.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ matrixSum3),\n/* harmony export */   b: () => (/* binding */ determinant2),\n/* harmony export */   c: () => (/* binding */ determinant4),\n/* harmony export */   d: () => (/* binding */ determinant3),\n/* harmony export */   g: () => (/* binding */ getMinor),\n/* harmony export */   m: () => (/* binding */ matrix)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\n\n/**\n *\n * @param terms\n *\n * | a b |\n * | c d |\n *\n * @returns {number} determinant\n */\n\nfunction determinant2() {\n  for (var _len = arguments.length, terms = new Array(_len), _key = 0; _key < _len; _key++) {\n    terms[_key] = arguments[_key];\n  }\n\n  var a = terms[0],\n      b = terms[1],\n      c = terms[2],\n      d = terms[3];\n  return a * d - b * c;\n}\n/**\n *\n * @param terms\n *\n * | a b c |\n * | d e f |\n * | g h i |\n *\n * @returns {number} determinant\n */\n\nfunction determinant3() {\n  for (var _len2 = arguments.length, terms = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    terms[_key2] = arguments[_key2];\n  }\n\n  var a = terms[0],\n      b = terms[1],\n      c = terms[2],\n      d = terms[3],\n      e = terms[4],\n      f = terms[5],\n      g = terms[6],\n      h = terms[7],\n      i = terms[8];\n  return a * e * i + b * f * g + c * d * h - c * e * g - b * d * i - a * f * h;\n}\n/**\n *\n * @param terms\n *\n * | a b c g |\n * | h i j k |\n * | l m n o |\n *\n * @returns {number} determinant\n */\n\nfunction determinant4() {\n  for (var _len3 = arguments.length, terms = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    terms[_key3] = arguments[_key3];\n  }\n\n  terms[0];\n      terms[1];\n      terms[2];\n      terms[3];\n      terms[4];\n      terms[5];\n      terms[6];\n      terms[7];\n      terms[8];\n      terms[9];\n      terms[10];\n      terms[11];\n      terms[12];\n      terms[13];\n      terms[14]; // TODO\n}\n/**\n *\n * Get the determinant of matrix m without row r and col c\n *\n * @param {matrix} m Starter matrix\n * @param r row to remove\n * @param c col to remove\n *\n *     | a b c |\n * m = | d e f |\n *     | g h i |\n *\n * getMinor(m, 1, 1) would result in this determinant\n *\n * | a c |\n * | g i |\n *\n * @returns {number} determinant\n */\n\nfunction getMinor(matrix, r, c) {\n  var _matrixTranspose = matrix.clone().transpose();\n\n  var x = [];\n  var l = _matrixTranspose.elements.length;\n  var n = Math.sqrt(l);\n\n  for (var i = 0; i < l; i++) {\n    var element = _matrixTranspose.elements[i];\n    var row = Math.floor(i / n);\n    var col = i % n;\n\n    if (row !== r - 1 && col !== c - 1) {\n      x.push(element);\n    }\n  }\n\n  return determinant3.apply(void 0, x);\n}\n/**\n *\n */\n\nfunction matrixSum3(m1, m2) {\n  var sum = [];\n  var m1Array = m1.toArray();\n  var m2Array = m2.toArray();\n\n  for (var i = 0; i < m1Array.length; i++) {\n    sum[i] = m1Array[i] + m2Array[i];\n  }\n\n  return new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3().fromArray(sum);\n}\n\nvar matrix = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  determinant2: determinant2,\n  determinant3: determinant3,\n  determinant4: determinant4,\n  getMinor: getMinor,\n  matrixSum3: matrixSum3\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvbWF0cml4LWJhYTUzMGJmLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBOztBQUVBLGFBQWEsMENBQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUUrRyIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9wb3N0cHJvY2Vzc2luZy9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9tYXRyaXgtYmFhNTMwYmYuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICd0aHJlZSc7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB0ZXJtc1xuICpcbiAqIHwgYSBiIHxcbiAqIHwgYyBkIHxcbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkZXRlcm1pbmFudFxuICovXG5cbmZ1bmN0aW9uIGRldGVybWluYW50MigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHRlcm1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHRlcm1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGEgPSB0ZXJtc1swXSxcbiAgICAgIGIgPSB0ZXJtc1sxXSxcbiAgICAgIGMgPSB0ZXJtc1syXSxcbiAgICAgIGQgPSB0ZXJtc1szXTtcbiAgcmV0dXJuIGEgKiBkIC0gYiAqIGM7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdGVybXNcbiAqXG4gKiB8IGEgYiBjIHxcbiAqIHwgZCBlIGYgfFxuICogfCBnIGggaSB8XG4gKlxuICogQHJldHVybnMge251bWJlcn0gZGV0ZXJtaW5hbnRcbiAqL1xuXG5mdW5jdGlvbiBkZXRlcm1pbmFudDMoKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdGVybXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICB0ZXJtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgdmFyIGEgPSB0ZXJtc1swXSxcbiAgICAgIGIgPSB0ZXJtc1sxXSxcbiAgICAgIGMgPSB0ZXJtc1syXSxcbiAgICAgIGQgPSB0ZXJtc1szXSxcbiAgICAgIGUgPSB0ZXJtc1s0XSxcbiAgICAgIGYgPSB0ZXJtc1s1XSxcbiAgICAgIGcgPSB0ZXJtc1s2XSxcbiAgICAgIGggPSB0ZXJtc1s3XSxcbiAgICAgIGkgPSB0ZXJtc1s4XTtcbiAgcmV0dXJuIGEgKiBlICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZyAtIGIgKiBkICogaSAtIGEgKiBmICogaDtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB0ZXJtc1xuICpcbiAqIHwgYSBiIGMgZyB8XG4gKiB8IGggaSBqIGsgfFxuICogfCBsIG0gbiBvIHxcbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkZXRlcm1pbmFudFxuICovXG5cbmZ1bmN0aW9uIGRldGVybWluYW50NCgpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCB0ZXJtcyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIHRlcm1zW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICB0ZXJtc1swXTtcbiAgICAgIHRlcm1zWzFdO1xuICAgICAgdGVybXNbMl07XG4gICAgICB0ZXJtc1szXTtcbiAgICAgIHRlcm1zWzRdO1xuICAgICAgdGVybXNbNV07XG4gICAgICB0ZXJtc1s2XTtcbiAgICAgIHRlcm1zWzddO1xuICAgICAgdGVybXNbOF07XG4gICAgICB0ZXJtc1s5XTtcbiAgICAgIHRlcm1zWzEwXTtcbiAgICAgIHRlcm1zWzExXTtcbiAgICAgIHRlcm1zWzEyXTtcbiAgICAgIHRlcm1zWzEzXTtcbiAgICAgIHRlcm1zWzE0XTsgLy8gVE9ET1xufVxuLyoqXG4gKlxuICogR2V0IHRoZSBkZXRlcm1pbmFudCBvZiBtYXRyaXggbSB3aXRob3V0IHJvdyByIGFuZCBjb2wgY1xuICpcbiAqIEBwYXJhbSB7bWF0cml4fSBtIFN0YXJ0ZXIgbWF0cml4XG4gKiBAcGFyYW0gciByb3cgdG8gcmVtb3ZlXG4gKiBAcGFyYW0gYyBjb2wgdG8gcmVtb3ZlXG4gKlxuICogICAgIHwgYSBiIGMgfFxuICogbSA9IHwgZCBlIGYgfFxuICogICAgIHwgZyBoIGkgfFxuICpcbiAqIGdldE1pbm9yKG0sIDEsIDEpIHdvdWxkIHJlc3VsdCBpbiB0aGlzIGRldGVybWluYW50XG4gKlxuICogfCBhIGMgfFxuICogfCBnIGkgfFxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRldGVybWluYW50XG4gKi9cblxuZnVuY3Rpb24gZ2V0TWlub3IobWF0cml4LCByLCBjKSB7XG4gIHZhciBfbWF0cml4VHJhbnNwb3NlID0gbWF0cml4LmNsb25lKCkudHJhbnNwb3NlKCk7XG5cbiAgdmFyIHggPSBbXTtcbiAgdmFyIGwgPSBfbWF0cml4VHJhbnNwb3NlLmVsZW1lbnRzLmxlbmd0aDtcbiAgdmFyIG4gPSBNYXRoLnNxcnQobCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgZWxlbWVudCA9IF9tYXRyaXhUcmFuc3Bvc2UuZWxlbWVudHNbaV07XG4gICAgdmFyIHJvdyA9IE1hdGguZmxvb3IoaSAvIG4pO1xuICAgIHZhciBjb2wgPSBpICUgbjtcblxuICAgIGlmIChyb3cgIT09IHIgLSAxICYmIGNvbCAhPT0gYyAtIDEpIHtcbiAgICAgIHgucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGV0ZXJtaW5hbnQzLmFwcGx5KHZvaWQgMCwgeCk7XG59XG4vKipcbiAqXG4gKi9cblxuZnVuY3Rpb24gbWF0cml4U3VtMyhtMSwgbTIpIHtcbiAgdmFyIHN1bSA9IFtdO1xuICB2YXIgbTFBcnJheSA9IG0xLnRvQXJyYXkoKTtcbiAgdmFyIG0yQXJyYXkgPSBtMi50b0FycmF5KCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtMUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3VtW2ldID0gbTFBcnJheVtpXSArIG0yQXJyYXlbaV07XG4gIH1cblxuICByZXR1cm4gbmV3IE1hdHJpeDMoKS5mcm9tQXJyYXkoc3VtKTtcbn1cblxudmFyIG1hdHJpeCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBkZXRlcm1pbmFudDI6IGRldGVybWluYW50MixcbiAgZGV0ZXJtaW5hbnQzOiBkZXRlcm1pbmFudDMsXG4gIGRldGVybWluYW50NDogZGV0ZXJtaW5hbnQ0LFxuICBnZXRNaW5vcjogZ2V0TWlub3IsXG4gIG1hdHJpeFN1bTM6IG1hdHJpeFN1bTNcbn0pO1xuXG5leHBvcnQgeyBtYXRyaXhTdW0zIGFzIGEsIGRldGVybWluYW50MiBhcyBiLCBkZXRlcm1pbmFudDQgYXMgYywgZGV0ZXJtaW5hbnQzIGFzIGQsIGdldE1pbm9yIGFzIGcsIG1hdHJpeCBhcyBtIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/matrix-baa530bf.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/misc-7d870b3c.esm.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/misc-7d870b3c.esm.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ degToRad),\n/* harmony export */   b: () => (/* binding */ fibonacciOnSphere),\n/* harmony export */   c: () => (/* binding */ clamp),\n/* harmony export */   d: () => (/* binding */ deltaAngle),\n/* harmony export */   e: () => (/* binding */ lexicographic),\n/* harmony export */   f: () => (/* binding */ fade),\n/* harmony export */   g: () => (/* binding */ convexHull),\n/* harmony export */   h: () => (/* binding */ remap),\n/* harmony export */   i: () => (/* binding */ inverseLerp),\n/* harmony export */   j: () => (/* binding */ rotateVectorOnVector),\n/* harmony export */   k: () => (/* binding */ pointToCoordinate),\n/* harmony export */   l: () => (/* binding */ lerp),\n/* harmony export */   m: () => (/* binding */ misc),\n/* harmony export */   n: () => (/* binding */ normalize),\n/* harmony export */   o: () => (/* binding */ coordinateToPoint),\n/* harmony export */   p: () => (/* binding */ pointOnCubeToPointOnSphere),\n/* harmony export */   q: () => (/* binding */ planeSegmentIntersection),\n/* harmony export */   r: () => (/* binding */ radToDeg),\n/* harmony export */   s: () => (/* binding */ pointToPlaneDistance),\n/* harmony export */   t: () => (/* binding */ getIndexFrom3D),\n/* harmony export */   u: () => (/* binding */ get3DFromIndex),\n/* harmony export */   v: () => (/* binding */ vectorEquals),\n/* harmony export */   w: () => (/* binding */ getIndexFrom2D),\n/* harmony export */   x: () => (/* binding */ get2DFromIndex)\n/* harmony export */ });\n/* harmony import */ var _triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./triangle-b62b9067.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/triangle-b62b9067.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix-baa530bf.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/matrix-baa530bf.esm.js\");\n\n\n\n\n/**\n * Clamps a value between a range.\n */\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n} // Loops the value t, so that it is never larger than length and never smaller than 0.\n\nfunction repeat(t, length) {\n  return clamp(t - Math.floor(t / length) * length, 0, length);\n} // Calculates the shortest difference between two given angles.\n\n\nfunction deltaAngle(current, target) {\n  var delta = repeat(target - current, Math.PI * 2);\n  if (delta > Math.PI) delta -= Math.PI * 2;\n  return delta;\n}\n/**\n * Converts degrees to radians.\n */\n\nfunction degToRad(degrees) {\n  return degrees / 180 * Math.PI;\n}\n/**\n * Converts radians to degrees.\n */\n\nfunction radToDeg(radians) {\n  return radians * 180 / Math.PI;\n} // adapted from https://gist.github.com/stephanbogner/a5f50548a06bec723dcb0991dcbb0856 by https://twitter.com/st_phan\n\nfunction fibonacciOnSphere(buffer, _ref) {\n  var _ref$radius = _ref.radius,\n      radius = _ref$radius === void 0 ? 1 : _ref$radius;\n  var samples = buffer.length / 3;\n  var offset = 2 / samples;\n  var increment = Math.PI * (3 - 2.2360679775);\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    var y = i * offset - 1 + offset / 2;\n    var distance = Math.sqrt(1 - Math.pow(y, 2));\n    var phi = i % samples * increment;\n    var x = Math.cos(phi) * distance;\n    var z = Math.sin(phi) * distance;\n    buffer[i] = x * radius;\n    buffer[i + 1] = y * radius;\n    buffer[i + 2] = z * radius;\n  }\n} // @ts-ignore\n\nfunction vectorEquals(a, b) {\n  var eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.EPSILON;\n  return Math.abs(a.x - b.x) < eps && Math.abs(a.y - b.y) < eps && Math.abs(a.z - b.z) < eps;\n}\n/**\n * Sorts vectors in lexicographic order, works with both v2 and v3\n *\n *  Use as:\n *  const sorted = arrayOfVectors.sort(lexicographicOrder)\n */\n// https://en.wikipedia.org/wiki/Lexicographic_order\n\nfunction lexicographic(a, b) {\n  if (a.x === b.x) {\n    // do a check to see if points is 3D,\n    // in which case add y eq check and sort by z\n    if (typeof a.z !== \"undefined\") {\n      if (a.y === b.y) {\n        return a.z - b.z;\n      }\n    }\n\n    return a.y - b.y;\n  }\n\n  return a.x - b.x;\n}\n/**\n * Convex Hull\n *\n * Returns an array of 2D Vectors representing the convex hull of a set of 2D Vectors\n */\n\n/**\n * Calculate the convex hull of a set of points\n */\n\nfunction convexHull(_points) {\n  var points = _points.sort(lexicographic); // put p1 and p2 in a list lUpper with p1 as the first point\n\n\n  var lUpper = [points[0], points[1]]; // for i <- 3 to n\n\n  for (var i = 2; i < points.length; i++) {\n    lUpper.push(points[i]); // while lUpper contains more than 2 points and the last three points in lUpper do not make a right turn\n\n    while (lUpper.length > 2 && (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)((0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(lUpper.slice(-3)))) {\n      // delete the middle of the last three points from lUpper\n      lUpper.splice(lUpper.length - 2, 1);\n    }\n  } // put pn and pn-1 in a list lLower with pn as the first point\n\n\n  var lLower = [points[points.length - 1], points[points.length - 2]]; // for (i <- n - 2 downto 1)\n\n  for (var _i = points.length - 3; _i >= 0; _i--) {\n    // append pi to lLower\n    lLower.push(points[_i]); // while lLower contains more than 2 points and the last three points in lLower do not make a right turn\n\n    while (lLower.length > 2 && (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)((0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(lLower.slice(-3)))) {\n      // delete the middle of the last three points from lLower\n      lLower.splice(lLower.length - 2, 1);\n    }\n  } // remove the first and last point from lLower to avoid duplication of the points where the upper and lower hull meet\n\n\n  lLower.splice(0, 1);\n  lLower.splice(lLower.length - 1, 1); // prettier-ignore\n\n  var c = [].concat(lUpper, lLower);\n  return c;\n}\nfunction remap(x, _ref2, _ref3) {\n  var _ref4 = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(_ref2, 2),\n      low1 = _ref4[0],\n      high1 = _ref4[1];\n\n  var _ref5 = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(_ref3, 2),\n      low2 = _ref5[0],\n      high2 = _ref5[1];\n\n  return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n/**\n *\n * https://www.desmos.com/calculator/vsnmlaljdu\n *\n * Ease-in-out, goes to -Infinite before 0 and Infinite after 1\n *\n * @param t\n * @returns\n */\n\nfunction fade(t) {\n  return t * t * t * (t * (t * 6 - 15) + 10);\n}\n/**\n *\n * Returns the result of linearly interpolating between input A and input B by input T.\n *\n * @param v0\n * @param v1\n * @param t\n * @returns\n */\n\nfunction lerp(v0, v1, t) {\n  return v0 * (1 - t) + v1 * t;\n}\n/**\n *\n * Returns the linear parameter that produces the interpolant specified by input T within the range of input A to input B.\n *\n * @param v0\n * @param v1\n * @param t\n * @returns\n */\n\nfunction inverseLerp(v0, v1, t) {\n  return (t - v0) / (v1 - v0);\n}\n/**\n *\n */\n\nfunction normalize(x, y, z) {\n  var m = Math.sqrt(x * x + y * y + z * z);\n  return [x / m, y / m, z / m];\n}\n/**\n *\n */\n\nfunction pointOnCubeToPointOnSphere(x, y, z) {\n  var x2 = x * x;\n  var y2 = y * y;\n  var z2 = z * z;\n  var nx = x * Math.sqrt(1 - (y2 + z2) / 2 + y2 * z2 / 3);\n  var ny = y * Math.sqrt(1 - (z2 + x2) / 2 + z2 * x2 / 3);\n  var nz = z * Math.sqrt(1 - (x2 + y2) / 2 + x2 * y2 / 3);\n  return [nx, ny, nz];\n} // https://math.stackexchange.com/questions/180418/calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d\n\n/**\n * Give two unit vectors a and b, returns the transformation matrix that rotates a onto b.\n *\n * */\n\nfunction rotateVectorOnVector(a, b) {\n  var v = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().crossVectors(a, b);\n  var c = a.dot(b);\n  var i = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix3().identity(); //  skew-symmetric cross-product matrix of 𝑣 https://en.wikipedia.org/wiki/Skew-symmetric_matrix\n  // prettier-ignore\n\n  var vx = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix3().set(0, -v.z, v.y, v.z, 0, -v.x, -v.y, v.x, 0);\n  var vxsquared = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix3().multiplyMatrices(vx, vx).multiplyScalar(1 / (1 + c));\n\n  var _final = (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)((0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(i, vx), vxsquared);\n\n  return _final;\n} // calculate latitude and longitude (in radians) from point on unit sphere\n\nfunction pointToCoordinate(x, y, z) {\n  var lat = Math.asin(y);\n  var lon = Math.atan2(x, -z);\n  return [lat, lon];\n} // calculate point on unit sphere given latitude and logitude in radians\n\nfunction coordinateToPoint(lat, lon) {\n  var y = Math.sin(lat);\n  var r = Math.cos(lat);\n  var x = Math.sin(lon) * r;\n  var z = -Math.cos(lon) * r;\n  return [x, y, z];\n}\n/**\n * Given a plane and a segment, return the intersection point if it exists or null it doesn't.\n */\n\nfunction planeSegmentIntersection(plane, segment) {\n  var _segment = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(segment, 2),\n      a = _segment[0],\n      b = _segment[1];\n\n  var matrix = rotateVectorOnVector(plane.normal, new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0));\n  var t = inverseLerp(a.clone().applyMatrix3(matrix).y, b.clone().applyMatrix3(matrix).y, 0);\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().lerpVectors(a, b, t);\n}\n/**\n * Given a plane and a point, return the distance.\n */\n\nfunction pointToPlaneDistance(p, plane) {\n  var d = plane.normal.dot(p); // TODO\n\n  return d;\n}\nfunction getIndexFrom3D(coords, sides) {\n  var _coords = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(coords, 3),\n      ix = _coords[0],\n      iy = _coords[1],\n      iz = _coords[2];\n\n  var _sides = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(sides, 2),\n      rx = _sides[0],\n      ry = _sides[1];\n\n  return iz * rx * ry + iy * rx + ix;\n}\nfunction get3DFromIndex(index, size) {\n  var _size = (0,_triangle_b62b9067_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(size, 2),\n      rx = _size[0],\n      ry = _size[1];\n\n  var a = rx * ry;\n  var z = index / a;\n  var b = index - a * z;\n  var y = b / rx;\n  var x = b % rx;\n  return [x, y, z];\n}\nfunction getIndexFrom2D(coords, size) {\n  return coords[0] + size[0] * coords[1];\n}\nfunction get2DFromIndex(index, columns) {\n  var x = index % columns;\n  var y = Math.floor(index / columns);\n  return [x, y];\n}\n\nvar misc = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clamp: clamp,\n  deltaAngle: deltaAngle,\n  degToRad: degToRad,\n  radToDeg: radToDeg,\n  fibonacciOnSphere: fibonacciOnSphere,\n  vectorEquals: vectorEquals,\n  lexicographic: lexicographic,\n  convexHull: convexHull,\n  remap: remap,\n  fade: fade,\n  lerp: lerp,\n  inverseLerp: inverseLerp,\n  normalize: normalize,\n  pointOnCubeToPointOnSphere: pointOnCubeToPointOnSphere,\n  rotateVectorOnVector: rotateVectorOnVector,\n  pointToCoordinate: pointToCoordinate,\n  coordinateToPoint: coordinateToPoint,\n  planeSegmentIntersection: planeSegmentIntersection,\n  pointToPlaneDistance: pointToPlaneDistance,\n  getIndexFrom3D: getIndexFrom3D,\n  get3DFromIndex: get3DFromIndex,\n  getIndexFrom2D: getIndexFrom2D,\n  get2DFromIndex: get2DFromIndex\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvbWlzYy03ZDg3MGIzYy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdIO0FBQy9FO0FBQ2tCOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7O0FBRzVDLHVDQUF1Qzs7QUFFdkMsa0JBQWtCLG1CQUFtQjtBQUNyQyw0QkFBNEI7O0FBRTVCLGdDQUFnQyw0REFBdUIsQ0FBQyw0REFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0osdUVBQXVFOztBQUV2RSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBLDZCQUE2Qjs7QUFFN0IsZ0NBQWdDLDREQUF1QixDQUFDLDREQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDREQUFjO0FBQzVCO0FBQ0E7O0FBRUEsY0FBYyw0REFBYztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDBDQUFPO0FBQ3JCO0FBQ0EsY0FBYywwQ0FBTyxlQUFlO0FBQ3BDOztBQUVBLGVBQWUsMENBQU87QUFDdEIsc0JBQXNCLDBDQUFPOztBQUU3QixlQUFlLDBEQUFVLENBQUMsMERBQVU7O0FBRXBDO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsNERBQWM7QUFDL0I7QUFDQTs7QUFFQSxzREFBc0QsMENBQU87QUFDN0Q7QUFDQSxhQUFhLDBDQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQWM7QUFDOUI7QUFDQTtBQUNBOztBQUVBLGVBQWUsNERBQWM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDREQUFjO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFNmQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvbWlzYy03ZDg3MGIzYy5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZCBhcyBkb1RocmVlUG9pbnRzTWFrZUFSaWdodCwgYSBhcyBfdG9Db25zdW1hYmxlQXJyYXksIF8gYXMgX3NsaWNlZFRvQXJyYXkgfSBmcm9tICcuL3RyaWFuZ2xlLWI2MmI5MDY3LmVzbS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzLCBNYXRyaXgzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgYSBhcyBtYXRyaXhTdW0zIH0gZnJvbSAnLi9tYXRyaXgtYmFhNTMwYmYuZXNtLmpzJztcblxuLyoqXG4gKiBDbGFtcHMgYSB2YWx1ZSBiZXR3ZWVuIGEgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59IC8vIExvb3BzIHRoZSB2YWx1ZSB0LCBzbyB0aGF0IGl0IGlzIG5ldmVyIGxhcmdlciB0aGFuIGxlbmd0aCBhbmQgbmV2ZXIgc21hbGxlciB0aGFuIDAuXG5cbmZ1bmN0aW9uIHJlcGVhdCh0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGNsYW1wKHQgLSBNYXRoLmZsb29yKHQgLyBsZW5ndGgpICogbGVuZ3RoLCAwLCBsZW5ndGgpO1xufSAvLyBDYWxjdWxhdGVzIHRoZSBzaG9ydGVzdCBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGdpdmVuIGFuZ2xlcy5cblxuXG5mdW5jdGlvbiBkZWx0YUFuZ2xlKGN1cnJlbnQsIHRhcmdldCkge1xuICB2YXIgZGVsdGEgPSByZXBlYXQodGFyZ2V0IC0gY3VycmVudCwgTWF0aC5QSSAqIDIpO1xuICBpZiAoZGVsdGEgPiBNYXRoLlBJKSBkZWx0YSAtPSBNYXRoLlBJICogMjtcbiAgcmV0dXJuIGRlbHRhO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gKi9cblxuZnVuY3Rpb24gZGVnVG9SYWQoZGVncmVlcykge1xuICByZXR1cm4gZGVncmVlcyAvIDE4MCAqIE1hdGguUEk7XG59XG4vKipcbiAqIENvbnZlcnRzIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAqL1xuXG5mdW5jdGlvbiByYWRUb0RlZyhyYWRpYW5zKSB7XG4gIHJldHVybiByYWRpYW5zICogMTgwIC8gTWF0aC5QSTtcbn0gLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N0ZXBoYW5ib2duZXIvYTVmNTA1NDhhMDZiZWM3MjNkY2IwOTkxZGNiYjA4NTYgYnkgaHR0cHM6Ly90d2l0dGVyLmNvbS9zdF9waGFuXG5cbmZ1bmN0aW9uIGZpYm9uYWNjaU9uU3BoZXJlKGJ1ZmZlciwgX3JlZikge1xuICB2YXIgX3JlZiRyYWRpdXMgPSBfcmVmLnJhZGl1cyxcbiAgICAgIHJhZGl1cyA9IF9yZWYkcmFkaXVzID09PSB2b2lkIDAgPyAxIDogX3JlZiRyYWRpdXM7XG4gIHZhciBzYW1wbGVzID0gYnVmZmVyLmxlbmd0aCAvIDM7XG4gIHZhciBvZmZzZXQgPSAyIC8gc2FtcGxlcztcbiAgdmFyIGluY3JlbWVudCA9IE1hdGguUEkgKiAoMyAtIDIuMjM2MDY3OTc3NSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICB2YXIgeSA9IGkgKiBvZmZzZXQgLSAxICsgb2Zmc2V0IC8gMjtcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoMSAtIE1hdGgucG93KHksIDIpKTtcbiAgICB2YXIgcGhpID0gaSAlIHNhbXBsZXMgKiBpbmNyZW1lbnQ7XG4gICAgdmFyIHggPSBNYXRoLmNvcyhwaGkpICogZGlzdGFuY2U7XG4gICAgdmFyIHogPSBNYXRoLnNpbihwaGkpICogZGlzdGFuY2U7XG4gICAgYnVmZmVyW2ldID0geCAqIHJhZGl1cztcbiAgICBidWZmZXJbaSArIDFdID0geSAqIHJhZGl1cztcbiAgICBidWZmZXJbaSArIDJdID0geiAqIHJhZGl1cztcbiAgfVxufSAvLyBAdHMtaWdub3JlXG5cbmZ1bmN0aW9uIHZlY3RvckVxdWFscyhhLCBiKSB7XG4gIHZhciBlcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IE51bWJlci5FUFNJTE9OO1xuICByZXR1cm4gTWF0aC5hYnMoYS54IC0gYi54KSA8IGVwcyAmJiBNYXRoLmFicyhhLnkgLSBiLnkpIDwgZXBzICYmIE1hdGguYWJzKGEueiAtIGIueikgPCBlcHM7XG59XG4vKipcbiAqIFNvcnRzIHZlY3RvcnMgaW4gbGV4aWNvZ3JhcGhpYyBvcmRlciwgd29ya3Mgd2l0aCBib3RoIHYyIGFuZCB2M1xuICpcbiAqICBVc2UgYXM6XG4gKiAgY29uc3Qgc29ydGVkID0gYXJyYXlPZlZlY3RvcnMuc29ydChsZXhpY29ncmFwaGljT3JkZXIpXG4gKi9cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xleGljb2dyYXBoaWNfb3JkZXJcblxuZnVuY3Rpb24gbGV4aWNvZ3JhcGhpYyhhLCBiKSB7XG4gIGlmIChhLnggPT09IGIueCkge1xuICAgIC8vIGRvIGEgY2hlY2sgdG8gc2VlIGlmIHBvaW50cyBpcyAzRCxcbiAgICAvLyBpbiB3aGljaCBjYXNlIGFkZCB5IGVxIGNoZWNrIGFuZCBzb3J0IGJ5IHpcbiAgICBpZiAodHlwZW9mIGEueiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGEueSA9PT0gYi55KSB7XG4gICAgICAgIHJldHVybiBhLnogLSBiLno7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGEueSAtIGIueTtcbiAgfVxuXG4gIHJldHVybiBhLnggLSBiLng7XG59XG4vKipcbiAqIENvbnZleCBIdWxsXG4gKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiAyRCBWZWN0b3JzIHJlcHJlc2VudGluZyB0aGUgY29udmV4IGh1bGwgb2YgYSBzZXQgb2YgMkQgVmVjdG9yc1xuICovXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBjb252ZXggaHVsbCBvZiBhIHNldCBvZiBwb2ludHNcbiAqL1xuXG5mdW5jdGlvbiBjb252ZXhIdWxsKF9wb2ludHMpIHtcbiAgdmFyIHBvaW50cyA9IF9wb2ludHMuc29ydChsZXhpY29ncmFwaGljKTsgLy8gcHV0IHAxIGFuZCBwMiBpbiBhIGxpc3QgbFVwcGVyIHdpdGggcDEgYXMgdGhlIGZpcnN0IHBvaW50XG5cblxuICB2YXIgbFVwcGVyID0gW3BvaW50c1swXSwgcG9pbnRzWzFdXTsgLy8gZm9yIGkgPC0gMyB0byBuXG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBsVXBwZXIucHVzaChwb2ludHNbaV0pOyAvLyB3aGlsZSBsVXBwZXIgY29udGFpbnMgbW9yZSB0aGFuIDIgcG9pbnRzIGFuZCB0aGUgbGFzdCB0aHJlZSBwb2ludHMgaW4gbFVwcGVyIGRvIG5vdCBtYWtlIGEgcmlnaHQgdHVyblxuXG4gICAgd2hpbGUgKGxVcHBlci5sZW5ndGggPiAyICYmIGRvVGhyZWVQb2ludHNNYWtlQVJpZ2h0KF90b0NvbnN1bWFibGVBcnJheShsVXBwZXIuc2xpY2UoLTMpKSkpIHtcbiAgICAgIC8vIGRlbGV0ZSB0aGUgbWlkZGxlIG9mIHRoZSBsYXN0IHRocmVlIHBvaW50cyBmcm9tIGxVcHBlclxuICAgICAgbFVwcGVyLnNwbGljZShsVXBwZXIubGVuZ3RoIC0gMiwgMSk7XG4gICAgfVxuICB9IC8vIHB1dCBwbiBhbmQgcG4tMSBpbiBhIGxpc3QgbExvd2VyIHdpdGggcG4gYXMgdGhlIGZpcnN0IHBvaW50XG5cblxuICB2YXIgbExvd2VyID0gW3BvaW50c1twb2ludHMubGVuZ3RoIC0gMV0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl1dOyAvLyBmb3IgKGkgPC0gbiAtIDIgZG93bnRvIDEpXG5cbiAgZm9yICh2YXIgX2kgPSBwb2ludHMubGVuZ3RoIC0gMzsgX2kgPj0gMDsgX2ktLSkge1xuICAgIC8vIGFwcGVuZCBwaSB0byBsTG93ZXJcbiAgICBsTG93ZXIucHVzaChwb2ludHNbX2ldKTsgLy8gd2hpbGUgbExvd2VyIGNvbnRhaW5zIG1vcmUgdGhhbiAyIHBvaW50cyBhbmQgdGhlIGxhc3QgdGhyZWUgcG9pbnRzIGluIGxMb3dlciBkbyBub3QgbWFrZSBhIHJpZ2h0IHR1cm5cblxuICAgIHdoaWxlIChsTG93ZXIubGVuZ3RoID4gMiAmJiBkb1RocmVlUG9pbnRzTWFrZUFSaWdodChfdG9Db25zdW1hYmxlQXJyYXkobExvd2VyLnNsaWNlKC0zKSkpKSB7XG4gICAgICAvLyBkZWxldGUgdGhlIG1pZGRsZSBvZiB0aGUgbGFzdCB0aHJlZSBwb2ludHMgZnJvbSBsTG93ZXJcbiAgICAgIGxMb3dlci5zcGxpY2UobExvd2VyLmxlbmd0aCAtIDIsIDEpO1xuICAgIH1cbiAgfSAvLyByZW1vdmUgdGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50IGZyb20gbExvd2VyIHRvIGF2b2lkIGR1cGxpY2F0aW9uIG9mIHRoZSBwb2ludHMgd2hlcmUgdGhlIHVwcGVyIGFuZCBsb3dlciBodWxsIG1lZXRcblxuXG4gIGxMb3dlci5zcGxpY2UoMCwgMSk7XG4gIGxMb3dlci5zcGxpY2UobExvd2VyLmxlbmd0aCAtIDEsIDEpOyAvLyBwcmV0dGllci1pZ25vcmVcblxuICB2YXIgYyA9IFtdLmNvbmNhdChsVXBwZXIsIGxMb3dlcik7XG4gIHJldHVybiBjO1xufVxuZnVuY3Rpb24gcmVtYXAoeCwgX3JlZjIsIF9yZWYzKSB7XG4gIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYyLCAyKSxcbiAgICAgIGxvdzEgPSBfcmVmNFswXSxcbiAgICAgIGhpZ2gxID0gX3JlZjRbMV07XG5cbiAgdmFyIF9yZWY1ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgbG93MiA9IF9yZWY1WzBdLFxuICAgICAgaGlnaDIgPSBfcmVmNVsxXTtcblxuICByZXR1cm4gbG93MiArICh4IC0gbG93MSkgKiAoaGlnaDIgLSBsb3cyKSAvIChoaWdoMSAtIGxvdzEpO1xufVxuLyoqXG4gKlxuICogaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3Zzbm1sYWxqZHVcbiAqXG4gKiBFYXNlLWluLW91dCwgZ29lcyB0byAtSW5maW5pdGUgYmVmb3JlIDAgYW5kIEluZmluaXRlIGFmdGVyIDFcbiAqXG4gKiBAcGFyYW0gdFxuICogQHJldHVybnNcbiAqL1xuXG5mdW5jdGlvbiBmYWRlKHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdCAqICh0ICogKHQgKiA2IC0gMTUpICsgMTApO1xufVxuLyoqXG4gKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGxpbmVhcmx5IGludGVycG9sYXRpbmcgYmV0d2VlbiBpbnB1dCBBIGFuZCBpbnB1dCBCIGJ5IGlucHV0IFQuXG4gKlxuICogQHBhcmFtIHYwXG4gKiBAcGFyYW0gdjFcbiAqIEBwYXJhbSB0XG4gKiBAcmV0dXJuc1xuICovXG5cbmZ1bmN0aW9uIGxlcnAodjAsIHYxLCB0KSB7XG4gIHJldHVybiB2MCAqICgxIC0gdCkgKyB2MSAqIHQ7XG59XG4vKipcbiAqXG4gKiBSZXR1cm5zIHRoZSBsaW5lYXIgcGFyYW1ldGVyIHRoYXQgcHJvZHVjZXMgdGhlIGludGVycG9sYW50IHNwZWNpZmllZCBieSBpbnB1dCBUIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgaW5wdXQgQSB0byBpbnB1dCBCLlxuICpcbiAqIEBwYXJhbSB2MFxuICogQHBhcmFtIHYxXG4gKiBAcGFyYW0gdFxuICogQHJldHVybnNcbiAqL1xuXG5mdW5jdGlvbiBpbnZlcnNlTGVycCh2MCwgdjEsIHQpIHtcbiAgcmV0dXJuICh0IC0gdjApIC8gKHYxIC0gdjApO1xufVxuLyoqXG4gKlxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh4LCB5LCB6KSB7XG4gIHZhciBtID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHJldHVybiBbeCAvIG0sIHkgLyBtLCB6IC8gbV07XG59XG4vKipcbiAqXG4gKi9cblxuZnVuY3Rpb24gcG9pbnRPbkN1YmVUb1BvaW50T25TcGhlcmUoeCwgeSwgeikge1xuICB2YXIgeDIgPSB4ICogeDtcbiAgdmFyIHkyID0geSAqIHk7XG4gIHZhciB6MiA9IHogKiB6O1xuICB2YXIgbnggPSB4ICogTWF0aC5zcXJ0KDEgLSAoeTIgKyB6MikgLyAyICsgeTIgKiB6MiAvIDMpO1xuICB2YXIgbnkgPSB5ICogTWF0aC5zcXJ0KDEgLSAoejIgKyB4MikgLyAyICsgejIgKiB4MiAvIDMpO1xuICB2YXIgbnogPSB6ICogTWF0aC5zcXJ0KDEgLSAoeDIgKyB5MikgLyAyICsgeDIgKiB5MiAvIDMpO1xuICByZXR1cm4gW254LCBueSwgbnpdO1xufSAvLyBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE4MDQxOC9jYWxjdWxhdGUtcm90YXRpb24tbWF0cml4LXRvLWFsaWduLXZlY3Rvci1hLXRvLXZlY3Rvci1iLWluLTNkXG5cbi8qKlxuICogR2l2ZSB0d28gdW5pdCB2ZWN0b3JzIGEgYW5kIGIsIHJldHVybnMgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0aGF0IHJvdGF0ZXMgYSBvbnRvIGIuXG4gKlxuICogKi9cblxuZnVuY3Rpb24gcm90YXRlVmVjdG9yT25WZWN0b3IoYSwgYikge1xuICB2YXIgdiA9IG5ldyBWZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKGEsIGIpO1xuICB2YXIgYyA9IGEuZG90KGIpO1xuICB2YXIgaSA9IG5ldyBNYXRyaXgzKCkuaWRlbnRpdHkoKTsgLy8gIHNrZXctc3ltbWV0cmljIGNyb3NzLXByb2R1Y3QgbWF0cml4IG9mIPCdkaMgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2tldy1zeW1tZXRyaWNfbWF0cml4XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuXG4gIHZhciB2eCA9IG5ldyBNYXRyaXgzKCkuc2V0KDAsIC12LnosIHYueSwgdi56LCAwLCAtdi54LCAtdi55LCB2LngsIDApO1xuICB2YXIgdnhzcXVhcmVkID0gbmV3IE1hdHJpeDMoKS5tdWx0aXBseU1hdHJpY2VzKHZ4LCB2eCkubXVsdGlwbHlTY2FsYXIoMSAvICgxICsgYykpO1xuXG4gIHZhciBfZmluYWwgPSBtYXRyaXhTdW0zKG1hdHJpeFN1bTMoaSwgdngpLCB2eHNxdWFyZWQpO1xuXG4gIHJldHVybiBfZmluYWw7XG59IC8vIGNhbGN1bGF0ZSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChpbiByYWRpYW5zKSBmcm9tIHBvaW50IG9uIHVuaXQgc3BoZXJlXG5cbmZ1bmN0aW9uIHBvaW50VG9Db29yZGluYXRlKHgsIHksIHopIHtcbiAgdmFyIGxhdCA9IE1hdGguYXNpbih5KTtcbiAgdmFyIGxvbiA9IE1hdGguYXRhbjIoeCwgLXopO1xuICByZXR1cm4gW2xhdCwgbG9uXTtcbn0gLy8gY2FsY3VsYXRlIHBvaW50IG9uIHVuaXQgc3BoZXJlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb2dpdHVkZSBpbiByYWRpYW5zXG5cbmZ1bmN0aW9uIGNvb3JkaW5hdGVUb1BvaW50KGxhdCwgbG9uKSB7XG4gIHZhciB5ID0gTWF0aC5zaW4obGF0KTtcbiAgdmFyIHIgPSBNYXRoLmNvcyhsYXQpO1xuICB2YXIgeCA9IE1hdGguc2luKGxvbikgKiByO1xuICB2YXIgeiA9IC1NYXRoLmNvcyhsb24pICogcjtcbiAgcmV0dXJuIFt4LCB5LCB6XTtcbn1cbi8qKlxuICogR2l2ZW4gYSBwbGFuZSBhbmQgYSBzZWdtZW50LCByZXR1cm4gdGhlIGludGVyc2VjdGlvbiBwb2ludCBpZiBpdCBleGlzdHMgb3IgbnVsbCBpdCBkb2Vzbid0LlxuICovXG5cbmZ1bmN0aW9uIHBsYW5lU2VnbWVudEludGVyc2VjdGlvbihwbGFuZSwgc2VnbWVudCkge1xuICB2YXIgX3NlZ21lbnQgPSBfc2xpY2VkVG9BcnJheShzZWdtZW50LCAyKSxcbiAgICAgIGEgPSBfc2VnbWVudFswXSxcbiAgICAgIGIgPSBfc2VnbWVudFsxXTtcblxuICB2YXIgbWF0cml4ID0gcm90YXRlVmVjdG9yT25WZWN0b3IocGxhbmUubm9ybWFsLCBuZXcgVmVjdG9yMygwLCAxLCAwKSk7XG4gIHZhciB0ID0gaW52ZXJzZUxlcnAoYS5jbG9uZSgpLmFwcGx5TWF0cml4MyhtYXRyaXgpLnksIGIuY2xvbmUoKS5hcHBseU1hdHJpeDMobWF0cml4KS55LCAwKTtcbiAgcmV0dXJuIG5ldyBWZWN0b3IzKCkubGVycFZlY3RvcnMoYSwgYiwgdCk7XG59XG4vKipcbiAqIEdpdmVuIGEgcGxhbmUgYW5kIGEgcG9pbnQsIHJldHVybiB0aGUgZGlzdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gcG9pbnRUb1BsYW5lRGlzdGFuY2UocCwgcGxhbmUpIHtcbiAgdmFyIGQgPSBwbGFuZS5ub3JtYWwuZG90KHApOyAvLyBUT0RPXG5cbiAgcmV0dXJuIGQ7XG59XG5mdW5jdGlvbiBnZXRJbmRleEZyb20zRChjb29yZHMsIHNpZGVzKSB7XG4gIHZhciBfY29vcmRzID0gX3NsaWNlZFRvQXJyYXkoY29vcmRzLCAzKSxcbiAgICAgIGl4ID0gX2Nvb3Jkc1swXSxcbiAgICAgIGl5ID0gX2Nvb3Jkc1sxXSxcbiAgICAgIGl6ID0gX2Nvb3Jkc1syXTtcblxuICB2YXIgX3NpZGVzID0gX3NsaWNlZFRvQXJyYXkoc2lkZXMsIDIpLFxuICAgICAgcnggPSBfc2lkZXNbMF0sXG4gICAgICByeSA9IF9zaWRlc1sxXTtcblxuICByZXR1cm4gaXogKiByeCAqIHJ5ICsgaXkgKiByeCArIGl4O1xufVxuZnVuY3Rpb24gZ2V0M0RGcm9tSW5kZXgoaW5kZXgsIHNpemUpIHtcbiAgdmFyIF9zaXplID0gX3NsaWNlZFRvQXJyYXkoc2l6ZSwgMiksXG4gICAgICByeCA9IF9zaXplWzBdLFxuICAgICAgcnkgPSBfc2l6ZVsxXTtcblxuICB2YXIgYSA9IHJ4ICogcnk7XG4gIHZhciB6ID0gaW5kZXggLyBhO1xuICB2YXIgYiA9IGluZGV4IC0gYSAqIHo7XG4gIHZhciB5ID0gYiAvIHJ4O1xuICB2YXIgeCA9IGIgJSByeDtcbiAgcmV0dXJuIFt4LCB5LCB6XTtcbn1cbmZ1bmN0aW9uIGdldEluZGV4RnJvbTJEKGNvb3Jkcywgc2l6ZSkge1xuICByZXR1cm4gY29vcmRzWzBdICsgc2l6ZVswXSAqIGNvb3Jkc1sxXTtcbn1cbmZ1bmN0aW9uIGdldDJERnJvbUluZGV4KGluZGV4LCBjb2x1bW5zKSB7XG4gIHZhciB4ID0gaW5kZXggJSBjb2x1bW5zO1xuICB2YXIgeSA9IE1hdGguZmxvb3IoaW5kZXggLyBjb2x1bW5zKTtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxudmFyIG1pc2MgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgY2xhbXA6IGNsYW1wLFxuICBkZWx0YUFuZ2xlOiBkZWx0YUFuZ2xlLFxuICBkZWdUb1JhZDogZGVnVG9SYWQsXG4gIHJhZFRvRGVnOiByYWRUb0RlZyxcbiAgZmlib25hY2NpT25TcGhlcmU6IGZpYm9uYWNjaU9uU3BoZXJlLFxuICB2ZWN0b3JFcXVhbHM6IHZlY3RvckVxdWFscyxcbiAgbGV4aWNvZ3JhcGhpYzogbGV4aWNvZ3JhcGhpYyxcbiAgY29udmV4SHVsbDogY29udmV4SHVsbCxcbiAgcmVtYXA6IHJlbWFwLFxuICBmYWRlOiBmYWRlLFxuICBsZXJwOiBsZXJwLFxuICBpbnZlcnNlTGVycDogaW52ZXJzZUxlcnAsXG4gIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuICBwb2ludE9uQ3ViZVRvUG9pbnRPblNwaGVyZTogcG9pbnRPbkN1YmVUb1BvaW50T25TcGhlcmUsXG4gIHJvdGF0ZVZlY3Rvck9uVmVjdG9yOiByb3RhdGVWZWN0b3JPblZlY3RvcixcbiAgcG9pbnRUb0Nvb3JkaW5hdGU6IHBvaW50VG9Db29yZGluYXRlLFxuICBjb29yZGluYXRlVG9Qb2ludDogY29vcmRpbmF0ZVRvUG9pbnQsXG4gIHBsYW5lU2VnbWVudEludGVyc2VjdGlvbjogcGxhbmVTZWdtZW50SW50ZXJzZWN0aW9uLFxuICBwb2ludFRvUGxhbmVEaXN0YW5jZTogcG9pbnRUb1BsYW5lRGlzdGFuY2UsXG4gIGdldEluZGV4RnJvbTNEOiBnZXRJbmRleEZyb20zRCxcbiAgZ2V0M0RGcm9tSW5kZXg6IGdldDNERnJvbUluZGV4LFxuICBnZXRJbmRleEZyb20yRDogZ2V0SW5kZXhGcm9tMkQsXG4gIGdldDJERnJvbUluZGV4OiBnZXQyREZyb21JbmRleFxufSk7XG5cbmV4cG9ydCB7IGRlZ1RvUmFkIGFzIGEsIGZpYm9uYWNjaU9uU3BoZXJlIGFzIGIsIGNsYW1wIGFzIGMsIGRlbHRhQW5nbGUgYXMgZCwgbGV4aWNvZ3JhcGhpYyBhcyBlLCBmYWRlIGFzIGYsIGNvbnZleEh1bGwgYXMgZywgcmVtYXAgYXMgaCwgaW52ZXJzZUxlcnAgYXMgaSwgcm90YXRlVmVjdG9yT25WZWN0b3IgYXMgaiwgcG9pbnRUb0Nvb3JkaW5hdGUgYXMgaywgbGVycCBhcyBsLCBtaXNjIGFzIG0sIG5vcm1hbGl6ZSBhcyBuLCBjb29yZGluYXRlVG9Qb2ludCBhcyBvLCBwb2ludE9uQ3ViZVRvUG9pbnRPblNwaGVyZSBhcyBwLCBwbGFuZVNlZ21lbnRJbnRlcnNlY3Rpb24gYXMgcSwgcmFkVG9EZWcgYXMgciwgcG9pbnRUb1BsYW5lRGlzdGFuY2UgYXMgcywgZ2V0SW5kZXhGcm9tM0QgYXMgdCwgZ2V0M0RGcm9tSW5kZXggYXMgdSwgdmVjdG9yRXF1YWxzIGFzIHYsIGdldEluZGV4RnJvbTJEIGFzIHcsIGdldDJERnJvbUluZGV4IGFzIHggfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/misc-7d870b3c.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/objectSpread2-284232a6.esm.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/objectSpread2-284232a6.esm.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _objectSpread2),\n/* harmony export */   a: () => (/* binding */ _defineProperty)\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3Qvb2JqZWN0U3ByZWFkMi0yODQyMzJhNi5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVxRCIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9wb3N0cHJvY2Vzc2luZy9ub2RlX21vZHVsZXMvbWFhdGgvZGlzdC9vYmplY3RTcHJlYWQyLTI4NDIzMmE2LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IHsgX29iamVjdFNwcmVhZDIgYXMgXywgX2RlZmluZVByb3BlcnR5IGFzIGEgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/objectSpread2-284232a6.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/three-eb2ad8c0.esm.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/three-eb2ad8c0.esm.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   b: () => (/* binding */ bufferToVectors),\n/* harmony export */   t: () => (/* binding */ three),\n/* harmony export */   v: () => (/* binding */ vectorsToBuffer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\n\n/**\n * Helpers for converting buffers to and from Three.js objects\n */\n\n/**\n * Convents passed buffer of passed stride to an array of vectors with the correct length.\n *\n * @param buffer\n * @param stride\n * @returns\n */\nfunction bufferToVectors(buffer) {\n  var stride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  var p = [];\n\n  for (var i = 0, j = 0; i < buffer.length; i += stride, j++) {\n    if (stride === 3) {\n      p[j] = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);\n    } else {\n      p[j] = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(buffer[i], buffer[i + 1]);\n    }\n  }\n\n  return p;\n}\n/**\n * Transforms a passed Vector2 or Vector3 array to a points buffer\n *\n * @param vectorArray\n * @returns\n */\n\nfunction vectorsToBuffer(vectorArray) {\n  var l = vectorArray.length;\n  var stride = vectorArray[0].hasOwnProperty(\"z\") ? 3 : 2;\n  var buffer = new Float32Array(l * stride);\n\n  for (var i = 0; i < l; i++) {\n    var j = i * stride;\n    buffer[j] = vectorArray[i].x;\n    buffer[j + 1] = vectorArray[i].y;\n\n    if (stride === 3) {\n      buffer[j + 2] = vectorArray[i].z;\n    }\n  }\n\n  return buffer;\n}\n\nvar three = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  bufferToVectors: bufferToVectors,\n  vectorsToBuffer: vectorsToBuffer\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvdGhyZWUtZWIyYWQ4YzAuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0EsaUJBQWlCLDBDQUFPO0FBQ3hCLE1BQU07QUFDTixpQkFBaUIsMENBQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFaUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvdGhyZWUtZWIyYWQ4YzAuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjMsIFZlY3RvcjIgfSBmcm9tICd0aHJlZSc7XG5cbi8qKlxuICogSGVscGVycyBmb3IgY29udmVydGluZyBidWZmZXJzIHRvIGFuZCBmcm9tIFRocmVlLmpzIG9iamVjdHNcbiAqL1xuXG4vKipcbiAqIENvbnZlbnRzIHBhc3NlZCBidWZmZXIgb2YgcGFzc2VkIHN0cmlkZSB0byBhbiBhcnJheSBvZiB2ZWN0b3JzIHdpdGggdGhlIGNvcnJlY3QgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSBidWZmZXJcbiAqIEBwYXJhbSBzdHJpZGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvVmVjdG9ycyhidWZmZXIpIHtcbiAgdmFyIHN0cmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMztcbiAgdmFyIHAgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IHN0cmlkZSwgaisrKSB7XG4gICAgaWYgKHN0cmlkZSA9PT0gMykge1xuICAgICAgcFtqXSA9IG5ldyBWZWN0b3IzKGJ1ZmZlcltpXSwgYnVmZmVyW2kgKyAxXSwgYnVmZmVyW2kgKyAyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBbal0gPSBuZXcgVmVjdG9yMihidWZmZXJbaV0sIGJ1ZmZlcltpICsgMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgcGFzc2VkIFZlY3RvcjIgb3IgVmVjdG9yMyBhcnJheSB0byBhIHBvaW50cyBidWZmZXJcbiAqXG4gKiBAcGFyYW0gdmVjdG9yQXJyYXlcbiAqIEByZXR1cm5zXG4gKi9cblxuZnVuY3Rpb24gdmVjdG9yc1RvQnVmZmVyKHZlY3RvckFycmF5KSB7XG4gIHZhciBsID0gdmVjdG9yQXJyYXkubGVuZ3RoO1xuICB2YXIgc3RyaWRlID0gdmVjdG9yQXJyYXlbMF0uaGFzT3duUHJvcGVydHkoXCJ6XCIpID8gMyA6IDI7XG4gIHZhciBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGwgKiBzdHJpZGUpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGogPSBpICogc3RyaWRlO1xuICAgIGJ1ZmZlcltqXSA9IHZlY3RvckFycmF5W2ldLng7XG4gICAgYnVmZmVyW2ogKyAxXSA9IHZlY3RvckFycmF5W2ldLnk7XG5cbiAgICBpZiAoc3RyaWRlID09PSAzKSB7XG4gICAgICBidWZmZXJbaiArIDJdID0gdmVjdG9yQXJyYXlbaV0uejtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufVxuXG52YXIgdGhyZWUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYnVmZmVyVG9WZWN0b3JzOiBidWZmZXJUb1ZlY3RvcnMsXG4gIHZlY3RvcnNUb0J1ZmZlcjogdmVjdG9yc1RvQnVmZmVyXG59KTtcblxuZXhwb3J0IHsgYnVmZmVyVG9WZWN0b3JzIGFzIGIsIHRocmVlIGFzIHQsIHZlY3RvcnNUb0J1ZmZlciBhcyB2IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/three-eb2ad8c0.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/triangle-b62b9067.esm.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/triangle-b62b9067.esm.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _slicedToArray),\n/* harmony export */   a: () => (/* binding */ _toConsumableArray),\n/* harmony export */   b: () => (/* binding */ triangleDeterminant),\n/* harmony export */   c: () => (/* binding */ arePointsCollinear),\n/* harmony export */   d: () => (/* binding */ doThreePointsMakeARight),\n/* harmony export */   e: () => (/* binding */ isTriangleClockwise),\n/* harmony export */   f: () => (/* binding */ isPointInCircumcircle),\n/* harmony export */   g: () => (/* binding */ getCircumcircle),\n/* harmony export */   i: () => (/* binding */ isPointInTriangle),\n/* harmony export */   t: () => (/* binding */ triangle)\n/* harmony export */ });\n/* harmony import */ var _isNativeReflectConstruct_5594d075_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isNativeReflectConstruct-5594d075.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/isNativeReflectConstruct-5594d075.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix-baa530bf.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/matrix-baa530bf.esm.js\");\n\n\n\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _construct(Parent, args, Class) {\n  if ((0,_isNativeReflectConstruct_5594d075_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) (0,_isNativeReflectConstruct_5594d075_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\n/**\n *\n * @param point\n *\n * @param triangle\n *\n * @returns {boolean} true if the point is in the triangle\n *\n * TODO: Find explainer\n */\nfunction isPointInTriangle(point, triangle) {\n  var _triangle$ = _slicedToArray(triangle[0], 2),\n      ax = _triangle$[0],\n      ay = _triangle$[1];\n\n  var _triangle$2 = _slicedToArray(triangle[1], 2),\n      bx = _triangle$2[0],\n      by = _triangle$2[1];\n\n  var _triangle$3 = _slicedToArray(triangle[2], 2),\n      cx = _triangle$3[0],\n      cy = _triangle$3[1];\n\n  var _point = _slicedToArray(point, 2),\n      px = _point[0],\n      py = _point[1]; // TODO Sub with static calc\n\n\n  var matrix = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4(); // prettier-ignore\n\n  matrix.set(ax, ay, ax * ax + ay * ay, 1, bx, by, bx * bx + by * by, 1, cx, cy, cx * cx + cy * cy, 1, px, py, px * px + py * py, 1);\n  return matrix.determinant() <= 0;\n}\nfunction triangleDeterminant(triangle) {\n  var _triangle$4 = _slicedToArray(triangle[0], 2),\n      x1 = _triangle$4[0],\n      y1 = _triangle$4[1];\n\n  var _triangle$5 = _slicedToArray(triangle[1], 2),\n      x2 = _triangle$5[0],\n      y2 = _triangle$5[1];\n\n  var _triangle$6 = _slicedToArray(triangle[2], 2),\n      x3 = _triangle$6[0],\n      y3 = _triangle$6[1]; // prettier-ignore\n\n\n  return (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(x1, y1, 1, x2, y2, 1, x3, y3, 1);\n}\n/**\n * Uses triangle area determinant to check if 3 points are collinear.\n * If they are, they can't make a triangle, so the determinant will be 0!\n *\n *      0     1     2\n * ─────■─────■─────■\n *\n *\n * Fun fact, you can use this same determinant to check the order of the points in the triangle\n *\n * NOTE: Should this use a buffer instead? NOTE: Should this use a buffer instead? [x0, y0, x1, y1, x2, y2]?\n *\n */\n\nfunction arePointsCollinear(points) {\n  return triangleDeterminant(points) === 0;\n} // TODO This is the same principle as the prev function, find a way to make it have sense\n\nfunction isTriangleClockwise(triangle) {\n  return triangleDeterminant(triangle) < 0;\n}\n/**\n \nThe circumcircle is a circle touching all the vertices of a triangle or polygon.\n\n             ┌───┐             \n             │ B │             \n             └───┘             \n           .───●───.           \n        ,─'   ╱ ╲   '─.        \n      ,'     ╱   ╲     `.      \n     ╱      ╱     ╲      ╲     \n    ;      ╱       ╲      :    \n    │     ╱         ╲     │    \n    │    ╱           ╲    │    \n    :   ╱             ╲   ;    \n     ╲ ╱               ╲ ╱     \n┌───┐ ●─────────────────● ┌───┐\n│ A │  `.             ,'  │ C │\n└───┘    '─.       ,─'    └───┘\n            `─────'                         \n */\n\n/**\n *\n * @param triangle\n *\n * @returns {number} circumcircle\n */\n// https://math.stackexchange.com/a/1460096\n\nfunction getCircumcircle(triangle) {\n  // TS-TODO the next few lines are ignored because the types aren't current to the change in vectors (that can now be iterated)\n  // @ts-ignore\n  var _triangle$7 = _slicedToArray(triangle[0], 2),\n      ax = _triangle$7[0],\n      ay = _triangle$7[1]; // @ts-ignore\n\n\n  var _triangle$8 = _slicedToArray(triangle[1], 2),\n      bx = _triangle$8[0],\n      by = _triangle$8[1]; // @ts-ignore\n\n\n  var _triangle$9 = _slicedToArray(triangle[2], 2),\n      cx = _triangle$9[0],\n      cy = _triangle$9[1];\n\n  if (arePointsCollinear(triangle)) return null; // points are collinear\n\n  var m = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4(); // prettier-ignore\n\n  m.set(1, 1, 1, 1, ax * ax + ay * ay, ax, ay, 1, bx * bx + by * by, bx, by, 1, cx * cx + cy * cy, cx, cy, 1);\n  var m11 = (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(m, 1, 1);\n  var m13 = (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(m, 1, 3);\n  var m12 = (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(m, 1, 2);\n  var m14 = (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(m, 1, 4);\n  var x0 = 0.5 * (m12 / m11);\n  var y0 = 0.5 * (m13 / m11);\n  var r2 = x0 * x0 + y0 * y0 + m14 / m11;\n  return {\n    x: Math.abs(x0) === 0 ? 0 : x0,\n    y: Math.abs(y0) === 0 ? 0 : -y0,\n    r: Math.sqrt(r2)\n  };\n} // https://stackoverflow.com/questions/39984709/how-can-i-check-wether-a-point-is-inside-the-circumcircle-of-3-points\n\nfunction isPointInCircumcircle(point, triangle) {\n  var _ref = Array.isArray(triangle[0]) ? triangle[0] : triangle[0].toArray(),\n      _ref2 = _slicedToArray(_ref, 2),\n      ax = _ref2[0],\n      ay = _ref2[1];\n\n  var _ref3 = Array.isArray(triangle[1]) ? triangle[1] : triangle[1].toArray(),\n      _ref4 = _slicedToArray(_ref3, 2),\n      bx = _ref4[0],\n      by = _ref4[1];\n\n  var _ref5 = Array.isArray(triangle[2]) ? triangle[2] : triangle[2].toArray(),\n      _ref6 = _slicedToArray(_ref5, 2),\n      cx = _ref6[0],\n      cy = _ref6[1];\n\n  var _point2 = _slicedToArray(point, 2),\n      px = _point2[0],\n      py = _point2[1];\n\n  if (arePointsCollinear(triangle)) throw new Error(\"Collinear points don't form a triangle\");\n  /**\n          | ax-px, ay-py, (ax-px)² + (ay-py)² |\n    det = | bx-px, by-py, (bx-px)² + (by-py)² |\n          | cx-px, cy-py, (cx-px)² + (cy-py)² |\n  */\n\n  var x1mpx = ax - px;\n  var aympy = ay - py;\n  var bxmpx = bx - px;\n  var bympy = by - py;\n  var cxmpx = cx - px;\n  var cympy = cy - py; // prettier-ignore\n\n  var d = (0,_matrix_baa530bf_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(x1mpx, aympy, x1mpx * x1mpx + aympy * aympy, bxmpx, bympy, bxmpx * bxmpx + bympy * bympy, cxmpx, cympy, cxmpx * cxmpx + cympy * cympy); // if d is 0, the point is on C\n\n  if (d === 0) {\n    return true;\n  }\n\n  return !isTriangleClockwise(triangle) ? d > 0 : d < 0;\n} // From https://algorithmtutor.com/Computational-Geometry/Determining-if-two-consecutive-segments-turn-left-or-right/\n\nvar mv1 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();\nvar mv2 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();\n/**\n \n     ╱      ╲     \n    ╱        ╲    \n   ▕          ▏   \n                  \n right      left  \n\n * NOTE: Should this use a buffer instead? [x0, y0, x1, y1]?\n */\n\nfunction doThreePointsMakeARight(points) {\n  var _points$map = points.map(function (p) {\n    if (Array.isArray(p)) {\n      return _construct(three__WEBPACK_IMPORTED_MODULE_2__.Vector2, _toConsumableArray(p));\n    }\n\n    return p;\n  }),\n      _points$map2 = _slicedToArray(_points$map, 3),\n      p1 = _points$map2[0],\n      p2 = _points$map2[1],\n      p3 = _points$map2[2];\n\n  if (arePointsCollinear(points)) return false; // @ts-ignore\n\n  var p2p1 = mv1.subVectors(p2, p1); // @ts-ignore\n\n  var p3p1 = mv2.subVectors(p3, p1);\n  var cross = p3p1.cross(p2p1);\n  return cross > 0;\n}\n\nvar triangle = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  isPointInTriangle: isPointInTriangle,\n  triangleDeterminant: triangleDeterminant,\n  arePointsCollinear: arePointsCollinear,\n  isTriangleClockwise: isTriangleClockwise,\n  getCircumcircle: getCircumcircle,\n  isPointInCircumcircle: isPointInCircumcircle,\n  doThreePointsMakeARight: doThreePointsMakeARight\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvdHJpYW5nbGUtYjYyYjkwNjcuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0g7QUFDekU7QUFDbUM7O0FBRTVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDRFQUF5QjtBQUMvQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRFQUFlO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7OztBQUd0QixtQkFBbUIsMENBQU8sSUFBSTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7OztBQUczQixTQUFTLDBEQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7OztBQUczQjtBQUNBO0FBQ0EsMkJBQTJCOzs7QUFHM0I7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDs7QUFFakQsY0FBYywwQ0FBTyxJQUFJOztBQUV6QjtBQUNBLFlBQVksMERBQVE7QUFDcEIsWUFBWSwwREFBUTtBQUNwQixZQUFZLDBEQUFRO0FBQ3BCLFlBQVksMERBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCLFVBQVUsMERBQVkseUlBQXlJOztBQUUvSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGLGNBQWMsMENBQU87QUFDckIsY0FBYywwQ0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQ0FBTztBQUMvQjs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7O0FBRWhELHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFMlAiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvdHJpYW5nbGUtYjYyYjkwNjcuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGEgYXMgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCwgXyBhcyBfc2V0UHJvdG90eXBlT2YgfSBmcm9tICcuL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC01NTk0ZDA3NS5lc20uanMnO1xuaW1wb3J0IHsgVmVjdG9yMiwgTWF0cml4NCB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IGQgYXMgZGV0ZXJtaW5hbnQzLCBnIGFzIGdldE1pbm9yIH0gZnJvbSAnLi9tYXRyaXgtYmFhNTMwYmYuZXNtLmpzJztcblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHBvaW50XG4gKlxuICogQHBhcmFtIHRyaWFuZ2xlXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHBvaW50IGlzIGluIHRoZSB0cmlhbmdsZVxuICpcbiAqIFRPRE86IEZpbmQgZXhwbGFpbmVyXG4gKi9cbmZ1bmN0aW9uIGlzUG9pbnRJblRyaWFuZ2xlKHBvaW50LCB0cmlhbmdsZSkge1xuICB2YXIgX3RyaWFuZ2xlJCA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzBdLCAyKSxcbiAgICAgIGF4ID0gX3RyaWFuZ2xlJFswXSxcbiAgICAgIGF5ID0gX3RyaWFuZ2xlJFsxXTtcblxuICB2YXIgX3RyaWFuZ2xlJDIgPSBfc2xpY2VkVG9BcnJheSh0cmlhbmdsZVsxXSwgMiksXG4gICAgICBieCA9IF90cmlhbmdsZSQyWzBdLFxuICAgICAgYnkgPSBfdHJpYW5nbGUkMlsxXTtcblxuICB2YXIgX3RyaWFuZ2xlJDMgPSBfc2xpY2VkVG9BcnJheSh0cmlhbmdsZVsyXSwgMiksXG4gICAgICBjeCA9IF90cmlhbmdsZSQzWzBdLFxuICAgICAgY3kgPSBfdHJpYW5nbGUkM1sxXTtcblxuICB2YXIgX3BvaW50ID0gX3NsaWNlZFRvQXJyYXkocG9pbnQsIDIpLFxuICAgICAgcHggPSBfcG9pbnRbMF0sXG4gICAgICBweSA9IF9wb2ludFsxXTsgLy8gVE9ETyBTdWIgd2l0aCBzdGF0aWMgY2FsY1xuXG5cbiAgdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7IC8vIHByZXR0aWVyLWlnbm9yZVxuXG4gIG1hdHJpeC5zZXQoYXgsIGF5LCBheCAqIGF4ICsgYXkgKiBheSwgMSwgYngsIGJ5LCBieCAqIGJ4ICsgYnkgKiBieSwgMSwgY3gsIGN5LCBjeCAqIGN4ICsgY3kgKiBjeSwgMSwgcHgsIHB5LCBweCAqIHB4ICsgcHkgKiBweSwgMSk7XG4gIHJldHVybiBtYXRyaXguZGV0ZXJtaW5hbnQoKSA8PSAwO1xufVxuZnVuY3Rpb24gdHJpYW5nbGVEZXRlcm1pbmFudCh0cmlhbmdsZSkge1xuICB2YXIgX3RyaWFuZ2xlJDQgPSBfc2xpY2VkVG9BcnJheSh0cmlhbmdsZVswXSwgMiksXG4gICAgICB4MSA9IF90cmlhbmdsZSQ0WzBdLFxuICAgICAgeTEgPSBfdHJpYW5nbGUkNFsxXTtcblxuICB2YXIgX3RyaWFuZ2xlJDUgPSBfc2xpY2VkVG9BcnJheSh0cmlhbmdsZVsxXSwgMiksXG4gICAgICB4MiA9IF90cmlhbmdsZSQ1WzBdLFxuICAgICAgeTIgPSBfdHJpYW5nbGUkNVsxXTtcblxuICB2YXIgX3RyaWFuZ2xlJDYgPSBfc2xpY2VkVG9BcnJheSh0cmlhbmdsZVsyXSwgMiksXG4gICAgICB4MyA9IF90cmlhbmdsZSQ2WzBdLFxuICAgICAgeTMgPSBfdHJpYW5nbGUkNlsxXTsgLy8gcHJldHRpZXItaWdub3JlXG5cblxuICByZXR1cm4gZGV0ZXJtaW5hbnQzKHgxLCB5MSwgMSwgeDIsIHkyLCAxLCB4MywgeTMsIDEpO1xufVxuLyoqXG4gKiBVc2VzIHRyaWFuZ2xlIGFyZWEgZGV0ZXJtaW5hbnQgdG8gY2hlY2sgaWYgMyBwb2ludHMgYXJlIGNvbGxpbmVhci5cbiAqIElmIHRoZXkgYXJlLCB0aGV5IGNhbid0IG1ha2UgYSB0cmlhbmdsZSwgc28gdGhlIGRldGVybWluYW50IHdpbGwgYmUgMCFcbiAqXG4gKiAgICAgIDAgICAgIDEgICAgIDJcbiAqIOKUgOKUgOKUgOKUgOKUgOKWoOKUgOKUgOKUgOKUgOKUgOKWoOKUgOKUgOKUgOKUgOKUgOKWoFxuICpcbiAqXG4gKiBGdW4gZmFjdCwgeW91IGNhbiB1c2UgdGhpcyBzYW1lIGRldGVybWluYW50IHRvIGNoZWNrIHRoZSBvcmRlciBvZiB0aGUgcG9pbnRzIGluIHRoZSB0cmlhbmdsZVxuICpcbiAqIE5PVEU6IFNob3VsZCB0aGlzIHVzZSBhIGJ1ZmZlciBpbnN0ZWFkPyBOT1RFOiBTaG91bGQgdGhpcyB1c2UgYSBidWZmZXIgaW5zdGVhZD8gW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTJdP1xuICpcbiAqL1xuXG5mdW5jdGlvbiBhcmVQb2ludHNDb2xsaW5lYXIocG9pbnRzKSB7XG4gIHJldHVybiB0cmlhbmdsZURldGVybWluYW50KHBvaW50cykgPT09IDA7XG59IC8vIFRPRE8gVGhpcyBpcyB0aGUgc2FtZSBwcmluY2lwbGUgYXMgdGhlIHByZXYgZnVuY3Rpb24sIGZpbmQgYSB3YXkgdG8gbWFrZSBpdCBoYXZlIHNlbnNlXG5cbmZ1bmN0aW9uIGlzVHJpYW5nbGVDbG9ja3dpc2UodHJpYW5nbGUpIHtcbiAgcmV0dXJuIHRyaWFuZ2xlRGV0ZXJtaW5hbnQodHJpYW5nbGUpIDwgMDtcbn1cbi8qKlxuIFxuVGhlIGNpcmN1bWNpcmNsZSBpcyBhIGNpcmNsZSB0b3VjaGluZyBhbGwgdGhlIHZlcnRpY2VzIG9mIGEgdHJpYW5nbGUgb3IgcG9seWdvbi5cblxuICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkCAgICAgICAgICAgICBcbiAgICAgICAgICAgICDilIIgQiDilIIgICAgICAgICAgICAgXG4gICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYICAgICAgICAgICAgIFxuICAgICAgICAgICAu4pSA4pSA4pSA4peP4pSA4pSA4pSALiAgICAgICAgICAgXG4gICAgICAgICzilIAnICAg4pWxIOKVsiAgICfilIAuICAgICAgICBcbiAgICAgICwnICAgICDilbEgICDilbIgICAgIGAuICAgICAgXG4gICAgIOKVsSAgICAgIOKVsSAgICAg4pWyICAgICAg4pWyICAgICBcbiAgICA7ICAgICAg4pWxICAgICAgIOKVsiAgICAgIDogICAgXG4gICAg4pSCICAgICDilbEgICAgICAgICDilbIgICAgIOKUgiAgICBcbiAgICDilIIgICAg4pWxICAgICAgICAgICDilbIgICAg4pSCICAgIFxuICAgIDogICDilbEgICAgICAgICAgICAg4pWyICAgOyAgICBcbiAgICAg4pWyIOKVsSAgICAgICAgICAgICAgIOKVsiDilbEgICAgIFxu4pSM4pSA4pSA4pSA4pSQIOKXj+KUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKXjyDilIzilIDilIDilIDilJBcbuKUgiBBIOKUgiAgYC4gICAgICAgICAgICAgLCcgIOKUgiBDIOKUglxu4pSU4pSA4pSA4pSA4pSYICAgICfilIAuICAgICAgICzilIAnICAgIOKUlOKUgOKUgOKUgOKUmFxuICAgICAgICAgICAgYOKUgOKUgOKUgOKUgOKUgCcgICAgICAgICAgICAgICAgICAgICAgICAgXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHRyaWFuZ2xlXG4gKlxuICogQHJldHVybnMge251bWJlcn0gY2lyY3VtY2lyY2xlXG4gKi9cbi8vIGh0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9hLzE0NjAwOTZcblxuZnVuY3Rpb24gZ2V0Q2lyY3VtY2lyY2xlKHRyaWFuZ2xlKSB7XG4gIC8vIFRTLVRPRE8gdGhlIG5leHQgZmV3IGxpbmVzIGFyZSBpZ25vcmVkIGJlY2F1c2UgdGhlIHR5cGVzIGFyZW4ndCBjdXJyZW50IHRvIHRoZSBjaGFuZ2UgaW4gdmVjdG9ycyAodGhhdCBjYW4gbm93IGJlIGl0ZXJhdGVkKVxuICAvLyBAdHMtaWdub3JlXG4gIHZhciBfdHJpYW5nbGUkNyA9IF9zbGljZWRUb0FycmF5KHRyaWFuZ2xlWzBdLCAyKSxcbiAgICAgIGF4ID0gX3RyaWFuZ2xlJDdbMF0sXG4gICAgICBheSA9IF90cmlhbmdsZSQ3WzFdOyAvLyBAdHMtaWdub3JlXG5cblxuICB2YXIgX3RyaWFuZ2xlJDggPSBfc2xpY2VkVG9BcnJheSh0cmlhbmdsZVsxXSwgMiksXG4gICAgICBieCA9IF90cmlhbmdsZSQ4WzBdLFxuICAgICAgYnkgPSBfdHJpYW5nbGUkOFsxXTsgLy8gQHRzLWlnbm9yZVxuXG5cbiAgdmFyIF90cmlhbmdsZSQ5ID0gX3NsaWNlZFRvQXJyYXkodHJpYW5nbGVbMl0sIDIpLFxuICAgICAgY3ggPSBfdHJpYW5nbGUkOVswXSxcbiAgICAgIGN5ID0gX3RyaWFuZ2xlJDlbMV07XG5cbiAgaWYgKGFyZVBvaW50c0NvbGxpbmVhcih0cmlhbmdsZSkpIHJldHVybiBudWxsOyAvLyBwb2ludHMgYXJlIGNvbGxpbmVhclxuXG4gIHZhciBtID0gbmV3IE1hdHJpeDQoKTsgLy8gcHJldHRpZXItaWdub3JlXG5cbiAgbS5zZXQoMSwgMSwgMSwgMSwgYXggKiBheCArIGF5ICogYXksIGF4LCBheSwgMSwgYnggKiBieCArIGJ5ICogYnksIGJ4LCBieSwgMSwgY3ggKiBjeCArIGN5ICogY3ksIGN4LCBjeSwgMSk7XG4gIHZhciBtMTEgPSBnZXRNaW5vcihtLCAxLCAxKTtcbiAgdmFyIG0xMyA9IGdldE1pbm9yKG0sIDEsIDMpO1xuICB2YXIgbTEyID0gZ2V0TWlub3IobSwgMSwgMik7XG4gIHZhciBtMTQgPSBnZXRNaW5vcihtLCAxLCA0KTtcbiAgdmFyIHgwID0gMC41ICogKG0xMiAvIG0xMSk7XG4gIHZhciB5MCA9IDAuNSAqIChtMTMgLyBtMTEpO1xuICB2YXIgcjIgPSB4MCAqIHgwICsgeTAgKiB5MCArIG0xNCAvIG0xMTtcbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLmFicyh4MCkgPT09IDAgPyAwIDogeDAsXG4gICAgeTogTWF0aC5hYnMoeTApID09PSAwID8gMCA6IC15MCxcbiAgICByOiBNYXRoLnNxcnQocjIpXG4gIH07XG59IC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM5OTg0NzA5L2hvdy1jYW4taS1jaGVjay13ZXRoZXItYS1wb2ludC1pcy1pbnNpZGUtdGhlLWNpcmN1bWNpcmNsZS1vZi0zLXBvaW50c1xuXG5mdW5jdGlvbiBpc1BvaW50SW5DaXJjdW1jaXJjbGUocG9pbnQsIHRyaWFuZ2xlKSB7XG4gIHZhciBfcmVmID0gQXJyYXkuaXNBcnJheSh0cmlhbmdsZVswXSkgPyB0cmlhbmdsZVswXSA6IHRyaWFuZ2xlWzBdLnRvQXJyYXkoKSxcbiAgICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICBheCA9IF9yZWYyWzBdLFxuICAgICAgYXkgPSBfcmVmMlsxXTtcblxuICB2YXIgX3JlZjMgPSBBcnJheS5pc0FycmF5KHRyaWFuZ2xlWzFdKSA/IHRyaWFuZ2xlWzFdIDogdHJpYW5nbGVbMV0udG9BcnJheSgpLFxuICAgICAgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICBieCA9IF9yZWY0WzBdLFxuICAgICAgYnkgPSBfcmVmNFsxXTtcblxuICB2YXIgX3JlZjUgPSBBcnJheS5pc0FycmF5KHRyaWFuZ2xlWzJdKSA/IHRyaWFuZ2xlWzJdIDogdHJpYW5nbGVbMl0udG9BcnJheSgpLFxuICAgICAgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMiksXG4gICAgICBjeCA9IF9yZWY2WzBdLFxuICAgICAgY3kgPSBfcmVmNlsxXTtcblxuICB2YXIgX3BvaW50MiA9IF9zbGljZWRUb0FycmF5KHBvaW50LCAyKSxcbiAgICAgIHB4ID0gX3BvaW50MlswXSxcbiAgICAgIHB5ID0gX3BvaW50MlsxXTtcblxuICBpZiAoYXJlUG9pbnRzQ29sbGluZWFyKHRyaWFuZ2xlKSkgdGhyb3cgbmV3IEVycm9yKFwiQ29sbGluZWFyIHBvaW50cyBkb24ndCBmb3JtIGEgdHJpYW5nbGVcIik7XG4gIC8qKlxuICAgICAgICAgIHwgYXgtcHgsIGF5LXB5LCAoYXgtcHgpwrIgKyAoYXktcHkpwrIgfFxuICAgIGRldCA9IHwgYngtcHgsIGJ5LXB5LCAoYngtcHgpwrIgKyAoYnktcHkpwrIgfFxuICAgICAgICAgIHwgY3gtcHgsIGN5LXB5LCAoY3gtcHgpwrIgKyAoY3ktcHkpwrIgfFxuICAqL1xuXG4gIHZhciB4MW1weCA9IGF4IC0gcHg7XG4gIHZhciBheW1weSA9IGF5IC0gcHk7XG4gIHZhciBieG1weCA9IGJ4IC0gcHg7XG4gIHZhciBieW1weSA9IGJ5IC0gcHk7XG4gIHZhciBjeG1weCA9IGN4IC0gcHg7XG4gIHZhciBjeW1weSA9IGN5IC0gcHk7IC8vIHByZXR0aWVyLWlnbm9yZVxuXG4gIHZhciBkID0gZGV0ZXJtaW5hbnQzKHgxbXB4LCBheW1weSwgeDFtcHggKiB4MW1weCArIGF5bXB5ICogYXltcHksIGJ4bXB4LCBieW1weSwgYnhtcHggKiBieG1weCArIGJ5bXB5ICogYnltcHksIGN4bXB4LCBjeW1weSwgY3htcHggKiBjeG1weCArIGN5bXB5ICogY3ltcHkpOyAvLyBpZiBkIGlzIDAsIHRoZSBwb2ludCBpcyBvbiBDXG5cbiAgaWYgKGQgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAhaXNUcmlhbmdsZUNsb2Nrd2lzZSh0cmlhbmdsZSkgPyBkID4gMCA6IGQgPCAwO1xufSAvLyBGcm9tIGh0dHBzOi8vYWxnb3JpdGhtdHV0b3IuY29tL0NvbXB1dGF0aW9uYWwtR2VvbWV0cnkvRGV0ZXJtaW5pbmctaWYtdHdvLWNvbnNlY3V0aXZlLXNlZ21lbnRzLXR1cm4tbGVmdC1vci1yaWdodC9cblxudmFyIG12MSA9IG5ldyBWZWN0b3IyKCk7XG52YXIgbXYyID0gbmV3IFZlY3RvcjIoKTtcbi8qKlxuIFxuICAgICDilbEgICAgICDilbIgICAgIFxuICAgIOKVsSAgICAgICAg4pWyICAgIFxuICAg4paVICAgICAgICAgIOKWjyAgIFxuICAgICAgICAgICAgICAgICAgXG4gcmlnaHQgICAgICBsZWZ0ICBcblxuICogTk9URTogU2hvdWxkIHRoaXMgdXNlIGEgYnVmZmVyIGluc3RlYWQ/IFt4MCwgeTAsIHgxLCB5MV0/XG4gKi9cblxuZnVuY3Rpb24gZG9UaHJlZVBvaW50c01ha2VBUmlnaHQocG9pbnRzKSB7XG4gIHZhciBfcG9pbnRzJG1hcCA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwKSkge1xuICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoVmVjdG9yMiwgX3RvQ29uc3VtYWJsZUFycmF5KHApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfSksXG4gICAgICBfcG9pbnRzJG1hcDIgPSBfc2xpY2VkVG9BcnJheShfcG9pbnRzJG1hcCwgMyksXG4gICAgICBwMSA9IF9wb2ludHMkbWFwMlswXSxcbiAgICAgIHAyID0gX3BvaW50cyRtYXAyWzFdLFxuICAgICAgcDMgPSBfcG9pbnRzJG1hcDJbMl07XG5cbiAgaWYgKGFyZVBvaW50c0NvbGxpbmVhcihwb2ludHMpKSByZXR1cm4gZmFsc2U7IC8vIEB0cy1pZ25vcmVcblxuICB2YXIgcDJwMSA9IG12MS5zdWJWZWN0b3JzKHAyLCBwMSk7IC8vIEB0cy1pZ25vcmVcblxuICB2YXIgcDNwMSA9IG12Mi5zdWJWZWN0b3JzKHAzLCBwMSk7XG4gIHZhciBjcm9zcyA9IHAzcDEuY3Jvc3MocDJwMSk7XG4gIHJldHVybiBjcm9zcyA+IDA7XG59XG5cbnZhciB0cmlhbmdsZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBpc1BvaW50SW5UcmlhbmdsZTogaXNQb2ludEluVHJpYW5nbGUsXG4gIHRyaWFuZ2xlRGV0ZXJtaW5hbnQ6IHRyaWFuZ2xlRGV0ZXJtaW5hbnQsXG4gIGFyZVBvaW50c0NvbGxpbmVhcjogYXJlUG9pbnRzQ29sbGluZWFyLFxuICBpc1RyaWFuZ2xlQ2xvY2t3aXNlOiBpc1RyaWFuZ2xlQ2xvY2t3aXNlLFxuICBnZXRDaXJjdW1jaXJjbGU6IGdldENpcmN1bWNpcmNsZSxcbiAgaXNQb2ludEluQ2lyY3VtY2lyY2xlOiBpc1BvaW50SW5DaXJjdW1jaXJjbGUsXG4gIGRvVGhyZWVQb2ludHNNYWtlQVJpZ2h0OiBkb1RocmVlUG9pbnRzTWFrZUFSaWdodFxufSk7XG5cbmV4cG9ydCB7IF9zbGljZWRUb0FycmF5IGFzIF8sIF90b0NvbnN1bWFibGVBcnJheSBhcyBhLCB0cmlhbmdsZURldGVybWluYW50IGFzIGIsIGFyZVBvaW50c0NvbGxpbmVhciBhcyBjLCBkb1RocmVlUG9pbnRzTWFrZUFSaWdodCBhcyBkLCBpc1RyaWFuZ2xlQ2xvY2t3aXNlIGFzIGUsIGlzUG9pbnRJbkNpcmN1bWNpcmNsZSBhcyBmLCBnZXRDaXJjdW1jaXJjbGUgYXMgZywgaXNQb2ludEluVHJpYW5nbGUgYXMgaSwgdHJpYW5nbGUgYXMgdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/triangle-b62b9067.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/vector2-d2bf51f1.esm.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/vector2-d2bf51f1.esm.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ add),\n/* harmony export */   b: () => (/* binding */ addValue),\n/* harmony export */   c: () => (/* binding */ subValue),\n/* harmony export */   d: () => (/* binding */ scale),\n/* harmony export */   e: () => (/* binding */ dot),\n/* harmony export */   f: () => (/* binding */ length),\n/* harmony export */   g: () => (/* binding */ distance),\n/* harmony export */   l: () => (/* binding */ lengthSqr),\n/* harmony export */   o: () => (/* binding */ one),\n/* harmony export */   s: () => (/* binding */ sub),\n/* harmony export */   v: () => (/* binding */ vector2),\n/* harmony export */   z: () => (/* binding */ zero)\n/* harmony export */ });\n/**\n *\n */\nfunction zero() {\n  return [0, 0];\n}\nfunction one() {\n  return [1, 1];\n}\nfunction add(a, b) {\n  return [a[0] + b[0], a[1] + b[1]];\n}\nfunction addValue(a, n) {\n  return [a[0] + n, a[1] + n];\n}\nfunction sub(a, b) {\n  return [a[0] - b[0], a[1] - b[1]];\n}\nfunction subValue(a, n) {\n  return [a[0] - n, a[1] - n];\n}\nfunction scale(a, n) {\n  return [a[0] * n, a[1] * n];\n}\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Calculate the squared length of a vector.\n * Use this when comparing two vectors instead of length, as it's more efficient (no sqrt)\n */\n\nfunction lengthSqr(a) {\n  return a[0] * a[0] + a[1] * a[1];\n}\n/**\n * Calculate the length of a vector.\n * If you only need to compare lenghts, consider using the more efficient lengthSqr\n */\n\nfunction length(a) {\n  return Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n}\nfunction distance(a, b) {\n  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\n}\n\nvar vector2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  zero: zero,\n  one: one,\n  add: add,\n  addValue: addValue,\n  sub: sub,\n  subValue: subValue,\n  scale: scale,\n  dot: dot,\n  lengthSqr: lengthSqr,\n  length: length,\n  distance: distance\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvdmVjdG9yMi1kMmJmNTFmMS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFZ0siLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvdmVjdG9yMi1kMmJmNTFmMS5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICovXG5mdW5jdGlvbiB6ZXJvKCkge1xuICByZXR1cm4gWzAsIDBdO1xufVxuZnVuY3Rpb24gb25lKCkge1xuICByZXR1cm4gWzEsIDFdO1xufVxuZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgcmV0dXJuIFthWzBdICsgYlswXSwgYVsxXSArIGJbMV1dO1xufVxuZnVuY3Rpb24gYWRkVmFsdWUoYSwgbikge1xuICByZXR1cm4gW2FbMF0gKyBuLCBhWzFdICsgbl07XG59XG5mdW5jdGlvbiBzdWIoYSwgYikge1xuICByZXR1cm4gW2FbMF0gLSBiWzBdLCBhWzFdIC0gYlsxXV07XG59XG5mdW5jdGlvbiBzdWJWYWx1ZShhLCBuKSB7XG4gIHJldHVybiBbYVswXSAtIG4sIGFbMV0gLSBuXTtcbn1cbmZ1bmN0aW9uIHNjYWxlKGEsIG4pIHtcbiAgcmV0dXJuIFthWzBdICogbiwgYVsxXSAqIG5dO1xufVxuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWN0b3IuXG4gKiBVc2UgdGhpcyB3aGVuIGNvbXBhcmluZyB0d28gdmVjdG9ycyBpbnN0ZWFkIG9mIGxlbmd0aCwgYXMgaXQncyBtb3JlIGVmZmljaWVudCAobm8gc3FydClcbiAqL1xuXG5mdW5jdGlvbiBsZW5ndGhTcXIoYSkge1xuICByZXR1cm4gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IuXG4gKiBJZiB5b3Ugb25seSBuZWVkIHRvIGNvbXBhcmUgbGVuZ2h0cywgY29uc2lkZXIgdXNpbmcgdGhlIG1vcmUgZWZmaWNpZW50IGxlbmd0aFNxclxuICovXG5cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXSk7XG59XG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoKGFbMF0gLSBiWzBdKSAqIChhWzBdIC0gYlswXSkgKyAoYVsxXSAtIGJbMV0pICogKGFbMV0gLSBiWzFdKSk7XG59XG5cbnZhciB2ZWN0b3IyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHplcm86IHplcm8sXG4gIG9uZTogb25lLFxuICBhZGQ6IGFkZCxcbiAgYWRkVmFsdWU6IGFkZFZhbHVlLFxuICBzdWI6IHN1YixcbiAgc3ViVmFsdWU6IHN1YlZhbHVlLFxuICBzY2FsZTogc2NhbGUsXG4gIGRvdDogZG90LFxuICBsZW5ndGhTcXI6IGxlbmd0aFNxcixcbiAgbGVuZ3RoOiBsZW5ndGgsXG4gIGRpc3RhbmNlOiBkaXN0YW5jZVxufSk7XG5cbmV4cG9ydCB7IGFkZCBhcyBhLCBhZGRWYWx1ZSBhcyBiLCBzdWJWYWx1ZSBhcyBjLCBzY2FsZSBhcyBkLCBkb3QgYXMgZSwgbGVuZ3RoIGFzIGYsIGRpc3RhbmNlIGFzIGcsIGxlbmd0aFNxciBhcyBsLCBvbmUgYXMgbywgc3ViIGFzIHMsIHZlY3RvcjIgYXMgdiwgemVybyBhcyB6IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/vector2-d2bf51f1.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/vector3-0a088b7f.esm.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@react-three/postprocessing/node_modules/maath/dist/vector3-0a088b7f.esm.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ add),\n/* harmony export */   b: () => (/* binding */ addValue),\n/* harmony export */   c: () => (/* binding */ subValue),\n/* harmony export */   d: () => (/* binding */ scale),\n/* harmony export */   e: () => (/* binding */ dot),\n/* harmony export */   f: () => (/* binding */ cross),\n/* harmony export */   g: () => (/* binding */ length),\n/* harmony export */   h: () => (/* binding */ distance),\n/* harmony export */   l: () => (/* binding */ lengthSqr),\n/* harmony export */   o: () => (/* binding */ one),\n/* harmony export */   s: () => (/* binding */ sub),\n/* harmony export */   v: () => (/* binding */ vector3),\n/* harmony export */   z: () => (/* binding */ zero)\n/* harmony export */ });\n/**\n *\n */\nfunction zero() {\n  return [0, 0, 0];\n}\nfunction one() {\n  return [1, 1, 1];\n}\nfunction add(a, b) {\n  return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];\n}\nfunction addValue(a, n) {\n  return [a[0] + n, a[1] + n, a[2] + n];\n}\nfunction sub(a, b) {\n  return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\n}\nfunction subValue(a, n) {\n  return [a[0] - n, a[1] - n, a[2] - n];\n}\nfunction scale(a, n) {\n  return [a[0] * n, a[1] * n, a[2] * n];\n}\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\nfunction cross(a, b) {\n  var x = a[1] * b[2] - a[2] * b[1];\n  var y = a[2] * b[0] - a[0] * b[2];\n  var z = a[0] * b[1] - a[1] * b[0];\n  return [x, y, z];\n}\n/**\n * Calculate the squared length of a vector.\n * Use this when comparing two vectors instead of length, as it's more efficient (no sqrt)\n */\n\nfunction lengthSqr(a) {\n  return a[0] * a[0] + a[1] * a[1] + a[2] * a[2];\n}\n/**\n * Calculate the length of a vector.\n * If you only need to compare lenghts, consider using the more efficient lengthSqr\n */\n\nfunction length(a) {\n  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);\n}\nfunction distance(a, b) {\n  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]) + (a[2] - b[2]) * (a[2] - b[2]));\n}\n\nvar vector3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  zero: zero,\n  one: one,\n  add: add,\n  addValue: addValue,\n  sub: sub,\n  subValue: subValue,\n  scale: scale,\n  dot: dot,\n  cross: cross,\n  lengthSqr: lengthSqr,\n  length: length,\n  distance: distance\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvdmVjdG9yMy0wYTA4OGI3Zi5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFNEsiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3Npbmcvbm9kZV9tb2R1bGVzL21hYXRoL2Rpc3QvdmVjdG9yMy0wYTA4OGI3Zi5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICovXG5mdW5jdGlvbiB6ZXJvKCkge1xuICByZXR1cm4gWzAsIDAsIDBdO1xufVxuZnVuY3Rpb24gb25lKCkge1xuICByZXR1cm4gWzEsIDEsIDFdO1xufVxuZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgcmV0dXJuIFthWzBdICsgYlswXSwgYVsxXSArIGJbMV0sIGFbMl0gKyBiWzJdXTtcbn1cbmZ1bmN0aW9uIGFkZFZhbHVlKGEsIG4pIHtcbiAgcmV0dXJuIFthWzBdICsgbiwgYVsxXSArIG4sIGFbMl0gKyBuXTtcbn1cbmZ1bmN0aW9uIHN1YihhLCBiKSB7XG4gIHJldHVybiBbYVswXSAtIGJbMF0sIGFbMV0gLSBiWzFdLCBhWzJdIC0gYlsyXV07XG59XG5mdW5jdGlvbiBzdWJWYWx1ZShhLCBuKSB7XG4gIHJldHVybiBbYVswXSAtIG4sIGFbMV0gLSBuLCBhWzJdIC0gbl07XG59XG5mdW5jdGlvbiBzY2FsZShhLCBuKSB7XG4gIHJldHVybiBbYVswXSAqIG4sIGFbMV0gKiBuLCBhWzJdICogbl07XG59XG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuZnVuY3Rpb24gY3Jvc3MoYSwgYikge1xuICB2YXIgeCA9IGFbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV07XG4gIHZhciB5ID0gYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXTtcbiAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICByZXR1cm4gW3gsIHksIHpdO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjdG9yLlxuICogVXNlIHRoaXMgd2hlbiBjb21wYXJpbmcgdHdvIHZlY3RvcnMgaW5zdGVhZCBvZiBsZW5ndGgsIGFzIGl0J3MgbW9yZSBlZmZpY2llbnQgKG5vIHNxcnQpXG4gKi9cblxuZnVuY3Rpb24gbGVuZ3RoU3FyKGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzBdICsgYVsxXSAqIGFbMV0gKyBhWzJdICogYVsyXTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IuXG4gKiBJZiB5b3Ugb25seSBuZWVkIHRvIGNvbXBhcmUgbGVuZ2h0cywgY29uc2lkZXIgdXNpbmcgdGhlIG1vcmUgZWZmaWNpZW50IGxlbmd0aFNxclxuICovXG5cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXSArIGFbMl0gKiBhWzJdKTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguc3FydCgoYVswXSAtIGJbMF0pICogKGFbMF0gLSBiWzBdKSArIChhWzFdIC0gYlsxXSkgKiAoYVsxXSAtIGJbMV0pICsgKGFbMl0gLSBiWzJdKSAqIChhWzJdIC0gYlsyXSkpO1xufVxuXG52YXIgdmVjdG9yMyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICB6ZXJvOiB6ZXJvLFxuICBvbmU6IG9uZSxcbiAgYWRkOiBhZGQsXG4gIGFkZFZhbHVlOiBhZGRWYWx1ZSxcbiAgc3ViOiBzdWIsXG4gIHN1YlZhbHVlOiBzdWJWYWx1ZSxcbiAgc2NhbGU6IHNjYWxlLFxuICBkb3Q6IGRvdCxcbiAgY3Jvc3M6IGNyb3NzLFxuICBsZW5ndGhTcXI6IGxlbmd0aFNxcixcbiAgbGVuZ3RoOiBsZW5ndGgsXG4gIGRpc3RhbmNlOiBkaXN0YW5jZVxufSk7XG5cbmV4cG9ydCB7IGFkZCBhcyBhLCBhZGRWYWx1ZSBhcyBiLCBzdWJWYWx1ZSBhcyBjLCBzY2FsZSBhcyBkLCBkb3QgYXMgZSwgY3Jvc3MgYXMgZiwgbGVuZ3RoIGFzIGcsIGRpc3RhbmNlIGFzIGgsIGxlbmd0aFNxciBhcyBsLCBvbmUgYXMgbywgc3ViIGFzIHMsIHZlY3RvcjMgYXMgdiwgemVybyBhcyB6IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/postprocessing/node_modules/maath/dist/vector3-0a088b7f.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/n8ao/dist/N8AO.js":
/*!****************************************!*\
  !*** ./node_modules/n8ao/dist/N8AO.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DepthType: () => (/* binding */ $05f6997e4b65da14$export$ed4ee5d1e55474a5),\n/* harmony export */   N8AOPass: () => (/* binding */ $05f6997e4b65da14$export$2d57db20b5eb5e0a),\n/* harmony export */   N8AOPostPass: () => (/* binding */ $87431ee93b037844$export$2489f9981ab0fa82)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_Pass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/postprocessing/Pass.js */ \"(app-pages-browser)/./node_modules/three/examples/jsm/postprocessing/Pass.js\");\n/* harmony import */ var postprocessing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! postprocessing */ \"(app-pages-browser)/./node_modules/postprocessing/build/index.js\");\n\n\n\n\n\n\n\nclass $e4ca8dcb0218f846$var$FullScreenTriangleGeometry extends three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry {\n    boundingSphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n    constructor(){\n        super();\n        this.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array([\n            -1,\n            -1,\n            3,\n            -1,\n            -1,\n            3\n        ]), 2));\n        this.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new Float32Array([\n            0,\n            0,\n            2,\n            0,\n            0,\n            2\n        ]), 2));\n    }\n    computeBoundingSphere() {}\n}\nconst $e4ca8dcb0218f846$var$_geometry = /* @__PURE__ */ new $e4ca8dcb0218f846$var$FullScreenTriangleGeometry();\nconst $e4ca8dcb0218f846$var$_camera = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera();\nclass $e4ca8dcb0218f846$export$dcd670d73db751f5 {\n    constructor(material){\n        this._mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh($e4ca8dcb0218f846$var$_geometry, material);\n        this._mesh.frustumCulled = false;\n    }\n    render(renderer) {\n        renderer.render(this._mesh, $e4ca8dcb0218f846$var$_camera);\n    }\n    get material() {\n        return this._mesh.material;\n    }\n    set material(value) {\n        this._mesh.material = value;\n    }\n    dispose() {\n        this._mesh.material.dispose();\n        this._mesh.geometry.dispose();\n    }\n}\n\n\n\nconst $1ed45968c1160c3c$export$c9b263b9a17dffd7 = {\n    uniforms: {\n        \"sceneDiffuse\": {\n            value: null\n        },\n        \"sceneDepth\": {\n            value: null\n        },\n        \"sceneNormal\": {\n            value: null\n        },\n        \"projMat\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"viewMat\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"projViewMat\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"projectionMatrixInv\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"viewMatrixInv\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"cameraPos\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        },\n        \"resolution\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()\n        },\n        \"biasAdjustment\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()\n        },\n        \"time\": {\n            value: 0.0\n        },\n        \"samples\": {\n            value: []\n        },\n        \"bluenoise\": {\n            value: null\n        },\n        \"distanceFalloff\": {\n            value: 1.0\n        },\n        \"radius\": {\n            value: 5.0\n        },\n        \"near\": {\n            value: 0.1\n        },\n        \"far\": {\n            value: 1000.0\n        },\n        \"ortho\": {\n            value: false\n        },\n        \"screenSpaceRadius\": {\n            value: false\n        },\n        \"frame\": {\n            value: 0.0\n        }\n    },\n    depthWrite: false,\n    depthTest: false,\n    vertexShader: /* glsl */ `\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1);\n}`,\n    fragmentShader: /* glsl */ `\n    #define SAMPLES 16\n    #define FSAMPLES 16.0\nuniform sampler2D sceneDiffuse;\nuniform highp sampler2D sceneNormal;\nuniform highp sampler2D sceneDepth;\nuniform mat4 projectionMatrixInv;\nuniform mat4 viewMatrixInv;\nuniform mat4 projMat;\nuniform mat4 viewMat;\nuniform mat4 projViewMat;\nuniform vec3 cameraPos;\nuniform vec2 resolution;\nuniform vec2 biasAdjustment;\nuniform float time;\nuniform vec3[SAMPLES] samples;\nuniform float radius;\nuniform float distanceFalloff;\nuniform float near;\nuniform float far;\nuniform float frame;\nuniform bool ortho;\nuniform bool screenSpaceRadius;\nuniform sampler2D bluenoise;\n    varying vec2 vUv;\n    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)\n    {\n        return (zFar * zNear) / (zFar - d * (zFar - zNear));\n    }\n    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {\n      return nearZ + (farZ - nearZ) * d;\n    }\n    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {\n      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;\n      float a = farZ / (farZ - nearZ);\n      float b = farZ * nearZ / (nearZ - farZ);\n      float linDepth = a + b / depth;\n      /*return ortho ? linearize_depth_ortho(\n        linDepth,\n        nearZ,\n        farZ\n      ) :linearize_depth(linDepth, nearZ, farZ);*/\n       #ifdef ORTHO\n\n       return linearize_depth_ortho(d, nearZ, farZ);\n\n        #else\n        return linearize_depth(linDepth, nearZ, farZ);\n        #endif\n    }\n\n    vec3 getWorldPosLog(vec3 posS) {\n      vec2 uv = posS.xy;\n      float z = posS.z;\n      float nearZ =near;\n      float farZ = far;\n      float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;\n      float a = farZ / (farZ - nearZ);\n      float b = farZ * nearZ / (nearZ - farZ);\n      float linDepth = a + b / depth;\n      vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;\n      vec4 wpos = projectionMatrixInv * clipVec;\n      return wpos.xyz / wpos.w;\n    }\n    vec3 getWorldPos(float depth, vec2 coord) {\n      #ifdef LOGDEPTH\n        #ifndef ORTHO\n          return getWorldPosLog(vec3(coord, depth));\n        #endif\n      #endif\n      float z = depth * 2.0 - 1.0;\n      vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n      vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;\n      // Perspective division\n     vec4 worldSpacePosition = viewSpacePosition;\n     worldSpacePosition.xyz /= worldSpacePosition.w;\n      return worldSpacePosition.xyz;\n  }\n\n  vec3 computeNormal(vec3 worldPos, vec2 vUv) {\n    ivec2 p = ivec2(vUv * resolution);\n    #ifdef REVERSEDEPTH\n    float c0 = 1.0 - texelFetch(sceneDepth, p, 0).x;\n    float l2 = 1.0 - texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;\n    float l1 = 1.0 - texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;\n    float r1 = 1.0 - texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;\n    float r2 = 1.0 - texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;\n    float b2 = 1.0 - texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;\n    float b1 = 1.0 - texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;\n    float t1 = 1.0 - texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;\n    float t2 = 1.0 - texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;\n    #else\n    float c0 = texelFetch(sceneDepth, p, 0).x;\n    float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;\n    float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;\n    float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;\n    float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;\n    float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;\n    float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;\n    float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;\n    float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;\n    #endif\n\n    float dl = abs((2.0 * l1 - l2) - c0);\n    float dr = abs((2.0 * r1 - r2) - c0);\n    float db = abs((2.0 * b1 - b2) - c0);\n    float dt = abs((2.0 * t1 - t2) - c0);\n\n    vec3 ce = getWorldPos(c0, vUv).xyz;\n\n    vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz\n                          : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;\n    vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz\n                          : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;\n\n    return normalize(cross(dpdx, dpdy));\n}\n\nmat3 makeRotationZ(float theta) {\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\treturn mat3(c, - s, 0,\n\t\t\ts,  c, 0,\n\t\t\t0,  0, 1);\n  }\n\nvoid main() {\n      vec4 diffuse = texture2D(sceneDiffuse, vUv);\n      #ifdef REVERSEDEPTH\n      float depth = 1.0 - texture2D(sceneDepth, vUv).x;\n      #else\n      float depth = texture2D(sceneDepth, vUv).x;\n      #endif\n      if (depth == 1.0) {\n        gl_FragColor = vec4(vec3(1.0), 1.0);\n        return;\n      }\n      vec3 worldPos = getWorldPos(depth, vUv);\n      #ifdef HALFRES\n        vec3 normal = texture2D(sceneNormal, vUv).rgb;\n      #else\n        vec3 normal = computeNormal(worldPos, vUv);\n      #endif\n      vec4 noise = texture2D(bluenoise, gl_FragCoord.xy / 128.0);\n      vec2 harmoniousNumbers = vec2(\n        1.618033988749895,\n        1.324717957244746\n      );\n      noise.rg += harmoniousNumbers * frame;\n      noise.rg = fract(noise.rg);\n        vec3 helperVec = vec3(0.0, 1.0, 0.0);\n        if (dot(helperVec, normal) > 0.99) {\n          helperVec = vec3(1.0, 0.0, 0.0);\n        }\n        vec3 tangent = normalize(cross(helperVec, normal));\n        vec3 bitangent = cross(normal, tangent);\n        mediump mat3 tbn = mat3(tangent, bitangent, normal) *  makeRotationZ( noise.r * 3.1415962 * 2.0) ;\n\n      mediump float occluded = 0.0;\n      mediump float totalWeight = 0.0;\n      float radiusToUse = screenSpaceRadius ? distance(\n        worldPos,\n        getWorldPos(depth, vUv +\n          vec2(radius, 0.0) / resolution)\n      ) : radius;\n      float distanceFalloffToUse =screenSpaceRadius ?\n          radiusToUse * distanceFalloff\n      : radiusToUse * distanceFalloff * 0.2;\n      float bias = (min(\n        0.1,\n        distanceFalloffToUse * 0.1\n      ) / near) * fwidth(distance(worldPos, cameraPos)) / radiusToUse;\n      bias = biasAdjustment.x + biasAdjustment.y * bias;\n      mediump float offsetMove = noise.g;\n      mediump float offsetMoveInv = 1.0 / FSAMPLES;\n      float farTimesNear = far * near;\n      float farMinusNear = far - near;\n      \n      for(int i = 0; i < SAMPLES; i++) {\n        mediump vec3 sampleDirection = tbn * samples[i];\n\n        float moveAmt = fract(offsetMove);\n        offsetMove += offsetMoveInv;\n        vec3 samplePos = worldPos + radiusToUse * moveAmt * sampleDirection;\n        vec4 offset = projMat * vec4(samplePos, 1.0);\n        offset.xyz /= offset.w;\n        offset.xyz = offset.xyz * 0.5 + 0.5;\n        \n        if (all(greaterThan(offset.xyz * (1.0 - offset.xyz), vec3(0.0)))) {\n          #ifdef REVERSEDEPTH\n          float sampleDepth = 1.0 - textureLod(sceneDepth, offset.xy, 0.0).x;\n          #else\n          float sampleDepth = textureLod(sceneDepth, offset.xy, 0.0).x;\n          #endif\n\n          /*#ifdef LOGDEPTH\n          float distSample = linearize_depth_log(sampleDepth, near, far);\n      #else\n          #ifdef ORTHO\n              float distSample = near + farMinusNear * sampleDepth;\n          #else\n              float distSample = (farTimesNear) / (far - sampleDepth * farMinusNear);\n          #endif\n      #endif*/\n      #ifdef ORTHO\n          float distSample = near + sampleDepth * farMinusNear;\n      #else\n          #ifdef LOGDEPTH\n              float distSample = linearize_depth_log(sampleDepth, near, far);\n          #else\n              float distSample = (farTimesNear) / (far - sampleDepth * farMinusNear);\n          #endif\n      #endif\n      \n      #ifdef ORTHO\n          float distWorld = near + offset.z * farMinusNear;\n      #else\n          float distWorld = (farTimesNear) / (far - offset.z * farMinusNear);\n      #endif\n          \n          mediump float rangeCheck = smoothstep(0.0, 1.0, distanceFalloffToUse / (abs(distSample - distWorld)));\n          vec2 diff = gl_FragCoord.xy - floor(offset.xy * resolution);\n          occluded += rangeCheck * float(distSample != distWorld) * float(sampleDepth != depth) * step(distSample + bias, distWorld) * step(\n            1.0,\n            dot(diff, diff)\n          );\n          \n          totalWeight ++;\n        }\n      }\n      float occ = clamp(1.0 - occluded / (totalWeight == 0.0 ? 1.0 : totalWeight), 0.0, 1.0);\n      gl_FragColor = vec4(occ, 0.5 + 0.5 * normal);\n}`\n};\n\n\n\nconst $12b21d24d1192a04$export$a815acccbd2c9a49 = {\n    uniforms: {\n        \"sceneDiffuse\": {\n            value: null\n        },\n        \"sceneDepth\": {\n            value: null\n        },\n        \"tDiffuse\": {\n            value: null\n        },\n        \"transparencyDWFalse\": {\n            value: null\n        },\n        \"transparencyDWTrue\": {\n            value: null\n        },\n        \"transparencyDWTrueDepth\": {\n            value: null\n        },\n        \"transparencyAware\": {\n            value: false\n        },\n        \"projMat\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"viewMat\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"projectionMatrixInv\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"viewMatrixInv\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"cameraPos\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        },\n        \"resolution\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()\n        },\n        \"color\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0)\n        },\n        \"blueNoise\": {\n            value: null\n        },\n        \"downsampledDepth\": {\n            value: null\n        },\n        \"time\": {\n            value: 0.0\n        },\n        \"intensity\": {\n            value: 10.0\n        },\n        \"renderMode\": {\n            value: 0.0\n        },\n        \"gammaCorrection\": {\n            value: false\n        },\n        \"ortho\": {\n            value: false\n        },\n        \"near\": {\n            value: 0.1\n        },\n        \"far\": {\n            value: 1000.0\n        },\n        \"screenSpaceRadius\": {\n            value: false\n        },\n        \"radius\": {\n            value: 0.0\n        },\n        \"distanceFalloff\": {\n            value: 1.0\n        },\n        \"fog\": {\n            value: false\n        },\n        \"fogExp\": {\n            value: false\n        },\n        \"fogDensity\": {\n            value: 0.0\n        },\n        \"fogNear\": {\n            value: Infinity\n        },\n        \"fogFar\": {\n            value: Infinity\n        },\n        \"colorMultiply\": {\n            value: true\n        },\n        \"aoTones\": {\n            value: 0.0\n        }\n    },\n    depthWrite: false,\n    depthTest: false,\n    vertexShader: /* glsl */ `\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = vec4(position, 1);\n\t\t}`,\n    fragmentShader: /* glsl */ `\n\t\tuniform sampler2D sceneDiffuse;\n    uniform highp sampler2D sceneDepth;\n    uniform highp sampler2D downsampledDepth;\n    uniform highp sampler2D transparencyDWFalse;\n    uniform highp sampler2D transparencyDWTrue;\n    uniform highp sampler2D transparencyDWTrueDepth;\n    uniform sampler2D tDiffuse;\n    uniform sampler2D blueNoise;\n    uniform vec2 resolution;\n    uniform vec3 color;\n    uniform mat4 projectionMatrixInv;\n    uniform mat4 viewMatrixInv;\n    uniform float intensity;\n    uniform float renderMode;\n    uniform float near;\n    uniform float far;\n    uniform float aoTones;\n    uniform bool gammaCorrection;\n    uniform bool ortho;\n    uniform bool screenSpaceRadius;\n    uniform bool fog;\n    uniform bool fogExp;\n    uniform bool colorMultiply;\n    uniform bool transparencyAware;\n    uniform float fogDensity;\n    uniform float fogNear;\n    uniform float fogFar;\n    uniform float radius;\n    uniform float distanceFalloff;\n    uniform vec3 cameraPos;\n    varying vec2 vUv;\n    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)\n    {\n        return (zFar * zNear) / (zFar - d * (zFar - zNear));\n    }\n    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {\n      return nearZ + (farZ - nearZ) * d;\n    }\n    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {\n      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;\n      float a = farZ / (farZ - nearZ);\n      float b = farZ * nearZ / (nearZ - farZ);\n      float linDepth = a + b / depth;\n      return ortho ? linearize_depth_ortho(\n        linDepth,\n        nearZ,\n        farZ\n      ) :linearize_depth(linDepth, nearZ, farZ);\n    }\n    vec3 getWorldPosLog(vec3 posS) {\n        vec2 uv = posS.xy;\n        float z = posS.z;\n        float nearZ =near;\n        float farZ = far;\n        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;\n        float a = farZ / (farZ - nearZ);\n        float b = farZ * nearZ / (nearZ - farZ);\n        float linDepth = a + b / depth;\n        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;\n        vec4 wpos = projectionMatrixInv * clipVec;\n        return wpos.xyz / wpos.w;\n      }\n      vec3 getWorldPos(float depth, vec2 coord) {\n        #ifdef LOGDEPTH\n          #ifndef ORTHO\n            return getWorldPosLog(vec3(coord, depth));\n          #endif\n        #endif\n      //  }\n        float z = depth * 2.0 - 1.0;\n        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;\n        // Perspective division\n       vec4 worldSpacePosition = viewSpacePosition;\n       worldSpacePosition.xyz /= worldSpacePosition.w;\n        return worldSpacePosition.xyz;\n    }\n  \n    vec3 computeNormal(vec3 worldPos, vec2 vUv) {\n      ivec2 p = ivec2(vUv * resolution);\n      #ifdef REVERSEDEPTH\n      float c0 = 1.0 - texelFetch(sceneDepth, p, 0).x;\n      float l2 = 1.0 - texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;\n      float l1 = 1.0 - texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;\n      float r1 = 1.0 - texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;\n      float r2 = 1.0 - texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;\n      float b2 = 1.0 - texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;\n      float b1 = 1.0 - texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;\n      float t1 = 1.0 - texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;\n      float t2 = 1.0 - texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;\n      #else\n      float c0 = texelFetch(sceneDepth, p, 0).x;\n      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;\n      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;\n      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;\n      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;\n      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;\n      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;\n      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;\n      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;\n      #endif\n  \n      float dl = abs((2.0 * l1 - l2) - c0);\n      float dr = abs((2.0 * r1 - r2) - c0);\n      float db = abs((2.0 * b1 - b2) - c0);\n      float dt = abs((2.0 * t1 - t2) - c0);\n  \n      vec3 ce = getWorldPos(c0, vUv).xyz;\n  \n      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz\n                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;\n      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz\n                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;\n  \n      return normalize(cross(dpdx, dpdy));\n  }\n\n    #include <common>\n    #include <dithering_pars_fragment>\n    void main() {\n        //vec4 texel = texture2D(tDiffuse, vUv);//vec3(0.0);\n        vec4 sceneTexel = texture2D(sceneDiffuse, vUv);\n        #ifdef REVERSEDEPTH\n        float depth = 1.0 - texture2D(sceneDepth, vUv).x;\n        #else\n        float depth = texture2D(sceneDepth, vUv).x;\n        #endif\n        #ifdef HALFRES \n        vec4 texel;\n        if (depth == 1.0) {\n            texel = vec4(0.0, 0.0, 0.0, 1.0);\n        } else {\n        vec3 worldPos = getWorldPos(depth, vUv);\n        vec3 normal = computeNormal(getWorldPos(depth, vUv), vUv);\n       // vec4 texel = texture2D(tDiffuse, vUv);\n       // Find closest depth;\n       float totalWeight = 0.0;\n       float radiusToUse = screenSpaceRadius ? distance(\n        worldPos,\n        getWorldPos(depth, vUv +\n          vec2(radius, 0.0) / resolution)\n      ) : radius;\n      float distanceFalloffToUse =screenSpaceRadius ?\n          radiusToUse * distanceFalloff\n      : distanceFalloff;\n        for(float x = -1.0; x <= 1.0; x++) {\n            for(float y = -1.0; y <= 1.0; y++) {\n                vec2 offset = vec2(x, y);\n                ivec2 p = ivec2(\n                    (vUv * resolution * 0.5) + offset\n                );\n                vec2 pUv = vec2(p) / (resolution * 0.5);\n                float sampleDepth = texelFetch(downsampledDepth,p, 0).x;\n                vec4 sampleInfo = texelFetch(tDiffuse, p, 0);\n                vec3 normalSample = sampleInfo.gba * 2.0 - 1.0;\n                vec3 worldPosSample = getWorldPos(sampleDepth, pUv);\n                float tangentPlaneDist = abs(dot(worldPosSample - worldPos, normal));\n                float rangeCheck = exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0);\n                float weight = rangeCheck;\n                totalWeight += weight;\n                texel += sampleInfo * weight;\n            }\n        }\n        if (totalWeight == 0.0) {\n            texel = texture2D(tDiffuse, vUv);\n        } else {\n            texel /= totalWeight;\n        }\n    }\n        #else\n        vec4 texel = texture2D(tDiffuse, vUv);\n        #endif\n\n        #ifdef LOGDEPTH\n        texel.r = clamp(texel.r, 0.0, 1.0);\n        if (texel.r == 0.0) {\n          texel.r = 1.0;\n        }\n        #endif\n     \n        float finalAo = pow(texel.r, intensity);\n        if (aoTones > 0.0) {\n            finalAo = ceil(finalAo * aoTones) / aoTones;\n        }\n        float fogFactor;\n        float fogDepth = distance(\n            cameraPos,\n            getWorldPos(depth, vUv)\n        );\n        if (fog) {\n            if (fogExp) {\n                fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n            } else {\n                fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n            }\n        }\n        if (transparencyAware) {\n            float transparencyDWOff = texture2D(transparencyDWFalse, vUv).a;\n            float transparencyDWOn = texture2D(transparencyDWTrue, vUv).a;\n            float adjustmentFactorOff = transparencyDWOff;\n            #ifdef REVERSEDEPTH\n            float depthSample = 1.0 - texture2D(sceneDepth, vUv).r;\n            float trueDepthSample = 1.0 - texture2D(transparencyDWTrueDepth, vUv).r;\n            #else\n            float depthSample = texture2D(sceneDepth, vUv).r;\n            float trueDepthSample = texture2D(transparencyDWTrueDepth, vUv).r;\n            #endif\n            float adjustmentFactorOn = (1.0 - transparencyDWOn) * (\n                trueDepthSample == depthSample ? 1.0 : 0.0\n            );\n            float adjustmentFactor = max(adjustmentFactorOff, adjustmentFactorOn);\n            finalAo = mix(finalAo, 1.0, adjustmentFactor);\n        }\n        finalAo = mix(finalAo, 1.0, fogFactor);\n        vec3 aoApplied = color * mix(vec3(1.0), sceneTexel.rgb, float(colorMultiply));\n        if (renderMode == 0.0) {\n            gl_FragColor = vec4( mix(sceneTexel.rgb, aoApplied, 1.0 - finalAo), sceneTexel.a);\n        } else if (renderMode == 1.0) {\n            gl_FragColor = vec4( mix(vec3(1.0), aoApplied, 1.0 - finalAo), sceneTexel.a);\n        } else if (renderMode == 2.0) {\n            gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);\n        } else if (renderMode == 3.0) {\n            if (vUv.x < 0.5) {\n                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);\n            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {\n                gl_FragColor = vec4(1.0);\n            } else {\n                gl_FragColor = vec4( mix(sceneTexel.rgb, aoApplied, 1.0 - finalAo), sceneTexel.a);\n            }\n        } else if (renderMode == 4.0) {\n            if (vUv.x < 0.5) {\n                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);\n            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {\n                gl_FragColor = vec4(1.0);\n            } else {\n                gl_FragColor = vec4( mix(vec3(1.0), aoApplied, 1.0 - finalAo), sceneTexel.a);\n            }\n        }\n        #include <dithering_fragment>\n        if (gammaCorrection) {\n            gl_FragColor = sRGBTransferOETF(gl_FragColor);\n        }\n    }\n    `\n};\n\n\n\nconst $e52378cd0f5a973d$export$57856b59f317262e = {\n    uniforms: {\n        \"sceneDiffuse\": {\n            value: null\n        },\n        \"sceneDepth\": {\n            value: null\n        },\n        \"tDiffuse\": {\n            value: null\n        },\n        \"projMat\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"viewMat\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"projectionMatrixInv\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"viewMatrixInv\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"cameraPos\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        },\n        \"resolution\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()\n        },\n        \"time\": {\n            value: 0.0\n        },\n        \"r\": {\n            value: 5.0\n        },\n        \"blueNoise\": {\n            value: null\n        },\n        \"radius\": {\n            value: 12.0\n        },\n        \"worldRadius\": {\n            value: 5.0\n        },\n        \"index\": {\n            value: 0.0\n        },\n        \"poissonDisk\": {\n            value: []\n        },\n        \"distanceFalloff\": {\n            value: 1.0\n        },\n        \"near\": {\n            value: 0.1\n        },\n        \"far\": {\n            value: 1000.0\n        },\n        \"screenSpaceRadius\": {\n            value: false\n        }\n    },\n    depthWrite: false,\n    depthTest: false,\n    vertexShader: /* glsl */ `\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = vec4(position, 1.0);\n\t\t}`,\n    fragmentShader: /* glsl */ `\n\t\tuniform sampler2D sceneDiffuse;\n    uniform highp sampler2D sceneDepth;\n    uniform sampler2D tDiffuse;\n    uniform sampler2D blueNoise;\n    uniform mat4 projectionMatrixInv;\n    uniform mat4 viewMatrixInv;\n    uniform vec2 resolution;\n    uniform float r;\n    uniform float radius;\n     uniform float worldRadius;\n    uniform float index;\n     uniform float near;\n     uniform float far;\n     uniform float distanceFalloff;\n     uniform bool screenSpaceRadius;\n    varying vec2 vUv;\n\n    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)\n    {\n        highp float z_n = 2.0 * d - 1.0;\n        return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));\n    }\n    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {\n     float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;\n     float a = farZ / (farZ - nearZ);\n     float b = farZ * nearZ / (nearZ - farZ);\n     float linDepth = a + b / depth;\n     return linearize_depth(linDepth, nearZ, farZ);\n   }\n   highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {\n     return nearZ + (farZ - nearZ) * d;\n   }\n   vec3 getWorldPosLog(vec3 posS) {\n     vec2 uv = posS.xy;\n     float z = posS.z;\n     float nearZ =near;\n     float farZ = far;\n     float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;\n     float a = farZ / (farZ - nearZ);\n     float b = farZ * nearZ / (nearZ - farZ);\n     float linDepth = a + b / depth;\n     vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;\n     vec4 wpos = projectionMatrixInv * clipVec;\n     return wpos.xyz / wpos.w;\n   }\n    vec3 getWorldPos(float depth, vec2 coord) {\n     #ifdef LOGDEPTH\n      #ifndef ORTHO\n          return getWorldPosLog(vec3(coord, depth));\n      #endif\n     #endif\n        \n        float z = depth * 2.0 - 1.0;\n        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;\n        // Perspective division\n       vec4 worldSpacePosition = viewSpacePosition;\n       worldSpacePosition.xyz /= worldSpacePosition.w;\n        return worldSpacePosition.xyz;\n    }\n    #include <common>\n    #define NUM_SAMPLES 16\n    uniform vec2 poissonDisk[NUM_SAMPLES];\n    void main() {\n        const float pi = 3.14159;\n        vec2 texelSize = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n        vec2 uv = vUv;\n        vec4 data = texture2D(tDiffuse, vUv);\n        float occlusion = data.r;\n        float baseOcc = data.r;\n        vec3 normal = data.gba * 2.0 - 1.0;\n        float count = 1.0;\n        float d = texture2D(sceneDepth, vUv).x;\n        if (d == 1.0) {\n          gl_FragColor = data;\n          return;\n        }\n        vec3 worldPos = getWorldPos(d, vUv);\n        float size = radius;\n        float angle;\n        if (index == 0.0) {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).w * PI2;\n        } else if (index == 1.0) {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).z * PI2;\n        } else if (index == 2.0) {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).y * PI2;\n        } else {\n             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).x * PI2;\n        }\n\n        mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n        float radiusToUse = screenSpaceRadius ? distance(\n          worldPos,\n          getWorldPos(d, vUv +\n            vec2(worldRadius, 0.0) / resolution)\n        ) : worldRadius;\n        float distanceFalloffToUse =screenSpaceRadius ?\n        radiusToUse * distanceFalloff\n    : radiusToUse * distanceFalloff * 0.2;\n\n        float invDistance = (1.0 / distanceFalloffToUse);\n        for(int i = 0; i < NUM_SAMPLES; i++) {\n            vec2 offset = (rotationMatrix * poissonDisk[i]) * texelSize * size;\n            vec4 dataSample = texture2D(tDiffuse, uv + offset);\n            float occSample = dataSample.r;\n            vec3 normalSample = dataSample.gba * 2.0 - 1.0;\n            float dSample = texture2D(sceneDepth, uv + offset).x;\n            vec3 worldPosSample = getWorldPos(dSample, uv + offset);\n            float tangentPlaneDist = abs(dot(worldPosSample - worldPos, normal));\n            float rangeCheck = float(dSample != 1.0) * exp(-1.0 * tangentPlaneDist * invDistance ) * max(dot(normal, normalSample), 0.0);\n            occlusion += occSample * rangeCheck;\n            count += rangeCheck;\n        }\n        if (count > 0.0) {\n          occlusion /= count;\n        }\n        occlusion = clamp(occlusion, 0.0, 1.0);\n        if (occlusion == 0.0) {\n          occlusion = 1.0;\n        }\n        gl_FragColor = vec4(occlusion, 0.5 + 0.5 * normal);\n    }\n    `\n};\n\n\n\nconst $26aca173e0984d99$export$1efdf491687cd442 = {\n    uniforms: {\n        \"sceneDepth\": {\n            value: null\n        },\n        \"resolution\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()\n        },\n        \"near\": {\n            value: 0.1\n        },\n        \"far\": {\n            value: 1000.0\n        },\n        \"viewMatrixInv\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"projectionMatrixInv\": {\n            value: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()\n        },\n        \"logDepth\": {\n            value: false\n        },\n        \"ortho\": {\n            value: false\n        }\n    },\n    depthWrite: false,\n    depthTest: false,\n    vertexShader: /* glsl */ `\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 1);\n    }`,\n    fragmentShader: /* glsl */ `\n    uniform highp sampler2D sceneDepth;\n    uniform vec2 resolution;\n    uniform float near;\n    uniform float far;\n    uniform bool logDepth;\n    uniform bool ortho;\n    uniform mat4 viewMatrixInv;\n    uniform mat4 projectionMatrixInv;\n    varying vec2 vUv;\n    layout(location = 1) out vec4 gNormal;\n    vec3 getWorldPosLog(vec3 posS) {\n        vec2 uv = posS.xy;\n        float z = posS.z;\n        float nearZ =near;\n        float farZ = far;\n        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;\n        float a = farZ / (farZ - nearZ);\n        float b = farZ * nearZ / (nearZ - farZ);\n        float linDepth = a + b / depth;\n        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;\n        vec4 wpos = projectionMatrixInv * clipVec;\n        return wpos.xyz / wpos.w;\n      }\n      vec3 getWorldPos(float depth, vec2 coord) {\n        if (logDepth && !ortho) {\n          return getWorldPosLog(vec3(coord, depth));\n        }\n        float z = depth * 2.0 - 1.0;\n        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;\n        // Perspective division\n       vec4 worldSpacePosition = viewSpacePosition;\n       worldSpacePosition.xyz /= worldSpacePosition.w;\n        return worldSpacePosition.xyz;\n    }\n  \n    vec3 computeNormal(vec3 worldPos, vec2 vUv) {\n      ivec2 p = ivec2(vUv * resolution);\n      #ifdef REVERSEDEPTH\n      float c0 = 1.0 - texelFetch(sceneDepth, p, 0).x;\n      float l2 = 1.0 - texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;\n      float l1 = 1.0 - texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;\n      float r1 = 1.0 - texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;\n      float r2 = 1.0 - texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;\n      float b2 = 1.0 - texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;\n      float b1 = 1.0 - texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;\n      float t1 = 1.0 - texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;\n      float t2 = 1.0 - texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;\n      #else\n      float c0 = texelFetch(sceneDepth, p, 0).x;\n      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;\n      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;\n      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;\n      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;\n      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;\n      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;\n      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;\n      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;\n      #endif\n  \n      float dl = abs((2.0 * l1 - l2) - c0);\n      float dr = abs((2.0 * r1 - r2) - c0);\n      float db = abs((2.0 * b1 - b2) - c0);\n      float dt = abs((2.0 * t1 - t2) - c0);\n  \n      vec3 ce = getWorldPos(c0, vUv).xyz;\n  \n      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz\n                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;\n      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz\n                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;\n  \n      return normalize(cross(dpdx, dpdy));\n  }\n    void main() {\n        vec2 uv = vUv - vec2(0.5) / resolution;\n        vec2 pixelSize = vec2(1.0) / resolution;\n        highp vec2[4] uvSamples;\n        uvSamples[0] = uv;\n        uvSamples[1] = uv + vec2(pixelSize.x, 0.0);\n        uvSamples[2] = uv + vec2(0.0, pixelSize.y);\n        uvSamples[3] = uv + pixelSize;\n        #ifdef REVERSEDEPTH\n        float depth00 = 1.0 - texture2D(sceneDepth, uvSamples[0]).r;\n        float depth10 = 1.0 - texture2D(sceneDepth, uvSamples[1]).r;\n        float depth01 = 1.0 - texture2D(sceneDepth, uvSamples[2]).r;\n        float depth11 = 1.0 - texture2D(sceneDepth, uvSamples[3]).r;\n        #else\n        float depth00 = texture2D(sceneDepth, uvSamples[0]).r;\n        float depth10 = texture2D(sceneDepth, uvSamples[1]).r;\n        float depth01 = texture2D(sceneDepth, uvSamples[2]).r;\n        float depth11 = texture2D(sceneDepth, uvSamples[3]).r;\n        #endif\n        float minDepth = min(min(depth00, depth10), min(depth01, depth11));\n        float maxDepth = max(max(depth00, depth10), max(depth01, depth11));\n        float targetDepth = minDepth;\n        // Checkerboard pattern to avoid artifacts\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 2.0) > 0.5) { \n            targetDepth = maxDepth;\n        }\n        int chosenIndex = 0;\n        float[4] samples;\n        samples[0] = depth00;\n        samples[1] = depth10;\n        samples[2] = depth01;\n        samples[3] = depth11;\n        for(int i = 0; i < 4; ++i) {\n            if (samples[i] == targetDepth) {\n                chosenIndex = i;\n                break;\n            }\n        }\n        gl_FragColor = vec4(samples[chosenIndex], 0.0, 0.0, 1.0);\n        gNormal = vec4(computeNormal(\n            getWorldPos(samples[chosenIndex], uvSamples[chosenIndex]), uvSamples[chosenIndex]\n        ), 0.0);\n    }`\n};\n\n\n\n\n\n\n\n\n\nconst $06269ad78f3c5fdf$var$BlueNoise = `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`;\nconst $06269ad78f3c5fdf$var$bluenoiseBits = /* @__PURE__ */ (()=>Uint8Array.from(atob($06269ad78f3c5fdf$var$BlueNoise), (c)=>c.charCodeAt(0)))();\nvar $06269ad78f3c5fdf$export$2e2bcd8739ae039 = $06269ad78f3c5fdf$var$bluenoiseBits;\n\n\n\n\nconst $ff9437d9c7577f11$var$version = /* @__PURE__ */ (()=>parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")))();\nconst $ff9437d9c7577f11$export$156f6a58f569aa09 = $ff9437d9c7577f11$var$version >= 162 ? class extends three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget {\n    constructor(width = 1, height = 1, count = 1, options = {}){\n        super(width, height, {\n            ...options,\n            count: count\n        });\n        this.isWebGLMultipleRenderTargets = true;\n    }\n    get texture() {\n        return this.textures;\n    }\n} : class extends three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget {\n    constructor(width = 1, height = 1, count = 1, options = {}){\n        super(width, height, options);\n        this.isWebGLMultipleRenderTargets = true;\n        const texture = this.texture;\n        this.texture = [];\n        for(let i = 0; i < count; i++){\n            this.texture[i] = texture.clone();\n            this.texture[i].isRenderTargetTexture = true;\n        }\n    }\n    setSize(width, height, depth = 1) {\n        if (this.width !== width || this.height !== height || this.depth !== depth) {\n            this.width = width;\n            this.height = height;\n            this.depth = depth;\n            for(let i = 0, il = this.texture.length; i < il; i++){\n                this.texture[i].image.width = width;\n                this.texture[i].image.height = height;\n                this.texture[i].image.depth = depth;\n            }\n            this.dispose();\n        }\n        this.viewport.set(0, 0, width, height);\n        this.scissor.set(0, 0, width, height);\n    }\n    copy(source) {\n        this.dispose();\n        this.width = source.width;\n        this.height = source.height;\n        this.depth = source.depth;\n        this.scissor.copy(source.scissor);\n        this.scissorTest = source.scissorTest;\n        this.viewport.copy(source.viewport);\n        this.depthBuffer = source.depthBuffer;\n        this.stencilBuffer = source.stencilBuffer;\n        if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();\n        this.texture.length = 0;\n        for(let i = 0, il = source.texture.length; i < il; i++){\n            this.texture[i] = source.texture[i].clone();\n            this.texture[i].isRenderTargetTexture = true;\n        }\n        return this;\n    }\n};\n\n\n/**\n * \n * @param {*} timerQuery \n * @param {THREE.WebGLRenderer} gl \n * @param {N8AOPostPass | N8AOPass} pass \n */ function $87431ee93b037844$var$checkTimerQuery(timerQuery, gl, pass) {\n    const available = gl.getQueryParameter(timerQuery, gl.QUERY_RESULT_AVAILABLE);\n    if (available) {\n        const elapsedTimeInNs = gl.getQueryParameter(timerQuery, gl.QUERY_RESULT);\n        const elapsedTimeInMs = elapsedTimeInNs / 1000000;\n        pass.lastTime = pass.lastTime === 0 ? elapsedTimeInMs : pass.timeRollingAverage * pass.lastTime + (1 - pass.timeRollingAverage) * elapsedTimeInMs;\n    } else // If the result is not available yet, check again after a delay\n    setTimeout(()=>{\n        $87431ee93b037844$var$checkTimerQuery(timerQuery, gl, pass);\n    }, 1);\n}\nclass $87431ee93b037844$export$2489f9981ab0fa82 extends (0, postprocessing__WEBPACK_IMPORTED_MODULE_1__.Pass) {\n    /**\n     * \n     * @param {THREE.Scene} scene\n     * @param {THREE.Camera} camera \n     * @param {number} width \n     * @param {number} height\n     *  \n     * @property {THREE.Scene} scene\n     * @property {THREE.Camera} camera\n     * @property {number} width\n     * @property {number} height\n     */ constructor(scene, camera, width = 512, height = 512){\n        super();\n        this.width = width;\n        this.height = height;\n        this.clear = true;\n        this.camera = camera;\n        this.scene = scene;\n        /**\n         * @type {Proxy & {\n         * aoSamples: number,\n         * aoRadius: number,\n         * denoiseSamples: number,\n         * denoiseRadius: number,\n         * distanceFalloff: number,\n         * intensity: number,\n         * denoiseIterations: number,\n         * renderMode: 0 | 1 | 2 | 3 | 4,\n         * color: THREE.Color,\n         * gammaCorrection: boolean,\n         * depthBufferType: 1 | 2 | 3,\n         * screenSpaceRadius: boolean,\n         * halfRes: boolean,\n         * depthAwareUpsampling: boolean\n         * colorMultiply: boolean\n         * }\n         */ this.autosetGamma = true;\n        this.configuration = new Proxy({\n            aoSamples: 16,\n            aoRadius: 5.0,\n            aoTones: 0.0,\n            denoiseSamples: 8,\n            denoiseRadius: 12,\n            distanceFalloff: 1.0,\n            intensity: 5,\n            denoiseIterations: 2.0,\n            renderMode: 0,\n            biasOffset: 0.0,\n            biasMultiplier: 0.0,\n            color: new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0),\n            gammaCorrection: true,\n            depthBufferType: (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Default,\n            screenSpaceRadius: false,\n            halfRes: false,\n            depthAwareUpsampling: true,\n            colorMultiply: true,\n            transparencyAware: false,\n            accumulate: false\n        }, {\n            set: (target, propName, value)=>{\n                const oldProp = target[propName];\n                target[propName] = value;\n                if (value.equals) {\n                    if (!value.equals(oldProp)) this.firstFrame();\n                } else if (oldProp !== value) this.firstFrame();\n                if (propName === \"aoSamples\" && oldProp !== value) this.configureAOPass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n                if (propName === \"denoiseSamples\" && oldProp !== value) this.configureDenoisePass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n                if (propName === \"halfRes\" && oldProp !== value) {\n                    this.configureAOPass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n                    this.configureHalfResTargets();\n                    this.configureEffectCompositer(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n                    this.setSize(this.width, this.height);\n                }\n                if (propName === \"depthAwareUpsampling\" && oldProp !== value) this.configureEffectCompositer(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n                if (propName === \"gammaCorrection\") this.autosetGamma = false;\n                if (propName === \"transparencyAware\" && oldProp !== value) {\n                    this.autoDetectTransparency = false;\n                    this.configureTransparencyTarget();\n                }\n                return true;\n            }\n        });\n        /** @type {THREE.Vector3[]} */ this.samples = [];\n        /** @type {THREE.Vector2[]} */ this.samplesDenoise = [];\n        this.autoDetectTransparency = true;\n        this.frames = 0;\n        this.lastViewMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.lastProjectionMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.configureEffectCompositer(this.configuration.depthBufferType);\n        this.configureSampleDependentPasses();\n        this.configureHalfResTargets();\n        this.detectTransparency();\n        this.configureTransparencyTarget();\n        //   this.effectCompisterQuad = new FullScreenTriangle(new THREE.ShaderMaterial(EffectCompositer));\n        this.copyQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n            uniforms: {\n                tDiffuse: {\n                    value: null\n                }\n            },\n            depthWrite: false,\n            vertexShader: `\n            varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = vec4(position, 1);\n            }\n            `,\n            fragmentShader: `\n            uniform sampler2D tDiffuse;\n            varying vec2 vUv;\n            void main() {\n                gl_FragColor = texture2D(tDiffuse, vUv);\n            }\n            `\n        }));\n        this.writeTargetInternal = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            depthBuffer: false,\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat\n        });\n        this.readTargetInternal = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            depthBuffer: false,\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat\n        });\n        this.outputTargetInternal = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            depthBuffer: false\n        });\n        this.accumulationRenderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            depthBuffer: false,\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n            stencilBuffer: false,\n            depthBuffer: false,\n            alpha: true\n        });\n        this.accumulationQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n            uniforms: {\n                frame: {\n                    value: 0\n                },\n                tDiffuse: {\n                    value: null\n                }\n            },\n            transparent: true,\n            opacity: 1,\n            vertexShader: `\n             varying vec2 vUv;\n             void main() {\n                 vUv = uv;\n                 gl_Position = vec4(position, 1);\n             }`,\n            fragmentShader: `\n             uniform sampler2D tDiffuse;\n             uniform float frame;\n                varying vec2 vUv;\n                void main() {\n                    vec4 color = texture2D(tDiffuse, vUv);\n                    gl_FragColor = vec4(color.rgb, 1.0 / (frame + 1.0));\n                }\n                `\n        }));\n        /** @type {THREE.DataTexture} */ this.bluenoise = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture((0, $06269ad78f3c5fdf$export$2e2bcd8739ae039), 128, 128);\n        this.bluenoise.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace;\n        this.bluenoise.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n        this.bluenoise.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n        this.bluenoise.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n        this.bluenoise.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n        this.bluenoise.needsUpdate = true;\n        this.lastTime = 0;\n        this.timeRollingAverage = 0.99;\n        this.needsDepthTexture = true;\n        this.needsSwap = true;\n        this._r = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this._c = new three__WEBPACK_IMPORTED_MODULE_0__.Color();\n    }\n    configureHalfResTargets() {\n        this.firstFrame();\n        if (this.configuration.halfRes) {\n            this.depthDownsampleTarget = new (0, $ff9437d9c7577f11$export$156f6a58f569aa09)(this.width / 2, this.height / 2, 2);\n            if (three__WEBPACK_IMPORTED_MODULE_0__.REVISION <= 161) this.depthDownsampleTarget.textures = this.depthDownsampleTarget.texture;\n            this.depthDownsampleTarget.textures[0].format = three__WEBPACK_IMPORTED_MODULE_0__.RedFormat;\n            this.depthDownsampleTarget.textures[0].type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n            this.depthDownsampleTarget.textures[0].minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            this.depthDownsampleTarget.textures[0].magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            this.depthDownsampleTarget.textures[0].depthBuffer = false;\n            this.depthDownsampleTarget.textures[1].format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n            this.depthDownsampleTarget.textures[1].type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n            this.depthDownsampleTarget.textures[1].minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            this.depthDownsampleTarget.textures[1].magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            this.depthDownsampleTarget.textures[1].depthBuffer = false;\n            this.depthDownsampleQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial((0, $26aca173e0984d99$export$1efdf491687cd442)));\n        } else {\n            if (this.depthDownsampleTarget) {\n                this.depthDownsampleTarget.dispose();\n                this.depthDownsampleTarget = null;\n            }\n            if (this.depthDownsampleQuad) {\n                this.depthDownsampleQuad.dispose();\n                this.depthDownsampleQuad = null;\n            }\n        }\n    }\n    detectTransparency() {\n        if (this.autoDetectTransparency) {\n            let isTransparency = false;\n            this.scene.traverse((obj)=>{\n                if (obj.material && obj.material.transparent) isTransparency = true;\n            });\n            if (isTransparency) this.configuration.transparencyAware = true;\n        }\n    }\n    configureTransparencyTarget() {\n        if (this.configuration.transparencyAware) {\n            this.transparencyRenderTargetDWFalse = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n                minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n                magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n                type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n                format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat\n            });\n            this.transparencyRenderTargetDWTrue = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n                minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n                magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n                type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n                format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat\n            });\n            this.transparencyRenderTargetDWTrue.depthTexture = new three__WEBPACK_IMPORTED_MODULE_0__.DepthTexture(this.width, this.height, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType);\n            this.depthCopyPass = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n                uniforms: {\n                    depthTexture: {\n                        value: this.depthTexture\n                    },\n                    reverseDepthBuffer: {\n                        value: this.configuration.depthBufferType === (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Reverse\n                    }\n                },\n                vertexShader: /* glsl */ `\n            varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = vec4(position, 1);\n            }`,\n                fragmentShader: /* glsl */ `\n            uniform sampler2D depthTexture;\n            uniform bool reverseDepthBuffer;\n            varying vec2 vUv;\n            void main() {\n                if (reverseDepthBuffer) {\n               float d = 1.0 - texture2D(depthTexture, vUv).r;\n           \n               d += 0.00001;\n               gl_FragDepth = 1.0 - d;\n            } else {\n                float d = texture2D(depthTexture, vUv).r;\n                d += 0.00001;\n                gl_FragDepth = d;\n            }\n               gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            }\n            `\n            }));\n        } else {\n            if (this.transparencyRenderTargetDWFalse) {\n                this.transparencyRenderTargetDWFalse.dispose();\n                this.transparencyRenderTargetDWFalse = null;\n            }\n            if (this.transparencyRenderTargetDWTrue) {\n                this.transparencyRenderTargetDWTrue.dispose();\n                this.transparencyRenderTargetDWTrue = null;\n            }\n            if (this.depthCopyPass) {\n                this.depthCopyPass.dispose();\n                this.depthCopyPass = null;\n            }\n        }\n    }\n    renderTransparency(renderer) {\n        const oldBackground = this.scene.background;\n        const oldClearColor = renderer.getClearColor(new three__WEBPACK_IMPORTED_MODULE_0__.Color());\n        const oldClearAlpha = renderer.getClearAlpha();\n        const oldVisibility = new Map();\n        const oldAutoClearDepth = renderer.autoClearDepth;\n        this.scene.traverse((obj)=>{\n            oldVisibility.set(obj, obj.visible);\n        });\n        // Override the state\n        this.scene.background = null;\n        renderer.autoClearDepth = false;\n        renderer.setClearColor(new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0), 0);\n        this.depthCopyPass.material.uniforms.depthTexture.value = this.depthTexture;\n        this.depthCopyPass.material.uniforms.reverseDepthBuffer.value = this.configuration.depthBufferType === (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Reverse;\n        // Render out transparent objects WITHOUT depth write\n        renderer.setRenderTarget(this.transparencyRenderTargetDWFalse);\n        this.scene.traverse((obj)=>{\n            if (obj.material) obj.visible = oldVisibility.get(obj) && (obj.material.transparent && !obj.material.depthWrite && !obj.userData.treatAsOpaque || !!obj.userData.cannotReceiveAO);\n        });\n        renderer.clear(true, true, true);\n        this.depthCopyPass.render(renderer);\n        renderer.render(this.scene, this.camera);\n        // Render out transparent objects WITH depth write\n        renderer.setRenderTarget(this.transparencyRenderTargetDWTrue);\n        this.scene.traverse((obj)=>{\n            if (obj.material) obj.visible = oldVisibility.get(obj) && obj.material.transparent && obj.material.depthWrite && !obj.userData.treatAsOpaque;\n        });\n        renderer.clear(true, true, true);\n        this.depthCopyPass.render(renderer);\n        renderer.render(this.scene, this.camera);\n        // Restore\n        this.scene.traverse((obj)=>{\n            obj.visible = oldVisibility.get(obj);\n        });\n        renderer.setClearColor(oldClearColor, oldClearAlpha);\n        this.scene.background = oldBackground;\n        renderer.autoClearDepth = oldAutoClearDepth;\n    }\n    configureSampleDependentPasses() {\n        this.configureAOPass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n        this.configureDenoisePass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n    }\n    configureAOPass(depthBufferType = (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Default, ortho = false) {\n        this.firstFrame();\n        this.samples = this.generateHemisphereSamples(this.configuration.aoSamples);\n        const e = {\n            ...(0, $1ed45968c1160c3c$export$c9b263b9a17dffd7)\n        };\n        e.fragmentShader = e.fragmentShader.replace(\"16\", this.configuration.aoSamples).replace(\"16.0\", this.configuration.aoSamples + \".0\");\n        if (depthBufferType === (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Log) e.fragmentShader = \"#define LOGDEPTH\\n\" + e.fragmentShader;\n        else if (depthBufferType === (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Reverse) e.fragmentShader = \"#define REVERSEDEPTH\\n\" + e.fragmentShader;\n        if (ortho) e.fragmentShader = \"#define ORTHO\\n\" + e.fragmentShader;\n        if (this.configuration.halfRes) e.fragmentShader = \"#define HALFRES\\n\" + e.fragmentShader;\n        if (this.effectShaderQuad) {\n            this.effectShaderQuad.material.dispose();\n            this.effectShaderQuad.material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(e);\n        } else this.effectShaderQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(e));\n    }\n    configureDenoisePass(depthBufferType = (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Default, ortho = false) {\n        this.firstFrame();\n        this.samplesDenoise = this.generateDenoiseSamples(this.configuration.denoiseSamples, 11);\n        const p = {\n            ...(0, $e52378cd0f5a973d$export$57856b59f317262e)\n        };\n        p.fragmentShader = p.fragmentShader.replace(\"16\", this.configuration.denoiseSamples);\n        if (depthBufferType === (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Log) p.fragmentShader = \"#define LOGDEPTH\\n\" + p.fragmentShader;\n        else if (depthBufferType === (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Reverse) p.fragmentShader = \"#define REVERSEDEPTH\\n\" + p.fragmentShader;\n        if (ortho) p.fragmentShader = \"#define ORTHO\\n\" + p.fragmentShader;\n        if (this.poissonBlurQuad) {\n            this.poissonBlurQuad.material.dispose();\n            this.poissonBlurQuad.material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(p);\n        } else this.poissonBlurQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(p));\n    }\n    configureEffectCompositer(depthBufferType = (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Default, ortho = false) {\n        this.firstFrame();\n        const e = {\n            ...(0, $12b21d24d1192a04$export$a815acccbd2c9a49)\n        };\n        if (depthBufferType === (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Log) e.fragmentShader = \"#define LOGDEPTH\\n\" + e.fragmentShader;\n        else if (depthBufferType === (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Reverse) e.fragmentShader = \"#define REVERSEDEPTH\\n\" + e.fragmentShader;\n        if (ortho) e.fragmentShader = \"#define ORTHO\\n\" + e.fragmentShader;\n        if (this.configuration.halfRes && this.configuration.depthAwareUpsampling) e.fragmentShader = \"#define HALFRES\\n\" + e.fragmentShader;\n        if (this.effectCompositerQuad) {\n            this.effectCompositerQuad.material.dispose();\n            this.effectCompositerQuad.material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(e);\n        } else this.effectCompositerQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(e));\n    }\n    /**\n         * \n         * @param {Number} n \n         * @returns {THREE.Vector3[]}\n         */ generateHemisphereSamples(n) {\n        const points = [];\n        for(let k = 0; k < n; k++){\n            const theta = 2.399963 * k;\n            const r = Math.sqrt(k + 0.5) / Math.sqrt(n);\n            const x = r * Math.cos(theta);\n            const y = r * Math.sin(theta);\n            // Project to hemisphere\n            const z = Math.sqrt(1 - (x * x + y * y));\n            points.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z));\n        }\n        return points;\n    }\n    /**\n         * \n         * @param {number} numSamples \n         * @param {number} numRings \n         * @returns {THREE.Vector2[]}\n         */ generateDenoiseSamples(numSamples, numRings) {\n        const angleStep = 2 * Math.PI * numRings / numSamples;\n        const invNumSamples = 1.0 / numSamples;\n        const radiusStep = invNumSamples;\n        const samples = [];\n        let radius = invNumSamples;\n        let angle = 0;\n        for(let i = 0; i < numSamples; i++){\n            samples.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(Math.cos(angle), Math.sin(angle)).multiplyScalar(Math.pow(radius, 0.75)));\n            radius += radiusStep;\n            angle += angleStep;\n        }\n        return samples;\n    }\n    setSize(width, height) {\n        this.firstFrame();\n        this.width = width;\n        this.height = height;\n        const c = this.configuration.halfRes ? 0.5 : 1;\n        this.writeTargetInternal.setSize(width * c, height * c);\n        this.readTargetInternal.setSize(width * c, height * c);\n        this.accumulationRenderTarget.setSize(width * c, height * c);\n        if (this.configuration.halfRes) this.depthDownsampleTarget.setSize(width * c, height * c);\n        if (this.configuration.transparencyAware) {\n            this.transparencyRenderTargetDWFalse.setSize(width, height);\n            this.transparencyRenderTargetDWTrue.setSize(width, height);\n        }\n        this.outputTargetInternal.setSize(width, height);\n    }\n    setDepthTexture(depthTexture) {\n        this.depthTexture = depthTexture;\n    }\n    firstFrame() {\n        this.needsFrame = true;\n    }\n    render(renderer, inputBuffer, outputBuffer) {\n        const xrEnabled = renderer.xr.enabled;\n        renderer.xr.enabled = false;\n        // Copy inputBuffer to outputBuffer\n        //renderer.setRenderTarget(outputBuffer);\n        //  this.copyQuad.material.uniforms.tDiffuse.value = inputBuffer.texture;\n        //   this.copyQuad.render(renderer);\n        if (renderer.capabilities.logarithmicDepthBuffer && this.configuration.depthBufferType !== (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Log || renderer.capabilities.reverseDepthBuffer && this.configuration.depthBufferType !== (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Reverse) {\n            this.configuration.depthBufferType = renderer.capabilities.logarithmicDepthBuffer ? (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Log : renderer.capabilities.reverseDepthBuffer ? (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Reverse : (0, $05f6997e4b65da14$export$ed4ee5d1e55474a5).Default;\n            this.configureAOPass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n            this.configureDenoisePass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n            this.configureEffectCompositer(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n        }\n        this.detectTransparency();\n        if (inputBuffer.texture.type !== this.outputTargetInternal.texture.type || inputBuffer.texture.format !== this.outputTargetInternal.texture.format) {\n            this.outputTargetInternal.texture.type = inputBuffer.texture.type;\n            this.outputTargetInternal.texture.format = inputBuffer.texture.format;\n            this.outputTargetInternal.texture.needsUpdate = true;\n        }\n        this.camera.updateMatrixWorld();\n        if (this.lastViewMatrix.equals(this.camera.matrixWorldInverse) && this.lastProjectionMatrix.equals(this.camera.projectionMatrix) && this.configuration.accumulate && !this.needsFrame) this.frame++;\n        else {\n            if (this.configuration.accumulate) {\n                renderer.setRenderTarget(this.accumulationRenderTarget);\n                renderer.clear(true, true, true);\n            }\n            this.frame = 0;\n            this.needsFrame = false;\n        }\n        this.lastViewMatrix.copy(this.camera.matrixWorldInverse);\n        this.lastProjectionMatrix.copy(this.camera.projectionMatrix);\n        let gl;\n        let ext;\n        let timerQuery;\n        if (this.debugMode) {\n            gl = renderer.getContext();\n            ext = gl.getExtension(\"EXT_disjoint_timer_query_webgl2\");\n            if (ext === null) {\n                console.error(\"EXT_disjoint_timer_query_webgl2 not available, disabling debug mode.\");\n                this.debugMode = false;\n            }\n        }\n        if (this.debugMode) {\n            timerQuery = gl.createQuery();\n            gl.beginQuery(ext.TIME_ELAPSED_EXT, timerQuery);\n        }\n        if (this.configuration.transparencyAware) this.renderTransparency(renderer);\n        this._r.set(this.width, this.height);\n        let trueRadius = this.configuration.aoRadius;\n        if (this.configuration.halfRes && this.configuration.screenSpaceRadius) trueRadius *= 0.5;\n        if (this.frame < 1024 / this.configuration.aoSamples) {\n            if (this.configuration.halfRes) {\n                renderer.setRenderTarget(this.depthDownsampleTarget);\n                this.depthDownsampleQuad.material.uniforms.sceneDepth.value = this.depthTexture;\n                this.depthDownsampleQuad.material.uniforms.resolution.value = this._r;\n                this.depthDownsampleQuad.material.uniforms[\"near\"].value = this.camera.near;\n                this.depthDownsampleQuad.material.uniforms[\"far\"].value = this.camera.far;\n                this.depthDownsampleQuad.material.uniforms[\"projectionMatrixInv\"].value = this.camera.projectionMatrixInverse;\n                this.depthDownsampleQuad.material.uniforms[\"viewMatrixInv\"].value = this.camera.matrixWorld;\n                this.depthDownsampleQuad.material.uniforms[\"logDepth\"].value = this.configuration.logarithmicDepthBuffer;\n                this.depthDownsampleQuad.material.uniforms[\"ortho\"].value = this.camera.isOrthographicCamera;\n                this.depthDownsampleQuad.render(renderer);\n            }\n            this.effectShaderQuad.material.uniforms[\"sceneDiffuse\"].value = inputBuffer.texture;\n            this.effectShaderQuad.material.uniforms[\"sceneDepth\"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.depthTexture;\n            this.effectShaderQuad.material.uniforms[\"sceneNormal\"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[1] : null;\n            this.effectShaderQuad.material.uniforms[\"projMat\"].value = this.camera.projectionMatrix;\n            this.effectShaderQuad.material.uniforms[\"viewMat\"].value = this.camera.matrixWorldInverse;\n            this.effectShaderQuad.material.uniforms[\"projViewMat\"].value = this.camera.projectionMatrix.clone().multiply(this.camera.matrixWorldInverse.clone());\n            this.effectShaderQuad.material.uniforms[\"projectionMatrixInv\"].value = this.camera.projectionMatrixInverse;\n            this.effectShaderQuad.material.uniforms[\"viewMatrixInv\"].value = this.camera.matrixWorld;\n            this.effectShaderQuad.material.uniforms[\"cameraPos\"].value = this.camera.getWorldPosition(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n            this.effectShaderQuad.material.uniforms[\"biasAdjustment\"].value = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(this.configuration.biasOffset, this.configuration.biasMultiplier);\n            this.effectShaderQuad.material.uniforms[\"resolution\"].value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r;\n            this.effectShaderQuad.material.uniforms[\"time\"].value = performance.now() / 1000;\n            this.effectShaderQuad.material.uniforms[\"samples\"].value = this.samples;\n            this.effectShaderQuad.material.uniforms[\"bluenoise\"].value = this.bluenoise;\n            this.effectShaderQuad.material.uniforms[\"radius\"].value = trueRadius;\n            this.effectShaderQuad.material.uniforms[\"distanceFalloff\"].value = this.configuration.distanceFalloff;\n            this.effectShaderQuad.material.uniforms[\"near\"].value = this.camera.near;\n            this.effectShaderQuad.material.uniforms[\"far\"].value = this.camera.far;\n            this.effectShaderQuad.material.uniforms[\"ortho\"].value = this.camera.isOrthographicCamera;\n            this.effectShaderQuad.material.uniforms[\"screenSpaceRadius\"].value = this.configuration.screenSpaceRadius;\n            this.effectShaderQuad.material.uniforms[\"frame\"].value = this.frame;\n            // Start the AO\n            renderer.setRenderTarget(this.writeTargetInternal);\n            this.effectShaderQuad.render(renderer);\n            // End the AO\n            // Start the blur\n            for(let i = 0; i < this.configuration.denoiseIterations; i++){\n                [this.writeTargetInternal, this.readTargetInternal] = [\n                    this.readTargetInternal,\n                    this.writeTargetInternal\n                ];\n                this.poissonBlurQuad.material.uniforms[\"tDiffuse\"].value = this.readTargetInternal.texture;\n                this.poissonBlurQuad.material.uniforms[\"sceneDepth\"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.depthTexture;\n                this.poissonBlurQuad.material.uniforms[\"projMat\"].value = this.camera.projectionMatrix;\n                this.poissonBlurQuad.material.uniforms[\"viewMat\"].value = this.camera.matrixWorldInverse;\n                this.poissonBlurQuad.material.uniforms[\"projectionMatrixInv\"].value = this.camera.projectionMatrixInverse;\n                this.poissonBlurQuad.material.uniforms[\"viewMatrixInv\"].value = this.camera.matrixWorld;\n                this.poissonBlurQuad.material.uniforms[\"cameraPos\"].value = this.camera.getWorldPosition(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n                this.poissonBlurQuad.material.uniforms[\"resolution\"].value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r;\n                this.poissonBlurQuad.material.uniforms[\"time\"].value = performance.now() / 1000;\n                this.poissonBlurQuad.material.uniforms[\"blueNoise\"].value = this.bluenoise;\n                this.poissonBlurQuad.material.uniforms[\"radius\"].value = this.configuration.denoiseRadius * (this.configuration.halfRes ? 0.5 : 1);\n                this.poissonBlurQuad.material.uniforms[\"worldRadius\"].value = trueRadius;\n                this.poissonBlurQuad.material.uniforms[\"distanceFalloff\"].value = this.configuration.distanceFalloff;\n                this.poissonBlurQuad.material.uniforms[\"index\"].value = i;\n                this.poissonBlurQuad.material.uniforms[\"poissonDisk\"].value = this.samplesDenoise;\n                this.poissonBlurQuad.material.uniforms[\"near\"].value = this.camera.near;\n                this.poissonBlurQuad.material.uniforms[\"far\"].value = this.camera.far;\n                this.poissonBlurQuad.material.uniforms[\"screenSpaceRadius\"].value = this.configuration.screenSpaceRadius;\n                renderer.setRenderTarget(this.writeTargetInternal);\n                this.poissonBlurQuad.render(renderer);\n            }\n            renderer.setRenderTarget(this.accumulationRenderTarget);\n            const oldAutoClear = renderer.autoClear;\n            renderer.autoClear = false;\n            this.accumulationQuad.material.uniforms[\"tDiffuse\"].value = this.writeTargetInternal.texture;\n            this.accumulationQuad.material.uniforms[\"frame\"].value = this.frame;\n            this.accumulationQuad.render(renderer);\n            renderer.autoClear = oldAutoClear;\n        }\n        // Now, we have the blurred AO in writeTargetInternal\n        // End the blur\n        // Start the composition\n        if (this.configuration.transparencyAware) {\n            this.effectCompositerQuad.material.uniforms[\"transparencyDWFalse\"].value = this.transparencyRenderTargetDWFalse.texture;\n            this.effectCompositerQuad.material.uniforms[\"transparencyDWTrue\"].value = this.transparencyRenderTargetDWTrue.texture;\n            this.effectCompositerQuad.material.uniforms[\"transparencyDWTrueDepth\"].value = this.transparencyRenderTargetDWTrue.depthTexture;\n            this.effectCompositerQuad.material.uniforms[\"transparencyAware\"].value = true;\n        }\n        this.effectCompositerQuad.material.uniforms[\"sceneDiffuse\"].value = inputBuffer.texture;\n        this.effectCompositerQuad.material.uniforms[\"sceneDepth\"].value = this.depthTexture;\n        this.effectCompositerQuad.material.uniforms[\"aoTones\"].value = this.configuration.aoTones;\n        this.effectCompositerQuad.material.uniforms[\"near\"].value = this.camera.near;\n        this.effectCompositerQuad.material.uniforms[\"far\"].value = this.camera.far;\n        this.effectCompositerQuad.material.uniforms[\"projectionMatrixInv\"].value = this.camera.projectionMatrixInverse;\n        this.effectCompositerQuad.material.uniforms[\"viewMatrixInv\"].value = this.camera.matrixWorld;\n        this.effectCompositerQuad.material.uniforms[\"ortho\"].value = this.camera.isOrthographicCamera;\n        this.effectCompositerQuad.material.uniforms[\"downsampledDepth\"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.depthTexture;\n        this.effectCompositerQuad.material.uniforms[\"resolution\"].value = this._r;\n        this.effectCompositerQuad.material.uniforms[\"blueNoise\"].value = this.bluenoise;\n        this.effectCompositerQuad.material.uniforms[\"intensity\"].value = this.configuration.intensity;\n        this.effectCompositerQuad.material.uniforms[\"renderMode\"].value = this.configuration.renderMode;\n        this.effectCompositerQuad.material.uniforms[\"screenSpaceRadius\"].value = this.configuration.screenSpaceRadius;\n        this.effectCompositerQuad.material.uniforms[\"radius\"].value = trueRadius;\n        this.effectCompositerQuad.material.uniforms[\"distanceFalloff\"].value = this.configuration.distanceFalloff;\n        this.effectCompositerQuad.material.uniforms[\"gammaCorrection\"].value = this.autosetGamma ? this.renderToScreen : this.configuration.gammaCorrection;\n        this.effectCompositerQuad.material.uniforms[\"tDiffuse\"].value = this.accumulationRenderTarget.texture;\n        this.effectCompositerQuad.material.uniforms[\"color\"].value = this._c.copy(this.configuration.color).convertSRGBToLinear();\n        this.effectCompositerQuad.material.uniforms[\"colorMultiply\"].value = this.configuration.colorMultiply;\n        this.effectCompositerQuad.material.uniforms[\"cameraPos\"].value = this.camera.getWorldPosition(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n        this.effectCompositerQuad.material.uniforms[\"fog\"].value = !!this.scene.fog;\n        if (this.scene.fog) {\n            if (this.scene.fog.isFog) {\n                this.effectCompositerQuad.material.uniforms[\"fogExp\"].value = false;\n                this.effectCompositerQuad.material.uniforms[\"fogNear\"].value = this.scene.fog.near;\n                this.effectCompositerQuad.material.uniforms[\"fogFar\"].value = this.scene.fog.far;\n            } else if (this.scene.fog.isFogExp2) {\n                this.effectCompositerQuad.material.uniforms[\"fogExp\"].value = true;\n                this.effectCompositerQuad.material.uniforms[\"fogDensity\"].value = this.scene.fog.density;\n            } else console.error(`Unsupported fog type ${this.scene.fog.constructor.name} in SSAOPass.`);\n        }\n        renderer.setRenderTarget(/* this.renderToScreen ? null :\n                 outputBuffer*/ this.outputTargetInternal);\n        this.effectCompositerQuad.render(renderer);\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n        this.copyQuad.material.uniforms[\"tDiffuse\"].value = this.outputTargetInternal.texture;\n        this.copyQuad.render(renderer);\n        if (this.debugMode) {\n            gl.endQuery(ext.TIME_ELAPSED_EXT);\n            $87431ee93b037844$var$checkTimerQuery(timerQuery, gl, this);\n        }\n        renderer.xr.enabled = xrEnabled;\n    }\n    /**\n         * Enables the debug mode of the AO, meaning the lastTime value will be updated.\n         */ enableDebugMode() {\n        this.debugMode = true;\n    }\n    /**\n         * Disables the debug mode of the AO, meaning the lastTime value will not be updated.\n         */ disableDebugMode() {\n        this.debugMode = false;\n    }\n    /**\n         * Sets the display mode of the AO\n         * @param {\"Combined\" | \"AO\" | \"No AO\" | \"Split\" | \"Split AO\"} mode - The display mode. \n         */ setDisplayMode(mode) {\n        this.configuration.renderMode = [\n            \"Combined\",\n            \"AO\",\n            \"No AO\",\n            \"Split\",\n            \"Split AO\"\n        ].indexOf(mode);\n    }\n    /**\n         * \n         * @param {\"Performance\" | \"Low\" | \"Medium\" | \"High\" | \"Ultra\"} mode \n         */ setQualityMode(mode) {\n        if (mode === \"Performance\") {\n            this.configuration.aoSamples = 8;\n            this.configuration.denoiseSamples = 4;\n            this.configuration.denoiseRadius = 12;\n        } else if (mode === \"Low\") {\n            this.configuration.aoSamples = 16;\n            this.configuration.denoiseSamples = 4;\n            this.configuration.denoiseRadius = 12;\n        } else if (mode === \"Medium\") {\n            this.configuration.aoSamples = 16;\n            this.configuration.denoiseSamples = 8;\n            this.configuration.denoiseRadius = 12;\n        } else if (mode === \"High\") {\n            this.configuration.aoSamples = 64;\n            this.configuration.denoiseSamples = 8;\n            this.configuration.denoiseRadius = 6;\n        } else if (mode === \"Ultra\") {\n            this.configuration.aoSamples = 64;\n            this.configuration.denoiseSamples = 16;\n            this.configuration.denoiseRadius = 6;\n        }\n    }\n}\n\n\n\n\n/**\n * \n * @param {*} timerQuery \n * @param {THREE.WebGLRenderer} gl \n * @param {N8AOPass} pass \n */ function $05f6997e4b65da14$var$checkTimerQuery(timerQuery, gl, pass) {\n    const available = gl.getQueryParameter(timerQuery, gl.QUERY_RESULT_AVAILABLE);\n    if (available) {\n        const elapsedTimeInNs = gl.getQueryParameter(timerQuery, gl.QUERY_RESULT);\n        const elapsedTimeInMs = elapsedTimeInNs / 1000000;\n        pass.lastTime = pass.lastTime === 0 ? elapsedTimeInMs : pass.timeRollingAverage * pass.lastTime + (1 - pass.timeRollingAverage) * elapsedTimeInMs;\n    } else // If the result is not available yet, check again after a delay\n    setTimeout(()=>{\n        $05f6997e4b65da14$var$checkTimerQuery(timerQuery, gl, pass);\n    }, 1);\n}\nconst $05f6997e4b65da14$export$ed4ee5d1e55474a5 = {\n    Default: 1,\n    Log: 2,\n    Reverse: 3\n};\nclass $05f6997e4b65da14$export$2d57db20b5eb5e0a extends (0, three_examples_jsm_postprocessing_Pass_js__WEBPACK_IMPORTED_MODULE_2__.Pass) {\n    /**\n     * \n     * @param {THREE.Scene} scene\n     * @param {THREE.Camera} camera \n     * @param {number} width \n     * @param {number} height\n     *  \n     * @property {THREE.Scene} scene\n     * @property {THREE.Camera} camera\n     * @property {number} width\n     * @property {number} height\n     */ constructor(scene, camera, width = 512, height = 512){\n        super();\n        this.width = width;\n        this.height = height;\n        this.clear = true;\n        this.camera = camera;\n        this.scene = scene;\n        /**\n         * @type {Proxy & {\n         * aoSamples: number,\n         * aoRadius: number,\n         * denoiseSamples: number,\n         * denoiseRadius: number,\n         * distanceFalloff: number,\n         * intensity: number,\n         * denoiseIterations: number,\n         * renderMode: 0 | 1 | 2 | 3 | 4,\n         * color: THREE.Color,\n         * gammaCorrection: boolean,\n         * depthBufferType: 1 | 2 | 3,\n         * screenSpaceRadius: boolean,\n         * halfRes: boolean,\n         * depthAwareUpsampling: boolean,\n         * autoRenderBeauty: boolean\n         * colorMultiply: boolean\n         * }\n         */ this.configuration = new Proxy({\n            aoSamples: 16,\n            aoRadius: 5.0,\n            aoTones: 0.0,\n            denoiseSamples: 8,\n            denoiseRadius: 12,\n            distanceFalloff: 1.0,\n            intensity: 5,\n            denoiseIterations: 2.0,\n            renderMode: 0,\n            biasOffset: 0.0,\n            biasMultiplier: 0.0,\n            color: new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0),\n            gammaCorrection: true,\n            depthBufferType: $05f6997e4b65da14$export$ed4ee5d1e55474a5.Default,\n            screenSpaceRadius: false,\n            halfRes: false,\n            depthAwareUpsampling: true,\n            autoRenderBeauty: true,\n            colorMultiply: true,\n            transparencyAware: false,\n            stencil: false,\n            accumulate: false\n        }, {\n            set: (target, propName, value)=>{\n                const oldProp = target[propName];\n                target[propName] = value;\n                if (value.equals) {\n                    if (!value.equals(oldProp)) this.firstFrame();\n                } else if (oldProp !== value) this.firstFrame();\n                if (propName === \"aoSamples\" && oldProp !== value) this.configureAOPass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n                if (propName === \"denoiseSamples\" && oldProp !== value) this.configureDenoisePass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n                if (propName === \"halfRes\" && oldProp !== value) {\n                    this.configureAOPass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n                    this.configureHalfResTargets();\n                    this.configureEffectCompositer(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n                    this.setSize(this.width, this.height);\n                }\n                if (propName === \"depthAwareUpsampling\" && oldProp !== value) this.configureEffectCompositer(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n                if (propName === \"transparencyAware\" && oldProp !== value) {\n                    this.autoDetectTransparency = false;\n                    this.configureTransparencyTarget();\n                }\n                if (propName === \"stencil\" && oldProp !== value) {\n                    /*  this.beautyRenderTarget.stencilBuffer = value;\n                      this.beautyRenderTarget.depthTexture.format = value ? THREE.DepthStencilFormat : THREE.DepthFormat;\n                      this.beautyRenderTarget.depthTexture.type = value ? THREE.UnsignedInt248Type : THREE.UnsignedIntType;\n                      this.beautyRenderTarget.depthTexture.needsUpdate = true;\n                      this.beautyRenderTarget.needsUpdate = true;*/ this.beautyRenderTarget.dispose();\n                    this.beautyRenderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n                        minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n                        magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n                        type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n                        format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n                        stencilBuffer: value\n                    });\n                    this.beautyRenderTarget.depthTexture = new three__WEBPACK_IMPORTED_MODULE_0__.DepthTexture(this.width, this.height, value ? three__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt248Type : three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType);\n                    this.beautyRenderTarget.depthTexture.format = value ? three__WEBPACK_IMPORTED_MODULE_0__.DepthStencilFormat : three__WEBPACK_IMPORTED_MODULE_0__.DepthFormat;\n                }\n                return true;\n            }\n        });\n        /** @type {THREE.Vector3[]} */ this.samples = [];\n        /** @type {THREE.Vector2[]} */ this.samplesDenoise = [];\n        this.autoDetectTransparency = true;\n        this.frame = 0;\n        this.lastViewMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.lastProjectionMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.beautyRenderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n            stencilBuffer: false\n        });\n        this.beautyRenderTarget.depthTexture = new three__WEBPACK_IMPORTED_MODULE_0__.DepthTexture(this.width, this.height, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType);\n        this.beautyRenderTarget.depthTexture.format = three__WEBPACK_IMPORTED_MODULE_0__.DepthFormat;\n        this.configureEffectCompositer(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n        this.configureSampleDependentPasses();\n        this.configureHalfResTargets();\n        this.detectTransparency();\n        this.configureTransparencyTarget();\n        this.writeTargetInternal = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            depthBuffer: false,\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat\n        });\n        this.readTargetInternal = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            depthBuffer: false,\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat\n        });\n        this.accumulationRenderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            depthBuffer: false,\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n            stencilBuffer: false,\n            depthBuffer: false,\n            alpha: true\n        });\n        /** @type {THREE.DataTexture} */ this.bluenoise = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture((0, $06269ad78f3c5fdf$export$2e2bcd8739ae039), 128, 128);\n        this.accumulationQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n            uniforms: {\n                frame: {\n                    value: 0\n                },\n                tDiffuse: {\n                    value: null\n                }\n            },\n            transparent: true,\n            opacity: 1,\n            vertexShader: `\n             varying vec2 vUv;\n             void main() {\n                 vUv = uv;\n                 gl_Position = vec4(position, 1);\n             }`,\n            fragmentShader: `\n             uniform sampler2D tDiffuse;\n             uniform float frame;\n                varying vec2 vUv;\n                void main() {\n                    vec4 color = texture2D(tDiffuse, vUv);\n                    gl_FragColor = vec4(color.rgb, 1.0 / (frame + 1.0));\n                }\n                `\n        }));\n        this.bluenoise.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace;\n        this.bluenoise.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n        this.bluenoise.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n        this.bluenoise.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n        this.bluenoise.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n        this.bluenoise.needsUpdate = true;\n        this.lastTime = 0;\n        this.timeRollingAverage = 0.99;\n        this._r = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this._c = new three__WEBPACK_IMPORTED_MODULE_0__.Color();\n    }\n    configureHalfResTargets() {\n        this.firstFrame();\n        if (this.configuration.halfRes) {\n            this.depthDownsampleTarget = new (0, $ff9437d9c7577f11$export$156f6a58f569aa09)(this.width / 2, this.height / 2, 2);\n            if (three__WEBPACK_IMPORTED_MODULE_0__.REVISION <= 161) this.depthDownsampleTarget.textures = this.depthDownsampleTarget.texture;\n            this.depthDownsampleTarget.textures[0].format = three__WEBPACK_IMPORTED_MODULE_0__.RedFormat;\n            this.depthDownsampleTarget.textures[0].type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n            this.depthDownsampleTarget.textures[0].minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            this.depthDownsampleTarget.textures[0].magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            this.depthDownsampleTarget.textures[0].depthBuffer = false;\n            this.depthDownsampleTarget.textures[1].format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n            this.depthDownsampleTarget.textures[1].type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n            this.depthDownsampleTarget.textures[1].minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            this.depthDownsampleTarget.textures[1].magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            this.depthDownsampleTarget.textures[1].depthBuffer = false;\n            const e = {\n                ...(0, $26aca173e0984d99$export$1efdf491687cd442)\n            };\n            if (this.configuration.depthBufferType === $05f6997e4b65da14$export$ed4ee5d1e55474a5.Reverse) e.fragmentShader = \"#define REVERSEDEPTH\\n\" + e.fragmentShader;\n            this.depthDownsampleQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(e));\n        } else {\n            if (this.depthDownsampleTarget) {\n                this.depthDownsampleTarget.dispose();\n                this.depthDownsampleTarget = null;\n            }\n            if (this.depthDownsampleQuad) {\n                this.depthDownsampleQuad.dispose();\n                this.depthDownsampleQuad = null;\n            }\n        }\n    }\n    detectTransparency() {\n        if (this.autoDetectTransparency) {\n            let isTransparency = false;\n            this.scene.traverse((obj)=>{\n                if (obj.material && obj.material.transparent) isTransparency = true;\n            });\n            this.configuration.transparencyAware = isTransparency;\n        }\n    }\n    configureTransparencyTarget() {\n        if (this.configuration.transparencyAware) {\n            this.transparencyRenderTargetDWFalse = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n                minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n                magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n                type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n                format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat\n            });\n            this.transparencyRenderTargetDWTrue = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, {\n                minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n                magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n                type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n                format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat\n            });\n            this.transparencyRenderTargetDWTrue.depthTexture = new three__WEBPACK_IMPORTED_MODULE_0__.DepthTexture(this.width, this.height, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType);\n            this.depthCopyPass = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n                uniforms: {\n                    depthTexture: {\n                        value: this.depthTexture\n                    },\n                    reverseDepthBuffer: {\n                        value: this.configuration.depthBufferType === $05f6997e4b65da14$export$ed4ee5d1e55474a5.Reverse\n                    }\n                },\n                vertexShader: /* glsl */ `\n                        varying vec2 vUv;\n                        void main() {\n                            vUv = uv;\n                            gl_Position = vec4(position, 1);\n                        }`,\n                fragmentShader: /* glsl */ `\n                        uniform sampler2D depthTexture;\n                        uniform bool reverseDepthBuffer;\n                        varying vec2 vUv;\n                        void main() {\n                            if (reverseDepthBuffer) {\n                           float d = 1.0 - texture2D(depthTexture, vUv).r;\n                       \n                           d += 0.00001;\n                           gl_FragDepth = 1.0 - d;\n                        } else {\n                            float d = texture2D(depthTexture, vUv).r;\n                            d += 0.00001;\n                            gl_FragDepth = d;\n                        }\n                           gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n                        }\n                        `\n            }));\n        } else {\n            if (this.transparencyRenderTargetDWFalse) {\n                this.transparencyRenderTargetDWFalse.dispose();\n                this.transparencyRenderTargetDWFalse = null;\n            }\n            if (this.transparencyRenderTargetDWTrue) {\n                this.transparencyRenderTargetDWTrue.dispose();\n                this.transparencyRenderTargetDWTrue = null;\n            }\n            if (this.depthCopyPass) {\n                this.depthCopyPass.dispose();\n                this.depthCopyPass = null;\n            }\n        }\n    }\n    renderTransparency(renderer) {\n        const oldBackground = this.scene.background;\n        const oldClearColor = renderer.getClearColor(new three__WEBPACK_IMPORTED_MODULE_0__.Color());\n        const oldClearAlpha = renderer.getClearAlpha();\n        const oldVisibility = new Map();\n        const oldAutoClearDepth = renderer.autoClearDepth;\n        this.scene.traverse((obj)=>{\n            oldVisibility.set(obj, obj.visible);\n        });\n        // Override the state\n        this.scene.background = null;\n        renderer.autoClearDepth = false;\n        renderer.setClearColor(new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0), 0);\n        this.depthCopyPass.material.uniforms.depthTexture.value = this.beautyRenderTarget.depthTexture;\n        this.depthCopyPass.material.uniforms.reverseDepthBuffer.value = this.configuration.depthBufferType === $05f6997e4b65da14$export$ed4ee5d1e55474a5.Reverse;\n        // Render out transparent objects WITHOUT depth write\n        renderer.setRenderTarget(this.transparencyRenderTargetDWFalse);\n        this.scene.traverse((obj)=>{\n            if (obj.material) obj.visible = oldVisibility.get(obj) && (obj.material.transparent && !obj.material.depthWrite && !obj.userData.treatAsOpaque || !!obj.userData.cannotReceiveAO);\n        });\n        renderer.clear(true, true, true);\n        this.depthCopyPass.render(renderer);\n        renderer.render(this.scene, this.camera);\n        // Render out transparent objects WITH depth write\n        renderer.setRenderTarget(this.transparencyRenderTargetDWTrue);\n        this.scene.traverse((obj)=>{\n            if (obj.material) obj.visible = oldVisibility.get(obj) && obj.material.transparent && obj.material.depthWrite && !obj.userData.treatAsOpaque;\n        });\n        renderer.clear(true, true, true);\n        this.depthCopyPass.render(renderer);\n        renderer.render(this.scene, this.camera);\n        // Restore\n        this.scene.traverse((obj)=>{\n            obj.visible = oldVisibility.get(obj);\n        });\n        renderer.setClearColor(oldClearColor, oldClearAlpha);\n        this.scene.background = oldBackground;\n        renderer.autoClearDepth = oldAutoClearDepth;\n    }\n    configureSampleDependentPasses() {\n        this.firstFrame();\n        this.configureAOPass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n        this.configureDenoisePass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n    }\n    configureAOPass(depthBufferType = $05f6997e4b65da14$export$ed4ee5d1e55474a5.Default, ortho = false) {\n        this.firstFrame();\n        this.samples = this.generateHemisphereSamples(this.configuration.aoSamples);\n        const e = {\n            ...(0, $1ed45968c1160c3c$export$c9b263b9a17dffd7)\n        };\n        e.fragmentShader = e.fragmentShader.replace(\"16\", this.configuration.aoSamples).replace(\"16.0\", this.configuration.aoSamples + \".0\");\n        if (depthBufferType === $05f6997e4b65da14$export$ed4ee5d1e55474a5.Log) e.fragmentShader = \"#define LOGDEPTH\\n\" + e.fragmentShader;\n        else if (depthBufferType === $05f6997e4b65da14$export$ed4ee5d1e55474a5.Reverse) e.fragmentShader = \"#define REVERSEDEPTH\\n\" + e.fragmentShader;\n        if (ortho) e.fragmentShader = \"#define ORTHO\\n\" + e.fragmentShader;\n        if (this.configuration.halfRes) e.fragmentShader = \"#define HALFRES\\n\" + e.fragmentShader;\n        if (this.effectShaderQuad) {\n            this.effectShaderQuad.material.dispose();\n            this.effectShaderQuad.material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(e);\n        } else this.effectShaderQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(e));\n    }\n    configureDenoisePass(depthBufferType = $05f6997e4b65da14$export$ed4ee5d1e55474a5.Default, ortho = false) {\n        this.firstFrame();\n        this.samplesDenoise = this.generateDenoiseSamples(this.configuration.denoiseSamples, 11);\n        const p = {\n            ...(0, $e52378cd0f5a973d$export$57856b59f317262e)\n        };\n        p.fragmentShader = p.fragmentShader.replace(\"16\", this.configuration.denoiseSamples);\n        if (depthBufferType === $05f6997e4b65da14$export$ed4ee5d1e55474a5.Log) p.fragmentShader = \"#define LOGDEPTH\\n\" + p.fragmentShader;\n        else if (depthBufferType === $05f6997e4b65da14$export$ed4ee5d1e55474a5.Reverse) p.fragmentShader = \"#define REVERSEDEPTH\\n\" + p.fragmentShader;\n        if (ortho) p.fragmentShader = \"#define ORTHO\\n\" + p.fragmentShader;\n        if (this.poissonBlurQuad) {\n            this.poissonBlurQuad.material.dispose();\n            this.poissonBlurQuad.material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(p);\n        } else this.poissonBlurQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(p));\n    }\n    configureEffectCompositer(depthBufferType = $05f6997e4b65da14$export$ed4ee5d1e55474a5.Default, ortho = false) {\n        this.firstFrame();\n        const e = {\n            ...(0, $12b21d24d1192a04$export$a815acccbd2c9a49)\n        };\n        if (depthBufferType === $05f6997e4b65da14$export$ed4ee5d1e55474a5.Log) e.fragmentShader = \"#define LOGDEPTH\\n\" + e.fragmentShader;\n        else if (depthBufferType === $05f6997e4b65da14$export$ed4ee5d1e55474a5.Reverse) e.fragmentShader = \"#define REVERSEDEPTH\\n\" + e.fragmentShader;\n        if (ortho) e.fragmentShader = \"#define ORTHO\\n\" + e.fragmentShader;\n        if (this.configuration.halfRes && this.configuration.depthAwareUpsampling) e.fragmentShader = \"#define HALFRES\\n\" + e.fragmentShader;\n        if (this.effectCompositerQuad) {\n            this.effectCompositerQuad.material.dispose();\n            this.effectCompositerQuad.material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(e);\n        } else this.effectCompositerQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(e));\n    }\n    /**\n         * \n         * @param {Number} n \n         * @returns {THREE.Vector3[]}\n         */ generateHemisphereSamples(n) {\n        const points = [];\n        for(let k = 0; k < n; k++){\n            const theta = 2.399963 * k;\n            let r = Math.sqrt(k + 0.5) / Math.sqrt(n);\n            const x = r * Math.cos(theta);\n            const y = r * Math.sin(theta);\n            // Project to hemisphere\n            const z = Math.sqrt(1 - (x * x + y * y));\n            points.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z));\n        }\n        return points;\n    }\n    /**\n         * \n         * @param {number} numSamples \n         * @param {number} numRings \n         * @returns {THREE.Vector2[]}\n         */ generateDenoiseSamples(numSamples, numRings) {\n        const angleStep = 2 * Math.PI * numRings / numSamples;\n        const invNumSamples = 1.0 / numSamples;\n        const radiusStep = invNumSamples;\n        const samples = [];\n        let radius = invNumSamples;\n        let angle = 0;\n        for(let i = 0; i < numSamples; i++){\n            samples.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(Math.cos(angle), Math.sin(angle)).multiplyScalar(Math.pow(radius, 0.75)));\n            radius += radiusStep;\n            angle += angleStep;\n        }\n        return samples;\n    }\n    setSize(width, height) {\n        this.firstFrame();\n        this.width = width;\n        this.height = height;\n        const c = this.configuration.halfRes ? 0.5 : 1;\n        this.beautyRenderTarget.setSize(width, height);\n        this.writeTargetInternal.setSize(width * c, height * c);\n        this.readTargetInternal.setSize(width * c, height * c);\n        this.accumulationRenderTarget.setSize(width * c, height * c);\n        if (this.configuration.halfRes) this.depthDownsampleTarget.setSize(width * c, height * c);\n        if (this.configuration.transparencyAware) {\n            this.transparencyRenderTargetDWFalse.setSize(width, height);\n            this.transparencyRenderTargetDWTrue.setSize(width, height);\n        }\n    }\n    firstFrame() {\n        this.needsFrame = true;\n    }\n    render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n        if (renderer.capabilities.logarithmicDepthBuffer && this.configuration.depthBufferType !== $05f6997e4b65da14$export$ed4ee5d1e55474a5.Log || renderer.capabilities.reverseDepthBuffer && this.configuration.depthBufferType !== $05f6997e4b65da14$export$ed4ee5d1e55474a5.Reverse) {\n            this.configuration.depthBufferType = renderer.capabilities.logarithmicDepthBuffer ? $05f6997e4b65da14$export$ed4ee5d1e55474a5.Log : renderer.capabilities.reverseDepthBuffer ? $05f6997e4b65da14$export$ed4ee5d1e55474a5.Reverse : $05f6997e4b65da14$export$ed4ee5d1e55474a5.Default;\n            this.configureAOPass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n            this.configureDenoisePass(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n            this.configureEffectCompositer(this.configuration.depthBufferType, this.camera.isOrthographicCamera);\n        }\n        this.detectTransparency();\n        this.camera.updateMatrixWorld();\n        if (this.lastViewMatrix.equals(this.camera.matrixWorldInverse) && this.lastProjectionMatrix.equals(this.camera.projectionMatrix) && this.configuration.accumulate && !this.needsFrame) this.frame++;\n        else {\n            if (this.configuration.accumulate) {\n                renderer.setRenderTarget(this.accumulationRenderTarget);\n                renderer.clear(true, true, true);\n            }\n            this.frame = 0;\n            this.needsFrame = false;\n        }\n        this.lastViewMatrix.copy(this.camera.matrixWorldInverse);\n        this.lastProjectionMatrix.copy(this.camera.projectionMatrix);\n        let gl;\n        let ext;\n        let timerQuery;\n        if (this.debugMode) {\n            gl = renderer.getContext();\n            ext = gl.getExtension(\"EXT_disjoint_timer_query_webgl2\");\n            if (ext === null) {\n                console.error(\"EXT_disjoint_timer_query_webgl2 not available, disabling debug mode.\");\n                this.debugMode = false;\n            }\n        }\n        if (this.configuration.autoRenderBeauty) {\n            renderer.setRenderTarget(this.beautyRenderTarget);\n            renderer.render(this.scene, this.camera);\n            if (this.configuration.transparencyAware) this.renderTransparency(renderer);\n        }\n        if (this.debugMode) {\n            timerQuery = gl.createQuery();\n            gl.beginQuery(ext.TIME_ELAPSED_EXT, timerQuery);\n        }\n        const xrEnabled = renderer.xr.enabled;\n        renderer.xr.enabled = false;\n        this._r.set(this.width, this.height);\n        let trueRadius = this.configuration.aoRadius;\n        if (this.configuration.halfRes && this.configuration.screenSpaceRadius) trueRadius *= 0.5;\n        if (this.frame < 1024 / this.configuration.aoSamples) {\n            if (this.configuration.halfRes) {\n                renderer.setRenderTarget(this.depthDownsampleTarget);\n                this.depthDownsampleQuad.material.uniforms.sceneDepth.value = this.beautyRenderTarget.depthTexture;\n                this.depthDownsampleQuad.material.uniforms.resolution.value = this._r;\n                this.depthDownsampleQuad.material.uniforms[\"near\"].value = this.camera.near;\n                this.depthDownsampleQuad.material.uniforms[\"far\"].value = this.camera.far;\n                this.depthDownsampleQuad.material.uniforms[\"projectionMatrixInv\"].value = this.camera.projectionMatrixInverse;\n                this.depthDownsampleQuad.material.uniforms[\"viewMatrixInv\"].value = this.camera.matrixWorld;\n                this.depthDownsampleQuad.material.uniforms[\"logDepth\"].value = this.configuration.depthBufferType === $05f6997e4b65da14$export$ed4ee5d1e55474a5.Log;\n                this.depthDownsampleQuad.material.uniforms[\"ortho\"].value = this.camera.isOrthographicCamera;\n                this.depthDownsampleQuad.render(renderer);\n            }\n            this.effectShaderQuad.material.uniforms[\"sceneDiffuse\"].value = this.beautyRenderTarget.texture;\n            this.effectShaderQuad.material.uniforms[\"sceneDepth\"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.beautyRenderTarget.depthTexture;\n            this.effectShaderQuad.material.uniforms[\"sceneNormal\"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[1] : null;\n            this.effectShaderQuad.material.uniforms[\"projMat\"].value = this.camera.projectionMatrix;\n            this.effectShaderQuad.material.uniforms[\"viewMat\"].value = this.camera.matrixWorldInverse;\n            this.effectShaderQuad.material.uniforms[\"projViewMat\"].value = this.camera.projectionMatrix.clone().multiply(this.camera.matrixWorldInverse.clone());\n            this.effectShaderQuad.material.uniforms[\"projectionMatrixInv\"].value = this.camera.projectionMatrixInverse;\n            this.effectShaderQuad.material.uniforms[\"viewMatrixInv\"].value = this.camera.matrixWorld;\n            this.effectShaderQuad.material.uniforms[\"cameraPos\"].value = this.camera.getWorldPosition(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n            this.effectShaderQuad.material.uniforms[\"biasAdjustment\"].value = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(this.configuration.biasOffset, this.configuration.biasMultiplier);\n            this.effectShaderQuad.material.uniforms[\"resolution\"].value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r;\n            this.effectShaderQuad.material.uniforms[\"time\"].value = performance.now() / 1000;\n            this.effectShaderQuad.material.uniforms[\"samples\"].value = this.samples;\n            this.effectShaderQuad.material.uniforms[\"bluenoise\"].value = this.bluenoise;\n            this.effectShaderQuad.material.uniforms[\"radius\"].value = trueRadius;\n            this.effectShaderQuad.material.uniforms[\"distanceFalloff\"].value = this.configuration.distanceFalloff;\n            this.effectShaderQuad.material.uniforms[\"near\"].value = this.camera.near;\n            this.effectShaderQuad.material.uniforms[\"far\"].value = this.camera.far;\n            this.effectShaderQuad.material.uniforms[\"ortho\"].value = this.camera.isOrthographicCamera;\n            this.effectShaderQuad.material.uniforms[\"screenSpaceRadius\"].value = this.configuration.screenSpaceRadius;\n            this.effectShaderQuad.material.uniforms[\"frame\"].value = this.frame;\n            // Start the AO\n            renderer.setRenderTarget(this.writeTargetInternal);\n            this.effectShaderQuad.render(renderer);\n            // End the AO\n            // Start the blur\n            for(let i = 0; i < this.configuration.denoiseIterations; i++){\n                [this.writeTargetInternal, this.readTargetInternal] = [\n                    this.readTargetInternal,\n                    this.writeTargetInternal\n                ];\n                this.poissonBlurQuad.material.uniforms[\"tDiffuse\"].value = this.readTargetInternal.texture;\n                this.poissonBlurQuad.material.uniforms[\"sceneDepth\"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.beautyRenderTarget.depthTexture;\n                this.poissonBlurQuad.material.uniforms[\"projMat\"].value = this.camera.projectionMatrix;\n                this.poissonBlurQuad.material.uniforms[\"viewMat\"].value = this.camera.matrixWorldInverse;\n                this.poissonBlurQuad.material.uniforms[\"projectionMatrixInv\"].value = this.camera.projectionMatrixInverse;\n                this.poissonBlurQuad.material.uniforms[\"viewMatrixInv\"].value = this.camera.matrixWorld;\n                this.poissonBlurQuad.material.uniforms[\"cameraPos\"].value = this.camera.getWorldPosition(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n                this.poissonBlurQuad.material.uniforms[\"resolution\"].value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r;\n                this.poissonBlurQuad.material.uniforms[\"time\"].value = performance.now() / 1000;\n                this.poissonBlurQuad.material.uniforms[\"blueNoise\"].value = this.bluenoise;\n                this.poissonBlurQuad.material.uniforms[\"radius\"].value = this.configuration.denoiseRadius * (this.configuration.halfRes ? 0.5 : 1);\n                this.poissonBlurQuad.material.uniforms[\"worldRadius\"].value = trueRadius;\n                this.poissonBlurQuad.material.uniforms[\"distanceFalloff\"].value = this.configuration.distanceFalloff;\n                this.poissonBlurQuad.material.uniforms[\"index\"].value = i;\n                this.poissonBlurQuad.material.uniforms[\"poissonDisk\"].value = this.samplesDenoise;\n                this.poissonBlurQuad.material.uniforms[\"near\"].value = this.camera.near;\n                this.poissonBlurQuad.material.uniforms[\"far\"].value = this.camera.far;\n                this.poissonBlurQuad.material.uniforms[\"screenSpaceRadius\"].value = this.configuration.screenSpaceRadius;\n                renderer.setRenderTarget(this.writeTargetInternal);\n                this.poissonBlurQuad.render(renderer);\n            }\n            renderer.setRenderTarget(this.accumulationRenderTarget);\n            const oldAutoClear = renderer.autoClear;\n            renderer.autoClear = false;\n            this.accumulationQuad.material.uniforms[\"tDiffuse\"].value = this.writeTargetInternal.texture;\n            this.accumulationQuad.material.uniforms[\"frame\"].value = this.frame;\n            this.accumulationQuad.render(renderer);\n            renderer.autoClear = oldAutoClear;\n        }\n        // Now, we have the blurred AO in writeTargetInternal\n        // End the blur\n        // Start the composition\n        if (this.configuration.transparencyAware) {\n            this.effectCompositerQuad.material.uniforms[\"transparencyDWFalse\"].value = this.transparencyRenderTargetDWFalse.texture;\n            this.effectCompositerQuad.material.uniforms[\"transparencyDWTrue\"].value = this.transparencyRenderTargetDWTrue.texture;\n            this.effectCompositerQuad.material.uniforms[\"transparencyDWTrueDepth\"].value = this.transparencyRenderTargetDWTrue.depthTexture;\n            this.effectCompositerQuad.material.uniforms[\"transparencyAware\"].value = true;\n        }\n        this.effectCompositerQuad.material.uniforms[\"sceneDiffuse\"].value = this.beautyRenderTarget.texture;\n        this.effectCompositerQuad.material.uniforms[\"sceneDepth\"].value = this.beautyRenderTarget.depthTexture;\n        this.effectCompositerQuad.material.uniforms[\"aoTones\"].value = this.configuration.aoTones;\n        this.effectCompositerQuad.material.uniforms[\"near\"].value = this.camera.near;\n        this.effectCompositerQuad.material.uniforms[\"far\"].value = this.camera.far;\n        this.effectCompositerQuad.material.uniforms[\"projectionMatrixInv\"].value = this.camera.projectionMatrixInverse;\n        this.effectCompositerQuad.material.uniforms[\"viewMatrixInv\"].value = this.camera.matrixWorld;\n        this.effectCompositerQuad.material.uniforms[\"ortho\"].value = this.camera.isOrthographicCamera;\n        this.effectCompositerQuad.material.uniforms[\"downsampledDepth\"].value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.beautyRenderTarget.depthTexture;\n        this.effectCompositerQuad.material.uniforms[\"resolution\"].value = this._r;\n        this.effectCompositerQuad.material.uniforms[\"blueNoise\"].value = this.bluenoise;\n        this.effectCompositerQuad.material.uniforms[\"intensity\"].value = this.configuration.intensity;\n        this.effectCompositerQuad.material.uniforms[\"renderMode\"].value = this.configuration.renderMode;\n        this.effectCompositerQuad.material.uniforms[\"screenSpaceRadius\"].value = this.configuration.screenSpaceRadius;\n        this.effectCompositerQuad.material.uniforms[\"radius\"].value = trueRadius;\n        this.effectCompositerQuad.material.uniforms[\"distanceFalloff\"].value = this.configuration.distanceFalloff;\n        this.effectCompositerQuad.material.uniforms[\"gammaCorrection\"].value = this.configuration.gammaCorrection;\n        this.effectCompositerQuad.material.uniforms[\"tDiffuse\"].value = this.accumulationRenderTarget.texture;\n        this.effectCompositerQuad.material.uniforms[\"color\"].value = this._c.copy(this.configuration.color).convertSRGBToLinear();\n        this.effectCompositerQuad.material.uniforms[\"colorMultiply\"].value = this.configuration.colorMultiply;\n        this.effectCompositerQuad.material.uniforms[\"cameraPos\"].value = this.camera.getWorldPosition(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n        this.effectCompositerQuad.material.uniforms[\"fog\"].value = !!this.scene.fog;\n        if (this.scene.fog) {\n            if (this.scene.fog.isFog) {\n                this.effectCompositerQuad.material.uniforms[\"fogExp\"].value = false;\n                this.effectCompositerQuad.material.uniforms[\"fogNear\"].value = this.scene.fog.near;\n                this.effectCompositerQuad.material.uniforms[\"fogFar\"].value = this.scene.fog.far;\n            } else if (this.scene.fog.isFogExp2) {\n                this.effectCompositerQuad.material.uniforms[\"fogExp\"].value = true;\n                this.effectCompositerQuad.material.uniforms[\"fogDensity\"].value = this.scene.fog.density;\n            } else console.error(`Unsupported fog type ${this.scene.fog.constructor.name} in SSAOPass.`);\n        }\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        this.effectCompositerQuad.render(renderer);\n        if (this.debugMode) {\n            gl.endQuery(ext.TIME_ELAPSED_EXT);\n            $05f6997e4b65da14$var$checkTimerQuery(timerQuery, gl, this);\n        }\n        renderer.xr.enabled = xrEnabled;\n    }\n    /**\n         * Enables the debug mode of the AO, meaning the lastTime value will be updated.\n         */ enableDebugMode() {\n        this.debugMode = true;\n    }\n    /**\n         * Disables the debug mode of the AO, meaning the lastTime value will not be updated.\n         */ disableDebugMode() {\n        this.debugMode = false;\n    }\n    /**\n         * Sets the display mode of the AO\n         * @param {\"Combined\" | \"AO\" | \"No AO\" | \"Split\" | \"Split AO\"} mode - The display mode. \n         */ setDisplayMode(mode) {\n        this.configuration.renderMode = [\n            \"Combined\",\n            \"AO\",\n            \"No AO\",\n            \"Split\",\n            \"Split AO\"\n        ].indexOf(mode);\n    }\n    /**\n         * \n         * @param {\"Performance\" | \"Low\" | \"Medium\" | \"High\" | \"Ultra\"} mode \n         */ setQualityMode(mode) {\n        if (mode === \"Performance\") {\n            this.configuration.aoSamples = 8;\n            this.configuration.denoiseSamples = 4;\n            this.configuration.denoiseRadius = 12;\n        } else if (mode === \"Low\") {\n            this.configuration.aoSamples = 16;\n            this.configuration.denoiseSamples = 4;\n            this.configuration.denoiseRadius = 12;\n        } else if (mode === \"Medium\") {\n            this.configuration.aoSamples = 16;\n            this.configuration.denoiseSamples = 8;\n            this.configuration.denoiseRadius = 12;\n        } else if (mode === \"High\") {\n            this.configuration.aoSamples = 64;\n            this.configuration.denoiseSamples = 8;\n            this.configuration.denoiseRadius = 6;\n        } else if (mode === \"Ultra\") {\n            this.configuration.aoSamples = 64;\n            this.configuration.denoiseSamples = 16;\n            this.configuration.denoiseRadius = 6;\n        }\n    }\n}\n\n\n\n//# sourceMappingURL=N8AO.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uOGFvL2Rpc3QvTjhBTy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNjdCO0FBQy8yQjtBQUMxQjs7Ozs7QUFLcEQsK0RBQStELGlEQUFxQjtBQUNwRix5QkFBeUIseUNBQWE7QUFDdEM7QUFDQTtBQUNBLDBDQUEwQyxrREFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0RBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQscURBQXlCO0FBQ25GO0FBQ0E7QUFDQSx5QkFBeUIsdUNBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUMsMENBQWM7QUFDckQsU0FBUztBQUNUO0FBQ0EsdUNBQXVDLDBDQUFjO0FBQ3JELFNBQVM7QUFDVDtBQUNBLHVDQUF1QywwQ0FBYztBQUNyRCxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUMsMENBQWM7QUFDckQsU0FBUztBQUNUO0FBQ0EsdUNBQXVDLDBDQUFjO0FBQ3JELFNBQVM7QUFDVDtBQUNBLHVDQUF1QywwQ0FBYztBQUNyRCxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUMsMENBQWM7QUFDckQsU0FBUztBQUNUO0FBQ0EsdUNBQXVDLDBDQUFjO0FBQ3JELFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUNBQXVDLDBDQUFjO0FBQ3JELFNBQVM7QUFDVDtBQUNBLHVDQUF1QywwQ0FBYztBQUNyRCxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUMsMENBQWM7QUFDckQsU0FBUztBQUNUO0FBQ0EsdUNBQXVDLDBDQUFjO0FBQ3JELFNBQVM7QUFDVDtBQUNBLHVDQUF1QywwQ0FBYztBQUNyRCxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUMsMENBQWM7QUFDckQsU0FBUztBQUNUO0FBQ0EsdUNBQXVDLDBDQUFjO0FBQ3JELFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUNBQXVDLDBDQUFjO0FBQ3JELFNBQVM7QUFDVDtBQUNBLHVDQUF1QywwQ0FBYztBQUNyRCxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUMsMENBQWM7QUFDckQsU0FBUztBQUNUO0FBQ0EsdUNBQXVDLDBDQUFjO0FBQ3JELFNBQVM7QUFDVDtBQUNBLHVDQUF1QywwQ0FBYztBQUNyRCxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUMsMENBQWM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVDQUF1QywwQ0FBYztBQUNyRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUNBQXVDLDBDQUFjO0FBQ3JELFNBQVM7QUFDVDtBQUNBLHVDQUF1QywwQ0FBYztBQUNyRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsMENBQWM7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQyxpQ0FBaUM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFvRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFxRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2tMO0FBQ2xMIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvbjhhby9kaXN0L044QU8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb2xvciBhcyAkNVdoZTMkQ29sb3IsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzICQ1V2hlMyRXZWJHTFJlbmRlclRhcmdldCwgTGluZWFyRmlsdGVyIGFzICQ1V2hlMyRMaW5lYXJGaWx0ZXIsIE5lYXJlc3RGaWx0ZXIgYXMgJDVXaGUzJE5lYXJlc3RGaWx0ZXIsIEhhbGZGbG9hdFR5cGUgYXMgJDVXaGUzJEhhbGZGbG9hdFR5cGUsIFJHQkFGb3JtYXQgYXMgJDVXaGUzJFJHQkFGb3JtYXQsIERlcHRoVGV4dHVyZSBhcyAkNVdoZTMkRGVwdGhUZXh0dXJlLCBVbnNpZ25lZEludDI0OFR5cGUgYXMgJDVXaGUzJFVuc2lnbmVkSW50MjQ4VHlwZSwgVW5zaWduZWRJbnRUeXBlIGFzICQ1V2hlMyRVbnNpZ25lZEludFR5cGUsIERlcHRoU3RlbmNpbEZvcm1hdCBhcyAkNVdoZTMkRGVwdGhTdGVuY2lsRm9ybWF0LCBEZXB0aEZvcm1hdCBhcyAkNVdoZTMkRGVwdGhGb3JtYXQsIE1hdHJpeDQgYXMgJDVXaGUzJE1hdHJpeDQsIERhdGFUZXh0dXJlIGFzICQ1V2hlMyREYXRhVGV4dHVyZSwgU2hhZGVyTWF0ZXJpYWwgYXMgJDVXaGUzJFNoYWRlck1hdGVyaWFsLCBOb0NvbG9yU3BhY2UgYXMgJDVXaGUzJE5vQ29sb3JTcGFjZSwgUmVwZWF0V3JhcHBpbmcgYXMgJDVXaGUzJFJlcGVhdFdyYXBwaW5nLCBWZWN0b3IyIGFzICQ1V2hlMyRWZWN0b3IyLCBSRVZJU0lPTiBhcyAkNVdoZTMkUkVWSVNJT04sIFJlZEZvcm1hdCBhcyAkNVdoZTMkUmVkRm9ybWF0LCBGbG9hdFR5cGUgYXMgJDVXaGUzJEZsb2F0VHlwZSwgVmVjdG9yMyBhcyAkNVdoZTMkVmVjdG9yMywgU3BoZXJlIGFzICQ1V2hlMyRTcGhlcmUsIEJ1ZmZlckF0dHJpYnV0ZSBhcyAkNVdoZTMkQnVmZmVyQXR0cmlidXRlLCBCdWZmZXJHZW9tZXRyeSBhcyAkNVdoZTMkQnVmZmVyR2VvbWV0cnksIE9ydGhvZ3JhcGhpY0NhbWVyYSBhcyAkNVdoZTMkT3J0aG9ncmFwaGljQ2FtZXJhLCBNZXNoIGFzICQ1V2hlMyRNZXNofSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7UGFzcyBhcyAkNVdoZTMkUGFzc30gZnJvbSBcInRocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9QYXNzLmpzXCI7XG5pbXBvcnQge1Bhc3MgYXMgJDVXaGUzJFBhc3MxfSBmcm9tIFwicG9zdHByb2Nlc3NpbmdcIjtcblxuXG5cblxuY2xhc3MgJGU0Y2E4ZGNiMDIxOGY4NDYkdmFyJEZ1bGxTY3JlZW5UcmlhbmdsZUdlb21ldHJ5IGV4dGVuZHMgJDVXaGUzJEJ1ZmZlckdlb21ldHJ5IHtcbiAgICBib3VuZGluZ1NwaGVyZSA9IG5ldyAkNVdoZTMkU3BoZXJlKCk7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgJDVXaGUzJEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgICAgIC0xLFxuICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAzLFxuICAgICAgICAgICAgLTEsXG4gICAgICAgICAgICAtMSxcbiAgICAgICAgICAgIDNcbiAgICAgICAgXSksIDIpKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ1dlwiLCBuZXcgJDVXaGUzJEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMlxuICAgICAgICBdKSwgMikpO1xuICAgIH1cbiAgICBjb21wdXRlQm91bmRpbmdTcGhlcmUoKSB7fVxufVxuY29uc3QgJGU0Y2E4ZGNiMDIxOGY4NDYkdmFyJF9nZW9tZXRyeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgJGU0Y2E4ZGNiMDIxOGY4NDYkdmFyJEZ1bGxTY3JlZW5UcmlhbmdsZUdlb21ldHJ5KCk7XG5jb25zdCAkZTRjYThkY2IwMjE4Zjg0NiR2YXIkX2NhbWVyYSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgJDVXaGUzJE9ydGhvZ3JhcGhpY0NhbWVyYSgpO1xuY2xhc3MgJGU0Y2E4ZGNiMDIxOGY4NDYkZXhwb3J0JGRjZDY3MGQ3M2RiNzUxZjUge1xuICAgIGNvbnN0cnVjdG9yKG1hdGVyaWFsKXtcbiAgICAgICAgdGhpcy5fbWVzaCA9IG5ldyAkNVdoZTMkTWVzaCgkZTRjYThkY2IwMjE4Zjg0NiR2YXIkX2dlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuX21lc2guZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuX21lc2gsICRlNGNhOGRjYjAyMThmODQ2JHZhciRfY2FtZXJhKTtcbiAgICB9XG4gICAgZ2V0IG1hdGVyaWFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVzaC5tYXRlcmlhbDtcbiAgICB9XG4gICAgc2V0IG1hdGVyaWFsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX21lc2gubWF0ZXJpYWwgPSB2YWx1ZTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5fbWVzaC5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cbn1cblxuXG5cbmNvbnN0ICQxZWQ0NTk2OGMxMTYwYzNjJGV4cG9ydCRjOWIyNjNiOWExN2RmZmQ3ID0ge1xuICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIFwic2NlbmVEaWZmdXNlXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwic2NlbmVEZXB0aFwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcInNjZW5lTm9ybWFsXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwicHJvak1hdFwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyAkNVdoZTMkTWF0cml4NCgpXG4gICAgICAgIH0sXG4gICAgICAgIFwidmlld01hdFwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyAkNVdoZTMkTWF0cml4NCgpXG4gICAgICAgIH0sXG4gICAgICAgIFwicHJvalZpZXdNYXRcIjoge1xuICAgICAgICAgICAgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgJDVXaGUzJE1hdHJpeDQoKVxuICAgICAgICB9LFxuICAgICAgICBcInByb2plY3Rpb25NYXRyaXhJbnZcIjoge1xuICAgICAgICAgICAgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgJDVXaGUzJE1hdHJpeDQoKVxuICAgICAgICB9LFxuICAgICAgICBcInZpZXdNYXRyaXhJbnZcIjoge1xuICAgICAgICAgICAgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgJDVXaGUzJE1hdHJpeDQoKVxuICAgICAgICB9LFxuICAgICAgICBcImNhbWVyYVBvc1wiOiB7XG4gICAgICAgICAgICB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyAkNVdoZTMkVmVjdG9yMygpXG4gICAgICAgIH0sXG4gICAgICAgIFwicmVzb2x1dGlvblwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyAkNVdoZTMkVmVjdG9yMigpXG4gICAgICAgIH0sXG4gICAgICAgIFwiYmlhc0FkanVzdG1lbnRcIjoge1xuICAgICAgICAgICAgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgJDVXaGUzJFZlY3RvcjIoKVxuICAgICAgICB9LFxuICAgICAgICBcInRpbWVcIjoge1xuICAgICAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgICB9LFxuICAgICAgICBcInNhbXBsZXNcIjoge1xuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwiYmx1ZW5vaXNlXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlzdGFuY2VGYWxsb2ZmXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgXCJyYWRpdXNcIjoge1xuICAgICAgICAgICAgdmFsdWU6IDUuMFxuICAgICAgICB9LFxuICAgICAgICBcIm5lYXJcIjoge1xuICAgICAgICAgICAgdmFsdWU6IDAuMVxuICAgICAgICB9LFxuICAgICAgICBcImZhclwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogMTAwMC4wXG4gICAgICAgIH0sXG4gICAgICAgIFwib3J0aG9cIjoge1xuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwic2NyZWVuU3BhY2VSYWRpdXNcIjoge1xuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiZnJhbWVcIjoge1xuICAgICAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgIHZlcnRleFNoYWRlcjogLyogZ2xzbCAqLyBgXG52YXJ5aW5nIHZlYzIgdlV2O1xudm9pZCBtYWluKCkge1xuICB2VXYgPSB1djtcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAxKTtcbn1gLFxuICAgIGZyYWdtZW50U2hhZGVyOiAvKiBnbHNsICovIGBcbiAgICAjZGVmaW5lIFNBTVBMRVMgMTZcbiAgICAjZGVmaW5lIEZTQU1QTEVTIDE2LjBcbnVuaWZvcm0gc2FtcGxlcjJEIHNjZW5lRGlmZnVzZTtcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIHNjZW5lTm9ybWFsO1xudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgc2NlbmVEZXB0aDtcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4SW52O1xudW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXhJbnY7XG51bmlmb3JtIG1hdDQgcHJvak1hdDtcbnVuaWZvcm0gbWF0NCB2aWV3TWF0O1xudW5pZm9ybSBtYXQ0IHByb2pWaWV3TWF0O1xudW5pZm9ybSB2ZWMzIGNhbWVyYVBvcztcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xudW5pZm9ybSB2ZWMyIGJpYXNBZGp1c3RtZW50O1xudW5pZm9ybSBmbG9hdCB0aW1lO1xudW5pZm9ybSB2ZWMzW1NBTVBMRVNdIHNhbXBsZXM7XG51bmlmb3JtIGZsb2F0IHJhZGl1cztcbnVuaWZvcm0gZmxvYXQgZGlzdGFuY2VGYWxsb2ZmO1xudW5pZm9ybSBmbG9hdCBuZWFyO1xudW5pZm9ybSBmbG9hdCBmYXI7XG51bmlmb3JtIGZsb2F0IGZyYW1lO1xudW5pZm9ybSBib29sIG9ydGhvO1xudW5pZm9ybSBib29sIHNjcmVlblNwYWNlUmFkaXVzO1xudW5pZm9ybSBzYW1wbGVyMkQgYmx1ZW5vaXNlO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgaGlnaHAgZmxvYXQgbGluZWFyaXplX2RlcHRoKGhpZ2hwIGZsb2F0IGQsIGhpZ2hwIGZsb2F0IHpOZWFyLGhpZ2hwIGZsb2F0IHpGYXIpXG4gICAge1xuICAgICAgICByZXR1cm4gKHpGYXIgKiB6TmVhcikgLyAoekZhciAtIGQgKiAoekZhciAtIHpOZWFyKSk7XG4gICAgfVxuICAgIGhpZ2hwIGZsb2F0IGxpbmVhcml6ZV9kZXB0aF9vcnRobyhoaWdocCBmbG9hdCBkLCBoaWdocCBmbG9hdCBuZWFyWiwgaGlnaHAgZmxvYXQgZmFyWikge1xuICAgICAgcmV0dXJuIG5lYXJaICsgKGZhclogLSBuZWFyWikgKiBkO1xuICAgIH1cbiAgICBoaWdocCBmbG9hdCBsaW5lYXJpemVfZGVwdGhfbG9nKGhpZ2hwIGZsb2F0IGQsIGhpZ2hwIGZsb2F0IG5lYXJaLGhpZ2hwIGZsb2F0IGZhclopIHtcbiAgICAgIGZsb2F0IGRlcHRoID0gcG93KDIuMCwgZCAqIGxvZzIoZmFyWiArIDEuMCkpIC0gMS4wO1xuICAgICAgZmxvYXQgYSA9IGZhclogLyAoZmFyWiAtIG5lYXJaKTtcbiAgICAgIGZsb2F0IGIgPSBmYXJaICogbmVhclogLyAobmVhclogLSBmYXJaKTtcbiAgICAgIGZsb2F0IGxpbkRlcHRoID0gYSArIGIgLyBkZXB0aDtcbiAgICAgIC8qcmV0dXJuIG9ydGhvID8gbGluZWFyaXplX2RlcHRoX29ydGhvKFxuICAgICAgICBsaW5EZXB0aCxcbiAgICAgICAgbmVhclosXG4gICAgICAgIGZhclpcbiAgICAgICkgOmxpbmVhcml6ZV9kZXB0aChsaW5EZXB0aCwgbmVhclosIGZhclopOyovXG4gICAgICAgI2lmZGVmIE9SVEhPXG5cbiAgICAgICByZXR1cm4gbGluZWFyaXplX2RlcHRoX29ydGhvKGQsIG5lYXJaLCBmYXJaKTtcblxuICAgICAgICAjZWxzZVxuICAgICAgICByZXR1cm4gbGluZWFyaXplX2RlcHRoKGxpbkRlcHRoLCBuZWFyWiwgZmFyWik7XG4gICAgICAgICNlbmRpZlxuICAgIH1cblxuICAgIHZlYzMgZ2V0V29ybGRQb3NMb2codmVjMyBwb3NTKSB7XG4gICAgICB2ZWMyIHV2ID0gcG9zUy54eTtcbiAgICAgIGZsb2F0IHogPSBwb3NTLno7XG4gICAgICBmbG9hdCBuZWFyWiA9bmVhcjtcbiAgICAgIGZsb2F0IGZhclogPSBmYXI7XG4gICAgICBmbG9hdCBkZXB0aCA9IHBvdygyLjAsIHogKiBsb2cyKGZhclogKyAxLjApKSAtIDEuMDtcbiAgICAgIGZsb2F0IGEgPSBmYXJaIC8gKGZhclogLSBuZWFyWik7XG4gICAgICBmbG9hdCBiID0gZmFyWiAqIG5lYXJaIC8gKG5lYXJaIC0gZmFyWik7XG4gICAgICBmbG9hdCBsaW5EZXB0aCA9IGEgKyBiIC8gZGVwdGg7XG4gICAgICB2ZWM0IGNsaXBWZWMgPSB2ZWM0KHV2LCBsaW5EZXB0aCwgMS4wKSAqIDIuMCAtIDEuMDtcbiAgICAgIHZlYzQgd3BvcyA9IHByb2plY3Rpb25NYXRyaXhJbnYgKiBjbGlwVmVjO1xuICAgICAgcmV0dXJuIHdwb3MueHl6IC8gd3Bvcy53O1xuICAgIH1cbiAgICB2ZWMzIGdldFdvcmxkUG9zKGZsb2F0IGRlcHRoLCB2ZWMyIGNvb3JkKSB7XG4gICAgICAjaWZkZWYgTE9HREVQVEhcbiAgICAgICAgI2lmbmRlZiBPUlRIT1xuICAgICAgICAgIHJldHVybiBnZXRXb3JsZFBvc0xvZyh2ZWMzKGNvb3JkLCBkZXB0aCkpO1xuICAgICAgICAjZW5kaWZcbiAgICAgICNlbmRpZlxuICAgICAgZmxvYXQgeiA9IGRlcHRoICogMi4wIC0gMS4wO1xuICAgICAgdmVjNCBjbGlwU3BhY2VQb3NpdGlvbiA9IHZlYzQoY29vcmQgKiAyLjAgLSAxLjAsIHosIDEuMCk7XG4gICAgICB2ZWM0IHZpZXdTcGFjZVBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeEludiAqIGNsaXBTcGFjZVBvc2l0aW9uO1xuICAgICAgLy8gUGVyc3BlY3RpdmUgZGl2aXNpb25cbiAgICAgdmVjNCB3b3JsZFNwYWNlUG9zaXRpb24gPSB2aWV3U3BhY2VQb3NpdGlvbjtcbiAgICAgd29ybGRTcGFjZVBvc2l0aW9uLnh5eiAvPSB3b3JsZFNwYWNlUG9zaXRpb24udztcbiAgICAgIHJldHVybiB3b3JsZFNwYWNlUG9zaXRpb24ueHl6O1xuICB9XG5cbiAgdmVjMyBjb21wdXRlTm9ybWFsKHZlYzMgd29ybGRQb3MsIHZlYzIgdlV2KSB7XG4gICAgaXZlYzIgcCA9IGl2ZWMyKHZVdiAqIHJlc29sdXRpb24pO1xuICAgICNpZmRlZiBSRVZFUlNFREVQVEhcbiAgICBmbG9hdCBjMCA9IDEuMCAtIHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCwgMCkueDtcbiAgICBmbG9hdCBsMiA9IDEuMCAtIHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCAtIGl2ZWMyKDIsIDApLCAwKS54O1xuICAgIGZsb2F0IGwxID0gMS4wIC0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwIC0gaXZlYzIoMSwgMCksIDApLng7XG4gICAgZmxvYXQgcjEgPSAxLjAgLSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgKyBpdmVjMigxLCAwKSwgMCkueDtcbiAgICBmbG9hdCByMiA9IDEuMCAtIHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCArIGl2ZWMyKDIsIDApLCAwKS54O1xuICAgIGZsb2F0IGIyID0gMS4wIC0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwIC0gaXZlYzIoMCwgMiksIDApLng7XG4gICAgZmxvYXQgYjEgPSAxLjAgLSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgLSBpdmVjMigwLCAxKSwgMCkueDtcbiAgICBmbG9hdCB0MSA9IDEuMCAtIHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCArIGl2ZWMyKDAsIDEpLCAwKS54O1xuICAgIGZsb2F0IHQyID0gMS4wIC0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwICsgaXZlYzIoMCwgMiksIDApLng7XG4gICAgI2Vsc2VcbiAgICBmbG9hdCBjMCA9IHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCwgMCkueDtcbiAgICBmbG9hdCBsMiA9IHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCAtIGl2ZWMyKDIsIDApLCAwKS54O1xuICAgIGZsb2F0IGwxID0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwIC0gaXZlYzIoMSwgMCksIDApLng7XG4gICAgZmxvYXQgcjEgPSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgKyBpdmVjMigxLCAwKSwgMCkueDtcbiAgICBmbG9hdCByMiA9IHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCArIGl2ZWMyKDIsIDApLCAwKS54O1xuICAgIGZsb2F0IGIyID0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwIC0gaXZlYzIoMCwgMiksIDApLng7XG4gICAgZmxvYXQgYjEgPSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgLSBpdmVjMigwLCAxKSwgMCkueDtcbiAgICBmbG9hdCB0MSA9IHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCArIGl2ZWMyKDAsIDEpLCAwKS54O1xuICAgIGZsb2F0IHQyID0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwICsgaXZlYzIoMCwgMiksIDApLng7XG4gICAgI2VuZGlmXG5cbiAgICBmbG9hdCBkbCA9IGFicygoMi4wICogbDEgLSBsMikgLSBjMCk7XG4gICAgZmxvYXQgZHIgPSBhYnMoKDIuMCAqIHIxIC0gcjIpIC0gYzApO1xuICAgIGZsb2F0IGRiID0gYWJzKCgyLjAgKiBiMSAtIGIyKSAtIGMwKTtcbiAgICBmbG9hdCBkdCA9IGFicygoMi4wICogdDEgLSB0MikgLSBjMCk7XG5cbiAgICB2ZWMzIGNlID0gZ2V0V29ybGRQb3MoYzAsIHZVdikueHl6O1xuXG4gICAgdmVjMyBkcGR4ID0gKGRsIDwgZHIpID8gY2UgLSBnZXRXb3JsZFBvcyhsMSwgKHZVdiAtIHZlYzIoMS4wIC8gcmVzb2x1dGlvbi54LCAwLjApKSkueHl6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogLWNlICsgZ2V0V29ybGRQb3MocjEsICh2VXYgKyB2ZWMyKDEuMCAvIHJlc29sdXRpb24ueCwgMC4wKSkpLnh5ejtcbiAgICB2ZWMzIGRwZHkgPSAoZGIgPCBkdCkgPyBjZSAtIGdldFdvcmxkUG9zKGIxLCAodlV2IC0gdmVjMigwLjAsIDEuMCAvIHJlc29sdXRpb24ueSkpKS54eXpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAtY2UgKyBnZXRXb3JsZFBvcyh0MSwgKHZVdiArIHZlYzIoMC4wLCAxLjAgLyByZXNvbHV0aW9uLnkpKSkueHl6O1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZShjcm9zcyhkcGR4LCBkcGR5KSk7XG59XG5cbm1hdDMgbWFrZVJvdGF0aW9uWihmbG9hdCB0aGV0YSkge1xuXHRmbG9hdCBjID0gY29zKHRoZXRhKTtcblx0ZmxvYXQgcyA9IHNpbih0aGV0YSk7XG5cdHJldHVybiBtYXQzKGMsIC0gcywgMCxcblx0XHRcdHMsICBjLCAwLFxuXHRcdFx0MCwgIDAsIDEpO1xuICB9XG5cbnZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzQgZGlmZnVzZSA9IHRleHR1cmUyRChzY2VuZURpZmZ1c2UsIHZVdik7XG4gICAgICAjaWZkZWYgUkVWRVJTRURFUFRIXG4gICAgICBmbG9hdCBkZXB0aCA9IDEuMCAtIHRleHR1cmUyRChzY2VuZURlcHRoLCB2VXYpLng7XG4gICAgICAjZWxzZVxuICAgICAgZmxvYXQgZGVwdGggPSB0ZXh0dXJlMkQoc2NlbmVEZXB0aCwgdlV2KS54O1xuICAgICAgI2VuZGlmXG4gICAgICBpZiAoZGVwdGggPT0gMS4wKSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVjMygxLjApLCAxLjApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2ZWMzIHdvcmxkUG9zID0gZ2V0V29ybGRQb3MoZGVwdGgsIHZVdik7XG4gICAgICAjaWZkZWYgSEFMRlJFU1xuICAgICAgICB2ZWMzIG5vcm1hbCA9IHRleHR1cmUyRChzY2VuZU5vcm1hbCwgdlV2KS5yZ2I7XG4gICAgICAjZWxzZVxuICAgICAgICB2ZWMzIG5vcm1hbCA9IGNvbXB1dGVOb3JtYWwod29ybGRQb3MsIHZVdik7XG4gICAgICAjZW5kaWZcbiAgICAgIHZlYzQgbm9pc2UgPSB0ZXh0dXJlMkQoYmx1ZW5vaXNlLCBnbF9GcmFnQ29vcmQueHkgLyAxMjguMCk7XG4gICAgICB2ZWMyIGhhcm1vbmlvdXNOdW1iZXJzID0gdmVjMihcbiAgICAgICAgMS42MTgwMzM5ODg3NDk4OTUsXG4gICAgICAgIDEuMzI0NzE3OTU3MjQ0NzQ2XG4gICAgICApO1xuICAgICAgbm9pc2UucmcgKz0gaGFybW9uaW91c051bWJlcnMgKiBmcmFtZTtcbiAgICAgIG5vaXNlLnJnID0gZnJhY3Qobm9pc2UucmcpO1xuICAgICAgICB2ZWMzIGhlbHBlclZlYyA9IHZlYzMoMC4wLCAxLjAsIDAuMCk7XG4gICAgICAgIGlmIChkb3QoaGVscGVyVmVjLCBub3JtYWwpID4gMC45OSkge1xuICAgICAgICAgIGhlbHBlclZlYyA9IHZlYzMoMS4wLCAwLjAsIDAuMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmVjMyB0YW5nZW50ID0gbm9ybWFsaXplKGNyb3NzKGhlbHBlclZlYywgbm9ybWFsKSk7XG4gICAgICAgIHZlYzMgYml0YW5nZW50ID0gY3Jvc3Mobm9ybWFsLCB0YW5nZW50KTtcbiAgICAgICAgbWVkaXVtcCBtYXQzIHRibiA9IG1hdDModGFuZ2VudCwgYml0YW5nZW50LCBub3JtYWwpICogIG1ha2VSb3RhdGlvblooIG5vaXNlLnIgKiAzLjE0MTU5NjIgKiAyLjApIDtcblxuICAgICAgbWVkaXVtcCBmbG9hdCBvY2NsdWRlZCA9IDAuMDtcbiAgICAgIG1lZGl1bXAgZmxvYXQgdG90YWxXZWlnaHQgPSAwLjA7XG4gICAgICBmbG9hdCByYWRpdXNUb1VzZSA9IHNjcmVlblNwYWNlUmFkaXVzID8gZGlzdGFuY2UoXG4gICAgICAgIHdvcmxkUG9zLFxuICAgICAgICBnZXRXb3JsZFBvcyhkZXB0aCwgdlV2ICtcbiAgICAgICAgICB2ZWMyKHJhZGl1cywgMC4wKSAvIHJlc29sdXRpb24pXG4gICAgICApIDogcmFkaXVzO1xuICAgICAgZmxvYXQgZGlzdGFuY2VGYWxsb2ZmVG9Vc2UgPXNjcmVlblNwYWNlUmFkaXVzID9cbiAgICAgICAgICByYWRpdXNUb1VzZSAqIGRpc3RhbmNlRmFsbG9mZlxuICAgICAgOiByYWRpdXNUb1VzZSAqIGRpc3RhbmNlRmFsbG9mZiAqIDAuMjtcbiAgICAgIGZsb2F0IGJpYXMgPSAobWluKFxuICAgICAgICAwLjEsXG4gICAgICAgIGRpc3RhbmNlRmFsbG9mZlRvVXNlICogMC4xXG4gICAgICApIC8gbmVhcikgKiBmd2lkdGgoZGlzdGFuY2Uod29ybGRQb3MsIGNhbWVyYVBvcykpIC8gcmFkaXVzVG9Vc2U7XG4gICAgICBiaWFzID0gYmlhc0FkanVzdG1lbnQueCArIGJpYXNBZGp1c3RtZW50LnkgKiBiaWFzO1xuICAgICAgbWVkaXVtcCBmbG9hdCBvZmZzZXRNb3ZlID0gbm9pc2UuZztcbiAgICAgIG1lZGl1bXAgZmxvYXQgb2Zmc2V0TW92ZUludiA9IDEuMCAvIEZTQU1QTEVTO1xuICAgICAgZmxvYXQgZmFyVGltZXNOZWFyID0gZmFyICogbmVhcjtcbiAgICAgIGZsb2F0IGZhck1pbnVzTmVhciA9IGZhciAtIG5lYXI7XG4gICAgICBcbiAgICAgIGZvcihpbnQgaSA9IDA7IGkgPCBTQU1QTEVTOyBpKyspIHtcbiAgICAgICAgbWVkaXVtcCB2ZWMzIHNhbXBsZURpcmVjdGlvbiA9IHRibiAqIHNhbXBsZXNbaV07XG5cbiAgICAgICAgZmxvYXQgbW92ZUFtdCA9IGZyYWN0KG9mZnNldE1vdmUpO1xuICAgICAgICBvZmZzZXRNb3ZlICs9IG9mZnNldE1vdmVJbnY7XG4gICAgICAgIHZlYzMgc2FtcGxlUG9zID0gd29ybGRQb3MgKyByYWRpdXNUb1VzZSAqIG1vdmVBbXQgKiBzYW1wbGVEaXJlY3Rpb247XG4gICAgICAgIHZlYzQgb2Zmc2V0ID0gcHJvak1hdCAqIHZlYzQoc2FtcGxlUG9zLCAxLjApO1xuICAgICAgICBvZmZzZXQueHl6IC89IG9mZnNldC53O1xuICAgICAgICBvZmZzZXQueHl6ID0gb2Zmc2V0Lnh5eiAqIDAuNSArIDAuNTtcbiAgICAgICAgXG4gICAgICAgIGlmIChhbGwoZ3JlYXRlclRoYW4ob2Zmc2V0Lnh5eiAqICgxLjAgLSBvZmZzZXQueHl6KSwgdmVjMygwLjApKSkpIHtcbiAgICAgICAgICAjaWZkZWYgUkVWRVJTRURFUFRIXG4gICAgICAgICAgZmxvYXQgc2FtcGxlRGVwdGggPSAxLjAgLSB0ZXh0dXJlTG9kKHNjZW5lRGVwdGgsIG9mZnNldC54eSwgMC4wKS54O1xuICAgICAgICAgICNlbHNlXG4gICAgICAgICAgZmxvYXQgc2FtcGxlRGVwdGggPSB0ZXh0dXJlTG9kKHNjZW5lRGVwdGgsIG9mZnNldC54eSwgMC4wKS54O1xuICAgICAgICAgICNlbmRpZlxuXG4gICAgICAgICAgLyojaWZkZWYgTE9HREVQVEhcbiAgICAgICAgICBmbG9hdCBkaXN0U2FtcGxlID0gbGluZWFyaXplX2RlcHRoX2xvZyhzYW1wbGVEZXB0aCwgbmVhciwgZmFyKTtcbiAgICAgICNlbHNlXG4gICAgICAgICAgI2lmZGVmIE9SVEhPXG4gICAgICAgICAgICAgIGZsb2F0IGRpc3RTYW1wbGUgPSBuZWFyICsgZmFyTWludXNOZWFyICogc2FtcGxlRGVwdGg7XG4gICAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgICAgZmxvYXQgZGlzdFNhbXBsZSA9IChmYXJUaW1lc05lYXIpIC8gKGZhciAtIHNhbXBsZURlcHRoICogZmFyTWludXNOZWFyKTtcbiAgICAgICAgICAjZW5kaWZcbiAgICAgICNlbmRpZiovXG4gICAgICAjaWZkZWYgT1JUSE9cbiAgICAgICAgICBmbG9hdCBkaXN0U2FtcGxlID0gbmVhciArIHNhbXBsZURlcHRoICogZmFyTWludXNOZWFyO1xuICAgICAgI2Vsc2VcbiAgICAgICAgICAjaWZkZWYgTE9HREVQVEhcbiAgICAgICAgICAgICAgZmxvYXQgZGlzdFNhbXBsZSA9IGxpbmVhcml6ZV9kZXB0aF9sb2coc2FtcGxlRGVwdGgsIG5lYXIsIGZhcik7XG4gICAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgICAgZmxvYXQgZGlzdFNhbXBsZSA9IChmYXJUaW1lc05lYXIpIC8gKGZhciAtIHNhbXBsZURlcHRoICogZmFyTWludXNOZWFyKTtcbiAgICAgICAgICAjZW5kaWZcbiAgICAgICNlbmRpZlxuICAgICAgXG4gICAgICAjaWZkZWYgT1JUSE9cbiAgICAgICAgICBmbG9hdCBkaXN0V29ybGQgPSBuZWFyICsgb2Zmc2V0LnogKiBmYXJNaW51c05lYXI7XG4gICAgICAjZWxzZVxuICAgICAgICAgIGZsb2F0IGRpc3RXb3JsZCA9IChmYXJUaW1lc05lYXIpIC8gKGZhciAtIG9mZnNldC56ICogZmFyTWludXNOZWFyKTtcbiAgICAgICNlbmRpZlxuICAgICAgICAgIFxuICAgICAgICAgIG1lZGl1bXAgZmxvYXQgcmFuZ2VDaGVjayA9IHNtb290aHN0ZXAoMC4wLCAxLjAsIGRpc3RhbmNlRmFsbG9mZlRvVXNlIC8gKGFicyhkaXN0U2FtcGxlIC0gZGlzdFdvcmxkKSkpO1xuICAgICAgICAgIHZlYzIgZGlmZiA9IGdsX0ZyYWdDb29yZC54eSAtIGZsb29yKG9mZnNldC54eSAqIHJlc29sdXRpb24pO1xuICAgICAgICAgIG9jY2x1ZGVkICs9IHJhbmdlQ2hlY2sgKiBmbG9hdChkaXN0U2FtcGxlICE9IGRpc3RXb3JsZCkgKiBmbG9hdChzYW1wbGVEZXB0aCAhPSBkZXB0aCkgKiBzdGVwKGRpc3RTYW1wbGUgKyBiaWFzLCBkaXN0V29ybGQpICogc3RlcChcbiAgICAgICAgICAgIDEuMCxcbiAgICAgICAgICAgIGRvdChkaWZmLCBkaWZmKVxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgdG90YWxXZWlnaHQgKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsb2F0IG9jYyA9IGNsYW1wKDEuMCAtIG9jY2x1ZGVkIC8gKHRvdGFsV2VpZ2h0ID09IDAuMCA/IDEuMCA6IHRvdGFsV2VpZ2h0KSwgMC4wLCAxLjApO1xuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChvY2MsIDAuNSArIDAuNSAqIG5vcm1hbCk7XG59YFxufTtcblxuXG5cbmNvbnN0ICQxMmIyMWQyNGQxMTkyYTA0JGV4cG9ydCRhODE1YWNjY2JkMmM5YTQ5ID0ge1xuICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIFwic2NlbmVEaWZmdXNlXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwic2NlbmVEZXB0aFwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcInREaWZmdXNlXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHJhbnNwYXJlbmN5RFdGYWxzZVwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcInRyYW5zcGFyZW5jeURXVHJ1ZVwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcInRyYW5zcGFyZW5jeURXVHJ1ZURlcHRoXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHJhbnNwYXJlbmN5QXdhcmVcIjoge1xuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwicHJvak1hdFwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyAkNVdoZTMkTWF0cml4NCgpXG4gICAgICAgIH0sXG4gICAgICAgIFwidmlld01hdFwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyAkNVdoZTMkTWF0cml4NCgpXG4gICAgICAgIH0sXG4gICAgICAgIFwicHJvamVjdGlvbk1hdHJpeEludlwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyAkNVdoZTMkTWF0cml4NCgpXG4gICAgICAgIH0sXG4gICAgICAgIFwidmlld01hdHJpeEludlwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyAkNVdoZTMkTWF0cml4NCgpXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2FtZXJhUG9zXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3ICQ1V2hlMyRWZWN0b3IzKClcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZXNvbHV0aW9uXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3ICQ1V2hlMyRWZWN0b3IyKClcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xvclwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogLyogQF9fUFVSRV9fICovIG5ldyAkNVdoZTMkVmVjdG9yMygwLCAwLCAwKVxuICAgICAgICB9LFxuICAgICAgICBcImJsdWVOb2lzZVwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcImRvd25zYW1wbGVkRGVwdGhcIjoge1xuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0aW1lXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwLjBcbiAgICAgICAgfSxcbiAgICAgICAgXCJpbnRlbnNpdHlcIjoge1xuICAgICAgICAgICAgdmFsdWU6IDEwLjBcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZW5kZXJNb2RlXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwLjBcbiAgICAgICAgfSxcbiAgICAgICAgXCJnYW1tYUNvcnJlY3Rpb25cIjoge1xuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwib3J0aG9cIjoge1xuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwibmVhclwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogMC4xXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmFyXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAxMDAwLjBcbiAgICAgICAgfSxcbiAgICAgICAgXCJzY3JlZW5TcGFjZVJhZGl1c1wiOiB7XG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJyYWRpdXNcIjoge1xuICAgICAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgICB9LFxuICAgICAgICBcImRpc3RhbmNlRmFsbG9mZlwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogMS4wXG4gICAgICAgIH0sXG4gICAgICAgIFwiZm9nXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImZvZ0V4cFwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJmb2dEZW5zaXR5XCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwLjBcbiAgICAgICAgfSxcbiAgICAgICAgXCJmb2dOZWFyXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBJbmZpbml0eVxuICAgICAgICB9LFxuICAgICAgICBcImZvZ0ZhclwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogSW5maW5pdHlcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xvck11bHRpcGx5XCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwiYW9Ub25lc1wiOiB7XG4gICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgdmVydGV4U2hhZGVyOiAvKiBnbHNsICovIGBcblx0XHR2YXJ5aW5nIHZlYzIgdlV2O1xuXHRcdHZvaWQgbWFpbigpIHtcblx0XHRcdHZVdiA9IHV2O1xuXHRcdFx0Z2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAxKTtcblx0XHR9YCxcbiAgICBmcmFnbWVudFNoYWRlcjogLyogZ2xzbCAqLyBgXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgc2NlbmVEaWZmdXNlO1xuICAgIHVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIHNjZW5lRGVwdGg7XG4gICAgdW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZG93bnNhbXBsZWREZXB0aDtcbiAgICB1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCB0cmFuc3BhcmVuY3lEV0ZhbHNlO1xuICAgIHVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIHRyYW5zcGFyZW5jeURXVHJ1ZTtcbiAgICB1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCB0cmFuc3BhcmVuY3lEV1RydWVEZXB0aDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBibHVlTm9pc2U7XG4gICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4gICAgdW5pZm9ybSB2ZWMzIGNvbG9yO1xuICAgIHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4SW52O1xuICAgIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4SW52O1xuICAgIHVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5O1xuICAgIHVuaWZvcm0gZmxvYXQgcmVuZGVyTW9kZTtcbiAgICB1bmlmb3JtIGZsb2F0IG5lYXI7XG4gICAgdW5pZm9ybSBmbG9hdCBmYXI7XG4gICAgdW5pZm9ybSBmbG9hdCBhb1RvbmVzO1xuICAgIHVuaWZvcm0gYm9vbCBnYW1tYUNvcnJlY3Rpb247XG4gICAgdW5pZm9ybSBib29sIG9ydGhvO1xuICAgIHVuaWZvcm0gYm9vbCBzY3JlZW5TcGFjZVJhZGl1cztcbiAgICB1bmlmb3JtIGJvb2wgZm9nO1xuICAgIHVuaWZvcm0gYm9vbCBmb2dFeHA7XG4gICAgdW5pZm9ybSBib29sIGNvbG9yTXVsdGlwbHk7XG4gICAgdW5pZm9ybSBib29sIHRyYW5zcGFyZW5jeUF3YXJlO1xuICAgIHVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcbiAgICB1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XG4gICAgdW5pZm9ybSBmbG9hdCBmb2dGYXI7XG4gICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG4gICAgdW5pZm9ybSBmbG9hdCBkaXN0YW5jZUZhbGxvZmY7XG4gICAgdW5pZm9ybSB2ZWMzIGNhbWVyYVBvcztcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIGhpZ2hwIGZsb2F0IGxpbmVhcml6ZV9kZXB0aChoaWdocCBmbG9hdCBkLCBoaWdocCBmbG9hdCB6TmVhcixoaWdocCBmbG9hdCB6RmFyKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh6RmFyICogek5lYXIpIC8gKHpGYXIgLSBkICogKHpGYXIgLSB6TmVhcikpO1xuICAgIH1cbiAgICBoaWdocCBmbG9hdCBsaW5lYXJpemVfZGVwdGhfb3J0aG8oaGlnaHAgZmxvYXQgZCwgaGlnaHAgZmxvYXQgbmVhclosIGhpZ2hwIGZsb2F0IGZhclopIHtcbiAgICAgIHJldHVybiBuZWFyWiArIChmYXJaIC0gbmVhclopICogZDtcbiAgICB9XG4gICAgaGlnaHAgZmxvYXQgbGluZWFyaXplX2RlcHRoX2xvZyhoaWdocCBmbG9hdCBkLCBoaWdocCBmbG9hdCBuZWFyWixoaWdocCBmbG9hdCBmYXJaKSB7XG4gICAgICBmbG9hdCBkZXB0aCA9IHBvdygyLjAsIGQgKiBsb2cyKGZhclogKyAxLjApKSAtIDEuMDtcbiAgICAgIGZsb2F0IGEgPSBmYXJaIC8gKGZhclogLSBuZWFyWik7XG4gICAgICBmbG9hdCBiID0gZmFyWiAqIG5lYXJaIC8gKG5lYXJaIC0gZmFyWik7XG4gICAgICBmbG9hdCBsaW5EZXB0aCA9IGEgKyBiIC8gZGVwdGg7XG4gICAgICByZXR1cm4gb3J0aG8gPyBsaW5lYXJpemVfZGVwdGhfb3J0aG8oXG4gICAgICAgIGxpbkRlcHRoLFxuICAgICAgICBuZWFyWixcbiAgICAgICAgZmFyWlxuICAgICAgKSA6bGluZWFyaXplX2RlcHRoKGxpbkRlcHRoLCBuZWFyWiwgZmFyWik7XG4gICAgfVxuICAgIHZlYzMgZ2V0V29ybGRQb3NMb2codmVjMyBwb3NTKSB7XG4gICAgICAgIHZlYzIgdXYgPSBwb3NTLnh5O1xuICAgICAgICBmbG9hdCB6ID0gcG9zUy56O1xuICAgICAgICBmbG9hdCBuZWFyWiA9bmVhcjtcbiAgICAgICAgZmxvYXQgZmFyWiA9IGZhcjtcbiAgICAgICAgZmxvYXQgZGVwdGggPSBwb3coMi4wLCB6ICogbG9nMihmYXJaICsgMS4wKSkgLSAxLjA7XG4gICAgICAgIGZsb2F0IGEgPSBmYXJaIC8gKGZhclogLSBuZWFyWik7XG4gICAgICAgIGZsb2F0IGIgPSBmYXJaICogbmVhclogLyAobmVhclogLSBmYXJaKTtcbiAgICAgICAgZmxvYXQgbGluRGVwdGggPSBhICsgYiAvIGRlcHRoO1xuICAgICAgICB2ZWM0IGNsaXBWZWMgPSB2ZWM0KHV2LCBsaW5EZXB0aCwgMS4wKSAqIDIuMCAtIDEuMDtcbiAgICAgICAgdmVjNCB3cG9zID0gcHJvamVjdGlvbk1hdHJpeEludiAqIGNsaXBWZWM7XG4gICAgICAgIHJldHVybiB3cG9zLnh5eiAvIHdwb3MudztcbiAgICAgIH1cbiAgICAgIHZlYzMgZ2V0V29ybGRQb3MoZmxvYXQgZGVwdGgsIHZlYzIgY29vcmQpIHtcbiAgICAgICAgI2lmZGVmIExPR0RFUFRIXG4gICAgICAgICAgI2lmbmRlZiBPUlRIT1xuICAgICAgICAgICAgcmV0dXJuIGdldFdvcmxkUG9zTG9nKHZlYzMoY29vcmQsIGRlcHRoKSk7XG4gICAgICAgICAgI2VuZGlmXG4gICAgICAgICNlbmRpZlxuICAgICAgLy8gIH1cbiAgICAgICAgZmxvYXQgeiA9IGRlcHRoICogMi4wIC0gMS4wO1xuICAgICAgICB2ZWM0IGNsaXBTcGFjZVBvc2l0aW9uID0gdmVjNChjb29yZCAqIDIuMCAtIDEuMCwgeiwgMS4wKTtcbiAgICAgICAgdmVjNCB2aWV3U3BhY2VQb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXhJbnYgKiBjbGlwU3BhY2VQb3NpdGlvbjtcbiAgICAgICAgLy8gUGVyc3BlY3RpdmUgZGl2aXNpb25cbiAgICAgICB2ZWM0IHdvcmxkU3BhY2VQb3NpdGlvbiA9IHZpZXdTcGFjZVBvc2l0aW9uO1xuICAgICAgIHdvcmxkU3BhY2VQb3NpdGlvbi54eXogLz0gd29ybGRTcGFjZVBvc2l0aW9uLnc7XG4gICAgICAgIHJldHVybiB3b3JsZFNwYWNlUG9zaXRpb24ueHl6O1xuICAgIH1cbiAgXG4gICAgdmVjMyBjb21wdXRlTm9ybWFsKHZlYzMgd29ybGRQb3MsIHZlYzIgdlV2KSB7XG4gICAgICBpdmVjMiBwID0gaXZlYzIodlV2ICogcmVzb2x1dGlvbik7XG4gICAgICAjaWZkZWYgUkVWRVJTRURFUFRIXG4gICAgICBmbG9hdCBjMCA9IDEuMCAtIHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCwgMCkueDtcbiAgICAgIGZsb2F0IGwyID0gMS4wIC0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwIC0gaXZlYzIoMiwgMCksIDApLng7XG4gICAgICBmbG9hdCBsMSA9IDEuMCAtIHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCAtIGl2ZWMyKDEsIDApLCAwKS54O1xuICAgICAgZmxvYXQgcjEgPSAxLjAgLSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgKyBpdmVjMigxLCAwKSwgMCkueDtcbiAgICAgIGZsb2F0IHIyID0gMS4wIC0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwICsgaXZlYzIoMiwgMCksIDApLng7XG4gICAgICBmbG9hdCBiMiA9IDEuMCAtIHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCAtIGl2ZWMyKDAsIDIpLCAwKS54O1xuICAgICAgZmxvYXQgYjEgPSAxLjAgLSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgLSBpdmVjMigwLCAxKSwgMCkueDtcbiAgICAgIGZsb2F0IHQxID0gMS4wIC0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwICsgaXZlYzIoMCwgMSksIDApLng7XG4gICAgICBmbG9hdCB0MiA9IDEuMCAtIHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCArIGl2ZWMyKDAsIDIpLCAwKS54O1xuICAgICAgI2Vsc2VcbiAgICAgIGZsb2F0IGMwID0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwLCAwKS54O1xuICAgICAgZmxvYXQgbDIgPSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgLSBpdmVjMigyLCAwKSwgMCkueDtcbiAgICAgIGZsb2F0IGwxID0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwIC0gaXZlYzIoMSwgMCksIDApLng7XG4gICAgICBmbG9hdCByMSA9IHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCArIGl2ZWMyKDEsIDApLCAwKS54O1xuICAgICAgZmxvYXQgcjIgPSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgKyBpdmVjMigyLCAwKSwgMCkueDtcbiAgICAgIGZsb2F0IGIyID0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwIC0gaXZlYzIoMCwgMiksIDApLng7XG4gICAgICBmbG9hdCBiMSA9IHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCAtIGl2ZWMyKDAsIDEpLCAwKS54O1xuICAgICAgZmxvYXQgdDEgPSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgKyBpdmVjMigwLCAxKSwgMCkueDtcbiAgICAgIGZsb2F0IHQyID0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwICsgaXZlYzIoMCwgMiksIDApLng7XG4gICAgICAjZW5kaWZcbiAgXG4gICAgICBmbG9hdCBkbCA9IGFicygoMi4wICogbDEgLSBsMikgLSBjMCk7XG4gICAgICBmbG9hdCBkciA9IGFicygoMi4wICogcjEgLSByMikgLSBjMCk7XG4gICAgICBmbG9hdCBkYiA9IGFicygoMi4wICogYjEgLSBiMikgLSBjMCk7XG4gICAgICBmbG9hdCBkdCA9IGFicygoMi4wICogdDEgLSB0MikgLSBjMCk7XG4gIFxuICAgICAgdmVjMyBjZSA9IGdldFdvcmxkUG9zKGMwLCB2VXYpLnh5ejtcbiAgXG4gICAgICB2ZWMzIGRwZHggPSAoZGwgPCBkcikgPyBjZSAtIGdldFdvcmxkUG9zKGwxLCAodlV2IC0gdmVjMigxLjAgLyByZXNvbHV0aW9uLngsIDAuMCkpKS54eXpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC1jZSArIGdldFdvcmxkUG9zKHIxLCAodlV2ICsgdmVjMigxLjAgLyByZXNvbHV0aW9uLngsIDAuMCkpKS54eXo7XG4gICAgICB2ZWMzIGRwZHkgPSAoZGIgPCBkdCkgPyBjZSAtIGdldFdvcmxkUG9zKGIxLCAodlV2IC0gdmVjMigwLjAsIDEuMCAvIHJlc29sdXRpb24ueSkpKS54eXpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC1jZSArIGdldFdvcmxkUG9zKHQxLCAodlV2ICsgdmVjMigwLjAsIDEuMCAvIHJlc29sdXRpb24ueSkpKS54eXo7XG4gIFxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZShjcm9zcyhkcGR4LCBkcGR5KSk7XG4gIH1cblxuICAgICNpbmNsdWRlIDxjb21tb24+XG4gICAgI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgLy92ZWM0IHRleGVsID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpOy8vdmVjMygwLjApO1xuICAgICAgICB2ZWM0IHNjZW5lVGV4ZWwgPSB0ZXh0dXJlMkQoc2NlbmVEaWZmdXNlLCB2VXYpO1xuICAgICAgICAjaWZkZWYgUkVWRVJTRURFUFRIXG4gICAgICAgIGZsb2F0IGRlcHRoID0gMS4wIC0gdGV4dHVyZTJEKHNjZW5lRGVwdGgsIHZVdikueDtcbiAgICAgICAgI2Vsc2VcbiAgICAgICAgZmxvYXQgZGVwdGggPSB0ZXh0dXJlMkQoc2NlbmVEZXB0aCwgdlV2KS54O1xuICAgICAgICAjZW5kaWZcbiAgICAgICAgI2lmZGVmIEhBTEZSRVMgXG4gICAgICAgIHZlYzQgdGV4ZWw7XG4gICAgICAgIGlmIChkZXB0aCA9PSAxLjApIHtcbiAgICAgICAgICAgIHRleGVsID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICB2ZWMzIHdvcmxkUG9zID0gZ2V0V29ybGRQb3MoZGVwdGgsIHZVdik7XG4gICAgICAgIHZlYzMgbm9ybWFsID0gY29tcHV0ZU5vcm1hbChnZXRXb3JsZFBvcyhkZXB0aCwgdlV2KSwgdlV2KTtcbiAgICAgICAvLyB2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1xuICAgICAgIC8vIEZpbmQgY2xvc2VzdCBkZXB0aDtcbiAgICAgICBmbG9hdCB0b3RhbFdlaWdodCA9IDAuMDtcbiAgICAgICBmbG9hdCByYWRpdXNUb1VzZSA9IHNjcmVlblNwYWNlUmFkaXVzID8gZGlzdGFuY2UoXG4gICAgICAgIHdvcmxkUG9zLFxuICAgICAgICBnZXRXb3JsZFBvcyhkZXB0aCwgdlV2ICtcbiAgICAgICAgICB2ZWMyKHJhZGl1cywgMC4wKSAvIHJlc29sdXRpb24pXG4gICAgICApIDogcmFkaXVzO1xuICAgICAgZmxvYXQgZGlzdGFuY2VGYWxsb2ZmVG9Vc2UgPXNjcmVlblNwYWNlUmFkaXVzID9cbiAgICAgICAgICByYWRpdXNUb1VzZSAqIGRpc3RhbmNlRmFsbG9mZlxuICAgICAgOiBkaXN0YW5jZUZhbGxvZmY7XG4gICAgICAgIGZvcihmbG9hdCB4ID0gLTEuMDsgeCA8PSAxLjA7IHgrKykge1xuICAgICAgICAgICAgZm9yKGZsb2F0IHkgPSAtMS4wOyB5IDw9IDEuMDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgdmVjMiBvZmZzZXQgPSB2ZWMyKHgsIHkpO1xuICAgICAgICAgICAgICAgIGl2ZWMyIHAgPSBpdmVjMihcbiAgICAgICAgICAgICAgICAgICAgKHZVdiAqIHJlc29sdXRpb24gKiAwLjUpICsgb2Zmc2V0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2ZWMyIHBVdiA9IHZlYzIocCkgLyAocmVzb2x1dGlvbiAqIDAuNSk7XG4gICAgICAgICAgICAgICAgZmxvYXQgc2FtcGxlRGVwdGggPSB0ZXhlbEZldGNoKGRvd25zYW1wbGVkRGVwdGgscCwgMCkueDtcbiAgICAgICAgICAgICAgICB2ZWM0IHNhbXBsZUluZm8gPSB0ZXhlbEZldGNoKHREaWZmdXNlLCBwLCAwKTtcbiAgICAgICAgICAgICAgICB2ZWMzIG5vcm1hbFNhbXBsZSA9IHNhbXBsZUluZm8uZ2JhICogMi4wIC0gMS4wO1xuICAgICAgICAgICAgICAgIHZlYzMgd29ybGRQb3NTYW1wbGUgPSBnZXRXb3JsZFBvcyhzYW1wbGVEZXB0aCwgcFV2KTtcbiAgICAgICAgICAgICAgICBmbG9hdCB0YW5nZW50UGxhbmVEaXN0ID0gYWJzKGRvdCh3b3JsZFBvc1NhbXBsZSAtIHdvcmxkUG9zLCBub3JtYWwpKTtcbiAgICAgICAgICAgICAgICBmbG9hdCByYW5nZUNoZWNrID0gZXhwKC0xLjAgKiB0YW5nZW50UGxhbmVEaXN0ICogKDEuMCAvIGRpc3RhbmNlRmFsbG9mZlRvVXNlKSkgKiBtYXgoZG90KG5vcm1hbCwgbm9ybWFsU2FtcGxlKSwgMC4wKTtcbiAgICAgICAgICAgICAgICBmbG9hdCB3ZWlnaHQgPSByYW5nZUNoZWNrO1xuICAgICAgICAgICAgICAgIHRvdGFsV2VpZ2h0ICs9IHdlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXhlbCArPSBzYW1wbGVJbmZvICogd2VpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b3RhbFdlaWdodCA9PSAwLjApIHtcbiAgICAgICAgICAgIHRleGVsID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4ZWwgLz0gdG90YWxXZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgICAgICNlbHNlXG4gICAgICAgIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdik7XG4gICAgICAgICNlbmRpZlxuXG4gICAgICAgICNpZmRlZiBMT0dERVBUSFxuICAgICAgICB0ZXhlbC5yID0gY2xhbXAodGV4ZWwuciwgMC4wLCAxLjApO1xuICAgICAgICBpZiAodGV4ZWwuciA9PSAwLjApIHtcbiAgICAgICAgICB0ZXhlbC5yID0gMS4wO1xuICAgICAgICB9XG4gICAgICAgICNlbmRpZlxuICAgICBcbiAgICAgICAgZmxvYXQgZmluYWxBbyA9IHBvdyh0ZXhlbC5yLCBpbnRlbnNpdHkpO1xuICAgICAgICBpZiAoYW9Ub25lcyA+IDAuMCkge1xuICAgICAgICAgICAgZmluYWxBbyA9IGNlaWwoZmluYWxBbyAqIGFvVG9uZXMpIC8gYW9Ub25lcztcbiAgICAgICAgfVxuICAgICAgICBmbG9hdCBmb2dGYWN0b3I7XG4gICAgICAgIGZsb2F0IGZvZ0RlcHRoID0gZGlzdGFuY2UoXG4gICAgICAgICAgICBjYW1lcmFQb3MsXG4gICAgICAgICAgICBnZXRXb3JsZFBvcyhkZXB0aCwgdlV2KVxuICAgICAgICApO1xuICAgICAgICBpZiAoZm9nKSB7XG4gICAgICAgICAgICBpZiAoZm9nRXhwKSB7XG4gICAgICAgICAgICAgICAgZm9nRmFjdG9yID0gMS4wIC0gZXhwKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZm9nRGVwdGggKiBmb2dEZXB0aCApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGZvZ0RlcHRoICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zcGFyZW5jeUF3YXJlKSB7XG4gICAgICAgICAgICBmbG9hdCB0cmFuc3BhcmVuY3lEV09mZiA9IHRleHR1cmUyRCh0cmFuc3BhcmVuY3lEV0ZhbHNlLCB2VXYpLmE7XG4gICAgICAgICAgICBmbG9hdCB0cmFuc3BhcmVuY3lEV09uID0gdGV4dHVyZTJEKHRyYW5zcGFyZW5jeURXVHJ1ZSwgdlV2KS5hO1xuICAgICAgICAgICAgZmxvYXQgYWRqdXN0bWVudEZhY3Rvck9mZiA9IHRyYW5zcGFyZW5jeURXT2ZmO1xuICAgICAgICAgICAgI2lmZGVmIFJFVkVSU0VERVBUSFxuICAgICAgICAgICAgZmxvYXQgZGVwdGhTYW1wbGUgPSAxLjAgLSB0ZXh0dXJlMkQoc2NlbmVEZXB0aCwgdlV2KS5yO1xuICAgICAgICAgICAgZmxvYXQgdHJ1ZURlcHRoU2FtcGxlID0gMS4wIC0gdGV4dHVyZTJEKHRyYW5zcGFyZW5jeURXVHJ1ZURlcHRoLCB2VXYpLnI7XG4gICAgICAgICAgICAjZWxzZVxuICAgICAgICAgICAgZmxvYXQgZGVwdGhTYW1wbGUgPSB0ZXh0dXJlMkQoc2NlbmVEZXB0aCwgdlV2KS5yO1xuICAgICAgICAgICAgZmxvYXQgdHJ1ZURlcHRoU2FtcGxlID0gdGV4dHVyZTJEKHRyYW5zcGFyZW5jeURXVHJ1ZURlcHRoLCB2VXYpLnI7XG4gICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgIGZsb2F0IGFkanVzdG1lbnRGYWN0b3JPbiA9ICgxLjAgLSB0cmFuc3BhcmVuY3lEV09uKSAqIChcbiAgICAgICAgICAgICAgICB0cnVlRGVwdGhTYW1wbGUgPT0gZGVwdGhTYW1wbGUgPyAxLjAgOiAwLjBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmbG9hdCBhZGp1c3RtZW50RmFjdG9yID0gbWF4KGFkanVzdG1lbnRGYWN0b3JPZmYsIGFkanVzdG1lbnRGYWN0b3JPbik7XG4gICAgICAgICAgICBmaW5hbEFvID0gbWl4KGZpbmFsQW8sIDEuMCwgYWRqdXN0bWVudEZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxBbyA9IG1peChmaW5hbEFvLCAxLjAsIGZvZ0ZhY3Rvcik7XG4gICAgICAgIHZlYzMgYW9BcHBsaWVkID0gY29sb3IgKiBtaXgodmVjMygxLjApLCBzY2VuZVRleGVsLnJnYiwgZmxvYXQoY29sb3JNdWx0aXBseSkpO1xuICAgICAgICBpZiAocmVuZGVyTW9kZSA9PSAwLjApIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIG1peChzY2VuZVRleGVsLnJnYiwgYW9BcHBsaWVkLCAxLjAgLSBmaW5hbEFvKSwgc2NlbmVUZXhlbC5hKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZW5kZXJNb2RlID09IDEuMCkge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggbWl4KHZlYzMoMS4wKSwgYW9BcHBsaWVkLCAxLjAgLSBmaW5hbEFvKSwgc2NlbmVUZXhlbC5hKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZW5kZXJNb2RlID09IDIuMCkge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggc2NlbmVUZXhlbC5yZ2IsIHNjZW5lVGV4ZWwuYSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVyTW9kZSA9PSAzLjApIHtcbiAgICAgICAgICAgIGlmICh2VXYueCA8IDAuNSkge1xuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHNjZW5lVGV4ZWwucmdiLCBzY2VuZVRleGVsLmEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhYnModlV2LnggLSAwLjUpIDwgMS4wIC8gcmVzb2x1dGlvbi54KSB7XG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBtaXgoc2NlbmVUZXhlbC5yZ2IsIGFvQXBwbGllZCwgMS4wIC0gZmluYWxBbyksIHNjZW5lVGV4ZWwuYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVyTW9kZSA9PSA0LjApIHtcbiAgICAgICAgICAgIGlmICh2VXYueCA8IDAuNSkge1xuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHNjZW5lVGV4ZWwucmdiLCBzY2VuZVRleGVsLmEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhYnModlV2LnggLSAwLjUpIDwgMS4wIC8gcmVzb2x1dGlvbi54KSB7XG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBtaXgodmVjMygxLjApLCBhb0FwcGxpZWQsIDEuMCAtIGZpbmFsQW8pLCBzY2VuZVRleGVsLmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XG4gICAgICAgIGlmIChnYW1tYUNvcnJlY3Rpb24pIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHNSR0JUcmFuc2Zlck9FVEYoZ2xfRnJhZ0NvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBgXG59O1xuXG5cblxuY29uc3QgJGU1MjM3OGNkMGY1YTk3M2QkZXhwb3J0JDU3ODU2YjU5ZjMxNzI2MmUgPSB7XG4gICAgdW5pZm9ybXM6IHtcbiAgICAgICAgXCJzY2VuZURpZmZ1c2VcIjoge1xuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJzY2VuZURlcHRoXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwidERpZmZ1c2VcIjoge1xuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJwcm9qTWF0XCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3ICQ1V2hlMyRNYXRyaXg0KClcbiAgICAgICAgfSxcbiAgICAgICAgXCJ2aWV3TWF0XCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3ICQ1V2hlMyRNYXRyaXg0KClcbiAgICAgICAgfSxcbiAgICAgICAgXCJwcm9qZWN0aW9uTWF0cml4SW52XCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3ICQ1V2hlMyRNYXRyaXg0KClcbiAgICAgICAgfSxcbiAgICAgICAgXCJ2aWV3TWF0cml4SW52XCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3ICQ1V2hlMyRNYXRyaXg0KClcbiAgICAgICAgfSxcbiAgICAgICAgXCJjYW1lcmFQb3NcIjoge1xuICAgICAgICAgICAgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgJDVXaGUzJFZlY3RvcjMoKVxuICAgICAgICB9LFxuICAgICAgICBcInJlc29sdXRpb25cIjoge1xuICAgICAgICAgICAgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgJDVXaGUzJFZlY3RvcjIoKVxuICAgICAgICB9LFxuICAgICAgICBcInRpbWVcIjoge1xuICAgICAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgICB9LFxuICAgICAgICBcInJcIjoge1xuICAgICAgICAgICAgdmFsdWU6IDUuMFxuICAgICAgICB9LFxuICAgICAgICBcImJsdWVOb2lzZVwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBcInJhZGl1c1wiOiB7XG4gICAgICAgICAgICB2YWx1ZTogMTIuMFxuICAgICAgICB9LFxuICAgICAgICBcIndvcmxkUmFkaXVzXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiA1LjBcbiAgICAgICAgfSxcbiAgICAgICAgXCJpbmRleFwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogMC4wXG4gICAgICAgIH0sXG4gICAgICAgIFwicG9pc3NvbkRpc2tcIjoge1xuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlzdGFuY2VGYWxsb2ZmXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgXCJuZWFyXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwLjFcbiAgICAgICAgfSxcbiAgICAgICAgXCJmYXJcIjoge1xuICAgICAgICAgICAgdmFsdWU6IDEwMDAuMFxuICAgICAgICB9LFxuICAgICAgICBcInNjcmVlblNwYWNlUmFkaXVzXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgIHZlcnRleFNoYWRlcjogLyogZ2xzbCAqLyBgXG5cdFx0dmFyeWluZyB2ZWMyIHZVdjtcblx0XHR2b2lkIG1haW4oKSB7XG5cdFx0XHR2VXYgPSB1djtcblx0XHRcdGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMS4wKTtcblx0XHR9YCxcbiAgICBmcmFnbWVudFNoYWRlcjogLyogZ2xzbCAqLyBgXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgc2NlbmVEaWZmdXNlO1xuICAgIHVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIHNjZW5lRGVwdGg7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgYmx1ZU5vaXNlO1xuICAgIHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4SW52O1xuICAgIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4SW52O1xuICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gZmxvYXQgcjtcbiAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcbiAgICAgdW5pZm9ybSBmbG9hdCB3b3JsZFJhZGl1cztcbiAgICB1bmlmb3JtIGZsb2F0IGluZGV4O1xuICAgICB1bmlmb3JtIGZsb2F0IG5lYXI7XG4gICAgIHVuaWZvcm0gZmxvYXQgZmFyO1xuICAgICB1bmlmb3JtIGZsb2F0IGRpc3RhbmNlRmFsbG9mZjtcbiAgICAgdW5pZm9ybSBib29sIHNjcmVlblNwYWNlUmFkaXVzO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG5cbiAgICBoaWdocCBmbG9hdCBsaW5lYXJpemVfZGVwdGgoaGlnaHAgZmxvYXQgZCwgaGlnaHAgZmxvYXQgek5lYXIsaGlnaHAgZmxvYXQgekZhcilcbiAgICB7XG4gICAgICAgIGhpZ2hwIGZsb2F0IHpfbiA9IDIuMCAqIGQgLSAxLjA7XG4gICAgICAgIHJldHVybiAyLjAgKiB6TmVhciAqIHpGYXIgLyAoekZhciArIHpOZWFyIC0gel9uICogKHpGYXIgLSB6TmVhcikpO1xuICAgIH1cbiAgICBoaWdocCBmbG9hdCBsaW5lYXJpemVfZGVwdGhfbG9nKGhpZ2hwIGZsb2F0IGQsIGhpZ2hwIGZsb2F0IG5lYXJaLGhpZ2hwIGZsb2F0IGZhclopIHtcbiAgICAgZmxvYXQgZGVwdGggPSBwb3coMi4wLCBkICogbG9nMihmYXJaICsgMS4wKSkgLSAxLjA7XG4gICAgIGZsb2F0IGEgPSBmYXJaIC8gKGZhclogLSBuZWFyWik7XG4gICAgIGZsb2F0IGIgPSBmYXJaICogbmVhclogLyAobmVhclogLSBmYXJaKTtcbiAgICAgZmxvYXQgbGluRGVwdGggPSBhICsgYiAvIGRlcHRoO1xuICAgICByZXR1cm4gbGluZWFyaXplX2RlcHRoKGxpbkRlcHRoLCBuZWFyWiwgZmFyWik7XG4gICB9XG4gICBoaWdocCBmbG9hdCBsaW5lYXJpemVfZGVwdGhfb3J0aG8oaGlnaHAgZmxvYXQgZCwgaGlnaHAgZmxvYXQgbmVhclosIGhpZ2hwIGZsb2F0IGZhclopIHtcbiAgICAgcmV0dXJuIG5lYXJaICsgKGZhclogLSBuZWFyWikgKiBkO1xuICAgfVxuICAgdmVjMyBnZXRXb3JsZFBvc0xvZyh2ZWMzIHBvc1MpIHtcbiAgICAgdmVjMiB1diA9IHBvc1MueHk7XG4gICAgIGZsb2F0IHogPSBwb3NTLno7XG4gICAgIGZsb2F0IG5lYXJaID1uZWFyO1xuICAgICBmbG9hdCBmYXJaID0gZmFyO1xuICAgICBmbG9hdCBkZXB0aCA9IHBvdygyLjAsIHogKiBsb2cyKGZhclogKyAxLjApKSAtIDEuMDtcbiAgICAgZmxvYXQgYSA9IGZhclogLyAoZmFyWiAtIG5lYXJaKTtcbiAgICAgZmxvYXQgYiA9IGZhclogKiBuZWFyWiAvIChuZWFyWiAtIGZhclopO1xuICAgICBmbG9hdCBsaW5EZXB0aCA9IGEgKyBiIC8gZGVwdGg7XG4gICAgIHZlYzQgY2xpcFZlYyA9IHZlYzQodXYsIGxpbkRlcHRoLCAxLjApICogMi4wIC0gMS4wO1xuICAgICB2ZWM0IHdwb3MgPSBwcm9qZWN0aW9uTWF0cml4SW52ICogY2xpcFZlYztcbiAgICAgcmV0dXJuIHdwb3MueHl6IC8gd3Bvcy53O1xuICAgfVxuICAgIHZlYzMgZ2V0V29ybGRQb3MoZmxvYXQgZGVwdGgsIHZlYzIgY29vcmQpIHtcbiAgICAgI2lmZGVmIExPR0RFUFRIXG4gICAgICAjaWZuZGVmIE9SVEhPXG4gICAgICAgICAgcmV0dXJuIGdldFdvcmxkUG9zTG9nKHZlYzMoY29vcmQsIGRlcHRoKSk7XG4gICAgICAjZW5kaWZcbiAgICAgI2VuZGlmXG4gICAgICAgIFxuICAgICAgICBmbG9hdCB6ID0gZGVwdGggKiAyLjAgLSAxLjA7XG4gICAgICAgIHZlYzQgY2xpcFNwYWNlUG9zaXRpb24gPSB2ZWM0KGNvb3JkICogMi4wIC0gMS4wLCB6LCAxLjApO1xuICAgICAgICB2ZWM0IHZpZXdTcGFjZVBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeEludiAqIGNsaXBTcGFjZVBvc2l0aW9uO1xuICAgICAgICAvLyBQZXJzcGVjdGl2ZSBkaXZpc2lvblxuICAgICAgIHZlYzQgd29ybGRTcGFjZVBvc2l0aW9uID0gdmlld1NwYWNlUG9zaXRpb247XG4gICAgICAgd29ybGRTcGFjZVBvc2l0aW9uLnh5eiAvPSB3b3JsZFNwYWNlUG9zaXRpb24udztcbiAgICAgICAgcmV0dXJuIHdvcmxkU3BhY2VQb3NpdGlvbi54eXo7XG4gICAgfVxuICAgICNpbmNsdWRlIDxjb21tb24+XG4gICAgI2RlZmluZSBOVU1fU0FNUExFUyAxNlxuICAgIHVuaWZvcm0gdmVjMiBwb2lzc29uRGlza1tOVU1fU0FNUExFU107XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICBjb25zdCBmbG9hdCBwaSA9IDMuMTQxNTk7XG4gICAgICAgIHZlYzIgdGV4ZWxTaXplID0gdmVjMigxLjAgLyByZXNvbHV0aW9uLngsIDEuMCAvIHJlc29sdXRpb24ueSk7XG4gICAgICAgIHZlYzIgdXYgPSB2VXY7XG4gICAgICAgIHZlYzQgZGF0YSA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KTtcbiAgICAgICAgZmxvYXQgb2NjbHVzaW9uID0gZGF0YS5yO1xuICAgICAgICBmbG9hdCBiYXNlT2NjID0gZGF0YS5yO1xuICAgICAgICB2ZWMzIG5vcm1hbCA9IGRhdGEuZ2JhICogMi4wIC0gMS4wO1xuICAgICAgICBmbG9hdCBjb3VudCA9IDEuMDtcbiAgICAgICAgZmxvYXQgZCA9IHRleHR1cmUyRChzY2VuZURlcHRoLCB2VXYpLng7XG4gICAgICAgIGlmIChkID09IDEuMCkge1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGRhdGE7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZlYzMgd29ybGRQb3MgPSBnZXRXb3JsZFBvcyhkLCB2VXYpO1xuICAgICAgICBmbG9hdCBzaXplID0gcmFkaXVzO1xuICAgICAgICBmbG9hdCBhbmdsZTtcbiAgICAgICAgaWYgKGluZGV4ID09IDAuMCkge1xuICAgICAgICAgICAgIGFuZ2xlID0gdGV4dHVyZTJEKGJsdWVOb2lzZSwgZ2xfRnJhZ0Nvb3JkLnh5IC8gMTI4LjApLncgKiBQSTI7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT0gMS4wKSB7XG4gICAgICAgICAgICAgYW5nbGUgPSB0ZXh0dXJlMkQoYmx1ZU5vaXNlLCBnbF9GcmFnQ29vcmQueHkgLyAxMjguMCkueiAqIFBJMjtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PSAyLjApIHtcbiAgICAgICAgICAgICBhbmdsZSA9IHRleHR1cmUyRChibHVlTm9pc2UsIGdsX0ZyYWdDb29yZC54eSAvIDEyOC4wKS55ICogUEkyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIGFuZ2xlID0gdGV4dHVyZTJEKGJsdWVOb2lzZSwgZ2xfRnJhZ0Nvb3JkLnh5IC8gMTI4LjApLnggKiBQSTI7XG4gICAgICAgIH1cblxuICAgICAgICBtYXQyIHJvdGF0aW9uTWF0cml4ID0gbWF0Mihjb3MoYW5nbGUpLCAtc2luKGFuZ2xlKSwgc2luKGFuZ2xlKSwgY29zKGFuZ2xlKSk7XG4gICAgICAgIGZsb2F0IHJhZGl1c1RvVXNlID0gc2NyZWVuU3BhY2VSYWRpdXMgPyBkaXN0YW5jZShcbiAgICAgICAgICB3b3JsZFBvcyxcbiAgICAgICAgICBnZXRXb3JsZFBvcyhkLCB2VXYgK1xuICAgICAgICAgICAgdmVjMih3b3JsZFJhZGl1cywgMC4wKSAvIHJlc29sdXRpb24pXG4gICAgICAgICkgOiB3b3JsZFJhZGl1cztcbiAgICAgICAgZmxvYXQgZGlzdGFuY2VGYWxsb2ZmVG9Vc2UgPXNjcmVlblNwYWNlUmFkaXVzID9cbiAgICAgICAgcmFkaXVzVG9Vc2UgKiBkaXN0YW5jZUZhbGxvZmZcbiAgICA6IHJhZGl1c1RvVXNlICogZGlzdGFuY2VGYWxsb2ZmICogMC4yO1xuXG4gICAgICAgIGZsb2F0IGludkRpc3RhbmNlID0gKDEuMCAvIGRpc3RhbmNlRmFsbG9mZlRvVXNlKTtcbiAgICAgICAgZm9yKGludCBpID0gMDsgaSA8IE5VTV9TQU1QTEVTOyBpKyspIHtcbiAgICAgICAgICAgIHZlYzIgb2Zmc2V0ID0gKHJvdGF0aW9uTWF0cml4ICogcG9pc3NvbkRpc2tbaV0pICogdGV4ZWxTaXplICogc2l6ZTtcbiAgICAgICAgICAgIHZlYzQgZGF0YVNhbXBsZSA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdXYgKyBvZmZzZXQpO1xuICAgICAgICAgICAgZmxvYXQgb2NjU2FtcGxlID0gZGF0YVNhbXBsZS5yO1xuICAgICAgICAgICAgdmVjMyBub3JtYWxTYW1wbGUgPSBkYXRhU2FtcGxlLmdiYSAqIDIuMCAtIDEuMDtcbiAgICAgICAgICAgIGZsb2F0IGRTYW1wbGUgPSB0ZXh0dXJlMkQoc2NlbmVEZXB0aCwgdXYgKyBvZmZzZXQpLng7XG4gICAgICAgICAgICB2ZWMzIHdvcmxkUG9zU2FtcGxlID0gZ2V0V29ybGRQb3MoZFNhbXBsZSwgdXYgKyBvZmZzZXQpO1xuICAgICAgICAgICAgZmxvYXQgdGFuZ2VudFBsYW5lRGlzdCA9IGFicyhkb3Qod29ybGRQb3NTYW1wbGUgLSB3b3JsZFBvcywgbm9ybWFsKSk7XG4gICAgICAgICAgICBmbG9hdCByYW5nZUNoZWNrID0gZmxvYXQoZFNhbXBsZSAhPSAxLjApICogZXhwKC0xLjAgKiB0YW5nZW50UGxhbmVEaXN0ICogaW52RGlzdGFuY2UgKSAqIG1heChkb3Qobm9ybWFsLCBub3JtYWxTYW1wbGUpLCAwLjApO1xuICAgICAgICAgICAgb2NjbHVzaW9uICs9IG9jY1NhbXBsZSAqIHJhbmdlQ2hlY2s7XG4gICAgICAgICAgICBjb3VudCArPSByYW5nZUNoZWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA+IDAuMCkge1xuICAgICAgICAgIG9jY2x1c2lvbiAvPSBjb3VudDtcbiAgICAgICAgfVxuICAgICAgICBvY2NsdXNpb24gPSBjbGFtcChvY2NsdXNpb24sIDAuMCwgMS4wKTtcbiAgICAgICAgaWYgKG9jY2x1c2lvbiA9PSAwLjApIHtcbiAgICAgICAgICBvY2NsdXNpb24gPSAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChvY2NsdXNpb24sIDAuNSArIDAuNSAqIG5vcm1hbCk7XG4gICAgfVxuICAgIGBcbn07XG5cblxuXG5jb25zdCAkMjZhY2ExNzNlMDk4NGQ5OSRleHBvcnQkMWVmZGY0OTE2ODdjZDQ0MiA9IHtcbiAgICB1bmlmb3Jtczoge1xuICAgICAgICBcInNjZW5lRGVwdGhcIjoge1xuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZXNvbHV0aW9uXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAvKiBAX19QVVJFX18gKi8gbmV3ICQ1V2hlMyRWZWN0b3IyKClcbiAgICAgICAgfSxcbiAgICAgICAgXCJuZWFyXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwLjFcbiAgICAgICAgfSxcbiAgICAgICAgXCJmYXJcIjoge1xuICAgICAgICAgICAgdmFsdWU6IDEwMDAuMFxuICAgICAgICB9LFxuICAgICAgICBcInZpZXdNYXRyaXhJbnZcIjoge1xuICAgICAgICAgICAgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgJDVXaGUzJE1hdHJpeDQoKVxuICAgICAgICB9LFxuICAgICAgICBcInByb2plY3Rpb25NYXRyaXhJbnZcIjoge1xuICAgICAgICAgICAgdmFsdWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgJDVXaGUzJE1hdHJpeDQoKVxuICAgICAgICB9LFxuICAgICAgICBcImxvZ0RlcHRoXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcIm9ydGhvXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgIHZlcnRleFNoYWRlcjogLyogZ2xzbCAqLyBgXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZVdiA9IHV2O1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEpO1xuICAgIH1gLFxuICAgIGZyYWdtZW50U2hhZGVyOiAvKiBnbHNsICovIGBcbiAgICB1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBzY2VuZURlcHRoO1xuICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gZmxvYXQgbmVhcjtcbiAgICB1bmlmb3JtIGZsb2F0IGZhcjtcbiAgICB1bmlmb3JtIGJvb2wgbG9nRGVwdGg7XG4gICAgdW5pZm9ybSBib29sIG9ydGhvO1xuICAgIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4SW52O1xuICAgIHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4SW52O1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgbGF5b3V0KGxvY2F0aW9uID0gMSkgb3V0IHZlYzQgZ05vcm1hbDtcbiAgICB2ZWMzIGdldFdvcmxkUG9zTG9nKHZlYzMgcG9zUykge1xuICAgICAgICB2ZWMyIHV2ID0gcG9zUy54eTtcbiAgICAgICAgZmxvYXQgeiA9IHBvc1MuejtcbiAgICAgICAgZmxvYXQgbmVhclogPW5lYXI7XG4gICAgICAgIGZsb2F0IGZhclogPSBmYXI7XG4gICAgICAgIGZsb2F0IGRlcHRoID0gcG93KDIuMCwgeiAqIGxvZzIoZmFyWiArIDEuMCkpIC0gMS4wO1xuICAgICAgICBmbG9hdCBhID0gZmFyWiAvIChmYXJaIC0gbmVhclopO1xuICAgICAgICBmbG9hdCBiID0gZmFyWiAqIG5lYXJaIC8gKG5lYXJaIC0gZmFyWik7XG4gICAgICAgIGZsb2F0IGxpbkRlcHRoID0gYSArIGIgLyBkZXB0aDtcbiAgICAgICAgdmVjNCBjbGlwVmVjID0gdmVjNCh1diwgbGluRGVwdGgsIDEuMCkgKiAyLjAgLSAxLjA7XG4gICAgICAgIHZlYzQgd3BvcyA9IHByb2plY3Rpb25NYXRyaXhJbnYgKiBjbGlwVmVjO1xuICAgICAgICByZXR1cm4gd3Bvcy54eXogLyB3cG9zLnc7XG4gICAgICB9XG4gICAgICB2ZWMzIGdldFdvcmxkUG9zKGZsb2F0IGRlcHRoLCB2ZWMyIGNvb3JkKSB7XG4gICAgICAgIGlmIChsb2dEZXB0aCAmJiAhb3J0aG8pIHtcbiAgICAgICAgICByZXR1cm4gZ2V0V29ybGRQb3NMb2codmVjMyhjb29yZCwgZGVwdGgpKTtcbiAgICAgICAgfVxuICAgICAgICBmbG9hdCB6ID0gZGVwdGggKiAyLjAgLSAxLjA7XG4gICAgICAgIHZlYzQgY2xpcFNwYWNlUG9zaXRpb24gPSB2ZWM0KGNvb3JkICogMi4wIC0gMS4wLCB6LCAxLjApO1xuICAgICAgICB2ZWM0IHZpZXdTcGFjZVBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeEludiAqIGNsaXBTcGFjZVBvc2l0aW9uO1xuICAgICAgICAvLyBQZXJzcGVjdGl2ZSBkaXZpc2lvblxuICAgICAgIHZlYzQgd29ybGRTcGFjZVBvc2l0aW9uID0gdmlld1NwYWNlUG9zaXRpb247XG4gICAgICAgd29ybGRTcGFjZVBvc2l0aW9uLnh5eiAvPSB3b3JsZFNwYWNlUG9zaXRpb24udztcbiAgICAgICAgcmV0dXJuIHdvcmxkU3BhY2VQb3NpdGlvbi54eXo7XG4gICAgfVxuICBcbiAgICB2ZWMzIGNvbXB1dGVOb3JtYWwodmVjMyB3b3JsZFBvcywgdmVjMiB2VXYpIHtcbiAgICAgIGl2ZWMyIHAgPSBpdmVjMih2VXYgKiByZXNvbHV0aW9uKTtcbiAgICAgICNpZmRlZiBSRVZFUlNFREVQVEhcbiAgICAgIGZsb2F0IGMwID0gMS4wIC0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwLCAwKS54O1xuICAgICAgZmxvYXQgbDIgPSAxLjAgLSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgLSBpdmVjMigyLCAwKSwgMCkueDtcbiAgICAgIGZsb2F0IGwxID0gMS4wIC0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwIC0gaXZlYzIoMSwgMCksIDApLng7XG4gICAgICBmbG9hdCByMSA9IDEuMCAtIHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCArIGl2ZWMyKDEsIDApLCAwKS54O1xuICAgICAgZmxvYXQgcjIgPSAxLjAgLSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgKyBpdmVjMigyLCAwKSwgMCkueDtcbiAgICAgIGZsb2F0IGIyID0gMS4wIC0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwIC0gaXZlYzIoMCwgMiksIDApLng7XG4gICAgICBmbG9hdCBiMSA9IDEuMCAtIHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCAtIGl2ZWMyKDAsIDEpLCAwKS54O1xuICAgICAgZmxvYXQgdDEgPSAxLjAgLSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgKyBpdmVjMigwLCAxKSwgMCkueDtcbiAgICAgIGZsb2F0IHQyID0gMS4wIC0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwICsgaXZlYzIoMCwgMiksIDApLng7XG4gICAgICAjZWxzZVxuICAgICAgZmxvYXQgYzAgPSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAsIDApLng7XG4gICAgICBmbG9hdCBsMiA9IHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCAtIGl2ZWMyKDIsIDApLCAwKS54O1xuICAgICAgZmxvYXQgbDEgPSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgLSBpdmVjMigxLCAwKSwgMCkueDtcbiAgICAgIGZsb2F0IHIxID0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwICsgaXZlYzIoMSwgMCksIDApLng7XG4gICAgICBmbG9hdCByMiA9IHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCArIGl2ZWMyKDIsIDApLCAwKS54O1xuICAgICAgZmxvYXQgYjIgPSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgLSBpdmVjMigwLCAyKSwgMCkueDtcbiAgICAgIGZsb2F0IGIxID0gdGV4ZWxGZXRjaChzY2VuZURlcHRoLCBwIC0gaXZlYzIoMCwgMSksIDApLng7XG4gICAgICBmbG9hdCB0MSA9IHRleGVsRmV0Y2goc2NlbmVEZXB0aCwgcCArIGl2ZWMyKDAsIDEpLCAwKS54O1xuICAgICAgZmxvYXQgdDIgPSB0ZXhlbEZldGNoKHNjZW5lRGVwdGgsIHAgKyBpdmVjMigwLCAyKSwgMCkueDtcbiAgICAgICNlbmRpZlxuICBcbiAgICAgIGZsb2F0IGRsID0gYWJzKCgyLjAgKiBsMSAtIGwyKSAtIGMwKTtcbiAgICAgIGZsb2F0IGRyID0gYWJzKCgyLjAgKiByMSAtIHIyKSAtIGMwKTtcbiAgICAgIGZsb2F0IGRiID0gYWJzKCgyLjAgKiBiMSAtIGIyKSAtIGMwKTtcbiAgICAgIGZsb2F0IGR0ID0gYWJzKCgyLjAgKiB0MSAtIHQyKSAtIGMwKTtcbiAgXG4gICAgICB2ZWMzIGNlID0gZ2V0V29ybGRQb3MoYzAsIHZVdikueHl6O1xuICBcbiAgICAgIHZlYzMgZHBkeCA9IChkbCA8IGRyKSA/IGNlIC0gZ2V0V29ybGRQb3MobDEsICh2VXYgLSB2ZWMyKDEuMCAvIHJlc29sdXRpb24ueCwgMC4wKSkpLnh5elxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogLWNlICsgZ2V0V29ybGRQb3MocjEsICh2VXYgKyB2ZWMyKDEuMCAvIHJlc29sdXRpb24ueCwgMC4wKSkpLnh5ejtcbiAgICAgIHZlYzMgZHBkeSA9IChkYiA8IGR0KSA/IGNlIC0gZ2V0V29ybGRQb3MoYjEsICh2VXYgLSB2ZWMyKDAuMCwgMS4wIC8gcmVzb2x1dGlvbi55KSkpLnh5elxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogLWNlICsgZ2V0V29ybGRQb3ModDEsICh2VXYgKyB2ZWMyKDAuMCwgMS4wIC8gcmVzb2x1dGlvbi55KSkpLnh5ejtcbiAgXG4gICAgICByZXR1cm4gbm9ybWFsaXplKGNyb3NzKGRwZHgsIGRwZHkpKTtcbiAgfVxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjMiB1diA9IHZVdiAtIHZlYzIoMC41KSAvIHJlc29sdXRpb247XG4gICAgICAgIHZlYzIgcGl4ZWxTaXplID0gdmVjMigxLjApIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgaGlnaHAgdmVjMls0XSB1dlNhbXBsZXM7XG4gICAgICAgIHV2U2FtcGxlc1swXSA9IHV2O1xuICAgICAgICB1dlNhbXBsZXNbMV0gPSB1diArIHZlYzIocGl4ZWxTaXplLngsIDAuMCk7XG4gICAgICAgIHV2U2FtcGxlc1syXSA9IHV2ICsgdmVjMigwLjAsIHBpeGVsU2l6ZS55KTtcbiAgICAgICAgdXZTYW1wbGVzWzNdID0gdXYgKyBwaXhlbFNpemU7XG4gICAgICAgICNpZmRlZiBSRVZFUlNFREVQVEhcbiAgICAgICAgZmxvYXQgZGVwdGgwMCA9IDEuMCAtIHRleHR1cmUyRChzY2VuZURlcHRoLCB1dlNhbXBsZXNbMF0pLnI7XG4gICAgICAgIGZsb2F0IGRlcHRoMTAgPSAxLjAgLSB0ZXh0dXJlMkQoc2NlbmVEZXB0aCwgdXZTYW1wbGVzWzFdKS5yO1xuICAgICAgICBmbG9hdCBkZXB0aDAxID0gMS4wIC0gdGV4dHVyZTJEKHNjZW5lRGVwdGgsIHV2U2FtcGxlc1syXSkucjtcbiAgICAgICAgZmxvYXQgZGVwdGgxMSA9IDEuMCAtIHRleHR1cmUyRChzY2VuZURlcHRoLCB1dlNhbXBsZXNbM10pLnI7XG4gICAgICAgICNlbHNlXG4gICAgICAgIGZsb2F0IGRlcHRoMDAgPSB0ZXh0dXJlMkQoc2NlbmVEZXB0aCwgdXZTYW1wbGVzWzBdKS5yO1xuICAgICAgICBmbG9hdCBkZXB0aDEwID0gdGV4dHVyZTJEKHNjZW5lRGVwdGgsIHV2U2FtcGxlc1sxXSkucjtcbiAgICAgICAgZmxvYXQgZGVwdGgwMSA9IHRleHR1cmUyRChzY2VuZURlcHRoLCB1dlNhbXBsZXNbMl0pLnI7XG4gICAgICAgIGZsb2F0IGRlcHRoMTEgPSB0ZXh0dXJlMkQoc2NlbmVEZXB0aCwgdXZTYW1wbGVzWzNdKS5yO1xuICAgICAgICAjZW5kaWZcbiAgICAgICAgZmxvYXQgbWluRGVwdGggPSBtaW4obWluKGRlcHRoMDAsIGRlcHRoMTApLCBtaW4oZGVwdGgwMSwgZGVwdGgxMSkpO1xuICAgICAgICBmbG9hdCBtYXhEZXB0aCA9IG1heChtYXgoZGVwdGgwMCwgZGVwdGgxMCksIG1heChkZXB0aDAxLCBkZXB0aDExKSk7XG4gICAgICAgIGZsb2F0IHRhcmdldERlcHRoID0gbWluRGVwdGg7XG4gICAgICAgIC8vIENoZWNrZXJib2FyZCBwYXR0ZXJuIHRvIGF2b2lkIGFydGlmYWN0c1xuICAgICAgICBpZiAobW9kKGdsX0ZyYWdDb29yZC54ICsgZ2xfRnJhZ0Nvb3JkLnksIDIuMCkgPiAwLjUpIHsgXG4gICAgICAgICAgICB0YXJnZXREZXB0aCA9IG1heERlcHRoO1xuICAgICAgICB9XG4gICAgICAgIGludCBjaG9zZW5JbmRleCA9IDA7XG4gICAgICAgIGZsb2F0WzRdIHNhbXBsZXM7XG4gICAgICAgIHNhbXBsZXNbMF0gPSBkZXB0aDAwO1xuICAgICAgICBzYW1wbGVzWzFdID0gZGVwdGgxMDtcbiAgICAgICAgc2FtcGxlc1syXSA9IGRlcHRoMDE7XG4gICAgICAgIHNhbXBsZXNbM10gPSBkZXB0aDExO1xuICAgICAgICBmb3IoaW50IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoc2FtcGxlc1tpXSA9PSB0YXJnZXREZXB0aCkge1xuICAgICAgICAgICAgICAgIGNob3NlbkluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHNhbXBsZXNbY2hvc2VuSW5kZXhdLCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgZ05vcm1hbCA9IHZlYzQoY29tcHV0ZU5vcm1hbChcbiAgICAgICAgICAgIGdldFdvcmxkUG9zKHNhbXBsZXNbY2hvc2VuSW5kZXhdLCB1dlNhbXBsZXNbY2hvc2VuSW5kZXhdKSwgdXZTYW1wbGVzW2Nob3NlbkluZGV4XVxuICAgICAgICApLCAwLjApO1xuICAgIH1gXG59O1xuXG5cblxuXG5cblxuXG5cblxuY29uc3QgJDA2MjY5YWQ3OGYzYzVmZGYkdmFyJEJsdWVOb2lzZSA9IGA1TDdwUDRVWHJPSXIvVloxRzNmNnA4OUZJV1U3bHFjN0ozRFB4S2pKVVhPREpvSFF6Zi9hTlZNK0FCbHZoWGVCR043aUMwV2ttVGpFYUFxT0l0QmZCZGFLNUtTR1YxRVQ1U09LbDN4OUpPWDV3MnNBbDYrNktqRGhWVUhnYnFxN0RaNUVlWXpiZFNOeHRyUUxXL0trUEpvT1RHNHU1Q0JVWmtDS0huaVk5bDdEVWdqdXo3MDh6RzFISUM4cWZvaGkxdlBqUEg5THE0N2tzalJyandYRDRNbFZDamRBcVlGR29kUTh0Um1Ia09mcTR3VlJJQUh2b2F2UEh2TjFscGszWDRZMXl6QVBHZThTOUtCczNjcmM0R3dsVTFkRU9YaVdvbC9tZ1FxeGtOcUIxeGQwNCswQm1wd2owR2NDYzROVWkrYzczMUZVeGp2YWV4Q2tDSjBxaHJKSisraHRXcWV0TkM0TmV3Q2x1OGFGUlN3cnFpSkVHZStxdFRnNENZQ0hhRjF3Skkwc3kvWkJRQUkwcUFNeUJ2VmpXWmx2MnBka0Nhcm85ZVdETEs1STRtYmI4RTRkN2hacjlkREppVEptNkJtYjVTKzJGN3lhbC9KUGRlTFVmd3E3am1WTGFRZmh2NHRXTUpBdDdWNHNHOUx1QXYyb1BKZ1NqMW5ubEJ2UGliZkhNMlRybFdId0dDTEd4Vy81Sm0yVG90YURMK3BIRE01cG4xcjBVdVRaMjROOFM1azY4YkxIVzl0ZkQrMms0ekdldjIzRXhKYjRZVFJLV3JqODJONUxqSjI2bGoxQmtHWjBDc1hMR0dFTG9QYVlRb21qVHFQeFlxaGZ3T3dEbGlOR1ZxdXg5ZmZ1eWJxT0tnc2JCNTFCMUdiWmZHOHZIREJFMkpRR2liMW1uQ21XT1dBTUpjSE4wY0tlREhZVGZsYkRUVlhhanRyNjhtd2ZSamU2V3VlUS82eVdxbVpNTFdOSDdQMjd6R0ZoTUZxYXFmZzExUTg4Zy85VUEvRlJPZTl5ZnEweU9PMHBuTkF4dmVwRnkyQnBFYmNnRyttQ3lqQ0MwMUpXbE9abElQZGYxVHRseU90N0w5NFRvWUdDdWtvRnQ0T3F3T3JvZmFtakVDcFNnS0xMbXJSTStzTlJBdzEyZWFxazhLdGRGazdwbjJJY0RRaVBYQ2gxNnQxYStwc2krdzl0b3dIVEtQeVFNMFN0S3I2MWIyQm5OMUhVK2FlekZOQkxmSFRpWHdoR1RiZHhMTG1yc0FHSVZTaU5BZUNHRThHbEIwaU92MnY3OGtQMENUbUFQVUVxbkhZUlNEbFArTDZtL3JZakVLNlE4NUdSREppMlcyMC83TkxQcFNPYU1SKytJRnZwa2N3UnVjNTlqOGhoOXRZbGMxeGpkdDJqbXA5S0pjekI3VTlQNDNpbnV4TE92MTFQNS9IWUg1ZDZnTEIwQ3NiR0M4QVBqaCtFY0NQMHpGV3FsYUFDWndlTGhWZnYzeWl5ZDhSM2JkVmc4c1JLc3hQdmhEYVBwaUZwOStNTiswVWEwYnNQcitsaHhmWmhNaGxldmtMYlI0WnZjU1JQNkFwUUx5MytlTWg5ZWhDQjN6NURWQWFOM1A2SjhwaTVRYTg4WlFzT3VDVFd5SDZxOHlNZkJ3OHk4bm02amFPeEpoUEg2SGYwSTRqbUFMVUJzV0tINGdXQm55aWpIaDd6My8xSGhRekZMUkRScklRd1V0dTExeWs3VTBnRHcvRmF0T0laT0phQngzVXFiVXhTWjZkYm9GUG01cEF5eVhDMndZZFNXbHBaeC9EMkM2aERPMnNKTTRIVDlJS1dXbURrWklPMnNpLzZCS0hydVhJRURwZkF0ejN4RGxJZEtubmxxbmtmQ3l5NnZOT1B5dW9Xc1NXQmVpTjBtY2ZJcm5PdHAyajdieGpPa3IyNXNrZlMvbHdPQzY5MmNFcDdUS1NseW1ic3l6b1dnLzBBTjY2U3ZRWW82QnFwTndQcFRhVXUyNXpNV2x3VlVkZnUxRUVkYzBPMDZUSTBKbUhrNGY2R1pRYmZPcy8vT2RndEdQTzZ1TG9hZEp5Y1I4WjgwcmtkODhRb05taW1aZDh2Y3BRS1NjQ0ZreEgxUk1Ua1BsTjNLN0NML05TTU9pWEV2eHJuOVZ5VVBGZWU2M3VSZmxnYVBNU3NhZnZxTWd6VHQzVDFSYUhOTExGYXRRYkQwVmhhNFlYWi82QWtlN29uTTY1bkM5Y3lMa3RlWWtEZkhvSnRlZjd3Q3JXWFRLMCt2SDM4VlVCY0ZKUDArdVVYcGtpSzBnRFhOQTM5SEwvcWRWY2FPQTE2a2QyZ3pxOGFIcE5TYUt0Z01MSkM2ZmRMTFMvSS80bFVXVjIrZGpZOVJjM1F1Sk9VcmxIRlFFUnRYTjR4SmFBSFpFUkNVUVo5TkQycEV0Wmc4ZHNuaWxjbnFtcVluM2Mxc1J5SzB6aUtwSE55dEV5aTJnbXp4RUZjaHZUMXVCV3haVWlra0FsV3V5cXZ2aHRlU0c5a0ZoVExOTTk3czNYMWlTMlViRTZjdkFwZ2JtZUovS3F0UDBOTlQzYlppRzlUVVJJbkNadFZzTlp6WXVzNk9uMHdjZE1sVmZxbzhYTGhUNW9qYU9rNER0Q3llb1FrQnQxbWY1bHVGTmFMRmpJLzFjblBlZnlDUXdjcTVpYS80cE40TkIreEUvM1NFUHNsaUp5cFM5NjRTSTZvNWZEVmEwSUVSUjhEb2VRKzFpeVJMVTFxR1lleEI2MXBoNHBrRzFyZjNjMllENkJ5MXBGQ213dzlCMHIyVmpGZWF1YmtJZGdXeDRSS0xRUlBMRU5kR284ZXpJNW1rTnRkQ3dzMTlhUDF1SGhlbkQrSEthOEdEZUx1bGIyZmlNUmhVMnhKenp6OWU0eU9NUHZFbkdFZmJDaVExN25VRHBjRkRXdGhyNjhtaFo0V2lIVWtScGFWV0pORXh1VUxjR2t1eVZMc1FqNTlwZjZPSEZSN3RvZmh5OUZNcldQQ0V2WDFkNXNDVkp0OHlCRmlCNk5vT3V3TXk0d2xzbzlJMkc0RTUvNUIyYzZ2SVpVVVk5ZkZ1alQzaHBrZFR1VmhiaEJ3TEN0bmxJakJwTjRjcSt3YVowd1hTcm1lYmNsK2RjcmI3c1BoOWpLeEZJTmtTY0RUQmdqU1VmTGtDM2h1SkpzL000TThBT0Z4YmJTSVZwQlVhcllGbUxwR3N2K1Y2VEpuV05Ud0k0MXR1YndvN1FTSTFWT2RSS1QvUHA4VTNvSzJjaURiZXVXbkFHQUFOdlFqR2ZjZXdkQWRvNkg4M1h6cWxLLzR5dWR0RkhKU3Y5WStxSnNrd25WVG9IMUkwK3RKM3ZzTEJYdGx2TXpMSXhVai84TGNxWm5yTkhmVlJnYWJGTlhXMHFwVXZEZ3huUDNmNTRLb29SM05JKzJRL1ZIQVlGaWdNa1FFNWRMSDZDNmZHcy9US2VFNkUyak9oWlFjUDkvcnJKakpLY0xZZG41Y3c2WExDVWU5RjdxdWs1WWhhYytuWUw1SE9YdnA2US81cWJpUUhrdWViYW5YNzdZU054MzRZYVdZcGNFSHVZMXUvbEVWVENRN3RhUGF3M29OY24vcUpoTXpHUFpVczNYQXE0OHdqL2hDSU8yZDVhRmRmWG5TMHlnNTcvanh6REpCd2tkT2dlVm55eWgxOUl6MVVxaXlzVDRKMWVlS3dVdVdFWWxuMjN5ZHRQN2czUjFCbnZueHFGUEFuT01nT0lvcDJka1hQZlVoLzlaS1YzWlFiWk5hY3RQRDRxbDVRZzlDeFNCbkl3emxqL3RzZVFLV1JzdHdOYmYxN25lR3dERkZXZG0vOGYrbkRXdC9XbEtWM01VaUFtM2NpNnhYTURTTDV1YlBYQmcvZ0tFRTdUc1pWR1VjckliZFhJTGNNbmd2R3M3dW52bFBKaDZvYWRlQkRxaUF2aUlaL2l5aVVNZFFaQXVmL1lCQVkwVlAxaGNnSW51V29LYngzMUFPanlUTjJPT0hybHRoQjNueTlKS0hPQWM4Qk12cW9waWtQbGRjd0lRb0Z4VGNjS0tJZUk4MTVHY3dhS0RMc01iQ3N4ZWdyelhsOEUwYnBpYy94ZmZVOXkxRENnZUtab0YyUElZNzdSSW42a1NSZEJpR2Q4TnROd1Q3NGR5ZUZCTWtZcmFQa3VkTjI2eDlOUHVCdDRpQ09BbkJGYU5TS1ZnS2laUXJ1dzIya00xZmdCS0c3Y1BZQXhkSEo4TTRWL2p6Qm4yakVKZytqay9qalY0b01tTU5PcEtCNW9WcFZoN3RLNTI5Wis1dktaME5TWTJBNFlkY1QweDRCZGtvTkVEcnBzVG1la1NUanZ4OVpCaVRIcm05TS9uL2hHbWdwano0V0VqdHRSZkFFeTVEWUg1dkNLLzlHdVZQYTRob0FwRmFObHJGRC9uMlBwS093MjRpS3VqS2hWSXo0MXAxRTBId3NDZC9jMTdPQTBIMFJqWmkxVi9yakpMZXhVenBtWFRNSU11emFPQmJVNGR4dlFNZ3l2eEp2UjZEeUYzQmFIa2FxVDRQM0ZSWWxtK3poOEVFR2dta05xRDFXUlV1YkRXNjJWcUxvSDhVRWVsSXBMN0M4Q2d1V1dHR0NBSURQbWE5Ym5oKzdJSlN0MENuNkFDRVIybVlrOGRMc3JONzBSVVZMaUUwaWcrMDh5UFk5SU90dXFIZi9LWXNUODRCd2hNY1ZxN3Q4cTFXVmpwSkdOeVhkdElQSWpoQXphYnRyWDAzSXRuMjlRTzNUQ2l4RTlXcGtISU9kQW9HdnFDcncxRDN4OWc5UHg4dTB5Wlp1dWxadUd5MHZlU1kzNEtEU2xoc08xengyWk1ycERCekNIUEI0bml3QXBrNk5ldkl2bUJ4VTMrNHlhZXdEdmdFUURKNk9mNWlSeGpBSXBwOVVPOEV6Tlk0YmxqNHFoOFNDU1pUcWJlL2xTaEU2dE5VOVk1SW9XSGVKeFBjSEY5S3dZUUQ3bEZjSXBjc2NIcmNma0hKZkwybEwxemN6S3l3RUY3QndralhFaXJnQmN2TldheWF0cWRUVlQ1b0xielRtRUQzRU9ZQlNYRnliMlZJWWszdDBkT1pXSmRHMW5QK1c3UWZ5ZWI4TVNJeVVHS0VBNTdwdFB4clBIS1lHWlBIc3VCcVF1VlNybjBpOEtKWCtybHpBcW84QWF3Y2hzSjI2RmNreFRmNStqb1RjdysyeThjOGJ1c2hwUllFYmdyZHI2NGx0RVlQVjJBYlZnS1hWM1hBQ29EMWdiczAxQ0V4YkpBTGt1SXRqZllOMys2SThrYmlUWW1kekJMYU5DK3h1OXovZVhjUlFWMUxvOGNKb1NzS3lXSlB1VG5jdTV2Y21mTVVBV211d2hqeW1LMXJoWVI4cFFNWE5RZzlYKzVoYTVmRW5hcCtMaFVMMWQ1U1VSWno5ckdkT1dMaHJNY01LU2FVM0xoT1EvNmE2cVNDd2d6UXhDVzJnRnM1M2ZwdmZXeGhIK3hESGRLUlY2dzI5blE2ck5xZDlieSt6bTFPcHpZeUp3dkZ5T2tyVlhRVXd0NEhhYXBud2VDYTdUajJNcC90VDRZY1kzUS90azFjemdremxWNW1wRHJkcDFzcE9ZQjhpb25Bd3h1ampkaGo1eTlxRUh1MHVjMzZQQUtBWXNLTGFFb2l3UG5vYjBwZGx1UFdkdjRzTlNsRzhHV1ZpSSt4L1o0RGtXL2tTczJpRTNBREZqZzRUQ3ZnQ2JYM3YwSHowS1prZXJycHpFSXVrQXVzaWREczJnL3cwemdtTG5aWHZWcjVra3B3UVRMWjBMNnVhVEhsMExWaWtJdU5JVlBtTDNmT1FKcUlkZnp5bVVOMHp1Y0lyRGludEJuNklDbC9pbmo1enRlSVN2NWhFTUdNcXRIYzJnaGNGSnZtSDNaaElaaTM0dnFxVEZDYjlwbHRUWXo1ODJZM2R3WWFIYjlraGRmdmUxWXJ5ekV3RUtiSThxbTYycXYrTnlsbEMrV3hMTEFKanowWmFFRjJhVG4zNXFlRm1rYlA2TERZY2J3cVd4QTBXS3N0ZUI3dnk4YlJIRTRyOExodWJXRGMwcGJlOTBYY2tTRERBa1JlajBUUWxtV3NXd2F6MThUeDJwaHlrVnZ3dUlSemY0a3Q5c3JUOE43Z3NNak1zME5MQUFsZGFiRmYydGlNb2FheEhjWlNYNTFXUGMxQnJ3QXBNeGloMjI3cVRaa2NndGtkSzFoMzE0WHZaS1VLaC9YeXNXWW5rMVNUNGtpQkkxQjlPbGZUakIzV0h6VEFSZUZMb2ZzR3Rpa3dwSVh6UUJjL2dPanoyVGhsajM2V04wc3h5ZjRSbUFGdHJZdDY0ZndtK1RoamJobG1VVFp6ZWJMbDR5QWtBcXpKU2ZqUEJaUzJIL0l2a2tUVWRWaDBxZEI2RXVpSEVqRWlsNWxrOUJUUHp4bW9XNEp4NTQzaGl5eTRBU2RZQTJETm9wcnNSOWl3R0Z3RkczRjJ2SVJPeTRMNUNacmwyMzArazczM0p3Ym9TTkJLbmdzYUZQdHFvK3EzbUZGU2pDMWswa0lBRm1LaWhhWVN3YVNGN2tvbm1ZSFpXbWNodWFxMTVUcG5lQTJBRFNSdkEwN0k3VVMwbFRPT2ZLcmd4aHpSbDB1SmloY0VaaGhZV3hPYmp2TlRKLzVzUjRBYTV3T1FoR0NsR0xiNzQ2Y0poUTJFNkppZTFoYkdnV3hVSDdZU0tFVHB0clRlUi94ZmNNTmsyV00xMlMwWEVsQzlrbFI4TzdqTFlla0VPWmRzY1AweXBTZG9DVlpBb0srMmp1MlBIRTg2OVE5cnhDczlEVlFjbzRCcmlpUGJDak4vOHRCanNhaDRJdWJvUjVRYm1ieURwY2RYVnhHTXh2V0tJam9jQnVLYmpiK0I0SHZrdW5iRzB3WDBJRkNqUUtvTk1GSUtjSlNKWHRrUDNFTytKMTZ1aDRpbWcwTFFsQkFPWXdCTHVwdTVyMU5BTE1vMGczeGtkOWI0ZjdLb0NCV0hleWsyNEZtWVVDeS9QR0x2MHhFck9UeU9ScDhUSjVubmMyazFkT1ZCVEpvazdpSHllOWR3eHdSVlAzYzdlQVM4cE1tSllIR3B6SUh6NmlpMldKbThITVRQQVpkQTRxK3VnajNQTkNML040NWt5Z2xxdlFWNGYvK3J5RERHNVJQeTVIVm9WOUZWdUpjcTJkeEY5WTBoZVZvaXBWNnExTHlmQWV1TXpic1VWK3JzU0JtQ1NWKzFDZEtseHkwVDBZNk9tMFg2NzAxVVJtMk1sNkRJUWdKLzNLTzZrd2NNWVJybUtzWTdUZnhXaFNYWmxsKzFQZnlSWGU5SFMwdDFJS1RRTVpMN1pxUThEL28rZW41N1k5WEFROUMra1pZeWtOcjB4T014RXd1MitDcHBtNjltUXlUbTNIN1FYNmtIdlhGMjAxcitLVkFmMzU0cXlwSkM1T0hTZUJVNDdiTTFiVGFWbWRWRVdRKzlDY3Z2SGR1OFVlNVVuZEhNK0VldWttUjgydm9RcGV0WjdXSmp5WHMrdFBTNjBuazA5Z3ltdU9Sb0hOdGJtMFZ1dnlpZ2lFdk9zeUhpUkJXN1Y2RnlUQ3BwTFBFSHZlc2FuOTFTbEVoMS9RRXVucStxZ1JFRlhCeUR3TktjQUg1czgvUkZnOGhQNHdjUG1GcVgweFhHU0tZMDg3YnFSTHNCWmU1MmpUaHgwWExraEtRVVdQdkkxOFdRUVMzZzJSYTFwelExb05GS2RmSkpqeWFINXRKSDZ3MC91cEpvYndCOEtaNWNJczlMblZHeGZCYUhYQmZ2TGtOcGFiN2RwVTZUZGNiQkljK0E0YnFYRS9YdDgveHNHUU9kb1hyYTRVczVuREFNNnYyQk5CUWFHTW1nTWZRUVYraWtUdGVTSHZ5bDh3VXhVTGlZUklFS2FpRHhwQkpueWY5T29xUWRaVko4YWhxT3Z1d3FxNW1uRFVBVXpVci9MdnMxd0x1MkYrcjRlWk1mSlBMNGdWNW1LTGtJVG1velJuVHZBN1ZBQmF4Wm1GUnRraHZVNWlIOVJRMXoyNmt1N2FBQm9rdnB0eDdSS1pCVkw2ZHZlTEtPemcwTkM3SEF4Y2c1a0Uxd3V5SmlFUUxPcE8wbWEzQXRXRDJRMldtbjJvUFplRFlBd1Z5RXB4dXdEeTdpdm1kVURTTDk1b2wzaDJKQnlUTW92T0NneFoxcTRFNW53d2E3KzRXdERBc2U2YkRkcjI3WGdBaTVQeDNJV2J5Wi92UmlFQ0t3T01lSlN1SWw4QTREczBlbUkzU2dLVlZXVk81dXlpRVVFVCt1Y0VxMGNhc0ErRFF5aHpSYzhqK1BsbzBweEt5bkIvdDB1WG9kMUZWVjRmWDFzQzRrRGZ3RmFVREdRNHA5SFlnYU1xSVdYM09GL1M4K3ZjUjBKUzBiRGFwV0tKd0FJSVFpUlV6dmg1WXd0emtqY2NiYnJUOUt5L3F0NVg3TUFHQTBsemg0M21ERjlFQjZsQ0d1Ty9hRkNNaGRPcU5yeXZkNzNLZEpOeTNteHRUOEFxZ21HNHhxN2VFMWpLdTZyVjBnOFVHeU1hdHp5SU1qaU9DZjRsSUpGekFmd0RiSWZDNzJUSi9USytjR3NMUjhibHBqbEVJTGpEOE14cjdJZmZoYkZoZ28xMkN6WFJRMk84SnFCSjcwK3QxMjM4NXRTbUZDOE9yK1U4c3ZPYW9Hb29qVDEvRW1qUk1UN3gyaVRVWjdOeTAyVkdlTVpUdEd5MDI5dEdOMS85azd4M21GdTYzbFluYVdqZkpUMW0xenBXTzNIU1hwR2tGcVZkL20za0RNdjRYOXJtTE9wd0VldThyNlRJNkMyelVHK01UNnY5ME9VM3k1aEtxTGhweUZMR3RrWmhEbVVnL1cxSkdTbUE4TjFUYXBSNEtueStQNitEdU1hZFo5K3hCYnYwNm5mT2pNd2tvVHNqRzB6Rm1OYnZseEVqdytQbDVRWUsrVjhReWIrbmtuWjBOYi9PZmk5K1YwZW9OdFRydEQxLzB3elVHR0c1dTJEL0oxb3VPL1BqWEZKVng2THVyVm5QT3lGVmJaeDdzM1pTalNxKzdZTjN3elRiRmJVdlA4R0JoN2NLaWVKdDU2U0lvd1EySTU3NytVRVhyeFVLTUZPK1hhTExDQUx1aUpXQjJ2VWRwc1Qra1ErYWRvZVRmd091bFhoZC9LWjd5Z2pqNlBodkdUMXh6ZlQ3aFR3ZDZkelNCNHhWNzBDZXNIQzBkc2cyVnl1amxNR0JLamc1c25ickhIWC9MTmozU3NvTEdTWCtiWk5URERDTlRYaCtkQ1ZQbGo0SzgraEova1ZkZHJidFp3MjZIeDVxWWl2M29OTmc1YmxIUlNQdG1vamhabUJRQXo4c0xDOW5BdVdOU3oxZElvZkZ0bHJ5RUtrbGJka2hCQ2N4NWRoajdwaW5YRE5sQ2VhdENlVENFallDcFozSFJmNVF6VWNSUjFUZGIzZ3d0WXRwUGRnTXhtV2ZKR29aU3UxRXNDSmJJaFMxNkVkOTcrOGJyNEFyMW1CMUdjblpWeC9IUHRKbDRDZ2JIWHJyRFB3bEU0b2Q4ZGVSUVlMdDlJbHN2Q3FnZXNNbUxBVnhCK2lnSDdXR1RjWS9lM2xMSEo0cmtCZ2gycDFRcFVCUmIvY1NRc0pDYm9zRkRrYWxiSmlnaW1sZFZLN1RJSEtTcTJ3OG1lemt1OWhndzhmWEp4R2RYb0wxZ2dtYTUya1h6alA3OGwwZDB6TXd0VFZsdDBGcW5SeUdMUEdFam1JQ3pnU3A3WFBGbFVyN0FlTWNsUTRvcHF3QkZJbnppTTVGOG9KSjhxZXVja0dPbkFjWlpPTGwxK1poR0YxN3BmSXV1amlwd0ZKTDdDaElJQjJ2bG8wSVFaR1RKUE5hMllqTmNHVXcrYS9nV1lMa0NwK2JPR0lZaFdyMDhVSUU3MDlaRUhsVW9FYnVtemdwSnYxRDAraFdZTkVwaitsYW9aSUs1d2VPMkRGd0xMNlVCWU5yWFRtOVl2dnhlTjlVOW9Lc0IzektCd3pGRndEZ2lkNUVTTWh5Njh4Qm5WYTU1c0NaZCtsNUFuelQ4ZXRZakl3Ri9CR3dFeDFqanpGdjMyYms2RWVKdWxFU0FSaDhSWjQ4bzdyS3c2N1VacHVkUGExNVNEbkw4QUw4eE1WMlNDMEQxUDUzcDE5MHpoQ0ZrTW1FaWlyMm9sd3hjSnBwbC9rTG02LzBRU1VRTE5heGkxQUMzUGcxQ1Rvc1gyWVFyNzNQakVJeElsZzRtSjYydlA3WnlvSEU1NUIwU1g5WXJyckNQdE5zckpFd3RuNktPU3Q3bkxUM24zRExKVFBiTHVsY3FRMWtFVFA2SHV0czI5b1ArSkxFcVJHV2ducnFNRCttaENsMVhDWmlmamdRMzlBZXVkRThweXUyRHFuWVUzUHlQYkpoU3RxMUhiUCtWeGdzZVdMK2hRKzR3MW9rQURsQTlXcW9hUnVvUzdJWTc3Q200MGNKaUU2RkxvbVVNbHRUK3hPM1VwY3Y1ZHpTaDlGNTdob2RTQm5NSHVrY0gxa2Q5dHFscHByQlEvSWo5RSt3TVFYclpHNVBsendZSjZqbVJkblF0Umo2NHdDLzd2c0RhYU1GdGVCT1VEUjRlYlJyTlpKSGh3bE5FSzlCejNrN2pxT1Y1S0pwTDc0cDJzUW5kN3ZMRTM3NEp6K0c3SDNSVWJYMTdTb2JZT2U5d0trTC9KYS96ZWlLRXhPQm1QbzBYMjliVVJRTXhKa040ZGRickhuT2tuNitNMXpUWkhvMGVmc0IyM1dTU3NCeWZteWUyWnVURVoxMkozWThmZlQ2RmN2OFhWZkEvaytwK3hKR3JlS0hKUlZVSUJxZkVJbFJ0OTg3L1FYa3NzWHV2TGtFQ1NwVkVCcytnRTFtZUI2WG4xUldJU0c2c1YzK0tPVmppRTl3R2RSSFM4cm1URVJSbmswbUROVS8ra09RWU4vNmpkZXEwSUhlaDljNnhsU05JQ285T2NYMU1tQWlFdXZHYXk0M3hDWmd4SGVacUQ3ZXRaTWlnb0pJNVYycTd4RGNYY1BvcnQ3QUVqTHdXbEVmNG91enkyaVBhM2x4cGNKV2RJY0hqaExaZjF6Zy9LdjMveU4xdm9PbUNMckkxRmUwTXVGYkIwVEZTVXQrdDRXcWUyTWoxbzJLUzBURlFQR1JsRm0yNkl2VlA5T1hLSVFramZ1ZVJ0TVBvcUxmVmdEaHBsS3ZXV0pBNjczKzUyRmdFRWdtK0h3RWd6T2phVHVCejYzOVh0Q1R3YVFML0RyQ2VSZFh1bjBWVTNIRG1ObVRrYzZZck5SNnRUVlduYnFId3lrU0Jzd2NoRkxudm91UjBLUmhEaFppVFlZWU5XZHZYelkrNjFKejVJQmNUSmF2R1hyOUJjSGRrLzN0cWFMYndDYmZwd2p4Q0ZTVXMxeGZGY1J6UmZNQWwrUVl1Q3BzWUd6OUgwMXBvYzFMeXpoWHdtT0RtVVNnL3hGcS9Sb3NnWWlrejRPbS9uaTlRQ2NyMjhaUElTYUtyWTdPK0NzcE0vcytzSHRuQTlvOVdnRldoY0JYMkxETjIvQUw1dUI2VXhML1JhQnA3RUkrSkhHejZNZUxmdlNOSm5CZ0k5VEhGZFV3bWcxQVhiOXB2ZDdjY0xxUmRtY0hMUlQxSTJWdUVBZ2hCZHVCbTdwSE5yWklqYjJVVnJpanBaUGxHTDY4aHIrU0RsQzMxbWRpczBCalA0YVpGRU9jdyt1QjE3eTV1N1dPbmhvNjBWY3k3Z1JyN0JaOXo1elkxdUl3byt0VzFZS3B1UXBkUjBWaTdBeEttYUlhNGpYVGpVaDdNUmxOTTBXL1V0L0NTRDdhdEZkNHNvTXNYN1FiY3JVWlphV3VOMEtPVkNMOUUwOVVjSmxYK2VzV0s1Nm1yZS9zNlVPOWtzMG93UStmb2FWb3BrdUtHK0haWWJFMUwxZTBWd1kySjUzYUNwd0M3N0hxdHB5TnRvSWxCVnpPUHRGdnpCcERWOVRqaVAzQ2NUVEdxTEtoK203dXJIdnRIU0IvK2NHdVJrNFNzVG1hOXNQQ1ZKMTlVUHZhQXY1V0I4dTU3bE5lVWV3d0twWG1tS201WFpWOTErRnFDQ1Q2blZycnJPZ1hmWW1HRmxWanFzU24zL3l1ZmtHSWR0bWREMHlWQmNZRlIzaER4NDNlM0U0aXVpRXRQM01lOWdjc0JxdmVRZEtvaktSLy9xRDJuRURZMElrdE1nRnZIK1NxVldpOW1Bb3J5bTkyTkVHYlk4TWVEanA1NTNNaVRYQ1JTQVNQdCtHYTVxN3BCOXZ3RlFDVHBhb2V2eDB5RWZycTlyTXMzZVU2d2NsQk1KOVZlOG02UXVMWVo1OEo0MVlHM2pXL2toVzkyaDZNL3ZiRklVUHVvcFo2VlZ0cGNpZXNVNzRFZjdpYzhpU3ltRG9oR2VVbjR1YlQwdlJzWG1ic2phSmFZaEw4Zis4STVFaUQ1bDY4ME1KYnhYLzRHWXJPZzRpUFFxcEtwMHFkZFN1L0hLdHpuSGVWeXhnVHdoZkVPUk1Dd25hcWV0VlN6dmlkYVdOOVArZlh0R1hmRVA5Y1Rkd3gyZ0tWZkRkSUNxN2hlY2dSaElzMHFsQ3Q2KzVwR2xDYzZrV29wbEhhL0tqUCtGSmRYQlUvSURvS014UmpGaFNZa2dnSWtodlJLaU4vYjJ1ZDhVUlBGK2xCODdBR0F3eU1qci9XanUyVWo1SXJwcFhaV2pJM2QxNEJkS0UyZmhBTHlRUG1IcXFBK0FYZDJMd3ZSSGNCcTRtaE9RNG9OUldIN3dwemM2UGdnZmNidjlrcWhMeHJKS0VhSnFBNlJ4aStURE5PSnN0ZDVEb1JWQ0RqbVZzcENWeUhKc0ZFV1BnOStOQThsMWU0WDJQRHZPZDVNUFpBR3c2TFJoV3FlWm9TUWNQZjkvZEdKWUF5ekNtdHRsUm54MEJmcktRL0c5aTVEVkpmdDlmdUp3TWkzT0QvMER2MWJSb3hjWEF5WjB3TUo2cndrOVJqUlRGNFpLOEp2aUNDTnVWdC9CcVFZaXBoT3pXQ3BuYndPWnQ2cVh1aUFhYlFXclM0bU5YUTdjRUVyWFIveUpjYmRGcDVuV0UxYlBCakQwZm1HM292TXhtT3E1YmxwY09zMER0TlFwY2kxdCs5REtFUldBTzUzSVZWL1M0eWhNa2x2SXAwajBGSVFnd2pkVXB0cW1vTVlHVldTSTVZa1RLTEhaZFhSRHY5enMrSGRGWnQxUVZjZGxHT2dBVHJvM2ZnNnRpY0NyRFFLVUpDN2JZWDUwd2R2ZXRpbEV3VmVuSGhscjg1SE1MUkxURDZuRFhXSWQ0T1JMd3dlNUlYaU9ocHVaVFZUdit4ZGtUeEpvZnFlQ1JNL2pjWnFRbFUwZ0ZWVGxZbGZ3TWk2SEtSMllHNGZROFRPdGdSK3lWK0JNWmI2TDVPd0RjLzI4L3hkZkQ3R1hGYVZBMlpTT2JpSXhCd1QyWmV2NjM3RXV2cE02cnhjb2dkTTRGSkZhMFpoRjducnF0TnNxV2c1TTdoWk1PUnBqZDRzemYvd1MrQWhzMXNoWTU0Q3Q1SjFkT0JPNHNkRXRTblJjMFA5UGhneU9DdDZhUVc5OFIyMkRwQWNOVERlNzJBSEs0MHZ1dEtUUGZwb2tnaFJQdUd2ejBkdWxCUEtmQzNPNEtWREN5V3JKR083SWtkdTA2QTBrZUtsVmZpMHRHY3BPME5oelhFaDc1Tkh5TXlzQU1WMTlmcTcvL3NQQzBGb3IxazJ1RkV2cThsd3JNQWZtUDdhZlI2OVUyUnFhSUxIZTdnbHBjOEhtVmY4N1FiMm9oc3crRGk5VStlUGRITGVjUzY2TWhCLzBPd2RjWFI1V0JjV1RaTEdxL2tpQWFUK2J6a2pSOEdJcFdkdjZwZklnUStRMHhkaUt2bytnTkI3L05mOWtuTkpHeG5oN0xlWkVGdE1uNTE3dE5jNzRQUFMwTTRLM0k2SEhacU5QQStWWmNCYy9nNWEyQVJ5cUtySjRaM2tyc3VBK1ZPSkp6MktKcEJNZ0NDV0ZsbjN1N2s2L3EzREVUQXViS0cvcHQzT2JhTlQwTkkwUXVnOTBMMmlwNWRIblpKVWpQVHZLNUU5NmFYLzRtUlUydThuOGtoNk1LYlk3QU5Ccm8zaHVGMDZVK0p2ZnlFTFFQMjVvSWFqK24wSVRRNEtUOXJYWkQ0RXRCSU9qOTVmWU5sZEROM2lvL1ZNSXZXTmo5UC9iOTVXRU1xOFVBVmZHMlhHME42ZlNZZG5CRUM3c1VFYmF0YkRJQ0g5cUE4VFR1VzlrRXQ5RGxGT1pGUDdiZGZZTGEva2hTWThXNUsvQWtJSUFQWHRNdnlWS3lFU2pLeDluZnJhZ3NzeEMwakZNVlk5NGQ4bE9Bd1JvY2RTL2wvUDQzY0JHYTNJcURhMGloR1BjbXdTOE84VmoxNlV5NTVyT3JuTjBzaGhSSlpkVzhJN0YwUTBLZUhjMzVHRm80YUpPRmMyNWdOYWZCdTFWL1ZPMHFTNFFrYjZ3alJybmxlcFVXanRZeWFEQUJaY2VWYWx1T010b0RkZUlJVFdLT0ppd0dQcEIxMmxRZ3drbVhoOU04NnBvZGIwRDExN21OUThFbGx1RnZiYVM4UlRLUTZseWo4OGRVd29KVS9vZk9ldWJob1hXQkY4ZU51bWtWSnUrQXMzRUQvQXZMbHJWOTFVb3dJV0kybThIQkcrYTNrMjQ3WktBR1lzT2NXZTdmVFdxTDhlcXdNNVpGdW9YYmV1Z1BLdU1PQXRPc04rNGRTd2toclNBbGZHTlR6RndFbUNOV3R6cGE5Q2dQYllOY21vSHRPOHBqOHFNdmxHRVQ2bnJrSm9RMmxwNU1FVVYxRTJBNFpINzBKVWxDTFh2cVRJcFpsenl4ZHI1cC9HWmlEMS9CdUZPR2J5ZkZ6aHV4YUMvbDNsQzJqanQ2R05SQmEwNkFxcVBsWXRkQTdraWlkWWE1UWkwL1hwWGlNRHlNWE5PajNrbUpFYVh1ZlcwR084K0RGOE9vTVVMWDF2dmpDZVBLTmlzNEFteFFLTENGK2NqZi93eWlsQ0p2dWl5TFZQU2RzdVJUUFowQWhwZERGLzF1Rm1Ed0c3aVAzcVl3TnNLenFkM3NZZG5Nb2xDT3VRT0lIV3kxZVFwV2h1VitqbVNlQUM1ekNjMC9Lc09JWGtaUGRpdzh2dEIzM2pFQnBlenBHREJQNEpMWTJ3SDFKN0Z6cDh5OFJJQ3FWZDI1bURUMnREYi9MMW1oNGZ2OVRPZkRINWRUZUFUcXUrZGlPWmkrL3NJdDE4aGlUb3ZQc1ZRVmFxWExQUngvNFIvdUgvODZ0Qk1jRitXQmtUaEtMZmJsY1ZDSUVDYzhEZ05SVlg5N0tkcnNDZUlLK0N2SlpNZndyZnRjRFpEWnlwN0c4SGVLbDdiUFluVEtYODhkWEF3QXl6NjZPMmNoa1BESHkvMksyWGNULzYxWG5sQUtnUHd0STh5UDlWdTQ1eWg1NUtIaEp1OTNtTDRuZm84c3pwL0l5RGptRkh0U01xcW9Xc2o4V2FWaGJqWGd6WnhjcVpjeU9lN3BVSzZhWEYvWTMyTG5CT3QwV04yOFVtSFJpT3BMNTI1QzYzSTJKUVBYOHZ2T1UwZnoyaWo3NE9lSjFBcGd1M0pST2JmZG85eEdEcHA3Y3YzVGRVTEVmTlM2R3UzRUp1N2RyQnNCc29nVXFVYzZ3QVVXM3V4MC8xaExWSS9KRUtKckFHbThnNzJDMmFKU3NHQXNLRlc0Q0J2QlhWbE5JS2E1cjdIdlQxQmVHWUJmeFRSMXZoTmxGRk5OOFdRWXdyMzl5VC8xM1h6UkdpRjJJc2ZFOEhjTjArbE4xek4vT256ZWtWQktrRlkxMUdncks1Q0x4ckUvMkhDRU13UWI5eU91UDJyVFhpWnpURUVUcC9pc21GR2NUV21iTTlHMVNuMkQveDNHNzR1V1laWTRyZ0tCMlpvMmJUS1M2UW5NNXgxWWVlNjZZMUw3SzQ0QXlpWTVLMk1INXdyVHd4TUZoK1M4THpOUTI1ejZzdW5XWnlpUndGSUl2U25pb2x0VVhOaU9yK1hNWjZPOWg5SGNIeFpKa2ZGMHRVbTZRa1U3aUoyb3pYQVJpdGlMODZhcVZzTU9wbXZkSUJST2hVb2FuUHRDamdmdDh1cDNoQWFLcHc5UXM5TXpZdEJBMmlqSFhvdHphcmtWM3pLRUswZEZGUVV3VDc0TmdDbUdHdVNDRURtRkNlelhQQzlCaHlHaG16TmE2clFlUVF6K3I5Q21HVVpqSVFFUHNId2U4Nm9DT1FoV2FIRVJzdjVpYTlyWnZKLy83VVhPN0IzMjlZVWtMTEFpcXBMUnNWVjVYcGNmZGF3bEpxaS9CVmNDcU82ZHI5WUpURkZSTVZHaGZVYkI5WVdOdllQWTZSeWF5ZEFGWXExWUlCUXh1TkFHZllXTE1BSHR0MlhSSG9PS0NMeitxZjVIQ1ZCRE9QT2t0UTNTZEpCZnhVa2FpRDU4NWJtVHpNd1Uzb2VYVUhaNTVFQzk5S3o5a2s0WlhNSUVOd1ZWcHFXMkptR0ljVWl1dElNajJLa3BqRTJRRCtkSVpVQ3hjWDU3a0g3aGl1VVBuS0NUZGF3NEtOOTVYUGVGUnZNY3ZvNUw4TGV4V3F2YUpQRUN6d1hDcy80WFBBbFNNcFdVekJCakszcEVua2J1ZU1rTUpRclljblhmN1BqYkFvSnJhMVZMWDRZdXNjUUxwYWVZV2JUK2gyNGhDRnJmY0hqeHh4NldUU2U0QUdZL0tIUlpDUUtxVHVGV3QwRDhSbUdXbXZYU2RnMXB0SWVmWVBzaHVJVlpUN0NWNE55NjdmdmpKdWd5MFROWUhxb0NPNDVDQjg4a3hydklzaWgxOURxakQwVXFpSnNURlBjR1czUC9VTE9HM25iOENqcGdWVElvYTVuTzlaWUVYNHVFSHU4aExYckpQalYxbFRRNXhUZFpWYWdnK1dqOFYwRUU0eVBzVGMzNDVLTTZsVlhxTGlIdG0rRzZlZEM0R1ZFaVBnZDk4Zyt0d1NZbTE4Z0NzUG5qcWxMY0ZtOWU3MkNMSmJZRCtvY0laT3h1VmpyWDZJS2g5Zmg3V3FkSVo2Nng5UFdrREdPVlZHa3g3ak03Nll3ZTE2RFg5bmcyMDVrZzVlcStSMnEyTWd1VEp4WXYvd1dIbGlEOW1PWXB6WktOWFlDM1dyNGlCR2ttNTRoQndrUHpGaGlYL1ZCSGRWSC9LSjFaSU1PSHhJTjZhcktkeHJtNkVCc2d3RHQwbVBlME1YMUhSVU1xOGN0Y215c1U2eFgwYnpNMUowN2tBdnEzM2p3MXEwUHEyY3lNV21lOEY3YVZrZmh6WkVGZHlpOGZWQlFhdjBZWnF2QWpaODNXS0g3MjZyQng1Qm43R0hGdGhSNkg0bEZzbHR1K2pXbXNBaWJKM2twV01HL1FibmNVN245c2tJQkwwTXVYWHRqOXNKZys0RGwwWGhLSjFMY3JNeWRhSWd5cmdaZ1NjUDRrOFlRdmNzQm1EMjZYMWlZWEtMek1ZZlpuMklmUmp6bnNySjFlNWNubC8zYTV4aU5vSTZuMXgxVTM2Rldja0pieXgraGlTWmcwUXFBcWVlU3Z6RllNbFoyUkVuTy9hNnlvUWh1N1BkSE1ZRVBGSXZmeUdleUNVOGU3cnBqdTREcmxPaHN6ajlyT0lwTnN2Q2t1RCtUTHlmNUo3RC93c1BrQnBzY0ZWSTFxN29VU1U5Yk4zMHZINUFxbk83YnNmKzlyR2h0VmpPSlEzMkg5aEhTQXpSMmFwZTRMMEN6NFd4YXlTbTRqdnVHWHdrRnA1Tk1NTHJnWjhMZEErNXVMdXl4TzVTTU9tSk5EQmNiYkxlZnY3ejZMeXhCd2x0bmZRTGQ3cXFwRzFNbU5jb0xVY3g3M0JrTkYveHBkUzBjS2Q2RzY0Nm50Q2hYU2VUWkpKVEZZR3czOVQ3ZnFYRFBLb0cyY0Y3L1pjVHZNRTQyZ1hMVmpUcXpBRVIxUnQ1bTdHWXNoMFgwK1hnT2VXOU1KcUU1ai9ycEd6WTZ2VXU2QUNjQ1R6RE1kWkhpV0VMcERudmdFMWhtenRMY1NZejBNdE55VUJMcXZ5bFVKSm5KdTc5U2t1OU5NSENUa2dxb3pUbmhNRmZkdVYyTkxDU1l2QUk1SFV2UXAxaC9NMDJ2S0ZENmVvc0lrR1RnNm11alVvMVc4aHk1S25mL2Vya0JRQzlMek5xUEFZQ2dSK2hjemdldnRhODhOTnFTbEJacnlxOVFOZVVLN1JwYnZIam9OaFVLQUFlTllINTVMZVRXMzZLeUZhWGRBa0J2eU5QOXhtUnVCb2tQaTJPaHFEYnk2SVo2MW13ZnpHK0dtQUNrUytHODBBNFdHT041aXpnSldlZURLOTFqenVzZk9pMFJtRXNWSlh3YlZVcjh1L0oyTENRYU1uSGhpK3dKVEVQTjl0UzJiNlc0R1JHQ05tdGpBTWdQc1AzNTduT2VEM0gydGNEQVB1NXhRQktNSGYvajRaaFhsa3Z2eTNZbUJKc2pzZDRwU09sZlBaQ253NUp2enhFWE01SkljK0UybVU0Q2dCMG1kSm5INE5Fc0NIWU5lVlJEWEZOdXlaVUU0bnV2YUpmMWgrMTFBV0xkQVo3MkQ5WE5SY3hmYjIrWEhaTi9TTjQ4VTd5bCtzTlpoZzVnbi9QRDh3a0J0blJqMXpCVVBJV25vTVA2eUdVRUV6dVQrVmFYM3gyakVJWkFac3IzcnM5d0NmWTFTczBFZElGRnpCYnlydVV1cDRFUGFuYlNZZXc1dGYxNi9aV1Z1cDVpeWt0dHVxTDR4b0MvamRaV3NBWmVTZkRTZDNmUDlrYnlBRllYa2YwUTJsbXhhVGtLUlpyQ285WENvaVVHNHlQMVVSSjVHNytIU09oaEpwMEFuejBOMDdRWnR5RlV5ZTZyY2dpT0ZidHlvTzFsa3VWMGlRNjAyTVR5Rks5eExxTkh0Tnk0Y0phVE82aGp0aXdOeW5WYzM0WkE2SDdrOGFpNlM2ZUY2aklHMHhKeCtKZlA5N2x6dUNacjh2VTVTSXpJbWFOcGlRaHl2RGJ6MjMvL1BKY09rN2hENGlJdkp6ZklnT0dJUjZaUEVKcFdIWlFvYWNiRitvbWVIdzhhV0hhTk9mYUl5R2VHNGxFcnlNZmh0Tm1XaDRSQUlwbjhkTHM3WkUyZVRWRHdLKyt4RG9TVWdoNDdXRG1LbFovazZPb3NFVW9Rams3UStLcDdPeHdnTUZTaEF2Nno0cFRXOGxvVmoyK3FYTFEwVDNobUl1ZThxSHkxby9IWGptMDg5bTcxdDZtcnJVeURmdHFNWXRtZnZRWEtEbForSzFIUi9Ga3FQU3FjakdsY1BQSXdiTXczd0lGS0JkVk1KNHBGTHQrb09Ja1daTXc4cGtvWVozYnl3NExtQUYrN0JkaWNHWEZjYjVQV3REdzVYTk5WYzZlQjlkdjByQUVwZ3I1SitiTHIwMTBicGZHdytJa1JveERia0RGbVFkRVFVU0VsUDViVmlMbzF1ci8yM0tOMGpFd2wrckdDNkFVTUt4SGN2K1Q5RjFLdHBuOGpTU3JLeEpuVmtLOFVEL3RINURONm5YQjhtalVkRlU1MzllOXl3THRMWUN3bUhZVkVWcW5GbWR1YmR1YVNkMWl2SW80cFRzWCttSmNPQWtyUjFENjBSSW9vY0NCSWR3SmhDQk0xck9FMlhTbFBvMFUra2hBTHZ3K3pmeFl6d3pkNHJvV2xMSmtaaGVGUlI4UUI4djRVU3dtQWNEc3dVWjJQLzd2N1hhNTFGczdvclllYll5d3c0WVc1ODY5WS9jNktxMmVUUjlITFNqWXVDaFRrWGFEeWdvbzhuei95SjBLemZYOG9vd2FOQXd6OEh2UWRsTFU5VjloanFZTVVSeVl2UHpaNjBHMGl0bVVkWndCK3NZNnJVa01BWlp0V1N0YkRGbW5rL2RRb3Jod3IzMTIxWFFXZmZySzNhczBnMjlBU3d4YnNaM2RaQXEvOTZiNy9YV2NrYmptbzgrandkRTY4MER6b0VVVWl2bkJnb3dNdUJReEhYb0d5cCt3L2NTR1k4OHJXdG13b3lOTkl2Q2hzL1FzWlJuYmRWN3k4eDd0MlJrbGlKVi9qOGU2cWZjdHJUc01WMjJ6b3FnUXVUU05GaDdVN3AvUTQ5TDBreWdYTm5FWVhDQkRnaTVCZU5XeHU3VmpVTGNVSEkrbEdqK09UQ0VBVHpXckRtYXlucTN3VDlJQWVqdHZoM2VzQ3U2c0V1OUpPc1h4TURwcXhtNFR6bCtwdDJXYTVCcTNUTTVUS0g0TjdLTGlyOEZHSVBBNTY5K3VKMVZFTDNmVzhKeWlnei9uRVVqQVZZcmRDV3EyTW5TNGhRVmdjdlhxOWFGN1hrZS9rKytyQXRJUXFja1BOd2pLclYydDdIQ09yQTFwczg4WTVSdzFacCs5aXRuQjcxajh0TmlRYzdtVjFrVUNRWGtvaTVmT3NxMXVDNmhVUFVMN1o2OU5BTTZsZzBjL2FlaWlmSG9pMzV2K3BWQmg3Q0RNMVhmdllwaUs1SkliSVFGSGFmbW5oSGZSVG5NYWdLY2pkRTd6emd0eGtUUEtWck9iVHlTVFQ1MWc5YkI1cm8vZHpuL3NCMjRmTk0yTEdKdVJRc21DNDlQTGkxalRSZlphTHBvOFR4eHhjemlqNVBsMnZ1citTMXdRVzNXNXF5VmNJVXlTWkh0RkRRSHYrRVlEb1pHMVQxSjdEOTF2RUlWOGRIelVCelcxVXl1eFJiUCtNL0NNL3ZzYXM2UnptUzV0cmFYblEwSnp2OWhZWHhLSGNzMTVUUUNQNzQ0WHNManpGaklMWVVSWEZuaE0rbm5WMGlPNm53bHM5VFI0dGx6MUo5L052RThGR2c1bWdwWkE0aHRTMDVBSzBOblUyZ3h1cWYydmpDeVdsbTN5cEt2YVg0dnhoOFVtMU1IR0IyTlRlQUZoYkR5R20rNXcyenFKQVd4VmxqNmRWZVBiNXlSK2FNaHV6MDVZdWJDUUowQk90b1lRNlBvRG9XNWZDd0N0WGo1U0h2Q2dMLzNCNXoybWNYV2FSVGY4L0dzRkFmWC9udGRXWldGYzJ4ZzhNSmVlbndaNGRaVVRvY2U0M0lmNHpWYjFleDNCTUFXR2hna1B3UjVFZ2t0WmhXM1lpK25zblpUVXI5RllJMTYwWWhBcmFCMHpNVitvdUh6NmhZbTI1L0VURE0wTVRtY3lwb0dnWklTU2tmd1lBUWFIR1k0NXlaOTFLNEE0TW00Zm5iTWs4R1RjNG9yeXBUM05MQnFBeFlkY1kvcUNIODJQcElrbVZPRUhpMU5vWWFVeW11SW1MTGNpYjVwbWQyTUhUQjNKUis0ckxkUmMzZ3RROXplRmRjaWNpUmlXdml1M0hrcWFMU3hKZUkycmdjN09LUXNsSXR1bUFDUW93ODllbFhtaTRQM2dUWmVDYXV2TUg1bkY0VnJCY0xqandHRCtLbEtxZS9SV0lFZ1Qyd0dxQWdTdUw2YitSVFRQblFaenhaNXk1SFFKa0VFS0pwNU5mb0I4aEpCTThxbjZ4Yk9GdHl6QmpWQnJ3U1MxekNKUjNsRWM5T0RRNVd1L3hjdDkvMlE2cUxIbm1OeDZYd1p1cy9pOHJFZDZVc1Z4R3RvRHJtK0JyMEw1b1Vvamx3ZGNxeVZWNFBJTXNSNjBKaFp3SnRnWDdpelFXaitHT2VGOURBOFdleGRtdjZEV2pnUjhMRUJwOVl1UEFNOHRKRHUzdUN1bU5xSG5GMkFUWVgvdHVWTzU1T2dRdWlVaG1EbUpiRjlqSnlpZkJSdHhPVkk5RENOTFVZNzFJWFpZVHVpWWNuSUxRL1hIdVZKOGFIRFN0TDBOKzNlWU52WHdIaTJ2RWlUUG5CcXpzQzRUc1BuRlZuWVkwNDJqNWk3QzExQVZkQloxcEdTYTUyak05ZElMMTE5cnJ5MG1nR3hGekk4eFBzKzdibU1mWUtoMzdBNEh0QTA4MW9sRzFtOVM0WmNoMmhvTkNHVnZWaGQ2VUw3QzJkNWhLSUJIb0IrVXhhcnEvNGFRWGhoN0lXalNqK2NhN1ZocWI0K1p3WTNuSFhoMlM5Skg0WFp4UW9qYmUvZUlOeFlsb3pUWXRUMnJwVS94YmorVzJoWGpGUSt6K2RROHdoOTc1MU1QMFVwanV0UWR4ejMvRkpZQUVHNUJGNDAwSlhXQ0JzN0tyQ1JmL2wrRitkOUV1d1ZrNnRoT1BEQitITlM5aVdsTG1EZ1h2WTZLMHZnaXlvZUEzQW4rald1ZmRBRzFzdVVNQnVKVCsvdzBGTkpaYk9iVVQ4YzVxNVd0UXhBU1FGNkUrL3U4VXdWQnMxZW84alRhbUNyY2RoWkpsQURKYnFuM2NyY0RIUWxCUU5HcTdidGNHS2lKWFc2cTBjbjNGMHh6ZitrMUpKUzJ0ZXN0QjNyeDE1WlBURFhtOFFWNVhFMnF4Qk9kTTJuNnQ1WWJ4eU5PbUVkc0h4K2hNcCt5OXBXa2NndzFOaWtlWHVhZkp2emNqYU53RTFBZDZnRzc5UzY4YU83aldwS2dCRVRZTG1WNE9OSGhCazdCZTh0amYyV1Z2V01EUXZRZE9uazQ0OHllTXYxdFFLVTF4ZXYwTDE3MWUvcXhrTVpibWtmS25kMjlYUkNLMmhnTk5KaHd0MXFpWVdaR0t6N0RpNkszZkdEVDdETzJZUTdXVTMzc3ZFL1dLR2JXUUV2elVWMncrVk5ZRG9jSTR5eFE2aTNpNHpVMlRqbWpDd3U1UGsrSmE5SFN3THBFb1Vzd3EzdEZKMWppbXRoZ01YZDdLalNsNlFkMEsrdnhXVDhHNC8reElUSHNXREdTZlFUU2RGUXRoNXVWVmZhOHdya0RaSFRHVmdwSnlzMmlrKzNJMGRTZjZUTm82QS9zVnB0eVkva3gxaGRBV0tQSTZ0L3hqNnMrZlBNVTNoZzF2a0VCMFJSSHEvdEN5M0tVVWh6VS9kMEpLeFR5anZVbXM1aXkxR2JPRmNvME5BNHQ4M1NLOXNCbXRMV200a09MTGZseXhxZ1FZUDA4aXlYd1lYektubFE2VlRpcHVhc3BTSjlnNUg1THUzZUxNblBLYmhjd3VFZzBWWjgwcHBKV2pVbmhTM3JMMzVlcnp5c3ArZkpoeHNVczg2bTI4L1V3VytJZ3JTNVkweldheGxGSjh4TUw1d2s4c2cxcmFnRitlTmFqeUkwWTRtd1N0eHQxUlpIMkJqYUFodnUrU25OTklLODh0aEVnWkVzb0h2K2lpK09NbVhKTDdkbkFpSU5WRHozdENucURncFFYOU9ndU5HZ1pqM2F4Y2pxMVVneER3Nzg1eU5JcHFOaUxndjU3Mzk5alZtSjAvUlN0TnN3YUZJczZGdG5raWxGWmxkeGo2bTU2MmpMNHA1ZzNZOVhDaVhSSlg2bnEyUEdKRmlmRlI3RXlQRzRqRE1uQk00dCtPOFpwRXAzdGg3VEN4RXcrWkc0YWZIbDRzTkZhcXh5TGg2Kzk3OXR0MEFxOUJycUkrQ1MyVTdISm9LaUdteVZVMWxGYTMvME81bU5DMWJ6UmdOTXkrR1h5aWZMd0pQN0Z3VVNVbXhtVlJwbitnblhXb0l1c3dQdXRzaWNpdXJ2TjZsc01HN3lxRWMyWTVaSTNqclBnUHEweEVLUFpwRjd0ZUphMFRRbjhCUUw0VGgraGp2MkJ5ZndLb29reVhFbWowZDFLTWNzbWZLYWVLSzNjWlp1YmlZcW1TQ3JuR3BZVHdnUGs1aXRLdWNWdGpWaXVzd1FzRFI2VHV5R1NJSFl2bHo3d2tMZzFScjBLOWtWMW84UmdBQmxoYkxyTjc0Y1ZXSlc2VG5mWE4wcTEySkZNcFViRWE4dDErajQ0MEZBKzE3bzhxYThQUTlpZ2tjdFZST1ZJZkIzalU1dnRHbTVwWVlIWVNEdlUyVEVjMTVwSXoxOWthMXE2Yy83V1hmRjgrUE9rQXBkT3c3bm43S3F6NlY0dHJ1N05YZ25BL3UwZzYrZlBSVDNocC9RckRRd01zandOQ1p4ZFdyUjZwZ0NCREpOYzcvS0Fsd0MwVVo0eVdRczBLc3V3YmJPZ2NUeFFQSzU0d2lYcjdzKzIyMWh6WjhSVnhmb1JVS00zZTRscHhIQzgzSmxseGxyVjc2MHRsMDZmNy82NXFoRTFqaE1maXZBVVhJWGZSTWUzdVkvRzJUcFdZekRydzVDbTVjUzA2MkJ4OWxoSHE5Z3RKcDh4WndBdFNkU3VXL0tkNytvckVBaXN3QTc2Tjhlem1WR1lnTmFZbFEveGs5MzBMQVdBdEtWQkM0VTZSMDhMNDVJb2hCMWtGaWE3WEpzMFRjYVQyekJab0xGdU9HdTRpSmFvQW5makwzdVM2Z25SSDdHN0ErYVQ2RVRsbWtZVWZnckJ1YVNMTERKZmhQSmUwMVBmTjBvcUJUZVFVUmFzbDNOOEJaaVFTZ2RyMGFEdjNoUFRpb2c0TlN5ZkFVeXk5OFdQN2RuVERXUVRZK1F3emdrMXV4d1JxSGw1TXBDLzg0Q3V3MVRYZlJsZ0pyd1BvcDEwa0NIam1mZm5GZHhDZTJKM1IzSjVqKzNIL3NabjNJVXUzU3V5K0krZEFPTVd2endFeE5SM1JSUFZlbFpBaHRhcktsWFBXTmpQUklWUDRKc0FGU1JYczNvL2ZTWUFQYVYvelA4cTZEbHRINDcvclloQ0xkeS9McnBPc2JhTGYwOWVBQ2NDbEpvc05lZmV0TkVsa1NGU3VDZ2VZN29UQUFsKzhZMnpPWEpiL2JnRURwb0RYZlFxYzZsbmxCci9Xc21Wem5rQlMxTTd1ZmlxcHh2S1hqd3ZSNFd4TGJoNU5iTU55OExzblg0VWl1QWk4WG9uYlNVY1ZaS1FPV0JZVWVjU09NajZqTUc4Z0h1N1dOcmVCSFk5MGxWN0ZvY0RwclNyU2JleGtBdE1XOUtsWGNuck95TG5aZG9kR1lkeHo4YXc3MUh6dElxTGhSZENPQjZOeXpIUG9TMmhEeTZ3TGswSTVKcjJ0K1UwQStBN0VzZ1NuL0loMDNBNUNzcEhuVkY0TU9pYytMY2szbTYxVW0rR0hERWU0RHJIQmhtZ3REbFJRbDFYSi9WL1Z1bUNIdFVERGNaQ2tnalZNQk9tVk9HWVcwUmNkaTFhaGRqaEJjRmxmakErNWNSakJvcDFhTkR2ZHJmN0N4a0xWZ3hpQ3hoUmN0Vzh3Y3pNOCtrVm1Jckd0a2FIR2xyOHkyRDA5OEhYRTIzcjdmbkpGVVU2OHp5ZXlNMjY1aWdOT0dQekZHMGRJZ1VEV042UzNaY2ZNRVJKZFdWdnBHaFZFSFhOTGVXcUhpVGNGM3dPdDBGYkpZNFhIRXBta29HOU1RUEpKNHVlUTAxK01CK1NSMHJDU0d6bEU4em9kMTlxNzVMbExXZ3pvZ3BuSm9ENGdQeFVZY1grR3BjNUx5NG5rK1ptOExEWGNOUjdTTlZ4TGg2TkFjeDhla2piL0FDN0FEbFJuZnVIYUhKYUJvZFpyN1JCWDlGTFR2b2NZNmtZOGJhdmRBa1FpY0U5YmJ3R0xrWnU2d2hUQ0o1NmxPdk0zOWlqZWhwVE9GcVIzVjUzblF4NGhmT3Z3UlBVMnkydzdVVTh5aVJiY3lhWDZqR0o5Q1J2bDl5YlYxdGViVHA1TU11TW53TGN4L2x2ZW4wdzlUMGF0SnVpVUUyV3RZR2lWTWFQM0VjaEFCbDVBc3lhQ3B1L0JLQVdERnZVMnZhQ0wyL2ZKQktDS0xqeEc2eHpUNE1oNHdIaEgzL0Vxc0dTb1FBSHUyd2JIbVhIajJMdm9XMTlHWERhMm95ZUtSd0dHMVBVK1M3bUUvUytVbWpIaURGMW9xSjBSNVFzZGpBWllOMU16cE5YNVlEcVdZZmhmZGpBWHlGUWFWeUdLa3Axb0VHVFI4TUs2amFHZlJERmQ0MXUyRXg4YWM4aktQWXUzcFhzazhndSttOXRyMVJWelRUdURzQUNXNFMxaDMyeUZIWDdxcFhTbUEwUVZFY1I4VzlqMkp1dTBwY1lxVG1kaXM4OFZnVDNncTdpWXVlNUh4LzNLNmhGUWE5clpyTlNEY2phU1FsTm40TFNxczIwYnlwbktxcHp2bm54ak1kejVTdGJ6dm9BSktnVlphNERMQ1ZvSlc3NjUvS3lURjRzNFl6dG1BVDFjMHBUbUtKSFRwYTEwNkZlZ0RvOHAyekQ2dU9ud3BZaTB2SmxSTURlOXdQVDY5NjRVZkFmNmxxM3FXeXBVT3g5cTZCYktFWXQ3SzNnV01YRE5ONndBbTFmTm5TT25aNEprYlBxN2pMUXJsMHdMMVY3UXdPL3NYbmVLR2ZUZ1VMMjhJNWlQVkc5ZEEyZ1M3S2kwMDVKVVI3Vm13NGdYNFRKdnkxV1M3NGNJWEQwOExDRjVvYnFjWndhbXVvWitGUE1KRWNrMFRMSGp5SDFiYVByNTUvQ3kwcHREZlJKN2Q4OXBiUDQ4dExNSEc1ZE8xMVo4eFNTcFBHUVNnWERXbXBzTnNtbStNdnhKak1DaTdPRkRIeHhwbVR0amduT0NxK2M3RmkxRHliZmhBbnR2aUtjY3orc2orT1BLUFlPS2VZWVBMdnE2TXBVeC9jaFN2QmNjZzlkZmJlcWV0UU5DczNlaUNGWlRVMW1yRGlkby9taWI2NFNUTWdzYStJS0xrOVB5eEdHYlZTUUI5R3NIdG82ZjVwckFGSWJSRFNJdERlZHozdDUrTm42OUZGUzBuRWZta0Y3aEtCbU5WY2U1eHY2NVVTS0dCb0hZeEp5dXRTR25SSXE3dk1Ec0FNdmlyT0VKT3pOaTVLdDdmeXB1U1UyYzJOcG82VUg1ak1Pa2VQSDBUd2dwYW1tTzNGYjJGWDZmMTEzMDl6L21xUm1ROTQ5SEhSai93TXpLTng5NU05cHdLZitVUWtNRXdpc0wzWVZvdHZIaEN2NHkwMFVpMFFsOGRSN3RHcUZjU2RZdG1vQU91QW9ka0JOczRQWlNqQUFGN1Mvc3p3TGRkRk1kQ3lCL2RXUGdGVWlVRStXbVVVQ2pZcktmSkxRZk5OcFE0TkthRjU3dzdLcC9pc1pWd1FQVUp5akphdk4zZlFOS1UrRjc0alZCSllRRWNFZHcwTmlpbnllYTBsOVBKMS9BY1RtL0xJOTFSWmpEdkxJODFwbmF0N1JLVTJQNC9UbklBYTNoSUVmZWc0aUdRK3dURGxVUks2WWpOcE41czVWa1FXOXc3c0RZS1U0WG1qeVpzQ1FMeHp0cWQ0U0RRdkx5dVBEaFVSQUpYS2ZSMWM3dHEzbVJ1NHVzRkhQcXo3SGdTMFg3a054aVdXUjNmYjN1VndiZ0twbWdMWWt3S3JYS3QwOUNPdzRNamh4ZVpsRFhLeTduTkxIWEFJS1B0ZmVyV1FuWkxib29uUVhLODF4K0JCM29VaWRCZWhLMXN3U1h4VmJzY2ovTHNmT051L3hZRVhZUE0zYU1xSVlkKzJoQW5GdkRIYmRySkxoR0VkM3NHNVB5eHFoemVqaFFKbzl3YXVGSzN4bVBZcXhCOTlKOHpZVTkveXpyRVpOenpidlBvUjl2VWxFM0hhNHpzcFZEekhIZmZQWk1KMVZMWmtLcUdDZjhacXVwcU10NlQrTlJQZm1QbTJ4ZURndnpNclJKRUw0L3p6bHU3WjM1c212emJnZUMyNVZQMkNVclprUnhFaTE1QTA3NjlvamRPMWQ3QzlPRytzd2oxUk9NTTNOZ0tkZUJBRG9STWVKa1JaY1oxRmJRdTZDMEJTOU5OU2FveHRGellUNGxYNytQUTdCS2E4NHlyTit1alZWZWYrU2duRWllMUcwTitlT3RiWkYvVVUrd2tlZXJXamxvWXFGaXFvMHZCbm14aCtUd05NbzlJLzhsZlUyWFRDVDBLNE9vV0UwOGlweU5IanhIdmZoWTZxYTN4NEh6ZFE4K2praU81K2o5MVlraWhTNW1lbWZwRlJFSFAvMnZlTjVYY1J1ZTJ6Q1Z1QXViOFY2dkRsT3Z5UCtQQm0rb3d5UmhNbW5nNXd3R0dJWHNPa1Fla1hyWHBFLzZkRmprSHd3b0ZvajViSUZpcXArNHdIcFNXUmJ2MnhHclJwZDJjODdGek1QNkhmai8zTFdJQnFGaU5PQXhCdytBQVAxWHFVQnN6ZFpoek9TUXJRUzRFaW40ZnlWN01hR3NCMFZzTUY0YlBiNGx4L2ZvVEdRUkp2NDVMcG94RGQ4NHhDYXdIYVg3anBYVXJPZGtGeHgyb1V2WTJ4cXBnSXZjVnVmd2QrekFuYWFWVG5FeURYRDdTL28veHJyazRtZ1RqWGhjamo1UnpyYnIyM05tdVpRdnBkTnpueTVNQ1I5Ynd2SVJJcXpPWlpMc3N0WlNDRFlhNTZKVHZ6eGdCczIwZFlUdFRVYmUyMXVsamxXcUdmU2gyYllBek9wZjZVZ3VLMzBaeE5YZ0xIczZZNnVydHhGQTVpTFl2bHVlNW1ET05XME1PdFFqaHFyOGZSYkNrWW5laURrdnpIa1FWVDRGOXY5dnhoMlNJR1BCSDhiWmI4dWdvL0JTZ1hvamVTZE5YYkJBSURzQjZEVU5TWG53bHUvYkZMYUNxU2J2dTQrWUxwbHdPMUpidHJNZjlaVWZzeGVyQVpqQjdFL3psM3F3Z0syN0Zzd2VtVW1TTTRpMzdZQVZoUVNvY3VWOEFjREkvQ1NlQ0ROUGF2RVNzaERROEEvbFZJckFKQU1kUC9ySFhvdWlOVThSTC9USXZmUWl1WkViNmRrSUtNR0dPVzVrVDh2TzhwaXZXblQ0djdxbXd1Sm81MkFTMXIvUnlRMmcvN2M5WkpnbU1JemYwR3ZKSlJmTU51MXV0Uk51TFdIT205SklNY0pLM3FpRHRWcEdDRFA0NVcxb1RUTVVuTUM5MWtZaFAwR0hqaENXOFYzOHhoakhnRkZCZnVXTXNtU1E5TXZOcUtYaXF0VWhEQWtJeTBQVzdZU0thS1V2NnpjdEFpSWsrSnQxN2tHNkxwTlZPZU12Sm5sVkJhSlNrS2UwSFRKSlVNdmY4UjJ6bmEzNS95aDJ3TmxXTHpJUDNCSlI1YVJOeGtWOTRJQ09seWNJMS9KWVJadHp2V01Ob0lwUXJkTnZ5QnVCeWRoU3doUndQbzA3OVhrL1hRWnBiaHpOL0tLNE5iZEpRVjBKSU1QK1k1VUJJTTNUVFlsRkdZVmpjdkE1eVZvemtpbWNvOTFGeC9lbyt5ZGdBeDFnTWV6VGgrYll4Q3RYUFlrTW9QZHRhRWxSdXN4bG1kU1Y5emdGNE5wK2l5bHVuM0xWeEN5Y0FGeEdDRnNtQVJmNnk0STZ6WFkwdHg4MWFReWFscjMvaWgrWmp4R05XZGhJdGdOTGRFWi9CT0lKcFBvQXZlaDJiS2JFRnhVL00wKzR4cURvM094OE1uTm44TG12MTVOSmlnU3ZKVit5MlcvWm9nRVhOaXYwL251RnpaR3IwcEt1ak9TaHpjZGtFVmxNdzhtTlpYWkNidE05VittZmF3dEx4Q1R2bytlbkZXaEpjRnY4TFZURnljRGpQR0JYUlFLTk4rejY4SEp0WWRwSCsrZzVXZGhRcENPK0RFN1FkdTZUbVpndGV0cnBVMlpsZ3BzbE94KzRoYjNhWGFxYmRjOTJMQ2g1MWVyOHZtMUdROXVXRDkrZkFQUlY1MGl4aGdjNXppMkpzZzF4UVZ4emxhRUxSV0o1Yml5RitlQ3dOVjBvRm5UYkJIcjNHbG05cWxHVk9wb09zUUM4aGxORzg4ZnhlQWVra0NHbkhGbjZpNVd6eU83U2hEWWJaMktNNGVxbmR5eTAxdis2VEZobWt4Z2MwZG5kdDdFelJDY0VmQnhTYVdad2NldjZNRFpjdXZTWlE5Q05TZDRUeDI1VFk2VUFicmhpa3VQMXZORmZQZFpoQ0cxcGU2dng0RDZFejN6SWIwekRhNDJGUHB4V3ZJcEVlWGI3WVRjZlpPYWhTcFNZYVdMSC92cTBGM1UxS083WnhsaVpwb01CQllKczkxSUUwYk9rclBOUS9VU1lZMHFLQ08zQ1UrQUZiT1l4ektXQmtJZ2xyWDM0Mzc3QloxOE1LUUN2MUtXZklIRWVndVNwdnJOSDVSUU9ENExlaUgyZ2R4MU1PQUtwaGxMNDFGNFJweGFVNGR5OHhFUkZncW95SUNRcTlYbVE4V0pTb2t3cXZoUU0wZkx0c3Z5Q08yUEFrSjNCWmc1SXFvUjVxL0dkVExnT1dQRlI1M05xdzlNYTV2QnpaY1E0K2laZ2V0bUtnNVpJbisvN0piaStWbFZpWHVEOUNhQVV0ZEVtbndXVFM3d1pXdXNrVnZjL1NEYWFLVitKejZIclpUSG8zVXJBdTBJWkRCa1hXbUwrbVRUamRUYjFBK01kaEtrWS9odkZOd1hqMUZ6VW5nc041OHUva1RkSjNYaTBoeTdlZlI2ZmFBT2k0U0tHYWlPdHk4bHhERmtpRDl3cTJHVzFFWkVzb1dHdy9XenhYaFdEellZOENDN1d1TEZIYyt4MTlqaEgrRmlMWHdESUFSUnRua0pQRjJCVVBaOStnclozdGpxQVdoaE4zaDc0dzVwb29SUVVOQVR5MDVBOUhETG5JTEdTQ3RmRVNvU2lscXRxQUlRL1RWMnQzS2hPYyt0ZURmNXQrRHFaRGRCOE9iOVlYeWtsclNPNzNwUjBRQXhQdlFqNTdjNkZJUjVkT2NpcWVIWjJMUkFCTVJPbzhKazhWNkpGZXdDTDhUQ2QvQTVNU2JYTGt5MWNXN21Yb2JxZ2VFWGRGRG9FeWRLbzVvQ3V5bisySllJLzdwSUdGQXpFcmxIWjVoT2FpVDE3SEMzenAySHBKd3NJQWI0L29Jb1o4eDhhazQzWXA4M0VybXE1NURnOEh4S0dIWGJYczQ3c2gwUHpRRUxUR0ZzZjVlTzNsWUF1SmpNbmVvWVdrOFcvM3RXMldMbnRFS0JaRVc0aE9GZ284SzU4Umowdms1S0x5ZXp1MWQ4U08vSmN1eHBPSnFGVU0yc3hCbWJRLzlxcXdiOTBSMFd1bHBSL0p1ODRiUTUvZlRoN3BvL3BiQmI3QVFhWU5kSzNmYXREM0s0VExIQWFhNjZNUXpwLytaR3lDanpvNU9YUnpKOFVIeWcvWXBOSHZ2bE9wd1FJT2pha3BMSHdHVjRXc0xEUGpFSXFHMjNpbHkzTEwwZGxrWVF4ajNYeDBBcENvMzV6WUdvR090SWNsWVM4M01uSTVUd1ZkUStIZzQ1M1dGUU42OTREYXFoR2FML2RtMEtuY1hZcVhMaTVwb2xnVDRET3J6RDRvU1ZocmtoOEdXMlBhWGpPRkRDTFBjbjRSUWo4ZFJHSUp1VjgxTHhNUFowVUw2enBrYWViaGJGQnhjUkplMzhVaVRiVVBEakZXazJqQnF6ckJ2WGNLbWdkRGNtUnlKaElwdXErM0RRWTQ2NEFsWTQyejJFTTB5SUswSTZiK1ZncGFuTWZwZFdvN094S1k4Uk01dFNKdjM0MC9xRDhTeHJZc3liTXVVa0Y4ZkhqN0hjdnhFUEM1WVlySDRMVzFZS2c2UWFlRlpMdlBickhaSHZpNE9YTEtrTjhjR1FPODAxOU9LcWN2NlFuQmxqMDFlN3FTNWV2b0dtNTNyditWbUR4eENYRGlPckRnK0lhUGVNUHJuOFRKMW9SZVhZSTN5Yis0SFFiaWt4UDVUUVhIazRZWFBVdjk1K0tta3hHc1JnVHdQNzFZaU1wcU5YcDBsb0haZVhScDlpM2V1S3JWdHhNTTBlNlhBb0FDd050Y2M2c091aFpWYjFodEJMdWR6YWhyREZ0NUdrZGx3SGpabDV5MExidlNId0lJK3FZZUR3UktUVHp5WGFJbkhJTSs4cmM1VHJqVWxQUlZ3QjVMS0ZwUW5WOGU3dkx2N1Q3Vi9pSlRXOWg5VG5SdE5DU0djb2ZCV1ltNVA3d1pjQXEzQUZhbUVXL0dNYm8yN2xkejBwbHQ1SEk1M2RkV2tuOUl1Q1pZK0l5ME1BVFVoM1llblJUYlZnZExZdHU4OTNTdU42RUw0ZTlWNE5obHpVakk4bk9TNkI5OWVjeUMxT3Q4c0RhaFFwV0hibXQyWXZXR3lMM1M5dEVWTEtZcytMbmdoQm1tU2wydVBXZnFQb2JQd0JITkxXMjFMVWpmWmI3amZMTVRzTXAzaWNHTzFucEsvckNzVWdkQlZLVmcwWXMrL1dLdVRtVkpvQzhPZTVoM1BLMVRRaGJwWjJ5dFA5bmx1dFFQdExBRXQrQ1ZUOTBEZlZrbjdsSExPWDhBZlM2SEx6ZkhlQWh1MWFsbmwxOVJIS1YxTEkwRzdSUHpZZ1ZhU3BYN3RoOWYwNnVvMldweGpMODZpLzJ1eksycWovQ2xIYkdEeVFyM0Y5L2F4bXE0a0o3elpGVlhWVndmaUZyNWJoVUdWWmVRSkhLRkFjc25xUEtzYjh2SHlCOVNwRnBUOVUxVTdENGFTOXZZZ3FhanhoQytoT2tvbEpWMmRLQXh5c0NrV0JvM1NQaVBVclNRWVp4T1d3V0NvUXpiVjBvZWFERWNnVXRxSTNucTlUU21wUTY4OC8rd2IyNlAyQ0hMWTFIN3E1bHlwWFNybndubnp0cS9qTjFvOWx5dkxtTHlHZ3VWMFZKbkRDUkVraVVOclpxR0cwNk1zeUErUGhkOUN1Rm9NNU0xUHlrN1M2VEphSGRUdzBuaTNuNXlzQXVwMGt5eHI2NWxGYzgxTmNIOHhTbXBwK2lPRXRRWnJIL3kwMWsxckdNUkpBR0ZoaStuRGVjcFVsbnJoK3FCT0NNWkNjU0Nvdk9QSnJ4alpuWkpETUxkcE1WdSt0QlNWUzFuS3hzWWpZOUR0cTEvKytyaVZmTFVWaHpvZkljSWdRUVBPcUhpb0VMeFUzRXBDY1pNb0w5bGFhNVlsT1pBTUVwNWFweDdDcGhya0wrZnlLYkJBZjhjdHdWZDkzRlRvN0Y1T2MvYWxOc0NnSzZsSHJ1UFJPdE4yUnliaUxxeDhQNUxUVVpYVStBb3l6MDh6WUhhc1IzVThoUERLais2YXJXWFI5eVdkSm9NbjQ1cHJDU1VSS0t5MytKSGd2czJPdDZ2NkdiRXRkQ3VtZ0N0dHYyVk5vVTNLT3FVd3FOSVdIcVltNGVNaWpUTTlWV0I3dW1FeXA3VVBPSThmZHVISlkwVzl4U0NaZHZjMnhNam8zWmR1Mm8vV1pLRE1PU2g5VW1Mdm80NUlCcHBEMmRHKytISnU4a2JmRmRsd3VJeGsyS0hoZ0hRZU5LY0hoRmtZR1J6TDJWSlZNT0FiMENvNjR3dmRzNUNhWWw5Wm1CbTR6dUdEZWFPMmVJMVhNNCtyRC9IbVp5UkY2MlNhYmdBZThURjQzVnVNdXRpZ0pKTWZiVzJVSzBhekdMRmJPZnVqbkhEK0dHQlltU21PUWJVQ09ZOTlIWXZzd0JRQTZyOWhyYzJqdHNVVXhMVmp4blo0Sm5JclR3SVZkV0NUUHRwSnB2bEE3bTAxLzR0YlVNeXo5bXYxamROMWpraUhRQ0pYWEtnOGJKK2FxVzZyYndibjV5RFNIQlRjRlhJZWdyaEhHQWpKT1pJMXB5UDgzWjN2TVlUQUpvbzhWOUl3eVMrVTZPVmc3OCtJaFNZSERZalJzOEZyRjhzbUhROWg0cUFZeHA0OXJSUDJkNXV4TEF1UDcyR3ZaYVl2ZmVMT2tNcmNnMFBrUHVxN05zWGhNRm1pWmE2UEtCSDFsK29LSEk1REJMZFpDdkN3VFBkWHFtbno4Z0x6VlJiL2l4TFRTZGl0Mm5yenQweCs1ckRlWlQrYWMzMU5LTnNrUXM2bm9LbFFjY3lEM1V4emZWWkZtY2JwbXJmUHNaRDBWZTM0eHBLV2svRTlLaG40QTV5VlBWcStkd252MEV5WWVjUHFYR1U3UjhzdVRXMEE2TkpXd2VMSTNpU0dEbFFYek1Zc1NXa1NNaEZUZnlBMnZURHQvM3dYayttVlU2YlJOa1p2Tm55VkhZaUE0dG1uTndkaC9SVnNrL0VnU2VyZlRJZjVWQm11QWMySUtTZUw1TmJyZzNhY2dGajgwbUk4U1dzYzNkTkFHQ0JMTE1QODlnSDVVbkxUS3E3OGQ5U3hRSC9nN0RWbkJoL3FuQmR3NUNEcncvdU16Y2RYU3hXcUdJRmNuUVp0LzFhT0h4VWc4OE1OMncrRlB4L1Y3NWd5Mnd6RVZlNkc1MVBRSVIydFpzeGJ2NjJIaGdqd3RsenJWUkV3L3l6bGFBaXVYQzI2Y25wdlF6V1hwMm1PZ2loeVBDV3FxMzhuRWFkWDJUN2YxWTV6R3hFR0JhVC8vSWNML0JzcXVBSlg1RURiWDhYMXA4bkxXUjJ5eWpGUnZxQy9qc3NvQ0pCQ0RKT3Nadm9CZlhxUVNFS2hOQVJIMVlmdWVlS0JzbEF3TGkyNC93QU8xQkhwdGxmMWtRRk5zT1BsRHZsWWVkbnJFcDNhNFNBei9HN0xJVkVzWkJ1MEVLV1p1L2V1Qi9YS2RrR29uUDZ0NmxnRWNDT3c4bWNldXp2RVZ6eW9Qbk15enJxb05RWEpiOUM4WkNYU2llZEtpQ2dOd2ZOa3BWbEhiVWdFMlJiOVdGU2NPZUVhZCtUK2pUOFhsU2M4cmN2a0l1aEF2L2d4UnUyZWIyR29uTFR5b2tqY0dGMUVCcENKYmh5MkgzbGhMMHJkWkl3MW9rQTVwQmcyb1JmUWNlWFRQemh1TktvclRFRjd0MVVJZ0RxSW83L2xveHlUZ2J0S3UyOW85SzlLdWp2Q3FVR3lQWTd1cGNmaVpMTkJWS2g1dVhBQVpqUWpobGhCcDB1a21PNEF2eHU0eEFWaEN0bnNPSUEvdEFtOTRVM0hFdVNyM3dxK1pMbzhweW9DOUVCL3EzcE96UVJ5Q1Rrb3ptSndvMUxuLzJ4RWJ0Tm5TMlMwTlVJUzN5ejMvbUJJZHhPTkh4cVA5RlcrdW9HSTFGNDE1bEkxblp3SzBTb1BBMCtmbGFva0JHRW9YZ1puTzRHT0V4VTdWT2pkUG5zNTlla21EeHFOaEVIZUFGNWk1Ti8zVzJOQzFYR0ZqVHBxTHJuQ0VDaXdWa09Uckx0cDJlaFVJYWVqT0c2KzEzMzZZUVNLTVNzTDR6aFVqdzZTUUtyeVZSejVMZG4zUjUvcjhBT2kwMlJKa1FYUGR2UHNsL0ZNZzk2RS9jSm1JRkxtRUR6cjFHa2g5RzN6aXNHNHBxTS9NVjZYSXorQ3REVWg2aG1KQjk3VnpOOGphUFNTOTB2Z0Rqdm5hTmxLa3kyL3pJaEU5T2J1Z3dyZnRJK09pMmE0VlZhQi9Nd24zVm1hV2pzVTlOT2YydXNiY04vR0xRTWp2ZmVVL1l2eUVFUlBLdzFsZVhaV1drMUhYelkzUDlNVXE2TVpxMWhrRWdGemRzNTFtdjhtbnAxaTRwUXByUHdZMFRJZDFzelh3ZTVURytSNW1NRDc2bkdQUXI3L0VoUVdrc2pzZ0dzN1p5NVFZdk1jR1Y1dGNYSlIrNmhsSEZJQWMvTTZYamtLWXR3bTY3M0JpK0sxdE5POWkxWUJlUFR1cjRJK2dNc09LN2Y3OTgwbWNKWGhnZFdkaE56VU4ySnZGc3ZYcTN6WlJHMlYzMHNKdEpZeGowYVV2MXU0L3BwVkhpMWlIblRZM2dESHNyUVM4WXdNWDVYd1oyZ2NGWVllMndkN1pPOXN3cjBnYjh6Zi9mWHg4UVdLUFhjSzFVZEprMzc2MEIvVE1scFdMQ2Joa3FWb1NUc09xemdrbUZtRnRlQ0NUR2hOeXZGaHcxUnJUSVd6UnhxOFRqNUZpcnZLdnRrcDJHQVZoblo3dm5yNzFweUkwckt3UWJWeEtadXFNN0dBdm4ybVJCajVwOGRqbEhVc2gvci9lQkVDcHRwYmJqUDVuRnl1TjRtdlFMWkNheGVUa0RVemQva05HTEl6QkZ2MUNFbFFPK3htZjdEenQxZjdHTTFCaCt3TERDSlpsaGNWRFhidFB1R3NzZEVpZTNsWk5pV2NYTVRqWnRXQVQ1TUNtcHE2SkNSdUZTSFpZR0tjU0ZaOWtPWUpmRXFMSWNXZHpwVEErSG11K2t0Z1NVd1hWU3drYWEvYUhkWlhoN0lPeXJ1ZENCYWxDWnBnWEdSTmJoTjJYcEVZNjBEWFhPMUNpNWF5WlNveHRHMFdSQ0M1MCtYdGdXejdxZ1g1TVJBNVMranpYQ1l5N083Tm4wbGpWeGlCeFFOQ1pLWk1UcWk2bVBmeTJMWng3NnV5UlVYSGpucEpKRWltZmxIRFV4eVg3ZkZnN2lKdlNyc1pNSDZVdjJ4YmZRTng1ZUNieDNvS3ljVXJCWTIyS1BtZ2ZnL3cwN0NEVnN3NnRiNVZ4UGc1L1gzOGNRdFhJNDdVN01BR0dqTzI4SUkxMlQrUGphWEhsc3RQdGtVUU5uMERLa0NZaXMra1ZBa0Exd3lBSmdZS0xHbktEM25sVkNhcllxQ2tOSVpiaVZ3TzJZZGpsN042aU90dnZiQWZ1cTdWS1pMbzBqRWR3MVlkc1JhSGN1SlF1bGdiNTFKeUVMellCa1AxaGQwM0lEY1pmUGc1WG1OdllRU09JTnNDU24zQnVMdGtDUFpSYWxLNytTOTd6eHZKSGlKQ1pKTTlYUDc4NU5aOEI4ZnFEZS9PdDBCUzNQSDFwdEVyd3hCdHBnZk9qNGQvNDFuclNqSlFmOWJWMWtmZEJISnhZYkhJTHhPc1drWnZvUC9aNFNsMFl4M2JEalRGOTZ4Zjk2KzZ1SW9RMzUxQ2U2RGVUd1Rua1ByMjBZd0FUbG5oc2tXSWRkVW9oa2xOSVRDcS8wN3praUVjM0I1OHVpQkc2ZDlZQWM0aC83czQ0Rk4yUkcxVXVaV2VvanJPWkloRWx2RFA0S3FIY09ZYnFxUzk1bzdpbFFINU9OSmZ5K2FZaUIrc1BwbjM1SGZIRzNkdUxwTnZCalhjK0tsZjRJS3JGSGplVnR5MDJ4UFRObmJkTDRndGtxUHFNTGhTZ1IvZkRYenhKYlNTY3Fld2lGMXdkVm9KL2ZHTC9uR1daZlZsREhPUUtEKy9pL21xd1hxdk5xeHRaZVJId29lL2JvZGs2NkI5c29PblpwMzZnZHpWTVJSUXNRaUJGZitIWGpSY3JSZjlGc0dnaHczK3FvTjBKZWVNdkRKcmtTQlBzRVNEYWkvdVZPem4yT2hnZStVVmRpMDUwZmRXcHNqUDBEL1F1VGRZczZReUk5eG5oVThXVDIrS0JLem9aN0JxOGZPZEtQZUx1bFVoSmpUMzQvRU9uVWxvcXVzOCtwenFOaC9VZFVPaGdUbHJia3VUZnNhSVlEbTg3dS9HTklsM041M3VhVThiZ2FCanB6MGpkdTFmNTlLNEtGRHR3VVVlRVVvZVl4NkRFa1dLSGRpN2R0SGhRRjQ0bGJ5c2s3UHFFUnJzdUFRdTJENXRETWw3a0ZvR2RJOHIvczhyTXl0SnpZQlU0MHdxZUZ2VGwwWlZMZE9CNllhOUUvZjhWUGJHeDVNZHBZcVlNTE15QjBReFZkbm9KK3RnQVFWV2ZIK2p0T0hEM1BzanVUOGRPVFNydXB1dkhXUkhRb0dJMVFqMUhjNmsrTWc4NEZBWi9nemwzU0V6dUdXWktGd3VvMkQzRWlHOTVEMloxc3pUcUF1RlJtVDFuRWgyMHRrQzR5c21YeDZKdE4wdGFLMWlSUjYyczJ1Tlc1clNBdk1FSjh5b3RyM1VoSmUyMmJybFFuOEd2Y3ExSTBhT0RhSEp1Y1FLVmU2U1h5ZmNEV09ETXc4eGYrMkM3Wng1YTRRbGg3cEpzNTUwRGljdEw0T3hjRFhLdlZtTGdWV1J3YjNtb3h2NGtjeHptODlFRVJKWENsN1gvQnppQmtHUVdPSFBHRis2SzVORkpZT0ZWdjQrTnlGcStPUE1hU1daS295ZHBsdWZZK0NZeUw2M1Q4TUNNbXdxTFRtQUU4aDBwcmhpMTc0d254N0RIWldZdVJKU1laNjN1ejk3QUdPenlJM2FlYmNsbnVkNzd6bmJaZXRiV1VyaXBlK0FhZExRZVpQdFdzRitGTmlhWEN5Lzk4a20xMzdsV2V3eWM3R2FtYWkxSGQzTHMrS01NVmgwUjNOS1RRMDhUSUNsRGZNS3dVR0t5LzdZWmxKSFUzdVc2MFgwcjc0QWZoMDJ2NU1KZ1ZPWWtqbW9yczZHQWFEVTd5S0h5ZGZrWFlkNm5FalljNzZ4d3MxTERMV0NOTktCdFVITnlMc2VPeU5EZ21IaUo0MWxYdnE2MzhSekRHaXM4V0luaU9iL3BiVHMrSHNRVkdQaTZteEcrQ1Urb2ZsTVI2L3F4M3BWUCtHUGdxYTBVMGxvOE1WbUkxY0JnU25QR2dyaCtKK205VFZnOG5pdnVhMEVRUDd4YWk0NHJ1QzVnc0FWT3A5YkxzRFhmSFF1am82SXBCbXBmYmJVOFBEYXZacFR1SnRtZmxWUXVPSW1uUlE1a0tvUXoyTkJGamRpSEgzY0Y5UUxnRFA1dnovVzV0ckN5MjJVaytUQ2pYamRiQ0NIQjNySmhLWVR3aXlRVWY4eHU2eVRLdEl3cmJ3NHR6RmdYRE9EbVdZRW5ucER1cGszYjRBUDNxejRBWjJFbjV3aTZhWlYyODdBZ0NGNHZIOFRsV0xuaTFFNUhkOTN2THhTWUxCV1N1ajNlWEdGdFd5V3BCa0llS3UrWXNCaDE5VmVha0E4T2VQTTBJTHU2ZFlZbDlETklLM2tVMXliSCtBNXhZaEZJL0VxU1gzdnROczZWNWVRZ3hZTHZ1MGhZRmppRytuOEp6cUxRVlJPaVZhOFhOUURZSnREQWV0UEZTdUV0R0kzQjhybmJick5vOVRKbi96M2xSWXEwZWNCSWU3YTAzdkxFU3doS09tMWJHVGsya1BNdi9TaDl3eUNPbUlvcmU3SmhTRlQ5SElqb25CZmkrZ2NkRExmRnQ3ZHBTaEptVzFna2NYbWl0V3dtMWNDNDgwQ3JhSG0vb3IyTUhwaEI5UTFibXQvU0JYRnFYSmRjdjVHVHQzSVMyZlJncVRoaEluQ2pSa2g3RGsxaVMydk1CTFNHdFJQcHBiNEZFdTc2MkplaFVNUXh4TFFyZTM2NUNLb0pHdkp3VmRlOTFYUStiRHA1WnNNdS9RSG1MZ0lUbXdHWFNwUUZRbFFCYWpxcXV4bHdJT2UyY3lmZXphU0hJb1JOTGN3alcrZXBubUF0bW1XQTlLVTI5di9jQTJpdVdiajlaVjdIUjRhbmhIa2pieG56S1BIbklaN01tNXdBZjJvLzN4VWhuZkgrK3F1UzIwVGRoYWxIZ05odXNpZFBLV3lLV1Y4WmpGTGdiMWZYMnI3aWZMeVV0eHVLSEhJZkNXWFFKL0RLZVU2MXZ4bVBUMzRNVGkyUTlyNy9zSzFDWXVIVnFNQnNndGZlbm4zMWJVekNveVBOODlLaU81d0h2ZXFuazN1eUhuSlNVQlZUUVEzTnlSUG1lUktUUXZXRUJaNFFXY1NnTXlaRjBSUWd2VVhSY3A2S2ZsRjA1NmZ3YWhTaW9QNjIyVGRjVFZZaTRjQXdTWkxXRHZmam9LRkxNb3dQUXB6bjZvZ1hIYzkzZkZBNU5abW53c2xTdWVzT3lOSTFFRTNSTThremF0NnRoa21wT2lHbW02OVluOHlOdXh6MVl1dVBXZWtveWJrZWUxMDZUOVdUUFhvNDRlYTlFNVFIMklnNkZabjcxNkRCYTJGeVhIRzFCK1lmbm1oYkVwQU5sT2k2MUJvR080K0czV01KRG9rSlhqOUdoTnNGcWRhTGpBMXBraExQKy9tR0Nab1lzeE5JK0Erc012V3lvaitQTVdlUjhrb1J6K3I5cE5WRVdUNzBXaGlBa05Ucm9qZHIwc0JMd3hJTTdENHpUK2NWeTk2WkUrQUJpOUNxa005Vks3aU9ma0pWcDdBcUNxUTlFWjllbW44ckI4emZvUVpVQnJWZDZZUzJBcWlURnQwbko4SGZQR21uQldmM1hpNUNneVdvTEFtSEpwL0FmVGRIQjArTnM1RGxoTDZVSitPLzZ4eXMrQ1dWS3RMOVM4ZlZIa3B3WlpNSm42alZ0aVVUdFhqeXdtaVZYdzlhNmYvRzdRZDR0WnRjb1MzYXl0eFhZQTlhR0dtRWVCb2JqaWFtbWhVYU1EaWNIM25sT2tEdnZ6MTlOcVdPdkhDMlNNdjdPUUh0REl5a1llclB1b0x6NlNRTk9CdHc2b1gyU2ozWkxJVEJEY1dOeDlDdVpZWVZhRSt2bGVYbkFUcnduK1BudVEzNGpMNTJ0cDg1YUlPazY4NFNVbFE4dXlPMnQrZUlPSG5kWjNveEQrQmNNQWJhL0pWeFJZVUFVWm9FdzNEODBXV096MC91bCtmWWJoRm5mZngzUGdPeTJMTGl1ODJENUZNU3BpK1BkNEVrSUZUZ2Z2N3AvMHZuWDF3cDBWcE56eVhzLzVTLzR6MFJGUzIxdklGNjdrMUVSVGZGdWhMTS84ZmRiS29nbm9oTXFUTkYvK29xdlhYTHVKQjdJSGVEZG4xWDJlUGFyTEJFcHo4eTlDQU4yZzVWZEU3RWltZWtBT2hrdyt0VHpxZUVzZ3lRTDRpVkRuV3JQL1JjQmQ2Q0RtMTYvNXQrSTFTQXhDbjl3bzhrbnptcGc4RFlQOFYvdkh3OFN0dTdjbGlBdCtHL1ZSNFhQTlpYV0YyclpCZVFPNzVvczJqRkpyYnRrZmhOOUJ6SFQ0SEdnWFRqeVR5OE5Hc2lRZGVPdzEyR2pZS0N5eFArMzRrUkhacVlzbjBwRnZWdWJCMCsvZW1LUmdpR1hOUldRd01TdkFCMXh2VHByRDBaeXQwOEJqUC80VzlIR05mTkJjQTBRYjlxRjVoZFE0ZERxcEtBRkxvSVcyZ0ZFVktPZ2FudzNNOS80V1A5Y2tQMC9nNmthSkRSdXJ0eE5nVCtQanZXWUVXbEZhODB3S1lDa2QvMFpDaFY5NG5qakd5ZzB0OThQejNBTDJBRkFodlJSaUp3ZGZSY1FxcWhXa3YvbzZYNDVkNXcxWUxKT3llM3Y3cmd0YTdZYTBqQWwvYW40Mm5nNVd6NFM1d2U3bjIrMVc5NEpucG9HeVY4V1cySFlqS0xrS21wNGhCS2xOdGI1eTRXMU1yc0cvd2ZxMk41WHJ6MmtxaGRQUUwvWW94Z0NRZDZZMktOa0FEVnU3VHh1Z1FSV1Z1TkwwQlVqM0pSRnlXTmVDbUI3NFdzejU0T1BuYnEwR0ZGeHpTa29pSjNSdHE4eUVKTUt2T01NYWxGS0g3WUZIS2piMm53cktWZnVVVXVSdFRmSkRpQnVhRUhIb1grTVVyTTJiQmFBc1Nkblk1UGpxY01Cbi93d29qUXh6dDJNb09DQzNPRUFycjA5Z2hoc2oyTTBtdWU1bnRRY21jQzFSL3NLM3pmU2hHSnVhelMrbUpVZUt4azV1MzZDWWo4K1NKQ3E4WkV2N2JOZjErQnl3R2VEUW9UREdxNlloMXhXM1N1d28yTy95a2F6VFBLL1RkVk9JQ3lpd0s4TXVRcEsrRlgzbXFTUHp4Zkx3RkovaVlEanMwV2dXMmtxWFlnbStna05Ub0I1K2pZSDgzWGx0MGNidEVta2tCYVZHbEh6NjFyVnVXenJLMXlqbjVuWUhLdktDckJQUFJ0aDNBS0RRUUI4M2ZkcmJnSWVJZkIzaUh5YTVOUHBFeXhiem10TjVEbms3R3FyUTR1dTRoM1FTb0hVKzc0enMzMWNXcUl4NFNaMmJ3V0x2SXhVdFI2Z3VmWmhOWm9NY21TQjV6MU85VEt2SE1PUkQrVm11aXF6c3lKS0ExT2FBcEIrYjl4NnU5RlR2VWthbGdsMHI3cmFWK3dScWltYzJEN0Ixei9PaVNhZ2RkNVVNRTJpZ0xHVWNnUGxNU1gxVnNLUXAvOXlEaVllaTg3S1RCQTJOUENVbWdhTHdWZHZRRkZGeFdwMnZHQ1kvS0NVdnh0M0ZPdTZ4SWd3UzRWeWJ2Ymo2ZmVVQ2tyUVBwTy93UEhKUGhBb2JTai9hYTVZclV2akhNY1FrRFp3ZmM5bXZnaHJrL1BJUHZjSmE1SW5oVkJmamgzWHI5dkl2QTRhYyttK3B5d1MvRXFrU1g1NXhnaXlqMFRCMUVFME5UM1cyQ1BGZFZEODhQNzJTcGRGekhTLzZYc21iR3RNOEpFL204ZW9qemQ0UE0xYk5BRGxpWitYRy85aGJjS2c2UGZ0Vkt5S0t0LzhCejRsR3NIeVQwVktqMnZER3AvcURHQmFqU0hycXptcEVqVzVMWHNiNWtUVjZIZ2JNY25QVzJkelFqdTlOMXNJL2dQVmxnR21rMGJIS09YMldzMXE0YVBpemhjTS9YaUo1RVpOVUs2YlpOVWVGYVVKVlR2R3hnbFJVWTd2ZG5vVk9lMFJhaG8zaHVoMVhEZVRsSHBrLzJnQmpqaFVRWGU4Rk41QTR6Y1Jxa050S3BTVnEweHl3OWozeVFsUXhxL0xucWtscHo4bFhtekhrejhzWDlISmpId3luOFVBamJsdk4wWkZJazRsaWVqeDBsVkFDb0t2cHNUOStwUW9MWTR3ZU1IUnpjdVZDNjBEVUZrYXFMZmNsUzRVSnRpNVdLNEZFM2RZY2MwT2lsWDUwdXNjTEpvbWxSNnBYcmlENkVMTk5CV09TTXQ1MENKalBreXQzWm4veGoxZGxQVlAxdDZYRXhLK2Izak1vVUxMUE9yRUd2akVMZkFNTTFxY3VCYjBBaWprSXVGY2E4Zjh4YXBVbGt2TGptbUpXN1JLOTRyOEhhUHp2bUhIU3FYOU1YZGl2Tkk0QStKSHkwVkNlNzlVWlpKdnpNR3pwbnNqK1E2azNFSXREQmlBMTJmVE1sU2JFT01BV0NkUXE5VHR5VWlBYUFxSm96TXpyeUVnMGsreVZIcUNjL0R5SmNDRTJWNFdYSWhFbnNPYzVjOGY0Q2hXZlVhT05oUFBXb2dwRHMvbHlWQ3ZwM20wTlNmckFKS05pVnk1YU5DOWdaNmM5QnF3WWdqL2NETzNrZGFtNmdDamhSK2FrQUxGWW10NGl4SGtXeEtoRFRHczVLK0N3UmlLSm52eFA5ZGJ4UlBDQkhiaVZhOGdzZDJHdWlOSFpEOThNTndYTWRNQzBNdWJWb2RkN2RueWszVVFGZkNJSUwxb3NQeFkwWko2RHZaWHd0WjJJMHRoNmFxbFRNVUxWbytsaFNJVS81cU82M2xUU2EzTWdQUkpFT2kwQUo4L1VsWnV2Z3FMdzlkeUVEUW9IVEtXT3NxKzZmem9BeXZJcHYxNGZMYVkrYnJhUGQ2TmtTYXEwUkNsTWVuSzFRTEg4N05acmlVYWV1Q282U1o3L0NmVXQySzZWT3QwQWpJSzJqUjB2b3JmNlI4K1RWenhaYitRZExpbUg5cFU1dFFjNzN4VzkzUVJQTUd5L2dDSytSK1l6bVY0ZkhLNTJHV0JFQkwwNUVFb1RZNk9ZRzFXV2ppNjZkV25WVGcwdVBOdzgzOXAveWpMeGtDZmRUYUgrdjZoVlVDZDZIbFJPajZXOE1pbDZBWUdDN05JMitxa1p2SmgvZEF3L2lRc3BYUU53d1dIcjZzbExJcDBoQkhZVERoL0o3QmE3WlI2Y3AzaVU0YlNYZG16aFRhaFlEZXY0eUtpSUh5TjY0RUFOaEk1T0hZdjFHNEtYZklPdlFpellXY2hQaHpRZzVlVkdOTXhzcXJ2V1Z4anRJYmtLdUh6RStJY0EyTlo4M0dLejBEOHo1em1nUm5vSkdLaWdzZVA5VG1NUzdCZ0FxdHF5aXhBL1NMYzFLRVVXcmhYT1E2a0E1WlFSYXpwM3d3U2E0MDRjcHBCbmZzUzhFc0VwYnIvZ1h5VzM2Y1o5cHQxUmh6eXhHeERVbW5aZUJ6L1VmMUFQK2d5TElnOXgwNHUxZlRobTJ3L0gxWlhHdlZxc08xVnF1dFY1Z1VoRmtka3dvQ2p6ejNGM0ZVcjF2MG5qR1lUMm1TWll2b0YvZlNkMVcxMWM1Vkloa0VPMDZVUzV3WVJtSFZQWVhtWm5iSzVZSFE4cGtJREoweXFzc3FGSzM0Q3VIRThSV2IrRHI0b21rNzc5UU9PY1lvbUFNWVE5SUx0MktVazJ1TmxhaFcvSWpHdGVudUdMeGIvdDNhRm9WejRvTndNWjdpeXA0dGQ4bWR6Z0pBZm5DY1l0a2x1YkdBVUI5azZiR0M1RFNrZjVWRmFybkdFQld6NjAwVkdSOFF5d1oraklZRlpidEtUMlFkRE9ZUDZrN0Q4cVZnRVpCeUdtUmVkWlJXYVFEVGdnTHlOZ0RENnBRd0VlU3M4MitoVHhXeXBxd1UzenVBV3Fmd2lsK215dHpWbkt6dHl2TUZKeUp3UEZhUHI0WjNtVGp5eENSMkp2Njc0SlZHR01VU1diMGwrR3RjWXRkK05CR0Nod3I4bUIyaGx5Y2NnZXQ5bGlKaFFFYjBYZ1hmZ1ZSbEhsYk8ramxaOUNjQWV3ME53K3RSY1dnTm56L0dMOUt1cjdSb2hSaGFZWkJCbVFBNkpodnprYXpIUmNkWkRuMHpEa2ZCbVlQMVBmUWpQM2Q2cXF4NmdFN3ZyYjNsQktFZkszWS9uQ2U0Q09kcHIyM29aQ29JcHNzR1htcUU4Q0dwTzJiRXdrU042dXFlcVI0VXRXUit4c2dPek5lUjQ5UFRMSnBGRUFrWGhhNVlhZWNKOHQvS1IrZUc3L0hLVjIzelBaQU12SERDMXJkeFEwbCs2d2xJZ1piVXliakJlNnl1c0w3aXNSdXVZWXdnNCs4KzRsaWEyb3g4UkNkdm1YbHQwMFpzaEJuQUlmTGtTd0lxVXpDY3NEL2QxWkc2QXo3MjhMNEZDSXFCS3BiQTZiemtKODdsWVFwYmFIcHdQcHF1M1MwVXFOREN3Z2czcTlNRW4wMlgxNkU0eGliei9yTHg3Tk1EdEhjd01PdDlyMWRWVTZId3M5VHZKVkg3VEhyblNGRVNnTjVlQnk1M05xMkZkYjhteVNUeHo1Q2l0dlZFK1pqSGFZUzNocTlCYXgrdVM3VHhNSVQ0cUpFN0hHZHNITTEvOXVQTkJ5bGhQMDRMY2szOUpNZTh2MmRQT1NKenlRb3k4bS84RmM2aCtYKzUvbUJWQTlqQXNHNHZteC9LZFVXK05YeGdSdC8vU1MySWI3YUdJTHNqT3orWlpRdS9OTWV1QXNQMXBGUlROOTBycUlWVUxiSjIwWkpscmpvWkQxVnhIRW9ERkZHVldDVk9UM2pHSyt2RkQwNmdjM3lEVVNuWjdaSGpHbXc0WmlBZ2xZMm5tNzhhVXBYeEk0QmZVSHFMNllRS0ZEQ2F6VUlyeUxpNTNSY3psYVRoMHJ5N1dONFdwV0s5c1BKMEo0OWZ1NlJHVU1ZWmQzK05yUnZFZE9yUzVuK0VKT1RrcjRsTnpvOHZhd2NZblIvbjFEcTByQ0h1NW8yQkdCRUhBQkpic0ZMaS9tbFdGTzFNanB2VXU2VVBKalhsWHNlNk10QlJPVC9tUWZ5ZWdXR21GUlE3US9PK3JKcDQ3MSt0UUYxMCtidmtFeGZCb1RRcmV3ZDVVd2hBVU9EcHllVythSzZ2eDJBcm9VbzJiR0JaL1pqY3NKRmZNWUVNc200N0xkUVNxN1Q3cGVJMkV4KzQvOW9JQUpHZmhpZGJYQTlVWVBOaHhpZ0ZUZzgzQ0VUTllmWVZrb2FtYmozdnY0TVpOdEUvd3JJZlRndUJOcWtRazllYkxQVG1ZMlU0VUN6YllxUEtPNXZqYVpYZVZrc29iREFKemhWam9VN3A5VGRGbU5NeUx5Q1FKcnlCU09jbTBoRmsvcGN3Y1YxNUtaLytJSXFlUUdQa1RiaVkxaGFXU251UVlCZXlXNXVTUEhHdFl3MjhjUVMvdjNyVG9OQVVHVkJTUTZ6cEJ0NENIdmFPZkVKaHVESllaQ2N4dlBlT1N0ZEN6YW9TUW45bkRlOHdEYzFNWHJKMCs5TjlUQUtjUzZ1OEFOTENMWTRVZkhMR2Y4ODQvTEZJbjRPTE9sUmNObDdGUzFJSmd1MS92TG00SU5rZ0h0NUlTcDJ2QzNNRkpIejF6Sm5vcG5LUzFBZ0p0Q21oSlJaRGFXNndpczhDSjBLQUpXMFl5MCtrV0kzbEo5Tjh5cUpodDY4Rk1OVmdrZ2FBR2k1THVLbWtaV20renRLdmY5Z1Q4aEpyWFprTS9RZEhJNnd5OUJxVmVXYTdnN1pNMVlMYlV2MzdZU25MbUdzQ3JsL1VWaS90RytmWmJ6WTRiR3llMHpIMDhWUXBHbXlkL3YrK2ZTOUV0YXNtYmtRRUlZbm1MWkx4Tyt0TkhwM215SUd3WUJaVlhqbFd2ckNpUWNzUC9GdTlsMEhXbUxCdTNndnVKNHBodEpzWFhsbEpkTThpWklRUjhaNnpFTXMrY3FWTDcrVFloeERkMGMwbDRzYnlJRXc2TitWMHYzWmJVbGlkeWVrZGN6L2FJb21HZFp0bWRJKzFRVXJySHc3ZURYVCtHM3piVFpNWHhwRWdKYzR6WTViSDVhejhlSHp3b284UVVsZVVLcFZScnNFckdtU0Y2R1BKMk9sdEtZTDYvQzR6eDRySGRjZnNyUVRjV0JtckJXTU1pRmlVNE5HdHBZZUFDcVlhZlJ5dThqOHg3bHRwM254VmJzUE8wTVNvYVI4dHY2MS9xK1lDcUhYM2g0dnk0SHpqQ1lFbCs0WkR0ajIrbWF3dWo0SjByQnBjRHcrc3B6dUNRMmtoRmJrczA5bFBHeEs4SFlKbDBZL2xOTFV4R0xaKzJoNitFRlNhRDIyYll6Rjdkay9FaENXaDZ1L3YxSFVWS0Mvci9XbDZKSHRkMVY2OEo5emRPVGdidkp1UXVnNHI0dlVWM0pKb2xRUTV0ZWNIS3FjTm9Zak9JczZCWlRsZkIreUhHZkdkeFRLc0d4YlUvNHRhS3VIOFFwZC9NN2ZJRzV6ZWJycGlESFY5N1Q0amlVTnQ3SzY0L3UxZS8rZXJYVjM0YU9qZmRkY0tOTzc2RXpJZjFwZkQrS2l2QnNSbHpsc2pqMTdhRFBxL2xuS0hRQ0xzRCszVEswMjFITnpoWnl1d3BMUktTM0tFMFhILzBUcVVPcjNWcUxNY3NTWk02MzQ5UUpEem5QRytzVXFlUzZ3d01XcDI4VEFvREtkbWp6VzZmKzJhdTcxSHNPekxJZVdlbmNSYTVKYXBLa1ZUWXB2d01JQzh1MkwrL2hZR0ptazA1ODhycTZObnFlMDQxTk16VTZsajFLNUttU2owWlJpVnB6dTJGU1RsNFBCWUhBdWhlNWR0d25SUXd2dk5xSUVMVnhLTUZXZWR4eEI3VU80enBZUmUyeDB6SDRYNnBJMm00ZzZZZENzMDh2UjlCN29teS9nb1FVWWJVWkErd0phbXE3L2MwRmhrTm03NE1wMDVOU0NLMURjeTErOXFwODJwOFhWa1VCNCtTc1ZSSi9UcXRuOHYyZXNtZW1yN3pqQ2ZqTGljTWIwNUpxTm9MNnp6ejBLYVlrWGVTdEJyRjkrVDdFYlpUbzJGYS93UzVOaEp2Um9aYzhRVWZTNDZIWDhISVo4QTZMSzh6S3RST25ha0FuRUVGb29uVmx2WVI3MXhZdUJBWGJqdHhmdS9idGVOOFdrQXJCMy8vcXArM2J0cGkyU0lNeUs2clgwM2lDTG56T2QyT3JQbkQ2eHFnVlQzNWU2TlVNcE43RUpTejBEUlJ6eXplMUorRHgzY2Z4ME01NzdXODRxaWZENTFtWkc4Vk5iQmYrNVB4bUdHckdPbWtPK1E0MVluQ2t4NTFEK1gzQ1hzTkFqYXovWGZjUEpVWEowMHZhUXlmWUR0bUZxNGtVMVpIZG5lcDQ4VDRJc2t6UHNZVDlvcjNyZC91YmlZTHFlQnFqbkdidU5XYjlaZFBEeGtlQm1Kd1lUanNUVStWdWdRbXR6NStDM1FCWDBwaVZoM2Q3QksrSGs0bU8zcThxSlZRWGVJcXM0aEt1UnZCZkl3d1V5S2c5VzF4OGR2K0V3RVN1azJCZ3MxK1pjM3d6eDRlR2FzeW5XczNWMzYwd0gzZktYWkZUY2tlSFpkZ3R6VHFjUVBDMmhDSGhTWHlGTXlsanZybmVMRStjK2IvWVEwWGNEQmFtMW9BUHp2S21tY2dFUjZBcW55QzMySWM0SE1QNEZRTjJyaDRZMm50cmF3QnlWKzlvcS9aOGhkd1FFUFlSWWlFTEJDbnVHR1hEUWJsM1pMdVVvMHZmS1UvQXVNd1lmTlhtTk0ydmtuL0dScnBjNVdEUCtNRUw4MHRiSkRaZkROQlJmcGZjdlZwZjc1dTBMcmtJSWpuVTRhZGFvbFpXekIyeWpJVndOckY3ekYvL240TjV4SGVhR2M3VmgxRVlSZGMwaDJsMjNxRnZMQk5RNWtIYm1YOFl0YTJWajREVTZlQk4zWHlKQnZKZjlpTDR4K2h3MWh4LzdFajVVOEVaci9RaGdvbmk1cjlQeEJmVTNmZHZYSUNHVzlEelNUN0dWMTQxYnZ5TURYYmxGRzVQaXpOakpVVkFXTlN4SUFTdHo2K2VEQWJrWWVBS1RqNkRJUjZ5c0Z2WkFsb0JMQ2dTZE1GZDNvbC9XWERRaDNCYkJ0THFPOWhwMDhCZnVtWmpMcFRKR1JBSUh6RGl6WFpmaGJncWVqTlNTMjdCSVhRTFYwbXV3emdYR3FZdDlNY1N2dExXbzFGb3MzazZOdTJxR3lGZnRxUXlEejAvYm1ndnRaeWlGY2UvU0xZbmp0MlE5Qm5sbVVWQldPdGJEUHZVZ09TaXp2SkRoZGlTa2JMTFA5Nk1KN2RLTzNlVUsyblpucGI0czRiMlhHRjRUNmdDNHFvOVREdjl6MlNZNFJmZmIvUmpQczc2UDBZaVdBRHBQQi9uUWpDMnREUmx4dDRzZE5DSWptTXNMZ1UrY3I4Y3B5YU1TWUk5bWFQNEhId3cyalRQa0dLdkY2SDYrREZBRitqQVpLVDlvaTIzZ3BaMnphdkUweFhQa0Y3YTJGVE5KM2J3eHZzSlYrbzBmWFpBa21vdVlxNkIyKzZjY0hoblVJZUwxMFF0WmFQb1pQSkI3L1hyeS8yTnYrSkpGbVEvcDJOU2lPNWJZR0E4ZWoxdmg1UWxXaGFYM0pNczVnTUJueXlJZlhJTWY0aW0wV0VVbkNQQUp6cTlxMDRUbXh6eTduR0tLRWYzMWtBcDZJRms5NWFqMEFvZ0w3aWxqTFZKbE9YTnZWN0J3Wm40ZEtmdVp3ZVNFWkJxeStNdnVhbDBUVkRIaXdIdUl1WGJ2YXcrT2tVN2FlQWZjazBIYzZIMGpndDlnNlJ4YjZkQXVhaUtFTjFjVVl0RDg4eTBiOUFycTFxNk1MOUIyMC9GdW5UblpORitJSGdzZzY0MUZmbGxERnBRK2RxcklQS1E4SWtMeC8ycHB4MGl2UVNyZWhOYWY1ZHd0QmpuUEhyb1JHekcvUldPZGlXMENPUHplcHhJcWNzV2poZm1CWFNVRDdZQ3ZQbS9xVEdjU25oY3JpRktldzZhNXMwQWdLMDNJMWdFaWZYNnk5MGNKQlk5UkViUTd5Vy9YQit6QVhOMVhaUVZFczdyKzBhanR4OEt2VkJLSmtzS2o1WUZHZGhFZW5uTWJ3Z0NKSklNZHQvcEpENkZJY05WZWd0MkxpUVM3MERBSmVpTk5HODZkUVZOWU5abVlFZm84b2EwMDJ4S0xoMStySGxCWDQwaVk4V2x2N0Zxc3dRRmt0cHlMbjVvU2RvMWpCUno4VjNhUklPbWhTbnJzMnd4R3dHQkVWRVh2Um04UlpWdlNRMHhsS01WV3M5WTdubm1KOWpFVnVETDA4RDJFUzNwbHp2Q05QM0ZwS1FlU2tuRmVWQlh2NVQxWWswL1g1dmRqMUoxTFlhNkZmeHhydjkwT2JMSEFSa0NJK3R6NiswaTVjWlRpbnZnSVlMTVZuVi9PTCttNFJDc1R5Lys5VlFQc1l2NlgycVNTbFZkUTNLTTFTT250TU5VQnBiNEMwTXNEaDEweEhRMGNiSkswZ3NSNlg5M3J1NjNCRFliUlptUElTdDFjYXNWd1ZWRTcrdTNsNTVYSkdKMEV2NlMrMnpwTnFPQUg2NlJ1enBWc2tYRTZYOHg2d0hPZnA1UEFJLzdZRzNab3poMVUyN0lYR0VFS0ltMTNSdC9uVEUzcEtXQTdpMU5GZFZRS1EwQ05kcUVzQmtqaXVNNDFkZDVySWJSNERNbm9EdmEwN3YxZXN4WUJHVTRKV0pVSlF5ZWpZYkk5cDdwcWpycEhaVU5sejJleFgxbFRBa3MrV3hZNkNFeG9QbFNsTk52NkFJc0UwVmRQbUhPajRtMGE4YmlnRGVsVHBJTDFXb2VQTGhibG1oUmxrUERLaVp2a3p6NmVHOHZMZUpqQ0dKTDErVkZhNFFSRUJWeXVoY3BabTF5Z0ptOWt1USs4djR5RU13MFZPK1RLZWU2c01GUlZjL2tTNElpckp1cG53NDhMb1IyYVJrK0d1REJaMjV4bktGeGRTWXFacXZXbEVjZW1zYnpsN3d2UWc1ejJ4S3hFVXNxdXlHeml5emQvWCtYRmwvY3Q5S1JMenl5YjZDb21JTDhXYW05eDZMUE5aWHZoTzBRUVptUThUMk1Gam1SSjQyV3lSemZ5TEdrSktmdDk0dU8wWXk2RmZsbzNBb0lFb24zWEJ5Z3BpM0plOTMyVG9VNUVLb2lrdnFrZUxGQUNwc0JONWRzZWVtaU1kSHhPSktyVkpEZFRTMHFDY1R6UEN5ejUwNm95RU5GZGVsc2t3ZGdobVVuV3lYSzJXZUpYMkNCWHVkTlVCT04vaThrTWR0Sm01MlJFdm1HcVZteGU1YXJpY3VUQ0dMYmdadFl2aWdUKytFN3hsdEVoL1pnVW9NUCtkOHZhUFUvSGRoWmFVanNnUThPb3FaZWV6dk5SMkpGbTJvbitJbGlWeVlRLzU4TG1aMnN0Z0tvQmJzNFNsbHdpVHBOUnc3ZWNMMldSOGJiZzA1YVROMDBDOGFHV3RSZVdTc1lzaXJKMEswSTk3ZmxJMmdKUlJONzE3d0VTcnlXYWhYVUFGWkFkeUQwOGo5U0laUW0rd3E1R2tvVWtLNWNRM3drMXgwMXg0ZktMUGdQSWo2RDZsWml5bHF2V0d0bDZLeENmb1NRWGxOWklIZURzcklScWhJTnhkckNpbk0waU1Na3ZlTnhocXJFemhuQm44RjZuWFZZNXpVREx6T1hwcDMzOEkySHljRmEycHVlT2JFb2YzSFFnRkVNbkhTMy9DREt3SkF5WWwzSHlBNFg1dlhVRThNTWE3OWdZRUxzZVRmMElFVUpSc2ZTYTg3M3ZsNm4yOWxGcStHQ3FGMUkrbUI1UFN5TEZ2Z0h2NmhHNUhkMTRQQUhUS2hZK3h6Q2dPd3dSWnh5Z1B3TkVUMFVpTzl5bkgwcDNqN0dBRkVzK1ZTamw0QXJoSEpieVNvaFJMZm02QjdGeHhZSkxKeEpsUXI1VWREKzVWczBuTTZDZWhTWlpOWXc0RnpjcFlvTDZuUyt3R0dTTktMVkxYZ2JndnpBYlQ0QjFKNEdNUzE2SUtNbG81Uy9kek0vTk00TkkrYTFGdWs0cXdhZXdvSHFHcDc4dmdwK1NrdWhMeUFWaEkyT3I1MElkNExsSHdSb245bzdKVDNEMnBpYmNoRnZGaTJWVEV4NmNMWC9xb3JXMllHU1NtbnU5K004dGVXOURJUkgxVGZhYnVESXVMazE2TkZ6M2tOcjVRTFBHQWQwSnpOMklZRkExNDB5cWZpOUxmQmNaSTNhVUsvR3QyYmZNTWs4ZXF0dE44YzkyT21VWUtVYUhiQjlDOWNwRXdhT1lzNDlNenR1R3RJMFZNcURESE44SGlSUDU1QnBSSUp0SVdiU3lpMC9MT0M5NFhoenFHVnl1emFWYUJmZzBmKytzVjh3eTd5dHhsUVlBOXcxZWpFMFhhQ2twTTl6Yk9yeW1mNE9yRWFJeVFYODRaOWU2d1ExY3pJdk9paG5TYXEvZmNGZGt4SmNNekUya1djQVJ3V1QxVTgwZFc2Qit2NkhkY2xXTXlNV0xZcjQ5aUtXcmhtN28xeXVtSkt4VkdpdjFSeDNUdzYxanJoK3Z1Tmppa3BGUnhhMEY5RzdaV3M1N251aGFJZVQ4WlJqWXp1eXE0V1pCRVhzNEN5ZnZtWnhHY1M0L0cyYVdvbjJPL1VranFyZmRiQlVGMHlhdlNQZE5KYWNhYVp4RlFOZWpHRFBLN1NDRjgyWHhpYWhiTnB3RnMvdDA3Z2JDSmtEVXZ2S2pxYVl2MVNOSkJhMjFSS3NPdUdKTktPL0Y2SFRqYzFRNXQ4bHFMTDRlODNnV1RUNGF1YllHdEUrRDRlOXpkUFBvMlIzZHZHN2JEckNRb3NwNjJZaFRhVjNCL2tFUUdxdHp2dTU5ZmJnQTZsRnlHZTd1cmhZcjNUV0NCRllCbXJFcEI3OGZXblhVRWQxejBMU3pNY1dMNnZ1aDRDSllSMHRnMWpYNEgwd2t3OW1rYk0wN01Yb3BMSjJSdDcvYUwzSGwzTWpPOGgvMWxxTmxLNzRRVGJna3VybWdkMjNYZmxFY01oak81MlkvV3N6K0Nxd2tCQ0ROOFNVY2QwaHZKNnNyaWtVUmRES3c3NVpaTXltczhOZHp2emZzWHJlZUN6cFZhUEtia2dXbzBCbEQrcVdxYVh6aVZhN1lUU2V6TmtDRDFVQnBoTXdFM0lGd0czK09qYTBBSUxid1IrVk1qaXJySWtSUHQrRE10cCtPS0xwa2lFMTVBVnYzam4xOWJyWkdaa2hoQXN1VDJzVGlXU2pMdnhKa01JQ0FHZFFZNkNjSjFibVFzeWNyWENDeG94ck1FOEI1azdhWVFrbDMxaDRrbW52bVVBMVVvNWJHRUpremViUU51TWVWSVJ3S3I3c2hNM1kzaW93enVPOEptODMzQUxoamVEYlI5aSthakdkaXY1bnVRY0JEVzBQWjBDQi9HSHZubUU3MDJlM2lFbVdLaW4vU3Rta2JmdnNWaDltWG5qTHpaQ1JmaHQzZzVGdTZPcERTc3ExRFNWVWllNGhOVGhHVFNUV2tPaFRLYkFSdjU0QnhwMW0vQnFXMENmdmZVSk1RWWNpK0h6UUJyQXc3bEhKSThrbE56cTF3Ynd0eGYwenpURklwWVFjc1UzZGREV0RNdWNpS21OK0JISjQ3QjZGa2dYNHVSNVFTV3pMcWdOMndRSzFhTHAyaGdNSkdxTUlJNHJMSzU2VmNEazg5UVFodzZjeThQQ00xOW9sTnB1RHdkclFGdlArNzd3aXl5S3g4WjRNVkpOeFY1dkpXT3d2RithRG91Wk1XNUhObm81ZDk2MHFjUFBPODlxWW02Wmg2VU83TXlGeDI3MmFXWXR1LzArVVo2ZVRoT1Azcy91TUdSYXJyWU5HVk4yYmtsMFZiTTdaQXJQMkFuQ1FMdVBvSWJrcnk0blRTL1JzSWRGbVBnOTh6ZVlJNFIwUlk0MUZRc0J5bTFPWG5KY0h0bUtQamZFWHV1alZRR2ZDUHJDWnNhVCt2RmJNRldJdlV5N094cXVJdmRpMkRWcDMrcTNFM05HRzA2ZC9jejc3d2dIR1dyZmN5NUxKSXpDTVpIa2s2bTJRblpDWFlWWHdNc1ZoSkk5bkpjZ0cvQ3JVNWxnRGIvRGxWRXNYRzA2QkhJdXFWZm5UeUxkQVFaWW1KbEVFazQzcGRnRjY5VjEyWEMrc0I5VzVUZm0zalB3aUhuL1ZtR3N6a1l4K0VyNDlDTGJ5azNoREJTS3V6RGorbnpDbzc3Wk80MEVJUDRaUk9kU3dXbGY1Uzh3ZlljQXpqTmRqL2FaOHVrbnczdHVyMTI2UmZDek1BK2NVbzVtUGFaTDljVnAzM1gwbVJUVUlTMnZndHdEUmdzU1NYNXhjSlVXUjhnWmJkZXF5cVFFRUFlRHUzK0JNbHJnWVAyU0gvbGUydTF5ZlZGbjVKWDlWUTA0WDltbUFCUi9LT2QzckFZcVIrT1F3TFdhbzlNWFZTMXkrME9LbzBGbFh1aXJLdVBhWTFCUWJZM1ZvMDVHZi8rTit1NHJEY0ZCUXFpQ3JZaGdSQUVqdlZXOWVOQ2FPc3VrY0pXRWFEdW8vcFdDWUdKTGFkbTRzc1RDUHZWVkVKTkJmVlhBY1RJeEg0RUZ0V0ZNSlV5NW9mNTBRTlhOWkJsK29SdUZJa2RidDA0RGVVNmoyQTN2enpQK0lrTWFoTEQ2ekJWSnYreFJCSWM1Zk9Edm5KTW1KUk1JOGtjeU1GcXhwZVdaQUh4QzY4dEdGTnlsNnl5R045NVN3TllYd0RTSVFDUGxMOWJ6alphV05XdnM1cHVpUDJsYkVCbER3NXZDSHRWbWIvc0Q4UUJnT2hSYXNzQ2h3TTVvNWc0bGhsRDR1ODZ3bWRtVm1obUVYbkN5TGVRSjByUnRxWUlXUmhnNzJpZURucW1Qdk9rRFRXdEtSMzhUZUp3cksvN0lSWWZiTnNweWdyVTZ5VjlZdEp5dzNJM3VFa0RnYlBycGNOVXBJU1l2enYzYmVGZzNaTitzd2VkcWYzSVZLa2NkaUFlenUvS3BIR0hQeXZYOW9UNnF6VFMzNDIvRGVuVzljdE0xOTdVZkZsNHJrMjFLeFNtYTFLbkxJV2xHR2FzTUY0K0czZHhUbnFCc2N1bDRDcU5kYTZReThpdGE3SEN6S2xZYTg2eWxqbStIUUEyQjVBckpvWnk0TE54ZVQ5aXpGdVFoRW9FaFVUTkpRajJwQ2MvTzQ0aDhHcFFYNlhncGFBdkFRSkxWTnEweVhHRmJ6YjNPNTRYUTZzbTU1NytsVDNBK1ZXUHlDSm4xTUxic3NzSElkRmhKY010QkZRWWkwYlMrZXhRNFJxNzR4TkUyQ0lSU3ppM25qNVROeTJBb08wZ2R5QkMwLzJpSDY3VUI1ODFqbU05Mk9IcWdENEV6QXp5eERhdVBubElkWnUwbld3QjRkdHhXTittZXEvZmFJdVFwSzJob1JQL1VMd0lKOXIzeHl4dFh4ZkZ3SjNZcXVYbGRTRW54b1BpWUQ4NXUwT0FIdktPRzYrM2VCcmFVaU9ndmRmcDFFamlyb2VTTExGdXR1UFBWOVhxaEFSZVlQYVJ5ODdPQWtWNXR6U3F2eWZ1ZkN2T01UdGtweEFwV3NKOW4rY05NMnVCV3U0bGoxb0RqR2FzQ2ZDdDZjZmdDemg2VWJaYW5iTC9xQ2dmL2lIaktZYWF2SWlSTEpyVTJCdXpkc1A5N1hIa1hMWWJiZnNIVlRsWFNvaEtPWE9KKzNMaVI2aXg5VUZMbzlxaWVlallrK1A0ZTV3QzY0akdRTFN4SnpZdDNjRXJ4MVJ0YzIreGxKYUVCeW5MTjRoTGwvcU9yZ0JNN2EreXN3QzBNaDJPaWVBNFNSNk1mTTlXSy9GT1diVnlvVUJJVUFLT2hoSVpwMkxPZ3VrazAvRElubjdzRjdkUlA2Tnc3N01hQWNZZzZrMGdkalFOOS8xd3RHVlNCbSs2THdrSSt4ZmNLOWwrSmlXZXBYdWwrL0VFZFY3WFhwLzlsVXNXNFJRbUlrZGE5SDM4RkpqM0VZSlRyRzRoRVU5WVd0TmQybEtJMTY4M2NYRlZ6U01raCsybnV1OUswSlVCb0FucllrS1ZacEFLRjlHN3k1bi9LTVpyUDJ4UHVVRlNPYXJ1cXJpZmZTRVg5RXVqL2s1ZGdld0V5UUNGVGlmODNMaGtJanQ1cUoxTHlJNHluSXpuV2wxU29BZGVjRXArSTVXbUtCQjJmcjV5dzMzTlg5NHE2SElQMGpXM05wMkUwcjFmN2ZVanFkeFYraUNSVUxVK3lBd1BYRnZUTDdIcWZGTGord0NmSWJPZytuc1cwM3JHVGYxaGFMdkFaQS9uQzUycFNEbkM0ZjBxT2lBNld0SzIwQmxkWlVhQTZHTzNtNVpPQ0d5ZW1HSzRhMTJoTTNCWG5ibGFkQS95VFJWK3BIN0lpVC85V09pakdHTlh6VitLNHdtZG1SalUzSXQrUXdVQ1JhdDJtR2tFSGhPY1FZMDZwV2VRcUJHakhrV2NjZVg4L2Rya2srdFl5c0hNWFZrOGhMaExHalVWZ2l2SzFSYTRLK1J0VWNaTzVma1ZrV1E0VzhmeW8ydGFmaEdFRFNzZmxVSDd5ajh3c0FUQkU5WXBza1IrcjdBYzh4cWR4dEVBZlJpb0dYU3ByamJMSTJEQVpaejlIQVlSN3JVSHp2aC9VUHBGdnJMYmQvaEZmN3NGM1JpbVdOcGlHc1FSWjExUnFmWmtjazlJSnUvRlBVMkRZci9IV1Vkc2tKSHVMdWZYQ3ZEYktuMEY5c00zMUhuM3pJdUFNVFVjK3RRc085bGw2am5Oblc5VWxvN2QzMmpFUU1xSklyV1FMNStTZTBhOGxLUnArWGhZcDRJZnlVYVRSQzU4dkZFakt1cGVGRXBVNEVPcDFBamVBTGM3dlpWMG92emE4UVNsM3J1NnhGcFkwL2NrRWxNT0Noa2hMV1NESExDS2FGSy9xQy9TSWZUNTBHSlpua0NyNVNnWFpSZGRYcThHYzZYTmpJelNkQ0YrOVlsVUZLTWlyaS9zbjFHcC9kRU1oQVJhaDk3R2lkTHFpdExOQmxGK0g4WG9RbWRyTTNHWEJTQ042aXpObjJPTjBPenBDeE91TTkxN09aQ3cyWkMwRFN2TnVUT0ZDR0dZZjFUWWdVYmdLMktLYzR6bS8yNWR6M0doVnBGcXM2eDR5aFpCYml5LzZGRDF2WFcvYUljRGlTVW9JaHdyVXR4dUdHWmlqYjQ3Sno4SmZVVGJseng0ZU5QYlhlWXB5Z2tRbzF4WG9uamVvdVR1SnZBSC96SCtGSzUwek9MQXRiTjlBTzZ4amZYMDlDc2pLaXRNVmxIV21tUXliTG9CSEJQa0M1SWJBWnh2czNjSDFWQWN5Mlg5MFdMNnkvMFNYTnNHZUxCZHIxT1dWdVlnKy93VU5pUjdRblAyZWM3ak5yWlpPb3NUNk9sd24wMkRoNnpTd0tvRG5NRkxmazdsQk8wcDltV2pleDdnRUZYTmZ4Rk8xOXFtYW9JU1VaRWdkVHV5N3NIZ3JELzM2bzNYZUZkekxGb0ZuT0phNHlhRU5CWGRUU21WWmFjeis1SUdkVmtFZ2pRdC9UeHVoTkdIR3RRdXpORGZNNGlOWjI4THk5UzlXa1VHTU5BZkRSTHI0aXBaa0p4VUE2SG5sT2k0WWIwNC9aZThyQitIRVhwREdDNUpwcjRmTjYyTFFoOG82a3hrbkUxUDUvck5tejQzamVoRmxSVXZDeU5pM1k1U3Q3bEM3YTJvZ0N0M1phNk03QXNoUWRiVlYyK1IyRHV1aUxFSnowTUxobm4vMS9GMloyVTNoNTYwUHJuaFIwR2MvNUdXNUR3Ty9ER3JSLzRQdkwwNDZCS2pVcDFsZnJ0S2ZFNG9zUlRTOS9vQjBHck5XM2NZZ3ZoVThsZDYxc0hoS09mNFA5NHQ0bjdoOXpkUlhEYUZ2NE9SUEhva2tZK05BOVFBNDlSbXNHTWZKTHUxL1JYdWx1cTBKNGZzVVVCb2E5ZEw5VDB5REpYdkd0dW9sbjhhWXJOem9hcGE3RThjUjczL3dYNkt3QlBwd0NVVWx4c0J0T2owcm5jYTd6dTVGcUpDNVcwVThZdDUyOVNBSTBTNm5tV25TOHpndVFMUnpmL2dSTGFxU1E2RTlUNlE4NHUxY3M1NmR6Qk12MmVCRyt6QUt3MlYweDFOSlgxZ0M4TTJNWVpwU2NkWEVLUEcxNDQyVUZXVEVVbGtNOU9qYlI0RnVydEpOVjRJcUV1MWh0bGdsdEVTTzBTZVpNSFoxSk03Yk50WWVnZXZ3UFNDbVcrUzh1RUdqN0ZUU1NWMEhiRGcxck9udDRXczhEeHFOMlQvSE9YTmQ1Tkdib1o4VlRTRDZnNnJMV2NvV093c3llRzA4R1BHNktIUGlMUnVuRWRUUE5tWTc0T2JSR1QxVkNIUDdubUJZbWpuSCtrcUs2ckR5ckVvTmpkcWM4dUc4eVpySFdCWFU5d2VxRDVycFE2Uy9hbm5xN1AvR2lZZXBBMlpEZEpBL0diZHhwSFlhdFBna1h0NXNvcDU2NGdWSFphbVc2Y3EvY2RBRGFMQ1hXdDFXZ0s3eTExV2FRUjkwWU9lbjhCRUNRNTZwbUpiTHZ6emZXQmhVVUpQK2RBRUVLNG80d1p2MitJQkFGRWROa05GM21LbnRzTEU1UERMQS9JRWlWMHJ6aXlPUnpMSnNveFJNQ1FWL0hscENrWHNhaXpjSFQvdnhVOWlhZGYyaE9rS2VoR3VtMzk3M2ZGczd1UmxxeHovb0RlckZMMDYxN1BxRytWWUl4amVSYjJJUkxaSkdIOHZwOElUekY3VTdIVWc4Q3JzM1dwVlk1cjh3eG44dHpHdlVVd1k1Y3NWdTE1Vm1tMXhjczBVTC9sVUNrck9YZEx0bGFhNHBITGVRZ3BkL3Z1MVp6ak1PY2d6ZlFhSXdpWksrZk1aalJMQUhVZjgzVFNDT2tvdmIzeFBrRDBqRWxtYjRUQnFGcnduOEc0S1dyK1JNNThxaENubFZpbVEzOTBtOFlMeitmTkhiQlJEczdHSmdIU0srdjVaOWN3WnE0Z2xuUjJlVGpucVR5OFdvN0JFZzI0Q0wvUlQxQUt6T0lFN211bzhvZWd6bjhSNnFhYjA4THpUY2JiMGlwcHNTY2ZqUW9KaHNyNGpLRzJwTVZjenBDWXFwdFpjR0Q1cnhUSEZiTDMrTkRuRVVwdFJNeUFSaEYyRk1pTTdwZ2FCL0lwQW5hMUFIYTVFUHQ3b0Jkek1HZzdrT2RTT3B4clBYYmRQM2wvK1FDZkNMTXBDc3hGZDNWQXhBL0lQVnZLOEphZW5DWUNhZGh5WjZySmVHeFRVaDExK09PQWpyWElKeGIvRWJJeThydjZoN2h5d1BwOVpoUENjZ3Q5Qk44MDhKaEdJYUt3dEw4NWpPNW5pcFF5QUY2OTB4SjlBMkRNdUN4NTVUU0c4OGZONnJxQk1ZREkrSStEdEZtb0FxSkIyN0IveHhOOXhNTG5Rd0xjTENIT3g0R0lGQ3EzLzZpN2d3SmVQam9HL0hLTmIwWGpodUVRbVlGelRndHQvdUlvMWJCWDRDK3kxanJiK1IwbVJqK1J5YURrUnVzOFc0V1c3M3FiY2pwakloMnRHVVk2S0p5aEVhS2lLK0xIRzVldVFlWVpPNHpYb0tiWk9XaUpUdkpOTlZyV3VncFhrSUlJRTR6Sy9nNEpLQVRRanRhQzFxYko2a2hhSkh4T1RTMmdvVTV6R3lqbWFQS3ZWUHJCaDI3RTdFMmlaLzZvbXdwQkFSVi85RUtlVTFtNE1zejhRN3kzTXpFRjBDOFZJSXFBeEIrRms4cUc5NzBsaFYvWklYNkNzeGlIcXliZW1xaWwzUXYvY1dLbTk2ZlBvTUpXU0ExZGNGMDNkU3dTeU5NZHZLS0JDWVZZTHVxcjJwSVNLUGFOUkpKdzJSNDNSTkU2YXZoL1ROQTF0R0ovaWxXL2U0TGJPdkloN2NTMk9zYmp5WGNENldTMERZYURhK29nMGxTeGVoWlFpRFN0MmZWZHRGK0RPNy9jRVVBTTN1anU0N0ZsMTdyVVBrUlBhaGVBKzYvanBTWUs1Tmg2clN3TzhQYmkxeTQvTDBMNVNTdHZhME5jc2NwSDBwdy8zWTkrRXF3MVNEVnZSbjJyMmQ4dlJDNlloUXl3ZGhLV3JhS0dCTUlMcWppVTJsNWQzamIxdG5RSXdpOTVRaVRKVzdNQWpKRDRQbHI5RkdSR2xNNE5ReUFpRzh3U0FLVWJSQ3BteEUrems5WWhYamlDL1JidDk4M3BWMFZ6b3ZKVys5MGRINjVJT2IyVlMrV2srTXBzUmdaODZ1RXV4ZUdQeUIrKzA3SGxBd3FGanEwc201THZvbS9yY0hTYUxkdUpyRGRhYnVqWUpSV2JiWTJRWnB0dkd3VEhBaWFxc0FhZkU5TlFhMm9xNmhWOCtFMllSYmRFY3Jpcnh5eDlKVldwdGk3Q3NGZkEvZWdNZXZIME1SNDAvWDFqUXpNWWJ3Nm1yMDFNSTgzM1JpRTNFdVU3OWNwc3BDOHR1TjZReEZCN0V4SEY4eXJGUTR2Um5pRWtUZ0tjOGtUMnRDMkhnTkpKK2wvRndZWGt5NnFiSGoxY010QkdWT3czU0ZNSG41bDVvZFlWckxxaEw2UjREdWpLcS9DRXNFajc0MlFqVW9ndnJTYjlET2gxTW01WjduNk1JK1lIaWkzYldwMmFiaTI1RkpJaVgzR00vMTM3TVFWcjR3d1E1SVFFVG5ZeDBDb1hYMW5MZXFMalEyVmxPdWxoeTU4aVZ4TjVkMFEyVEVWNk1Qcit3QTZsbHVHRUM1ODkwZGI0MmVsRFV2VGJiTWNqSEdyVDdXQTRlRWhOTHFWVDM1TmhMcnVTUGt3ZzFVQ0FVejk0RGoyM2k2ZHFTMU1QaDQwT3lpMFcrd2ZvV1lYSXcrc2l3ZVUzcUtkUU0vSVdMVXdEamdNUXVpSytDVHlSZ1IvQ2crWG1mYXpDTGlGMUpDaEs3QzJ4K1JPQ2w0dDJXalluZ0dSeEJXUlFxcXJOcXgxRWVzTHg4WjhHT2ltQkpLM0lwM08wVFdwMXo2ZmhpYlVCdkN0QnBDQkg3V3owTXJzWUV0Vy82Z2QvckxiQjJJY014T3J4Z1c1dSsvWkJPamQrOVpnOVNSZjdsbjV0cVhnTTd3WkUycmo0dTdCT2V6V3Z1eWNhMlRwSmtRT1I4VS9iUitMUmptTjZSQVM3TUNmWVNQdEpXU2JaWW5RTDh2R21KYjM5U3lpWWlFUjJWaWExbmxTaGpKRWUzSmdDd1RPVGlJUUo1aCtOUWVFczdxV2twSURKaVFIYjdWd2NSN1QxZ0xHaEtBcVVUNURQTzV6dkdQbnkvRE9oK0xvK1hoeGY1d1RrRjVwNXlZMHZNMWd3MlVaUTJuaENlZFErUEJ4QUNhQWV1QllUeUJzOWFOV3ZZQVRQQkxVdFhKM0gvK3JNSVVRM1h6NU1KS2RWNk9oTEVFSzczcmI5aGZqUGxBMGdLTzRqMTIwVTZWSGg0QUp2TDNXcWphWS9LQ2J3cEN6VUNBRFptbkpkcEQ0cDRVNXJ5Ni9ZdWhjV1hjVlY0ZEZtNUo4cUFEQld3OWpQSVRqVXRrZjBsaElKa3poWExUY1hRQlphYXVudkNDeHlXaDZpZll6TlRUQ0dKY1VENkR5ZkdhbTJ6ajRxZEJ5N0R3QmFMMlMySXhpY0Y3RjJ1YlBEdngwK0RFUVZ5ZEFJRjRVdG4rL25peXhEUXBHbGFhRzVlUlFjZllFSGFaZUhCT2ZaOHg2S25Tc1puQjhZWmJMVkJjRUYzTXYvODdjajRyL0JZRFlBYVVXcnJtL3JXUEltU1ZwdlBsQjN4UXZWRzMwNUIrYkNqNGtJVzRaV3pGblg3L25BcERpYlBaeG5jQVYwNGxhRHNEODcyZzU0ejU1RFp5bGtVS0hYRjdZNWlGd3NjMEhEb3ZZcEoxUCtYSUFiNHBLWm53L2UyQnJUWm42akNlQUF2QXQ2WjhFZFhxUy9Lb1J3SzM3eGhaTDd3MTduMlBZcHFub0N0UkF2blUvQ29jVXErZWwrUEZFd00yR2toTEJBSlh2VmJxeEJNZlBXbEE4WE1OWTErZGZzVjlVeTBDK1dnU3pjWHcveWxOMjNEbEVMSzlEUFoxbnpGQ3Z5RFd5Z2gxQUJ2MExYaHVWdURFcmFZT3JYMEovTnBiWW94amwvbWZuY1hOMURvcmZ1bU1qT28vZFdFay9PdmRaOHcvNjZDdElTcEdNMmh0R1JwVDkyOXFFeitrUk0rMlhwQXFjU1M5R09yTFdWVlVWSW0zRXoveUlxQVdtMDE5VGQveXRiRTZlZVlKYVkrbUpwZWxjcDBoKzRZMWhtY0Y5SjZjWlFFSmk3Zm9ZOG4xcHNWVEN6RTBRWU1YK1NjWXhLeGIvYlU5ZXByb1VhU05UeEhlTmhvbXRiYTR5L0NmTEFaWVhuZG41bmRlSWpGSXNSV1Jwd1gzSHdySXNLeFJnZDUydFJzL2l1bjV1eTQ0dzh1MndaZ2F5aVBiT1RXR1hVbi9CRHFhazVFWmViWGJkUUh5RTB5RWhVTzVIY0RuRTZ4bEF1WkZEU0tMRFRUWno5YldjZmUxd3k4S2hTT3doMTVjQlJpYnQrZmFVUWdsNy81bmE2Tmw1ZDFvN2lVV1RqT2hqUWE0ejJQaGExUE5HU24waFpGZUlDTUtHdEhKNkVHUWJCK0hGNitNMmU4WVNRakoyY25HMlNWcGR6WGxua3p4WXF3WHYwczBXTThuZ2dTaDdWaXE1am9YTmlGM1JKMEE5NjM3cDFIRkpkMkk3R3JRNFpUT1dSaThqY1phTC8yNVBveDlmZU1UN1ZEUFY2VFQrKzBSaTNhMWFMUzhJQUJaaDJkV2Z4bkJtWERXUGR2cnhtQmlGM2VlUFZxZDJaTTViSTlZQU4yMy8zcVZMRWxEZUQ2MXh2Z1JkamtYa2wydHFpZjN6c1gxZ0dwOW16RW02c3VoMWtXTDc1WEMya1hsckNyZWlOaTJwZkkraVdWRkpEWFBkM01CTnA3VlNBWlJwMWpwdDN1ZzFwUUVNNDcwbFpYd290cERsamtsdkd4dU5lS3dUdUtOSncwRUs3NG5jMGQ4NTFRWEw5UDRweFpkTTdwa21iQTdJVTJTMlhhL0FKUlAyVk96M0t5cDlvVzZGZ29RaTRub05rb0hlTm5wcmJRb2Q4bitkUVNTYk16TlJaSXVML3JpSGF4b09Ia2FHWXdST0Nad3FjYksxdFVuVTJRdDFKKzNVVHZrbGo2d09EL2Q4bHJaRzd1Y2paaUN5SHhLNVhWdHpxOWxESjROMUZ2QVJDVFVmbkxlT0xjNWJtcnRHdmI4bW1zcjBsRER5UjU2MDdrNDF3emdsWkgxZkV4Zm1zWHJFamlOTFN6U0tHYjdGVnVzbDA3L0JnZUNjbERzUWtkczJHNjU0R1ZlVXBYN1VIYXFRQkVtSnNJeXZmeHZ6ODUrV3lSYW9ZdVFmU0g5V3BKTGVVb1hwVXQ3K0NybmwxSnF6K2VBUnlDbXpMNTlPVVVCd0J1b1FBbDVWZGRJcmZHNnh2REEvUlpCT1Y1QWZ3ak9ySjJ4Um80TjQyckNTRkNjbk9ZN3hmZXdsNnRWTGV0aU0ydEdMcVJMYzlrL293eUhyaVgxQTlCbmx1emZEYzV4ZEVVS3l1d3pXUEcrdFpHTkRWMFdMbDFKeUhQZmx6Y0JwajkyRzBBUjBsR2FNU1p1S3VpNS9MVU1uNjlYOXdQS2M2RlZrTkVIRWpIalFLUFFqdUZDb2tqTitOLzZEbE1zY3BFNDhJaEhJYTBHaHJjMzZHd0dFaVBSeW1YV0tEL2RpOTJ5ZmpaakRNM2ZkSEJkd1N4SlJTQlZLSFN3aDZFeTEveldaUlo0a2srS01TOEh1cm9JdzFVUGErUERWcHNTSUt2bXFablppc2JmSEZXTlcvZGw5bjUrd000Vkl6aG1yRVR6M2s5V1Uzcyt6ODRTSGgyZjdkR1QvRzVXdm9pc0JZQWd3bStwcUZTMEE4eHloeTRQaUtmZ1MrNlRnblFENWhERWVycHpnRlNhTWN3M3l2RFowK3hmTDB5em5mMHVZOE42QVBpcUhkb0paT1dxVFBuVEliZUJMYzVkdkZkaCttdkQrc0R0bDhCQVd6WVI3UWtTZ254MzBSdTdUSDVhL2c0YnlhY3VyQ052RzBsVGdwa2o5dzQydXFCcDF6TXNLcjJyaU9DUXdmQ1JLa3VTWDlDR0FET1lHcUNIaDFKVXNrNlJ3dkk5T3ZNOWZDSm9MN1NhcDhOVVE3bUF2ZEIyb3VnQTAxTmRxeFZvOE5lR3RhMFI5QzdReWJpTjR1QXREeHcyekxURzkrMHdlNjhKa3Facmo5dEppbFVWL2Y0d09MYzgzR2ZzdFhPVkYyYkFKNnpmNTZZd29yUVFFRGo2UW5DK2xxeU1rR0FyMFF1QWlrbTBqcVM3Znk5YllTQno1aGVrUElMYzk0YjhhVWF1M0t0NjlRSTFrRkVtY2IxOWFGUUE0YlNlZ0E5L2hGaTYxUkRJVlE3aU9CcVZpWWRHYUs4ZDN6SDVxV0lqZWQwaFI5ZTZvNHpFTGRYV2hPVk9jUENtWklZWVh2Z1VzQXlHVW9Dc3pzQ2lUZHdPYVBFTDJrUm5ZaDBtTlNaR2I2L2tyOFhmYnlVZGJFWjdtREJZeTB5VER4aGtycElvSm1WdXRONkZIay9FNGNURW9sYUdudjd4K1F4UUlLWnVzOElFeWdwZHRCRHhqK2xDNU02SGFKMzEzcExEWWJqcENBK29ZbDExSVNSSi9mQjJvSWREQkhGTGVmUW1GMXVIazd2dFNtSXlJN1E5SEcwcXh1OFFSV2VjUDhpcEtSMW80YkdyQWhSMktjR0VERTZrOHIyRjdOOWxOVVpDc3dYaS9FWGFPbFBiOWZkc2F3MVNzcGt1MXhybXlBRElJbUVzLy9YaVBxSTNKbDhCbHJzSGYxbUFWQ0JtbHFFN3VzTWJERXBpbHQ0NWlhNUNYelZxbElaOTVGZXN1NDhMRUFUUzNkeVhWRWp3UUFxVmJGQnR0YkxmWHZYNExoYUdLdjZQM1hCc0tXdnFFRmZxMXJQWWRvaEh0UUgwM2VobFZNcFovQlJDQkZWNmRmZkdDcklhN09uZ1JBYk9SZDZ3c0ljUi9nUVN4aGZyZkhGbWI5V3MzUGsvU2lrd0l2QUlZbGpOYlhidklwS1RST1NpUGNtQkRwNGh4TGtyalIrTWZCRlpMVjVJNHVzTFk2V1ltamhUMmt6VzlYQXh4TFlDRUxMSWY2bGc2cC9HRmdwb1JUbSt5UTZQWXRtS1Z2ZFRIeUJ4djI4eTN2VGl5K3JlWUJacW1DN3gwVERhc2lNQ2NBK1R4ZEtnRFk0czYxTXBaeUkxK1JVemVNZngxcWg5TUJYZzF0SS9IU0twY1VqNytxVHJ3cDM1SjNlemVmbzZVWmlFV01QQnR4MC90SnlhZWo3TlVtVUhWUkJKZkIxcTBic3c0eUhmdWkyWk9QTmgvNlIyL0kwajA5dDlRR2VSeHB1SnpCNkROYmFQVE9tRVI2V1RYWUVHWHE3RGh6a3ZDUDI0N3VTejZyN01mYWFzRHM0MTlmVkY0UkF0NFhveGtGUm1rM3NqcmhwTlNldURvRzVScGpFNHBJM3JIL0VTUGFGNlJJSUpCaUFiVlUvY3QvbktyRG1CUVBCWWxOb2IwV21XMDdHaE92dnowbS9CWFRzUEI4cUE4SWVzbTZQc0R1T0xFRW01K2pibmlERnlYZm5kd0lYSGdXQkIxR0N5R1Y1Mk1VKzVpWGd1bmNRUzhUK1d5eGFQRHFDQ1hNandQSnhHT2JkRjhtQmtHMitTcHFhQlFrZU4rMUlMOENiYjcyZDN5U1FVUi91TytOOXYzNktBaUtWRVB4OEVFUlUwdmZLaTUzSldONTArTFNZcWdIbUYwVXJubkhDTnBjd2ZYOGV6b2tHTDRzSy9yZ0ZabFhuSXFnNmE4RUpoN0RmTU93TWdUd1JqalorVHJYc2o3U0E2RWFNUnJvRmd4WFJJT0dEUFlaZ2thZGxsckNvc2Z1VlpxTlF3QVkxY0RKenVENG9jUjdQZ1pZWGJDQTNnOUpkMVBSeDdQeVJUTmFkNTZxRk1WSXYvOUFZWWQzMm9wTC9LUU91RWEyTElveU1VSFdzSFZlSkVnRG5UQWl6a2RmaWdLU21aVlVEcnp0b0dYQStCKzlCK01ZVDJxNUJFVFhKVUtSTGlFdzN1cFRwWG5saDdoa0VrOC8wRDNyVjFsVXh4U2xuRHpMZkZBcnhkblhSaEJOdTA4NVJ4aVR3VElTakl0R1B1ajBNUWtuQmZMVGk5QWVMVFQ5UVVLUkc3YnhIbTdQMktlaTZmVkFlTkJQMzFxL09Wc1R1QkpaZktheExvZHNDeE9ieEZkeUpOTFYydEF0KzJTQ0FPNS9WV2NET2Q3T3Iwd3piVkd3YlhKcjczKy9QWW4zVmZOUTRDU3hkcWdYTlBXRHFoOVpGVlJRYlNlYitiRm1PcGRrTzdDNzB5NmRUU0hWdUhsSVkzMy9LVjFRSERKMjI2YXRHNGx0UzRmazBaTkRybVBaMkxwczZxeU1ZTytXa21zeXcvRUN1eGZYY1owek03dm1MamtrL0xzWC9YRzB2YUwzS1piMkM1MUk1VFZmOGZCSm1NeEhIekt2YVhEd1NUR2l5YTBmOFpaM29scWJxY2QyY2pYTTBqaWNYbFgwY0pzYUI4MVBPeXVJdHdFaVlad3NIbjRneW1ybmxEMG1mQXJvMllvU0M3S3hEZEwxRFFWTyswYTdmTjFmTGt2OEVsYVh4NDZaOEVHSi9XNmFrSXI2dUV1aUZJUUI5Zkh1amdOekl6QWdhREVZVklUSkpPNVhRa3lpbWRnYVRCdnJhMWhVYnc0amI4aW1xVnBkN0c5ZFNvUVZOUGF0cUJsYm03TkxzZEkvZWluZnB3NkhkRmxvOWJwTGIvd0J4ZjJCR0svWVdobjZMaHpFdkJ1UnVCWkpURHY3SFY5V2ZuQTJTeVQzSFYvRjZmKzIzYU9ZQzhyeE83UVExRkk0LzBtL09BSGRDd1llZHp4NkY2VElsU2g2NjhCK0lkM1p4TlAzVitaODJUdC9BSFlTekRzeHlZQzhteHlrK1phNFE2dTh5NzBBS3BVbTFOUFAyV01lU0hmcUNjNW1VY0c2N1JSK3NKV1pnN1A1aUc0RlBuRm1XS3Yxbnd3aytmTTBJSUE1cDd4bUhuajF6Ymo4OXNOMGhjODF0ekk2ZW5Cakl5UGQ2UDVHWHpzbXA5SVJIS1M1MDZTQUVLN0l4ZmpRTHhrTksxeCtNOFlBWUxyRDFxV1hxbzAza1R2WGdZbGxtdGJndVpYMUZRR3BYWWpiWnpncVNMeGNYVEtxUS9HaFlxQkp6WnR2UGFZR09EQlRvenQwUnc2L3ZQK2hUVUpHT0FZY0VXV3I1TXF5NDc5MmxMV21FbGtmMmsySGlGNTI2OERTa0VMMm9RbCtWWGwyTlhnYmZhOHh4UW9JN2xwdU5rVVJjQS9wTnovZ28zTEQrdzQxcTRlUXkyMGVjakN3ZWtyMFhmT0R1bXAwWFBVbTJ2dk5mazRQL3RBVkEyUExobDIxem9GT3JTS2pkNkQxQWlNdHovZjQxdVdsQldDRERZNHREUk1oeUdzbHM0R1c3UDhiMC9kR3g2VlRnQzZvQ0NXeE15SnlPZ2w1UlBhRkRFL0V6R0dHTDlYVW01WDlMM2NybjBEdkVFTG0vVng2SHdsR1d0bmZaSzdkQTgvekprcjliN1BCZ0xlRmxtWHlmVUJ4WkhGOGt4Z1c1dGN4dmtFejByb1M3MGpOTHZrM1FOQ1RVSXdDSG5xazVOUkRFYWV3REN6alRSNWxLek56eDFSSEhKTmlaWkowbFhyQXNTTTAzaUtQeVlOZEpmTXdVQXZSbEtQNDl5SXg3WFM5Y3ZzZUJXVnZHTkFjMkkwUG1SNlhjOUtqcWF1cWpnRy9ROGkxNk9JUHRRMkxsM3FEa3VuVE5xMk82NUFFRkc1cXljSGFCMi8xNTlONG42N2lNRXB5Tm93TmRrcS9abER4c1g0ZFJLTnZCVUphWXFoSUQ3MHFhMlJncTgrQXpxVGFKaHVZcnFyRERPMW4vMHJXZ2dyQmNGc1l3bzd1akpaYmxLR2FtRmYrM0I1TVRBWE5VT0tuNVBXOTFHeDU2Z3RxVHF6MWRZTU1MMWRGUi9LWlVab203V2t5N3Y5RWZLblliQnNlQXZEdUJGQkZGQ3VYbmh2V2MvSlM0aXBVSWU1OUxzL2tMK1c1bHRlbzF4dDVia0pZZnVnMTd2R3c2Y3FyT2pURzRuUVhaK1JiRURDTVRmNUpaNERCY3VWdit0R1B5dWNjM0I2UjlOTUYvbGM0dWJ1bHJxY0JQaFJVakdCSUxiUSs0dUJKOWVVSE1BajJpamZNc2tSTUxjVjVGZGdxSVdoaUV2eE5WbFpTUnJ6VHp5U2ZCVWpaSENKUXRiZ0RaOG5SV0x3azZyUUtXRDVhU0h1SmgwdkJndmxOVFArYTRQN3A1OWwwRllCUHRvTnBpRmwvZE9vMDVLSGVzUUN1ZVR4ajdJQjZpbzlzcVRXeFR1MlBLMkMzQUNpWFdOeXhzNTI0NDFoeGczZWNvODdwU1JWMU5VdlFlYWMzNW8zdGdVcFh0bXRsMnlIaDNRTzFtUTU1d1NxSXJpM1B0VnhKNTdsMG5PdXlhdi8waXh6TEVxM1FsTFptTGI4WTJKVmxyZFFNamhwY0MxajBEUytWSHJZSUI0Smd5WGFjVnU5UENSb0M1WTIrcDhxZmVKQTNPRnJlYWFieFd4ejVvbXluL2w1NSt1ZlFrTzVlOWlPRENkTFdsMmNyd0xyVXBhTUNpOEVVY1ZYR2IzWjhvQkNVZHd1dW9objFzaXZ3UXAxTytEYVJGWVhJYkhRaWJkUGZxNGRVOFdlaVlKNFdLTWxORXVRci9CUklHd09yQUlNM1Bwam16dmgyN0x5eDZ4SzE0c1VIZ055MmdnTkc1N0NCYlh6bkZQLzBOVnJVUWVmNW1NZHNvM0FKMzNTSnhJbnFZZWJ6Y1oycEVWWUhZY3pYRS8rbWNwdEJIYjRBTnRHb2h3UWFiTDF4bUZIYXYvd0ZIL2FsOFRLanpHbllpRkxFaWZKSEw3T0pEMHgvcnR6V3VDckRUb0VXUEJOdFJLWEZacXova0JINmdzeHp5L1RVelA2UitDL0E0NTZGYkdtOHNvSy91WXlhZmdObVgwcmU2ZmdYZWVoVXZ0RENYZEFVSkVsSnQ3QU12K1ZNZElyck9LN1RBYUhvNkU4S2h4MXJxNDh5T3FNcXRDMDhzbzljUWgvQVY3NjBDaUV0U202UEJMN0pLQ1pCVjRtN3Q4R2JiYzRUUVJhd3B1d1RGeVMvdnQxSkJuQVFVQkRQZEVkZGxKbFZBZmJHeStPS2tvaE93OUJCL0pZOXJEWlFLMW8va3BmbDgydW1IaWpVbmowZ1ZxaEpDc3J6VXhZbCt5Z2tSUERFUFpxVUlvLytBdHNHcGxtQlN4TDhiVUUxaUJjOGxDdFNoRjJpcU1DMURkSElIMURjdWNiU050eE9GOUxZNElNbmc0VDllVFl6RHIrZ25PUFZ4V0JZTWFtYkpVZXhUenh5dkZPbmVGZzNyNEZCRUhxRzNRWlJnbktJU1lVUUt2OUIyM0E4dmhGUmU4dU5acEJ0aU10WHFPUWxWRWJPL0h6a1JicVZhR2o0czJYUlZsaE8rZXdrdkVhVHA0cE5MWEcxT1ZGNm5jeGYzRnE5NEttR3VHMjlMTHNGSTFmdVgzNUowVHNSTkdvK1RDaW95VHJYTFZFalB6dE5WUUwxL3E1dEdTck1QaGZKRWFReEhjcm5xaFZWcU4xZ2ZGK0pLOVBnY3VkL2xHYStJZzdlS1FwSnVVTitQWWhCWVEvYjZhaGk0bkxOZTUrZDhyUWxmSy9nbDNPUTNXREdXdVVNT3QxWWxCS29YKzk5SldsWnI2dFRBVmdERjBOU0hzNWZxYlUwZXVPN2NYS252VkIzdGFCRkhQNi9LS1pDQmZHcXpObzZEZ1pnaUFFTGgxRVlPbmk2NGRtT1dVdXdBUUNLdStMOHRuVEZMbEw2dUtrYU50TzhZR2xPQlZVOW1RRll4NGFHUGdHRUkvSFR5Y3hZWEJDbGZLYm1TRXJ0Y3N1aGFsT2g3M0ZuelJ6L3RoUGp2UkpjUndQdFptQ0hzMW5Zaml2TE1XV0dwcmw0ZlJVT2xyQ0Rpd05VKzlUWnVhVnN1Q3hqLzREektmY2xhMTM5aWdIN1orMHVza1drRXEvYzBtcnNSTGxWcGw4bG4wRzc3aHdLOXJMS2MrUkxlSTZLTEt5M1VtNUM2T2YzcWlLTm9ZLzdhZDNFRnZkUDRWSUNzdVRNVGlpL2JlZTllZm1LQWl5bTBBK2wzaFM3U29mdUVKNDZJbjdCRU8rS2Y1OTd3bmQ2czVtTDFkNXpOUkJkT0VtZk5LeVBkVXVDVzN1L1NmRlFlczduWWxmVi9CMURPRTlwL3BtZ0srYngrZVpkWlVNdTQ0dUJHbGFQdmVqNXd4VTlhdW1peXQvdUNDWjRQeU8wT1lmRkFNTXFUYVljSThHeFllSE8vM3RESnNKaXNMbGVMcFMvZ3ZQTGJFa3NJbTNSNE9DSjIxUzRQLy91eXpRNEVKWnlZbVdaanRrbktKYnowdkZFaTB6RFduWkhsNGt2cE1TUGxWSThjRUFHNXIwSm9OTjU5am9Fc01oVWNQWjFZdElEWVg5Y25SNzExeDZTUUVuQkdnVHo2ZDNiMWllYklkb3RsZ3FFMDN3ODd4bEQwK3FFeWtjVml6YU9CM1orb2NhTUdXeWJaVElkcFI0bmlWOW1EbTY1RXpLSzhWUXE1OWlNbEFCazU0QTd6QWxNZGtZTm1hUnVXSk4rYkxKN1JxRVpmOHZycE0wKzNjd0QwTmN0dXdKSkExM0pJSlZGbFBTdE5JWHpBVzRwcDFPblR4M3JNWlFmRitvNHA5MldEa0YydHgxTVVkQzE0RXI5bDFSbFlzRVluT3ViajJJb3RMNHRrZ0t3bkUyMTlac2pYYjhQSkZremFrYVdoUkJKQWtnYlI2bXlpWUZzSmdDL2xlbGxzTjlnMU1MMGo0SFg0cndJekhicTIwRkRrQmRmcU45U1VuSWJKZjBRUXIrUXhIeDRmMGtSZWtYYXFLWllVWFlNYlJLYTZPT2JMUE9hS0dmdDd4RkFnVDJwSHVTdzdrZGZsb0VSOTF6c0pQV1FKYmtBenlERmtrZ1VnODBrVzduN24rV0JOM0NNWEEzbFU2UVIyM0lweC85ODU3N2gyT0drcGNwNVlpVFgvVGlrQmtjemEraXdCR05CaS9qK0d3Vzh0R2JLeHBpU05FUXFVRGRxZnNjYlZNUStPU1lHb2VRS1NMd1JFZlVHRGpSL2VtYytaQUpzeTNzcmFUWmtwSEZaQUk2OWR3TzFkdnNPdy9RK08vMmxnZ2htRXNrNk5Lem1mSStPWXVPRzJVb2FnUDlMZS95OVVBQms0VkhrNTQrNmZXODkxcWUxeVZEVDJLVWM1aE5lZVBCYVF3VmI1QlFZUHQvKzJ4RXBxc0hDNEdZMzdoWHlSU0d2ZndZYTdER1VEYk1LZDh2dWQyOGg2N21wT2w3ZmU0dUZSZS9IT0tmM1RGcys5UlgrUXBMMCtDMmI0Ui84VmZrVVFPQUJ0NHRjYURWMzRuVS9VRlhCVUR2UFlNWWUwRjI0QVpQSVdwaFk5Ykx3dCt0V3ZtdVd3aHZBZ1BOMXJ4dm8zaHBYdlFOU1BzVktnRlVLRU5ybVNDaldQWUNVb1FmSkZwZXBJNm9xcHNWd0p0NklsQkZHTzRzb0FCTk9TMkt0bkY5UDdFOXNTTEsxV1dPZEd2WU5oeEtPNS9ENUFDTVNNM29MeTZYdmp6UGU1N2hQMjZES0tzSWJoTFpxY3o4dEpPY20xemxWS1Y4N2NWcURoNWlPZ0drTklLcDdKVThlQnA0VlJQdnY2cGV1M0RSK1JPaHJvM0dPbnBvNkNkbHRrcTM5NWhVaStwRFh6d2NPTkEyWWpDNEJLdlgzSkdaaTc3d0pib1N6d3dQZWxSQ2U1Mjk3R2F1M2hIZGprTmZETWFvQ2RmbzRCWDFJdGhsRk5FSFVtMm5Uc3VpUGUvck91eDdGU2x4SXdUMDlOcW52eUJtV1FZY2xlcWxQRXJldW9DWlJGdlhMMDd2ODRBeGx4TmRKTS9hdERtQ2pwbXp1bUlvWU9mNHVWcVYvOFpuU3dWNzhXVzBTMFI3QXdJMEVEcTRCNklhSTZBVUJ3UHJOTFkwZWVTdzI0elE2cVZBZ0JHVzVhSzc5TWcrU2tqNFh4ZFBsOGF4TWw0eDZud21uQWZFQklqdTFzc3A0eXIvZ2RpOWtsK1NjR1czcjVOVnFKMWZYUmtXOU8wQTZKQm90dHZXR3lwUWlvU0gyQzQ2YmVwTnB0NWRYUksyOFhZMGhzZUVuVzlmREJhVU1Iemlhdld5OFE3anR0dWxyc2pPZDVXdW5xR3oyMHJQaXdYLzNmZEt1UWd2MGc0Q0RxR0JNYW1vOWh0Q3lLcU4wcVRPeFdQNU1tWkcwbHVyK2VJTXd0Y3JmWXFKdWpUMTlKM2RwczhtckN5U3QxTVJkbWxOSXlrRzhjSU1zencvbk1sUlYxRG1weE5uMnpmM2dmbFhtMXNYU0gwMEVxcklDajI5ZG55TlNiSXRlUU9xalBMcUJmMlFERFZWQ0FnY0N6N3ZFUjltNVg0WGtUSWVCNHBwcWFGYTJVSEUwNVFTa0FoczdGa3lQZjQwVUZHbEtHOEducmRLcTBaTFVrOW01amxlVEJ3aGREc1lQOEhDREtSRTZMUzQ4cUxIRDRwdlNsM1hGdm1IOEtCRW15ZXlOd3dKekFKUWQ4TXFobUtzZGFuZEI2RWMxYkhPdzhhZ21WR1AvdnZZMkM2MFg4QW5SMnIySGhka1ViY2xXOStvempteG1pcEExQUpJWm5xeGc0YWExTGUwUkhmVTJ2a3BmNjh5L3JGTVlnQ1h1ZTdlTnF4b1MwTmtPdzlhOS9XY0RGSk9oMEdyYjh6WWpQZ2FTREVOSUZNQ00wSDVPbElxcTJyMkZLR2thUVNNelZtODdyOUw3ZnlzYTR4eFZNRDBoN0NJRXhMQlZiQ2UxL3IvV2F2SzN5UGhIVmUzWEJqeVZURE9xSTQvOTBOL0NtNUtucXhGclZZT0hid01JWGEzR3dOd1ZNRSszOE9wWHZOd0Q2bCtqTjhCRENSREVqR0RGQytXT2JUZG0rNS90Zm0wUWVFZlZVWUZ0QTdnVG9iaUNubDhyeXdyb015QkhOQ2xvZnorVzdPaHNzckd1b3MrZlJoaDhrQkErTmkwZllkaEtLK3FDWmFZMExVRHBuMTdVVUtDWDZkT1pjY0NZelNzRDJpU1FQNzRwRm5obGtPekFDc2FwZFQyMHpiakY2WnFMZ0VMVVBUOElnbGFYMzh6UDZ6ZmR5QkYrTmpOZjI0N1hOdG1JejRRQ081aVJ5L0djUzhqamFXTWZUeEkzRWJVdnpycHJ0Z1JRRE96L2VNbnlWUVZiYkZpVE1aZmhmUUxldStqNmlZMFFzL1FZR0ZkSGVmd3pBWXVWcFBoVlpLL3RYc3k2REFpb0xsbU5EekF1MWVRNWloQ25vYk8rTU9adFNEMCt1VHBpT0F2UHdHV2Y1MnhEVUhqNHpiZEZ0WlVMUFY0YzFUbVdmbERHTWtnL0lhNmtQSHBySEVyd0ZUR29CZysxRDZvWDhsU1BkejVzckFGMFJia3RVVG1xNDQrVVNBWVlvd1pRT1ZiTTNCV01jNjAzT3k5U1FEM2J1TlRneko3eWFNQmJvL3Bqa3pWcnBXNXhZSDBSYTExeWtpejMydm80bkJnOVp2bTkyS0hXaEptN3VRSlY1RE1QQTFKSEJXQk1janovdVp1cHdYcWpvVGZmZUhaMTdOM3dhWFVhUjdjWkRzOTRld2xoc2JRcm1JNy9BNHpKRFVaajBxS2lWUWhuM2YzQW5lRWhEd2w2R1VkQ0JkS1kxNHE5bjZheTU4dHdXMlBSWFhQSjZVRTZUVXM2b3FILzB4Z0RwUDNieC9tZmNDVXk1b285MWFnQ1B0cFRmb3dHWjB0eXc1bUlPc1VxdmRVUkRoanVXTFgvV0lxYVBsWXgzem1KM2FoVGN4dEM1eFFnS1dyUXNrRjU3TGFPdndZTjBsekl3ei9qb05Za2lad0x5QjdKb2kwQ3NXV1JDNlNhcEVONVRDbElpc05RdE5QbWZ3S2FLWWIrSGd1bzc2UnRjUU1YZFJaV2pFSk5IcThLWktlZy91V1dET1c2YXlnTFA5SkRyTk5XN0pmV0R5SFBSOEdMKzI5ekJBRDVGWTFXWlhzbVlmZEtVMVZUTEx6QUhFUkpKR1Rwd0taSDVrMHVackRZTTh6RzlXWCtSVkRNOGJzbU44Y0kyd0t6MFRkOEdFcTlUNER2WTZGdWhNc3FQR0hDMXRrTGR4dXdCWVAwTHUyUnZqWGF4b2RyWmhLZmtrSXdHY2ZtK2xGUzRXTUZQQ3ozRndXd3V2TkxOcXY3Yzg1eG5rM2FYV2w0OXlDVzBZVHpUcXd5S3VLV1NJRkp1bTVHOEJCanZ4eDJ5RE9aTWgxOE0yV2hSR1g1VkEwcDNlQWlsQnNHYTU0UCtpRWF0MmMwbExuVHJYZzdmekRMSnJqTy8yMTNoUm1ULzkyekh3SFNobnRVaVIrOUtVV0tXUmN4OU9yTVdmZWZFby9wMkZSN2RiTldvUC9QL3NlN0pKVWZCekppeGNQdlR6TXZTVFFyY2NEQW1wd29Mbmg2cG5zQUYzN1U5Q2FrdndiMEVaenl3aFloZlV5QVo0b0F1NFIxWDU1eXJiSmlmS1JiTElDNk5hWXFaeGJwelY5ZWM0L1NGU2pKS0V2bVZHYTl0SGZVSmF5QXZyUFBiVkhOYXhsYmRKT09uN2Y0M0dUVGRHR3VmWHUvZGFBaHVZdG9sMnk1ckZWVXhsRHB5S0NmWVJ6M2ZPeUpaRWpoeGl6ZXRsRjVrcEs4a1V1RXBLTlduU0c5VkVkbWNuN1R1MC9VOVBobytJWmlUaW5jWGVwRDl6UVhHdXNtcjZqMTlUS1JDZTRkbWJHbVJsMWNERE5BQlllT0tUNTFmSGM2K2QxUTlUMm4xVU1ta2QrYWlTVWdOSXJvZ3F0bkluZXphRXM3SG10bXBqS3R0V2c3dWxMaFB2RUVuR0U1VHFQWTNpQ0l0UHpZb2pHRVQ0Vjc1NWIrY05tcWRHNk9CVGxiWWpEczRBQXAraG8xSXE4Ui9lV2EwL0ZPeUI0SzVKTFEvV3F3cGFOUHVhb3VmSGNKTUVsZDRwZWl3Lzd1SVJaOVU0b3RWMmxBQ0JZMlBmU1VVdTd2Si9pWlV0dlBvSm1kOEsvQm1ibk5vMml1bVR0UXhFZUFSbmpzSGR6ZjFKckUxTDZOR0ZzSTd0ODFjNUdDZ21XSUxLTTVwV0RBNUhPNTNJNmFqdTY5MTZKa1VsMVljWXlrOUh3d2Yvd2FLekdiTmFlWEQyZDFqQmQrcnJpRHlQZ1I1cDMya3hBYjQxdmpNTTVRalVyVnp0SVNNbWJWREJueDJxQXJuTEo2RUNSR1pjZks0VTZMQ0FNeFJ0RStZMzJNb2JXSVlxYmVKTENzYUY0cENYeVpqUEFCVm1OMzZOUkFhdlg4UlhPODBKdUYybS9Tbm1nMk5MMGRTVzY3RVZIOUk0ZmNGU2pwTDczcjZvaExoL1YrdUszNzg2VHB6NHU5cDFieVpFRUZWam40ZUs0d0JOZVE3REdoZGJGYlJUdDYvOWI1NUVCTWZKR2FrcnFaNFUrRmduaDJ1SXBpZFVjRytpQmpIRTVITVJYMlpLa0tMeVlRRWxrdy9LYmoydzhPdkRheGQ4cnpXb1NVbndraVA5REI0TDFGQmRycmY5YW5UcU5mUGVoSFRCbHlHOWNnY1FMclI4dFFFWk45enV4czhCVjFaZitjSWs5a1NTdGNDT0RwaFFDYlpQN05ZaGdUdXFQaDk2N2d5bzZEaEpWRWVNL2dxMmFyRW8zTmtWdFg3RDdtek00enpzandFYXplWmJ5Z1k2eHdQNUY1TkxxUEowSHhuY25pMlhNbi9HZEhRbVRiUUYxemVlNExPaFphRGxCek1aTHNLWGNKM3NKc0JtUE9EY1NXL0ZLWWlWZ3p6N3dMZHowQzNiRnBUd2VkV3BJWnpHK0gwa3BTNmhPRkY1eU5qL3hVR0hFUUs3NXF4WVVGdVhxMnZGSVRQVmY3YWFBV1VGK2VCVjVWYkJxRmNVY2NITmFUbUdhRGRSVGRYVHVyS0o4QVR4WDBESFd6MnFOaEdQNG5yWUpSQ0tJMTJodnZhaGRmUjZSbFIremNhNDJtanliVnVIRUVHclUyS3ZuSHk5K21tbFFESDRqWUhaS0M2a25rbmU1UTI4bGRncklTQUYwcDJ1OFlWVHkyYkdMWnFVa0lWNnpXRFhpMER1Wk1pUWhPSndVZ1pRTm5yanpwYm94aWY3Q2FDQUZkeEh1a0E1ZlBUdWJGNmFMT1RXQ25TL0VQOFpTT0l5Tkdwa244NkJWTEVneE5vQ281WERkSkhkblNCMFp5KzVPNE5RU3NvS2Raemlrd2cwZVN2WEFFNmo2V1cyN2lybFhqTkhIeGl1T1kvTGFGc1NnWHY2MkpmSzIvTzA5cjFETWpweHYzMlk0NTdXZDh3RkJmOVY2aTZDZExQMlo5cU5Gc3hjUDg4UzdONmI1RkFrWkFrTzc4VDNmNG1wVVZuWGVkL1FRQzFBQXVkQnIrZ2cxMThpMjAyK2pIZjRtMXRCdkQyaXd0LzhQcW9BV1FTYWpSZVUya0RKOTFsWjljcWZnS1ZiemdlNW1VbEtEU2g3YWVDbEZPb1Z6OVVFZFRReU55amordTdKYVg5RFd5cXR0Njk1NWZjdkJKRjFhS0VqalBRallWNCtGUXI5Rm5kOE5xV2F2QlJMOTFPVWNJTHpYVnNlbHp2TFF0UG1tdnRkaGtVTmk4RytPK2IvcWNWeUh2bHM5bEpqUkdiZTBZV3R1cTl6WEEwMnlJanRCam9RZDF2WTBFbUVGdmIzdTN4aVB0OVdpeDZOWjdsaldRVmJ3MjI5U0FQcmgvaHNJRUNIVExteEt4V0QzL0s2VFVpZVFlcUpJZnBjSW9PUWNnbXZIRHl5UlVldnpLSW1laWtSemcrbHkxK3FTaWN6N2hoL0RDbS8zOUZ5azZNODZYTmtoY0VnSktBTk50MW1hdFVIQlB1TW1xa3FSMElyc2VlMHVJb2ZqZzhlZlN6QzRNbDZPekFWMVB1eWRBTk9EVitTYVZxS3JnOHFUdlQyUk9waVFIcW9PQXEzRWRGUm8xUVcrMWFrL0FZbUdFVkE0Y0Y5OUE4MkdSbTVtTEhoTEhxT1NxQlZORjVkK3RqRmtvMm1vclcrYkF0V3FFM01oaTJ1WVBKRWVMK3B1V09vSmFMVjl1SHRRSWoyR3ZqcUVuUGlGM2dTTmsya3ExcmIrdjMxRER3Y2FsdTFuc21mRTFuN0ozOXVRZ2xpRHl5b0JvdWRrWnJVdG5JVXJEc0M2aUdzL0RBMVlVK0VwQzhWWVE0aXc5MUQwTzhrSklSSzBabzNZelV6WW5tNnZ4cSs5RURBUDVTV2YrRXl1cHdsaGN5cTdyZ2Z1MFVjc1MvY3l5MThiWkJ2cG9veWcxcTBHTmtUSitNd3RYQnREb2FDaEhFcU1kRi9hN0dqVWdib1NiOGpIREpyZnFSaFEvYmJJNjJyOG5Ib09hNlVnT2FKTHh4ZzFFaFhwWG1rZDNSY2g3dU54Z3BQenhQL21CZHJHc3lnbm90aDF6N1EvWUxZSmI3THdwdUdSRWRoUCtlZjRpbWkzQ0JtSnJxOXBXUjgvczQzUzR1eHFOWUhVdjloYTlSQkFDQmh1eitTNHhUUVRaYUNLU29ESG54QzhDeEdoaUhjenZKVVRsdDRycldRcHU5K0F2c3JSMndNdndxcFRUZDJFVFRzTy9QM0pKaUxCVXZjczBUWENQQ1JZMmg5Tng4WnFNejhYU0VxYTlCeURMb05NOFB4eEsvNjJ2L1drenRiOWRseGZIc2w0dTRVaklabzVsRDdrbk5EZXZPWnZGUllIaHdGRTIybFhyWCtTZmZydDN5OVIxREthRy9HbEFQTFFRWC9IZXR6cG1jZTBUVDY5VTNjRlpTVVdqMWhjSmEyNU9vQ1h4M081alhTaXpqUHU2OGVGNkpSdTRseTBHUG1paEpBY2RZNTRMQXUrUGVUdEhkR1dhUmZiNlJWcDl6eHdQKzJQb1RTUW0rcUZoRDVMa2hzWXVUMUl3V0xJQVVqVTlQMHo3SU9VajJRUDRzWUFCdDJ2WDVoSkNWVW5qT0JQVkdRVG13eVI4TFNSYzJXdmhsbUQ0RE1pdG92VzhBbXJ1SHZzdXh4TW5ZL3liWEIwZjZqZ3ZZKzd0TXUwc0pONXI0REJFQlhhMzdTSDVQZXBiaUFsWTVMNiswOXFGOWRiZzU3cVpkWHIrTGtqKzlPRHdJZG9ZOU9nczlRWEFNUEJLOXNOTE5ETTFtRmFPRE1WcHFlQkJ4MysvWDhCa3lQb2ZPbXhsK2tZSnNHMVBQNTBGREJYajBBNHVWVXdTWE9ueUR2akhkNXB1cE1peTVEeU9NVkRqUERpMjJZVlRlS0tQeHRHejUvd0xtL3gvRHpITzRQQktscmlVeVIyZmRhelo4TVp3Wk8yeXptNDBSd0xxZXpOaHNOVDdhcWhPcVdCTWZUYlljeVZ0VnpyUk9LTFEvY3c4aDlNQllnTFFaNW03UnRhakxoakFtd1dSdWJiT3lzVlk5K01iVHh1bHZTcVF5bWp4VGowL3lHbW93WE9rOExvckxIYnljaUhaYmk1V2lwcTVlMDI4eE9uWFBxMFNPMUVpL0JtWEZDcitpdzR0b1F3bGQxZDVLWFpKYXExZURQZHVxTEV1VlJwS0E5Q3pCN0tKc1RUcGRyWXBNYU9zSUZNN1dncjlPaC9jYW9SQW9oUU42QTZIU3JtYlV1eGZmWWxTNHltYzRXNDBRWWZhdXVxcFEvSlRYZTJsM2dXMXZCVTNRMENRV2krWW5HTUFsTTdRQ2U4MDZ2SXJyZ1FtZWpnWWIzejIxYkZuMEtOWmo4cU1idGswZnViY3JEWVl3bUJoalplelp0QUs3TjNNUUtLQ09EV3d0bU4vV1lFR2N0dWRLSnpSQjN4ckJHSVhQYmgyb3lPc1E0cHN2dzJwYWNrUGwzNnVsRzJBbFc1cnZTM3hzRHJaRzBqUGdjTE5PQlpWcXVCS3VkdnR4NUV5WW5pdm1MUkVXUG4zMGNia2ZMNFJzZlR3dUpWU0ZaWkpGaDZVa29mR3EvYmt6L1dxYlB3eURrOHhwcENWTno3SlFzdGlqdnhFV3JiNDBUSE1RSmViTG56eVkycTJqeDJTTGVjYVI3LzBiNjc2ZjVkZFIzYURRcVF4elM2WWxQdkZjWWJ3Kzh2aWM1U0FrNzVIOUNTc0VvclFDVmxKU2s3RFU1SEJSa3pEblYyUXRUSmU5ZnNmcXkxc1FOQlhxVVh6diszSERWRFNqbEhOUEtFbU5HbTUremxFUC9QYTBtTFI4aHhPRzVQZXVIZnNPNFlBYUMrYnR4R3dLVldDOVNlN3R2OGZCSkJ4MW4rS294Nkd5UEIxU1Z1a2tOUWtqaDlkbDhzNmRSOHV3Um82RXAzenJweW9ESHdOdnBHVTB6VjUvMjdncHZlVWpDeXJ0MlpGNFRPUHNTL1d5Z0xrZkUyZGJOWHNORFhqVTBrZ2diaCtSRW5ick9HVk5iZVlBb2M0WlgwYVJkeVRZT0Z6bFJLYUdvNE1vSExrTUg5Rk13WWxZK2pJdEJZVmJJenNCeUxJVW11N3hNN04zcTRWdE9BemRCdFlwd1l4LzV5VElJSjl5aDJWWldnL3VQWmltRFJnQVNVZWFJZUYvVFUrbjNOQkxPa1F2c2Y0Q0t1Smk5czRGcXBFMnAwSExhdzZ5SWNGVThtY2w4Sng2WFBXditlTDlVditFeXIxUVZZUWZhSmNWd0o2a2pGbjlHU1ozdXZiSXhhWk13aTd4K25OTHA2MHNnZHpvZ290cWM1b1ZUK0xEc3lnVURrK1MzNjFtZTdMMkJXWUZrY0RFUi9SeCtKMHRnRFo2d3dLUnU3a0Z0eENwcXR0MTlXZ3NGNkx6cHFtRGxMT1J2T3NZNjhKbnVaZ0JkbzdvekZtRlI2dUdYeGJ5U05lQ3ZQS2w5MnZrVnNZRVlqWjcwblNzTlF6OVdpSXkwcGNkNENqbmQxNmdIVmozWCtJSXIrWkgvZ1RuWXkwSlF2VnRwb1FLQTN5cVRIOFpLNVdBV0ZMU1hqTmVIQ3d0WW1hYW42dUpvT1dXM2t0bVIwbjlqMHV4U0VuaUNIZm9iY2FhNGFkaGg2VTY1aUtDSGVyOURzdnBvRkp4a2o1amhHTGhQU2pKK2hMZGR6YXRWLzFPY24xQ0U1dVpvWkFNdGdraFVZTjV6azkrVlVqSnhPVGpEc1g4a1FGYW4rZkNTdzBySzhJaFhOcDNkeW5mSFhTWUNOcTA3NlBuNjBscHNnYkxDNDFwbDc1VU5qQXRka1hKME9GQlA5U09GeFlkL3F4b0FDbUNmMmM0Qk5qZ2xsM1A4UDc3aWtHUVBMYktlNkJwcmY1UlI3U0xUY29MaitXRXJpWUQrWHZsbkNRNmd3TjA5TUlrYzZQSCt4UzhKZkpEN2l5Qm9Tc0x4L0wvMUF6YXhHN2UwZUlQMmR4cm9FUmhwQzZqZzhhcnJnN1hRQmtzREhJSlpJUFJoeTE2V2pXYXVjTVVPTHR4cmdCVTlyZXpFVGpvQ3RNbkJZZGFPQWFna1ZIZHVlUmtwK3AwK1NSb1o0ZWpRYUN3aE9pWVJZWUpDN05zVjczb084ZHdZTGlvQzNxSUxvbzlCL2VNdWQ1dUVSSmRUQitMM2dhWmNYT2JudFo0M2ZlZ2V6aHBtU3dIeXc0ZE0xMHhmc1hGMU1ZNVhBUjFYbUdSOVF6OFlyYzJCU0JpVVVmMXdTeWUxdEdRTEt0bXNoZUJJMHpXRUt6SnU4L3RkV1E4NGxjV2duWG85SU5Qd0RVNVhpSmkwT3lCUWJ3UkgxYWhSMTRMMTBnOWtBWVdsREsvME4zVnpjZ1lZdXJzalR0dy8yd1NIbWZUR0pzeDVOT1htTW1WbGlCTExIR3U2RzBqRkJMWnRVa0g3RXpGem9yaGxLaEtSckxxWFhsWHBPOGNyUTNDSEVjWkx1OVh6d0NjOVN2a1BlOTRneHdvbmlqZGl6TEh0R2ZMTEtMRjFjZHRYTUZhN01mNFAvSlFIaUJaSVJYQnpDS29xUGFJdXZoN1g0L1NRZEVKbnhic0lFQ1VGOTBabnJMVXBCalRYaVg0WEFjM01zZTdlVFhLeVpwOFEzU2YxUzNlc1p5RFFsK0JCRVI0UG1iR09lUStLMTExMkZiRWV5cVFaZzU2V2lRMGpSQ1VtUCtLZXc5QTFaeFNqdXRMVk9ma3B1QndvU2tQNFJHTm9lN1dybXlUWEtJNm5rMVRuejBvZTJWbTNQakJEZjhHd2hlK2Z3QVlTQWpsUHJhMVR0Q2oxdXUxR2NkSUFtNlZpUW45U3JxZjF5bTlmUEl4SW5MeHQ0OG1DSWw2RFNUaTRaSitYa0pyejJkWFdRcWhwU0Y0bk5XYXBkSWpKSCtwMU9wZWR1Zmt3MHhIbHI0dk9SYjlCQ0ozVzh2QVBkWlNxSTdWeGJOYWFPZnFoSS84dzdMOWhvclZLdjdNTG5FcjJsMlhnVU02K2k1SXg1OHhnUmxZVnhhK2x0RWRhdXBENXlrdFBFT2xsZE1JYXRFSFRNOWo3aDdoeFZ2UVBFYnRRUDZCbURkVmFQejJ1L283K0FpeTRsc1hHRStLbTJzczY4Mjh1cVk0eTI4Y3JveGN3UUJhZW1QMis0aEVBODhXbW1YblFUbUlNRmplL2k1cVZ6UC9keW5oQXB5NUdFQjU1aFU3K2pQZHZlZXh4eXJVTHVwWkIxaGp5cUlTdktzY3VLWE9YWlVucDhkUExsVGtPSWxPaE11OXQ0Vng1UExQSURLMFNkVWlaOTVBbFMwKy8xbWFjbnE2aFhZWWVqZ1hpZ3Q5TmVQeE4yUFk5Q0MwSGZ0SDBxOGh0dHZCZUxaNDhvb3RibVNJWmdLNy9XbTF6cXEvbFVEWkJMNkNZQzVLRHlMZy9XZlJLSVFNTnlOMlg0MzJ1THIvZi85QW9WMTMyaHZETld2SWJkZ0pLbXpGd25xamQ4K01qd3JDSU5XNDgwWS8wdmU3RXB2dFhIZzRXekp2NU11SUxnODlnamRNazg2UVJPOVEvWUtkbWIrSFY2ZU1xUlRxL291ZE8vRTZ6dkgzTnpHZ0hOei96STRDbGMxa1hVTURUcm5EcEJJMktiV2UvLzdpSTZkMUE4bmhYNEYrNHRHa2k3aGZzQTRWT0s4M2ZkTG1jZEFHcVFSanRJdFZYYTNKN3ZoRSt4MGgzSytmVkpwTTJGWkRkWTdnVkY5TUUxcnRRbXlRT0UrRjdiNnZRQVVyZWdxTW5JZWdweHRJS1JoeVR2ZngrREZXWkxmK1ZVWkhVTytDaWNIOHNFKzlMcGxkQUNGVXBHK1dNZkU1NlgrOHhJQjVsK0V1NGlqMmtCVU5ZeXRocTRvMWt5SUV1RDFrdDlYUTk3Z1M5K3dhYUlIb2tXYWU2am0vWThHb3ZnbWszMVoyTTBTQlpBSWV1ZGJBL3k2UmtCeXMzenNXVkhvUHhENzNqSXM5MmNvdWdwcEozVXhmL3BRY29Pdy9xdDIwZXBkVkpnSGhUNS9SZzVtTmYrYnZRNExKbndTeHM3VkU5UWMvbXlaRjRJRkJVQW9tNDliTVRJZ2hWVzZSSjJnZlhrUDZvdmMwVEhURXB4Wld4NHpUa0FSVlRmSDc1dmZ0YUlrWnB0UytoM0VSY2l3TCt6RkJmeG9qcXJkUnFxZGtZV0FWbVhwZit1ZWNrT2ZYUHJONWI5ZUV3bDhPSldnb1h3eVBNNzNSRG41aXgwOStxWVRVYmhJUnF1QkFJSG5PMDNIM3E1VEZkU1h6UCtzUERGK0ZWNjFBTGlKd0x0dHRzNy9ORjJxaEZKSTU3cDRzaXhlWmZvRXRtMERnNXdHd1BDSDZ0YzZhcU84b2U1UitJa0RSOFR1eUZFTjJ3MmtCZFR4eHZlamFTb2FwM2JRbENXNHN2YWtVSWpWcnBlN3pDYmJjR0wweFNlL1QzaHlzQ2ZiMjBYajBvRml0bW1ZMVErMVFBYkhKajNNZmVlWmZ4dXZZWW9GN21MbmI5c0YyU1BRRUZyUnd0MDhxYXBZME9EdzRSZUVNM1RhbVZnNGozQnZnS1dXTEllV3JNWFBTTStJM2hCempVbjZUYnFNTldJUERXajVGQllyV0J3WFlCNzFCT3BtWCs1aVlvbWpIb1E3TFVjUTg2N1FSUzNxWlhZbkJiTHkvRk8ydEVHZnpFL3JHeU54RUQybnZNeVNJSXM0RngzZlpJc0labi90Q2tvY0c5a3JaNVRXaGE0ZURJM3pteUNRZUJNWXNYbFJETnNNZmpFRUJGaDYvUWhxMTJjOUlVcDYwNmtFWTVid2JHL1FuVStJQXlKaGxmdG4yZjhpUkw1QTd2NFI5b0FKR1UyR1lqTkhxWlVHZzJ6NmF6NFlNdFF5WGNWOVg5V0JSbGFZbmZWSVJzbXVWR0RoREJJb0c2QzhBa0NLNkxkWGQwTmdlU2hnVkNOcHg3aWFjZDZMNXI0clZpMUdjbzZyQ0J3QmZ3eUlKczRGaG5xOElaclVSbjl6aGtKMkZlblVQaWpuYklvbTRjRE5KVDN6cU1mdnlTR3Q0a28yS3F3b0dESDI1UUxmdVdNYmN1Umh1UXdZS2dDWDlWZ0NseEVUUjZETTVETmpUdjdGM3lzRzBrSThOS1o1QVpEempKbkpENFZWUHdWUi9mTktIcHpnTThRUUdTYXBWRWJRQ3VpU3cweGpIcGhwMGVEeFplYW1lczFNcDlXd1EycHVobWhqNXFsMUx2MGVZSkVwTjhSRmEwMXlmTlkwS1prVHBZemNPL0NraGJiMzZrOWVzVlhTTVBsMUcvSzcvc1I5TWNxdno3dEVtZEZ3R2FPMDJjNmF6Zkx4bFJnNmJ5eDV5NWFxSFhCZ0grTjhYKzBwR1NqSHNhRU5zMHRFY0pVNFh0THJSTEJKR0lGVkVlM1R2SVlrdmMzc2lhVTFkM3hpOXQ3VFBxMUwvK2hNUnFvanFtcDhqQkx5bzdLRXVZWmVPS0hGTTNtVWtWK1hreWhpRmhtd3h0TGdTc0dNYmg4ZkU2aENSMnJUT0lpbmxtc0Y3NHlqN0lwVmlRa0xieUNicnZEdDUveVg2STdZMWFickZzN1FCSTNEOVFubHhsd2JnWkh2RlRLZWFGS2NJM052VVFGUVVSTWltUTVNK2VGNnZ3U2xZZmYrNy9jV3BZbXZQckloOUJWT056VllPZTJ0UWRBV1dUNWZKU1lMNVVwdDBMNkRsL3BaT2JCRWRvK0ZQQzRiMitpVTA5ZUo2dmIva2MyL3VxOUN2Q1VWOUtCK0MvQ1BBSmRPdTd2cTh3Zi9ZeHk4MDgxUEVubTdWR3NJenpvRlluRHZmWVRVeVBoZFhWMnlJQ1dsanhXcWt5RWU0ZTFuK1NaQ1JBQ0R5aUxUZHpqNURxNVRoTWRBK0NOSmhWMDlpTTJpVzFQZ2YyWGlMRGtJcE5vOHVnRHROZFZUTUVCc08rdUh6cnFFSStFd01PRnIyZ2V2RDhUa215anZyWUg5Qnc2cmtBUlVGd2M3RFJwT0NJYUFDbjJFZGp2N2JtaVMzTUZlVmdkajF5MFJ2K3YxRFlxWTZFd0hzdDNDTmxwcTZYQlc3US9mdStGMVIyMGFIVVI1WjFMSVo3d3ZZMEUvdzk5Ykt6QXlVakc3NjcxWlVZRjZGNStZbnY0Q20wdHdMWitHVHJCcDhWTC9MTWVxOFhZZ3pZbGRya2xNZ2x5V0pTN2lXQmhkQTVHcmFPM20zck8yQW9yTjRONjJiSGNwSWhHOGtidklreWJuUlZURVd0NWE1ZjdpSVlKTjYxT08xZ0xwK2xNS2E5Q3VhVVIveTllb0YzL2pIZ3FoNmlQU2FkZ2xGWVEvR1RzTGt6SVhNVEZ0QmVsWHdKSHR2bVF0b1hJdHVPc0xHdkwySUsvTTI5NVlEOFNhTmZTTkQ4elRmZ1VYR1lRUnlyenNQWUMxY3hXT3RvK1lrVzlSM0VpblpCRlV5LzVIV1hGNldlcUxjUEFER2VKSDNVNjQybWpWOWhNcUEvR1krN0RjTjJicGxzMjVWaXpsR3YrRnlIMHFoRG1tZDBnVVM4eTkwckRYK1hrNnk2TWNKNlM3Z00vRFljb1RIdi8yTmVLZzRyak13OFRxcmxMOUxCY0xLV1F4dHVKeFZYN09iS0RDczZmTmxmVWo2aVJyR1BGZEpEK3ppRmtuQ0pLZ2l4WjVSSlFFUVppMk1lZlJtVVlpNWNyWXUzT2g1MGE1SmYrdXB2TnpGQW83S2h4TzhXUnZvcW5MTzB3dnZkY1BzYVZVT0ljdmZab1VpZXJkVHlGeW94d25KSTkxS0NCcm9Fb2R5YnRCR3NodUxzZWV3T0w4UkpQK0gyT3FzY2EvU1lkZWVSdGl2WFkrRkZRZVRRMzNlZVgzRGR0UzArd2dIWFZDQ1FrL0NrRy9hejRhWStFeE85ZXlKUm1wZUtBWG9zZTU3VVNQWkVvUktvNm0zdUlZMHJzR2hqdzB4QVM3WDFEdUJURlZ1bzI5djNkQ2hndTcwY1BqcGw1L3hRbXJQZEEzNlBYTlpSV09zenI5RnRUWVl4RzdkSFVvb3JlbW5ZbzFRblVHV3NOL3h5Z0xxOVRER0xMaFZIL3BjNHBEKzE1dUdpQUxGelU0UElObWZEMjVHOExBc0plYTFkUWxwQzFzN3JrWUpVUXFJd0ZORFk0RWgwZGF3TG44ZkNvbC9yaFVDRWJFSE0xZEpsQ0JwWHhLZm03enQvWnBzYlhneTY4bkVrRW9ManM5cmswRTlHRkZab1lMWnYvNHFaUjdubDdxQmJlQUx1MEZXdmRXb05iNGhDdmxrTUUraTVuYk1hZm45dVZ4eFhscFhCbE94SEE3SUt2S0pMTVhRYW5Xa3VLOUErMlZJMUpTRG9ZMDYrUjAvZzVUUEpJSGZPM3JvbGpmaE05bmN4NlFyazY2eFkxSDArMlVnRitvUWdtMjhBMjd1OStUNHJHbzBzVDZzdUE4SmR3dGhnMVQ5Z29qWnJvMzNkRmI1cHVia1o1WkhjaEx6c0traWJhUjNESHhmNzY5VjRpSW1OdUtLcnBnTU1LOHZjdkY0WWdGeDlBc2NhNjNNVnlOUHRwNSt6WFBBU25zM2J3ZG1zeG5uMVM1NEdUZGtCNER3WDRMN0pYTW5RR3FJYVMrbVBnV3hiSVpiRmNETklyTWlsRUlFR0ZjemZ2Y0FDdG1SZVR5enFucElUeWZzaDVRSzRSS1g5Wld0dlV5NGJXWGpzTFliTlY3TXJyWnNUODJjOWNtZjRmOEkwc1NZcVZJbGNVWWdJNzgyaW14QnVFS3MzT1djb2dXRG13bHI5VEdMdFZTU1RseXpIVVc0UFU5ZjdXdjA2Z0xpb0JTb0FmNWVzVGozRkQ5a0t0VEtRWmZUS0VJT2NDWVdjZklrNElrY2ZvRkdLU0xxc0hoQnBCT1RmRUo2ZHhrQkpYQ1Nsa25EcmI4WEpZTzQvOTZYRmQ0VGhBZzQvSGVnM3U1cDFrUDNRRzJ5TXVVcnR5MmNGUWFUM2NXTUFCSUIyZGlFdS8xS2ZGRlNLYmZqVHA4YVVoYjk5Qy9aQTVtN2g4SldzR3dUNU1sOVVodzZDbU5IeVJBMTVUeVZ3SXNPSDBJMXRGZVZxUWFvcVQ3d0dqeXFySjliSStXdHBqTXY1Q0FHUWZqK2syYVBPSlovekx2eEF0a2QvQnpoOUJaUEV3VkUwSTBESTgydVdLNzJQNSttSEtpZzV6YlhZclFFNWJTTkE5L2dIdlNORDJxTFYzaExQbm9KcDVxL05lWlg3bWhiMmFXZjdxa0Y4aU00SEVIUTZZaVlBK0Ura1BtZk1HYWJIcTYyUUJpOHNTSjN5YjY4aVRjQTRZVDZmK2dKYjZHM2FkR2tZOWVldTdYUVppUUVpMmZYUlNLVU9qL3pMa3loNFIzaE9BWDZ4aFQxeUN2Q0hUMkpiOXRBelNNeGUwUkZiTTNnNmIvVkhnUDhueVprdDQ1ajFaWUJUd09wUUlhRlU3blU1Zm9jTmJpY2xOT2RzOWI2SStGT25CWHd5QWYxVmlKUE1LQkJvZm1SOHdnKzc3ZzVvM0NpWVV6UStLZE54VW8xNFhRYzU4L0dLcklxM1hTSWVmTTlhenFsNXNYN0tsVHNVOERHVDFIbEhJWW5kMTBjSllzQUVIb04wbUxLY0hUeVNIc2pURmVzS1dzbUsrc2laRlhobGF2RTZGNDRtd2VYT3JYNkZCb0VMUnJ2SXJzc3Q0T0grTzQ3VmFNTDRDSy9jTnJqbFRvZGZScjN1Mlhac0hDY3c5a1hMR1gvMTVzbTEwRFltUDNHMzM4N3g3TER5Vm9wbHJzMHB6SXZmY3k0MWViMk9iL3dNNnRRTkx4UUtuZlNiTDBleVlMK1JXUjA5cWVIVC9sV3BDRnZjSVNZbG1kRi9qTWFJV0R5eEUvTEExdGd1WU9TaVF0U3FIZmdxSHIxbi9rNW5GaG5VQm5VMUoxZXlzLzhxeVNtV3dJcGxnZkQzdU5jRkhsZzZ0cmYyQjExT20vZjdFOW9uTzUzc1dIaGFzNG5OdWhCSnNVbjJPak9uT0FGWmkyZGNBdmV4SHl0VnhJZHliakhjRWRYVWNwMGprYWIxOWh3WjBSZGRUVUdqdHl1bEJtcGJmR0QrNGQrb3luVEVqbU1sWVMvcGZvQ3loRWs5WGJnYkJmN3d0RnM1cWxlRnJDbUIwTnJVWVpMeG13KzJ3RnFZRVV5MmhZUDNaeFk4dWhSWmVGWFpmaE9ENTh6R0J4N2xvNHlNamlCYzB6dk9HcVZRbThkNHRrMUNScHlHSk9HSldWVTRFcEhQeHFnTVA2aFY3ZjBJeEp1Z3ppSUVKSGF2clphdVJYZTAvVEhZRU9LcGwvYTRqbS9mYWgrb0F6SFJCcXdldGpKQlNqTnA1TGFaM1pVTlFFbFpKQkRPRjFlNG11dW1TSEY2ZGEzOTRDdnBwcTQ1UU4xQjJ3WUJmYng0WTlmbnE1YitoZVROVENtUDlYaE1RR25pRGhtZGhHemZQVVk1WVB2VFVoRWNhYUEydWNORFVPL3h2YVVWaFhESW9kck0vMDVSMzFibkZralVqbjM0TjdBaXVhZ2w5VkI5U2pZc3U4M1dzOWVvZXZhWlZ3Wk1DNHVpWmtvMkd0TnpaQ3lNSFJxNkdLaHZFR0JpTTFnTHl2TVprM2VSMmRHY24xOVlYNzJKbkRCWTZSV25jRzdsR0FnMFlaUjlseW9DeVExM2d0bnlCaTA1Z1BsTzl5T2VJWUdxUXJoZ1JwUitwQXZ4NGN6ZGFCTXBWSTdTZ1pNQWhNU3NkUFVFUTlzdFR0d1NhYkJtcmxuMHVIc09NaER2aTBiTlJVV1VtcW51M2VpTGd6azJYS0d5VGFIQ2U1OXZaWmNtRGtrOGFPTzZwVHc1SCtEV0FMQlBNY0NPbWZJejRjRjlFNXplc1hiUWtRTkRGazd2bG5BY2V0YnBpZCtDZTlNblRiM0NsaHYwbEw3bHl1c0pZQ3BMcGFsVlhtUTY3WU5SK0lJRGg5dlc3WGVXblUzRkZmZG5PMHlxQ09OMWpvc1NMVk1UVGFIL1QzUTdZK2dPVW9mRHd3WGFHeUdSQis0R1JDMmtrN3pBTmxnZDdQbUU1a1hkYTRJcG1UYlAyT3FVSi9POUVYVzRhc2xRUjVQdFl5M3ROTWFtdGs0THd6YjZXSUZsbDdNVkJuZUc1dlBmRUdzbGJsdks0dW56TExJdmNlSTZXeGhpWk5jL25yMTBrOW5uOGlrS1B6NWptQTlvQytsV0lFOFFSNFhZVGNPNldaN1ZNT1J5a21XTEJiVEUxTlFjOC9UQnBZU2FZamxzeU9LNTBFRXdaQzYvaHlNaWx0RkRVL09jVmZTcy80czBSazY4cUprVTVtSUZ4elFjeVNRU3pMS21xUXprYmIyWmxDOE1MTVA4VHQvdWkyVUszcjNJb3lPV2pETmZBVisyL2lZQWJhVS9nY0V1QzlQcVpiQkNwSHBvYnJzTVNKcElwQWJkaytsWkFyTWFRZmRRUDJrWTlLcms2VHNqTmIvYWQ3R2hjL0hUbEp5eFJJU0VvaWpHeXVMaFVKQjVDaDM1UHJSMW9pYm1SRTN2dmhDNWNXai9BRkZNbGxpVDVFTEhvajlpZU1MRUcwQk9rVlJVWEt1djJiZmFGOEFkWE9SbnpUdE1mWFlxQjhVVlk1VHZ5Ylg0TWtnOVlYYWlERHJwN0tWOHdWSHBteDNNSWxtUmt6bkc0UTdEYllOVFpCRWkyeXhRZlFXMzdOckFPeUNQOEFYUC9FSGkvQkxMRmcvaXAxdGxlWkxvamxucGR6S2dTbUp5aTRJUkRXTmlmQ3RGeFRSanpoMno5RE5hM0tVWkxabml4cmtzUVdId3AyZ1JrbXV1N0hZUEhZSVFyZGppaDBXbk5iN0NMN2hGRExqYmZHYVZMUWg1RnU3U0h0WlRxRFl6Z1k0UW5NL3gyUEM4djYrcW1DQU1iT3ZXeFpPSXhqZ3BVRjF1ZDIvZTQxSzFiSkFYUFRaMGN0SkxzaWdKRHFOSDZmTnNYR0dYTng3Y3dKUGdQNklOSzNReGMzeWxmdjBMMWU5bTM3aytDcWtKSlRONk12dlF1YWU4V2pPMWwwSnZCaDZ5SElyWmdmL0J0L0ROUzFRVUxnSGZVQ0xkd0g2R1ZYeG44SkNoenJURUpMNGRUWkdENm5Dd1BXRCtlZVUvanhOYy93cGgvSFluZ0laY1NUT25BN1pvSGVtYzdwVVlYeDBOcjQ1U2JjZTlDeUF2Rm5Dem9JWWJYeG9EWFlWd3QvN3NmNTA5VkVmdm9MempiRnJSS3I0dm50YjVkZ2VEaXdSWDZuZU8weVFac09Tb1ZqVnZPT1NBdVA0UFQrZXpLZ09UTDVDTWVCRmg1ZlR5Q1RuZVhITmV4THJzMXBCcExISDNrbXQvR2k2OTM4QnlqSnlHUjF3TTcvcnZSUVFvUzFkclFqUTB2ZWZxSUpLbGF2eFVBeWkwUHVJTEF5R0dmYWVDenowMERLalkxY293cFJ1d3dmN3JZUEVaT0J5anR0bnFqNkVVWjg0RjVnWnArNEhKbVRwTWpOcTBxL2x5S0Zod0hLRzB3a1ZwNWgrZ0VTeDgyVktHUittYmFvOFlPaDIzSm5FeStlTko0NXlvczdkMWdGYzZHQzY3ZHQrT3pFNVRwQVlpY0VwZTJZdHV1SUhOdDBoUXBkTEJkUzhlcXg5RDlSU3J5YTNoMTZqWUlwOU9nZnY1OFVTVHJRYTZiT0pnQzZGdXczVlNvaG9VT1FwUS9YWStQVkt3MmVWOFExTjZ5eHp5bVQ2UUlpTGl6bTNrY0EranRGVkpWai9JbFRUR3I3VGo2UDhmUW1oMGFnM0FKZlJiTHM4bm1FUTFRSEdVdGFVdjlkalRnS05HNWhWTHlpdWpITEw3N3RObEhjWUx3cXF1VTZaMlYrV01vRHdmQmlNRHFLMzkvdE5oczdkWFFoUVRIWWtvbGQ1VmdObVYrV0pyOEVUeW9LVEhUUzhnMVJaTCtLQ2JadzFMWm9HVGdSNmVObGVxK1hHUmdnRzlwYncxK1djVzBqekpwdlFsZStwRFdUQTN5UGFKb2dldW9oZzdFaWpSLzQ4U2U2a2p3TnBHU3RlbEFIV05PdHpyZmdtTnh0SDlyMWVTUldMejc5blJORjV0aDQzVnkrclo5RmN3SzdQbGZKb2pRbWs2eURJZ0RWcFMySUp0RmZsSGtsMnBkckEvWks0R3JrczlkZlVSR1VOazU0SGltcGxLYVlFWlg1ZEUyTTlXLzYwdnhUTEJFNlhlSVowMWg0WWlIQkhHTVgrZUFIWkFIcFNrMmRGWlViUUwveWxicThWZHp5T0Nud3pCNTMyeEFzejJYcW1KRk5KQ1o2WXV2RXB5WnRMYTA3R3VoUGtpOE1lWlVJNjNLTjRqQzMwU1NYNy9iV3BzTXlmcHFyem1NSStjQ1lsbVJVQjBNdTRrRy91bnR1SWxGeldHMkpudVNUaE92TkI4N1d1eERGNEs5TVBMdEFwQTJuUFYrMnlNcVp0UXUvNWVCZ016ZzgvNkZCaGRkSnoza1Ywb25LNEpibzcxdzZkaEk0Y3pGM2tzaDcvd1ZlMHZBSDhCL3BWR2Ixdjd4c2NQSWhnNktMK2h2VHRxNmcxK2tDUHBCVVJVaGtqNnlyZlBnWjMvWHRjMjJNYVFKcDBvdUk4c21GMElXN1A4WmZrQ05SbHh5b3o1ck9sWEoyWW9CWWYraFpKQUNMcElXNkVjZzdzMmZwdElXdHZ1QWdHdkdWN2RTTkxrWXYxN2doamtKUXg2dEx1Y25BcGQ2VjU2UEFLTmovN1l5aTZNT0M5dXd2WEM0SG5RU29sTVQ0OWM2LzVaUklmV2F1T3l3K2FyUUJ4RVQzZ3FqZ1pQbGRIRHVoUERkWXhmZnVKMWl0eXV3YTc1T1V3VnpDZlEzRGhoS0FmdWllQkZZcXFOMWk1dXN4ak5Gd0thZDRWMzlnanQyd0xqY1MxeVg1OXF6MExDeVZXOUtiU1lVOUEyOGh5NURDN2hkdGRReFJVOVBYNHZmZzhSNEtaenBUN09oSmU0UndudW9iODhLc1lKVDNYZGI1dVFqL2lJMmI5aytJQUwyUmF6UmVnMm54d2kzaWE3NzFqSDhtV2NTdEFzMU5KdStjTWd4Nm9hckZxTGU4YjFIU1J4UTd6YTBXdFFoVktkaE9TbytsNU15VWJPN2w0cnRNZjh2T2lkUkRZU0JvRVN5aURpclpSL2xpcmI3bU53T0hSOUIwMFUzS0RIalIrLzYvcDBGakhDVnBXTk96SmNXZklSUWtaNlhtYmRYb0dOYllpKy82SzMxa1ZRU3BFaUZIbGYwWFRBelFLRGgwM0JKdjZhb2xkU1hJblFmQUVJTlkzNG1ON1RHdmFJTEkxaXExRjhxUUQ5TGRVeU0xeTFHa21JY29WaUF5YXFQbVRGNnNydGFudXlUTTRMMUQwd3l1ajB0RVZBZnV5Y0dkd0VPTjRmbnNDcWx0NVQ2UzFvYmduVXV0cHJTNHM1V3B6UWd6ZDRVOVRSWEpFcmxpMitvMmJTN0EvdUlTQlpoZ2gvNjc5Sy96TGRhNmdXdHVad0F2VEdOZENiQU45dXdadGkzSGs5a0tXcklxL3pESHowMCtmU1lMY2M1c2dqZ1k1c1dkL0Y5bkdpcmdHb2pJQ01UeFV6R21WVnlqc0MrMGlaN2krK1VLdUxBMktDZWtJZ3lsWGorREFaVktVRmdCZ1hZVzUrMWJ3eUFTTVVsdEI1TWhDY2FNdWl2eXloWnczTUo3T2pqbUp5SCtzSDd6d1dPd0ZhenR3K0tRcGw2RVR1bkdaNHdnWERra2VwOVJEcFhIS2RFUnk1UjFLZk9maTYxbDRrWGtsT1ZpK1V2SVBiR3VLeFRxU3VLeGpnZzVhVVUwWDNWL0VLZE91Z2JZeWVZS2xZVHlmZTZQeTZ1MlorQTBrNGsyZ2lIaVVWcWtvQzhNS3hUWHhtQ2hTczY4V3J5QU1oVXh5bzg0T1Jkd1RPTmNMZG1yVkpibnlIK3VnbXl5eDlpS0VQQURzTWlqdW8yVTN1SkRhN1duZnI5Z2N5Y1FxMDA2VnhJd3JoazBGVi9CRGpxenF1Tk9zRUpYZHJpbUd3MEcrSlZVNC81Qk5rK2xFNWtTQ1l6OWNPT2ZOQnRidFBVb1ZIbnUxamZQd3dHbGFUYzdHVXhQY0RGbkVnd2FIaDV6blZuU3dQQUFkWHo1bzZ2STM0RXB6ME5LZngxMXdtVWpmVzhuVEFuNjAvQ3dQVjRYakhNMnl6WGJxL0VBOWhVaW1wUHlIK2dNV1FjOGZpRXBhVHRrN2wxaUFEeHZETzhFTWRsYVEwblhkWG5oQ3VDcnNvQytVdmxiOUlhWHBUYmhEeXpUellZVVBSc0oxa2hZVTYrVU1QazFZSG43bUU1VjMvRjI4WWlhL3dyd0RkRitSNlRtVnpzcXVkeml4N055VUdrNDZ3WHMwV2FISVVSY1pEaWNHaVY3U0Vob1ZOVFUwemdCb2FTZDQ5TE5uQ2NtU2dXUk1VYTBKS2RwY1ZuZm92ZERjSXlFY3FPWEQ0VmVQMWJhVzFPNVhLaThEdVp6TnVFTC9kcmFmeGxrSHoyUklsYTBKcDhJTE5uN1MzZmRlZzlVaEF4OXEwK1NLdGtacTJLc0pyZGpqeUFqcjNHZlRqVklEQXo5ODQxNE54WU90UzdFV3MyWmFGSzcrNFdCWW9DNUhrZXE0Yi9UVlhlbjJXNXN4R1VYR1ZiZWEwUGZJT2llRXpxdGFjWTlpWkg4SkJ3ckx2YU85bVF4OFM4WHMxcW9RQTVtUnVoTFVGSWNER01qMXdKSy9LK3ZjbEI1QmwwNzFQbHJwcTUrTDRXSjc3Zi9oYWVtUjNRQkRWTitEWW8vTk1NRmtxb2tJN2IxblJ3dXpEbUk1ZEV4NFhNbEdBTmQ2VXRaWlZRMTIrQ0hqd2lMZkFNOXlQV2FlaTZ3UmpHYnhCUlpVV3h5dC9sQTNCYW5scVZicmRTZE1CRzVwM2o0UGE5c1NmWWpVcjc3ekI5aDJxcG5DNlY4dTErWEZtR0JUUDN5OTdLQ0NIeWtHZkI2bWJDTm5nMk9ZY0RmRnhTcDEyTWFxdHFPd3J5K3hCOWdVa0hsbmZXOURFTkFHcWNZT3hGT1d3WkhBSkVlSXVQdXlMcjNwYzhldVFHa0pBNksxcm1ISkRvZUFsMzcwaG1IWStXazAyV0JOcjZiT2o4b3dsYkVQWFpvYkJRL3hVNEpWTjlsMkdIMG5uSWVkb2tYeUN2QmlxK2pPZjkwd0VDRmhoeVhnYUtpT29zK0o1dDVpNzIrY3lTQ29vU2V5cjg4VUxUMm13VXVNQ0xEdzlQdHk3MlBCeWlFdGF0cGlxTmVaRjhLbGFkZzRqRCs4aVkrdzhydS9QdmVBVm1yQUJNZnQvWWV2Rnl6bXlCMUxOaWRVejh5cm5vbEttaXR3SzJiUEpyUXpTZnlNZzdSQ1p0bmo4MDFRbXhCMkhoMVJkT0RKMDROWUNSODRta3llVm1McnlTUXNQZldCaVphd0lQdXNqM1c4MDNZVHJDSUZaaDU1YTdSaFlTQWg1dW9sR3N2MFRNQytwZlo4Q0pGTWZocmpJa1BYNGlQbHBvVmlqMG0rMUVEUGFPYk1oc3NvaHhpUUxqQWI4dW44OGVILzZaOFNuSnhvRERZOUpqSWtNMjh4ZTlHOUJNcUU4Q2RSaXpOcVhGK3l6Rm9xK2kwSlhtR0N1bms2bUd3Vno3ZHcwQWh0MnlaTFhMMWpncnJVcFA4NGlrQlZsakxpSm1BQldjT1V0NWFxNGUyRkxQUDRJWXdOdzYvNmtCR2hVdzkyanFHdnp6U3oySVhGb1NHa0ZUaENaNkhkaTk1azNoYlRSK1V5T3ROWHhLZjNxT0h0b0cxK3RPNXUySDZYdkNlNE9aMElzU2RWMkMyMmY0WDBYUmpub0xJOWRrQUpjbWFQenlMYmdyV2dqL2RpeldIc3JOejVQekdDQ1o3enl3aFpNeWs2UnJFSjV1Y1o1azRGb3NtOCtVOTRaeUpGSFlhSHRoTWhKU0xnb0hkOXBscGdneE5GZWFCTXgyQmRTZzhkMHFNMVA5czN4SFRyN24rdXZGc2ZVNXFKYWZBa3lmQWkvZ0MrT0x4Q3cwdU1sL1hKK2lkM2JwZEc0VnhRd3lLdlpheENXclBhUkhJeTlLY2RSNDNqdjlqZnlrR1VUekI5S2p5RjFHMFNreU1ITWVZNXdnQW1jRXA5QjhmZkQ5MkdSNEZRRXhYQUQvUm03MHh5ZjltcmcwSG93SitZNW8xdHJ6M2dKeDZFbStwR1B0MFB2Q1ZTWHNteUE3QkxNcUlpTDhpS3l2bUZ6UjBPN0ZKUG9VRDVkWkoxZUtuNHREVUpKNFVtYjcyWFRIcVIxcXM4S3NIUHB1MUJhczJqTTZGb1RNeW9YNWFTY1R6MlJWSkgweHNvNlNreHh1TUJnM3VVYmx6NGZqODNTbksxR0FEWDhaSnRyWTZsNWxyYkYxL1p1U2kxQlNoVkFkRm5mQkIzU2gxU1c0S1F6Mm1MK1k0c3ZXd3NwemVHcDRXNnBURktkTURqT3hIemtKSGtBZkxqTGpxZitUMUF4YTlvZytDbDdnUlRpNzBiU1dqc1FNOUYxOUhxSDFJZEpPb2VyTE1RVExwdVZwRlUvL0c2L2hzeEc2c0ZzbnpNSjduNzNTYklpekJyY3JpcUpRb3Q2c0tlK3VQMWdPTlVWdUJJUGxESkE0OWF0a3ZhZlNka1M0TlIremNpQUZyd29IamRJc1ZTSktxRHhBVnJNMTV1RkpiNGNVSTFaNWozV2dvNGdMcUxaRE1kTnRZS0oxUDdvQlRHU0JLWkdUcWd1QVlYajlGdGNRNHNTYnV3QXZFS2owaVNIZkd6TllwQXpNaElWRWwrTzV0VkxlNHMvM3VFZDlHc3JsNmJvZ1M1SEtRd1gzWEs4Vm5qN2xmKzVxSVFpVFN6Um5ma0VwZHh4Z1UwTEFaRzdPU3hqaUhrVkQyZ0ZhWjFHaktoSWVkY2U3ZEZVd2FjOHFBOFV0MjUwd3dIN080cktIRkVDV0VoaFBmeXlOTkZGV2VGcmNJakNCOVFrcFh1ejBVODBEWEZpcmV4Z2d2NmJDdnhsenJwWUwyQTAySHlrSG9nZUlJdW0xNEFUeXpabktTZktOWnFZVUhrRnI2cU4yL21QTzFXSzAxQzlDcHdYY2wzZkxFZmljbitxTWlGTkg1YS9KRkpCQUYyWlpXSjVFUDhtR3pQQ0Y5Q0RscjB6MFlIcnVQKzZiQVVHNDdDTnc1eURkUjBXRFRqcS9EcURFOFcrL2ZjNmlUQjRyOTk0NVliSGpSNzZacW9PRkFrcDNLblJuaVJMZFdLNWlLdkxDQ0gvSmY5dnpIblg0TGZkSGxBaUV1Y09BRGQ2YWFUSm5NRFRCMERuTG9XOXB2QS9UdkpQb0gyR1lPd1V5QmdEa0d2N1ZMcVJQemp6OW5JV3lsbm5XcUlsbTdMOVlSQXV1Y0hJbGVLYVRRQ2VVclhQMFdueXAybm1CeHplRGlWT1BzYXA2bDZNWUxITzR4ZzhIQkFLM0oxZGd2QnBJamNZREtaZXhKVjVtZjhjMGhwdzVPREtUd2RrS0NlZVRlemNQWGgvOW5JL0ZsUmNJWXk4c0gzbktDUTBFRXVjVmkrdWluTE5YR1RtWlhTdUI1allDMmsxUjZYOEZZRExTczdHM3FnK1dhMzAvU1paVnNOK3ZiSVdQRFJxczlITXovVjJlWFJyeENsR3d6TVJaVG5wd3VxckQxR1RqTFVsdU9mOXVQeWdKR3hlKy9FQjZBazVVQ0NzQ1dlMkdMRDVpWlg4eXdxR3lhUDlDR0tPT3NRNTA0dFNWakFNUFBwS283RXg4TFQzeFlkaDRRUmVpamZhc0x2TUtkOC9idTY4OXkrV1krUzhJTzlMWFY3S1l6bU9PeWNuYjdpbXNqZWlCUENaZ05kMkhkMmZMSVFPYUxvclBrS2pGWmNHUmFOTzZscCtwQlBUTXZ3OVFJYll1UVpCbGh1NDhWbVYzaS8zWTBtNzFCQ2hVV1IzY2ROU1M0RDk2WUM1SjBZN1pGcU1IQlc2RzlwOXBmMUVNdnNvcTJkelgyd1N2TllYcWRQNDd6eWVQTHJrK25yZWI5N2NCTmFvN1UzNGxIRFhlRlErSHFUOFh2Y0UyNmc0MlN5UVptSEZSbEgyVVowa29ocGNnbTdMaTJ3QW8wSUhNcmUvMFhmUlYwSHRhckI2b2cxMUtDM1o3L1JVY3FLekVQQTdaRUpRZ1pOZ0JaRTAyTUZUNzAySE42N3A1MTZOdnFrbTBHang4M3dRZFFNZXF4bG1sOExESzBWNVNkVGRuYXRFSzdDK2JoaVEzQ0xSQnVwVnVUZUdZaEpZL0JicnFpRTFTWTF2ZFhaMlNGdXZOYmNySTZFckdKVjgvcUgxYWNERXR1NThDbTlJWVhsUjRSLy84RlMrc2pLamlJUGN1elZRKzliVjI1TU9EclJZVHp4RkpZYkxocDJVbS9IS09uY2dMZEtIajd0T3JNWmZ4UjZDclYxcVJBR2grdkQ1ZE1NRGtxdmgzUnRGSThNL0IrOTVnT200ODc5ekxqQVJrZlZ5Y0FPcWpKZG9CZmdXaldOc0puYWZUa21jN0IzbklRdi9Eb2VvbDl6YUdXL0RscGVFSEhMU0NWQUZwUGNvUkZiWHFJQjBOSWZDbnNLY0s4R21hTlZlMVMxV21EalI5a1YyV2pZZERwdTNkK2dYM2VkalozNjNmOWpRRWJVaEZYdHVSWE9RditnbVlDdWJxQnJxVW9hZ1VkUDd4ajBISUZFWmc5My9LWjJDclpmTjl0MEE2V2NwVUpCSTVXTHlvTG5xZjExakp4emk3WFA3aWNUR2lmWGg4SFBkUHdPdm1iN0ExQkZjZlkySDF5cmdwUTlMTDFXUGM4ZjRkcWZ1RTkxQk5xOER0Y0VxbDMvMDZyR2s0Z3NOeVdJNzdHbkg5SUt3VXNBRmxycFVtQTN6elVQb2pvcmlnOC8yQ2JkM1Rqc0NLTTl3eGxpQ0x5S1BuZ0tzTTFLRmtxTTZiTUZ0eXhZWXJVMmVld2N4WU02UmtMSXp1Q2J0MnRqamtyV2tTVm9JUzVsR2FlSDlBQ3Nnc0NEOHVCSlRnMkZHK2pPWHdUVFNDdkdJV09pU1BtcklLS2NxRUlTVnZVY01XaEhFZVVLalhUTWR0Qm1QbDhzNFdpcHdUWWEyajdybWFhMFJOZjdJWEFPVDc3TkdlcC9xMGgwS2RXUm81VVBFUlR1ZmdBcUhndHVtMWRaRVBxNk9IOElMQStub2tkOE1YUGhDa28remdrTnFObHJMUWV3NXVnaVZCSStUU2FGMCtOaC8wbElwc0NvQlFXbERhY1ZEK1Z4M3gzYVNYVGJrcDZVUmFmQm83cjRXMFlNSllMME1ud0ZNNW16U0J2SDQ1OW1IQVoweXpUMDlkRVhnalZXOS9nZ2cyTHhSTzZ5R281RlRwR1FTNUV3TVNqRzNjcnRkM1U0WDRDTytLWDVXNDZUQzVCL1gvRHBFaXBGaFdMYUU2cnBZTzByNDRLd3NTOUdlOUgyZGZGWTNRTnZYQTFzV0hONldSMjVIZ1EwOTF1L0ZteGNtVFhwdlhlckgwYjV4UmkxTXdtR21ySzRaQVQxVGFwb0Q4K3Ntelh1VzR4ZkZXa1ZET0w3ems5eE50QjUzQTMrZEpySXpjNU9UQjYwMVVYU0Z0UWtYM2hXYVNuaEIwZklXYXhwOXc3dkdRRFl0REFlVFREaWdyTE1oVk5mTFVwSmNJeGhyTWpPMEFtaWNiK1ViYXVldjZnQXBKYkJ5elZRUlRXcTA0N0dHUlNZZ3h1a0hubGs1K3hXVFlUaTMxY1FRQ0o5SUxaUkozdFYwNU0xQUlnTmVlRFcySDhJQkpxa3pTbDlubktTYWpHWU9EN2VNeWpISFdiRzRTRVY4Q3ZBSDhJZXc2U29kUFNsWDRzcE95YjRPOFhkWVEyYm5lOThqTU1vbGdCSWJjOGoxVmZQaG1kUGNxVmNtZjVxTWpaY0MyVnpHU01GOXM0ODYzaFlQVkdxODZIdXk1Y21nNnpCeitxRFUzeWplOXZtRXIzeUo2a1poRjV6OFVkbGtKZGpxLzU4MU85VnVDUjJCM2x5RUFmUW9VWm90OUhkVklMYXdyZXlSeEF5MTFKbHBFM1VvTy9maTUvNW9ta1VzMEE3R3ZiNStic3RlRlZJVys5bCtxUjJkSU5vdzQ3c21BaWR2MGJMTEVyL3lxS2NVYW5qdml4eXpBUUNNNUNWenEwcjdyRFI5TTd3akx4QnE5ZUJXUlZteUs5VGZTSnFYSGpMOFQzbDhwaHF6V0dacmtSQzVvaVBPNkM1V2Y1OWZGRFAraXR1VWFpRXF5dGViWDBGZXl1N1U1TGVxbDVnQk1UZERQc21LN0tVT3lBNVR1V3hqR2M3ZE43a0pLRVlwcm8wVldSaGpNQXJNSUdidXR1NnZOMk9TSGI2bnZkNTA4UzRRMzR1Q1JLdTk2YlNBRDdZSEFTTlZoelh2OE44anJvWWY1WTdFOXM0d1Rwa3ZvM0Jaa2tXcXBGME0xdmthM2pqVUMvSnVadnc5VjhhdlgrRDliY2lJQ2wxMnZyL2JRSnhEZStUTjlNUXdESndPZTVIUldaS3RDdEgvMS8yYnJIVkRFMzgxRkYzSklJTGpaZjIwVVRGTDRNTHdtWnRGdjNNODhCdjF4NmhFeW9hQWxaNXA1UUVXemx3OGJKQnQ4b3JBUmhpb2RvZHRkdVl0SkJTRjdvY3RUOUp6YmVLZG96YWlmMExCV0wvdTlSamJlVk5MWjhVVjQ0WWU2U3o1NlZuOFFsd2Z0V0wwMVdvUHJ5aWkzWlo5MzBaeDZJbnMvSEd2R1FtSEFEKzJxdnVLUUFzOFk2dWJsYitEdmhwM1kyTk5NanN1ek92YjZtNFl0a1B6YmhsY3RLYWRleDh0QlF1bzB6aG1TeGZESVptNVZuRURkRzJ2WjZrY3lrWUZ4Z0F6M3dya1Z5WFFud3h5UUllWU1JSFFZVCsyNTdqQldEMHlKSWlDM1BxbW9oTXpUQy82NVhWZ1Nzb3dHMmtnbmxSN3BZWTE4bkJROGFWZko2NEQ3OXJIMnB5bU00eE1VMVprL09TMTRYaURjbGRoTzBjMFJoUXhpUFNZNzJYWXhwaWFLVlltek9jRXZJMVB6UWE3K0xWWjZwQkl3bjhmZld2aHFhMzhiM0lza1RzNFJCa1lzOWkraTkvQXFkQVFnMklPZVd2MmZ1bzV0RWNGeWVmSTluQVRKWFFjaGJCRVFPMkNqM2thQmUyWCs4MW85N0IyMmtZU3dqT2tnWnliZjUzcVpGUTZwL04wZEwvVm51TDFjWVRHaThrNnJNcGtLR3g0aitNYy9mY0hVVk5YVEtoeU8xMEZrdkhpTitxU2JKR2VwSi9hTFhvTFo4UkVUMEJzaHYvNGhBUWd6ZVM3eWwwbjc0Y2VkcWRubUFlSG1RMkN5WHZNTTBNV3BFdkEyZXpaSUtVK1d2VVNhR3BUdDFrdk1sb2VycW5xeEhMZlQwMVloMm4zaUQyOUVXbnJRc3lqZWRpMUk1U1VndlFLQk05RytvQWFpMTVjTzFjb24yUUZ6M1VLN3c3Wmd6TSt2UG1iazJRcVI4N2Z6bGJkVFNBaHJMWHpxVmZMbldCQS80KzVhQyswQlJNWjZpWDlsSDNRWHRLVTlEMDFLM0hwcmRpbEw0NTZ5NWxzbDM4VlFhTWJ6OWhrMExncXV6aU1ZMDFabnoyV0U0Q2xIRzljRi9lN3N0Vm1uODlvTkZVRTlOWjFSQWM5N0t6REVXSExvS3dsQ0c2TDIwLzJHajcvTTZQRGhzdmhZK0ZNellSZyt2LzBqbzJnUFQwVVRDZmFMQkRSVnZLUWdVU1lQTUcxZHI2b3g3b2hlcEJVUzBtc0hxL1Y3QTZZOVdmS0RnU0xhdHFUendoT1hudVhBb0ZjMUxzZGxWL052N1hIcWc1VEFvaFpHYTFtT240NFN5WTFmeVBNQ3hMMVFteHZoQkM3bXhEeWo5RFVuQnBiamRBenJCVzBtVXpaNTFickRWVzNmMEE4b0tMNkZZQmYwbXdLNll4RE1Kb2dxOTRPUGdwWnlLSEtCWXZKWE1mczZ1MHBZbkVuL2pQZVRWUU1LNnVZOUVnd3c1c2V0anF3ZFFtd2kxZWEwL3VvTnc3UUtQb3JDV1pvaEZ0NFZCK0hVeS9PYmpDRGR4cnlJZy95MHdYR013RnlmdFN5ZjB2L0VTT1ZhVU5PSGcxYUEwU1EwS093eC9vcUJuZU12U294WmM3U3F2UWFIY3gzWkxnN0kwRlFnUTk3OTlLdVZHVGZHTmdXdnpJTW5IcU1ObkN5Q0xKTU5vTlFLOVhBNFdrcSs2dFZ1Q1VSRWVoS2orc3pFNktsYVN3Z0FQZmI2SmVHcUl5QnJqSksvd053MnlQYVlCOXdIaWEzQTU2TTVyNE9wbEF2ZFZqTzF2cnNjNEk4TEF5MXpxcXBvMHlNMWhmaXhIZUxOREc2dWZYYVgvNG1XeFlwcUwzaEJIcFBibm94NDlQM2pqL3dHZ2RaRmFKZTFKVGVyMDM2eGQwWGFrNXFDSTZTVjg2eHFBZEFDaHY2c2o3RVN3MFNVN3cwbGVDaS8wOGxmWWZ1Y1JRSGR6ak8zSmtBN2x2SHcwb3VNQ1NDd2VQK21zNUhsU3RUMUhMbGdRL3BrTFEwSGlEa3VvUHRUWTZmRFcwVVBsSDNlYktKS0pzaUlsRXdBbldRMUV4ZlFoZnMxSVJkYkVPNnNneUM3dTJZcVN5ZTlXRm9IM3MwK2Q0UDJYNzhVUGNVc1JpdGJpU2ZsTWRzMys1aXhrNDd3RUFid0hPb3V2M2wwQVViOXpaSVAzMmhoKzhuM2ZKeDNMWFQ0d3FFckpYUm11ZnlkdnlKdUtXNUlrQStyRDdCNXkzaEpHVUZyZitqZTh4MldFWjkzTU1aWmpLRjNSNGhZNEU4Mko3eTB6OXpuV0VYcXRuR2NlMGRlak9Ca3JmNkNiUDFWQ2g0aXhoUnZtT1hPOXlBMEEyWFFxZVdZTmZrMWVVa1JXbHliUkRCaUU1U09PdGp1ZHhPcHFDNkh2MFhScWRMNTgvZHNyRUl0Vm9wcHZiMTNsOU1yWlJLek9lL3Z0dzlKUDlhQWtPYTdyYTZNYlQvM1lFNExsRUo1dGljS1dLZStyT0dpYmcrTjIwVng2Vmc3SjNieVpHOStoSXBVTG5aV0g0VHEzTG1sTUErb1VmZ0FiYnpQbDN0d2JEdVFvelNFbEk5NUtTc1hhQldldlV4SVdQUWRZKzRlb2xNbFR0THduKzUxU1A2QldGRWlpb1l5K3IyUnphNE9xS0pQTWJ4N3QwQ1pDdHBNS3hZUTVKQ293YkFIN0o0WTNFaDNDMDRqMUgvMmE3cUgzY1ZvMDFtZzBLalZWUjU5cUVObUxMQ25RNExOTVMzaTJYc2hFSzdRQUl2aTREK2VnWlBwTVV5d29nM3MrdHFSaWFHWElFTUZwM3JkM1R1dkxYVlQ5dHBKR3hqZ1FMR01LWG1HTDFNVmpvTjk3YnkyTmFPbjBKb0liT1FxZUJJSFRWYkJZTk9ONUREM1hQK3JTdFBJZlZidUhkKzkwVEpwR2g4QmxmVjBkTG5lSzJ3RE1ubmRWR1Z2UUxodmFReHU2c0wzWHN2dHhtUXplRldVU0hMZUFsbVRjOXlOUUtrWHRPSldTOWZhZXdTOHlvdGlYZEpRNkVJMXZwVk9IZ2g0NmdsalNsbFZEUng5cWxIN2kyUUZVL2RLcGFRRWJwQUZVQkkvZVNVR2JwZ1QyT1JHY1VHWFhEV2pRSlFvK25Da1FWbklNUlVDUDM2N29zNUl3NFJiM0xEdk9pKy9td2NCb3p6VWE0V2tqVmNTSVVSS08zUlRGQ2lZOWozTzZDNU1CUzZZMFdiQm9vQzBuT3poS3hMOHhNSUlhTS90bnlFeklkbEFCcnozZjlYbENpUTBoaCtDNy9iTnAxNGVVdm5qY0hXakJPU3c4RTdCanplWGtSUWtwSXVaU09yaXdaOFBpT0xaeENrWEZPUTRoYlhhNFR1NjlsY2NKOUhkMEYxbHhrZzVRbkFoaGZ4NVdkY1RrQkgzU2liQlVNQ0xQYi9jWXlwejZzNEdHRE1WNXNtWWlibGRwLy9qOWdiQ0VocWFucHhMc29leE9NaWs0U090ODc5ejIxaXorOFYzd2dHOENpY1FzbXhjc3FDYzVRVXFPWmhucE80cUFGZ3pIRitub3hOODM1UDR4ZjVFc09jUHZZV3d0ekszV0VZVkd5NXR1dnhFNVdaQjI0NlNHSURnZUM0c01nZTBCNHA3MFRzZTRiNk5qbFBIVys5MEdtcW55U3FZODNyMGlsYWV3NDZxbXdpNFJ6bU9jUGVoYm40WVBDb0lTalE0NFJVUlYrK2RmVTUzdmNLaGtTajZjV3VoNzV0ZFNTVU5NeXNGd29QK2xOMmdHVHd4T2ZyaGE5d1d4RFBwaW1oRUJWcnQ2ZGNCSXZkb1ViQ0xURFFEWnVVT1ZWaFpQNHNBVHFxOHo3QWkwU1RuR3h6S21BSEcrM0krL3R2ckROL09PVEh3UjZXNWFXU1JqK001d21TNWhmZHZpbWx1czJ6NHBFNlJWK2w2c2NTRVgzWGpGVVZnYlN1dXVmbG40cVpmbWdCeE52SVpta1B0TWg0V0hBdHVxUlZkZ0RPTGtzcWRoanFjOWpyTlZwUnNZTDRMNWZYYUtoTlhZTkpmVG9yeGJhb1Nwb3FqNlpFcDA1eHNjNHk0UXJ5eDdCUnMzaVl2dUhSYkNVc2lDUG1tR2RVUFhEbjZIN3dvRWppejFZZXJpSDZOUEY1YXU1YVZydGN3MER2RWdMTEtNdVZxNlF2ekUxbXUreDlBRmhoSUVFM2pWdnpHV3M3eCtJQkdKMmhmRzhLYjU3cTVzRHNQbWRkcmMwczJkb2F2R3QzajU5U3BLa2JFVEFWeGNTd3dIYnBBRXNZVE5QTTFLaFZsN0VQcFFwK2dOb3R5UHg3aEkxMXhHNDdDcllFNys0eGxDRnBhRHd2ZjlGV2VzY2pFOXFOcmNnQ1h2U2VtZTBHQU9vNlFqc3R0V1FjUmd1d1daYjZPRzFWUE4yeFpjZnlVZUVHTEhoUGtyemlERGY0U0hOYUNjWFhKOUN0RmR5Uk1WdWVaTldxYW9TS2hwRkk5MU1NTFNYanUzcEdiU3pKbE04RlBmL294WmJSQUR2bFpaQ3liOGZiYjRtUVZCWlozR1dWNGhqNFBDckxBMXFRdkVxczlYTHNSbm9hbDlXYVNRaFdSekxKbUN1cm5HR1JjNnd4eUFBZWpwMHBBUjcwazBNOFIremlYcGhUYlN6NWpVMnhwMmNGZTFFaGVncnFQcWpGQXRZV2JZd3NtOVg5NjlvWWY3NlJTVnBENURmSThpRGZGSUxCa2Z2blphWnRIaWtRMnRmTlkxVDBRT1lhZlorZGZpUWpXWnhxckR4WERXYmMvallaU2JPenBnSjBIdkM5d29kT2dUazVkNWQ5ZG1Ocm5NMExIOGJ2dEk0emdrdFVaZGYvRGtZTTEwRUY4eU1oYkZxdnBNVGkrVGFMQlVOZDlhTFN6U0dBcXU0MXhzS3hzRVlIRlBoeG96WVpNUENhZmM0VTV0OEphN2szNGN6YjlwVHNOMkpGbndsOEFtWlNwSTM5S3pCb0VjRDhmejBDQWNpbzJLbGFESWhQRjhWMEhrRWJ3YzJjMG1rcEJhemhPTUkxZDRjeG5LRzE1bmxKK2hhUDREOWcvSDF6N2pJRUhTN2VuTDlzdCtyMTlpSnBxTEZ1SmlLRDJOVDdMWHlCemFBY0Z4SUovZm80cm9lWlN2SFV5ZmdxVWpTVmNQaXN6RUF1azRGZ3FqeGloK2xuNlRaVzhiNXNiREl2ckIxVWwrK2MxQjYzWGJGZ0hkVkpUYVJQeklYZWg1ZjV1K1FZdmZhN3BIeVFWMFpVSXY0U25mRk12VEMwZzAvZmRhYUJkOXJjcHh1L0NCcGJvYktaZ0NJeVZSRFpHZFBsWnM4VUd5dTcrSHhiNjRFL2swWUlJeUcwZDdaU0ljVTFkT3d5QVF0MjVPdzVCNFcvb1VoZ1UrR2YrcUIvRXFmK1YxMStHeWxFa2l5R2FnMnNTYWJuQXdnYXFUcjU0OXU3VVNYOEZINkVuS0x2MWc5amwyeklVN0M2R00zYWVEbjhrUCs5YUJNMEFncmwxNjVSVjQvVUhhWFBuckJqczNZT0hsck1LOWp6aU5rd3d0NityQzVGUFB2U20ydVZ1T1FvdUQ0K1JrLzhYMlZvVCs4YmlqQjlQTnBmc09zTmhpU09WZ250dTdkemZ6Skl0cmFGRXhzMnlsUHQwdmFuVGdaSlAzU0l4UHZac2dhRFNCTm14SWgwS1BMUytFWmtKMVh5MGdZOFdWT1pEYllGOXYwR0p0YTYrR1V5N2VrOGxpc1l1bUoxbnl3OTBORjVuN0w2SDFhRk1ZcUEvV0kyQ09KQTdwV2FmOVVnZjVwbmlFVElKTnlOWHRvbndaT0xlQ0czODBwMmEybTVGczRXREpJYlZDdGtKNzdhaCtoM0hNdkpKMGZ6VzhPWGZuWkR1emJXQjkzNWxQNXpyMit2T2M3Q0w0NExqTnQ4cDJkZUpKS2QrZDhuMW13S3d4V3hVamt4SlJWbHBJcXdxMWErU2ZldTFvTkdEYU9YeVMvTFZvaVdBaTQvUkZGSzc3ajhzVkJXeVRlcWMxM0RDWVdLZEViSFRnRWNJZHRCZXdtM2Z2VTk5VjhKNGdZTEppamRpczJPL0QrM0ZCejhrRy9Td0FYd2p6S2dPMVRtWHVBM3N5TFB4eGZuRVV4dHRrVVBwelFKZ0F6Y042bzc5dHBIcjNRV1gzVFZ5NFVTS1pKUFgvRzcvc0Z2N1RCMlJLYU05THZHODUxOFVUbC9vTks2L21xTXBTT3FzdjB4UlZ6Tmp1bWdhbXF6L2UzTEczZTFsa3JXNVNxdXFsckRKSXJOOTBBUHJvak8yaHN2YTJ2QXYxWk5QYkhWZnZINks4S25NbURiWGNaSW1TK1lBWGFmZFhMVklMUy9RME1TS3VSYUxQUUFCVDZBc0gxU3BCbGtpU0xYeWhUL2dUNUliZkQ2WjFKeDBuN2wzM28ydUdXNGxnZDhCUm44V1VlRUhCSEVuMlNDWFZRd2xSRVF0dk43aVNDMnk4cVNuZ0Y0eXRjM3ZnT3VjckdjY2F1ZWJ5VW45c2RLbWtoTW9tK1hIUkdMZzR5cjdOVy9aQXE4VURDVGppbXcwdW5qMjA0TllvaWh0WlROZFh3Z21DcHF6QTZZNGEzUy9icmFJN0ZFWEVMZ3BqVlNuQitkcWt5RnEzVG55Mkc4bEF6MU90TjBUWmRFM3dnYnFMOFh0c0U1VXQxTmF5VHFtUE5tRWhKVkMwZjZaZk1vcDBIUDVWYXdUeEErbHExWG9lUkFvSUdIMG9qdVYrOU8xM3NoMlYyem94ajVqVnlOR3VaRHRxWlZsRWVTSVJJMDVQVmk3blpmS3crRXVUNVlUa2RYL3FueC9BbVFYQUJKUjhtRWJ0NUE4T2FiMlJxTWRHK1AwenZESTBnT0RuR0RTTzJ3NFpPckQxemk1TG5ZYUlsamliYk9NaHBEV2N3c2Q2Unk1ZVVtaUxRMjRPcGFFck82YTMvc1lMeWJtOXhPSkxxZm43RE5nLzVTS0J4RWZLTnl5VVlQNEt0a1NNUUk1WG83ZEhjSWhxSDRsM0NSSy9nQjdXdEZVNmJqMG1SZU5KSWl0TDhnclliVXlacHFEdU1EVDVzNVdRc1dqT0VtUlNiTWlIN0hJa0VJUHZSdTBXeE1uUkNKS2pHRldkbEtHcUs5NlQ3amxzRUhDanNQamsvOVZFUTRXNXFCMnRSQUZHSjVZR2dibXlZeHF4R3hkdXZrTmRkM0laS2NJYnZ0RXRINFg3YUhleVY0RGNuNHdrRXpVTlJSaElTTTUxQXY1STFtd2kybGozRFA4ZDZLOWlGek5WRENTYitlYjlwQnUrU0VxWXJ2RkM4V0tTaThPY1pEajUwS1Y4NzExMjBoZ3o2bjZPWnkxS09oOE96S051Q0tGdDltVmxVZkpLekQ5Z2N1TDUzcStvVEhHR0lLRno0KzQvekxDMTNOM2wzeTRGbjlkek0wMnVHeUJHb0pYbUYzanJ3VzlPZ3VPc2gxRlZ5a0Uxc3VNNmtDL2UwMDVWUm5na2djbjI5dGl4YmZHU3g3azhKelRJZCs1d1RYRTFIZ0tYQ3RHbHdBN0w2RnhTK1JVR0dQMmF6MUVtOTFEN1RIQUNqanFsVmRvRE9sdFE3WWI0UzhuNGtHL20vQ3Z0RmZRQjBlL2UvSk1nSUNMR0tkczZ2NVRIRU5CN1dZT2RKMFA1czNHUXpkYmVYalVBRzVZMldDVUJzNUxaNnhEWnp2MUw3amZVSHFCYm1uSFc3VTRnK1VUWUIvdFc3QjBZYTBKQWJweldGU29WUUg2Q2JZNnE5Zk04Y2NlbHdXZHhlV2RqWm0rVGNtQkFIcGplK2VtdzhUNW1VZ2w3T212a3M3RDJ4azA0L0hqeW56VnlCTjJkSTNkQmd4VGtCMWtlTDl0TU4wV2d5alkwZGRLSThwaWdIUDlsT2E4aGI3RjJiWklhL0ZxUzZKSlBQSG5seVBiVmwrd2VJRzdqNG9jbVdIL09rdmFUNHF0Y2JuYWZrMm9jd09ralNxVW9iNjZlaGl0MVVETXdLWHJlRDJSOTJNWnVnVEhOZS9QV0FaZXNBTmc5ZUJibTJwKzRrcUs1Mmo4TVczQWhxYWZmRE4ra0sxOTVEVU00RkxWWW04QlFoT0YrT1dvTTV0VEQ4TEltQ05SZW51dGJVNnFSeHBhTURYQ0JVMzcvSzNZN2VvYmNnL0lhWmFCdXc0NEZ0ZUk2N0hkZ3VmazVWcUNEamxLN2pEQlV0VnEwN2hwUEk5eW1XVy9tM25OTFFsdXNOR0RTQk5ZWE9VQkRSV05uSGlyYS8xZW85R0V3VmdwWG4ydEcxUFVVeFQxNXAvZmJmR1hDdnBzajBRbHp3RXJDMGdlL09xbHNoN0UwUWhwcURBY3ZsQkpPaVhERC9idjAxU2tNMjY5cm1naFdISlBVYm1wcTR0cmo3SDZjQ01YTUl3V2dPTGFUWFIwdzN0YW16SnBSZUM4RlhETndreFNDYm1nL2FnMTdKZFB5cHR6N21SM2s2S3ZYb3I2dEZDZkV2ODVUVzdDRFdMRWFwMUFDMTJZbStMSzkvQ3hkS1BuWHo5UXo0eE5YR24zc0cxd0FmdGhpZlFmakR5aUNuTG8ydWh1TXpJOXlLeEg0UFVUdDUybVJlTUxtbkhGcnJMcERZY1BDK2NVN2dlNTVndVloR3YvQU5COTJZem9YckkrSHM2Z2RYbm5mRThHR2hmeWRHd3ZLQktDdHBEZWNHbnU0MU16MjhqOS9MVFZ0U1Y5V1pFb3hBTk1nUEdvNEJEYlkycDY5aXhZR1FXQVRkeWc5VFJEQUs3Zi9Mcmx1YmF0NjB5dVZaOXdjd3FaN05CUDcxbVg2TkVnZHZmSzFFZ01ua1p6c0RRbC93V0RIZEFvT1lDbzRwS3dZNUkvVjI2Y0tUTzRhTVljVi9ZRGRnZ2xPdGFzMkt0SVhCSkFjZ290c1Y0WWZGK0NETjRUNVdkWDgwOFZkWGgzL1VYTHJBZGNNREYzUUlYajFIeVVISU9rWEJIN0RYSUNiSnQ5ZU5pb3dSWGl1QjBkMUovRnFqUEZlMklsTmRYbndGd3BSdXNCNVBMU3YwTGsvQWRJMWdRbWFvOHd3TG1ub2gvTDlyaU1iTU1zV0FPSSs1QjcxZCtsR1RLbHh4NGhRbjRpeFJmZWR5WlVVc1JjcEdyZ0FTMVhxQ0t6Z2dsMC9MRnV5UXBlOUJzZ3ZaR2tFSFE0RUxrbDZiY0x0aUhaKzd1RnhtUmpuVjd2OFBQMVdodWcxaWdJVDNPVE1ubWIvZEdKUHVHS1k1ZlJkdldvYXR4Zk5VM0FCaStmWTdlSGlQcUMwZ1FEcEFDMTl0d1ZmV0J0QnVyK1NUK3k3ZnptU0U1UTBDM21jcDgvMzFYSWRxbTdzRVpKSHRGblhCZ2FUeUcrZldSR0FZNzBLMTBJQnZLSDJURTZJTXptMWs5Mi9DbjJwYXlUdXBLVHRvamdQM3VhV0lnRlZnVjBsRDBXR1IwUGFucWlLdHJCRndxem52Yi9yejJQZ3BTaldkMkJFU0xRcHhZKzZ0bUtYWm5qdlk5eGZSMTJDUThvL2FLejF0K1h4Q1N6eTB1RTVmL2thRlVDcnd4akw4Z1Q3U0VVSnNocC8vNS95dlBGSkhnSmxnc3ZYcCtnUlFDU3p6K3ZTNnJsM0JoTXNiai9IendKWXo4R3NXcHBPUURHVnN3bE9IRWFGRS9xaEltaERydDJEVWZOeHR0MjFHVzdLd0pSbjkvbXRZSWpsbm53Z0VTUEVwd29MeVRydTNTc1ZHelJ4blpHNngrQmlzZVVzNTdsVGRiM0g4S0c3VVBlSDFTU2p5OXdaSEVMbmFyOXg1Y090T1I3bE92eWpXbTRBYjE4UStxb014eExDRml0MFY4U21PdTdBVThYR1kzZVNYYjZMeStrYVFtRGtSbE9zdGdtY2orckQzNEtOejdMVHZMTDBPMVo5Si9uQ2pwKzFmbE9GZ3RiZDdZZzB0NWVOclB1cHB4WXhKZlNwbkpSTkw0UzNZVGZmblYreCt6VnN1aW9zZUVUL09uMndOaS9UbkwyckFRSUtzd2k3RXIzU3Y0OEQvK1BMc2EyV0pPU2s2RHFjQ0xtdXNJTERpejBGd0tFaE1ld3J4dE55TTJJQUUwLzZoaW9wSVFvVWdDNlU4Q0xpcmhXYmZWaWJTbkNHWmxGNXV5d0ljYVVsY0VhWVAvZXZva2JpMU5TcXVPNjJYTm5XUjQrZkIzTTFON0xhSTVwd2RIWU9LRWpnOU9hU2lUdEVEeXBLR09WeFpoZFFTMGpFdlo0NmZvTlM0U0Jwd1pmUG42MHA2cFFsZE5VbWltaFdlVTVMVW5FcFpZalBKVTZobUFzaDRBS2FMRmZKQU5yWjlvdTQyOHlvRUlGdWlZOVVnT1lrcXRTVW9jV3h5aWp4SytOVHR1RGRiaDdOSmN5TElsNkNVQldRalppTDM0QmswUWUzdm1UOXRwSUt1czNyNUN2RWRFdTVWYTJXeG04Q1FKVDliRVN6dUZCZUgwUUlSeWJLRkFVVnFOYTl0Q1h1a2QxandMWFlLV3N1TXVGZGE4UjFValZHMmN2QVorUjNsQlYrbkxrc0w0VGk2bHViWDNoS0ZjU3lGc0c1cks5cEp0NW5sU0dJa0JMUC9IRnFMTC9LWDBTOTZOZE9vNENTK0dZUEJrK2xCWnh6NllpZTEydnZVajhsNHQxaWsvNVBtdmJMT1RQQ2Nhb1BlWjdBUFVRSUtJY3hjTlVEaW4zUjFva2JlQVVHd3Q3SmEzRzBudFFva0JobGFqaXN5WGVxYmZQTHJUVEtwVGF1Y2xLcCtER2R5QnNiekZIRVl0SXFabmxMZTV3amx1Ri9VSUQ2RWd3V1BHajBGVktNNTlKb20zKzBZMVFUYitJS3FIWnYvMEZJRUV1Vkl0bEpIU2l4ZHphMncwVU44MEh5Yy9lVUd2NlNCeWJDL0VFczljT2NMQlIxZWVRWFhlN3A3aGZJaHR4eEJyR2hrOW43am9tLzRMWEYxMjVXelBtTUNVaU55RThpTzdzVlNtUmYvaVNORkJ2ZVpXR1BlQ2lyZko4YTQzZms1akNmQTNOUEVKeU1BYW11M1E1aW0wREtvOGFvbldYdHllOWlFOHZyYWl4bFZUQUdTWEZNalAzK1hpT0U5anJuWFREekFSbnQ3KzlndkhjdFFwYUFJMHphNk43YnE5UjFsYjU1aklMd214NEloNE9BMEsxL1h4N0I5anl0UEZCUmhFTzh4cVhMaHhvdHNJUmpuR1J2bmtNSy9LSjFZaEU5VDJtTm1jbExZZ01Tbis3ZHppazhCem9IdCtFY1hzdFY4eU5wVHNwcXNuUzk2QVRxM0E2Nk5iRjQ0OXc5SnFWaUJ0NGdXaTd5Vnp0M2tSNFhTSjhpRUI1YW5NcUcrRXNTeXJNUVZ2MHNNZUV5c0d4K3lZczZHMnhQSnczenFUcTRSekRRWFBoWXJhL1ZNbHQ3RTh6emw0RDdMM0hTM2trV2Y0WmttRm1uamNFTlBRZGttb2hsNnAvZ3FrT2crOE1jeXpOeHhiNUZsMTlEc1NyM01UdVNNcWhTS0RuOTVpYnpZQ0VkclpYSmlLYXF1N0JGQnVqdStqU09iT1BjaG9nMklzRS91LzNVL1VLMm1udHZTbkQwcU5rUFlvUlRza0JuTEozTkphbUwwVjRzRWJyeVg4Tk1yN01LTUowK2gyK3hNS1k0S0VScHZVcmQwYzZBQlhXSHFMZFkxUVR1Z0MvNWRoZG9MeTMrS3dnRzVGbkwwTVp3NnF2T3ZIa0tRUm9RcmNLTHV3VWxkMTVzMDVReHVySDY3QTllQXIwMmEvdlVXTkJJZ1A2dk9hNjlaWnVaS0VsV3R0SWVyUkRHSUFrWjU0Znc3SEJjdFNadGZzcFB4YWxpd2JPRUgvTGF4b3QzWlFvbnp2WGtuU1ZvZHpaSEExSnc3QmNOUnNZdmwrS0owWTZwTVJQcEliYU4vUVN1SHRualVvZWordmxWaHE1MDIxeE1VUEt4Q0svRDhyU1JiT21kdUhHODUvSnJJaW1nbzV3WFdQODNsTHZSYXh3Q3hlVEdWdDQ0ZlRVcXNmVUFSbVFjUzNmNURiSFI5U1o0bkpZSUV2Y0NqSXFMZXpKM0k2Uzd4Qm9wNTdqM1p5TVFYMFh4cjVtYzZJVW1ybE9YTTlmSkc1aURaUVE5cldzR1owWTI2R3pUQUVzRDZwalB1RGExWEFUMU1ScHh5Wjh6TjUzc2wxWUVWMEUwRUh2WnFjbkJucU1UWFJoNnpDOVB3RFhFazNPSHMyekxMSWpCaFk1KzdsRHhwMVgwcWNtOFh0V29yYXQzM21VeCtrRUREZ2FEVWRwY2xRcS9aTTZtTVlvRjQzM25LYkNLRHhDb3p1Z1NQVmFSak5Qb3NNRHk4RnVqdklKU2I3NjNYdUJHQklZTFM5eCtIWmhZaVVhOXhvZDB4S1Y5YVJ0N3ljeldXbExnZks4cW40ZlVMSE1CU1A0OG0vd1RXZkRCZFRIOHVEQUt0NVdNMDMzKzJiQ3B4RGhtWnRFK2Q3WFA2NXlCVE9mOS9FV2FDRytHczkvNWtWYldTMEpsZm9ESDZTaTJ0VkN6Q1JHZlYwWFpBVVdmWE9NSjVGOWRrTWFnYndhZXFWcXFiVk9ORFFHZzh6SUQ1TVVWN0lrYXpkQXo0SkxPWHNuMVJ1Wm5vWk5JR1YyTmExNStkUktZVUFtWEZta1dCSnBQTUJ3VDhONGJkOFZad0JuaG0zV3pIOVMwc2Jwb1Awc2dmMk9tUHZRNnNtTXlma1ZLK09MalhZdWJtdGlvQWhkd0RiNS9wTFJnM1BHd2ZIRXo2djlPT2U0QUs4aXcyY21hNDl0VjQ0SW44UmM5akdjcVNRbEZYUGRsQzgzNjZrZTRVL0lURnkwL1NRQmwxdld2R2s0MEt5Y3dXR2FMZjhjQ3RFaS80WDJXODk2MWk2bFlucGZOUWhHY1F5QzhzMm9JT1crUHc1NDVUaHEzWkJFeU5DOFlEci9wekNFbUJJOFUzQTRJaVFKb0hpRDlrVU1OZDh3Znp5c0MyS3FjNE9HZVdZc0p4bURldjRKbjRIVit2cXBnTjZ4eFNFTUFCaFJNZFR0ZUhpSkFnblFFWDlCUjJWMXNOcWg1RWNNdlFOWVlhNStiYmxRbjdSbGkxVUZDdFFrUDZFQ21Ha3htUE5rZzJDR1MybW1mMC9XRXVUWlN5UE10YmJybmZ0UGdsZU9tSjNqU20wbTFFVTlmUUhRbzFOWnRpK0tjenBKOG1TWUlWdFh6WGg0ck5KY0wzRm03QmJmdHBqbWo1VW51RHBQazhIdnFLT2oyREdKeWs0UjBNZDF4N3VtaUgwRFRPWGFMd08wRUk5NGs3bjZSOG5mcWl3ZWtnVVFaMXJSZWswSFZpTTVZTjBKTFdwNGY0TlJFOEVyY0dOU0haZDU4KzlLeDhsbWtjOW9nZlFtWDByWDFrQjhRUXpOYkgrZVZEZWUwak9RTlVnUWNldzN5KzBRYmlmWHJ0TEhYREl4c3FzZWo0MUt6N3ZmY1FSRTF6VW5ZMnBoWU5JTEs4YTY1N3p5SE5NelBpUmh4czI4czFKWDJraUNNRWxvdWJPWG5jOEJ6VStuN0xNOXd6dGY2M2VGV04vZVdIWFZpdlNkQ1dnNURmV3NrMkNGOGFGSnJPUDI3N1FFUGRrV2xPbGV3Q1ZFa0xqeWQ1d1VuOVp6YUtPSktuRFFETGZsaWlSTFRLbFU4VE9lUWo4ak9VOEZmcE05dGF5SlREcHh3NnNWbFp1SlJBSUxmeG4rUUFHSUIvVzFGR0RqdXVWdTYyaEZEQmR2elZTZmdlOTVFYmY5cGNscDBHcnBWM1MrZ3dCV241SjdhR2lpbS9mUnlJTjdZVlZYSnNuQW5WZXE5MHZEZEFWMFhlYXJUcWpUMkNrL0FNa0JXNlQvbHMvNlZVVm5GV3MwMXd4a2FoS1IwdFJ3eUxSS2dIZWZtM1JXaWUvcFRWUXBVTVp3Ky83b3pRU1crN3Z1WmQ4bHN2VDFpWDVyd2xwaWFGbk9uRGJIc3IxQXM2dkxFVGQ1SFZiY0JDR2JKSGNTN2F4OUJ5ZDUwamRZeWFnVXRqQWFIWVg4cnl5dVIvYkRrdzFvNGo4K2hYTWZienkrQ1ZtZ3JmUkR5bDRkbis1THhycVJBWExvREtwUVJFQUhxZExTc1ZTSmgxczhLblovU3NVVnEyN2NxK082TE1TQm1oVDRYM0U3NTBybVd3Q3NvQ3JlNmJULy9vRldZQUxqcDJTYmN4blVMQmFUdm5ZREh0ZkViTzFtLzNjOW5KazhaTzVLSFFUVjg4aXZUV04vUzJFWHdtaXNUUGRjdXBNcnZJOGU0OFFaZGtadTlXSHlLcm9uN01LaEdGSnc2WjBLWjN0bGVWcnZ2Sm84OXNpVXdCeVBZK0hzNGdrS1BCUWJMUU9hZWRjdi94ZU0rSWg4cmwxZUhFQy9DNjV4V1ZjaVRvVnFTR3A5SGZiaFZ6RlNyTzZrQm52N21Kd25STHZNRXdxaU5hbmtWZEpKTXc0aWNVM2xLeXcvZWNOU1dJVWRkcWxiVGhZTWlxOG5IalJSdWZzKzI4Y3EwT0k5emhwdnhGdkZnU1pFL2VBWXZtMHgrOWxaTytFSDlOa0JuZ2FxVTFOTVloZG9tYk51eTNhd1VOOXAwbUpRLy9lOUw2NVliU2hnb2MrWlVsTnkrYzZGNmdERUhYVjBKcnpldlBJWkZBZTJSeVJhMmROcXpMdmloQUFNQ3N6WXVlcXN6elhSa1N5b2J4NStMVExLMlYzbGZnM3diUzlEelAzUVc3VkhkSGJqWmN0dFFSdnRqckd2ZUpuTm4yREUyWkRJYnZrQ3JUMEg4UnpiR0RkbUlxNFAxZXkraG9ZL1c2TnVaS096NGR2NEhVTnpueGRLVjFXZjNNdnFVdjM1cjJqVEt2cFBXQlVXTm01Znl0WC9RSndwNnFrSU9zU3g3WTY3QlNDYkNEVkxNOC9WY01HK1QwaitJTnJnTDlzZlQxSUN0QUNIOEJJMEc2VmlVWlBWenpDbVFIVzJvVkl3WmpBb0ZsNittZU8vcEQ4dGVPMUUrMXkwM21DcFlmVzlTOHFodEgyR2hsRmxlYlBmNE5iZXpWdjl4YlhLV3oweGV6Uk5RV3FVcXRZUlRVYnV6SzdLVHZqRzRyUUhmekJwVm1LNHdETG5TSXdkU3pUU2sxZlBOZVkwV09wUFpUTGx2UTU5eHdnZkZyYjMyNnZUMmhTMUpBWjlFNnN1akZ0S1RpSjdieEk2bzRjQmhEYVgrYWRYUkVUaGhSK013QTRUcUQ3cmdhL285aVk3ZDZUVlJlMTRDUzJTM2lTUXNEMFI2QXBuaEcvMldhMEEwQVkyTnRXVGptYWJkS1UrS2dJUkRQOVJRWVZqWGlGMXFDK3h5TlZHMDNJOXZwbUVwWS9HL3pDNG5MT0tnWEFaL3VUaWtISTlBZmJraGZnZmdvOWFyV2JpeDVlSDdXVW85UlF5Z0R6d0NuVlNqYlhjN01paEV1ZlZqNldHYks5NjNwdzhWalkzUlM4SUgxY3kyeVpiSWNLTE81Q2dBVWNYSmZGMitNY25ETEt0WHh5WmFmN1NQQTZLSnErekYyTkh5Zm9lVE93SGhHcU5jbkhWcjFoVDczcGNveVh5ZnZDWUJuRzFCcC9hUjl0OGhvSTdDWE0zVVpPaXNXR0ExU0haMmpmN2s5R2xSbnAzbUYvYzFBVitKanZVc25acnN5YkVPUUpnL2RuLzllSmt5eWtRSGpiRjU2emdjUFg2RGRNRzAzV0tVTWxZeit1T1orNURaeTlFOU1aT1o5R01vTEZkcklQUFFRTGp2K0dsQ01wb3lIUFhreklPRGpIQUlEMlBybmFScHFXVkhoMHJuaWVESUxLcStFbXJkNVJuamdFOXBEVVhXVG1IYUt1cXFZbGNnRXo0emJpNDZkYldyQUFGQmpzUXExckxISWlQSkVjd0ZMQ09ZNEpObFhSWFFKcUNVS1hrMmQxUlNCR3pEUDZIRFNwbzg2M0JoVlJGRkY2dUlwalFWN2o1ZWJGZTNVa2tPLytjb0lvMkJUQWNnQnFPdFExMzRzOWE0UUp2b2Z1cUJZTUdPQk1zV1orc24vMkFPeER4NlNmQW5ERkd3PT1gO1xuY29uc3QgJDA2MjY5YWQ3OGYzYzVmZGYkdmFyJGJsdWVub2lzZUJpdHMgPSAvKiBAX19QVVJFX18gKi8gKCgpPT5VaW50OEFycmF5LmZyb20oYXRvYigkMDYyNjlhZDc4ZjNjNWZkZiR2YXIkQmx1ZU5vaXNlKSwgKGMpPT5jLmNoYXJDb2RlQXQoMCkpKSgpO1xudmFyICQwNjI2OWFkNzhmM2M1ZmRmJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkgPSAkMDYyNjlhZDc4ZjNjNWZkZiR2YXIkYmx1ZW5vaXNlQml0cztcblxuXG5cblxuY29uc3QgJGZmOTQzN2Q5Yzc1NzdmMTEkdmFyJHZlcnNpb24gPSAvKiBAX19QVVJFX18gKi8gKCgpPT5wYXJzZUludCgkNVdoZTMkUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSkpKCk7XG5jb25zdCAkZmY5NDM3ZDljNzU3N2YxMSRleHBvcnQkMTU2ZjZhNThmNTY5YWEwOSA9ICRmZjk0MzdkOWM3NTc3ZjExJHZhciR2ZXJzaW9uID49IDE2MiA/IGNsYXNzIGV4dGVuZHMgJDVXaGUzJFdlYkdMUmVuZGVyVGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGNvdW50ID0gMSwgb3B0aW9ucyA9IHt9KXtcbiAgICAgICAgc3VwZXIod2lkdGgsIGhlaWdodCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGNvdW50OiBjb3VudFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IHRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmVzO1xuICAgIH1cbn0gOiBjbGFzcyBleHRlbmRzICQ1V2hlMyRXZWJHTFJlbmRlclRhcmdldCB7XG4gICAgY29uc3RydWN0b3Iod2lkdGggPSAxLCBoZWlnaHQgPSAxLCBjb3VudCA9IDEsIG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgPSB0cnVlO1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBbXTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspe1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlW2ldID0gdGV4dHVyZS5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlW2ldLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCBkZXB0aCA9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT09IHdpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSBoZWlnaHQgfHwgdGhpcy5kZXB0aCAhPT0gZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMCwgaWwgPSB0aGlzLnRleHR1cmUubGVuZ3RoOyBpIDwgaWw7IGkrKyl7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlW2ldLmltYWdlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlW2ldLmltYWdlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVbaV0uaW1hZ2UuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3BvcnQuc2V0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnNjaXNzb3Iuc2V0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBjb3B5KHNvdXJjZSkge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuICAgICAgICB0aGlzLmRlcHRoID0gc291cmNlLmRlcHRoO1xuICAgICAgICB0aGlzLnNjaXNzb3IuY29weShzb3VyY2Uuc2Npc3Nvcik7XG4gICAgICAgIHRoaXMuc2Npc3NvclRlc3QgPSBzb3VyY2Uuc2Npc3NvclRlc3Q7XG4gICAgICAgIHRoaXMudmlld3BvcnQuY29weShzb3VyY2Uudmlld3BvcnQpO1xuICAgICAgICB0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xuICAgICAgICB0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcbiAgICAgICAgaWYgKHNvdXJjZS5kZXB0aFRleHR1cmUgIT09IG51bGwpIHRoaXMuZGVwdGhUZXh0dXJlID0gc291cmNlLmRlcHRoVGV4dHVyZS5jbG9uZSgpO1xuICAgICAgICB0aGlzLnRleHR1cmUubGVuZ3RoID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMCwgaWwgPSBzb3VyY2UudGV4dHVyZS5sZW5ndGg7IGkgPCBpbDsgaSsrKXtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZVtpXSA9IHNvdXJjZS50ZXh0dXJlW2ldLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVbaV0uaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5cbi8qKlxuICogXG4gKiBAcGFyYW0geyp9IHRpbWVyUXVlcnkgXG4gKiBAcGFyYW0ge1RIUkVFLldlYkdMUmVuZGVyZXJ9IGdsIFxuICogQHBhcmFtIHtOOEFPUG9zdFBhc3MgfCBOOEFPUGFzc30gcGFzcyBcbiAqLyBmdW5jdGlvbiAkODc0MzFlZTkzYjAzNzg0NCR2YXIkY2hlY2tUaW1lclF1ZXJ5KHRpbWVyUXVlcnksIGdsLCBwYXNzKSB7XG4gICAgY29uc3QgYXZhaWxhYmxlID0gZ2wuZ2V0UXVlcnlQYXJhbWV0ZXIodGltZXJRdWVyeSwgZ2wuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSk7XG4gICAgaWYgKGF2YWlsYWJsZSkge1xuICAgICAgICBjb25zdCBlbGFwc2VkVGltZUluTnMgPSBnbC5nZXRRdWVyeVBhcmFtZXRlcih0aW1lclF1ZXJ5LCBnbC5RVUVSWV9SRVNVTFQpO1xuICAgICAgICBjb25zdCBlbGFwc2VkVGltZUluTXMgPSBlbGFwc2VkVGltZUluTnMgLyAxMDAwMDAwO1xuICAgICAgICBwYXNzLmxhc3RUaW1lID0gcGFzcy5sYXN0VGltZSA9PT0gMCA/IGVsYXBzZWRUaW1lSW5NcyA6IHBhc3MudGltZVJvbGxpbmdBdmVyYWdlICogcGFzcy5sYXN0VGltZSArICgxIC0gcGFzcy50aW1lUm9sbGluZ0F2ZXJhZ2UpICogZWxhcHNlZFRpbWVJbk1zO1xuICAgIH0gZWxzZSAvLyBJZiB0aGUgcmVzdWx0IGlzIG5vdCBhdmFpbGFibGUgeWV0LCBjaGVjayBhZ2FpbiBhZnRlciBhIGRlbGF5XG4gICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAkODc0MzFlZTkzYjAzNzg0NCR2YXIkY2hlY2tUaW1lclF1ZXJ5KHRpbWVyUXVlcnksIGdsLCBwYXNzKTtcbiAgICB9LCAxKTtcbn1cbmNsYXNzICQ4NzQzMWVlOTNiMDM3ODQ0JGV4cG9ydCQyNDg5Zjk5ODFhYjBmYTgyIGV4dGVuZHMgKDAsICQ1V2hlMyRQYXNzMSkge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7VEhSRUUuU2NlbmV9IHNjZW5lXG4gICAgICogQHBhcmFtIHtUSFJFRS5DYW1lcmF9IGNhbWVyYSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqICBcbiAgICAgKiBAcHJvcGVydHkge1RIUkVFLlNjZW5lfSBzY2VuZVxuICAgICAqIEBwcm9wZXJ0eSB7VEhSRUUuQ2FtZXJhfSBjYW1lcmFcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0XG4gICAgICovIGNvbnN0cnVjdG9yKHNjZW5lLCBjYW1lcmEsIHdpZHRoID0gNTEyLCBoZWlnaHQgPSA1MTIpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmNsZWFyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtQcm94eSAmIHtcbiAgICAgICAgICogYW9TYW1wbGVzOiBudW1iZXIsXG4gICAgICAgICAqIGFvUmFkaXVzOiBudW1iZXIsXG4gICAgICAgICAqIGRlbm9pc2VTYW1wbGVzOiBudW1iZXIsXG4gICAgICAgICAqIGRlbm9pc2VSYWRpdXM6IG51bWJlcixcbiAgICAgICAgICogZGlzdGFuY2VGYWxsb2ZmOiBudW1iZXIsXG4gICAgICAgICAqIGludGVuc2l0eTogbnVtYmVyLFxuICAgICAgICAgKiBkZW5vaXNlSXRlcmF0aW9uczogbnVtYmVyLFxuICAgICAgICAgKiByZW5kZXJNb2RlOiAwIHwgMSB8IDIgfCAzIHwgNCxcbiAgICAgICAgICogY29sb3I6IFRIUkVFLkNvbG9yLFxuICAgICAgICAgKiBnYW1tYUNvcnJlY3Rpb246IGJvb2xlYW4sXG4gICAgICAgICAqIGRlcHRoQnVmZmVyVHlwZTogMSB8IDIgfCAzLFxuICAgICAgICAgKiBzY3JlZW5TcGFjZVJhZGl1czogYm9vbGVhbixcbiAgICAgICAgICogaGFsZlJlczogYm9vbGVhbixcbiAgICAgICAgICogZGVwdGhBd2FyZVVwc2FtcGxpbmc6IGJvb2xlYW5cbiAgICAgICAgICogY29sb3JNdWx0aXBseTogYm9vbGVhblxuICAgICAgICAgKiB9XG4gICAgICAgICAqLyB0aGlzLmF1dG9zZXRHYW1tYSA9IHRydWU7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IG5ldyBQcm94eSh7XG4gICAgICAgICAgICBhb1NhbXBsZXM6IDE2LFxuICAgICAgICAgICAgYW9SYWRpdXM6IDUuMCxcbiAgICAgICAgICAgIGFvVG9uZXM6IDAuMCxcbiAgICAgICAgICAgIGRlbm9pc2VTYW1wbGVzOiA4LFxuICAgICAgICAgICAgZGVub2lzZVJhZGl1czogMTIsXG4gICAgICAgICAgICBkaXN0YW5jZUZhbGxvZmY6IDEuMCxcbiAgICAgICAgICAgIGludGVuc2l0eTogNSxcbiAgICAgICAgICAgIGRlbm9pc2VJdGVyYXRpb25zOiAyLjAsXG4gICAgICAgICAgICByZW5kZXJNb2RlOiAwLFxuICAgICAgICAgICAgYmlhc09mZnNldDogMC4wLFxuICAgICAgICAgICAgYmlhc011bHRpcGxpZXI6IDAuMCxcbiAgICAgICAgICAgIGNvbG9yOiBuZXcgJDVXaGUzJENvbG9yKDAsIDAsIDApLFxuICAgICAgICAgICAgZ2FtbWFDb3JyZWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgZGVwdGhCdWZmZXJUeXBlOiAoMCwgJDA1ZjY5OTdlNGI2NWRhMTQkZXhwb3J0JGVkNGVlNWQxZTU1NDc0YTUpLkRlZmF1bHQsXG4gICAgICAgICAgICBzY3JlZW5TcGFjZVJhZGl1czogZmFsc2UsXG4gICAgICAgICAgICBoYWxmUmVzOiBmYWxzZSxcbiAgICAgICAgICAgIGRlcHRoQXdhcmVVcHNhbXBsaW5nOiB0cnVlLFxuICAgICAgICAgICAgY29sb3JNdWx0aXBseTogdHJ1ZSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW5jeUF3YXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGFjY3VtdWxhdGU6IGZhbHNlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNldDogKHRhcmdldCwgcHJvcE5hbWUsIHZhbHVlKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFByb3AgPSB0YXJnZXRbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuZXF1YWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUuZXF1YWxzKG9sZFByb3ApKSB0aGlzLmZpcnN0RnJhbWUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9sZFByb3AgIT09IHZhbHVlKSB0aGlzLmZpcnN0RnJhbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09IFwiYW9TYW1wbGVzXCIgJiYgb2xkUHJvcCAhPT0gdmFsdWUpIHRoaXMuY29uZmlndXJlQU9QYXNzKHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUsIHRoaXMuY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09IFwiZGVub2lzZVNhbXBsZXNcIiAmJiBvbGRQcm9wICE9PSB2YWx1ZSkgdGhpcy5jb25maWd1cmVEZW5vaXNlUGFzcyh0aGlzLmNvbmZpZ3VyYXRpb24uZGVwdGhCdWZmZXJUeXBlLCB0aGlzLmNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSBcImhhbGZSZXNcIiAmJiBvbGRQcm9wICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZUFPUGFzcyh0aGlzLmNvbmZpZ3VyYXRpb24uZGVwdGhCdWZmZXJUeXBlLCB0aGlzLmNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJlSGFsZlJlc1RhcmdldHMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmVFZmZlY3RDb21wb3NpdGVyKHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUsIHRoaXMuY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSBcImRlcHRoQXdhcmVVcHNhbXBsaW5nXCIgJiYgb2xkUHJvcCAhPT0gdmFsdWUpIHRoaXMuY29uZmlndXJlRWZmZWN0Q29tcG9zaXRlcih0aGlzLmNvbmZpZ3VyYXRpb24uZGVwdGhCdWZmZXJUeXBlLCB0aGlzLmNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSBcImdhbW1hQ29ycmVjdGlvblwiKSB0aGlzLmF1dG9zZXRHYW1tYSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gXCJ0cmFuc3BhcmVuY3lBd2FyZVwiICYmIG9sZFByb3AgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b0RldGVjdFRyYW5zcGFyZW5jeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZVRyYW5zcGFyZW5jeVRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAdHlwZSB7VEhSRUUuVmVjdG9yM1tdfSAqLyB0aGlzLnNhbXBsZXMgPSBbXTtcbiAgICAgICAgLyoqIEB0eXBlIHtUSFJFRS5WZWN0b3IyW119ICovIHRoaXMuc2FtcGxlc0Rlbm9pc2UgPSBbXTtcbiAgICAgICAgdGhpcy5hdXRvRGV0ZWN0VHJhbnNwYXJlbmN5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mcmFtZXMgPSAwO1xuICAgICAgICB0aGlzLmxhc3RWaWV3TWF0cml4ID0gbmV3ICQ1V2hlMyRNYXRyaXg0KCk7XG4gICAgICAgIHRoaXMubGFzdFByb2plY3Rpb25NYXRyaXggPSBuZXcgJDVXaGUzJE1hdHJpeDQoKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmVFZmZlY3RDb21wb3NpdGVyKHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZVNhbXBsZURlcGVuZGVudFBhc3NlcygpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZUhhbGZSZXNUYXJnZXRzKCk7XG4gICAgICAgIHRoaXMuZGV0ZWN0VHJhbnNwYXJlbmN5KCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJlVHJhbnNwYXJlbmN5VGFyZ2V0KCk7XG4gICAgICAgIC8vICAgdGhpcy5lZmZlY3RDb21waXN0ZXJRdWFkID0gbmV3IEZ1bGxTY3JlZW5UcmlhbmdsZShuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoRWZmZWN0Q29tcG9zaXRlcikpO1xuICAgICAgICB0aGlzLmNvcHlRdWFkID0gbmV3ICgwLCAkZTRjYThkY2IwMjE4Zjg0NiRleHBvcnQkZGNkNjcwZDczZGI3NTFmNSkobmV3ICQ1V2hlMyRTaGFkZXJNYXRlcmlhbCh7XG4gICAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICAgIHREaWZmdXNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBgXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIHZVdiA9IHV2O1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBgLFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBgXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy53cml0ZVRhcmdldEludGVybmFsID0gbmV3ICQ1V2hlMyRXZWJHTFJlbmRlclRhcmdldCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwge1xuICAgICAgICAgICAgbWluRmlsdGVyOiAkNVdoZTMkTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgbWFnRmlsdGVyOiAkNVdoZTMkTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgZm9ybWF0OiAkNVdoZTMkUkdCQUZvcm1hdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWFkVGFyZ2V0SW50ZXJuYWwgPSBuZXcgJDVXaGUzJFdlYkdMUmVuZGVyVGFyZ2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB7XG4gICAgICAgICAgICBtaW5GaWx0ZXI6ICQ1V2hlMyRMaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICBtYWdGaWx0ZXI6ICQ1V2hlMyRMaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICBkZXB0aEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICBmb3JtYXQ6ICQ1V2hlMyRSR0JBRm9ybWF0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm91dHB1dFRhcmdldEludGVybmFsID0gbmV3ICQ1V2hlMyRXZWJHTFJlbmRlclRhcmdldCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwge1xuICAgICAgICAgICAgbWluRmlsdGVyOiAkNVdoZTMkTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgbWFnRmlsdGVyOiAkNVdoZTMkTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGlvblJlbmRlclRhcmdldCA9IG5ldyAkNVdoZTMkV2ViR0xSZW5kZXJUYXJnZXQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHtcbiAgICAgICAgICAgIG1pbkZpbHRlcjogJDVXaGUzJExpbmVhckZpbHRlcixcbiAgICAgICAgICAgIG1hZ0ZpbHRlcjogJDVXaGUzJExpbmVhckZpbHRlcixcbiAgICAgICAgICAgIGRlcHRoQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcm1hdDogJDVXaGUzJFJHQkFGb3JtYXQsXG4gICAgICAgICAgICB0eXBlOiAkNVdoZTMkSGFsZkZsb2F0VHlwZSxcbiAgICAgICAgICAgIHN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgYWxwaGE6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0aW9uUXVhZCA9IG5ldyAoMCwgJGU0Y2E4ZGNiMDIxOGY4NDYkZXhwb3J0JGRjZDY3MGQ3M2RiNzUxZjUpKG5ldyAkNVdoZTMkU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgICAgICBmcmFtZToge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdERpZmZ1c2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBgXG4gICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgIHZVdiA9IHV2O1xuICAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEpO1xuICAgICAgICAgICAgIH1gLFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcbiAgICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcbiAgICAgICAgICAgICB1bmlmb3JtIGZsb2F0IGZyYW1lO1xuICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1xuICAgICAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgMS4wIC8gKGZyYW1lICsgMS4wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGBcbiAgICAgICAgfSkpO1xuICAgICAgICAvKiogQHR5cGUge1RIUkVFLkRhdGFUZXh0dXJlfSAqLyB0aGlzLmJsdWVub2lzZSA9IG5ldyAkNVdoZTMkRGF0YVRleHR1cmUoKDAsICQwNjI2OWFkNzhmM2M1ZmRmJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLCAxMjgsIDEyOCk7XG4gICAgICAgIHRoaXMuYmx1ZW5vaXNlLmNvbG9yU3BhY2UgPSAkNVdoZTMkTm9Db2xvclNwYWNlO1xuICAgICAgICB0aGlzLmJsdWVub2lzZS53cmFwUyA9ICQ1V2hlMyRSZXBlYXRXcmFwcGluZztcbiAgICAgICAgdGhpcy5ibHVlbm9pc2Uud3JhcFQgPSAkNVdoZTMkUmVwZWF0V3JhcHBpbmc7XG4gICAgICAgIHRoaXMuYmx1ZW5vaXNlLm1pbkZpbHRlciA9ICQ1V2hlMyROZWFyZXN0RmlsdGVyO1xuICAgICAgICB0aGlzLmJsdWVub2lzZS5tYWdGaWx0ZXIgPSAkNVdoZTMkTmVhcmVzdEZpbHRlcjtcbiAgICAgICAgdGhpcy5ibHVlbm9pc2UubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gMDtcbiAgICAgICAgdGhpcy50aW1lUm9sbGluZ0F2ZXJhZ2UgPSAwLjk5O1xuICAgICAgICB0aGlzLm5lZWRzRGVwdGhUZXh0dXJlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yID0gbmV3ICQ1V2hlMyRWZWN0b3IyKCk7XG4gICAgICAgIHRoaXMuX2MgPSBuZXcgJDVXaGUzJENvbG9yKCk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZUhhbGZSZXNUYXJnZXRzKCkge1xuICAgICAgICB0aGlzLmZpcnN0RnJhbWUoKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5oYWxmUmVzKSB7XG4gICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldCA9IG5ldyAoMCwgJGZmOTQzN2Q5Yzc1NzdmMTEkZXhwb3J0JDE1NmY2YTU4ZjU2OWFhMDkpKHRoaXMud2lkdGggLyAyLCB0aGlzLmhlaWdodCAvIDIsIDIpO1xuICAgICAgICAgICAgaWYgKCQ1V2hlMyRSRVZJU0lPTiA8PSAxNjEpIHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmVzID0gdGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQudGV4dHVyZTtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmVzWzBdLmZvcm1hdCA9ICQ1V2hlMyRSZWRGb3JtYXQ7XG4gICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldC50ZXh0dXJlc1swXS50eXBlID0gJDVXaGUzJEZsb2F0VHlwZTtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmVzWzBdLm1pbkZpbHRlciA9ICQ1V2hlMyROZWFyZXN0RmlsdGVyO1xuICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQudGV4dHVyZXNbMF0ubWFnRmlsdGVyID0gJDVXaGUzJE5lYXJlc3RGaWx0ZXI7XG4gICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldC50ZXh0dXJlc1swXS5kZXB0aEJ1ZmZlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQudGV4dHVyZXNbMV0uZm9ybWF0ID0gJDVXaGUzJFJHQkFGb3JtYXQ7XG4gICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldC50ZXh0dXJlc1sxXS50eXBlID0gJDVXaGUzJEhhbGZGbG9hdFR5cGU7XG4gICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldC50ZXh0dXJlc1sxXS5taW5GaWx0ZXIgPSAkNVdoZTMkTmVhcmVzdEZpbHRlcjtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmVzWzFdLm1hZ0ZpbHRlciA9ICQ1V2hlMyROZWFyZXN0RmlsdGVyO1xuICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQudGV4dHVyZXNbMV0uZGVwdGhCdWZmZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlUXVhZCA9IG5ldyAoMCwgJGU0Y2E4ZGNiMDIxOGY4NDYkZXhwb3J0JGRjZDY3MGQ3M2RiNzUxZjUpKG5ldyAkNVdoZTMkU2hhZGVyTWF0ZXJpYWwoKDAsICQyNmFjYTE3M2UwOTg0ZDk5JGV4cG9ydCQxZWZkZjQ5MTY4N2NkNDQyKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRlcHRoRG93bnNhbXBsZVF1YWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVF1YWQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlUXVhZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGV0ZWN0VHJhbnNwYXJlbmN5KCkge1xuICAgICAgICBpZiAodGhpcy5hdXRvRGV0ZWN0VHJhbnNwYXJlbmN5KSB7XG4gICAgICAgICAgICBsZXQgaXNUcmFuc3BhcmVuY3kgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUudHJhdmVyc2UoKG9iaik9PntcbiAgICAgICAgICAgICAgICBpZiAob2JqLm1hdGVyaWFsICYmIG9iai5tYXRlcmlhbC50cmFuc3BhcmVudCkgaXNUcmFuc3BhcmVuY3kgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNUcmFuc3BhcmVuY3kpIHRoaXMuY29uZmlndXJhdGlvbi50cmFuc3BhcmVuY3lBd2FyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uZmlndXJlVHJhbnNwYXJlbmN5VGFyZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLnRyYW5zcGFyZW5jeUF3YXJlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXRmFsc2UgPSBuZXcgJDVXaGUzJFdlYkdMUmVuZGVyVGFyZ2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgbWluRmlsdGVyOiAkNVdoZTMkTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgICAgIG1hZ0ZpbHRlcjogJDVXaGUzJE5lYXJlc3RGaWx0ZXIsXG4gICAgICAgICAgICAgICAgdHlwZTogJDVXaGUzJEhhbGZGbG9hdFR5cGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAkNVdoZTMkUkdCQUZvcm1hdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXVHJ1ZSA9IG5ldyAkNVdoZTMkV2ViR0xSZW5kZXJUYXJnZXQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHtcbiAgICAgICAgICAgICAgICBtaW5GaWx0ZXI6ICQ1V2hlMyRMaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICAgICAgbWFnRmlsdGVyOiAkNVdoZTMkTmVhcmVzdEZpbHRlcixcbiAgICAgICAgICAgICAgICB0eXBlOiAkNVdoZTMkSGFsZkZsb2F0VHlwZSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICQ1V2hlMyRSR0JBRm9ybWF0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5UmVuZGVyVGFyZ2V0RFdUcnVlLmRlcHRoVGV4dHVyZSA9IG5ldyAkNVdoZTMkRGVwdGhUZXh0dXJlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAkNVdoZTMkVW5zaWduZWRJbnRUeXBlKTtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhDb3B5UGFzcyA9IG5ldyAoMCwgJGU0Y2E4ZGNiMDIxOGY4NDYkZXhwb3J0JGRjZDY3MGQ3M2RiNzUxZjUpKG5ldyAkNVdoZTMkU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoVGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuZGVwdGhUZXh0dXJlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VEZXB0aEJ1ZmZlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUgPT09ICgwLCAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNSkuUmV2ZXJzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IC8qIGdsc2wgKi8gYFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICB2VXYgPSB1djtcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEpO1xuICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IC8qIGdsc2wgKi8gYFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgZGVwdGhUZXh0dXJlO1xuICAgICAgICAgICAgdW5pZm9ybSBib29sIHJldmVyc2VEZXB0aEJ1ZmZlcjtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldmVyc2VEZXB0aEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgZmxvYXQgZCA9IDEuMCAtIHRleHR1cmUyRChkZXB0aFRleHR1cmUsIHZVdikucjtcbiAgICAgICAgICAgXG4gICAgICAgICAgICAgICBkICs9IDAuMDAwMDE7XG4gICAgICAgICAgICAgICBnbF9GcmFnRGVwdGggPSAxLjAgLSBkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbG9hdCBkID0gdGV4dHVyZTJEKGRlcHRoVGV4dHVyZSwgdlV2KS5yO1xuICAgICAgICAgICAgICAgIGQgKz0gMC4wMDAwMTtcbiAgICAgICAgICAgICAgICBnbF9GcmFnRGVwdGggPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwYXJlbmN5UmVuZGVyVGFyZ2V0RFdGYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5UmVuZGVyVGFyZ2V0RFdGYWxzZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3lSZW5kZXJUYXJnZXREV0ZhbHNlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXVHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5UmVuZGVyVGFyZ2V0RFdUcnVlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXVHJ1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZXB0aENvcHlQYXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXB0aENvcHlQYXNzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoQ29weVBhc3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlclRyYW5zcGFyZW5jeShyZW5kZXJlcikge1xuICAgICAgICBjb25zdCBvbGRCYWNrZ3JvdW5kID0gdGhpcy5zY2VuZS5iYWNrZ3JvdW5kO1xuICAgICAgICBjb25zdCBvbGRDbGVhckNvbG9yID0gcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcihuZXcgJDVXaGUzJENvbG9yKCkpO1xuICAgICAgICBjb25zdCBvbGRDbGVhckFscGhhID0gcmVuZGVyZXIuZ2V0Q2xlYXJBbHBoYSgpO1xuICAgICAgICBjb25zdCBvbGRWaXNpYmlsaXR5ID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBvbGRBdXRvQ2xlYXJEZXB0aCA9IHJlbmRlcmVyLmF1dG9DbGVhckRlcHRoO1xuICAgICAgICB0aGlzLnNjZW5lLnRyYXZlcnNlKChvYmopPT57XG4gICAgICAgICAgICBvbGRWaXNpYmlsaXR5LnNldChvYmosIG9iai52aXNpYmxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoZSBzdGF0ZVxuICAgICAgICB0aGlzLnNjZW5lLmJhY2tncm91bmQgPSBudWxsO1xuICAgICAgICByZW5kZXJlci5hdXRvQ2xlYXJEZXB0aCA9IGZhbHNlO1xuICAgICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKG5ldyAkNVdoZTMkQ29sb3IoMCwgMCwgMCksIDApO1xuICAgICAgICB0aGlzLmRlcHRoQ29weVBhc3MubWF0ZXJpYWwudW5pZm9ybXMuZGVwdGhUZXh0dXJlLnZhbHVlID0gdGhpcy5kZXB0aFRleHR1cmU7XG4gICAgICAgIHRoaXMuZGVwdGhDb3B5UGFzcy5tYXRlcmlhbC51bmlmb3Jtcy5yZXZlcnNlRGVwdGhCdWZmZXIudmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uZGVwdGhCdWZmZXJUeXBlID09PSAoMCwgJDA1ZjY5OTdlNGI2NWRhMTQkZXhwb3J0JGVkNGVlNWQxZTU1NDc0YTUpLlJldmVyc2U7XG4gICAgICAgIC8vIFJlbmRlciBvdXQgdHJhbnNwYXJlbnQgb2JqZWN0cyBXSVRIT1VUIGRlcHRoIHdyaXRlXG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXRmFsc2UpO1xuICAgICAgICB0aGlzLnNjZW5lLnRyYXZlcnNlKChvYmopPT57XG4gICAgICAgICAgICBpZiAob2JqLm1hdGVyaWFsKSBvYmoudmlzaWJsZSA9IG9sZFZpc2liaWxpdHkuZ2V0KG9iaikgJiYgKG9iai5tYXRlcmlhbC50cmFuc3BhcmVudCAmJiAhb2JqLm1hdGVyaWFsLmRlcHRoV3JpdGUgJiYgIW9iai51c2VyRGF0YS50cmVhdEFzT3BhcXVlIHx8ICEhb2JqLnVzZXJEYXRhLmNhbm5vdFJlY2VpdmVBTyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJlci5jbGVhcih0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kZXB0aENvcHlQYXNzLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgICAgIC8vIFJlbmRlciBvdXQgdHJhbnNwYXJlbnQgb2JqZWN0cyBXSVRIIGRlcHRoIHdyaXRlXG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXVHJ1ZSk7XG4gICAgICAgIHRoaXMuc2NlbmUudHJhdmVyc2UoKG9iaik9PntcbiAgICAgICAgICAgIGlmIChvYmoubWF0ZXJpYWwpIG9iai52aXNpYmxlID0gb2xkVmlzaWJpbGl0eS5nZXQob2JqKSAmJiBvYmoubWF0ZXJpYWwudHJhbnNwYXJlbnQgJiYgb2JqLm1hdGVyaWFsLmRlcHRoV3JpdGUgJiYgIW9iai51c2VyRGF0YS50cmVhdEFzT3BhcXVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyZXIuY2xlYXIodHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZGVwdGhDb3B5UGFzcy5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgICAgICAvLyBSZXN0b3JlXG4gICAgICAgIHRoaXMuc2NlbmUudHJhdmVyc2UoKG9iaik9PntcbiAgICAgICAgICAgIG9iai52aXNpYmxlID0gb2xkVmlzaWJpbGl0eS5nZXQob2JqKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3Iob2xkQ2xlYXJDb2xvciwgb2xkQ2xlYXJBbHBoYSk7XG4gICAgICAgIHRoaXMuc2NlbmUuYmFja2dyb3VuZCA9IG9sZEJhY2tncm91bmQ7XG4gICAgICAgIHJlbmRlcmVyLmF1dG9DbGVhckRlcHRoID0gb2xkQXV0b0NsZWFyRGVwdGg7XG4gICAgfVxuICAgIGNvbmZpZ3VyZVNhbXBsZURlcGVuZGVudFBhc3NlcygpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmVBT1Bhc3ModGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSwgdGhpcy5jYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZURlbm9pc2VQYXNzKHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUsIHRoaXMuY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhKTtcbiAgICB9XG4gICAgY29uZmlndXJlQU9QYXNzKGRlcHRoQnVmZmVyVHlwZSA9ICgwLCAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNSkuRGVmYXVsdCwgb3J0aG8gPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZpcnN0RnJhbWUoKTtcbiAgICAgICAgdGhpcy5zYW1wbGVzID0gdGhpcy5nZW5lcmF0ZUhlbWlzcGhlcmVTYW1wbGVzKHRoaXMuY29uZmlndXJhdGlvbi5hb1NhbXBsZXMpO1xuICAgICAgICBjb25zdCBlID0ge1xuICAgICAgICAgICAgLi4uKDAsICQxZWQ0NTk2OGMxMTYwYzNjJGV4cG9ydCRjOWIyNjNiOWExN2RmZmQ3KVxuICAgICAgICB9O1xuICAgICAgICBlLmZyYWdtZW50U2hhZGVyID0gZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwiMTZcIiwgdGhpcy5jb25maWd1cmF0aW9uLmFvU2FtcGxlcykucmVwbGFjZShcIjE2LjBcIiwgdGhpcy5jb25maWd1cmF0aW9uLmFvU2FtcGxlcyArIFwiLjBcIik7XG4gICAgICAgIGlmIChkZXB0aEJ1ZmZlclR5cGUgPT09ICgwLCAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNSkuTG9nKSBlLmZyYWdtZW50U2hhZGVyID0gXCIjZGVmaW5lIExPR0RFUFRIXFxuXCIgKyBlLmZyYWdtZW50U2hhZGVyO1xuICAgICAgICBlbHNlIGlmIChkZXB0aEJ1ZmZlclR5cGUgPT09ICgwLCAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNSkuUmV2ZXJzZSkgZS5mcmFnbWVudFNoYWRlciA9IFwiI2RlZmluZSBSRVZFUlNFREVQVEhcXG5cIiArIGUuZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIGlmIChvcnRobykgZS5mcmFnbWVudFNoYWRlciA9IFwiI2RlZmluZSBPUlRIT1xcblwiICsgZS5mcmFnbWVudFNoYWRlcjtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5oYWxmUmVzKSBlLmZyYWdtZW50U2hhZGVyID0gXCIjZGVmaW5lIEhBTEZSRVNcXG5cIiArIGUuZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIGlmICh0aGlzLmVmZmVjdFNoYWRlclF1YWQpIHtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdFNoYWRlclF1YWQubWF0ZXJpYWwgPSBuZXcgJDVXaGUzJFNoYWRlck1hdGVyaWFsKGUpO1xuICAgICAgICB9IGVsc2UgdGhpcy5lZmZlY3RTaGFkZXJRdWFkID0gbmV3ICgwLCAkZTRjYThkY2IwMjE4Zjg0NiRleHBvcnQkZGNkNjcwZDczZGI3NTFmNSkobmV3ICQ1V2hlMyRTaGFkZXJNYXRlcmlhbChlKSk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZURlbm9pc2VQYXNzKGRlcHRoQnVmZmVyVHlwZSA9ICgwLCAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNSkuRGVmYXVsdCwgb3J0aG8gPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZpcnN0RnJhbWUoKTtcbiAgICAgICAgdGhpcy5zYW1wbGVzRGVub2lzZSA9IHRoaXMuZ2VuZXJhdGVEZW5vaXNlU2FtcGxlcyh0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZVNhbXBsZXMsIDExKTtcbiAgICAgICAgY29uc3QgcCA9IHtcbiAgICAgICAgICAgIC4uLigwLCAkZTUyMzc4Y2QwZjVhOTczZCRleHBvcnQkNTc4NTZiNTlmMzE3MjYyZSlcbiAgICAgICAgfTtcbiAgICAgICAgcC5mcmFnbWVudFNoYWRlciA9IHAuZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcIjE2XCIsIHRoaXMuY29uZmlndXJhdGlvbi5kZW5vaXNlU2FtcGxlcyk7XG4gICAgICAgIGlmIChkZXB0aEJ1ZmZlclR5cGUgPT09ICgwLCAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNSkuTG9nKSBwLmZyYWdtZW50U2hhZGVyID0gXCIjZGVmaW5lIExPR0RFUFRIXFxuXCIgKyBwLmZyYWdtZW50U2hhZGVyO1xuICAgICAgICBlbHNlIGlmIChkZXB0aEJ1ZmZlclR5cGUgPT09ICgwLCAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNSkuUmV2ZXJzZSkgcC5mcmFnbWVudFNoYWRlciA9IFwiI2RlZmluZSBSRVZFUlNFREVQVEhcXG5cIiArIHAuZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIGlmIChvcnRobykgcC5mcmFnbWVudFNoYWRlciA9IFwiI2RlZmluZSBPUlRIT1xcblwiICsgcC5mcmFnbWVudFNoYWRlcjtcbiAgICAgICAgaWYgKHRoaXMucG9pc3NvbkJsdXJRdWFkKSB7XG4gICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbCA9IG5ldyAkNVdoZTMkU2hhZGVyTWF0ZXJpYWwocCk7XG4gICAgICAgIH0gZWxzZSB0aGlzLnBvaXNzb25CbHVyUXVhZCA9IG5ldyAoMCwgJGU0Y2E4ZGNiMDIxOGY4NDYkZXhwb3J0JGRjZDY3MGQ3M2RiNzUxZjUpKG5ldyAkNVdoZTMkU2hhZGVyTWF0ZXJpYWwocCkpO1xuICAgIH1cbiAgICBjb25maWd1cmVFZmZlY3RDb21wb3NpdGVyKGRlcHRoQnVmZmVyVHlwZSA9ICgwLCAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNSkuRGVmYXVsdCwgb3J0aG8gPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZpcnN0RnJhbWUoKTtcbiAgICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgICAgIC4uLigwLCAkMTJiMjFkMjRkMTE5MmEwNCRleHBvcnQkYTgxNWFjY2NiZDJjOWE0OSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlcHRoQnVmZmVyVHlwZSA9PT0gKDAsICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCRlZDRlZTVkMWU1NTQ3NGE1KS5Mb2cpIGUuZnJhZ21lbnRTaGFkZXIgPSBcIiNkZWZpbmUgTE9HREVQVEhcXG5cIiArIGUuZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIGVsc2UgaWYgKGRlcHRoQnVmZmVyVHlwZSA9PT0gKDAsICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCRlZDRlZTVkMWU1NTQ3NGE1KS5SZXZlcnNlKSBlLmZyYWdtZW50U2hhZGVyID0gXCIjZGVmaW5lIFJFVkVSU0VERVBUSFxcblwiICsgZS5mcmFnbWVudFNoYWRlcjtcbiAgICAgICAgaWYgKG9ydGhvKSBlLmZyYWdtZW50U2hhZGVyID0gXCIjZGVmaW5lIE9SVEhPXFxuXCIgKyBlLmZyYWdtZW50U2hhZGVyO1xuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLmhhbGZSZXMgJiYgdGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQXdhcmVVcHNhbXBsaW5nKSBlLmZyYWdtZW50U2hhZGVyID0gXCIjZGVmaW5lIEhBTEZSRVNcXG5cIiArIGUuZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIGlmICh0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkKSB7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwgPSBuZXcgJDVXaGUzJFNoYWRlck1hdGVyaWFsKGUpO1xuICAgICAgICB9IGVsc2UgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZCA9IG5ldyAoMCwgJGU0Y2E4ZGNiMDIxOGY4NDYkZXhwb3J0JGRjZDY3MGQ3M2RiNzUxZjUpKG5ldyAkNVdoZTMkU2hhZGVyTWF0ZXJpYWwoZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIFxuICAgICAgICAgKiBAcmV0dXJucyB7VEhSRUUuVmVjdG9yM1tdfVxuICAgICAgICAgKi8gZ2VuZXJhdGVIZW1pc3BoZXJlU2FtcGxlcyhuKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IobGV0IGsgPSAwOyBrIDwgbjsgaysrKXtcbiAgICAgICAgICAgIGNvbnN0IHRoZXRhID0gMi4zOTk5NjMgKiBrO1xuICAgICAgICAgICAgY29uc3QgciA9IE1hdGguc3FydChrICsgMC41KSAvIE1hdGguc3FydChuKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSByICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgICAgICAgY29uc3QgeSA9IHIgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgICAgICAvLyBQcm9qZWN0IHRvIGhlbWlzcGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHogPSBNYXRoLnNxcnQoMSAtICh4ICogeCArIHkgKiB5KSk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChuZXcgJDVXaGUzJFZlY3RvcjMoeCwgeSwgeikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bVNhbXBsZXMgXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1SaW5ncyBcbiAgICAgICAgICogQHJldHVybnMge1RIUkVFLlZlY3RvcjJbXX1cbiAgICAgICAgICovIGdlbmVyYXRlRGVub2lzZVNhbXBsZXMobnVtU2FtcGxlcywgbnVtUmluZ3MpIHtcbiAgICAgICAgY29uc3QgYW5nbGVTdGVwID0gMiAqIE1hdGguUEkgKiBudW1SaW5ncyAvIG51bVNhbXBsZXM7XG4gICAgICAgIGNvbnN0IGludk51bVNhbXBsZXMgPSAxLjAgLyBudW1TYW1wbGVzO1xuICAgICAgICBjb25zdCByYWRpdXNTdGVwID0gaW52TnVtU2FtcGxlcztcbiAgICAgICAgY29uc3Qgc2FtcGxlcyA9IFtdO1xuICAgICAgICBsZXQgcmFkaXVzID0gaW52TnVtU2FtcGxlcztcbiAgICAgICAgbGV0IGFuZ2xlID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG51bVNhbXBsZXM7IGkrKyl7XG4gICAgICAgICAgICBzYW1wbGVzLnB1c2gobmV3ICQ1V2hlMyRWZWN0b3IyKE1hdGguY29zKGFuZ2xlKSwgTWF0aC5zaW4oYW5nbGUpKS5tdWx0aXBseVNjYWxhcihNYXRoLnBvdyhyYWRpdXMsIDAuNzUpKSk7XG4gICAgICAgICAgICByYWRpdXMgKz0gcmFkaXVzU3RlcDtcbiAgICAgICAgICAgIGFuZ2xlICs9IGFuZ2xlU3RlcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FtcGxlcztcbiAgICB9XG4gICAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZmlyc3RGcmFtZSgpO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBjb25zdCBjID0gdGhpcy5jb25maWd1cmF0aW9uLmhhbGZSZXMgPyAwLjUgOiAxO1xuICAgICAgICB0aGlzLndyaXRlVGFyZ2V0SW50ZXJuYWwuc2V0U2l6ZSh3aWR0aCAqIGMsIGhlaWdodCAqIGMpO1xuICAgICAgICB0aGlzLnJlYWRUYXJnZXRJbnRlcm5hbC5zZXRTaXplKHdpZHRoICogYywgaGVpZ2h0ICogYyk7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0aW9uUmVuZGVyVGFyZ2V0LnNldFNpemUod2lkdGggKiBjLCBoZWlnaHQgKiBjKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5oYWxmUmVzKSB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldC5zZXRTaXplKHdpZHRoICogYywgaGVpZ2h0ICogYyk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24udHJhbnNwYXJlbmN5QXdhcmUpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5UmVuZGVyVGFyZ2V0RFdGYWxzZS5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3lSZW5kZXJUYXJnZXREV1RydWUuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFRhcmdldEludGVybmFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5kZXB0aFRleHR1cmUgPSBkZXB0aFRleHR1cmU7XG4gICAgfVxuICAgIGZpcnN0RnJhbWUoKSB7XG4gICAgICAgIHRoaXMubmVlZHNGcmFtZSA9IHRydWU7XG4gICAgfVxuICAgIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlcikge1xuICAgICAgICBjb25zdCB4ckVuYWJsZWQgPSByZW5kZXJlci54ci5lbmFibGVkO1xuICAgICAgICByZW5kZXJlci54ci5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIC8vIENvcHkgaW5wdXRCdWZmZXIgdG8gb3V0cHV0QnVmZmVyXG4gICAgICAgIC8vcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG91dHB1dEJ1ZmZlcik7XG4gICAgICAgIC8vICB0aGlzLmNvcHlRdWFkLm1hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0gaW5wdXRCdWZmZXIudGV4dHVyZTtcbiAgICAgICAgLy8gICB0aGlzLmNvcHlRdWFkLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICAgIGlmIChyZW5kZXJlci5jYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uZGVwdGhCdWZmZXJUeXBlICE9PSAoMCwgJDA1ZjY5OTdlNGI2NWRhMTQkZXhwb3J0JGVkNGVlNWQxZTU1NDc0YTUpLkxvZyB8fCByZW5kZXJlci5jYXBhYmlsaXRpZXMucmV2ZXJzZURlcHRoQnVmZmVyICYmIHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUgIT09ICgwLCAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNSkuUmV2ZXJzZSkge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSA9IHJlbmRlcmVyLmNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gKDAsICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCRlZDRlZTVkMWU1NTQ3NGE1KS5Mb2cgOiByZW5kZXJlci5jYXBhYmlsaXRpZXMucmV2ZXJzZURlcHRoQnVmZmVyID8gKDAsICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCRlZDRlZTVkMWU1NTQ3NGE1KS5SZXZlcnNlIDogKDAsICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCRlZDRlZTVkMWU1NTQ3NGE1KS5EZWZhdWx0O1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmVBT1Bhc3ModGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSwgdGhpcy5jYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEpO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmVEZW5vaXNlUGFzcyh0aGlzLmNvbmZpZ3VyYXRpb24uZGVwdGhCdWZmZXJUeXBlLCB0aGlzLmNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZUVmZmVjdENvbXBvc2l0ZXIodGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSwgdGhpcy5jYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0ZWN0VHJhbnNwYXJlbmN5KCk7XG4gICAgICAgIGlmIChpbnB1dEJ1ZmZlci50ZXh0dXJlLnR5cGUgIT09IHRoaXMub3V0cHV0VGFyZ2V0SW50ZXJuYWwudGV4dHVyZS50eXBlIHx8IGlucHV0QnVmZmVyLnRleHR1cmUuZm9ybWF0ICE9PSB0aGlzLm91dHB1dFRhcmdldEludGVybmFsLnRleHR1cmUuZm9ybWF0KSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dFRhcmdldEludGVybmFsLnRleHR1cmUudHlwZSA9IGlucHV0QnVmZmVyLnRleHR1cmUudHlwZTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0VGFyZ2V0SW50ZXJuYWwudGV4dHVyZS5mb3JtYXQgPSBpbnB1dEJ1ZmZlci50ZXh0dXJlLmZvcm1hdDtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0VGFyZ2V0SW50ZXJuYWwudGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgICAgaWYgKHRoaXMubGFzdFZpZXdNYXRyaXguZXF1YWxzKHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSkgJiYgdGhpcy5sYXN0UHJvamVjdGlvbk1hdHJpeC5lcXVhbHModGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCkgJiYgdGhpcy5jb25maWd1cmF0aW9uLmFjY3VtdWxhdGUgJiYgIXRoaXMubmVlZHNGcmFtZSkgdGhpcy5mcmFtZSsrO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24uYWNjdW11bGF0ZSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLmFjY3VtdWxhdGlvblJlbmRlclRhcmdldCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuY2xlYXIodHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZyYW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMubmVlZHNGcmFtZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFZpZXdNYXRyaXguY29weSh0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuICAgICAgICB0aGlzLmxhc3RQcm9qZWN0aW9uTWF0cml4LmNvcHkodGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICAgIGxldCBnbDtcbiAgICAgICAgbGV0IGV4dDtcbiAgICAgICAgbGV0IHRpbWVyUXVlcnk7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgICAgICAgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBleHQgPSBnbC5nZXRFeHRlbnNpb24oXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyXCIpO1xuICAgICAgICAgICAgaWYgKGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyIG5vdCBhdmFpbGFibGUsIGRpc2FibGluZyBkZWJ1ZyBtb2RlLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgICAgICAgdGltZXJRdWVyeSA9IGdsLmNyZWF0ZVF1ZXJ5KCk7XG4gICAgICAgICAgICBnbC5iZWdpblF1ZXJ5KGV4dC5USU1FX0VMQVBTRURfRVhULCB0aW1lclF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLnRyYW5zcGFyZW5jeUF3YXJlKSB0aGlzLnJlbmRlclRyYW5zcGFyZW5jeShyZW5kZXJlcik7XG4gICAgICAgIHRoaXMuX3Iuc2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgbGV0IHRydWVSYWRpdXMgPSB0aGlzLmNvbmZpZ3VyYXRpb24uYW9SYWRpdXM7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24uaGFsZlJlcyAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uc2NyZWVuU3BhY2VSYWRpdXMpIHRydWVSYWRpdXMgKj0gMC41O1xuICAgICAgICBpZiAodGhpcy5mcmFtZSA8IDEwMjQgLyB0aGlzLmNvbmZpZ3VyYXRpb24uYW9TYW1wbGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLmhhbGZSZXMpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlUXVhZC5tYXRlcmlhbC51bmlmb3Jtcy5zY2VuZURlcHRoLnZhbHVlID0gdGhpcy5kZXB0aFRleHR1cmU7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVRdWFkLm1hdGVyaWFsLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUgPSB0aGlzLl9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcIm5lYXJcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5uZWFyO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImZhclwiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLmZhcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJwcm9qZWN0aW9uTWF0cml4SW52XCJdLnZhbHVlID0gdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1widmlld01hdHJpeEludlwiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImxvZ0RlcHRoXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLmxvZ2FyaXRobWljRGVwdGhCdWZmZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wib3J0aG9cIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVF1YWQucmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInNjZW5lRGlmZnVzZVwiXS52YWx1ZSA9IGlucHV0QnVmZmVyLnRleHR1cmU7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdFNoYWRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJzY2VuZURlcHRoXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLmhhbGZSZXMgPyB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldC50ZXh0dXJlc1swXSA6IHRoaXMuZGVwdGhUZXh0dXJlO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wic2NlbmVOb3JtYWxcIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uaGFsZlJlcyA/IHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmVzWzFdIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInByb2pNYXRcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1widmlld01hdFwiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInByb2pWaWV3TWF0XCJdLnZhbHVlID0gdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jbG9uZSgpLm11bHRpcGx5KHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5jbG9uZSgpKTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInByb2plY3Rpb25NYXRyaXhJbnZcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInZpZXdNYXRyaXhJbnZcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZDtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImNhbWVyYVBvc1wiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLmdldFdvcmxkUG9zaXRpb24obmV3ICQ1V2hlMyRWZWN0b3IzKCkpO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiYmlhc0FkanVzdG1lbnRcIl0udmFsdWUgPSBuZXcgJDVXaGUzJFZlY3RvcjIodGhpcy5jb25maWd1cmF0aW9uLmJpYXNPZmZzZXQsIHRoaXMuY29uZmlndXJhdGlvbi5iaWFzTXVsdGlwbGllcik7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdFNoYWRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJyZXNvbHV0aW9uXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLmhhbGZSZXMgPyB0aGlzLl9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMC41KS5mbG9vcigpIDogdGhpcy5fcjtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInRpbWVcIl0udmFsdWUgPSBwZXJmb3JtYW5jZS5ub3coKSAvIDEwMDA7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdFNoYWRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJzYW1wbGVzXCJdLnZhbHVlID0gdGhpcy5zYW1wbGVzO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiYmx1ZW5vaXNlXCJdLnZhbHVlID0gdGhpcy5ibHVlbm9pc2U7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdFNoYWRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJyYWRpdXNcIl0udmFsdWUgPSB0cnVlUmFkaXVzO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZGlzdGFuY2VGYWxsb2ZmXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLmRpc3RhbmNlRmFsbG9mZjtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcIm5lYXJcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5uZWFyO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZmFyXCJdLnZhbHVlID0gdGhpcy5jYW1lcmEuZmFyO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wib3J0aG9cIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInNjcmVlblNwYWNlUmFkaXVzXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLnNjcmVlblNwYWNlUmFkaXVzO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZnJhbWVcIl0udmFsdWUgPSB0aGlzLmZyYW1lO1xuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIEFPXG4gICAgICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy53cml0ZVRhcmdldEludGVybmFsKTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgICAgICAgLy8gRW5kIHRoZSBBT1xuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIGJsdXJcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZUl0ZXJhdGlvbnM7IGkrKyl7XG4gICAgICAgICAgICAgICAgW3RoaXMud3JpdGVUYXJnZXRJbnRlcm5hbCwgdGhpcy5yZWFkVGFyZ2V0SW50ZXJuYWxdID0gW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRUYXJnZXRJbnRlcm5hbCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZVRhcmdldEludGVybmFsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInREaWZmdXNlXCJdLnZhbHVlID0gdGhpcy5yZWFkVGFyZ2V0SW50ZXJuYWwudGV4dHVyZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInNjZW5lRGVwdGhcIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uaGFsZlJlcyA/IHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmVzWzBdIDogdGhpcy5kZXB0aFRleHR1cmU7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJwcm9qTWF0XCJdLnZhbHVlID0gdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInZpZXdNYXRcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJwcm9qZWN0aW9uTWF0cml4SW52XCJdLnZhbHVlID0gdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJ2aWV3TWF0cml4SW52XCJdLnZhbHVlID0gdGhpcy5jYW1lcmEubWF0cml4V29ybGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJjYW1lcmFQb3NcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5nZXRXb3JsZFBvc2l0aW9uKG5ldyAkNVdoZTMkVmVjdG9yMygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInJlc29sdXRpb25cIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uaGFsZlJlcyA/IHRoaXMuX3IuY2xvbmUoKS5tdWx0aXBseVNjYWxhcigwLjUpLmZsb29yKCkgOiB0aGlzLl9yO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pc3NvbkJsdXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1widGltZVwiXS52YWx1ZSA9IHBlcmZvcm1hbmNlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImJsdWVOb2lzZVwiXS52YWx1ZSA9IHRoaXMuYmx1ZW5vaXNlO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pc3NvbkJsdXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wicmFkaXVzXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLmRlbm9pc2VSYWRpdXMgKiAodGhpcy5jb25maWd1cmF0aW9uLmhhbGZSZXMgPyAwLjUgOiAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcIndvcmxkUmFkaXVzXCJdLnZhbHVlID0gdHJ1ZVJhZGl1cztcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImRpc3RhbmNlRmFsbG9mZlwiXS52YWx1ZSA9IHRoaXMuY29uZmlndXJhdGlvbi5kaXN0YW5jZUZhbGxvZmY7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJpbmRleFwiXS52YWx1ZSA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJwb2lzc29uRGlza1wiXS52YWx1ZSA9IHRoaXMuc2FtcGxlc0Rlbm9pc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJuZWFyXCJdLnZhbHVlID0gdGhpcy5jYW1lcmEubmVhcjtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImZhclwiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLmZhcjtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInNjcmVlblNwYWNlUmFkaXVzXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLnNjcmVlblNwYWNlUmFkaXVzO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLndyaXRlVGFyZ2V0SW50ZXJuYWwpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pc3NvbkJsdXJRdWFkLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5hY2N1bXVsYXRpb25SZW5kZXJUYXJnZXQpO1xuICAgICAgICAgICAgY29uc3Qgb2xkQXV0b0NsZWFyID0gcmVuZGVyZXIuYXV0b0NsZWFyO1xuICAgICAgICAgICAgcmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFjY3VtdWxhdGlvblF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJ0RGlmZnVzZVwiXS52YWx1ZSA9IHRoaXMud3JpdGVUYXJnZXRJbnRlcm5hbC50ZXh0dXJlO1xuICAgICAgICAgICAgdGhpcy5hY2N1bXVsYXRpb25RdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZnJhbWVcIl0udmFsdWUgPSB0aGlzLmZyYW1lO1xuICAgICAgICAgICAgdGhpcy5hY2N1bXVsYXRpb25RdWFkLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICAgICAgICByZW5kZXJlci5hdXRvQ2xlYXIgPSBvbGRBdXRvQ2xlYXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93LCB3ZSBoYXZlIHRoZSBibHVycmVkIEFPIGluIHdyaXRlVGFyZ2V0SW50ZXJuYWxcbiAgICAgICAgLy8gRW5kIHRoZSBibHVyXG4gICAgICAgIC8vIFN0YXJ0IHRoZSBjb21wb3NpdGlvblxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLnRyYW5zcGFyZW5jeUF3YXJlKSB7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1widHJhbnNwYXJlbmN5RFdGYWxzZVwiXS52YWx1ZSA9IHRoaXMudHJhbnNwYXJlbmN5UmVuZGVyVGFyZ2V0RFdGYWxzZS50ZXh0dXJlO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInRyYW5zcGFyZW5jeURXVHJ1ZVwiXS52YWx1ZSA9IHRoaXMudHJhbnNwYXJlbmN5UmVuZGVyVGFyZ2V0RFdUcnVlLnRleHR1cmU7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1widHJhbnNwYXJlbmN5RFdUcnVlRGVwdGhcIl0udmFsdWUgPSB0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXVHJ1ZS5kZXB0aFRleHR1cmU7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1widHJhbnNwYXJlbmN5QXdhcmVcIl0udmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJzY2VuZURpZmZ1c2VcIl0udmFsdWUgPSBpbnB1dEJ1ZmZlci50ZXh0dXJlO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wic2NlbmVEZXB0aFwiXS52YWx1ZSA9IHRoaXMuZGVwdGhUZXh0dXJlO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiYW9Ub25lc1wiXS52YWx1ZSA9IHRoaXMuY29uZmlndXJhdGlvbi5hb1RvbmVzO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wibmVhclwiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLm5lYXI7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJmYXJcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5mYXI7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJwcm9qZWN0aW9uTWF0cml4SW52XCJdLnZhbHVlID0gdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2U7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJ2aWV3TWF0cml4SW52XCJdLnZhbHVlID0gdGhpcy5jYW1lcmEubWF0cml4V29ybGQ7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJvcnRob1wiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZG93bnNhbXBsZWREZXB0aFwiXS52YWx1ZSA9IHRoaXMuY29uZmlndXJhdGlvbi5oYWxmUmVzID8gdGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQudGV4dHVyZXNbMF0gOiB0aGlzLmRlcHRoVGV4dHVyZTtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInJlc29sdXRpb25cIl0udmFsdWUgPSB0aGlzLl9yO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiYmx1ZU5vaXNlXCJdLnZhbHVlID0gdGhpcy5ibHVlbm9pc2U7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJpbnRlbnNpdHlcIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uaW50ZW5zaXR5O1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wicmVuZGVyTW9kZVwiXS52YWx1ZSA9IHRoaXMuY29uZmlndXJhdGlvbi5yZW5kZXJNb2RlO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wic2NyZWVuU3BhY2VSYWRpdXNcIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uc2NyZWVuU3BhY2VSYWRpdXM7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJyYWRpdXNcIl0udmFsdWUgPSB0cnVlUmFkaXVzO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZGlzdGFuY2VGYWxsb2ZmXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLmRpc3RhbmNlRmFsbG9mZjtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImdhbW1hQ29ycmVjdGlvblwiXS52YWx1ZSA9IHRoaXMuYXV0b3NldEdhbW1hID8gdGhpcy5yZW5kZXJUb1NjcmVlbiA6IHRoaXMuY29uZmlndXJhdGlvbi5nYW1tYUNvcnJlY3Rpb247XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJ0RGlmZnVzZVwiXS52YWx1ZSA9IHRoaXMuYWNjdW11bGF0aW9uUmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJjb2xvclwiXS52YWx1ZSA9IHRoaXMuX2MuY29weSh0aGlzLmNvbmZpZ3VyYXRpb24uY29sb3IpLmNvbnZlcnRTUkdCVG9MaW5lYXIoKTtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImNvbG9yTXVsdGlwbHlcIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uY29sb3JNdWx0aXBseTtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImNhbWVyYVBvc1wiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLmdldFdvcmxkUG9zaXRpb24obmV3ICQ1V2hlMyRWZWN0b3IzKCkpO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZm9nXCJdLnZhbHVlID0gISF0aGlzLnNjZW5lLmZvZztcbiAgICAgICAgaWYgKHRoaXMuc2NlbmUuZm9nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZS5mb2cuaXNGb2cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZm9nRXhwXCJdLnZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImZvZ05lYXJcIl0udmFsdWUgPSB0aGlzLnNjZW5lLmZvZy5uZWFyO1xuICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJmb2dGYXJcIl0udmFsdWUgPSB0aGlzLnNjZW5lLmZvZy5mYXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2NlbmUuZm9nLmlzRm9nRXhwMikge1xuICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJmb2dFeHBcIl0udmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJmb2dEZW5zaXR5XCJdLnZhbHVlID0gdGhpcy5zY2VuZS5mb2cuZGVuc2l0eTtcbiAgICAgICAgICAgIH0gZWxzZSBjb25zb2xlLmVycm9yKGBVbnN1cHBvcnRlZCBmb2cgdHlwZSAke3RoaXMuc2NlbmUuZm9nLmNvbnN0cnVjdG9yLm5hbWV9IGluIFNTQU9QYXNzLmApO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCgvKiB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgIG91dHB1dEJ1ZmZlciovIHRoaXMub3V0cHV0VGFyZ2V0SW50ZXJuYWwpO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IG91dHB1dEJ1ZmZlcik7XG4gICAgICAgIHRoaXMuY29weVF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJ0RGlmZnVzZVwiXS52YWx1ZSA9IHRoaXMub3V0cHV0VGFyZ2V0SW50ZXJuYWwudGV4dHVyZTtcbiAgICAgICAgdGhpcy5jb3B5UXVhZC5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHtcbiAgICAgICAgICAgIGdsLmVuZFF1ZXJ5KGV4dC5USU1FX0VMQVBTRURfRVhUKTtcbiAgICAgICAgICAgICQ4NzQzMWVlOTNiMDM3ODQ0JHZhciRjaGVja1RpbWVyUXVlcnkodGltZXJRdWVyeSwgZ2wsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyLnhyLmVuYWJsZWQgPSB4ckVuYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSBkZWJ1ZyBtb2RlIG9mIHRoZSBBTywgbWVhbmluZyB0aGUgbGFzdFRpbWUgdmFsdWUgd2lsbCBiZSB1cGRhdGVkLlxuICAgICAgICAgKi8gZW5hYmxlRGVidWdNb2RlKCkge1xuICAgICAgICB0aGlzLmRlYnVnTW9kZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgZGVidWcgbW9kZSBvZiB0aGUgQU8sIG1lYW5pbmcgdGhlIGxhc3RUaW1lIHZhbHVlIHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4gICAgICAgICAqLyBkaXNhYmxlRGVidWdNb2RlKCkge1xuICAgICAgICB0aGlzLmRlYnVnTW9kZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgZGlzcGxheSBtb2RlIG9mIHRoZSBBT1xuICAgICAgICAgKiBAcGFyYW0ge1wiQ29tYmluZWRcIiB8IFwiQU9cIiB8IFwiTm8gQU9cIiB8IFwiU3BsaXRcIiB8IFwiU3BsaXQgQU9cIn0gbW9kZSAtIFRoZSBkaXNwbGF5IG1vZGUuIFxuICAgICAgICAgKi8gc2V0RGlzcGxheU1vZGUobW9kZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucmVuZGVyTW9kZSA9IFtcbiAgICAgICAgICAgIFwiQ29tYmluZWRcIixcbiAgICAgICAgICAgIFwiQU9cIixcbiAgICAgICAgICAgIFwiTm8gQU9cIixcbiAgICAgICAgICAgIFwiU3BsaXRcIixcbiAgICAgICAgICAgIFwiU3BsaXQgQU9cIlxuICAgICAgICBdLmluZGV4T2YobW9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtcIlBlcmZvcm1hbmNlXCIgfCBcIkxvd1wiIHwgXCJNZWRpdW1cIiB8IFwiSGlnaFwiIHwgXCJVbHRyYVwifSBtb2RlIFxuICAgICAgICAgKi8gc2V0UXVhbGl0eU1vZGUobW9kZSkge1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJQZXJmb3JtYW5jZVwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uYW9TYW1wbGVzID0gODtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5kZW5vaXNlU2FtcGxlcyA9IDQ7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZVJhZGl1cyA9IDEyO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiTG93XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5hb1NhbXBsZXMgPSAxNjtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5kZW5vaXNlU2FtcGxlcyA9IDQ7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZVJhZGl1cyA9IDEyO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiTWVkaXVtXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5hb1NhbXBsZXMgPSAxNjtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5kZW5vaXNlU2FtcGxlcyA9IDg7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZVJhZGl1cyA9IDEyO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiSGlnaFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uYW9TYW1wbGVzID0gNjQ7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZVNhbXBsZXMgPSA4O1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmRlbm9pc2VSYWRpdXMgPSA2O1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiVWx0cmFcIikge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmFvU2FtcGxlcyA9IDY0O1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmRlbm9pc2VTYW1wbGVzID0gMTY7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZVJhZGl1cyA9IDY7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG5cbi8qKlxuICogXG4gKiBAcGFyYW0geyp9IHRpbWVyUXVlcnkgXG4gKiBAcGFyYW0ge1RIUkVFLldlYkdMUmVuZGVyZXJ9IGdsIFxuICogQHBhcmFtIHtOOEFPUGFzc30gcGFzcyBcbiAqLyBmdW5jdGlvbiAkMDVmNjk5N2U0YjY1ZGExNCR2YXIkY2hlY2tUaW1lclF1ZXJ5KHRpbWVyUXVlcnksIGdsLCBwYXNzKSB7XG4gICAgY29uc3QgYXZhaWxhYmxlID0gZ2wuZ2V0UXVlcnlQYXJhbWV0ZXIodGltZXJRdWVyeSwgZ2wuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSk7XG4gICAgaWYgKGF2YWlsYWJsZSkge1xuICAgICAgICBjb25zdCBlbGFwc2VkVGltZUluTnMgPSBnbC5nZXRRdWVyeVBhcmFtZXRlcih0aW1lclF1ZXJ5LCBnbC5RVUVSWV9SRVNVTFQpO1xuICAgICAgICBjb25zdCBlbGFwc2VkVGltZUluTXMgPSBlbGFwc2VkVGltZUluTnMgLyAxMDAwMDAwO1xuICAgICAgICBwYXNzLmxhc3RUaW1lID0gcGFzcy5sYXN0VGltZSA9PT0gMCA/IGVsYXBzZWRUaW1lSW5NcyA6IHBhc3MudGltZVJvbGxpbmdBdmVyYWdlICogcGFzcy5sYXN0VGltZSArICgxIC0gcGFzcy50aW1lUm9sbGluZ0F2ZXJhZ2UpICogZWxhcHNlZFRpbWVJbk1zO1xuICAgIH0gZWxzZSAvLyBJZiB0aGUgcmVzdWx0IGlzIG5vdCBhdmFpbGFibGUgeWV0LCBjaGVjayBhZ2FpbiBhZnRlciBhIGRlbGF5XG4gICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAkMDVmNjk5N2U0YjY1ZGExNCR2YXIkY2hlY2tUaW1lclF1ZXJ5KHRpbWVyUXVlcnksIGdsLCBwYXNzKTtcbiAgICB9LCAxKTtcbn1cbmNvbnN0ICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCRlZDRlZTVkMWU1NTQ3NGE1ID0ge1xuICAgIERlZmF1bHQ6IDEsXG4gICAgTG9nOiAyLFxuICAgIFJldmVyc2U6IDNcbn07XG5jbGFzcyAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkMmQ1N2RiMjBiNWViNWUwYSBleHRlbmRzICgwLCAkNVdoZTMkUGFzcykge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7VEhSRUUuU2NlbmV9IHNjZW5lXG4gICAgICogQHBhcmFtIHtUSFJFRS5DYW1lcmF9IGNhbWVyYSBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqICBcbiAgICAgKiBAcHJvcGVydHkge1RIUkVFLlNjZW5lfSBzY2VuZVxuICAgICAqIEBwcm9wZXJ0eSB7VEhSRUUuQ2FtZXJhfSBjYW1lcmFcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0XG4gICAgICovIGNvbnN0cnVjdG9yKHNjZW5lLCBjYW1lcmEsIHdpZHRoID0gNTEyLCBoZWlnaHQgPSA1MTIpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmNsZWFyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtQcm94eSAmIHtcbiAgICAgICAgICogYW9TYW1wbGVzOiBudW1iZXIsXG4gICAgICAgICAqIGFvUmFkaXVzOiBudW1iZXIsXG4gICAgICAgICAqIGRlbm9pc2VTYW1wbGVzOiBudW1iZXIsXG4gICAgICAgICAqIGRlbm9pc2VSYWRpdXM6IG51bWJlcixcbiAgICAgICAgICogZGlzdGFuY2VGYWxsb2ZmOiBudW1iZXIsXG4gICAgICAgICAqIGludGVuc2l0eTogbnVtYmVyLFxuICAgICAgICAgKiBkZW5vaXNlSXRlcmF0aW9uczogbnVtYmVyLFxuICAgICAgICAgKiByZW5kZXJNb2RlOiAwIHwgMSB8IDIgfCAzIHwgNCxcbiAgICAgICAgICogY29sb3I6IFRIUkVFLkNvbG9yLFxuICAgICAgICAgKiBnYW1tYUNvcnJlY3Rpb246IGJvb2xlYW4sXG4gICAgICAgICAqIGRlcHRoQnVmZmVyVHlwZTogMSB8IDIgfCAzLFxuICAgICAgICAgKiBzY3JlZW5TcGFjZVJhZGl1czogYm9vbGVhbixcbiAgICAgICAgICogaGFsZlJlczogYm9vbGVhbixcbiAgICAgICAgICogZGVwdGhBd2FyZVVwc2FtcGxpbmc6IGJvb2xlYW4sXG4gICAgICAgICAqIGF1dG9SZW5kZXJCZWF1dHk6IGJvb2xlYW5cbiAgICAgICAgICogY29sb3JNdWx0aXBseTogYm9vbGVhblxuICAgICAgICAgKiB9XG4gICAgICAgICAqLyB0aGlzLmNvbmZpZ3VyYXRpb24gPSBuZXcgUHJveHkoe1xuICAgICAgICAgICAgYW9TYW1wbGVzOiAxNixcbiAgICAgICAgICAgIGFvUmFkaXVzOiA1LjAsXG4gICAgICAgICAgICBhb1RvbmVzOiAwLjAsXG4gICAgICAgICAgICBkZW5vaXNlU2FtcGxlczogOCxcbiAgICAgICAgICAgIGRlbm9pc2VSYWRpdXM6IDEyLFxuICAgICAgICAgICAgZGlzdGFuY2VGYWxsb2ZmOiAxLjAsXG4gICAgICAgICAgICBpbnRlbnNpdHk6IDUsXG4gICAgICAgICAgICBkZW5vaXNlSXRlcmF0aW9uczogMi4wLFxuICAgICAgICAgICAgcmVuZGVyTW9kZTogMCxcbiAgICAgICAgICAgIGJpYXNPZmZzZXQ6IDAuMCxcbiAgICAgICAgICAgIGJpYXNNdWx0aXBsaWVyOiAwLjAsXG4gICAgICAgICAgICBjb2xvcjogbmV3ICQ1V2hlMyRDb2xvcigwLCAwLCAwKSxcbiAgICAgICAgICAgIGdhbW1hQ29ycmVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGRlcHRoQnVmZmVyVHlwZTogJDA1ZjY5OTdlNGI2NWRhMTQkZXhwb3J0JGVkNGVlNWQxZTU1NDc0YTUuRGVmYXVsdCxcbiAgICAgICAgICAgIHNjcmVlblNwYWNlUmFkaXVzOiBmYWxzZSxcbiAgICAgICAgICAgIGhhbGZSZXM6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGhBd2FyZVVwc2FtcGxpbmc6IHRydWUsXG4gICAgICAgICAgICBhdXRvUmVuZGVyQmVhdXR5OiB0cnVlLFxuICAgICAgICAgICAgY29sb3JNdWx0aXBseTogdHJ1ZSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW5jeUF3YXJlOiBmYWxzZSxcbiAgICAgICAgICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgICAgICAgICAgYWNjdW11bGF0ZTogZmFsc2VcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgc2V0OiAodGFyZ2V0LCBwcm9wTmFtZSwgdmFsdWUpPT57XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkUHJvcCA9IHRhcmdldFtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5lcXVhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5lcXVhbHMob2xkUHJvcCkpIHRoaXMuZmlyc3RGcmFtZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2xkUHJvcCAhPT0gdmFsdWUpIHRoaXMuZmlyc3RGcmFtZSgpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gXCJhb1NhbXBsZXNcIiAmJiBvbGRQcm9wICE9PSB2YWx1ZSkgdGhpcy5jb25maWd1cmVBT1Bhc3ModGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSwgdGhpcy5jYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gXCJkZW5vaXNlU2FtcGxlc1wiICYmIG9sZFByb3AgIT09IHZhbHVlKSB0aGlzLmNvbmZpZ3VyZURlbm9pc2VQYXNzKHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUsIHRoaXMuY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09IFwiaGFsZlJlc1wiICYmIG9sZFByb3AgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJlQU9QYXNzKHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUsIHRoaXMuY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmVIYWxmUmVzVGFyZ2V0cygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZUVmZmVjdENvbXBvc2l0ZXIodGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSwgdGhpcy5jYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09IFwiZGVwdGhBd2FyZVVwc2FtcGxpbmdcIiAmJiBvbGRQcm9wICE9PSB2YWx1ZSkgdGhpcy5jb25maWd1cmVFZmZlY3RDb21wb3NpdGVyKHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUsIHRoaXMuY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09IFwidHJhbnNwYXJlbmN5QXdhcmVcIiAmJiBvbGRQcm9wICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9EZXRlY3RUcmFuc3BhcmVuY3kgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmVUcmFuc3BhcmVuY3lUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSBcInN0ZW5jaWxcIiAmJiBvbGRQcm9wICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvKiAgdGhpcy5iZWF1dHlSZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVhdXR5UmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5mb3JtYXQgPSB2YWx1ZSA/IFRIUkVFLkRlcHRoU3RlbmNpbEZvcm1hdCA6IFRIUkVFLkRlcHRoRm9ybWF0O1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVhdXR5UmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS50eXBlID0gdmFsdWUgPyBUSFJFRS5VbnNpZ25lZEludDI0OFR5cGUgOiBUSFJFRS5VbnNpZ25lZEludFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWF1dHlSZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJlYXV0eVJlbmRlclRhcmdldC5uZWVkc1VwZGF0ZSA9IHRydWU7Ki8gdGhpcy5iZWF1dHlSZW5kZXJUYXJnZXQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJlYXV0eVJlbmRlclRhcmdldCA9IG5ldyAkNVdoZTMkV2ViR0xSZW5kZXJUYXJnZXQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkZpbHRlcjogJDVXaGUzJExpbmVhckZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hZ0ZpbHRlcjogJDVXaGUzJE5lYXJlc3RGaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAkNVdoZTMkSGFsZkZsb2F0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJDVXaGUzJFJHQkFGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVuY2lsQnVmZmVyOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWF1dHlSZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlID0gbmV3ICQ1V2hlMyREZXB0aFRleHR1cmUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHZhbHVlID8gJDVXaGUzJFVuc2lnbmVkSW50MjQ4VHlwZSA6ICQ1V2hlMyRVbnNpZ25lZEludFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJlYXV0eVJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZm9ybWF0ID0gdmFsdWUgPyAkNVdoZTMkRGVwdGhTdGVuY2lsRm9ybWF0IDogJDVXaGUzJERlcHRoRm9ybWF0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAdHlwZSB7VEhSRUUuVmVjdG9yM1tdfSAqLyB0aGlzLnNhbXBsZXMgPSBbXTtcbiAgICAgICAgLyoqIEB0eXBlIHtUSFJFRS5WZWN0b3IyW119ICovIHRoaXMuc2FtcGxlc0Rlbm9pc2UgPSBbXTtcbiAgICAgICAgdGhpcy5hdXRvRGV0ZWN0VHJhbnNwYXJlbmN5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mcmFtZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFZpZXdNYXRyaXggPSBuZXcgJDVXaGUzJE1hdHJpeDQoKTtcbiAgICAgICAgdGhpcy5sYXN0UHJvamVjdGlvbk1hdHJpeCA9IG5ldyAkNVdoZTMkTWF0cml4NCgpO1xuICAgICAgICB0aGlzLmJlYXV0eVJlbmRlclRhcmdldCA9IG5ldyAkNVdoZTMkV2ViR0xSZW5kZXJUYXJnZXQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHtcbiAgICAgICAgICAgIG1pbkZpbHRlcjogJDVXaGUzJExpbmVhckZpbHRlcixcbiAgICAgICAgICAgIG1hZ0ZpbHRlcjogJDVXaGUzJE5lYXJlc3RGaWx0ZXIsXG4gICAgICAgICAgICB0eXBlOiAkNVdoZTMkSGFsZkZsb2F0VHlwZSxcbiAgICAgICAgICAgIGZvcm1hdDogJDVXaGUzJFJHQkFGb3JtYXQsXG4gICAgICAgICAgICBzdGVuY2lsQnVmZmVyOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iZWF1dHlSZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlID0gbmV3ICQ1V2hlMyREZXB0aFRleHR1cmUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsICQ1V2hlMyRVbnNpZ25lZEludFR5cGUpO1xuICAgICAgICB0aGlzLmJlYXV0eVJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZm9ybWF0ID0gJDVXaGUzJERlcHRoRm9ybWF0O1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZUVmZmVjdENvbXBvc2l0ZXIodGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSwgdGhpcy5jYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZVNhbXBsZURlcGVuZGVudFBhc3NlcygpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZUhhbGZSZXNUYXJnZXRzKCk7XG4gICAgICAgIHRoaXMuZGV0ZWN0VHJhbnNwYXJlbmN5KCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJlVHJhbnNwYXJlbmN5VGFyZ2V0KCk7XG4gICAgICAgIHRoaXMud3JpdGVUYXJnZXRJbnRlcm5hbCA9IG5ldyAkNVdoZTMkV2ViR0xSZW5kZXJUYXJnZXQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHtcbiAgICAgICAgICAgIG1pbkZpbHRlcjogJDVXaGUzJExpbmVhckZpbHRlcixcbiAgICAgICAgICAgIG1hZ0ZpbHRlcjogJDVXaGUzJExpbmVhckZpbHRlcixcbiAgICAgICAgICAgIGRlcHRoQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcm1hdDogJDVXaGUzJFJHQkFGb3JtYXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhZFRhcmdldEludGVybmFsID0gbmV3ICQ1V2hlMyRXZWJHTFJlbmRlclRhcmdldCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwge1xuICAgICAgICAgICAgbWluRmlsdGVyOiAkNVdoZTMkTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgbWFnRmlsdGVyOiAkNVdoZTMkTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgZm9ybWF0OiAkNVdoZTMkUkdCQUZvcm1hdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRpb25SZW5kZXJUYXJnZXQgPSBuZXcgJDVXaGUzJFdlYkdMUmVuZGVyVGFyZ2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB7XG4gICAgICAgICAgICBtaW5GaWx0ZXI6ICQ1V2hlMyRMaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICBtYWdGaWx0ZXI6ICQ1V2hlMyRMaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICBkZXB0aEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICBmb3JtYXQ6ICQ1V2hlMyRSR0JBRm9ybWF0LFxuICAgICAgICAgICAgdHlwZTogJDVXaGUzJEhhbGZGbG9hdFR5cGUsXG4gICAgICAgICAgICBzdGVuY2lsQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIGRlcHRoQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIGFscGhhOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQHR5cGUge1RIUkVFLkRhdGFUZXh0dXJlfSAqLyB0aGlzLmJsdWVub2lzZSA9IG5ldyAkNVdoZTMkRGF0YVRleHR1cmUoKDAsICQwNjI2OWFkNzhmM2M1ZmRmJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLCAxMjgsIDEyOCk7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0aW9uUXVhZCA9IG5ldyAoMCwgJGU0Y2E4ZGNiMDIxOGY4NDYkZXhwb3J0JGRjZDY3MGQ3M2RiNzUxZjUpKG5ldyAkNVdoZTMkU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgICAgICBmcmFtZToge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdERpZmZ1c2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBgXG4gICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgIHZVdiA9IHV2O1xuICAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEpO1xuICAgICAgICAgICAgIH1gLFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcbiAgICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcbiAgICAgICAgICAgICB1bmlmb3JtIGZsb2F0IGZyYW1lO1xuICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1xuICAgICAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgMS4wIC8gKGZyYW1lICsgMS4wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGBcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmJsdWVub2lzZS5jb2xvclNwYWNlID0gJDVXaGUzJE5vQ29sb3JTcGFjZTtcbiAgICAgICAgdGhpcy5ibHVlbm9pc2Uud3JhcFMgPSAkNVdoZTMkUmVwZWF0V3JhcHBpbmc7XG4gICAgICAgIHRoaXMuYmx1ZW5vaXNlLndyYXBUID0gJDVXaGUzJFJlcGVhdFdyYXBwaW5nO1xuICAgICAgICB0aGlzLmJsdWVub2lzZS5taW5GaWx0ZXIgPSAkNVdoZTMkTmVhcmVzdEZpbHRlcjtcbiAgICAgICAgdGhpcy5ibHVlbm9pc2UubWFnRmlsdGVyID0gJDVXaGUzJE5lYXJlc3RGaWx0ZXI7XG4gICAgICAgIHRoaXMuYmx1ZW5vaXNlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IDA7XG4gICAgICAgIHRoaXMudGltZVJvbGxpbmdBdmVyYWdlID0gMC45OTtcbiAgICAgICAgdGhpcy5fciA9IG5ldyAkNVdoZTMkVmVjdG9yMigpO1xuICAgICAgICB0aGlzLl9jID0gbmV3ICQ1V2hlMyRDb2xvcigpO1xuICAgIH1cbiAgICBjb25maWd1cmVIYWxmUmVzVGFyZ2V0cygpIHtcbiAgICAgICAgdGhpcy5maXJzdEZyYW1lKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24uaGFsZlJlcykge1xuICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQgPSBuZXcgKDAsICRmZjk0MzdkOWM3NTc3ZjExJGV4cG9ydCQxNTZmNmE1OGY1NjlhYTA5KSh0aGlzLndpZHRoIC8gMiwgdGhpcy5oZWlnaHQgLyAyLCAyKTtcbiAgICAgICAgICAgIGlmICgkNVdoZTMkUkVWSVNJT04gPD0gMTYxKSB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldC50ZXh0dXJlcyA9IHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmU7XG4gICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldC50ZXh0dXJlc1swXS5mb3JtYXQgPSAkNVdoZTMkUmVkRm9ybWF0O1xuICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQudGV4dHVyZXNbMF0udHlwZSA9ICQ1V2hlMyRGbG9hdFR5cGU7XG4gICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldC50ZXh0dXJlc1swXS5taW5GaWx0ZXIgPSAkNVdoZTMkTmVhcmVzdEZpbHRlcjtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmVzWzBdLm1hZ0ZpbHRlciA9ICQ1V2hlMyROZWFyZXN0RmlsdGVyO1xuICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQudGV4dHVyZXNbMF0uZGVwdGhCdWZmZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmVzWzFdLmZvcm1hdCA9ICQ1V2hlMyRSR0JBRm9ybWF0O1xuICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQudGV4dHVyZXNbMV0udHlwZSA9ICQ1V2hlMyRIYWxmRmxvYXRUeXBlO1xuICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQudGV4dHVyZXNbMV0ubWluRmlsdGVyID0gJDVXaGUzJE5lYXJlc3RGaWx0ZXI7XG4gICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldC50ZXh0dXJlc1sxXS5tYWdGaWx0ZXIgPSAkNVdoZTMkTmVhcmVzdEZpbHRlcjtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmVzWzFdLmRlcHRoQnVmZmVyID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBlID0ge1xuICAgICAgICAgICAgICAgIC4uLigwLCAkMjZhY2ExNzNlMDk4NGQ5OSRleHBvcnQkMWVmZGY0OTE2ODdjZDQ0MilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSA9PT0gJDA1ZjY5OTdlNGI2NWRhMTQkZXhwb3J0JGVkNGVlNWQxZTU1NDc0YTUuUmV2ZXJzZSkgZS5mcmFnbWVudFNoYWRlciA9IFwiI2RlZmluZSBSRVZFUlNFREVQVEhcXG5cIiArIGUuZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVF1YWQgPSBuZXcgKDAsICRlNGNhOGRjYjAyMThmODQ2JGV4cG9ydCRkY2Q2NzBkNzNkYjc1MWY1KShuZXcgJDVXaGUzJFNoYWRlck1hdGVyaWFsKGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZXB0aERvd25zYW1wbGVRdWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVRdWFkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVF1YWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRldGVjdFRyYW5zcGFyZW5jeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RldGVjdFRyYW5zcGFyZW5jeSkge1xuICAgICAgICAgICAgbGV0IGlzVHJhbnNwYXJlbmN5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNjZW5lLnRyYXZlcnNlKChvYmopPT57XG4gICAgICAgICAgICAgICAgaWYgKG9iai5tYXRlcmlhbCAmJiBvYmoubWF0ZXJpYWwudHJhbnNwYXJlbnQpIGlzVHJhbnNwYXJlbmN5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnRyYW5zcGFyZW5jeUF3YXJlID0gaXNUcmFuc3BhcmVuY3k7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uZmlndXJlVHJhbnNwYXJlbmN5VGFyZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLnRyYW5zcGFyZW5jeUF3YXJlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXRmFsc2UgPSBuZXcgJDVXaGUzJFdlYkdMUmVuZGVyVGFyZ2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgbWluRmlsdGVyOiAkNVdoZTMkTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgICAgIG1hZ0ZpbHRlcjogJDVXaGUzJE5lYXJlc3RGaWx0ZXIsXG4gICAgICAgICAgICAgICAgdHlwZTogJDVXaGUzJEhhbGZGbG9hdFR5cGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAkNVdoZTMkUkdCQUZvcm1hdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXVHJ1ZSA9IG5ldyAkNVdoZTMkV2ViR0xSZW5kZXJUYXJnZXQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHtcbiAgICAgICAgICAgICAgICBtaW5GaWx0ZXI6ICQ1V2hlMyRMaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICAgICAgbWFnRmlsdGVyOiAkNVdoZTMkTmVhcmVzdEZpbHRlcixcbiAgICAgICAgICAgICAgICB0eXBlOiAkNVdoZTMkSGFsZkZsb2F0VHlwZSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICQ1V2hlMyRSR0JBRm9ybWF0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5UmVuZGVyVGFyZ2V0RFdUcnVlLmRlcHRoVGV4dHVyZSA9IG5ldyAkNVdoZTMkRGVwdGhUZXh0dXJlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAkNVdoZTMkVW5zaWduZWRJbnRUeXBlKTtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhDb3B5UGFzcyA9IG5ldyAoMCwgJGU0Y2E4ZGNiMDIxOGY4NDYkZXhwb3J0JGRjZDY3MGQ3M2RiNzUxZjUpKG5ldyAkNVdoZTMkU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoVGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuZGVwdGhUZXh0dXJlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VEZXB0aEJ1ZmZlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUgPT09ICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCRlZDRlZTVkMWU1NTQ3NGE1LlJldmVyc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmVydGV4U2hhZGVyOiAvKiBnbHNsICovIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdlV2ID0gdXY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1gLFxuICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiAvKiBnbHNsICovIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIGRlcHRoVGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gYm9vbCByZXZlcnNlRGVwdGhCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXZlcnNlRGVwdGhCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGQgPSAxLjAgLSB0ZXh0dXJlMkQoZGVwdGhUZXh0dXJlLCB2VXYpLnI7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZCArPSAwLjAwMDAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xfRnJhZ0RlcHRoID0gMS4wIC0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZCA9IHRleHR1cmUyRChkZXB0aFRleHR1cmUsIHZVdikucjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkICs9IDAuMDAwMDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xfRnJhZ0RlcHRoID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXRmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXRmFsc2UuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5UmVuZGVyVGFyZ2V0RFdGYWxzZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc3BhcmVuY3lSZW5kZXJUYXJnZXREV1RydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXVHJ1ZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3lSZW5kZXJUYXJnZXREV1RydWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVwdGhDb3B5UGFzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhDb3B5UGFzcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXB0aENvcHlQYXNzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJUcmFuc3BhcmVuY3kocmVuZGVyZXIpIHtcbiAgICAgICAgY29uc3Qgb2xkQmFja2dyb3VuZCA9IHRoaXMuc2NlbmUuYmFja2dyb3VuZDtcbiAgICAgICAgY29uc3Qgb2xkQ2xlYXJDb2xvciA9IHJlbmRlcmVyLmdldENsZWFyQ29sb3IobmV3ICQ1V2hlMyRDb2xvcigpKTtcbiAgICAgICAgY29uc3Qgb2xkQ2xlYXJBbHBoYSA9IHJlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcbiAgICAgICAgY29uc3Qgb2xkVmlzaWJpbGl0eSA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3Qgb2xkQXV0b0NsZWFyRGVwdGggPSByZW5kZXJlci5hdXRvQ2xlYXJEZXB0aDtcbiAgICAgICAgdGhpcy5zY2VuZS50cmF2ZXJzZSgob2JqKT0+e1xuICAgICAgICAgICAgb2xkVmlzaWJpbGl0eS5zZXQob2JqLCBvYmoudmlzaWJsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBPdmVycmlkZSB0aGUgc3RhdGVcbiAgICAgICAgdGhpcy5zY2VuZS5iYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgcmVuZGVyZXIuYXV0b0NsZWFyRGVwdGggPSBmYWxzZTtcbiAgICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcihuZXcgJDVXaGUzJENvbG9yKDAsIDAsIDApLCAwKTtcbiAgICAgICAgdGhpcy5kZXB0aENvcHlQYXNzLm1hdGVyaWFsLnVuaWZvcm1zLmRlcHRoVGV4dHVyZS52YWx1ZSA9IHRoaXMuYmVhdXR5UmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZTtcbiAgICAgICAgdGhpcy5kZXB0aENvcHlQYXNzLm1hdGVyaWFsLnVuaWZvcm1zLnJldmVyc2VEZXB0aEJ1ZmZlci52YWx1ZSA9IHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUgPT09ICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCRlZDRlZTVkMWU1NTQ3NGE1LlJldmVyc2U7XG4gICAgICAgIC8vIFJlbmRlciBvdXQgdHJhbnNwYXJlbnQgb2JqZWN0cyBXSVRIT1VUIGRlcHRoIHdyaXRlXG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXRmFsc2UpO1xuICAgICAgICB0aGlzLnNjZW5lLnRyYXZlcnNlKChvYmopPT57XG4gICAgICAgICAgICBpZiAob2JqLm1hdGVyaWFsKSBvYmoudmlzaWJsZSA9IG9sZFZpc2liaWxpdHkuZ2V0KG9iaikgJiYgKG9iai5tYXRlcmlhbC50cmFuc3BhcmVudCAmJiAhb2JqLm1hdGVyaWFsLmRlcHRoV3JpdGUgJiYgIW9iai51c2VyRGF0YS50cmVhdEFzT3BhcXVlIHx8ICEhb2JqLnVzZXJEYXRhLmNhbm5vdFJlY2VpdmVBTyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJlci5jbGVhcih0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kZXB0aENvcHlQYXNzLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgICAgIC8vIFJlbmRlciBvdXQgdHJhbnNwYXJlbnQgb2JqZWN0cyBXSVRIIGRlcHRoIHdyaXRlXG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXVHJ1ZSk7XG4gICAgICAgIHRoaXMuc2NlbmUudHJhdmVyc2UoKG9iaik9PntcbiAgICAgICAgICAgIGlmIChvYmoubWF0ZXJpYWwpIG9iai52aXNpYmxlID0gb2xkVmlzaWJpbGl0eS5nZXQob2JqKSAmJiBvYmoubWF0ZXJpYWwudHJhbnNwYXJlbnQgJiYgb2JqLm1hdGVyaWFsLmRlcHRoV3JpdGUgJiYgIW9iai51c2VyRGF0YS50cmVhdEFzT3BhcXVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyZXIuY2xlYXIodHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZGVwdGhDb3B5UGFzcy5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgICAgICAvLyBSZXN0b3JlXG4gICAgICAgIHRoaXMuc2NlbmUudHJhdmVyc2UoKG9iaik9PntcbiAgICAgICAgICAgIG9iai52aXNpYmxlID0gb2xkVmlzaWJpbGl0eS5nZXQob2JqKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3Iob2xkQ2xlYXJDb2xvciwgb2xkQ2xlYXJBbHBoYSk7XG4gICAgICAgIHRoaXMuc2NlbmUuYmFja2dyb3VuZCA9IG9sZEJhY2tncm91bmQ7XG4gICAgICAgIHJlbmRlcmVyLmF1dG9DbGVhckRlcHRoID0gb2xkQXV0b0NsZWFyRGVwdGg7XG4gICAgfVxuICAgIGNvbmZpZ3VyZVNhbXBsZURlcGVuZGVudFBhc3NlcygpIHtcbiAgICAgICAgdGhpcy5maXJzdEZyYW1lKCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJlQU9QYXNzKHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUsIHRoaXMuY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmVEZW5vaXNlUGFzcyh0aGlzLmNvbmZpZ3VyYXRpb24uZGVwdGhCdWZmZXJUeXBlLCB0aGlzLmNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZUFPUGFzcyhkZXB0aEJ1ZmZlclR5cGUgPSAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNS5EZWZhdWx0LCBvcnRobyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZmlyc3RGcmFtZSgpO1xuICAgICAgICB0aGlzLnNhbXBsZXMgPSB0aGlzLmdlbmVyYXRlSGVtaXNwaGVyZVNhbXBsZXModGhpcy5jb25maWd1cmF0aW9uLmFvU2FtcGxlcyk7XG4gICAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgICAgICAuLi4oMCwgJDFlZDQ1OTY4YzExNjBjM2MkZXhwb3J0JGM5YjI2M2I5YTE3ZGZmZDcpXG4gICAgICAgIH07XG4gICAgICAgIGUuZnJhZ21lbnRTaGFkZXIgPSBlLmZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXCIxNlwiLCB0aGlzLmNvbmZpZ3VyYXRpb24uYW9TYW1wbGVzKS5yZXBsYWNlKFwiMTYuMFwiLCB0aGlzLmNvbmZpZ3VyYXRpb24uYW9TYW1wbGVzICsgXCIuMFwiKTtcbiAgICAgICAgaWYgKGRlcHRoQnVmZmVyVHlwZSA9PT0gJDA1ZjY5OTdlNGI2NWRhMTQkZXhwb3J0JGVkNGVlNWQxZTU1NDc0YTUuTG9nKSBlLmZyYWdtZW50U2hhZGVyID0gXCIjZGVmaW5lIExPR0RFUFRIXFxuXCIgKyBlLmZyYWdtZW50U2hhZGVyO1xuICAgICAgICBlbHNlIGlmIChkZXB0aEJ1ZmZlclR5cGUgPT09ICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCRlZDRlZTVkMWU1NTQ3NGE1LlJldmVyc2UpIGUuZnJhZ21lbnRTaGFkZXIgPSBcIiNkZWZpbmUgUkVWRVJTRURFUFRIXFxuXCIgKyBlLmZyYWdtZW50U2hhZGVyO1xuICAgICAgICBpZiAob3J0aG8pIGUuZnJhZ21lbnRTaGFkZXIgPSBcIiNkZWZpbmUgT1JUSE9cXG5cIiArIGUuZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24uaGFsZlJlcykgZS5mcmFnbWVudFNoYWRlciA9IFwiI2RlZmluZSBIQUxGUkVTXFxuXCIgKyBlLmZyYWdtZW50U2hhZGVyO1xuICAgICAgICBpZiAodGhpcy5lZmZlY3RTaGFkZXJRdWFkKSB7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdFNoYWRlclF1YWQubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsID0gbmV3ICQ1V2hlMyRTaGFkZXJNYXRlcmlhbChlKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuZWZmZWN0U2hhZGVyUXVhZCA9IG5ldyAoMCwgJGU0Y2E4ZGNiMDIxOGY4NDYkZXhwb3J0JGRjZDY3MGQ3M2RiNzUxZjUpKG5ldyAkNVdoZTMkU2hhZGVyTWF0ZXJpYWwoZSkpO1xuICAgIH1cbiAgICBjb25maWd1cmVEZW5vaXNlUGFzcyhkZXB0aEJ1ZmZlclR5cGUgPSAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNS5EZWZhdWx0LCBvcnRobyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZmlyc3RGcmFtZSgpO1xuICAgICAgICB0aGlzLnNhbXBsZXNEZW5vaXNlID0gdGhpcy5nZW5lcmF0ZURlbm9pc2VTYW1wbGVzKHRoaXMuY29uZmlndXJhdGlvbi5kZW5vaXNlU2FtcGxlcywgMTEpO1xuICAgICAgICBjb25zdCBwID0ge1xuICAgICAgICAgICAgLi4uKDAsICRlNTIzNzhjZDBmNWE5NzNkJGV4cG9ydCQ1Nzg1NmI1OWYzMTcyNjJlKVxuICAgICAgICB9O1xuICAgICAgICBwLmZyYWdtZW50U2hhZGVyID0gcC5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwiMTZcIiwgdGhpcy5jb25maWd1cmF0aW9uLmRlbm9pc2VTYW1wbGVzKTtcbiAgICAgICAgaWYgKGRlcHRoQnVmZmVyVHlwZSA9PT0gJDA1ZjY5OTdlNGI2NWRhMTQkZXhwb3J0JGVkNGVlNWQxZTU1NDc0YTUuTG9nKSBwLmZyYWdtZW50U2hhZGVyID0gXCIjZGVmaW5lIExPR0RFUFRIXFxuXCIgKyBwLmZyYWdtZW50U2hhZGVyO1xuICAgICAgICBlbHNlIGlmIChkZXB0aEJ1ZmZlclR5cGUgPT09ICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCRlZDRlZTVkMWU1NTQ3NGE1LlJldmVyc2UpIHAuZnJhZ21lbnRTaGFkZXIgPSBcIiNkZWZpbmUgUkVWRVJTRURFUFRIXFxuXCIgKyBwLmZyYWdtZW50U2hhZGVyO1xuICAgICAgICBpZiAob3J0aG8pIHAuZnJhZ21lbnRTaGFkZXIgPSBcIiNkZWZpbmUgT1JUSE9cXG5cIiArIHAuZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIGlmICh0aGlzLnBvaXNzb25CbHVyUXVhZCkge1xuICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwgPSBuZXcgJDVXaGUzJFNoYWRlck1hdGVyaWFsKHApO1xuICAgICAgICB9IGVsc2UgdGhpcy5wb2lzc29uQmx1clF1YWQgPSBuZXcgKDAsICRlNGNhOGRjYjAyMThmODQ2JGV4cG9ydCRkY2Q2NzBkNzNkYjc1MWY1KShuZXcgJDVXaGUzJFNoYWRlck1hdGVyaWFsKHApKTtcbiAgICB9XG4gICAgY29uZmlndXJlRWZmZWN0Q29tcG9zaXRlcihkZXB0aEJ1ZmZlclR5cGUgPSAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNS5EZWZhdWx0LCBvcnRobyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZmlyc3RGcmFtZSgpO1xuICAgICAgICBjb25zdCBlID0ge1xuICAgICAgICAgICAgLi4uKDAsICQxMmIyMWQyNGQxMTkyYTA0JGV4cG9ydCRhODE1YWNjY2JkMmM5YTQ5KVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVwdGhCdWZmZXJUeXBlID09PSAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNS5Mb2cpIGUuZnJhZ21lbnRTaGFkZXIgPSBcIiNkZWZpbmUgTE9HREVQVEhcXG5cIiArIGUuZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIGVsc2UgaWYgKGRlcHRoQnVmZmVyVHlwZSA9PT0gJDA1ZjY5OTdlNGI2NWRhMTQkZXhwb3J0JGVkNGVlNWQxZTU1NDc0YTUuUmV2ZXJzZSkgZS5mcmFnbWVudFNoYWRlciA9IFwiI2RlZmluZSBSRVZFUlNFREVQVEhcXG5cIiArIGUuZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIGlmIChvcnRobykgZS5mcmFnbWVudFNoYWRlciA9IFwiI2RlZmluZSBPUlRIT1xcblwiICsgZS5mcmFnbWVudFNoYWRlcjtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5oYWxmUmVzICYmIHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEF3YXJlVXBzYW1wbGluZykgZS5mcmFnbWVudFNoYWRlciA9IFwiI2RlZmluZSBIQUxGUkVTXFxuXCIgKyBlLmZyYWdtZW50U2hhZGVyO1xuICAgICAgICBpZiAodGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZCkge1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsID0gbmV3ICQ1V2hlMyRTaGFkZXJNYXRlcmlhbChlKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQgPSBuZXcgKDAsICRlNGNhOGRjYjAyMThmODQ2JGV4cG9ydCRkY2Q2NzBkNzNkYjc1MWY1KShuZXcgJDVXaGUzJFNoYWRlck1hdGVyaWFsKGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbiBcbiAgICAgICAgICogQHJldHVybnMge1RIUkVFLlZlY3RvcjNbXX1cbiAgICAgICAgICovIGdlbmVyYXRlSGVtaXNwaGVyZVNhbXBsZXMobikge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yKGxldCBrID0gMDsgayA8IG47IGsrKyl7XG4gICAgICAgICAgICBjb25zdCB0aGV0YSA9IDIuMzk5OTYzICogaztcbiAgICAgICAgICAgIGxldCByID0gTWF0aC5zcXJ0KGsgKyAwLjUpIC8gTWF0aC5zcXJ0KG4pO1xuICAgICAgICAgICAgY29uc3QgeCA9IHIgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gciAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgICAgIC8vIFByb2plY3QgdG8gaGVtaXNwaGVyZVxuICAgICAgICAgICAgY29uc3QgeiA9IE1hdGguc3FydCgxIC0gKHggKiB4ICsgeSAqIHkpKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKG5ldyAkNVdoZTMkVmVjdG9yMyh4LCB5LCB6KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtU2FtcGxlcyBcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bVJpbmdzIFxuICAgICAgICAgKiBAcmV0dXJucyB7VEhSRUUuVmVjdG9yMltdfVxuICAgICAgICAgKi8gZ2VuZXJhdGVEZW5vaXNlU2FtcGxlcyhudW1TYW1wbGVzLCBudW1SaW5ncykge1xuICAgICAgICBjb25zdCBhbmdsZVN0ZXAgPSAyICogTWF0aC5QSSAqIG51bVJpbmdzIC8gbnVtU2FtcGxlcztcbiAgICAgICAgY29uc3QgaW52TnVtU2FtcGxlcyA9IDEuMCAvIG51bVNhbXBsZXM7XG4gICAgICAgIGNvbnN0IHJhZGl1c1N0ZXAgPSBpbnZOdW1TYW1wbGVzO1xuICAgICAgICBjb25zdCBzYW1wbGVzID0gW107XG4gICAgICAgIGxldCByYWRpdXMgPSBpbnZOdW1TYW1wbGVzO1xuICAgICAgICBsZXQgYW5nbGUgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbnVtU2FtcGxlczsgaSsrKXtcbiAgICAgICAgICAgIHNhbXBsZXMucHVzaChuZXcgJDVXaGUzJFZlY3RvcjIoTWF0aC5jb3MoYW5nbGUpLCBNYXRoLnNpbihhbmdsZSkpLm11bHRpcGx5U2NhbGFyKE1hdGgucG93KHJhZGl1cywgMC43NSkpKTtcbiAgICAgICAgICAgIHJhZGl1cyArPSByYWRpdXNTdGVwO1xuICAgICAgICAgICAgYW5nbGUgKz0gYW5nbGVTdGVwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYW1wbGVzO1xuICAgIH1cbiAgICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5maXJzdEZyYW1lKCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmNvbmZpZ3VyYXRpb24uaGFsZlJlcyA/IDAuNSA6IDE7XG4gICAgICAgIHRoaXMuYmVhdXR5UmVuZGVyVGFyZ2V0LnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMud3JpdGVUYXJnZXRJbnRlcm5hbC5zZXRTaXplKHdpZHRoICogYywgaGVpZ2h0ICogYyk7XG4gICAgICAgIHRoaXMucmVhZFRhcmdldEludGVybmFsLnNldFNpemUod2lkdGggKiBjLCBoZWlnaHQgKiBjKTtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRpb25SZW5kZXJUYXJnZXQuc2V0U2l6ZSh3aWR0aCAqIGMsIGhlaWdodCAqIGMpO1xuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLmhhbGZSZXMpIHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnNldFNpemUod2lkdGggKiBjLCBoZWlnaHQgKiBjKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi50cmFuc3BhcmVuY3lBd2FyZSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3lSZW5kZXJUYXJnZXREV0ZhbHNlLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXVHJ1ZS5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpcnN0RnJhbWUoKSB7XG4gICAgICAgIHRoaXMubmVlZHNGcmFtZSA9IHRydWU7XG4gICAgfVxuICAgIHJlbmRlcihyZW5kZXJlciwgd3JpdGVCdWZmZXIsIHJlYWRCdWZmZXIsIGRlbHRhVGltZSwgbWFza0FjdGl2ZSkge1xuICAgICAgICBpZiAocmVuZGVyZXIuY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgdGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSAhPT0gJDA1ZjY5OTdlNGI2NWRhMTQkZXhwb3J0JGVkNGVlNWQxZTU1NDc0YTUuTG9nIHx8IHJlbmRlcmVyLmNhcGFiaWxpdGllcy5yZXZlcnNlRGVwdGhCdWZmZXIgJiYgdGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSAhPT0gJDA1ZjY5OTdlNGI2NWRhMTQkZXhwb3J0JGVkNGVlNWQxZTU1NDc0YTUuUmV2ZXJzZSkge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSA9IHJlbmRlcmVyLmNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJDA1ZjY5OTdlNGI2NWRhMTQkZXhwb3J0JGVkNGVlNWQxZTU1NDc0YTUuTG9nIDogcmVuZGVyZXIuY2FwYWJpbGl0aWVzLnJldmVyc2VEZXB0aEJ1ZmZlciA/ICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCRlZDRlZTVkMWU1NTQ3NGE1LlJldmVyc2UgOiAkMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNS5EZWZhdWx0O1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmVBT1Bhc3ModGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSwgdGhpcy5jYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEpO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmVEZW5vaXNlUGFzcyh0aGlzLmNvbmZpZ3VyYXRpb24uZGVwdGhCdWZmZXJUeXBlLCB0aGlzLmNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZUVmZmVjdENvbXBvc2l0ZXIodGhpcy5jb25maWd1cmF0aW9uLmRlcHRoQnVmZmVyVHlwZSwgdGhpcy5jYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0ZWN0VHJhbnNwYXJlbmN5KCk7XG4gICAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICAgIGlmICh0aGlzLmxhc3RWaWV3TWF0cml4LmVxdWFscyh0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpICYmIHRoaXMubGFzdFByb2plY3Rpb25NYXRyaXguZXF1YWxzKHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXgpICYmIHRoaXMuY29uZmlndXJhdGlvbi5hY2N1bXVsYXRlICYmICF0aGlzLm5lZWRzRnJhbWUpIHRoaXMuZnJhbWUrKztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLmFjY3VtdWxhdGUpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5hY2N1bXVsYXRpb25SZW5kZXJUYXJnZXQpO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmNsZWFyKHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcmFtZSA9IDA7XG4gICAgICAgICAgICB0aGlzLm5lZWRzRnJhbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RWaWV3TWF0cml4LmNvcHkodGhpcy5jYW1lcmEubWF0cml4V29ybGRJbnZlcnNlKTtcbiAgICAgICAgdGhpcy5sYXN0UHJvamVjdGlvbk1hdHJpeC5jb3B5KHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgICBsZXQgZ2w7XG4gICAgICAgIGxldCBleHQ7XG4gICAgICAgIGxldCB0aW1lclF1ZXJ5O1xuICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHtcbiAgICAgICAgICAgIGdsID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKTtcbiAgICAgICAgICAgIGlmIChleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMiBub3QgYXZhaWxhYmxlLCBkaXNhYmxpbmcgZGVidWcgbW9kZS5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z01vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLmF1dG9SZW5kZXJCZWF1dHkpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLmJlYXV0eVJlbmRlclRhcmdldCk7XG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi50cmFuc3BhcmVuY3lBd2FyZSkgdGhpcy5yZW5kZXJUcmFuc3BhcmVuY3kocmVuZGVyZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgICAgICAgdGltZXJRdWVyeSA9IGdsLmNyZWF0ZVF1ZXJ5KCk7XG4gICAgICAgICAgICBnbC5iZWdpblF1ZXJ5KGV4dC5USU1FX0VMQVBTRURfRVhULCB0aW1lclF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ckVuYWJsZWQgPSByZW5kZXJlci54ci5lbmFibGVkO1xuICAgICAgICByZW5kZXJlci54ci5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Iuc2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgbGV0IHRydWVSYWRpdXMgPSB0aGlzLmNvbmZpZ3VyYXRpb24uYW9SYWRpdXM7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24uaGFsZlJlcyAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uc2NyZWVuU3BhY2VSYWRpdXMpIHRydWVSYWRpdXMgKj0gMC41O1xuICAgICAgICBpZiAodGhpcy5mcmFtZSA8IDEwMjQgLyB0aGlzLmNvbmZpZ3VyYXRpb24uYW9TYW1wbGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLmhhbGZSZXMpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5kZXB0aERvd25zYW1wbGVUYXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlUXVhZC5tYXRlcmlhbC51bmlmb3Jtcy5zY2VuZURlcHRoLnZhbHVlID0gdGhpcy5iZWF1dHlSZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlUXVhZC5tYXRlcmlhbC51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlID0gdGhpcy5fcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJuZWFyXCJdLnZhbHVlID0gdGhpcy5jYW1lcmEubmVhcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJmYXJcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5mYXI7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGVRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wicHJvamVjdGlvbk1hdHJpeEludlwiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInZpZXdNYXRyaXhJbnZcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZDtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJsb2dEZXB0aFwiXS52YWx1ZSA9IHRoaXMuY29uZmlndXJhdGlvbi5kZXB0aEJ1ZmZlclR5cGUgPT09ICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCRlZDRlZTVkMWU1NTQ3NGE1LkxvZztcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsZVF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJvcnRob1wiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxlUXVhZC5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wic2NlbmVEaWZmdXNlXCJdLnZhbHVlID0gdGhpcy5iZWF1dHlSZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInNjZW5lRGVwdGhcIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uaGFsZlJlcyA/IHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmVzWzBdIDogdGhpcy5iZWF1dHlSZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wic2NlbmVOb3JtYWxcIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uaGFsZlJlcyA/IHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmVzWzFdIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInByb2pNYXRcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1widmlld01hdFwiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInByb2pWaWV3TWF0XCJdLnZhbHVlID0gdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jbG9uZSgpLm11bHRpcGx5KHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5jbG9uZSgpKTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInByb2plY3Rpb25NYXRyaXhJbnZcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInZpZXdNYXRyaXhJbnZcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZDtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImNhbWVyYVBvc1wiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLmdldFdvcmxkUG9zaXRpb24obmV3ICQ1V2hlMyRWZWN0b3IzKCkpO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiYmlhc0FkanVzdG1lbnRcIl0udmFsdWUgPSBuZXcgJDVXaGUzJFZlY3RvcjIodGhpcy5jb25maWd1cmF0aW9uLmJpYXNPZmZzZXQsIHRoaXMuY29uZmlndXJhdGlvbi5iaWFzTXVsdGlwbGllcik7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdFNoYWRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJyZXNvbHV0aW9uXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLmhhbGZSZXMgPyB0aGlzLl9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMC41KS5mbG9vcigpIDogdGhpcy5fcjtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInRpbWVcIl0udmFsdWUgPSBwZXJmb3JtYW5jZS5ub3coKSAvIDEwMDA7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdFNoYWRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJzYW1wbGVzXCJdLnZhbHVlID0gdGhpcy5zYW1wbGVzO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiYmx1ZW5vaXNlXCJdLnZhbHVlID0gdGhpcy5ibHVlbm9pc2U7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdFNoYWRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJyYWRpdXNcIl0udmFsdWUgPSB0cnVlUmFkaXVzO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZGlzdGFuY2VGYWxsb2ZmXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLmRpc3RhbmNlRmFsbG9mZjtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcIm5lYXJcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5uZWFyO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZmFyXCJdLnZhbHVlID0gdGhpcy5jYW1lcmEuZmFyO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wib3J0aG9cIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInNjcmVlblNwYWNlUmFkaXVzXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLnNjcmVlblNwYWNlUmFkaXVzO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RTaGFkZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZnJhbWVcIl0udmFsdWUgPSB0aGlzLmZyYW1lO1xuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIEFPXG4gICAgICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy53cml0ZVRhcmdldEludGVybmFsKTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0U2hhZGVyUXVhZC5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgICAgICAgLy8gRW5kIHRoZSBBT1xuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIGJsdXJcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZUl0ZXJhdGlvbnM7IGkrKyl7XG4gICAgICAgICAgICAgICAgW3RoaXMud3JpdGVUYXJnZXRJbnRlcm5hbCwgdGhpcy5yZWFkVGFyZ2V0SW50ZXJuYWxdID0gW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRUYXJnZXRJbnRlcm5hbCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZVRhcmdldEludGVybmFsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInREaWZmdXNlXCJdLnZhbHVlID0gdGhpcy5yZWFkVGFyZ2V0SW50ZXJuYWwudGV4dHVyZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInNjZW5lRGVwdGhcIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uaGFsZlJlcyA/IHRoaXMuZGVwdGhEb3duc2FtcGxlVGFyZ2V0LnRleHR1cmVzWzBdIDogdGhpcy5iZWF1dHlSZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pc3NvbkJsdXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wicHJvak1hdFwiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJ2aWV3TWF0XCJdLnZhbHVlID0gdGhpcy5jYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pc3NvbkJsdXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wicHJvamVjdGlvbk1hdHJpeEludlwiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pc3NvbkJsdXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1widmlld01hdHJpeEludlwiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pc3NvbkJsdXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiY2FtZXJhUG9zXCJdLnZhbHVlID0gdGhpcy5jYW1lcmEuZ2V0V29ybGRQb3NpdGlvbihuZXcgJDVXaGUzJFZlY3RvcjMoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJyZXNvbHV0aW9uXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLmhhbGZSZXMgPyB0aGlzLl9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMC41KS5mbG9vcigpIDogdGhpcy5fcjtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInRpbWVcIl0udmFsdWUgPSBwZXJmb3JtYW5jZS5ub3coKSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJibHVlTm9pc2VcIl0udmFsdWUgPSB0aGlzLmJsdWVub2lzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInJhZGl1c1wiXS52YWx1ZSA9IHRoaXMuY29uZmlndXJhdGlvbi5kZW5vaXNlUmFkaXVzICogKHRoaXMuY29uZmlndXJhdGlvbi5oYWxmUmVzID8gMC41IDogMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJ3b3JsZFJhZGl1c1wiXS52YWx1ZSA9IHRydWVSYWRpdXM7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJkaXN0YW5jZUZhbGxvZmZcIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uZGlzdGFuY2VGYWxsb2ZmO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pc3NvbkJsdXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiaW5kZXhcIl0udmFsdWUgPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pc3NvbkJsdXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wicG9pc3NvbkRpc2tcIl0udmFsdWUgPSB0aGlzLnNhbXBsZXNEZW5vaXNlO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pc3NvbkJsdXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wibmVhclwiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLm5lYXI7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJmYXJcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5mYXI7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2lzc29uQmx1clF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJzY3JlZW5TcGFjZVJhZGl1c1wiXS52YWx1ZSA9IHRoaXMuY29uZmlndXJhdGlvbi5zY3JlZW5TcGFjZVJhZGl1cztcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy53cml0ZVRhcmdldEludGVybmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaXNzb25CbHVyUXVhZC5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMuYWNjdW11bGF0aW9uUmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IG9sZEF1dG9DbGVhciA9IHJlbmRlcmVyLmF1dG9DbGVhcjtcbiAgICAgICAgICAgIHJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hY2N1bXVsYXRpb25RdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1widERpZmZ1c2VcIl0udmFsdWUgPSB0aGlzLndyaXRlVGFyZ2V0SW50ZXJuYWwudGV4dHVyZTtcbiAgICAgICAgICAgIHRoaXMuYWNjdW11bGF0aW9uUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImZyYW1lXCJdLnZhbHVlID0gdGhpcy5mcmFtZTtcbiAgICAgICAgICAgIHRoaXMuYWNjdW11bGF0aW9uUXVhZC5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgICAgICAgcmVuZGVyZXIuYXV0b0NsZWFyID0gb2xkQXV0b0NsZWFyO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdywgd2UgaGF2ZSB0aGUgYmx1cnJlZCBBTyBpbiB3cml0ZVRhcmdldEludGVybmFsXG4gICAgICAgIC8vIEVuZCB0aGUgYmx1clxuICAgICAgICAvLyBTdGFydCB0aGUgY29tcG9zaXRpb25cbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi50cmFuc3BhcmVuY3lBd2FyZSkge1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInRyYW5zcGFyZW5jeURXRmFsc2VcIl0udmFsdWUgPSB0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXRmFsc2UudGV4dHVyZTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJ0cmFuc3BhcmVuY3lEV1RydWVcIl0udmFsdWUgPSB0aGlzLnRyYW5zcGFyZW5jeVJlbmRlclRhcmdldERXVHJ1ZS50ZXh0dXJlO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInRyYW5zcGFyZW5jeURXVHJ1ZURlcHRoXCJdLnZhbHVlID0gdGhpcy50cmFuc3BhcmVuY3lSZW5kZXJUYXJnZXREV1RydWUuZGVwdGhUZXh0dXJlO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInRyYW5zcGFyZW5jeUF3YXJlXCJdLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wic2NlbmVEaWZmdXNlXCJdLnZhbHVlID0gdGhpcy5iZWF1dHlSZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInNjZW5lRGVwdGhcIl0udmFsdWUgPSB0aGlzLmJlYXV0eVJlbmRlclRhcmdldC5kZXB0aFRleHR1cmU7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJhb1RvbmVzXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLmFvVG9uZXM7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJuZWFyXCJdLnZhbHVlID0gdGhpcy5jYW1lcmEubmVhcjtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImZhclwiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLmZhcjtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInByb2plY3Rpb25NYXRyaXhJbnZcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZTtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInZpZXdNYXRyaXhJbnZcIl0udmFsdWUgPSB0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZDtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcIm9ydGhvXCJdLnZhbHVlID0gdGhpcy5jYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmE7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJkb3duc2FtcGxlZERlcHRoXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLmhhbGZSZXMgPyB0aGlzLmRlcHRoRG93bnNhbXBsZVRhcmdldC50ZXh0dXJlc1swXSA6IHRoaXMuYmVhdXR5UmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZTtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcInJlc29sdXRpb25cIl0udmFsdWUgPSB0aGlzLl9yO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiYmx1ZU5vaXNlXCJdLnZhbHVlID0gdGhpcy5ibHVlbm9pc2U7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJpbnRlbnNpdHlcIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uaW50ZW5zaXR5O1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wicmVuZGVyTW9kZVwiXS52YWx1ZSA9IHRoaXMuY29uZmlndXJhdGlvbi5yZW5kZXJNb2RlO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wic2NyZWVuU3BhY2VSYWRpdXNcIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uc2NyZWVuU3BhY2VSYWRpdXM7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJyYWRpdXNcIl0udmFsdWUgPSB0cnVlUmFkaXVzO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZGlzdGFuY2VGYWxsb2ZmXCJdLnZhbHVlID0gdGhpcy5jb25maWd1cmF0aW9uLmRpc3RhbmNlRmFsbG9mZjtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImdhbW1hQ29ycmVjdGlvblwiXS52YWx1ZSA9IHRoaXMuY29uZmlndXJhdGlvbi5nYW1tYUNvcnJlY3Rpb247XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJ0RGlmZnVzZVwiXS52YWx1ZSA9IHRoaXMuYWNjdW11bGF0aW9uUmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJjb2xvclwiXS52YWx1ZSA9IHRoaXMuX2MuY29weSh0aGlzLmNvbmZpZ3VyYXRpb24uY29sb3IpLmNvbnZlcnRTUkdCVG9MaW5lYXIoKTtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImNvbG9yTXVsdGlwbHlcIl0udmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uY29sb3JNdWx0aXBseTtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImNhbWVyYVBvc1wiXS52YWx1ZSA9IHRoaXMuY2FtZXJhLmdldFdvcmxkUG9zaXRpb24obmV3ICQ1V2hlMyRWZWN0b3IzKCkpO1xuICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZm9nXCJdLnZhbHVlID0gISF0aGlzLnNjZW5lLmZvZztcbiAgICAgICAgaWYgKHRoaXMuc2NlbmUuZm9nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZS5mb2cuaXNGb2cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdENvbXBvc2l0ZXJRdWFkLm1hdGVyaWFsLnVuaWZvcm1zW1wiZm9nRXhwXCJdLnZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5tYXRlcmlhbC51bmlmb3Jtc1tcImZvZ05lYXJcIl0udmFsdWUgPSB0aGlzLnNjZW5lLmZvZy5uZWFyO1xuICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJmb2dGYXJcIl0udmFsdWUgPSB0aGlzLnNjZW5lLmZvZy5mYXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2NlbmUuZm9nLmlzRm9nRXhwMikge1xuICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJmb2dFeHBcIl0udmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0Q29tcG9zaXRlclF1YWQubWF0ZXJpYWwudW5pZm9ybXNbXCJmb2dEZW5zaXR5XCJdLnZhbHVlID0gdGhpcy5zY2VuZS5mb2cuZGVuc2l0eTtcbiAgICAgICAgICAgIH0gZWxzZSBjb25zb2xlLmVycm9yKGBVbnN1cHBvcnRlZCBmb2cgdHlwZSAke3RoaXMuc2NlbmUuZm9nLmNvbnN0cnVjdG9yLm5hbWV9IGluIFNTQU9QYXNzLmApO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHdyaXRlQnVmZmVyKTtcbiAgICAgICAgdGhpcy5lZmZlY3RDb21wb3NpdGVyUXVhZC5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHtcbiAgICAgICAgICAgIGdsLmVuZFF1ZXJ5KGV4dC5USU1FX0VMQVBTRURfRVhUKTtcbiAgICAgICAgICAgICQwNWY2OTk3ZTRiNjVkYTE0JHZhciRjaGVja1RpbWVyUXVlcnkodGltZXJRdWVyeSwgZ2wsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyLnhyLmVuYWJsZWQgPSB4ckVuYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSBkZWJ1ZyBtb2RlIG9mIHRoZSBBTywgbWVhbmluZyB0aGUgbGFzdFRpbWUgdmFsdWUgd2lsbCBiZSB1cGRhdGVkLlxuICAgICAgICAgKi8gZW5hYmxlRGVidWdNb2RlKCkge1xuICAgICAgICB0aGlzLmRlYnVnTW9kZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgZGVidWcgbW9kZSBvZiB0aGUgQU8sIG1lYW5pbmcgdGhlIGxhc3RUaW1lIHZhbHVlIHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4gICAgICAgICAqLyBkaXNhYmxlRGVidWdNb2RlKCkge1xuICAgICAgICB0aGlzLmRlYnVnTW9kZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgZGlzcGxheSBtb2RlIG9mIHRoZSBBT1xuICAgICAgICAgKiBAcGFyYW0ge1wiQ29tYmluZWRcIiB8IFwiQU9cIiB8IFwiTm8gQU9cIiB8IFwiU3BsaXRcIiB8IFwiU3BsaXQgQU9cIn0gbW9kZSAtIFRoZSBkaXNwbGF5IG1vZGUuIFxuICAgICAgICAgKi8gc2V0RGlzcGxheU1vZGUobW9kZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucmVuZGVyTW9kZSA9IFtcbiAgICAgICAgICAgIFwiQ29tYmluZWRcIixcbiAgICAgICAgICAgIFwiQU9cIixcbiAgICAgICAgICAgIFwiTm8gQU9cIixcbiAgICAgICAgICAgIFwiU3BsaXRcIixcbiAgICAgICAgICAgIFwiU3BsaXQgQU9cIlxuICAgICAgICBdLmluZGV4T2YobW9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHtcIlBlcmZvcm1hbmNlXCIgfCBcIkxvd1wiIHwgXCJNZWRpdW1cIiB8IFwiSGlnaFwiIHwgXCJVbHRyYVwifSBtb2RlIFxuICAgICAgICAgKi8gc2V0UXVhbGl0eU1vZGUobW9kZSkge1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJQZXJmb3JtYW5jZVwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uYW9TYW1wbGVzID0gODtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5kZW5vaXNlU2FtcGxlcyA9IDQ7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZVJhZGl1cyA9IDEyO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiTG93XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5hb1NhbXBsZXMgPSAxNjtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5kZW5vaXNlU2FtcGxlcyA9IDQ7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZVJhZGl1cyA9IDEyO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiTWVkaXVtXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5hb1NhbXBsZXMgPSAxNjtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5kZW5vaXNlU2FtcGxlcyA9IDg7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZVJhZGl1cyA9IDEyO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiSGlnaFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uYW9TYW1wbGVzID0gNjQ7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZVNhbXBsZXMgPSA4O1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmRlbm9pc2VSYWRpdXMgPSA2O1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiVWx0cmFcIikge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmFvU2FtcGxlcyA9IDY0O1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmRlbm9pc2VTYW1wbGVzID0gMTY7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZGVub2lzZVJhZGl1cyA9IDY7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IHskMDVmNjk5N2U0YjY1ZGExNCRleHBvcnQkZWQ0ZWU1ZDFlNTU0NzRhNSBhcyBEZXB0aFR5cGUsICQwNWY2OTk3ZTRiNjVkYTE0JGV4cG9ydCQyZDU3ZGIyMGI1ZWI1ZTBhIGFzIE44QU9QYXNzLCAkODc0MzFlZTkzYjAzNzg0NCRleHBvcnQkMjQ4OWY5OTgxYWIwZmE4MiBhcyBOOEFPUG9zdFBhc3N9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TjhBTy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/n8ao/dist/N8AO.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/postprocessing/build/index.js":
/*!****************************************************!*\
  !*** ./node_modules/postprocessing/build/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASCIIEffect: () => (/* binding */ ASCIIEffect),\n/* harmony export */   ASCIITexture: () => (/* binding */ ASCIITexture),\n/* harmony export */   AdaptiveLuminanceMaterial: () => (/* binding */ AdaptiveLuminanceMaterial),\n/* harmony export */   AdaptiveLuminancePass: () => (/* binding */ AdaptiveLuminancePass),\n/* harmony export */   BlendFunction: () => (/* binding */ BlendFunction),\n/* harmony export */   BlendMode: () => (/* binding */ BlendMode),\n/* harmony export */   BloomEffect: () => (/* binding */ BloomEffect),\n/* harmony export */   BlurPass: () => (/* binding */ KawaseBlurPass),\n/* harmony export */   BokehEffect: () => (/* binding */ BokehEffect),\n/* harmony export */   BokehMaterial: () => (/* binding */ BokehMaterial),\n/* harmony export */   BoxBlurMaterial: () => (/* binding */ BoxBlurMaterial),\n/* harmony export */   BoxBlurPass: () => (/* binding */ BoxBlurPass),\n/* harmony export */   BrightnessContrastEffect: () => (/* binding */ BrightnessContrastEffect),\n/* harmony export */   ChromaticAberrationEffect: () => (/* binding */ ChromaticAberrationEffect),\n/* harmony export */   CircleOfConfusionMaterial: () => (/* binding */ CircleOfConfusionMaterial),\n/* harmony export */   ClearMaskPass: () => (/* binding */ ClearMaskPass),\n/* harmony export */   ClearPass: () => (/* binding */ ClearPass),\n/* harmony export */   ColorAverageEffect: () => (/* binding */ ColorAverageEffect),\n/* harmony export */   ColorChannel: () => (/* binding */ ColorChannel),\n/* harmony export */   ColorDepthEffect: () => (/* binding */ ColorDepthEffect),\n/* harmony export */   ColorEdgesMaterial: () => (/* binding */ EdgeDetectionMaterial),\n/* harmony export */   ConvolutionMaterial: () => (/* binding */ KawaseBlurMaterial),\n/* harmony export */   CopyMaterial: () => (/* binding */ CopyMaterial),\n/* harmony export */   CopyPass: () => (/* binding */ CopyPass),\n/* harmony export */   DepthComparisonMaterial: () => (/* binding */ DepthComparisonMaterial),\n/* harmony export */   DepthCopyMaterial: () => (/* binding */ DepthCopyMaterial),\n/* harmony export */   DepthCopyMode: () => (/* binding */ DepthCopyMode),\n/* harmony export */   DepthCopyPass: () => (/* binding */ DepthCopyPass),\n/* harmony export */   DepthDownsamplingMaterial: () => (/* binding */ DepthDownsamplingMaterial),\n/* harmony export */   DepthDownsamplingPass: () => (/* binding */ DepthDownsamplingPass),\n/* harmony export */   DepthEffect: () => (/* binding */ DepthEffect),\n/* harmony export */   DepthMaskMaterial: () => (/* binding */ DepthMaskMaterial),\n/* harmony export */   DepthOfFieldEffect: () => (/* binding */ DepthOfFieldEffect),\n/* harmony export */   DepthPass: () => (/* binding */ DepthPass),\n/* harmony export */   DepthPickingPass: () => (/* binding */ DepthPickingPass),\n/* harmony export */   DepthSavePass: () => (/* binding */ DepthCopyPass),\n/* harmony export */   DepthTestStrategy: () => (/* binding */ DepthTestStrategy),\n/* harmony export */   Disposable: () => (/* binding */ Disposable),\n/* harmony export */   DotScreenEffect: () => (/* binding */ DotScreenEffect),\n/* harmony export */   DownsamplingMaterial: () => (/* binding */ DownsamplingMaterial),\n/* harmony export */   EdgeDetectionMaterial: () => (/* binding */ EdgeDetectionMaterial),\n/* harmony export */   EdgeDetectionMode: () => (/* binding */ EdgeDetectionMode),\n/* harmony export */   Effect: () => (/* binding */ Effect),\n/* harmony export */   EffectAttribute: () => (/* binding */ EffectAttribute),\n/* harmony export */   EffectComposer: () => (/* binding */ EffectComposer),\n/* harmony export */   EffectMaterial: () => (/* binding */ EffectMaterial),\n/* harmony export */   EffectPass: () => (/* binding */ EffectPass),\n/* harmony export */   EffectShaderData: () => (/* binding */ EffectShaderData),\n/* harmony export */   EffectShaderSection: () => (/* binding */ EffectShaderSection),\n/* harmony export */   FXAAEffect: () => (/* binding */ FXAAEffect),\n/* harmony export */   GammaCorrectionEffect: () => (/* binding */ GammaCorrectionEffect),\n/* harmony export */   GaussKernel: () => (/* binding */ GaussKernel),\n/* harmony export */   GaussianBlurMaterial: () => (/* binding */ GaussianBlurMaterial),\n/* harmony export */   GaussianBlurPass: () => (/* binding */ GaussianBlurPass),\n/* harmony export */   GlitchEffect: () => (/* binding */ GlitchEffect),\n/* harmony export */   GlitchMode: () => (/* binding */ GlitchMode),\n/* harmony export */   GodRaysEffect: () => (/* binding */ GodRaysEffect),\n/* harmony export */   GodRaysMaterial: () => (/* binding */ GodRaysMaterial),\n/* harmony export */   GridEffect: () => (/* binding */ GridEffect),\n/* harmony export */   HueSaturationEffect: () => (/* binding */ HueSaturationEffect),\n/* harmony export */   ImmutableTimer: () => (/* binding */ ImmutableTimer),\n/* harmony export */   Initializable: () => (/* binding */ Initializable),\n/* harmony export */   KawaseBlurMaterial: () => (/* binding */ KawaseBlurMaterial),\n/* harmony export */   KawaseBlurPass: () => (/* binding */ KawaseBlurPass),\n/* harmony export */   KernelSize: () => (/* binding */ KernelSize),\n/* harmony export */   LUT1DEffect: () => (/* binding */ LUT1DEffect),\n/* harmony export */   LUT3DEffect: () => (/* binding */ LUT3DEffect),\n/* harmony export */   LUT3dlLoader: () => (/* binding */ LUT3dlLoader),\n/* harmony export */   LUTCubeLoader: () => (/* binding */ LUTCubeLoader),\n/* harmony export */   LUTEffect: () => (/* binding */ LUT3DEffect),\n/* harmony export */   LUTOperation: () => (/* binding */ LUTOperation),\n/* harmony export */   LambdaPass: () => (/* binding */ LambdaPass),\n/* harmony export */   LensDistortionEffect: () => (/* binding */ LensDistortionEffect),\n/* harmony export */   LookupTexture: () => (/* binding */ LookupTexture),\n/* harmony export */   LookupTexture3D: () => (/* binding */ LookupTexture),\n/* harmony export */   LuminanceMaterial: () => (/* binding */ LuminanceMaterial),\n/* harmony export */   LuminancePass: () => (/* binding */ LuminancePass),\n/* harmony export */   MaskFunction: () => (/* binding */ MaskFunction),\n/* harmony export */   MaskMaterial: () => (/* binding */ MaskMaterial),\n/* harmony export */   MaskPass: () => (/* binding */ MaskPass),\n/* harmony export */   MipmapBlurPass: () => (/* binding */ MipmapBlurPass),\n/* harmony export */   NoiseEffect: () => (/* binding */ NoiseEffect),\n/* harmony export */   NoiseTexture: () => (/* binding */ NoiseTexture),\n/* harmony export */   NormalPass: () => (/* binding */ NormalPass),\n/* harmony export */   OutlineEdgesMaterial: () => (/* binding */ OutlineMaterial),\n/* harmony export */   OutlineEffect: () => (/* binding */ OutlineEffect),\n/* harmony export */   OutlineMaterial: () => (/* binding */ OutlineMaterial),\n/* harmony export */   OverrideMaterialManager: () => (/* binding */ OverrideMaterialManager),\n/* harmony export */   Pass: () => (/* binding */ Pass),\n/* harmony export */   PixelationEffect: () => (/* binding */ PixelationEffect),\n/* harmony export */   PredicationMode: () => (/* binding */ PredicationMode),\n/* harmony export */   RawImageData: () => (/* binding */ RawImageData),\n/* harmony export */   RealisticBokehEffect: () => (/* binding */ RealisticBokehEffect),\n/* harmony export */   RenderPass: () => (/* binding */ RenderPass),\n/* harmony export */   Resizable: () => (/* binding */ Resizable),\n/* harmony export */   Resizer: () => (/* binding */ Resolution),\n/* harmony export */   Resolution: () => (/* binding */ Resolution),\n/* harmony export */   SMAAAreaImageData: () => (/* binding */ SMAAAreaImageData),\n/* harmony export */   SMAAEffect: () => (/* binding */ SMAAEffect),\n/* harmony export */   SMAAImageGenerator: () => (/* binding */ SMAAImageGenerator),\n/* harmony export */   SMAAImageLoader: () => (/* binding */ SMAAImageLoader),\n/* harmony export */   SMAAPreset: () => (/* binding */ SMAAPreset),\n/* harmony export */   SMAASearchImageData: () => (/* binding */ SMAASearchImageData),\n/* harmony export */   SMAAWeightsMaterial: () => (/* binding */ SMAAWeightsMaterial),\n/* harmony export */   SSAOEffect: () => (/* binding */ SSAOEffect),\n/* harmony export */   SSAOMaterial: () => (/* binding */ SSAOMaterial),\n/* harmony export */   SavePass: () => (/* binding */ CopyPass),\n/* harmony export */   ScanlineEffect: () => (/* binding */ ScanlineEffect),\n/* harmony export */   Section: () => (/* binding */ EffectShaderSection),\n/* harmony export */   Selection: () => (/* binding */ Selection),\n/* harmony export */   SelectiveBloomEffect: () => (/* binding */ SelectiveBloomEffect),\n/* harmony export */   SepiaEffect: () => (/* binding */ SepiaEffect),\n/* harmony export */   ShaderPass: () => (/* binding */ ShaderPass),\n/* harmony export */   ShockWaveEffect: () => (/* binding */ ShockWaveEffect),\n/* harmony export */   TetrahedralUpscaler: () => (/* binding */ TetrahedralUpscaler),\n/* harmony export */   TextureEffect: () => (/* binding */ TextureEffect),\n/* harmony export */   TiltShiftBlurMaterial: () => (/* binding */ TiltShiftBlurMaterial),\n/* harmony export */   TiltShiftBlurPass: () => (/* binding */ TiltShiftBlurPass),\n/* harmony export */   TiltShiftEffect: () => (/* binding */ TiltShiftEffect),\n/* harmony export */   Timer: () => (/* binding */ Timer),\n/* harmony export */   ToneMappingEffect: () => (/* binding */ ToneMappingEffect),\n/* harmony export */   ToneMappingMode: () => (/* binding */ ToneMappingMode),\n/* harmony export */   UpsamplingMaterial: () => (/* binding */ UpsamplingMaterial),\n/* harmony export */   VignetteEffect: () => (/* binding */ VignetteEffect),\n/* harmony export */   VignetteTechnique: () => (/* binding */ VignetteTechnique),\n/* harmony export */   WebGLExtension: () => (/* binding */ WebGLExtension),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/**\n * postprocessing v6.37.6 build Fri Jul 04 2025\n * https://github.com/pmndrs/postprocessing\n * Copyright 2015-2025 Raoul van Rüschen\n * @license Zlib\n */\n\n// package.json\nvar version = \"6.37.6\";\n\n// src/core/Disposable.js\nvar Disposable = class {\n  /**\n   * Frees internal resources.\n   */\n  dispose() {\n  }\n};\n\n// src/core/EffectComposer.js\n\n\n// src/core/Timer.js\nvar MILLISECONDS_TO_SECONDS = 1 / 1e3;\nvar SECONDS_TO_MILLISECONDS = 1e3;\nvar Timer = class {\n  /**\n   * Constructs a new timer.\n   */\n  constructor() {\n    this.startTime = performance.now();\n    this.previousTime = 0;\n    this.currentTime = 0;\n    this._delta = 0;\n    this._elapsed = 0;\n    this._fixedDelta = 1e3 / 60;\n    this.timescale = 1;\n    this.useFixedDelta = false;\n    this._autoReset = false;\n  }\n  /**\n   * Enables or disables auto reset based on page visibility.\n   *\n   * If enabled, the timer will be reset when the page becomes visible. This effectively pauses the timer when the page\n   * is hidden. Has no effect if the API is not supported.\n   *\n   * @type {Boolean}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API\n   */\n  get autoReset() {\n    return this._autoReset;\n  }\n  set autoReset(value) {\n    if (typeof document !== \"undefined\" && document.hidden !== void 0) {\n      if (value) {\n        document.addEventListener(\"visibilitychange\", this);\n      } else {\n        document.removeEventListener(\"visibilitychange\", this);\n      }\n      this._autoReset = value;\n    }\n  }\n  get delta() {\n    return this._delta * MILLISECONDS_TO_SECONDS;\n  }\n  get fixedDelta() {\n    return this._fixedDelta * MILLISECONDS_TO_SECONDS;\n  }\n  set fixedDelta(value) {\n    this._fixedDelta = value * SECONDS_TO_MILLISECONDS;\n  }\n  get elapsed() {\n    return this._elapsed * MILLISECONDS_TO_SECONDS;\n  }\n  /**\n   * Updates this timer.\n   *\n   * @param {Boolean} [timestamp] - The current time in milliseconds.\n   */\n  update(timestamp) {\n    if (this.useFixedDelta) {\n      this._delta = this.fixedDelta;\n    } else {\n      this.previousTime = this.currentTime;\n      this.currentTime = (timestamp !== void 0 ? timestamp : performance.now()) - this.startTime;\n      this._delta = this.currentTime - this.previousTime;\n    }\n    this._delta *= this.timescale;\n    this._elapsed += this._delta;\n  }\n  /**\n   * Resets this timer.\n   */\n  reset() {\n    this._delta = 0;\n    this._elapsed = 0;\n    this.currentTime = performance.now() - this.startTime;\n  }\n  getDelta() {\n    return this.delta;\n  }\n  getElapsed() {\n    return this.elapsed;\n  }\n  handleEvent(e) {\n    if (!document.hidden) {\n      this.currentTime = performance.now() - this.startTime;\n    }\n  }\n  dispose() {\n    this.autoReset = false;\n  }\n};\n\n// src/passes/Pass.js\n\nvar fullscreenGeometry = /* @__PURE__ */ (() => {\n  const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);\n  const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);\n  const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(vertices, 3));\n  geometry.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(uvs, 2));\n  return geometry;\n})();\nvar Pass = class _Pass {\n  /**\n   * A shared fullscreen triangle.\n   *\n   * The screen size is 2x2 units (NDC). A triangle needs to be 4x4 units to fill the screen.\n   * @see https://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes/\n   * @type {BufferGeometry}\n   * @internal\n   */\n  static get fullscreenGeometry() {\n    return fullscreenGeometry;\n  }\n  /**\n   * Constructs a new pass.\n   *\n   * @param {String} [name] - The name of this pass. Does not have to be unique.\n   * @param {Scene} [scene] - The scene to render. The default scene contains a single mesh that fills the screen.\n   * @param {Camera} [camera] - A camera. Fullscreen effect passes don't require a camera.\n   */\n  constructor(name = \"Pass\", scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene(), camera = new three__WEBPACK_IMPORTED_MODULE_0__.Camera()) {\n    this.name = name;\n    this.renderer = null;\n    this.scene = scene;\n    this.camera = camera;\n    this.screen = null;\n    this.rtt = true;\n    this.needsSwap = true;\n    this.needsDepthTexture = false;\n    this.enabled = true;\n  }\n  /**\n   * Sets the render to screen flag.\n   *\n   * If this flag is changed, the fullscreen material will be updated as well.\n   *\n   * @type {Boolean}\n   */\n  get renderToScreen() {\n    return !this.rtt;\n  }\n  set renderToScreen(value) {\n    if (this.rtt === value) {\n      const material = this.fullscreenMaterial;\n      if (material !== null) {\n        material.needsUpdate = true;\n      }\n      this.rtt = !value;\n    }\n  }\n  /**\n   * Sets the main scene.\n   *\n   * @type {Scene}\n   */\n  set mainScene(value) {\n  }\n  /**\n   * Sets the main camera.\n   *\n   * @type {Camera}\n   */\n  set mainCamera(value) {\n  }\n  /**\n   * Sets the renderer\n   *\n   * @deprecated\n   * @param {WebGLRenderer} renderer - The renderer.\n   */\n  setRenderer(renderer) {\n    this.renderer = renderer;\n  }\n  /**\n   * Indicates whether this pass is enabled.\n   *\n   * @deprecated Use enabled instead.\n   * @return {Boolean} Whether this pass is enabled.\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Enables or disables this pass.\n   *\n   * @deprecated Use enabled instead.\n   * @param {Boolean} value - Whether the pass should be enabled.\n   */\n  setEnabled(value) {\n    this.enabled = value;\n  }\n  /**\n   * The fullscreen material.\n   *\n   * @type {Material}\n   */\n  get fullscreenMaterial() {\n    return this.screen !== null ? this.screen.material : null;\n  }\n  set fullscreenMaterial(value) {\n    let screen = this.screen;\n    if (screen !== null) {\n      screen.material = value;\n    } else {\n      screen = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(_Pass.fullscreenGeometry, value);\n      screen.frustumCulled = false;\n      if (this.scene === null) {\n        this.scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n      }\n      this.scene.add(screen);\n      this.screen = screen;\n    }\n  }\n  /**\n   * Returns the current fullscreen material.\n   *\n   * @deprecated Use fullscreenMaterial instead.\n   * @return {Material} The current fullscreen material, or null if there is none.\n   */\n  getFullscreenMaterial() {\n    return this.fullscreenMaterial;\n  }\n  /**\n   * Sets the fullscreen material.\n   *\n   * @deprecated Use fullscreenMaterial instead.\n   * @protected\n   * @param {Material} value - A fullscreen material.\n   */\n  setFullscreenMaterial(value) {\n    this.fullscreenMaterial = value;\n  }\n  /**\n   * Returns the current depth texture.\n   *\n   * @return {Texture} The current depth texture, or null if there is none.\n   */\n  getDepthTexture() {\n    return null;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * This method will be called automatically by the {@link EffectComposer}.\n   * You may override this method if your pass relies on the depth information of a preceding {@link RenderPass}.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategy} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n  }\n  /**\n   * Renders this pass.\n   *\n   * This is an abstract method that must be overridden.\n   *\n   * @abstract\n   * @throws {Error} An error is thrown if the method is not overridden.\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    throw new Error(\"Render method not implemented!\");\n  }\n  /**\n   * Sets the size.\n   *\n   * You may override this method if you want to be informed about the size of the backbuffer/canvas.\n   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * This method is called when this pass is added to an {@link EffectComposer}.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n  }\n  /**\n   * Performs a shallow search for disposable properties and deletes them.\n   *\n   * The {@link EffectComposer} calls this method when it is being destroyed. You can use it independently to free\n   * memory when you're certain that you don't need this pass anymore.\n   */\n  dispose() {\n    for (const key of Object.keys(this)) {\n      const property = this[key];\n      const isDisposable = property instanceof three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture || property instanceof _Pass;\n      if (isDisposable) {\n        this[key].dispose();\n      }\n    }\n    if (this.fullscreenMaterial !== null) {\n      this.fullscreenMaterial.dispose();\n    }\n  }\n};\n\n// src/passes/ClearMaskPass.js\nvar ClearMaskPass = class extends Pass {\n  /**\n   * Constructs a new clear mask pass.\n   */\n  constructor() {\n    super(\"ClearMaskPass\", null, null);\n    this.needsSwap = false;\n  }\n  /**\n   * Disables the global stencil test.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const stencil = renderer.state.buffers.stencil;\n    stencil.setLocked(false);\n    stencil.setTest(false);\n  }\n};\n\n// src/passes/CopyPass.js\n\n\n// src/materials/CopyMaterial.js\n\n\n// src/materials/glsl/copy.frag\nvar copy_default = `#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}`;\n\n// src/materials/glsl/common.vert\nvar common_default = `varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/CopyMaterial.js\nvar CopyMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new copy material.\n   */\n  constructor() {\n    super({\n      name: \"CopyMaterial\",\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        opacity: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: copy_default,\n      vertexShader: common_default\n    });\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Number} value - The buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Returns the opacity.\n   *\n   * @deprecated Use opacity instead.\n   * @return {Number} The opacity.\n   */\n  getOpacity(value) {\n    return this.uniforms.opacity.value;\n  }\n  /**\n   * Sets the opacity.\n   *\n   * @deprecated Use opacity instead.\n   * @param {Number} value - The opacity.\n   */\n  setOpacity(value) {\n    this.uniforms.opacity.value = value;\n  }\n};\n\n// src/passes/CopyPass.js\nvar CopyPass = class extends Pass {\n  /**\n   * Constructs a new save pass.\n   *\n   * @param {WebGLRenderTarget} [renderTarget] - A render target.\n   * @param {Boolean} [autoResize=true] - Whether the render target size should be updated automatically.\n   */\n  constructor(renderTarget, autoResize = true) {\n    super(\"CopyPass\");\n    this.fullscreenMaterial = new CopyMaterial();\n    this.needsSwap = false;\n    this.renderTarget = renderTarget;\n    if (renderTarget === void 0) {\n      this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n        minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n        magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n        stencilBuffer: false,\n        depthBuffer: false\n      });\n      this.renderTarget.texture.name = \"CopyPass.Target\";\n    }\n    this.autoResize = autoResize;\n  }\n  /**\n   * Enables or disables auto resizing of the render target.\n   *\n   * @deprecated Use autoResize instead.\n   * @type {Boolean}\n   */\n  get resize() {\n    return this.autoResize;\n  }\n  set resize(value) {\n    this.autoResize = value;\n  }\n  /**\n   * The output texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the output texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Enables or disables auto resizing of the render target.\n   *\n   * @deprecated Use autoResize instead.\n   * @param {Boolean} value - Whether the render target size should be updated automatically.\n   */\n  setAutoResizeEnabled(value) {\n    this.autoResize = value;\n  }\n  /**\n   * Saves the input buffer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    this.fullscreenMaterial.inputBuffer = inputBuffer.texture;\n    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n    renderer.render(this.scene, this.camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    if (this.autoResize) {\n      this.renderTarget.setSize(width, height);\n    }\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (frameBufferType !== void 0) {\n      this.renderTarget.texture.type = frameBufferType;\n      if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n      } else if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        this.renderTarget.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n      }\n    }\n  }\n};\n\n// src/passes/ClearPass.js\n\nvar color = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Color();\nvar ClearPass = class extends Pass {\n  /**\n   * Constructs a new clear pass.\n   *\n   * @param {Boolean} [color=true] - Determines whether the color buffer should be cleared.\n   * @param {Boolean} [depth=true] - Determines whether the depth buffer should be cleared.\n   * @param {Boolean} [stencil=false] - Determines whether the stencil buffer should be cleared.\n   */\n  constructor(color2 = true, depth = true, stencil = false) {\n    super(\"ClearPass\", null, null);\n    this.needsSwap = false;\n    this.color = color2;\n    this.depth = depth;\n    this.stencil = stencil;\n    this.overrideClearColor = null;\n    this.overrideClearAlpha = -1;\n  }\n  /**\n   * Sets the clear flags.\n   *\n   * @param {Boolean} color - Whether the color buffer should be cleared.\n   * @param {Boolean} depth - Whether the depth buffer should be cleared.\n   * @param {Boolean} stencil - Whether the stencil buffer should be cleared.\n   */\n  setClearFlags(color2, depth, stencil) {\n    this.color = color2;\n    this.depth = depth;\n    this.stencil = stencil;\n  }\n  /**\n   * Returns the override clear color. Default is null.\n   *\n   * @deprecated Use overrideClearColor instead.\n   * @return {Color} The clear color.\n   */\n  getOverrideClearColor() {\n    return this.overrideClearColor;\n  }\n  /**\n   * Sets the override clear color.\n   *\n   * @deprecated Use overrideClearColor instead.\n   * @param {Color} value - The clear color.\n   */\n  setOverrideClearColor(value) {\n    this.overrideClearColor = value;\n  }\n  /**\n   * Returns the override clear alpha. Default is -1.\n   *\n   * @deprecated Use overrideClearAlpha instead.\n   * @return {Number} The clear alpha.\n   */\n  getOverrideClearAlpha() {\n    return this.overrideClearAlpha;\n  }\n  /**\n   * Sets the override clear alpha.\n   *\n   * @deprecated Use overrideClearAlpha instead.\n   * @param {Number} value - The clear alpha.\n   */\n  setOverrideClearAlpha(value) {\n    this.overrideClearAlpha = value;\n  }\n  /**\n   * Clears the input buffer or the screen.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const overrideClearColor = this.overrideClearColor;\n    const overrideClearAlpha = this.overrideClearAlpha;\n    const clearAlpha = renderer.getClearAlpha();\n    const hasOverrideClearColor = overrideClearColor !== null;\n    const hasOverrideClearAlpha = overrideClearAlpha >= 0;\n    if (hasOverrideClearColor) {\n      renderer.getClearColor(color);\n      renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);\n    } else if (hasOverrideClearAlpha) {\n      renderer.setClearAlpha(overrideClearAlpha);\n    }\n    renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);\n    renderer.clear(this.color, this.depth, this.stencil);\n    if (hasOverrideClearColor) {\n      renderer.setClearColor(color, clearAlpha);\n    } else if (hasOverrideClearAlpha) {\n      renderer.setClearAlpha(clearAlpha);\n    }\n  }\n};\n\n// src/passes/MaskPass.js\nvar MaskPass = class extends Pass {\n  /**\n   * Constructs a new mask pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use.\n   */\n  constructor(scene, camera) {\n    super(\"MaskPass\", scene, camera);\n    this.needsSwap = false;\n    this.clearPass = new ClearPass(false, false, true);\n    this.inverse = false;\n  }\n  set mainScene(value) {\n    this.scene = value;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n  }\n  /**\n   * Indicates whether the mask should be inverted.\n   *\n   * @type {Boolean}\n   */\n  get inverted() {\n    return this.inverse;\n  }\n  set inverted(value) {\n    this.inverse = value;\n  }\n  /**\n   * Indicates whether this pass should clear the stencil buffer.\n   *\n   * @type {Boolean}\n   * @deprecated Use clearPass.enabled instead.\n   */\n  get clear() {\n    return this.clearPass.enabled;\n  }\n  set clear(value) {\n    this.clearPass.enabled = value;\n  }\n  /**\n   * Returns the internal clear pass.\n   *\n   * @deprecated Use clearPass.enabled instead.\n   * @return {ClearPass} The clear pass.\n   */\n  getClearPass() {\n    return this.clearPass;\n  }\n  /**\n   * Indicates whether the mask is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the mask is inverted.\n   */\n  isInverted() {\n    return this.inverted;\n  }\n  /**\n   * Enables or disable mask inversion.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether the mask should be inverted.\n   */\n  setInverted(value) {\n    this.inverted = value;\n  }\n  /**\n   * Renders the effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const context = renderer.getContext();\n    const buffers = renderer.state.buffers;\n    const scene = this.scene;\n    const camera = this.camera;\n    const clearPass = this.clearPass;\n    const writeValue = this.inverted ? 0 : 1;\n    const clearValue = 1 - writeValue;\n    buffers.color.setMask(false);\n    buffers.depth.setMask(false);\n    buffers.color.setLocked(true);\n    buffers.depth.setLocked(true);\n    buffers.stencil.setTest(true);\n    buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n    buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);\n    buffers.stencil.setClear(clearValue);\n    buffers.stencil.setLocked(true);\n    if (this.clearPass.enabled) {\n      if (this.renderToScreen) {\n        clearPass.render(renderer, null);\n      } else {\n        clearPass.render(renderer, inputBuffer);\n        clearPass.render(renderer, outputBuffer);\n      }\n    }\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      renderer.render(scene, camera);\n    } else {\n      renderer.setRenderTarget(inputBuffer);\n      renderer.render(scene, camera);\n      renderer.setRenderTarget(outputBuffer);\n      renderer.render(scene, camera);\n    }\n    buffers.color.setLocked(false);\n    buffers.depth.setLocked(false);\n    buffers.stencil.setLocked(false);\n    buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);\n    buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n    buffers.stencil.setLocked(true);\n  }\n};\n\n// src/core/EffectComposer.js\nvar EffectComposer = class {\n  /**\n   * Constructs a new effect composer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer that should be used.\n   * @param {Object} [options] - The options.\n   * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.\n   * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.\n   * @param {Boolean} [options.alpha] - Deprecated. Buffers are always RGBA since three r137.\n   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.\n   * @param {Number} [options.frameBufferType] - The type of the internal frame buffers. It's recommended to use HalfFloatType if possible.\n   */\n  constructor(renderer = null, {\n    depthBuffer = true,\n    stencilBuffer = false,\n    multisampling = 0,\n    frameBufferType\n  } = {}) {\n    this.renderer = null;\n    this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType, multisampling);\n    this.outputBuffer = this.inputBuffer.clone();\n    this.copyPass = new CopyPass();\n    this.depthTexture = null;\n    this.passes = [];\n    this.timer = new Timer();\n    this.autoRenderToScreen = true;\n    this.setRenderer(renderer);\n  }\n  /**\n   * The current amount of samples used for multisample anti-aliasing.\n   *\n   * @type {Number}\n   */\n  get multisampling() {\n    return this.inputBuffer.samples || 0;\n  }\n  /**\n   * Sets the amount of MSAA samples.\n   *\n   * Requires WebGL 2. Set to zero to disable multisampling.\n   *\n   * @type {Number}\n   */\n  set multisampling(value) {\n    const buffer = this.inputBuffer;\n    const multisampling = this.multisampling;\n    if (multisampling > 0 && value > 0) {\n      this.inputBuffer.samples = value;\n      this.outputBuffer.samples = value;\n      this.inputBuffer.dispose();\n      this.outputBuffer.dispose();\n    } else if (multisampling !== value) {\n      this.inputBuffer.dispose();\n      this.outputBuffer.dispose();\n      this.inputBuffer = this.createBuffer(\n        buffer.depthBuffer,\n        buffer.stencilBuffer,\n        buffer.texture.type,\n        value\n      );\n      this.inputBuffer.depthTexture = this.depthTexture;\n      this.outputBuffer = this.inputBuffer.clone();\n    }\n  }\n  /**\n   * Returns the internal timer.\n   *\n   * @return {Timer} The timer.\n   */\n  getTimer() {\n    return this.timer;\n  }\n  /**\n   * Returns the renderer.\n   *\n   * @return {WebGLRenderer} The renderer.\n   */\n  getRenderer() {\n    return this.renderer;\n  }\n  /**\n   * Sets the renderer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   */\n  setRenderer(renderer) {\n    this.renderer = renderer;\n    if (renderer !== null) {\n      const size = renderer.getSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n      const alpha = renderer.getContext().getContextAttributes().alpha;\n      const frameBufferType = this.inputBuffer.texture.type;\n      if (frameBufferType === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        this.inputBuffer.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        this.outputBuffer.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        this.inputBuffer.dispose();\n        this.outputBuffer.dispose();\n      }\n      renderer.autoClear = false;\n      this.setSize(size.width, size.height);\n      for (const pass of this.passes) {\n        pass.initialize(renderer, alpha, frameBufferType);\n      }\n    }\n  }\n  /**\n   * Replaces the current renderer with the given one.\n   *\n   * The auto clear mechanism of the provided renderer will be disabled. If the new render size differs from the\n   * previous one, all passes will be updated.\n   *\n   * By default, the DOM element of the current renderer will automatically be removed from its parent node and the DOM\n   * element of the new renderer will take its place.\n   *\n   * @deprecated Use setRenderer instead.\n   * @param {WebGLRenderer} renderer - The new renderer.\n   * @param {Boolean} updateDOM - Indicates whether the old canvas should be replaced by the new one in the DOM.\n   * @return {WebGLRenderer} The old renderer.\n   */\n  replaceRenderer(renderer, updateDOM = true) {\n    const oldRenderer = this.renderer;\n    const parent = oldRenderer.domElement.parentNode;\n    this.setRenderer(renderer);\n    if (updateDOM && parent !== null) {\n      parent.removeChild(oldRenderer.domElement);\n      parent.appendChild(renderer.domElement);\n    }\n    return oldRenderer;\n  }\n  /**\n   * Creates a depth texture attachment that will be provided to all passes.\n   *\n   * Note: When a shader reads from a depth texture and writes to a render target that uses the same depth texture\n   * attachment, the depth information will be lost. This happens even if `depthWrite` is disabled.\n   *\n   * @private\n   * @return {DepthTexture} The depth texture.\n   */\n  createDepthTexture() {\n    const depthTexture = this.depthTexture = new three__WEBPACK_IMPORTED_MODULE_0__.DepthTexture();\n    this.inputBuffer.depthTexture = depthTexture;\n    this.inputBuffer.dispose();\n    if (this.inputBuffer.stencilBuffer) {\n      depthTexture.format = three__WEBPACK_IMPORTED_MODULE_0__.DepthStencilFormat;\n      depthTexture.type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt248Type;\n    } else {\n      depthTexture.type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType;\n    }\n    return depthTexture;\n  }\n  /**\n   * Deletes the current depth texture.\n   *\n   * @private\n   */\n  deleteDepthTexture() {\n    if (this.depthTexture !== null) {\n      this.depthTexture.dispose();\n      this.depthTexture = null;\n      this.inputBuffer.depthTexture = null;\n      this.inputBuffer.dispose();\n      for (const pass of this.passes) {\n        pass.setDepthTexture(null);\n      }\n    }\n  }\n  /**\n   * Creates a new render target.\n   *\n   * @deprecated Create buffers manually via WebGLRenderTarget instead.\n   * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.\n   * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.\n   * @param {Number} type - The frame buffer type.\n   * @param {Number} multisampling - The number of samples to use for antialiasing.\n   * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.\n   */\n  createBuffer(depthBuffer, stencilBuffer, type, multisampling) {\n    const renderer = this.renderer;\n    const size = renderer === null ? new three__WEBPACK_IMPORTED_MODULE_0__.Vector2() : renderer.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n    const options = {\n      minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n      magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n      stencilBuffer,\n      depthBuffer,\n      type\n    };\n    const renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(size.width, size.height, options);\n    if (multisampling > 0) {\n      renderTarget.ignoreDepthForMultisampleCopy = false;\n      renderTarget.samples = multisampling;\n    }\n    if (type === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType && renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n      renderTarget.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n    }\n    renderTarget.texture.name = \"EffectComposer.Buffer\";\n    renderTarget.texture.generateMipmaps = false;\n    return renderTarget;\n  }\n  /**\n   * Can be used to change the main scene for all registered passes and effects.\n   *\n   * @param {Scene} scene - The scene.\n   */\n  setMainScene(scene) {\n    for (const pass of this.passes) {\n      pass.mainScene = scene;\n    }\n  }\n  /**\n   * Can be used to change the main camera for all registered passes and effects.\n   *\n   * @param {Camera} camera - The camera.\n   */\n  setMainCamera(camera) {\n    for (const pass of this.passes) {\n      pass.mainCamera = camera;\n    }\n  }\n  /**\n   * Adds a pass, optionally at a specific index.\n   *\n   * @param {Pass} pass - A new pass.\n   * @param {Number} [index] - An index at which the pass should be inserted.\n   */\n  addPass(pass, index) {\n    const passes = this.passes;\n    const renderer = this.renderer;\n    const drawingBufferSize = renderer.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n    const alpha = renderer.getContext().getContextAttributes().alpha;\n    const frameBufferType = this.inputBuffer.texture.type;\n    pass.setRenderer(renderer);\n    pass.setSize(drawingBufferSize.width, drawingBufferSize.height);\n    pass.initialize(renderer, alpha, frameBufferType);\n    if (this.autoRenderToScreen) {\n      if (passes.length > 0) {\n        passes[passes.length - 1].renderToScreen = false;\n      }\n      if (pass.renderToScreen) {\n        this.autoRenderToScreen = false;\n      }\n    }\n    if (index !== void 0) {\n      passes.splice(index, 0, pass);\n    } else {\n      passes.push(pass);\n    }\n    if (this.autoRenderToScreen) {\n      passes[passes.length - 1].renderToScreen = true;\n    }\n    if (pass.needsDepthTexture || this.depthTexture !== null) {\n      if (this.depthTexture === null) {\n        const depthTexture = this.createDepthTexture();\n        for (pass of passes) {\n          pass.setDepthTexture(depthTexture);\n        }\n      } else {\n        pass.setDepthTexture(this.depthTexture);\n      }\n    }\n  }\n  /**\n   * Removes a pass.\n   *\n   * @param {Pass} pass - The pass.\n   */\n  removePass(pass) {\n    const passes = this.passes;\n    const index = passes.indexOf(pass);\n    const exists = index !== -1;\n    const removed = exists && passes.splice(index, 1).length > 0;\n    if (removed) {\n      if (this.depthTexture !== null) {\n        const reducer = (a, b) => a || b.needsDepthTexture;\n        const depthTextureRequired = passes.reduce(reducer, false);\n        if (!depthTextureRequired) {\n          if (pass.getDepthTexture() === this.depthTexture) {\n            pass.setDepthTexture(null);\n          }\n          this.deleteDepthTexture();\n        }\n      }\n      if (this.autoRenderToScreen) {\n        if (index === passes.length) {\n          pass.renderToScreen = false;\n          if (passes.length > 0) {\n            passes[passes.length - 1].renderToScreen = true;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Removes all passes.\n   */\n  removeAllPasses() {\n    const passes = this.passes;\n    this.deleteDepthTexture();\n    if (passes.length > 0) {\n      if (this.autoRenderToScreen) {\n        passes[passes.length - 1].renderToScreen = false;\n      }\n      this.passes = [];\n    }\n  }\n  /**\n   * Renders all enabled passes in the order in which they were added.\n   *\n   * @param {Number} [deltaTime] - The time since the last frame in seconds.\n   */\n  render(deltaTime) {\n    const renderer = this.renderer;\n    const copyPass = this.copyPass;\n    let inputBuffer = this.inputBuffer;\n    let outputBuffer = this.outputBuffer;\n    let stencilTest = false;\n    let context, stencil, buffer;\n    if (deltaTime === void 0) {\n      this.timer.update();\n      deltaTime = this.timer.getDelta();\n    }\n    for (const pass of this.passes) {\n      if (pass.enabled) {\n        pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);\n        if (pass.needsSwap) {\n          if (stencilTest) {\n            copyPass.renderToScreen = pass.renderToScreen;\n            context = renderer.getContext();\n            stencil = renderer.state.buffers.stencil;\n            stencil.setFunc(context.NOTEQUAL, 1, 4294967295);\n            copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);\n            stencil.setFunc(context.EQUAL, 1, 4294967295);\n          }\n          buffer = inputBuffer;\n          inputBuffer = outputBuffer;\n          outputBuffer = buffer;\n        }\n        if (pass instanceof MaskPass) {\n          stencilTest = true;\n        } else if (pass instanceof ClearMaskPass) {\n          stencilTest = false;\n        }\n      }\n    }\n  }\n  /**\n   * Sets the size of the buffers, passes and the renderer.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   * @param {Boolean} [updateStyle] - Determines whether the style of the canvas should be updated.\n   */\n  setSize(width, height, updateStyle) {\n    const renderer = this.renderer;\n    const currentSize = renderer.getSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n    if (width === void 0 || height === void 0) {\n      width = currentSize.width;\n      height = currentSize.height;\n    }\n    if (currentSize.width !== width || currentSize.height !== height) {\n      renderer.setSize(width, height, updateStyle);\n    }\n    const drawingBufferSize = renderer.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n    this.inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);\n    this.outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);\n    for (const pass of this.passes) {\n      pass.setSize(drawingBufferSize.width, drawingBufferSize.height);\n    }\n  }\n  /**\n   * Resets this composer by deleting all passes and creating new buffers.\n   */\n  reset() {\n    this.dispose();\n    this.autoRenderToScreen = true;\n  }\n  /**\n   * Disposes this composer and all passes.\n   */\n  dispose() {\n    for (const pass of this.passes) {\n      pass.dispose();\n    }\n    this.passes = [];\n    if (this.inputBuffer !== null) {\n      this.inputBuffer.dispose();\n    }\n    if (this.outputBuffer !== null) {\n      this.outputBuffer.dispose();\n    }\n    this.deleteDepthTexture();\n    this.copyPass.dispose();\n    this.timer.dispose();\n    Pass.fullscreenGeometry.dispose();\n  }\n};\n\n// src/core/EffectShaderData.js\n\n\n// src/enums/EffectAttribute.js\nvar EffectAttribute = {\n  NONE: 0,\n  DEPTH: 1,\n  CONVOLUTION: 2\n};\n\n// src/enums/EffectShaderSection.js\nvar EffectShaderSection = {\n  FRAGMENT_HEAD: \"FRAGMENT_HEAD\",\n  FRAGMENT_MAIN_UV: \"FRAGMENT_MAIN_UV\",\n  FRAGMENT_MAIN_IMAGE: \"FRAGMENT_MAIN_IMAGE\",\n  VERTEX_HEAD: \"VERTEX_HEAD\",\n  VERTEX_MAIN_SUPPORT: \"VERTEX_MAIN_SUPPORT\"\n};\n\n// src/core/EffectShaderData.js\nvar EffectShaderData = class {\n  /**\n   * Constructs new shader data.\n   */\n  constructor() {\n    this.shaderParts = /* @__PURE__ */ new Map([\n      [EffectShaderSection.FRAGMENT_HEAD, null],\n      [EffectShaderSection.FRAGMENT_MAIN_UV, null],\n      [EffectShaderSection.FRAGMENT_MAIN_IMAGE, null],\n      [EffectShaderSection.VERTEX_HEAD, null],\n      [EffectShaderSection.VERTEX_MAIN_SUPPORT, null]\n    ]);\n    this.defines = /* @__PURE__ */ new Map();\n    this.uniforms = /* @__PURE__ */ new Map();\n    this.blendModes = /* @__PURE__ */ new Map();\n    this.extensions = /* @__PURE__ */ new Set();\n    this.attributes = EffectAttribute.NONE;\n    this.varyings = /* @__PURE__ */ new Set();\n    this.uvTransformation = false;\n    this.readDepth = false;\n    this.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n  }\n};\n\n// src/core/GaussKernel.js\nfunction getCoefficients(n) {\n  let result;\n  if (n === 0) {\n    result = new Float64Array(0);\n  } else if (n === 1) {\n    result = new Float64Array([1]);\n  } else if (n > 1) {\n    let row0 = new Float64Array(n);\n    let row1 = new Float64Array(n);\n    for (let y = 1; y <= n; ++y) {\n      for (let x = 0; x < y; ++x) {\n        row1[x] = x === 0 || x === y - 1 ? 1 : row0[x - 1] + row0[x];\n      }\n      result = row1;\n      row1 = row0;\n      row0 = result;\n    }\n  }\n  return result;\n}\nvar GaussKernel = class {\n  /**\n   * Constructs a new Gauss kernel.\n   *\n   * @param {Number} kernelSize - The kernel size. Should be an odd number in the range [3, 1020].\n   * @param {Number} [edgeBias=2] - Determines how many edge coefficients should be cut off for increased accuracy.\n   */\n  constructor(kernelSize, edgeBias = 2) {\n    this.weights = null;\n    this.offsets = null;\n    this.linearWeights = null;\n    this.linearOffsets = null;\n    this.generate(kernelSize, edgeBias);\n  }\n  /**\n   * The number of steps for discrete sampling.\n   *\n   * @type {Number}\n   */\n  get steps() {\n    return this.offsets === null ? 0 : this.offsets.length;\n  }\n  /**\n   * The number of steps for linear sampling.\n   *\n   * @type {Number}\n   */\n  get linearSteps() {\n    return this.linearOffsets === null ? 0 : this.linearOffsets.length;\n  }\n  /**\n   * Generates the kernel.\n   *\n   * @private\n   * @param {Number} kernelSize - The kernel size.\n   * @param {Number} edgeBias - The amount of edge coefficients to ignore.\n   */\n  generate(kernelSize, edgeBias) {\n    if (kernelSize < 3 || kernelSize > 1020) {\n      throw new Error(\"The kernel size must be in the range [3, 1020]\");\n    }\n    const n = kernelSize + edgeBias * 2;\n    const coefficients = edgeBias > 0 ? getCoefficients(n).slice(edgeBias, -edgeBias) : getCoefficients(n);\n    const mid = Math.floor((coefficients.length - 1) / 2);\n    const sum = coefficients.reduce((a, b) => a + b, 0);\n    const weights = coefficients.slice(mid);\n    const offsets = [...Array(mid + 1).keys()];\n    const linearWeights = new Float64Array(Math.floor(offsets.length / 2));\n    const linearOffsets = new Float64Array(linearWeights.length);\n    linearWeights[0] = weights[0] / sum;\n    for (let i = 1, j = 1, l = offsets.length - 1; i < l; i += 2, ++j) {\n      const offset0 = offsets[i], offset1 = offsets[i + 1];\n      const weight0 = weights[i], weight1 = weights[i + 1];\n      const w = weight0 + weight1;\n      const o = (offset0 * weight0 + offset1 * weight1) / w;\n      linearWeights[j] = w / sum;\n      linearOffsets[j] = o;\n    }\n    for (let i = 0, l = weights.length, s = 1 / sum; i < l; ++i) {\n      weights[i] *= s;\n    }\n    const linearWeightSum = (linearWeights.reduce((a, b) => a + b, 0) - linearWeights[0] * 0.5) * 2;\n    if (linearWeightSum !== 0) {\n      for (let i = 0, l = linearWeights.length, s = 1 / linearWeightSum; i < l; ++i) {\n        linearWeights[i] *= s;\n      }\n    }\n    this.offsets = offsets;\n    this.weights = weights;\n    this.linearOffsets = linearOffsets;\n    this.linearWeights = linearWeights;\n  }\n};\n\n// src/core/ImmutableTimer.js\nvar ImmutableTimer = class {\n  /**\n   * The current delta time in seconds.\n   *\n   * @type {Number}\n   */\n  getDelta() {\n    return NaN;\n  }\n  /**\n   * The elapsed time in seconds.\n   *\n   * @type {Number}\n   */\n  getElapsed() {\n    return NaN;\n  }\n};\n\n// src/core/Initializable.js\nvar Initializable = class {\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n  }\n};\n\n// src/core/OverrideMaterialManager.js\n\nvar workaroundEnabled = false;\nvar OverrideMaterialManager = class {\n  /**\n   * Constructs a new override material manager.\n   *\n   * @param {Material} [material=null] - An override material.\n   */\n  constructor(material = null) {\n    this.originalMaterials = /* @__PURE__ */ new Map();\n    this.material = null;\n    this.materials = null;\n    this.materialsBackSide = null;\n    this.materialsDoubleSide = null;\n    this.materialsFlatShaded = null;\n    this.materialsFlatShadedBackSide = null;\n    this.materialsFlatShadedDoubleSide = null;\n    this.setMaterial(material);\n    this.meshCount = 0;\n    this.replaceMaterial = (node) => {\n      if (node.isMesh) {\n        let materials;\n        if (node.material.flatShading) {\n          switch (node.material.side) {\n            case three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide:\n              materials = this.materialsFlatShadedDoubleSide;\n              break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.BackSide:\n              materials = this.materialsFlatShadedBackSide;\n              break;\n            default:\n              materials = this.materialsFlatShaded;\n              break;\n          }\n        } else {\n          switch (node.material.side) {\n            case three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide:\n              materials = this.materialsDoubleSide;\n              break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.BackSide:\n              materials = this.materialsBackSide;\n              break;\n            default:\n              materials = this.materials;\n              break;\n          }\n        }\n        this.originalMaterials.set(node, node.material);\n        if (node.isSkinnedMesh) {\n          node.material = materials[2];\n        } else if (node.isInstancedMesh) {\n          node.material = materials[1];\n        } else {\n          node.material = materials[0];\n        }\n        ++this.meshCount;\n      }\n    };\n  }\n  /**\n   * Clones the given material.\n   *\n   * @private\n   * @param {Material} material - The material.\n   * @return {Material} The cloned material.\n   */\n  cloneMaterial(material) {\n    if (!(material instanceof three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial)) {\n      return material.clone();\n    }\n    const uniforms = material.uniforms;\n    const textureUniforms = /* @__PURE__ */ new Map();\n    for (const key in uniforms) {\n      const value = uniforms[key].value;\n      if (value.isRenderTargetTexture) {\n        uniforms[key].value = null;\n        textureUniforms.set(key, value);\n      }\n    }\n    const clone = material.clone();\n    for (const entry of textureUniforms) {\n      uniforms[entry[0]].value = entry[1];\n      clone.uniforms[entry[0]].value = entry[1];\n    }\n    return clone;\n  }\n  /**\n   * Sets the override material.\n   *\n   * @param {Material} material - The material.\n   */\n  setMaterial(material) {\n    this.disposeMaterials();\n    this.material = material;\n    if (material !== null) {\n      const materials = this.materials = [\n        this.cloneMaterial(material),\n        this.cloneMaterial(material),\n        this.cloneMaterial(material)\n      ];\n      for (const m2 of materials) {\n        m2.uniforms = Object.assign({}, material.uniforms);\n        m2.side = three__WEBPACK_IMPORTED_MODULE_0__.FrontSide;\n      }\n      materials[2].skinning = true;\n      this.materialsBackSide = materials.map((m2) => {\n        const c2 = this.cloneMaterial(m2);\n        c2.uniforms = Object.assign({}, material.uniforms);\n        c2.side = three__WEBPACK_IMPORTED_MODULE_0__.BackSide;\n        return c2;\n      });\n      this.materialsDoubleSide = materials.map((m2) => {\n        const c2 = this.cloneMaterial(m2);\n        c2.uniforms = Object.assign({}, material.uniforms);\n        c2.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        return c2;\n      });\n      this.materialsFlatShaded = materials.map((m2) => {\n        const c2 = this.cloneMaterial(m2);\n        c2.uniforms = Object.assign({}, material.uniforms);\n        c2.flatShading = true;\n        return c2;\n      });\n      this.materialsFlatShadedBackSide = materials.map((m2) => {\n        const c2 = this.cloneMaterial(m2);\n        c2.uniforms = Object.assign({}, material.uniforms);\n        c2.flatShading = true;\n        c2.side = three__WEBPACK_IMPORTED_MODULE_0__.BackSide;\n        return c2;\n      });\n      this.materialsFlatShadedDoubleSide = materials.map((m2) => {\n        const c2 = this.cloneMaterial(m2);\n        c2.uniforms = Object.assign({}, material.uniforms);\n        c2.flatShading = true;\n        c2.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        return c2;\n      });\n    }\n  }\n  /**\n   * Renders the scene with the override material.\n   *\n   * @private\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Scene} scene - A scene.\n   * @param {Camera} camera - A camera.\n   */\n  render(renderer, scene, camera) {\n    const shadowMapEnabled = renderer.shadowMap.enabled;\n    renderer.shadowMap.enabled = false;\n    if (workaroundEnabled) {\n      const originalMaterials = this.originalMaterials;\n      this.meshCount = 0;\n      scene.traverse(this.replaceMaterial);\n      renderer.render(scene, camera);\n      for (const entry of originalMaterials) {\n        entry[0].material = entry[1];\n      }\n      if (this.meshCount !== originalMaterials.size) {\n        originalMaterials.clear();\n      }\n    } else {\n      const overrideMaterial = scene.overrideMaterial;\n      scene.overrideMaterial = this.material;\n      renderer.render(scene, camera);\n      scene.overrideMaterial = overrideMaterial;\n    }\n    renderer.shadowMap.enabled = shadowMapEnabled;\n  }\n  /**\n   * Deletes cloned override materials.\n   *\n   * @private\n   */\n  disposeMaterials() {\n    if (this.material !== null) {\n      const materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);\n      for (const m2 of materials) {\n        m2.dispose();\n      }\n    }\n  }\n  /**\n   * Performs cleanup tasks.\n   */\n  dispose() {\n    this.originalMaterials.clear();\n    this.disposeMaterials();\n  }\n  /**\n   * Indicates whether the override material workaround is enabled.\n   *\n   * @type {Boolean}\n   */\n  static get workaroundEnabled() {\n    return workaroundEnabled;\n  }\n  /**\n   * Enables or disables the override material workaround globally.\n   *\n   * This only affects post processing passes and effects.\n   *\n   * @type {Boolean}\n   */\n  static set workaroundEnabled(value) {\n    workaroundEnabled = value;\n  }\n};\n\n// src/core/Resizable.js\nvar Resizable = class {\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n  }\n};\n\n// src/core/Resolution.js\n\nvar AUTO_SIZE = -1;\nvar Resolution = class extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n  /**\n   * Constructs a new resolution.\n   *\n   * TODO Remove resizable param.\n   * @param {Resizable} resizable - A resizable object.\n   * @param {Number} [width=Resolution.AUTO_SIZE] - The preferred width.\n   * @param {Number} [height=Resolution.AUTO_SIZE] - The preferred height.\n   * @param {Number} [scale=1.0] - A resolution scale.\n   */\n  constructor(resizable, width = AUTO_SIZE, height = AUTO_SIZE, scale = 1) {\n    super();\n    this.resizable = resizable;\n    this.baseSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n    this.preferredSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(width, height);\n    this.target = this.preferredSize;\n    this.s = scale;\n    this.effectiveSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.addEventListener(\"change\", () => this.updateEffectiveSize());\n    this.updateEffectiveSize();\n  }\n  /**\n   * Calculates the effective size.\n   *\n   * @private\n   */\n  updateEffectiveSize() {\n    const base = this.baseSize;\n    const preferred = this.preferredSize;\n    const effective = this.effectiveSize;\n    const scale = this.scale;\n    if (preferred.width !== AUTO_SIZE) {\n      effective.width = preferred.width;\n    } else if (preferred.height !== AUTO_SIZE) {\n      effective.width = Math.round(preferred.height * (base.width / Math.max(base.height, 1)));\n    } else {\n      effective.width = Math.round(base.width * scale);\n    }\n    if (preferred.height !== AUTO_SIZE) {\n      effective.height = preferred.height;\n    } else if (preferred.width !== AUTO_SIZE) {\n      effective.height = Math.round(preferred.width / Math.max(base.width / Math.max(base.height, 1), 1));\n    } else {\n      effective.height = Math.round(base.height * scale);\n    }\n  }\n  /**\n   * The effective width.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.\n   *\n   * @type {Number}\n   */\n  get width() {\n    return this.effectiveSize.width;\n  }\n  set width(value) {\n    this.preferredWidth = value;\n  }\n  /**\n   * The effective height.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.\n   *\n   * @type {Number}\n   */\n  get height() {\n    return this.effectiveSize.height;\n  }\n  set height(value) {\n    this.preferredHeight = value;\n  }\n  /**\n   * Returns the effective width.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.\n   *\n   * @deprecated Use width instead.\n   * @return {Number} The effective width.\n   */\n  getWidth() {\n    return this.width;\n  }\n  /**\n   * Returns the effective height.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.\n   *\n   * @deprecated Use height instead.\n   * @return {Number} The effective height.\n   */\n  getHeight() {\n    return this.height;\n  }\n  /**\n   * The resolution scale.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.s;\n  }\n  set scale(value) {\n    if (this.s !== value) {\n      this.s = value;\n      this.preferredSize.setScalar(AUTO_SIZE);\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The scale.\n   */\n  getScale() {\n    return this.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * Also sets the preferred resolution to {@link Resizer.AUTO_SIZE}.\n   *\n   * @deprecated Use scale instead.\n   * @param {Number} value - The scale.\n   */\n  setScale(value) {\n    this.scale = value;\n  }\n  /**\n   * The base width.\n   *\n   * @type {Number}\n   */\n  get baseWidth() {\n    return this.baseSize.width;\n  }\n  set baseWidth(value) {\n    if (this.baseSize.width !== value) {\n      this.baseSize.width = value;\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * Returns the base width.\n   *\n   * @deprecated Use baseWidth instead.\n   * @return {Number} The base width.\n   */\n  getBaseWidth() {\n    return this.baseWidth;\n  }\n  /**\n   * Sets the base width.\n   *\n   * @deprecated Use baseWidth instead.\n   * @param {Number} value - The width.\n   */\n  setBaseWidth(value) {\n    this.baseWidth = value;\n  }\n  /**\n   * The base height.\n   *\n   * @type {Number}\n   */\n  get baseHeight() {\n    return this.baseSize.height;\n  }\n  set baseHeight(value) {\n    if (this.baseSize.height !== value) {\n      this.baseSize.height = value;\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * Returns the base height.\n   *\n   * @deprecated Use baseHeight instead.\n   * @return {Number} The base height.\n   */\n  getBaseHeight() {\n    return this.baseHeight;\n  }\n  /**\n   * Sets the base height.\n   *\n   * @deprecated Use baseHeight instead.\n   * @param {Number} value - The height.\n   */\n  setBaseHeight(value) {\n    this.baseHeight = value;\n  }\n  /**\n   * Sets the base size.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setBaseSize(width, height) {\n    if (this.baseSize.width !== width || this.baseSize.height !== height) {\n      this.baseSize.set(width, height);\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * The preferred width.\n   *\n   * @type {Number}\n   */\n  get preferredWidth() {\n    return this.preferredSize.width;\n  }\n  set preferredWidth(value) {\n    if (this.preferredSize.width !== value) {\n      this.preferredSize.width = value;\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * Returns the preferred width.\n   *\n   * @deprecated Use preferredWidth instead.\n   * @return {Number} The preferred width.\n   */\n  getPreferredWidth() {\n    return this.preferredWidth;\n  }\n  /**\n   * Sets the preferred width.\n   *\n   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the width based on the height and aspect ratio.\n   *\n   * @deprecated Use preferredWidth instead.\n   * @param {Number} value - The width.\n   */\n  setPreferredWidth(value) {\n    this.preferredWidth = value;\n  }\n  /**\n   * The preferred height.\n   *\n   * @type {Number}\n   */\n  get preferredHeight() {\n    return this.preferredSize.height;\n  }\n  set preferredHeight(value) {\n    if (this.preferredSize.height !== value) {\n      this.preferredSize.height = value;\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * Returns the preferred height.\n   *\n   * @deprecated Use preferredHeight instead.\n   * @return {Number} The preferred height.\n   */\n  getPreferredHeight() {\n    return this.preferredHeight;\n  }\n  /**\n   * Sets the preferred height.\n   *\n   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the height based on the width and aspect ratio.\n   *\n   * @deprecated Use preferredHeight instead.\n   * @param {Number} value - The height.\n   */\n  setPreferredHeight(value) {\n    this.preferredHeight = value;\n  }\n  /**\n   * Sets the preferred size.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setPreferredSize(width, height) {\n    if (this.preferredSize.width !== width || this.preferredSize.height !== height) {\n      this.preferredSize.set(width, height);\n      this.dispatchEvent({ type: \"change\" });\n      this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n  }\n  /**\n   * Copies the given resolution.\n   *\n   * @param {Resolution} resolution - The resolution.\n   */\n  copy(resolution) {\n    this.s = resolution.scale;\n    this.baseSize.set(resolution.baseWidth, resolution.baseHeight);\n    this.preferredSize.set(resolution.preferredWidth, resolution.preferredHeight);\n    this.dispatchEvent({ type: \"change\" });\n    this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n  }\n  /**\n   * An auto sizing constant.\n   *\n   * Can be used to automatically calculate the width or height based on the original aspect ratio.\n   *\n   * @type {Number}\n   */\n  static get AUTO_SIZE() {\n    return AUTO_SIZE;\n  }\n};\n\n// src/utils/IdManager.js\nvar IdManager = class {\n  /**\n   * Constructs a new ID manager.\n   *\n   * @param initialId - The first ID.\n   */\n  constructor(initialId = 0) {\n    this.nextId = initialId;\n  }\n  /**\n   * Returns the next unique ID.\n   *\n   * @return The ID.\n   */\n  getNextId() {\n    return this.nextId++;\n  }\n  /**\n   * Resets the ID counter.\n   *\n   * @param initialId - The first ID.\n   * @return This manager.\n   */\n  reset(initialId = 0) {\n    this.nextId = initialId;\n    return this;\n  }\n};\n\n// src/core/Selection.js\nvar idManager = /* @__PURE__ */ new IdManager(2);\nvar Selection = class extends Set {\n  /**\n   * Constructs a new selection.\n   *\n   * @param {Iterable<Object3D>} [iterable] - A collection of objects that should be added to this selection.\n   * @param {Number} [layer] - A dedicated render layer for selected objects. Range is `[2, 31]`. Starts at 2 if omitted.\n   */\n  constructor(iterable, layer = idManager.getNextId()) {\n    super();\n    this.exclusive = false;\n    this._layer = layer;\n    if (this._layer < 1 || this._layer > 31) {\n      console.warn(\"Layer out of range, resetting to 2\");\n      idManager.reset(2);\n      this._layer = idManager.getNextId();\n    }\n    if (iterable !== void 0) {\n      this.set(iterable);\n    }\n  }\n  /**\n   * The render layer for selected objects.\n   *\n   * @type {Number}\n   */\n  get layer() {\n    return this._layer;\n  }\n  set layer(value) {\n    const currentLayer = this._layer;\n    for (const object of this) {\n      object.layers.disable(currentLayer);\n      object.layers.enable(value);\n    }\n    this._layer = value;\n  }\n  /**\n   * Returns the current render layer for selected objects.\n   *\n   * The default layer is 2. If this collides with your own custom layers, please change it before rendering!\n   *\n   * @deprecated Use layer instead.\n   * @return {Number} The layer.\n   */\n  getLayer() {\n    return this.layer;\n  }\n  /**\n   * Sets the render layer for selected objects.\n   *\n   * The current selection will be updated accordingly.\n   *\n   * @deprecated Use layer instead.\n   * @param {Number} value - The layer. Range is [0, 31].\n   */\n  setLayer(value) {\n    this.layer = value;\n  }\n  /**\n   * Indicates whether objects that are added to this selection will be removed from all other layers.\n   *\n   * @deprecated Use exclusive instead.\n   * @return {Number} Whether this selection is exclusive. Default is false.\n   */\n  isExclusive() {\n    return this.exclusive;\n  }\n  /**\n   * Controls whether objects that are added to this selection should be removed from all other layers.\n   *\n   * @deprecated Use exclusive instead.\n   * @param {Number} value - Whether this selection should be exclusive.\n   */\n  setExclusive(value) {\n    this.exclusive = value;\n  }\n  /**\n   * Clears this selection.\n   *\n   * @return {Selection} This selection.\n   */\n  clear() {\n    const layer = this.layer;\n    for (const object of this) {\n      object.layers.disable(layer);\n    }\n    return super.clear();\n  }\n  /**\n   * Clears this selection and adds the given objects.\n   *\n   * @param {Iterable<Object3D>} objects - The objects that should be selected.\n   * @return {Selection} This selection.\n   */\n  set(objects) {\n    this.clear();\n    for (const object of objects) {\n      this.add(object);\n    }\n    return this;\n  }\n  /**\n   * An alias for {@link has}.\n   *\n   * @param {Object3D} object - An object.\n   * @return {Number} Returns 0 if the given object is currently selected, or -1 otherwise.\n   * @deprecated Added for backward-compatibility.\n   */\n  indexOf(object) {\n    return this.has(object) ? 0 : -1;\n  }\n  /**\n   * Adds an object to this selection.\n   *\n   * If {@link exclusive} is set to `true`, the object will also be removed from all other layers.\n   *\n   * @param {Object3D} object - The object that should be selected.\n   * @return {Selection} This selection.\n   */\n  add(object) {\n    if (this.exclusive) {\n      object.layers.set(this.layer);\n    } else {\n      object.layers.enable(this.layer);\n    }\n    return super.add(object);\n  }\n  /**\n   * Removes an object from this selection.\n   *\n   * @param {Object3D} object - The object that should be deselected.\n   * @return {Boolean} Returns true if an object has successfully been removed from this selection; otherwise false.\n   */\n  delete(object) {\n    if (this.has(object)) {\n      object.layers.disable(this.layer);\n    }\n    return super.delete(object);\n  }\n  /**\n   * Removes an existing object from the selection. If the object doesn't exist it's added instead.\n   *\n   * @param {Object3D} object - The object.\n   * @return {Boolean} Returns true if the object is added, false otherwise.\n   */\n  toggle(object) {\n    let result;\n    if (this.has(object)) {\n      this.delete(object);\n      result = false;\n    } else {\n      this.add(object);\n      result = true;\n    }\n    return result;\n  }\n  /**\n   * Sets the visibility of all selected objects.\n   *\n   * This method enables or disables render layer 0 of all selected objects.\n   *\n   * @param {Boolean} visible - Whether the selected objects should be visible.\n   * @return {Selection} This selection.\n   */\n  setVisible(visible) {\n    for (const object of this) {\n      if (visible) {\n        object.layers.enable(0);\n      } else {\n        object.layers.disable(0);\n      }\n    }\n    return this;\n  }\n};\n\n// src/effects/blending/BlendMode.js\n\n\n// src/enums/BlendFunction.js\nvar BlendFunction = {\n  SKIP: 9,\n  SET: 30,\n  ADD: 0,\n  ALPHA: 1,\n  AVERAGE: 2,\n  COLOR: 3,\n  COLOR_BURN: 4,\n  COLOR_DODGE: 5,\n  DARKEN: 6,\n  DIFFERENCE: 7,\n  DIVIDE: 8,\n  DST: 9,\n  EXCLUSION: 10,\n  HARD_LIGHT: 11,\n  HARD_MIX: 12,\n  HUE: 13,\n  INVERT: 14,\n  INVERT_RGB: 15,\n  LIGHTEN: 16,\n  LINEAR_BURN: 17,\n  LINEAR_DODGE: 18,\n  LINEAR_LIGHT: 19,\n  LUMINOSITY: 20,\n  MULTIPLY: 21,\n  NEGATION: 22,\n  NORMAL: 23,\n  OVERLAY: 24,\n  PIN_LIGHT: 25,\n  REFLECT: 26,\n  SATURATION: 27,\n  SCREEN: 28,\n  SOFT_LIGHT: 29,\n  SRC: 30,\n  SUBTRACT: 31,\n  VIVID_LIGHT: 32\n};\n\n// src/effects/blending/glsl/add.frag\nvar add_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),opacity);}`;\n\n// src/effects/blending/glsl/alpha.frag\nvar alpha_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,y.a*opacity);}`;\n\n// src/effects/blending/glsl/average.frag\nvar average_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb)*0.5,y.a),opacity);}`;\n\n// src/effects/blending/glsl/color.frag\nvar color_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.xy,xHSL.z));return mix(x,vec4(z,y.a),opacity);}`;\n\n// src/effects/blending/glsl/color-burn.frag\nvar color_burn_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/b)),vec3(1.0),step(1.0,a));return mix(x,vec4(z,y.a),opacity);}`;\n\n// src/effects/blending/glsl/color-dodge.frag\nvar color_dodge_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(x,vec4(z,y.a),opacity);}`;\n\n// src/effects/blending/glsl/darken.frag\nvar darken_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb,y.rgb),y.a),opacity);}`;\n\n// src/effects/blending/glsl/difference.frag\nvar difference_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(abs(x.rgb-y.rgb),y.a),opacity);}`;\n\n// src/effects/blending/glsl/divide.frag\nvar divide_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb/max(y.rgb,1e-12),y.a),opacity);}`;\n\n// src/effects/blending/glsl/exclusion.frag\nvar exclusion_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb-2.0*x.rgb*y.rgb),y.a),opacity);}`;\n\n// src/effects/blending/glsl/hard-light.frag\nvar hard_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=min(x.rgb,1.0);vec3 b=min(y.rgb,1.0);vec3 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(x,vec4(z,y.a),opacity);}`;\n\n// src/effects/blending/glsl/hard-mix.frag\nvar hard_mix_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(step(1.0,x.rgb+y.rgb),y.a),opacity);}`;\n\n// src/effects/blending/glsl/hue.frag\nvar hue_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.x,xHSL.yz));return mix(x,vec4(z,y.a),opacity);}`;\n\n// src/effects/blending/glsl/invert.frag\nvar invert_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-y.rgb,y.a),opacity);}`;\n\n// src/effects/blending/glsl/invert-rgb.frag\nvar invert_rgb_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(y.rgb*(1.0-x.rgb),y.a),opacity);}`;\n\n// src/effects/blending/glsl/lighten.frag\nvar lighten_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb,y.rgb),y.a),opacity);}`;\n\n// src/effects/blending/glsl/linear-burn.frag\nvar linear_burn_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}`;\n\n// src/effects/blending/glsl/linear-dodge.frag\nvar linear_dodge_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb+y.rgb,1.0),y.a),opacity);}`;\n\n// src/effects/blending/glsl/linear-light.frag\nvar linear_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(2.0*y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}`;\n\n// src/effects/blending/glsl/luminosity.frag\nvar luminosity_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.xy,yHSL.z));return mix(x,vec4(z,y.a),opacity);}`;\n\n// src/effects/blending/glsl/multiply.frag\nvar multiply_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb*y.rgb,y.a),opacity);}`;\n\n// src/effects/blending/glsl/negation.frag\nvar negation_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-abs(1.0-x.rgb-y.rgb),y.a),opacity);}`;\n\n// src/effects/blending/glsl/normal.frag\nvar normal_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}`;\n\n// src/effects/blending/glsl/overlay.frag\nvar overlay_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(2.0*y.rgb*x.rgb,1.0-2.0*(1.0-y.rgb)*(1.0-x.rgb),step(0.5,x.rgb));return mix(x,vec4(z,y.a),opacity);}`;\n\n// src/effects/blending/glsl/pin-light.frag\nvar pin_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 y2=2.0*y.rgb;vec3 z=mix(mix(y2,x.rgb,step(0.5*x.rgb,y.rgb)),max(y2-1.0,vec3(0.0)),step(x.rgb,y2-1.0));return mix(x,vec4(z,y.a),opacity);}`;\n\n// src/effects/blending/glsl/reflect.frag\nvar reflect_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(min(x.rgb*x.rgb/max(1.0-y.rgb,1e-12),1.0),y.rgb,step(1.0,y.rgb));return mix(x,vec4(z,y.a),opacity);}`;\n\n// src/effects/blending/glsl/saturation.frag\nvar saturation_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.x,yHSL.y,xHSL.z));return mix(x,vec4(z,y.a),opacity);}`;\n\n// src/effects/blending/glsl/screen.frag\nvar screen_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb-min(x.rgb*y.rgb,1.0),y.a),opacity);}`;\n\n// src/effects/blending/glsl/soft-light.frag\nvar soft_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb;vec3 b=y.rgb;vec3 y2=2.0*b;vec3 w=step(0.5,b);vec3 c=a-(1.0-y2)*a*(1.0-a);vec3 d=mix(a+(y2-1.0)*(sqrt(a)-a),a+(y2-1.0)*a*((16.0*a-12.0)*a+3.0),w*(1.0-step(0.25,a)));vec3 z=mix(c,d,w);return mix(x,vec4(z,y.a),opacity);}`;\n\n// src/effects/blending/glsl/src.frag\nvar src_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}`;\n\n// src/effects/blending/glsl/subtract.frag\nvar subtract_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb+y.rgb-1.0,0.0),y.a),opacity);}`;\n\n// src/effects/blending/glsl/vivid-light.frag\nvar vivid_light_default = `vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(max(1.0-min((1.0-x.rgb)/(2.0*y.rgb),1.0),0.0),min(x.rgb/(2.0*(1.0-y.rgb)),1.0),step(0.5,y.rgb));return mix(x,vec4(z,y.a),opacity);}`;\n\n// src/effects/blending/BlendMode.js\nvar blendFunctions = /* @__PURE__ */ new Map([\n  [BlendFunction.ADD, add_default],\n  [BlendFunction.ALPHA, alpha_default],\n  [BlendFunction.AVERAGE, average_default],\n  [BlendFunction.COLOR, color_default],\n  [BlendFunction.COLOR_BURN, color_burn_default],\n  [BlendFunction.COLOR_DODGE, color_dodge_default],\n  [BlendFunction.DARKEN, darken_default],\n  [BlendFunction.DIFFERENCE, difference_default],\n  [BlendFunction.DIVIDE, divide_default],\n  [BlendFunction.DST, null],\n  [BlendFunction.EXCLUSION, exclusion_default],\n  [BlendFunction.HARD_LIGHT, hard_light_default],\n  [BlendFunction.HARD_MIX, hard_mix_default],\n  [BlendFunction.HUE, hue_default],\n  [BlendFunction.INVERT, invert_default],\n  [BlendFunction.INVERT_RGB, invert_rgb_default],\n  [BlendFunction.LIGHTEN, lighten_default],\n  [BlendFunction.LINEAR_BURN, linear_burn_default],\n  [BlendFunction.LINEAR_DODGE, linear_dodge_default],\n  [BlendFunction.LINEAR_LIGHT, linear_light_default],\n  [BlendFunction.LUMINOSITY, luminosity_default],\n  [BlendFunction.MULTIPLY, multiply_default],\n  [BlendFunction.NEGATION, negation_default],\n  [BlendFunction.NORMAL, normal_default],\n  [BlendFunction.OVERLAY, overlay_default],\n  [BlendFunction.PIN_LIGHT, pin_light_default],\n  [BlendFunction.REFLECT, reflect_default],\n  [BlendFunction.SATURATION, saturation_default],\n  [BlendFunction.SCREEN, screen_default],\n  [BlendFunction.SOFT_LIGHT, soft_light_default],\n  [BlendFunction.SRC, src_default],\n  [BlendFunction.SUBTRACT, subtract_default],\n  [BlendFunction.VIVID_LIGHT, vivid_light_default]\n]);\nvar BlendMode = class extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n  /**\n   * Constructs a new blend mode.\n   *\n   * @param {BlendFunction} blendFunction - The blend function.\n   * @param {Number} opacity - The opacity of the color that will be blended with the base color.\n   */\n  constructor(blendFunction, opacity = 1) {\n    super();\n    this._blendFunction = blendFunction;\n    this.opacity = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(opacity);\n  }\n  /**\n   * Returns the opacity.\n   *\n   * @return {Number} The opacity.\n   */\n  getOpacity() {\n    return this.opacity.value;\n  }\n  /**\n   * Sets the opacity.\n   *\n   * @param {Number} value - The opacity.\n   */\n  setOpacity(value) {\n    this.opacity.value = value;\n  }\n  /**\n   * The blend function.\n   *\n   * @type {BlendFunction}\n   */\n  get blendFunction() {\n    return this._blendFunction;\n  }\n  set blendFunction(value) {\n    this._blendFunction = value;\n    this.dispatchEvent({ type: \"change\" });\n  }\n  /**\n   * Returns the blend function.\n   *\n   * @deprecated Use blendFunction instead.\n   * @return {BlendFunction} The blend function.\n   */\n  getBlendFunction() {\n    return this.blendFunction;\n  }\n  /**\n   * Sets the blend function.\n   *\n   * @deprecated Use blendFunction instead.\n   * @param {BlendFunction} value - The blend function.\n   */\n  setBlendFunction(value) {\n    this.blendFunction = value;\n  }\n  /**\n   * Returns the blend function shader code.\n   *\n   * @return {String} The blend function shader code.\n   */\n  getShaderCode() {\n    return blendFunctions.get(this.blendFunction);\n  }\n};\n\n// src/effects/ASCIIEffect.js\n\n\n// src/textures/ASCIITexture.js\n\nvar ASCIITexture = class extends three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture {\n  /**\n   * Constructs a new ASCII texture.\n   *\n   * @param {Object} [options] - The options.\n   * @param {String} [options.characters] - The character set to render. Defaults to a common ASCII art charset.\n   * @param {String} [options.font=\"Arial\"] - The font.\n   * @param {Number} [options.fontSize=54] - The font size in pixels.\n   * @param {Number} [options.size=1024] - The texture size.\n   * @param {Number} [options.cellCount=16] - The cell count along each side of the texture.\n   */\n  constructor({\n    characters = \" .:,'-^=*+?!|0#X%WM@\",\n    font = \"Arial\",\n    fontSize = 54,\n    size = 1024,\n    cellCount = 16\n  } = {}) {\n    super(\n      document.createElement(\"canvas\"),\n      void 0,\n      three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping,\n      three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n    );\n    const canvas = this.image;\n    canvas.width = canvas.height = size;\n    const context = canvas.getContext(\"2d\");\n    const cellSize = size / cellCount;\n    context.font = `${fontSize}px ${font}`;\n    context.textAlign = \"center\";\n    context.textBaseline = \"middle\";\n    context.fillStyle = \"#ffffff\";\n    for (let i = 0, l = characters.length; i < l; ++i) {\n      const char = characters[i];\n      const x = i % cellCount;\n      const y = Math.floor(i / cellCount);\n      context.fillText(char, x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);\n    }\n    this.characterCount = characters.length;\n    this.cellCount = cellCount;\n  }\n};\n\n// src/effects/Effect.js\n\nvar Effect = class extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n  /**\n   * Constructs a new effect.\n   *\n   * @param {String} name - The name of this effect. Doesn't have to be unique.\n   * @param {String} fragmentShader - The fragment shader. This shader is required.\n   * @param {Object} [options] - Additional options.\n   * @param {EffectAttribute} [options.attributes=EffectAttribute.NONE] - The effect attributes that determine the execution priority and resource requirements.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.\n   * @param {Map<String, String>} [options.defines] - Custom preprocessor macro definitions. Keys are names and values are code.\n   * @param {Map<String, Uniform>} [options.uniforms] - Custom shader uniforms. Keys are names and values are uniforms.\n   * @param {Set<WebGLExtension>} [options.extensions] - WebGL extensions.\n   * @param {String} [options.vertexShader=null] - The vertex shader. Most effects don't need one.\n   */\n  constructor(name, fragmentShader, {\n    attributes = EffectAttribute.NONE,\n    blendFunction = BlendFunction.NORMAL,\n    defines = /* @__PURE__ */ new Map(),\n    uniforms = /* @__PURE__ */ new Map(),\n    extensions = null,\n    vertexShader = null\n  } = {}) {\n    super();\n    this.name = name;\n    this.renderer = null;\n    this.attributes = attributes;\n    this.fragmentShader = fragmentShader;\n    this.vertexShader = vertexShader;\n    this.defines = defines;\n    this.uniforms = uniforms;\n    this.extensions = extensions;\n    this.blendMode = new BlendMode(blendFunction);\n    this.blendMode.addEventListener(\"change\", (event) => this.setChanged());\n    this._inputColorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n    this._outputColorSpace = three__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace;\n  }\n  /**\n   * The input color space.\n   *\n   * @type {ColorSpace}\n   * @experimental\n   */\n  get inputColorSpace() {\n    return this._inputColorSpace;\n  }\n  /**\n   * @type {ColorSpace}\n   * @protected\n   * @experimental\n   */\n  set inputColorSpace(value) {\n    this._inputColorSpace = value;\n    this.setChanged();\n  }\n  /**\n   * The output color space.\n   *\n   * Should only be changed if this effect converts the input colors to a different color space.\n   *\n   * @type {ColorSpace}\n   * @experimental\n   */\n  get outputColorSpace() {\n    return this._outputColorSpace;\n  }\n  /**\n   * @type {ColorSpace}\n   * @protected\n   * @experimental\n   */\n  set outputColorSpace(value) {\n    this._outputColorSpace = value;\n    this.setChanged();\n  }\n  /**\n   * Sets the main scene.\n   *\n   * @type {Scene}\n   */\n  set mainScene(value) {\n  }\n  /**\n   * Sets the main camera.\n   *\n   * @type {Camera}\n   */\n  set mainCamera(value) {\n  }\n  /**\n   * Returns the name of this effect.\n   *\n   * @deprecated Use name instead.\n   * @return {String} The name.\n   */\n  getName() {\n    return this.name;\n  }\n  /**\n   * Sets the renderer.\n   *\n   * @deprecated\n   * @param {WebGLRenderer} renderer - The renderer.\n   */\n  setRenderer(renderer) {\n    this.renderer = renderer;\n  }\n  /**\n   * Returns the preprocessor macro definitions.\n   *\n   * @deprecated Use defines instead.\n   * @return {Map<String, String>} The extensions.\n   */\n  getDefines() {\n    return this.defines;\n  }\n  /**\n   * Returns the uniforms of this effect.\n   *\n   * @deprecated Use uniforms instead.\n   * @return {Map<String, Uniform>} The extensions.\n   */\n  getUniforms() {\n    return this.uniforms;\n  }\n  /**\n   * Returns the WebGL extensions that are required by this effect.\n   *\n   * @deprecated Use extensions instead.\n   * @return {Set<WebGLExtension>} The extensions.\n   */\n  getExtensions() {\n    return this.extensions;\n  }\n  /**\n   * Returns the blend mode.\n   *\n   * The result of this effect will be blended with the result of the previous effect using this blend mode.\n   *\n   * @deprecated Use blendMode instead.\n   * @return {BlendMode} The blend mode.\n   */\n  getBlendMode() {\n    return this.blendMode;\n  }\n  /**\n   * Returns the effect attributes.\n   *\n   * @return {EffectAttribute} The attributes.\n   */\n  getAttributes() {\n    return this.attributes;\n  }\n  /**\n   * Sets the effect attributes.\n   *\n   * Effects that have the same attributes will be executed in the order in which they were registered. Some attributes\n   * imply a higher priority.\n   *\n   * @protected\n   * @param {EffectAttribute} attributes - The attributes.\n   */\n  setAttributes(attributes) {\n    this.attributes = attributes;\n    this.setChanged();\n  }\n  /**\n   * Returns the fragment shader.\n   *\n   * @return {String} The fragment shader.\n   */\n  getFragmentShader() {\n    return this.fragmentShader;\n  }\n  /**\n   * Sets the fragment shader.\n   *\n   * @protected\n   * @param {String} fragmentShader - The fragment shader.\n   */\n  setFragmentShader(fragmentShader) {\n    this.fragmentShader = fragmentShader;\n    this.setChanged();\n  }\n  /**\n   * Returns the vertex shader.\n   *\n   * @return {String} The vertex shader.\n   */\n  getVertexShader() {\n    return this.vertexShader;\n  }\n  /**\n   * Sets the vertex shader.\n   *\n   * @protected\n   * @param {String} vertexShader - The vertex shader.\n   */\n  setVertexShader(vertexShader) {\n    this.vertexShader = vertexShader;\n    this.setChanged();\n  }\n  /**\n   * Informs the associated {@link EffectPass} that this effect requires a shader recompilation.\n   *\n   * Should be called after changing macros or extensions and after adding/removing uniforms.\n   *\n   * @protected\n   */\n  setChanged() {\n    this.dispatchEvent({ type: \"change\" });\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * You may override this method if your effect requires direct access to the depth texture that is bound to the\n   * associated {@link EffectPass}.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n  }\n  /**\n   * Updates this effect by performing supporting operations.\n   *\n   * This method is called by the {@link EffectPass} right before the main fullscreen render operation, even if the\n   * blend function is set to `SKIP`.\n   *\n   * You may override this method if you need to update custom uniforms or render additional off-screen textures.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n  }\n  /**\n   * Updates the size of this effect.\n   *\n   * You may override this method if you want to be informed about the size of the backbuffer/canvas.\n   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * This method is called when the associated {@link EffectPass} is added to an {@link EffectComposer}.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   * @example if(!alpha && frameBufferType === UnsignedByteType) { this.myRenderTarget.texture.format = RGBFormat; }\n   */\n  initialize(renderer, alpha, frameBufferType) {\n  }\n  /**\n   * Performs a shallow search for properties that define a dispose method and deletes them.\n   *\n   * The {@link EffectComposer} calls this method when it is being destroyed.\n   */\n  dispose() {\n    for (const key of Object.keys(this)) {\n      const property = this[key];\n      const isDisposable = property instanceof three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture || property instanceof Pass;\n      if (isDisposable) {\n        this[key].dispose();\n      }\n    }\n  }\n};\n\n// src/effects/glsl/ascii.frag\nvar ascii_default = `uniform sampler2D asciiTexture;uniform vec4 cellCount;\n#ifdef USE_COLOR\nuniform vec3 color;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 pixelizedUv=cellCount.zw*(0.5+floor(uv*cellCount.xy));vec4 texel=texture(inputBuffer,pixelizedUv);float lum=min(luminance(texel.rgb),1.0);\n#ifdef INVERTED\nlum=1.0-lum;\n#endif\nfloat characterIndex=floor(CHAR_COUNT_MINUS_ONE*lum);vec2 characterPosition=vec2(mod(characterIndex,TEX_CELL_COUNT),floor(characterIndex*INV_TEX_CELL_COUNT));vec2 offset=vec2(characterPosition.x,-characterPosition.y)*INV_TEX_CELL_COUNT;vec2 characterUv=mod(uv*(cellCount.xy*INV_TEX_CELL_COUNT),INV_TEX_CELL_COUNT);characterUv=characterUv-vec2(0.0,INV_TEX_CELL_COUNT)+offset;float asciiCharacter=texture(asciiTexture,characterUv).r;\n#ifdef USE_COLOR\noutputColor=vec4(color*asciiCharacter,inputColor.a);\n#else\noutputColor=vec4(texel.rgb*asciiCharacter,inputColor.a);\n#endif\n}`;\n\n// src/effects/ASCIIEffect.js\nvar ASCIIEffect = class extends Effect {\n  /**\n   * Constructs a new ASCII effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {ASCIITexture} [options.asciiTexture] - An ASCII character lookup texture.\n   * @param {Number} [options.cellSize=16] - The cell size. It's recommended to use even numbers.\n   * @param {Number} [options.color=null] - A color to use instead of the scene colors.\n   * @param {Boolean} [options.inverted=false] - Inverts the effect.\n   */\n  constructor({\n    asciiTexture = new ASCIITexture(),\n    cellSize = 16,\n    color: color2 = null,\n    inverted = false\n  } = {}) {\n    super(\"ASCIIEffect\", ascii_default, {\n      uniforms: /* @__PURE__ */ new Map([\n        [\"asciiTexture\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"cellCount\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4())],\n        [\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Color())]\n      ])\n    });\n    this._cellSize = -1;\n    this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.asciiTexture = asciiTexture;\n    this.cellSize = cellSize;\n    this.color = color2;\n    this.inverted = inverted;\n  }\n  /**\n   * The current ASCII lookup texture.\n   *\n   * @type {ASCIITexture}\n   */\n  get asciiTexture() {\n    return this.uniforms.get(\"asciiTexture\").value;\n  }\n  set asciiTexture(value) {\n    const currentTexture = this.uniforms.get(\"asciiTexture\").value;\n    this.uniforms.get(\"asciiTexture\").value = value;\n    if (currentTexture !== null && currentTexture !== value) {\n      currentTexture.dispose();\n    }\n    if (value !== null) {\n      const cellCount = value.cellCount;\n      this.defines.set(\"CHAR_COUNT_MINUS_ONE\", (value.characterCount - 1).toFixed(1));\n      this.defines.set(\"TEX_CELL_COUNT\", cellCount.toFixed(1));\n      this.defines.set(\"INV_TEX_CELL_COUNT\", (1 / cellCount).toFixed(9));\n      this.setChanged();\n    }\n  }\n  /**\n   * A color that overrides the scene colors.\n   *\n   * @type {Color | String | Number | null}\n   */\n  get color() {\n    return this.uniforms.get(\"color\").value;\n  }\n  set color(value) {\n    if (value !== null) {\n      this.uniforms.get(\"color\").value.set(value);\n    }\n    if (this.defines.has(\"USE_COLOR\") && value === null) {\n      this.defines.delete(\"USE_COLOR\");\n      this.setChanged();\n    } else if (!this.defines.has(\"USE_COLOR\") && value !== null) {\n      this.defines.set(\"USE_COLOR\", \"1\");\n      this.setChanged();\n    }\n  }\n  /**\n   * Controls whether the effect should be inverted.\n   *\n   * @type {Boolean}\n   */\n  get inverted() {\n    return this.defines.has(\"INVERTED\");\n  }\n  set inverted(value) {\n    if (this.inverted !== value) {\n      if (value) {\n        this.defines.set(\"INVERTED\", \"1\");\n      } else {\n        this.defines.delete(\"INVERTED\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * The cell size.\n   *\n   * @type {Number}\n   */\n  get cellSize() {\n    return this._cellSize;\n  }\n  set cellSize(value) {\n    if (this._cellSize !== value) {\n      this._cellSize = value;\n      this.updateCellCount();\n    }\n  }\n  /**\n   * Updates the cell count uniform.\n   *\n   * @private\n   */\n  updateCellCount() {\n    const cellCount = this.uniforms.get(\"cellCount\").value;\n    const resolution = this.resolution;\n    cellCount.x = resolution.width / this.cellSize;\n    cellCount.y = resolution.height / this.cellSize;\n    cellCount.z = 1 / cellCount.x;\n    cellCount.w = 1 / cellCount.y;\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.resolution.set(width, height);\n    this.updateCellCount();\n  }\n  /**\n   * Deletes internal render targets and textures.\n   */\n  dispose() {\n    if (this.asciiTexture !== null) {\n      this.asciiTexture.dispose();\n    }\n    super.dispose();\n  }\n};\n\n// src/effects/BloomEffect.js\n\n\n// src/enums/KernelSize.js\nvar KernelSize = {\n  VERY_SMALL: 0,\n  SMALL: 1,\n  MEDIUM: 2,\n  LARGE: 3,\n  VERY_LARGE: 4,\n  HUGE: 5\n};\n\n// src/passes/KawaseBlurPass.js\n\n\n// src/materials/KawaseBlurMaterial.js\n\n\n// src/materials/glsl/convolution.kawase.frag\nvar convolution_kawase_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}`;\n\n// src/materials/glsl/convolution.kawase.vert\nvar convolution_kawase_default2 = `uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/KawaseBlurMaterial.js\nvar kernelPresets = [\n  new Float32Array([0, 0]),\n  new Float32Array([0, 1, 1]),\n  new Float32Array([0, 1, 1, 2]),\n  new Float32Array([0, 1, 2, 2, 3]),\n  new Float32Array([0, 1, 2, 3, 4, 4, 5]),\n  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])\n];\nvar KawaseBlurMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new convolution material.\n   *\n   * TODO Remove texelSize param.\n   * @param {Vector4} [texelSize] - Deprecated.\n   */\n  constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4()) {\n    super({\n      name: \"KawaseBlurMaterial\",\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4()),\n        scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        kernel: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_kawase_default,\n      vertexShader: convolution_kawase_default2\n    });\n    this.setTexelSize(texelSize.x, texelSize.y);\n    this.kernelSize = KernelSize.MEDIUM;\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.inputBuffer = value;\n  }\n  /**\n   * The kernel sequence for the current kernel size.\n   *\n   * @type {Float32Array}\n   */\n  get kernelSequence() {\n    return kernelPresets[this.kernelSize];\n  }\n  /**\n   * The blur scale.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.uniforms.scale.value;\n  }\n  set scale(value) {\n    this.uniforms.scale.value = value;\n  }\n  /**\n   * Returns the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The scale.\n   */\n  getScale() {\n    return this.uniforms.scale.value;\n  }\n  /**\n   * Sets the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} value - The scale.\n   */\n  setScale(value) {\n    this.uniforms.scale.value = value;\n  }\n  /**\n   * Returns the kernel.\n   *\n   * @return {Float32Array} The kernel.\n   * @deprecated Implementation detail, removed with no replacement.\n   */\n  getKernel() {\n    return null;\n  }\n  /**\n   * The current kernel.\n   *\n   * @type {Number}\n   */\n  get kernel() {\n    return this.uniforms.kernel.value;\n  }\n  set kernel(value) {\n    this.uniforms.kernel.value = value;\n  }\n  /**\n   * Sets the current kernel.\n   *\n   * @deprecated Use kernel instead.\n   * @param {Number} value - The kernel.\n   */\n  setKernel(value) {\n    this.kernel = value;\n  }\n  /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */\n  setTexelSize(x, y) {\n    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const x = 1 / width, y = 1 / height;\n    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);\n  }\n};\n\n// src/passes/KawaseBlurPass.js\nvar KawaseBlurPass = class extends Pass {\n  /**\n   * Constructs a new Kawase blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor({\n    kernelSize = KernelSize.MEDIUM,\n    resolutionScale = 0.5,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"KawaseBlurPass\");\n    this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetA.texture.name = \"Blur.Target.A\";\n    this.renderTargetB = this.renderTargetA.clone();\n    this.renderTargetB.texture.name = \"Blur.Target.B\";\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this._blurMaterial = new KawaseBlurMaterial();\n    this._blurMaterial.kernelSize = kernelSize;\n    this.copyMaterial = new CopyMaterial();\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * The blur material.\n   *\n   * @type {KawaseBlurMaterial}\n   */\n  get blurMaterial() {\n    return this._blurMaterial;\n  }\n  /**\n   * The blur material.\n   *\n   * @type {KawaseBlurMaterial}\n   * @protected\n   */\n  set blurMaterial(value) {\n    this._blurMaterial = value;\n  }\n  /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use copyMaterial.dithering instead.\n   */\n  get dithering() {\n    return this.copyMaterial.dithering;\n  }\n  set dithering(value) {\n    this.copyMaterial.dithering = value;\n  }\n  /**\n   * The kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated Use blurMaterial.kernelSize instead.\n   */\n  get kernelSize() {\n    return this.blurMaterial.kernelSize;\n  }\n  set kernelSize(value) {\n    this.blurMaterial.kernelSize = value;\n  }\n  /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.width instead.\n   */\n  get width() {\n    return this.resolution.width;\n  }\n  /**\n   * Sets the render width.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.preferredWidth instead.\n   */\n  set width(value) {\n    this.resolution.preferredWidth = value;\n  }\n  /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.height instead.\n   */\n  get height() {\n    return this.resolution.height;\n  }\n  /**\n   * Sets the render height.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.preferredHeight instead.\n   */\n  set height(value) {\n    this.resolution.preferredHeight = value;\n  }\n  /**\n   * The current blur scale.\n   *\n   * @type {Number}\n   * @deprecated Use blurMaterial.scale instead.\n   */\n  get scale() {\n    return this.blurMaterial.scale;\n  }\n  set scale(value) {\n    this.blurMaterial.scale = value;\n  }\n  /**\n   * Returns the current blur scale.\n   *\n   * @deprecated Use blurMaterial.scale instead.\n   * @return {Number} The scale.\n   */\n  getScale() {\n    return this.blurMaterial.scale;\n  }\n  /**\n   * Sets the blur scale.\n   *\n   * @deprecated Use blurMaterial.scale instead.\n   * @param {Number} value - The scale.\n   */\n  setScale(value) {\n    this.blurMaterial.scale = value;\n  }\n  /**\n   * Returns the kernel size.\n   *\n   * @deprecated Use blurMaterial.kernelSize instead.\n   * @return {KernelSize} The kernel size.\n   */\n  getKernelSize() {\n    return this.kernelSize;\n  }\n  /**\n   * Sets the kernel size.\n   *\n   * Larger kernels require more processing power but scale well with larger render resolutions.\n   *\n   * @deprecated Use blurMaterial.kernelSize instead.\n   * @param {KernelSize} value - The kernel size.\n   */\n  setKernelSize(value) {\n    this.kernelSize = value;\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  getResolutionScale() {\n    return this.resolution.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  setResolutionScale(scale) {\n    this.resolution.scale = scale;\n  }\n  /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const renderTargetA = this.renderTargetA;\n    const renderTargetB = this.renderTargetB;\n    const material = this.blurMaterial;\n    const kernelSequence = material.kernelSequence;\n    let previousBuffer = inputBuffer;\n    this.fullscreenMaterial = material;\n    for (let i = 0, l = kernelSequence.length; i < l; ++i) {\n      const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;\n      material.kernel = kernelSequence[i];\n      material.inputBuffer = previousBuffer.texture;\n      renderer.setRenderTarget(buffer);\n      renderer.render(scene, camera);\n      previousBuffer = buffer;\n    }\n    this.fullscreenMaterial = this.copyMaterial;\n    this.copyMaterial.inputBuffer = previousBuffer.texture;\n    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n    renderer.render(scene, camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.renderTargetA.setSize(w, h);\n    this.renderTargetB.setSize(w, h);\n    this.blurMaterial.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (frameBufferType !== void 0) {\n      this.renderTargetA.texture.type = frameBufferType;\n      this.renderTargetB.texture.type = frameBufferType;\n      if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n        this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n      } else if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        this.renderTargetA.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        this.renderTargetB.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n      }\n    }\n  }\n  /**\n   * An auto sizing flag.\n   *\n   * @type {Number}\n   * @deprecated Use {@link Resolution.AUTO_SIZE} instead.\n   */\n  static get AUTO_SIZE() {\n    return Resolution.AUTO_SIZE;\n  }\n};\n\n// src/passes/LuminancePass.js\n\n\n// src/materials/LuminanceMaterial.js\n\n\n// src/materials/glsl/luminance.frag\nvar luminance_default = `#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}`;\n\n// src/materials/LuminanceMaterial.js\nvar LuminanceMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new luminance material.\n   *\n   * @param {Boolean} [colorOutput=false] - Defines whether the shader should output colors scaled with their luminance value.\n   * @param {Vector2} [luminanceRange] - If provided, the shader will mask out texels that aren't in the specified luminance range.\n   */\n  constructor(colorOutput = false, luminanceRange = null) {\n    super({\n      name: \"LuminanceMaterial\",\n      defines: {\n        THREE_REVISION: three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        threshold: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n        smoothing: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        range: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: luminance_default,\n      vertexShader: common_default\n    });\n    this.colorOutput = colorOutput;\n    this.luminanceRange = luminanceRange;\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The luminance threshold.\n   *\n   * @type {Number}\n   */\n  get threshold() {\n    return this.uniforms.threshold.value;\n  }\n  set threshold(value) {\n    if (this.smoothing > 0 || value > 0) {\n      this.defines.THRESHOLD = \"1\";\n    } else {\n      delete this.defines.THRESHOLD;\n    }\n    this.uniforms.threshold.value = value;\n  }\n  /**\n   * Returns the luminance threshold.\n   *\n   * @deprecated Use threshold instead.\n   * @return {Number} The threshold.\n   */\n  getThreshold() {\n    return this.threshold;\n  }\n  /**\n   * Sets the luminance threshold.\n   *\n   * @deprecated Use threshold instead.\n   * @param {Number} value - The threshold.\n   */\n  setThreshold(value) {\n    this.threshold = value;\n  }\n  /**\n   * The luminance threshold smoothing.\n   *\n   * @type {Number}\n   */\n  get smoothing() {\n    return this.uniforms.smoothing.value;\n  }\n  set smoothing(value) {\n    if (this.threshold > 0 || value > 0) {\n      this.defines.THRESHOLD = \"1\";\n    } else {\n      delete this.defines.THRESHOLD;\n    }\n    this.uniforms.smoothing.value = value;\n  }\n  /**\n   * Returns the luminance threshold smoothing factor.\n   *\n   * @deprecated Use smoothing instead.\n   * @return {Number} The smoothing factor.\n   */\n  getSmoothingFactor() {\n    return this.smoothing;\n  }\n  /**\n   * Sets the luminance threshold smoothing factor.\n   *\n   * @deprecated Use smoothing instead.\n   * @param {Number} value - The smoothing factor.\n   */\n  setSmoothingFactor(value) {\n    this.smoothing = value;\n  }\n  /**\n   * Indicates whether the luminance threshold is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Adjust the threshold or smoothing factor instead.\n   */\n  get useThreshold() {\n    return this.threshold > 0 || this.smoothing > 0;\n  }\n  set useThreshold(value) {\n  }\n  /**\n   * Indicates whether color output is enabled.\n   *\n   * @type {Boolean}\n   */\n  get colorOutput() {\n    return this.defines.COLOR !== void 0;\n  }\n  set colorOutput(value) {\n    if (value) {\n      this.defines.COLOR = \"1\";\n    } else {\n      delete this.defines.COLOR;\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Indicates whether color output is enabled.\n   *\n   * @deprecated Use colorOutput instead.\n   * @return {Boolean} Whether color output is enabled.\n   */\n  isColorOutputEnabled(value) {\n    return this.colorOutput;\n  }\n  /**\n   * Enables or disables color output.\n   *\n   * @deprecated Use colorOutput instead.\n   * @param {Boolean} value - Whether color output should be enabled.\n   */\n  setColorOutputEnabled(value) {\n    this.colorOutput = value;\n  }\n  /**\n   * Indicates whether luminance masking is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */\n  get useRange() {\n    return this.luminanceRange !== null;\n  }\n  set useRange(value) {\n    this.luminanceRange = null;\n  }\n  /**\n   * The luminance range. Set to null to disable.\n   *\n   * @type {Boolean}\n   */\n  get luminanceRange() {\n    return this.uniforms.range.value;\n  }\n  set luminanceRange(value) {\n    if (value !== null) {\n      this.defines.RANGE = \"1\";\n    } else {\n      delete this.defines.RANGE;\n    }\n    this.uniforms.range.value = value;\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the current luminance range.\n   *\n   * @deprecated Use luminanceRange instead.\n   * @return {Vector2} The luminance range.\n   */\n  getLuminanceRange() {\n    return this.luminanceRange;\n  }\n  /**\n   * Sets a luminance range. Set to null to disable.\n   *\n   * @deprecated Use luminanceRange instead.\n   * @param {Vector2} value - The luminance range.\n   */\n  setLuminanceRange(value) {\n    this.luminanceRange = value;\n  }\n};\n\n// src/passes/LuminancePass.js\nvar LuminancePass = class extends Pass {\n  /**\n   * Constructs a new luminance pass.\n   *\n   * @param {Object} [options] - The options. See {@link LuminanceMaterial} for additional options.\n   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor({\n    renderTarget,\n    luminanceRange,\n    colorOutput,\n    resolutionScale = 1,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"LuminancePass\");\n    this.fullscreenMaterial = new LuminanceMaterial(colorOutput, luminanceRange);\n    this.needsSwap = false;\n    this.renderTarget = renderTarget;\n    if (this.renderTarget === void 0) {\n      this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n      this.renderTarget.texture.name = \"LuminancePass.Target\";\n    }\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n  }\n  /**\n   * The luminance texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the luminance texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * Renders the luminance.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const material = this.fullscreenMaterial;\n    material.inputBuffer = inputBuffer.texture;\n    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n    renderer.render(this.scene, this.camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    this.renderTarget.setSize(resolution.width, resolution.height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (frameBufferType !== void 0 && frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n      this.renderTarget.texture.type = frameBufferType;\n      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n    }\n  }\n};\n\n// src/passes/MipmapBlurPass.js\n\n\n// src/materials/DownsamplingMaterial.js\n\n\n// src/materials/glsl/convolution.downsampling.frag\nvar convolution_downsampling_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}`;\n\n// src/materials/glsl/convolution.downsampling.vert\nvar convolution_downsampling_default2 = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/DownsamplingMaterial.js\nvar DownsamplingMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new downsampling material.\n   */\n  constructor() {\n    super({\n      name: \"DownsamplingMaterial\",\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_downsampling_default,\n      vertexShader: convolution_downsampling_default2\n    });\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/materials/UpsamplingMaterial.js\n\n\n// src/materials/glsl/convolution.upsampling.frag\nvar convolution_upsampling_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}`;\n\n// src/materials/glsl/convolution.upsampling.vert\nvar convolution_upsampling_default2 = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/UpsamplingMaterial.js\nvar UpsamplingMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new upsampling material.\n   */\n  constructor() {\n    super({\n      name: \"UpsamplingMaterial\",\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        supportBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        radius: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.85)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_upsampling_default,\n      vertexShader: convolution_upsampling_default2\n    });\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * A support buffer.\n   *\n   * @type {Texture}\n   */\n  set supportBuffer(value) {\n    this.uniforms.supportBuffer.value = value;\n  }\n  /**\n   * The blur radius.\n   *\n   * @type {Number}\n   */\n  get radius() {\n    return this.uniforms.radius.value;\n  }\n  set radius(value) {\n    this.uniforms.radius.value = value;\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/passes/MipmapBlurPass.js\nvar MipmapBlurPass = class extends Pass {\n  /**\n   * Constructs a new mipmap blur pass.\n   *\n   * @param {Object} [options] - The options.\n   */\n  constructor() {\n    super(\"MipmapBlurPass\");\n    this.needsSwap = false;\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTarget.texture.name = \"Upsampling.Mipmap0\";\n    this.downsamplingMipmaps = [];\n    this.upsamplingMipmaps = [];\n    this.downsamplingMaterial = new DownsamplingMaterial();\n    this.upsamplingMaterial = new UpsamplingMaterial();\n    this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n  }\n  /**\n   * A texture that contains the blurred result.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * The MIP levels. Default is 8.\n   *\n   * @type {Number}\n   */\n  get levels() {\n    return this.downsamplingMipmaps.length;\n  }\n  set levels(value) {\n    if (this.levels !== value) {\n      const renderTarget = this.renderTarget;\n      this.dispose();\n      this.downsamplingMipmaps = [];\n      this.upsamplingMipmaps = [];\n      for (let i = 0; i < value; ++i) {\n        const mipmap = renderTarget.clone();\n        mipmap.texture.name = \"Downsampling.Mipmap\" + i;\n        this.downsamplingMipmaps.push(mipmap);\n      }\n      this.upsamplingMipmaps.push(renderTarget);\n      for (let i = 1, l = value - 1; i < l; ++i) {\n        const mipmap = renderTarget.clone();\n        mipmap.texture.name = \"Upsampling.Mipmap\" + i;\n        this.upsamplingMipmaps.push(mipmap);\n      }\n      this.setSize(this.resolution.x, this.resolution.y);\n    }\n  }\n  /**\n   * The blur radius.\n   *\n   * @type {Number}\n   */\n  get radius() {\n    return this.upsamplingMaterial.radius;\n  }\n  set radius(value) {\n    this.upsamplingMaterial.radius = value;\n  }\n  /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const { scene, camera } = this;\n    const { downsamplingMaterial, upsamplingMaterial } = this;\n    const { downsamplingMipmaps, upsamplingMipmaps } = this;\n    let previousBuffer = inputBuffer;\n    this.fullscreenMaterial = downsamplingMaterial;\n    for (let i = 0, l = downsamplingMipmaps.length; i < l; ++i) {\n      const mipmap = downsamplingMipmaps[i];\n      downsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);\n      downsamplingMaterial.inputBuffer = previousBuffer.texture;\n      renderer.setRenderTarget(mipmap);\n      renderer.render(scene, camera);\n      previousBuffer = mipmap;\n    }\n    this.fullscreenMaterial = upsamplingMaterial;\n    for (let i = upsamplingMipmaps.length - 1; i >= 0; --i) {\n      const mipmap = upsamplingMipmaps[i];\n      upsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);\n      upsamplingMaterial.inputBuffer = previousBuffer.texture;\n      upsamplingMaterial.supportBuffer = downsamplingMipmaps[i].texture;\n      renderer.setRenderTarget(mipmap);\n      renderer.render(scene, camera);\n      previousBuffer = mipmap;\n    }\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.set(width, height);\n    let w = resolution.width, h = resolution.height;\n    for (let i = 0, l = this.downsamplingMipmaps.length; i < l; ++i) {\n      w = Math.round(w * 0.5);\n      h = Math.round(h * 0.5);\n      this.downsamplingMipmaps[i].setSize(w, h);\n      if (i < this.upsamplingMipmaps.length) {\n        this.upsamplingMipmaps[i].setSize(w, h);\n      }\n    }\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (frameBufferType !== void 0) {\n      const mipmaps = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);\n      for (const mipmap of mipmaps) {\n        mipmap.texture.type = frameBufferType;\n      }\n      if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n        this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n        this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n      } else if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        for (const mipmap of mipmaps) {\n          mipmap.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        }\n      }\n    }\n  }\n  /**\n   * Deletes internal render targets and textures.\n   */\n  dispose() {\n    super.dispose();\n    for (const mipmap of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) {\n      mipmap.dispose();\n    }\n  }\n};\n\n// src/effects/glsl/bloom.frag\nvar bloom_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,max(inputColor.a,texel.a));}`;\n\n// src/effects/BloomEffect.js\nvar BloomEffect = class extends Effect {\n  /**\n   * Constructs a new bloom effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.\n   * @param {Number} [options.luminanceThreshold=1.0] - The luminance threshold. Raise this value to mask out darker elements in the scene.\n   * @param {Number} [options.luminanceSmoothing=0.03] - Controls the smoothness of the luminance threshold.\n   * @param {Boolean} [options.mipmapBlur=true] - Enables or disables mipmap blur.\n   * @param {Number} [options.intensity=1.0] - The bloom intensity.\n   * @param {Number} [options.radius=0.85] - The blur radius. Only applies to mipmap blur.\n   * @param {Number} [options.levels=8] - The amount of MIP levels. Only applies to mipmap blur.\n   * @param {KernelSize} [options.kernelSize=KernelSize.LARGE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.resolutionScale=0.5] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   */\n  constructor({\n    blendFunction = BlendFunction.SCREEN,\n    luminanceThreshold = 1,\n    luminanceSmoothing = 0.03,\n    mipmapBlur = true,\n    intensity = 1,\n    radius = 0.85,\n    levels = 8,\n    kernelSize = KernelSize.LARGE,\n    resolutionScale = 0.5,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"BloomEffect\", bloom_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"map\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"intensity\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(intensity)]\n      ])\n    });\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTarget.texture.name = \"Bloom.Target\";\n    this.blurPass = new KawaseBlurPass({ kernelSize });\n    this.luminancePass = new LuminancePass({ colorOutput: true });\n    this.luminanceMaterial.threshold = luminanceThreshold;\n    this.luminanceMaterial.smoothing = luminanceSmoothing;\n    this.mipmapBlurPass = new MipmapBlurPass();\n    this.mipmapBlurPass.enabled = mipmapBlur;\n    this.mipmapBlurPass.radius = radius;\n    this.mipmapBlurPass.levels = levels;\n    this.uniforms.get(\"map\").value = mipmapBlur ? this.mipmapBlurPass.texture : this.renderTarget.texture;\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n  }\n  /**\n   * A texture that contains the intermediate result of this effect.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;\n  }\n  /**\n   * Returns the generated bloom texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.texture;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * Returns the blur pass.\n   *\n   * @deprecated\n   * @return {KawaseBlurPass} The blur pass.\n   */\n  getBlurPass() {\n    return this.blurPass;\n  }\n  /**\n   * Returns the luminance pass.\n   *\n   * @deprecated Use luminancePass instead.\n   * @return {LuminancePass} The luminance pass.\n   */\n  getLuminancePass() {\n    return this.luminancePass;\n  }\n  /**\n   * The luminance material.\n   *\n   * @type {LuminanceMaterial}\n   */\n  get luminanceMaterial() {\n    return this.luminancePass.fullscreenMaterial;\n  }\n  /**\n   * Returns the luminance material.\n   *\n   * @deprecated Use luminanceMaterial instead.\n   * @return {LuminanceMaterial} The material.\n   */\n  getLuminanceMaterial() {\n    return this.luminancePass.fullscreenMaterial;\n  }\n  /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated\n   */\n  get width() {\n    return this.resolution.width;\n  }\n  set width(value) {\n    this.resolution.preferredWidth = value;\n  }\n  /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated\n   */\n  get height() {\n    return this.resolution.height;\n  }\n  set height(value) {\n    this.resolution.preferredHeight = value;\n  }\n  /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use EffectPass.dithering instead.\n   */\n  get dithering() {\n    return this.blurPass.dithering;\n  }\n  set dithering(value) {\n    this.blurPass.dithering = value;\n  }\n  /**\n   * The blur kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated\n   */\n  get kernelSize() {\n    return this.blurPass.kernelSize;\n  }\n  set kernelSize(value) {\n    this.blurPass.kernelSize = value;\n  }\n  /**\n   * @type {Number}\n   * @deprecated\n   */\n  get distinction() {\n    console.warn(this.name, \"distinction was removed\");\n    return 1;\n  }\n  set distinction(value) {\n    console.warn(this.name, \"distinction was removed\");\n  }\n  /**\n   * The bloom intensity.\n   *\n   * @type {Number}\n   */\n  get intensity() {\n    return this.uniforms.get(\"intensity\").value;\n  }\n  set intensity(value) {\n    this.uniforms.get(\"intensity\").value = value;\n  }\n  /**\n   * The bloom intensity.\n   *\n   * @deprecated Use intensity instead.\n   * @return {Number} The intensity.\n   */\n  getIntensity() {\n    return this.intensity;\n  }\n  /**\n   * Sets the bloom intensity.\n   *\n   * @deprecated Use intensity instead.\n   * @param {Number} value - The intensity.\n   */\n  setIntensity(value) {\n    this.intensity = value;\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated\n   */\n  getResolutionScale() {\n    return this.resolution.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated\n   */\n  setResolutionScale(scale) {\n    this.resolution.scale = scale;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const renderTarget = this.renderTarget;\n    const luminancePass = this.luminancePass;\n    if (luminancePass.enabled) {\n      luminancePass.render(renderer, inputBuffer);\n      if (this.mipmapBlurPass.enabled) {\n        this.mipmapBlurPass.render(renderer, luminancePass.renderTarget);\n      } else {\n        this.blurPass.render(renderer, luminancePass.renderTarget, renderTarget);\n      }\n    } else {\n      if (this.mipmapBlurPass.enabled) {\n        this.mipmapBlurPass.render(renderer, inputBuffer);\n      } else {\n        this.blurPass.render(renderer, inputBuffer, renderTarget);\n      }\n    }\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    this.renderTarget.setSize(resolution.width, resolution.height);\n    this.blurPass.resolution.copy(resolution);\n    this.luminancePass.setSize(width, height);\n    this.mipmapBlurPass.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.blurPass.initialize(renderer, alpha, frameBufferType);\n    this.luminancePass.initialize(renderer, alpha, frameBufferType);\n    this.mipmapBlurPass.initialize(renderer, alpha, frameBufferType);\n    if (frameBufferType !== void 0) {\n      this.renderTarget.texture.type = frameBufferType;\n      if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        this.renderTarget.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n      }\n    }\n  }\n};\n\n// src/effects/BokehEffect.js\n\n\n// src/effects/glsl/bokeh.frag\nvar bokeh_default = `uniform float focus;uniform float dof;uniform float aperture;uniform float maxBlur;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec2 aspectCorrection=vec2(1.0,aspect);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat focusNear=clamp(focus-dof,0.0,1.0);float focusFar=clamp(focus+dof,0.0,1.0);float low=step(linearDepth,focusNear);float high=step(focusFar,linearDepth);float factor=(linearDepth-focusNear)*low+(linearDepth-focusFar)*high;vec2 dofBlur=vec2(clamp(factor*aperture,-maxBlur,maxBlur));vec2 dofblur9=dofBlur*0.9;vec2 dofblur7=dofBlur*0.7;vec2 dofblur4=dofBlur*0.4;vec4 color=inputColor;color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.37,0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.40,0.0)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.37,-0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.15,-0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.15,0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.37,0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.37,-0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,-0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.37,0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.37,-0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.15,-0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.15,0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.37,0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.37,-0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.15,-0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.40,0.0)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.4,0.0)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofblur4);outputColor=color/41.0;}`;\n\n// src/effects/BokehEffect.js\nvar BokehEffect = class extends Effect {\n  /**\n   * Constructs a new bokeh effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.focus=0.5] - The focus distance ratio, ranging from 0.0 to 1.0.\n   * @param {Number} [options.dof=0.02] - Depth of field. An area in front of and behind the focal point that still appears sharp.\n   * @param {Number} [options.aperture=0.015] - Camera aperture scale. Bigger values for stronger blur and shallower depth of field.\n   * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.\n   */\n  constructor({\n    blendFunction,\n    focus = 0.5,\n    dof = 0.02,\n    aperture = 0.015,\n    maxBlur = 1\n  } = {}) {\n    super(\"BokehEffect\", bokeh_default, {\n      blendFunction,\n      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"focus\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focus)],\n        [\"dof\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(dof)],\n        [\"aperture\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(aperture)],\n        [\"maxBlur\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxBlur)]\n      ])\n    });\n  }\n};\n\n// src/effects/BrightnessContrastEffect.js\n\n\n// src/effects/glsl/brightness-contrast.frag\nvar brightness_contrast_default = `uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}`;\n\n// src/effects/BrightnessContrastEffect.js\nvar BrightnessContrastEffect = class extends Effect {\n  /**\n   * Constructs a new brightness/contrast effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Number} [options.brightness=0.0] - The brightness factor, ranging from -1 to 1, where 0 means no change.\n   * @param {Number} [options.contrast=0.0] - The contrast factor, ranging from -1 to 1, where 0 means no change.\n   */\n  constructor({ blendFunction = BlendFunction.SRC, brightness = 0, contrast = 0 } = {}) {\n    super(\"BrightnessContrastEffect\", brightness_contrast_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"brightness\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(brightness)],\n        [\"contrast\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(contrast)]\n      ])\n    });\n    this.inputColorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n  }\n  /**\n   * The brightness.\n   *\n   * @type {Number}\n   */\n  get brightness() {\n    return this.uniforms.get(\"brightness\").value;\n  }\n  set brightness(value) {\n    this.uniforms.get(\"brightness\").value = value;\n  }\n  /**\n   * Returns the brightness.\n   *\n   * @deprecated Use brightness instead.\n   * @return {Number} The brightness.\n   */\n  getBrightness() {\n    return this.brightness;\n  }\n  /**\n   * Sets the brightness.\n   *\n   * @deprecated Use brightness instead.\n   * @param {Number} value - The brightness.\n   */\n  setBrightness(value) {\n    this.brightness = value;\n  }\n  /**\n   * The contrast.\n   *\n   * @type {Number}\n   */\n  get contrast() {\n    return this.uniforms.get(\"contrast\").value;\n  }\n  set contrast(value) {\n    this.uniforms.get(\"contrast\").value = value;\n  }\n  /**\n   * Returns the contrast.\n   *\n   * @deprecated Use contrast instead.\n   * @return {Number} The contrast.\n   */\n  getContrast() {\n    return this.contrast;\n  }\n  /**\n   * Sets the contrast.\n   *\n   * @deprecated Use contrast instead.\n   * @param {Number} value - The contrast.\n   */\n  setContrast(value) {\n    this.contrast = value;\n  }\n};\n\n// src/effects/glsl/color-average.frag\nvar color_average_default = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}`;\n\n// src/effects/ColorAverageEffect.js\nvar ColorAverageEffect = class extends Effect {\n  /**\n   * Constructs a new color average effect.\n   *\n   * @param {BlendFunction} [blendFunction] - The blend function of this effect.\n   */\n  constructor(blendFunction) {\n    super(\"ColorAverageEffect\", color_average_default, { blendFunction });\n  }\n};\n\n// src/effects/ColorDepthEffect.js\n\n\n// src/effects/glsl/color-depth.frag\nvar color_depth_default = `uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}`;\n\n// src/effects/ColorDepthEffect.js\nvar ColorDepthEffect = class extends Effect {\n  /**\n   * Constructs a new color depth effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.bits=16] - The color bit depth.\n   */\n  constructor({ blendFunction, bits = 16 } = {}) {\n    super(\"ColorDepthEffect\", color_depth_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"factor\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)]\n      ])\n    });\n    this.bits = 0;\n    this.bitDepth = bits;\n  }\n  /**\n   * The virtual amount of color bits.\n   *\n   * Each color channel effectively uses a fourth of the total amount of bits. Alpha remains unaffected.\n   *\n   * @type {Number}\n   */\n  get bitDepth() {\n    return this.bits;\n  }\n  set bitDepth(value) {\n    this.bits = value;\n    this.uniforms.get(\"factor\").value = Math.pow(2, value / 3);\n  }\n  /**\n   * Returns the current color bit depth.\n   *\n   * @return {Number} The bit depth.\n   */\n  getBitDepth() {\n    return this.bitDepth;\n  }\n  /**\n   * Sets the virtual amount of color bits.\n   *\n   * @param {Number} value - The bit depth.\n   */\n  setBitDepth(value) {\n    this.bitDepth = value;\n  }\n};\n\n// src/effects/ChromaticAberrationEffect.js\n\n\n// src/effects/glsl/chromatic-aberration.frag\nvar chromatic_aberration_default = `#ifdef RADIAL_MODULATION\nuniform float modulationOffset;\n#endif\nvarying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=inputColor.ra;vec2 ba=inputColor.ba;\n#ifdef RADIAL_MODULATION\nconst vec2 center=vec2(0.5);float d=distance(uv,center)*2.0;d=max(d-modulationOffset,0.0);if(vActive>0.0&&d>0.0){ra=texture2D(inputBuffer,mix(uv,vUvR,d)).ra;ba=texture2D(inputBuffer,mix(uv,vUvB,d)).ba;}\n#else\nif(vActive>0.0){ra=texture2D(inputBuffer,vUvR).ra;ba=texture2D(inputBuffer,vUvB).ba;}\n#endif\noutputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}`;\n\n// src/effects/glsl/chromatic-aberration.vert\nvar chromatic_aberration_default2 = `uniform vec2 offset;varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vActive=(shift.x!=0.0||shift.y!=0.0)?1.0:0.0;vUvR=uv+shift;vUvB=uv-shift;}`;\n\n// src/effects/ChromaticAberrationEffect.js\nvar ChromaticAberrationEffect = class extends Effect {\n  /**\n   * Constructs a new chromatic aberration effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Vector2} [options.offset] - The color offset.\n   * @param {Boolean} [options.radialModulation=false] - Whether the effect should be modulated with a radial gradient.\n   * @param {Number} [options.modulationOffset=0.15] - The modulation offset. Only applies if `radialModulation` is enabled.\n   */\n  constructor({\n    offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1e-3, 5e-4),\n    radialModulation = false,\n    modulationOffset = 0.15\n  } = {}) {\n    super(\"ChromaticAberrationEffect\", chromatic_aberration_default, {\n      vertexShader: chromatic_aberration_default2,\n      attributes: EffectAttribute.CONVOLUTION,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"offset\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(offset)],\n        [\"modulationOffset\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(modulationOffset)]\n      ])\n    });\n    this.radialModulation = radialModulation;\n  }\n  /**\n   * The color offset.\n   *\n   * @type {Vector2}\n   */\n  get offset() {\n    return this.uniforms.get(\"offset\").value;\n  }\n  set offset(value) {\n    this.uniforms.get(\"offset\").value = value;\n  }\n  /**\n   * Indicates whether radial modulation is enabled.\n   *\n   * When enabled, the effect will be weaker in the middle and stronger towards the screen edges.\n   *\n   * @type {Boolean}\n   */\n  get radialModulation() {\n    return this.defines.has(\"RADIAL_MODULATION\");\n  }\n  set radialModulation(value) {\n    if (value) {\n      this.defines.set(\"RADIAL_MODULATION\", \"1\");\n    } else {\n      this.defines.delete(\"RADIAL_MODULATION\");\n    }\n    this.setChanged();\n  }\n  /**\n   * The modulation offset.\n   *\n   * @type {Number}\n   */\n  get modulationOffset() {\n    return this.uniforms.get(\"modulationOffset\").value;\n  }\n  set modulationOffset(value) {\n    this.uniforms.get(\"modulationOffset\").value = value;\n  }\n  /**\n   * Returns the color offset vector.\n   *\n   * @deprecated Use offset instead.\n   * @return {Vector2} The offset.\n   */\n  getOffset() {\n    return this.offset;\n  }\n  /**\n   * Sets the color offset vector.\n   *\n   * @deprecated Use offset instead.\n   * @param {Vector2} value - The offset.\n   */\n  setOffset(value) {\n    this.offset = value;\n  }\n};\n\n// src/effects/glsl/depth.frag\nvar depth_default = `void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\n#ifdef INVERTED\nvec3 color=vec3(1.0-depth);\n#else\nvec3 color=vec3(depth);\n#endif\noutputColor=vec4(color,inputColor.a);}`;\n\n// src/effects/DepthEffect.js\nvar DepthEffect = class extends Effect {\n  /**\n   * Constructs a new depth effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Boolean} [options.inverted=false] - Whether the depth should be inverted.\n   */\n  constructor({ blendFunction = BlendFunction.SRC, inverted = false } = {}) {\n    super(\"DepthEffect\", depth_default, {\n      blendFunction,\n      attributes: EffectAttribute.DEPTH\n    });\n    this.inverted = inverted;\n  }\n  /**\n   * Indicates whether depth should be inverted.\n   *\n   * @type {Boolean}\n   */\n  get inverted() {\n    return this.defines.has(\"INVERTED\");\n  }\n  set inverted(value) {\n    if (this.inverted !== value) {\n      if (value) {\n        this.defines.set(\"INVERTED\", \"1\");\n      } else {\n        this.defines.delete(\"INVERTED\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether the rendered depth is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the rendered depth is inverted.\n   */\n  isInverted() {\n    return this.inverted;\n  }\n  /**\n   * Enables or disables depth inversion.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether depth should be inverted.\n   */\n  setInverted(value) {\n    this.inverted = value;\n  }\n};\n\n// src/effects/DepthOfFieldEffect.js\n\n\n// src/enums/ColorChannel.js\nvar ColorChannel = {\n  RED: 0,\n  GREEN: 1,\n  BLUE: 2,\n  ALPHA: 3\n};\n\n// src/enums/MaskFunction.js\nvar MaskFunction = {\n  DISCARD: 0,\n  MULTIPLY: 1,\n  MULTIPLY_RGB_SET_ALPHA: 2,\n  MULTIPLY_RGB: 3\n};\n\n// src/materials/BokehMaterial.js\n\n\n// src/materials/glsl/convolution.bokeh.frag\nvar convolution_bokeh_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if PASS == 1\nuniform vec4 kernel64[32];\n#else\nuniform vec4 kernel16[8];\n#endif\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){\n#ifdef FOREGROUND\nvec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;\n#else\nfloat coc=texture2D(cocBuffer,vUv).g*scale;\n#endif\nif(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\n#ifdef FOREGROUND\nvec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);\n#else\nvec2 step=texelSize*coc;\n#endif\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}`;\n\n// src/materials/BokehMaterial.js\nvar BokehMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new bokeh material.\n   *\n   * @param {Boolean} [fill=false] - Enables or disables the bokeh highlight fill mode.\n   * @param {Boolean} [foreground=false] - Determines whether this material will be applied to foreground colors.\n   */\n  constructor(fill = false, foreground = false) {\n    super({\n      name: \"BokehMaterial\",\n      defines: {\n        PASS: fill ? \"2\" : \"1\"\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        cocBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        kernel64: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        kernel16: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_bokeh_default,\n      vertexShader: common_default\n    });\n    if (foreground) {\n      this.defines.FOREGROUND = \"1\";\n    }\n    this.generateKernel();\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The circle of confusion buffer.\n   *\n   * @type {Texture}\n   */\n  set cocBuffer(value) {\n    this.uniforms.cocBuffer.value = value;\n  }\n  /**\n   * Sets the circle of confusion buffer.\n   *\n   * @deprecated Use cocBuffer instead.\n   * @param {Texture} value - The buffer.\n   */\n  setCoCBuffer(value) {\n    this.uniforms.cocBuffer.value = value;\n  }\n  /**\n   * The blur scale.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.uniforms.scale.value;\n  }\n  set scale(value) {\n    this.uniforms.scale.value = value;\n  }\n  /**\n   * Returns the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The scale.\n   */\n  getScale(value) {\n    return this.scale;\n  }\n  /**\n   * Sets the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @param {Number} value - The scale.\n   */\n  setScale(value) {\n    this.scale = value;\n  }\n  /**\n   * Generates the blur kernel.\n   *\n   * @private\n   */\n  generateKernel() {\n    const GOLDEN_ANGLE = 2.39996323;\n    const points64 = new Float64Array(128);\n    const points16 = new Float64Array(32);\n    let i64 = 0, i16 = 0;\n    for (let i = 0, sqrt80 = Math.sqrt(80); i < 80; ++i) {\n      const theta = i * GOLDEN_ANGLE;\n      const r = Math.sqrt(i) / sqrt80;\n      const u = r * Math.cos(theta), v3 = r * Math.sin(theta);\n      if (i % 5 === 0) {\n        points16[i16++] = u;\n        points16[i16++] = v3;\n      } else {\n        points64[i64++] = u;\n        points64[i64++] = v3;\n      }\n    }\n    this.uniforms.kernel64.value = points64;\n    this.uniforms.kernel16.value = points16;\n  }\n  /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */\n  setTexelSize(x, y) {\n    this.uniforms.texelSize.value.set(x, y);\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/materials/CircleOfConfusionMaterial.js\n\n\n// src/utils/orthographicDepthToViewZ.js\nfunction orthographicDepthToViewZ(depth, near, far) {\n  return depth * (near - far) - near;\n}\n\n// src/utils/viewZToOrthographicDepth.js\nfunction viewZToOrthographicDepth(viewZ, near, far) {\n  return Math.min(Math.max((viewZ + near) / (near - far), 0), 1);\n}\n\n// src/materials/glsl/circle-of-confusion.frag\nvar circle_of_confusion_default = `#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nfloat depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nfloat depth=texture2D(depthBuffer,uv).r;\n#endif\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;\n#endif\nreturn depth;}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`;\n\n// src/materials/CircleOfConfusionMaterial.js\nvar CircleOfConfusionMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new CoC material.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  constructor(camera) {\n    super({\n      name: \"CircleOfConfusionMaterial\",\n      defines: {\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        focusDistance: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n        focusRange: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n        cameraNear: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.3),\n        cameraFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1e3)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: circle_of_confusion_default,\n      vertexShader: common_default\n    });\n    this.uniforms.focalLength = this.uniforms.focusRange;\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * The current near plane setting.\n   *\n   * @type {Number}\n   * @private\n   */\n  get near() {\n    return this.uniforms.cameraNear.value;\n  }\n  /**\n   * The current far plane setting.\n   *\n   * @type {Number}\n   * @private\n   */\n  get far() {\n    return this.uniforms.cameraFar.value;\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer = buffer;\n    this.depthPacking = depthPacking;\n  }\n  /**\n   * The focus distance. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get focusDistance() {\n    return this.uniforms.focusDistance.value;\n  }\n  set focusDistance(value) {\n    this.uniforms.focusDistance.value = value;\n  }\n  /**\n   * The focus distance in world units.\n   *\n   * @type {Number}\n   */\n  get worldFocusDistance() {\n    return -orthographicDepthToViewZ(this.focusDistance, this.near, this.far);\n  }\n  set worldFocusDistance(value) {\n    this.focusDistance = viewZToOrthographicDepth(-value, this.near, this.far);\n  }\n  /**\n   * Returns the focus distance.\n   *\n   * @deprecated Use focusDistance instead.\n   * @return {Number} The focus distance.\n   */\n  getFocusDistance(value) {\n    this.uniforms.focusDistance.value = value;\n  }\n  /**\n   * Sets the focus distance.\n   *\n   * @deprecated Use focusDistance instead.\n   * @param {Number} value - The focus distance.\n   */\n  setFocusDistance(value) {\n    this.uniforms.focusDistance.value = value;\n  }\n  /**\n   * The focal length.\n   *\n   * @deprecated Renamed to focusRange.\n   * @type {Number}\n   */\n  get focalLength() {\n    return this.focusRange;\n  }\n  set focalLength(value) {\n    this.focusRange = value;\n  }\n  /**\n   * The focus range. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get focusRange() {\n    return this.uniforms.focusRange.value;\n  }\n  set focusRange(value) {\n    this.uniforms.focusRange.value = value;\n  }\n  /**\n   * The focus range in world units.\n   *\n   * @type {Number}\n   */\n  get worldFocusRange() {\n    return -orthographicDepthToViewZ(this.focusRange, this.near, this.far);\n  }\n  set worldFocusRange(value) {\n    this.focusRange = viewZToOrthographicDepth(-value, this.near, this.far);\n  }\n  /**\n   * Returns the focal length.\n   *\n   * @deprecated Use focusRange instead.\n   * @return {Number} The focal length.\n   */\n  getFocalLength(value) {\n    return this.focusRange;\n  }\n  /**\n   * Sets the focal length.\n   *\n   * @deprecated Use focusRange instead.\n   * @param {Number} value - The focal length.\n   */\n  setFocalLength(value) {\n    this.focusRange = value;\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */\n  adoptCameraSettings(camera) {\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  copyCameraSettings(camera) {\n    if (camera) {\n      this.uniforms.cameraNear.value = camera.near;\n      this.uniforms.cameraFar.value = camera.far;\n      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n        this.defines.PERSPECTIVE_CAMERA = \"1\";\n      } else {\n        delete this.defines.PERSPECTIVE_CAMERA;\n      }\n      this.needsUpdate = true;\n    }\n  }\n};\n\n// src/materials/MaskMaterial.js\n\n\n// src/materials/glsl/mask.frag\nvar mask_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef MASK_PRECISION_HIGH\nuniform mediump sampler2D maskTexture;\n#else\nuniform lowp sampler2D maskTexture;\n#endif\n#if MASK_FUNCTION != 0\nuniform float strength;\n#endif\nvarying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nmask=step(mask,0.0);\n#else\nmask=1.0-step(mask,0.0);\n#endif\n#else\nmask=clamp(mask*strength,0.0,1.0);\n#ifdef INVERTED\nmask=1.0-mask;\n#endif\n#endif\n#if MASK_FUNCTION == 3\nvec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);\n#elif MASK_FUNCTION == 2\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\n#else\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#endif\n}`;\n\n// src/materials/MaskMaterial.js\nvar MaskMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new mask material.\n   *\n   * @param {Texture} [maskTexture] - The mask texture.\n   */\n  constructor(maskTexture = null) {\n    super({\n      name: \"MaskMaterial\",\n      uniforms: {\n        maskTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maskTexture),\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        strength: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: mask_default,\n      vertexShader: common_default\n    });\n    this.colorChannel = ColorChannel.RED;\n    this.maskFunction = MaskFunction.DISCARD;\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The mask texture.\n   *\n   * @type {Texture}\n   */\n  set maskTexture(value) {\n    this.uniforms.maskTexture.value = value;\n    delete this.defines.MASK_PRECISION_HIGH;\n    if (value.type !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n      this.defines.MASK_PRECISION_HIGH = \"1\";\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the mask texture.\n   *\n   * @deprecated Use maskTexture instead.\n   * @param {Texture} value - The texture.\n   */\n  setMaskTexture(value) {\n    this.maskTexture = value;\n  }\n  /**\n   * Sets the color channel to use for masking. Default is `ColorChannel.RED`.\n   *\n   * @type {ColorChannel}\n   */\n  set colorChannel(value) {\n    this.defines.COLOR_CHANNEL = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the color channel to use for masking. Default is `ColorChannel.RED`.\n   *\n   * @deprecated Use colorChannel instead.\n   * @param {ColorChannel} value - The channel.\n   */\n  setColorChannel(value) {\n    this.colorChannel = value;\n  }\n  /**\n   * The masking technique. Default is `MaskFunction.DISCARD`.\n   *\n   * @type {MaskFunction}\n   */\n  set maskFunction(value) {\n    this.defines.MASK_FUNCTION = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the masking technique. Default is `MaskFunction.DISCARD`.\n   *\n   * @deprecated Use maskFunction instead.\n   * @param {MaskFunction} value - The function.\n   */\n  setMaskFunction(value) {\n    this.maskFunction = value;\n  }\n  /**\n   * Indicates whether the masking is inverted.\n   *\n   * @type {Boolean}\n   */\n  get inverted() {\n    return this.defines.INVERTED !== void 0;\n  }\n  set inverted(value) {\n    if (this.inverted && !value) {\n      delete this.defines.INVERTED;\n    } else if (value) {\n      this.defines.INVERTED = \"1\";\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Indicates whether the masking is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the masking is inverted.\n   */\n  isInverted() {\n    return this.inverted;\n  }\n  /**\n   * Determines whether the masking should be inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether the masking should be inverted.\n   */\n  setInverted(value) {\n    this.inverted = value;\n  }\n  /**\n   * The current mask strength.\n   *\n   * Individual mask values will be clamped to [0.0, 1.0]. Has no effect when the mask function is set to `DISCARD`.\n   *\n   * @type {Number}\n   */\n  get strength() {\n    return this.uniforms.strength.value;\n  }\n  set strength(value) {\n    this.uniforms.strength.value = value;\n  }\n  /**\n   * Returns the current mask strength.\n   *\n   * @deprecated Use strength instead.\n   * @return {Number} The mask strength.\n   */\n  getStrength() {\n    return this.strength;\n  }\n  /**\n   * Sets the mask strength.\n   *\n   * Has no effect when the mask function is set to `DISCARD`.\n   *\n   * @deprecated Use strength instead.\n   * @param {Number} value - The mask strength.\n   */\n  setStrength(value) {\n    this.strength = value;\n  }\n};\n\n// src/passes/ShaderPass.js\n\nvar ShaderPass = class extends Pass {\n  /**\n   * Constructs a new shader pass.\n   *\n   * @param {ShaderMaterial} material - A shader material.\n   * @param {String} [input=\"inputBuffer\"] - The name of the input buffer uniform.\n   */\n  constructor(material, input = \"inputBuffer\") {\n    super(\"ShaderPass\");\n    this.fullscreenMaterial = material;\n    this.input = input;\n  }\n  /**\n   * Sets the name of the input buffer uniform.\n   *\n   * @param {String} input - The name of the input buffer uniform.\n   * @deprecated Use input instead.\n   */\n  setInput(input) {\n    this.input = input;\n  }\n  /**\n   * Renders the effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const uniforms = this.fullscreenMaterial.uniforms;\n    if (inputBuffer !== null && uniforms !== void 0 && uniforms[this.input] !== void 0) {\n      uniforms[this.input].value = inputBuffer.texture;\n    }\n    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n    renderer.render(this.scene, this.camera);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (frameBufferType !== void 0 && frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n    }\n  }\n};\n\n// src/effects/glsl/depth-of-field.frag\nvar depth_of_field_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\n#else\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\n#endif\nuniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);\n#if MASK_FUNCTION == 1\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);\n#else\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);\n#endif\nvec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}`;\n\n// src/effects/DepthOfFieldEffect.js\nvar DepthOfFieldEffect = class extends Effect {\n  /**\n   * Constructs a new depth of field effect.\n   *\n   * @param {Camera} camera - The main camera.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.worldFocusDistance] - The focus distance in world units.\n   * @param {Number} [options.worldFocusRange] - The focus distance in world units.\n   * @param {Number} [options.focusDistance=0.0] - The normalized focus distance. Range is [0.0, 1.0].\n   * @param {Number} [options.focusRange=0.1] - The focus range. Range is [0.0, 1.0].\n   * @param {Number} [options.focalLength=0.1] - Deprecated.\n   * @param {Number} [options.bokehScale=1.0] - The scale of the bokeh blur.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor(camera, {\n    blendFunction,\n    worldFocusDistance,\n    worldFocusRange,\n    focusDistance = 0,\n    focalLength = 0.1,\n    focusRange = focalLength,\n    bokehScale = 1,\n    resolutionScale = 1,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"DepthOfFieldEffect\", depth_of_field_default, {\n      blendFunction,\n      attributes: EffectAttribute.DEPTH,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"nearColorBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"farColorBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"nearCoCBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"farCoCBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"scale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)]\n      ])\n    });\n    this.camera = camera;\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTarget.texture.name = \"DoF.Intermediate\";\n    this.renderTargetMasked = this.renderTarget.clone();\n    this.renderTargetMasked.texture.name = \"DoF.Masked.Far\";\n    this.renderTargetNear = this.renderTarget.clone();\n    this.renderTargetNear.texture.name = \"DoF.Bokeh.Near\";\n    this.uniforms.get(\"nearColorBuffer\").value = this.renderTargetNear.texture;\n    this.renderTargetFar = this.renderTarget.clone();\n    this.renderTargetFar.texture.name = \"DoF.Bokeh.Far\";\n    this.uniforms.get(\"farColorBuffer\").value = this.renderTargetFar.texture;\n    this.renderTargetCoC = this.renderTarget.clone();\n    this.renderTargetCoC.texture.name = \"DoF.CoC\";\n    this.uniforms.get(\"farCoCBuffer\").value = this.renderTargetCoC.texture;\n    this.renderTargetCoCBlurred = this.renderTargetCoC.clone();\n    this.renderTargetCoCBlurred.texture.name = \"DoF.CoC.Blurred\";\n    this.uniforms.get(\"nearCoCBuffer\").value = this.renderTargetCoCBlurred.texture;\n    this.cocPass = new ShaderPass(new CircleOfConfusionMaterial(camera));\n    const cocMaterial = this.cocMaterial;\n    cocMaterial.focusDistance = focusDistance;\n    cocMaterial.focusRange = focusRange;\n    if (worldFocusDistance !== void 0) {\n      cocMaterial.worldFocusDistance = worldFocusDistance;\n    }\n    if (worldFocusRange !== void 0) {\n      cocMaterial.worldFocusRange = worldFocusRange;\n    }\n    this.blurPass = new KawaseBlurPass({ resolutionScale, resolutionX, resolutionY, kernelSize: KernelSize.MEDIUM });\n    this.maskPass = new ShaderPass(new MaskMaterial(this.renderTargetCoC.texture));\n    const maskMaterial = this.maskPass.fullscreenMaterial;\n    maskMaterial.colorChannel = ColorChannel.GREEN;\n    this.maskFunction = MaskFunction.MULTIPLY_RGB;\n    this.bokehNearBasePass = new ShaderPass(new BokehMaterial(false, true));\n    this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;\n    this.bokehNearFillPass = new ShaderPass(new BokehMaterial(true, true));\n    this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;\n    this.bokehFarBasePass = new ShaderPass(new BokehMaterial(false, false));\n    this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;\n    this.bokehFarFillPass = new ShaderPass(new BokehMaterial(true, false));\n    this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;\n    this.target = null;\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this.bokehScale = bokehScale;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n    this.cocMaterial.copyCameraSettings(value);\n  }\n  /**\n   * The circle of confusion texture.\n   *\n   * @type {Texture}\n   */\n  get cocTexture() {\n    return this.renderTargetCoC.texture;\n  }\n  /**\n   * The mask function. Default is `MULTIPLY_RGB`.\n   *\n   * @type {MaskFunction}\n   */\n  get maskFunction() {\n    return this.maskPass.fullscreenMaterial.maskFunction;\n  }\n  set maskFunction(value) {\n    if (this.maskFunction !== value) {\n      this.defines.set(\"MASK_FUNCTION\", value.toFixed(0));\n      this.maskPass.fullscreenMaterial.maskFunction = value;\n      this.setChanged();\n    }\n  }\n  /**\n   * The circle of confusion material.\n   *\n   * @type {CircleOfConfusionMaterial}\n   */\n  get cocMaterial() {\n    return this.cocPass.fullscreenMaterial;\n  }\n  /**\n   * The circle of confusion material.\n   *\n   * @deprecated Use cocMaterial instead.\n   * @type {CircleOfConfusionMaterial}\n   */\n  get circleOfConfusionMaterial() {\n    return this.cocMaterial;\n  }\n  /**\n   * Returns the circle of confusion material.\n   *\n   * @deprecated Use cocMaterial instead.\n   * @return {CircleOfConfusionMaterial} The material.\n   */\n  getCircleOfConfusionMaterial() {\n    return this.cocMaterial;\n  }\n  /**\n   * Returns the pass that blurs the foreground CoC buffer to soften edges.\n   *\n   * @deprecated Use blurPass instead.\n   * @return {KawaseBlurPass} The blur pass.\n   */\n  getBlurPass() {\n    return this.blurPass;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * The current bokeh scale.\n   *\n   * @type {Number}\n   */\n  get bokehScale() {\n    return this.uniforms.get(\"scale\").value;\n  }\n  set bokehScale(value) {\n    this.bokehNearBasePass.fullscreenMaterial.scale = value;\n    this.bokehNearFillPass.fullscreenMaterial.scale = value;\n    this.bokehFarBasePass.fullscreenMaterial.scale = value;\n    this.bokehFarFillPass.fullscreenMaterial.scale = value;\n    this.maskPass.fullscreenMaterial.strength = value;\n    this.uniforms.get(\"scale\").value = value;\n  }\n  /**\n   * Returns the current bokeh scale.\n   *\n   * @deprecated Use bokehScale instead.\n   * @return {Number} The scale.\n   */\n  getBokehScale() {\n    return this.bokehScale;\n  }\n  /**\n   * Sets the bokeh scale.\n   *\n   * @deprecated Use bokehScale instead.\n   * @param {Number} value - The scale.\n   */\n  setBokehScale(value) {\n    this.bokehScale = value;\n  }\n  /**\n   * Returns the current auto focus target.\n   *\n   * @deprecated Use target instead.\n   * @return {Vector3} The target.\n   */\n  getTarget() {\n    return this.target;\n  }\n  /**\n   * Sets the auto focus target.\n   *\n   * @deprecated Use target instead.\n   * @param {Vector3} value - The target.\n   */\n  setTarget(value) {\n    this.target = value;\n  }\n  /**\n   * Calculates the focus distance from the camera to the given position.\n   *\n   * @param {Vector3} target - The target.\n   * @return {Number} The normalized focus distance.\n   */\n  calculateFocusDistance(target) {\n    const camera = this.camera;\n    const distance = camera.position.distanceTo(target);\n    return viewZToOrthographicDepth(-distance, camera.near, camera.far);\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.cocMaterial.depthBuffer = depthTexture;\n    this.cocMaterial.depthPacking = depthPacking;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const renderTarget = this.renderTarget;\n    const renderTargetCoC = this.renderTargetCoC;\n    const renderTargetCoCBlurred = this.renderTargetCoCBlurred;\n    const renderTargetMasked = this.renderTargetMasked;\n    if (this.target !== null) {\n      const distance = this.calculateFocusDistance(this.target);\n      this.cocMaterial.focusDistance = distance;\n    }\n    this.cocPass.render(renderer, null, renderTargetCoC);\n    this.blurPass.render(renderer, renderTargetCoC, renderTargetCoCBlurred);\n    this.maskPass.render(renderer, inputBuffer, renderTargetMasked);\n    this.bokehFarBasePass.render(renderer, renderTargetMasked, renderTarget);\n    this.bokehFarFillPass.render(renderer, renderTarget, this.renderTargetFar);\n    this.bokehNearBasePass.render(renderer, inputBuffer, renderTarget);\n    this.bokehNearFillPass.render(renderer, renderTarget, this.renderTargetNear);\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.cocPass.setSize(width, height);\n    this.blurPass.setSize(width, height);\n    this.maskPass.setSize(width, height);\n    this.renderTargetFar.setSize(width, height);\n    this.renderTargetCoC.setSize(width, height);\n    this.renderTargetMasked.setSize(width, height);\n    this.renderTarget.setSize(w, h);\n    this.renderTargetNear.setSize(w, h);\n    this.renderTargetCoCBlurred.setSize(w, h);\n    this.bokehNearBasePass.fullscreenMaterial.setSize(width, height);\n    this.bokehNearFillPass.fullscreenMaterial.setSize(width, height);\n    this.bokehFarBasePass.fullscreenMaterial.setSize(width, height);\n    this.bokehFarFillPass.fullscreenMaterial.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.cocPass.initialize(renderer, alpha, frameBufferType);\n    this.maskPass.initialize(renderer, alpha, frameBufferType);\n    this.bokehNearBasePass.initialize(renderer, alpha, frameBufferType);\n    this.bokehNearFillPass.initialize(renderer, alpha, frameBufferType);\n    this.bokehFarBasePass.initialize(renderer, alpha, frameBufferType);\n    this.bokehFarFillPass.initialize(renderer, alpha, frameBufferType);\n    this.blurPass.initialize(renderer, alpha, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType);\n    if (renderer.capabilities.logarithmicDepthBuffer) {\n      this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = \"1\";\n    }\n    if (frameBufferType !== void 0) {\n      this.renderTarget.texture.type = frameBufferType;\n      this.renderTargetNear.texture.type = frameBufferType;\n      this.renderTargetFar.texture.type = frameBufferType;\n      this.renderTargetMasked.texture.type = frameBufferType;\n      if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        this.renderTarget.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        this.renderTargetNear.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        this.renderTargetFar.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        this.renderTargetMasked.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n      }\n    }\n  }\n};\n\n// src/effects/DotScreenEffect.js\n\n\n// src/effects/glsl/dot-screen.frag\nvar dot_screen_default = `uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}`;\n\n// src/effects/DotScreenEffect.js\nvar DotScreenEffect = class extends Effect {\n  /**\n   * Constructs a new dot screen effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.angle=1.57] - The angle of the dot pattern.\n   * @param {Number} [options.scale=1.0] - The scale of the dot pattern.\n   */\n  constructor({ blendFunction, angle = Math.PI * 0.5, scale = 1 } = {}) {\n    super(\"DotScreenEffect\", dot_screen_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"angle\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())],\n        [\"scale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(scale)]\n      ])\n    });\n    this.angle = angle;\n  }\n  /**\n   * The angle.\n   *\n   * @type {Number}\n   */\n  get angle() {\n    return Math.acos(this.uniforms.get(\"angle\").value.y);\n  }\n  set angle(value) {\n    this.uniforms.get(\"angle\").value.set(Math.sin(value), Math.cos(value));\n  }\n  /**\n   * Returns the pattern angle.\n   *\n   * @deprecated Use angle instead.\n   * @return {Number} The angle in radians.\n   */\n  getAngle() {\n    return this.angle;\n  }\n  /**\n   * Sets the pattern angle.\n   *\n   * @deprecated Use angle instead.\n   * @param {Number} value - The angle in radians.\n   */\n  setAngle(value) {\n    this.angle = value;\n  }\n  /**\n   * The scale.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.uniforms.get(\"scale\").value;\n  }\n  set scale(value) {\n    this.uniforms.get(\"scale\").value = value;\n  }\n};\n\n// src/effects/glsl/fxaa.frag\nvar fxaa_default = `#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\n#define ONE_OVER_TWELVE 0.08333333333333333\nvarying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;vec4 fxaa(const in vec4 inputColor,const in vec2 uv){float lumaCenter=luminance(inputColor.rgb);float lumaDown=luminance(texture2D(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture2D(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture2D(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture2D(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture2D(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture2D(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture2D(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture2D(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?texelSize.y:texelSize.x;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(texelSize.x,0.0):vec2(0.0,texelSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(inputBuffer,finalUv);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=fxaa(inputColor,uv);}`;\n\n// src/effects/glsl/fxaa.vert\nvar fxaa_default2 = `varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*texelSize;vUvUp=uv+vec2(0.0,1.0)*texelSize;vUvRight=uv+vec2(1.0,0.0)*texelSize;vUvLeft=uv+vec2(-1.0,0.0)*texelSize;vUvDownLeft=uv+vec2(-1.0,-1.0)*texelSize;vUvUpRight=uv+vec2(1.0,1.0)*texelSize;vUvUpLeft=uv+vec2(-1.0,1.0)*texelSize;vUvDownRight=uv+vec2(1.0,-1.0)*texelSize;}`;\n\n// src/effects/FXAAEffect.js\nvar FXAAEffect = class extends Effect {\n  /**\n   * Constructs a new FXAA effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   */\n  constructor({ blendFunction = BlendFunction.SRC } = {}) {\n    super(\"FXAAEffect\", fxaa_default, {\n      vertexShader: fxaa_default2,\n      blendFunction,\n      defines: /* @__PURE__ */ new Map([\n        [\"EDGE_THRESHOLD_MIN\", \"0.0312\"],\n        [\"EDGE_THRESHOLD_MAX\", \"0.125\"],\n        [\"SUBPIXEL_QUALITY\", \"0.75\"],\n        [\"SAMPLES\", \"12\"]\n      ])\n    });\n  }\n  /**\n   * The minimum edge detection threshold. Range is [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get minEdgeThreshold() {\n    return Number(this.defines.get(\"EDGE_THRESHOLD_MIN\"));\n  }\n  set minEdgeThreshold(value) {\n    this.defines.set(\"EDGE_THRESHOLD_MIN\", value.toFixed(12));\n    this.setChanged();\n  }\n  /**\n   * The maximum edge detection threshold. Range is [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get maxEdgeThreshold() {\n    return Number(this.defines.get(\"EDGE_THRESHOLD_MAX\"));\n  }\n  set maxEdgeThreshold(value) {\n    this.defines.set(\"EDGE_THRESHOLD_MAX\", value.toFixed(12));\n    this.setChanged();\n  }\n  /**\n   * The subpixel blend quality. Range is [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get subpixelQuality() {\n    return Number(this.defines.get(\"SUBPIXEL_QUALITY\"));\n  }\n  set subpixelQuality(value) {\n    this.defines.set(\"SUBPIXEL_QUALITY\", value.toFixed(12));\n    this.setChanged();\n  }\n  /**\n   * The maximum amount of edge detection samples.\n   *\n   * @type {Number}\n   */\n  get samples() {\n    return Number(this.defines.get(\"SAMPLES\"));\n  }\n  set samples(value) {\n    this.defines.set(\"SAMPLES\", value.toFixed(0));\n    this.setChanged();\n  }\n};\n\n// src/effects/GammaCorrectionEffect.js\n\n\n// src/effects/glsl/gamma-correction.frag\nvar gamma_correction_default = `uniform float gamma;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=LinearToGamma(max(inputColor,0.0),gamma);}`;\n\n// src/effects/GammaCorrectionEffect.js\nvar GammaCorrectionEffect = class extends Effect {\n  /**\n   * Constructs a new gamma correction effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Number} [options.gamma=2.0] - The gamma factor.\n   */\n  constructor({ blendFunction = BlendFunction.SRC, gamma = 2 } = {}) {\n    super(\"GammaCorrectionEffect\", gamma_correction_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"gamma\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(gamma)]\n      ])\n    });\n  }\n};\n\n// src/effects/GlitchEffect.js\n\n\n// src/enums/GlitchMode.js\nvar GlitchMode = {\n  DISABLED: 0,\n  SPORADIC: 1,\n  CONSTANT_MILD: 2,\n  CONSTANT_WILD: 3\n};\n\n// src/textures/NoiseTexture.js\n\nfunction getNoise(size, format, type) {\n  const channels = /* @__PURE__ */ new Map([\n    [three__WEBPACK_IMPORTED_MODULE_0__.RedFormat, 1],\n    [three__WEBPACK_IMPORTED_MODULE_0__.RGFormat, 2],\n    [three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, 4]\n  ]);\n  let data;\n  if (!channels.has(format)) {\n    console.error(\"Invalid noise texture format\");\n  }\n  if (type === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n    data = new Uint8Array(size * channels.get(format));\n    for (let i = 0, l = data.length; i < l; ++i) {\n      data[i] = Math.random() * 255 + 0.5;\n    }\n  } else {\n    data = new Float32Array(size * channels.get(format));\n    for (let i = 0, l = data.length; i < l; ++i) {\n      data[i] = Math.random();\n    }\n  }\n  return data;\n}\nvar NoiseTexture = class extends three__WEBPACK_IMPORTED_MODULE_0__.DataTexture {\n  /**\n   * Constructs a new noise texture.\n   *\n   * Supported formats are `RGBAFormat`, `RedFormat` and `RGFormat`.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   * @param {Number} [format=RedFormat] - The texture format.\n   * @param {Number} [type=UnsignedByteType] - The texture type.\n   */\n  constructor(width, height, format = three__WEBPACK_IMPORTED_MODULE_0__.RedFormat, type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n    super(getNoise(width * height, format, type), width, height, format, type);\n    this.needsUpdate = true;\n  }\n};\n\n// src/effects/glsl/glitch.frag\nvar glitch_default = `uniform lowp sampler2D perturbationMap;uniform bool active;uniform float columns;uniform float random;uniform vec2 seeds;uniform vec2 distortion;void mainUv(inout vec2 uv){if(active){if(uv.y<distortion.x+columns&&uv.y>distortion.x-columns*random){float sx=clamp(ceil(seeds.x),0.0,1.0);uv.y=sx*(1.0-(uv.y+distortion.y))+(1.0-sx)*distortion.y;}if(uv.x<distortion.y+columns&&uv.x>distortion.y-columns*random){float sy=clamp(ceil(seeds.y),0.0,1.0);uv.x=sy*distortion.x+(1.0-sy)*(1.0-(uv.x+distortion.x));}vec2 normal=texture2D(perturbationMap,uv*random*random).rg;uv+=normal*seeds*(random*0.2);}}`;\n\n// src/effects/GlitchEffect.js\nvar textureTag = \"Glitch.Generated\";\nfunction randomFloat(low, high) {\n  return low + Math.random() * (high - low);\n}\nvar GlitchEffect = class extends Effect {\n  /**\n   * Constructs a new glitch effect.\n   *\n   * TODO Change ratio to 0.15.\n   * @param {Object} [options] - The options.\n   * @param {Vector2} [options.chromaticAberrationOffset] - A chromatic aberration offset. If provided, the glitch effect will influence this offset.\n   * @param {Vector2} [options.delay] - The minimum and maximum delay between glitch activations in seconds.\n   * @param {Vector2} [options.duration] - The minimum and maximum duration of a glitch in seconds.\n   * @param {Vector2} [options.strength] - The strength of weak and strong glitches.\n   * @param {Texture} [options.perturbationMap] - A perturbation map. If none is provided, a noise texture will be created.\n   * @param {Number} [options.dtSize=64] - The size of the generated noise map. Will be ignored if a perturbation map is provided.\n   * @param {Number} [options.columns=0.05] - The scale of the blocky glitch columns.\n   * @param {Number} [options.ratio=0.85] - The threshold for strong glitches.\n   */\n  constructor({\n    chromaticAberrationOffset = null,\n    delay = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1.5, 3.5),\n    duration = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.6, 1),\n    strength = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.3, 1),\n    columns = 0.05,\n    ratio = 0.85,\n    perturbationMap = null,\n    dtSize = 64\n  } = {}) {\n    super(\"GlitchEffect\", glitch_default, {\n      uniforms: /* @__PURE__ */ new Map([\n        [\"perturbationMap\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"columns\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(columns)],\n        [\"active\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(false)],\n        [\"random\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)],\n        [\"seeds\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())],\n        [\"distortion\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())]\n      ])\n    });\n    if (perturbationMap === null) {\n      const map = new NoiseTexture(dtSize, dtSize, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);\n      map.name = textureTag;\n      this.perturbationMap = map;\n    } else {\n      this.perturbationMap = perturbationMap;\n    }\n    this.time = 0;\n    this.distortion = this.uniforms.get(\"distortion\").value;\n    this.delay = delay;\n    this.duration = duration;\n    this.breakPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(\n      randomFloat(this.delay.x, this.delay.y),\n      randomFloat(this.duration.x, this.duration.y)\n    );\n    this.strength = strength;\n    this.mode = GlitchMode.SPORADIC;\n    this.ratio = ratio;\n    this.chromaticAberrationOffset = chromaticAberrationOffset;\n  }\n  /**\n   * Random number seeds.\n   *\n   * @type {Vector2}\n   * @private\n   */\n  get seeds() {\n    return this.uniforms.get(\"seeds\").value;\n  }\n  /**\n   * Indicates whether the glitch effect is currently active.\n   *\n   * @type {Boolean}\n   */\n  get active() {\n    return this.uniforms.get(\"active\").value;\n  }\n  /**\n   * Indicates whether the glitch effect is currently active.\n   *\n   * @deprecated Use active instead.\n   * @return {Boolean} Whether the glitch effect is active.\n   */\n  isActive() {\n    return this.active;\n  }\n  /**\n   * The minimum delay between glitch activations.\n   *\n   * @type {Number}\n   */\n  get minDelay() {\n    return this.delay.x;\n  }\n  set minDelay(value) {\n    this.delay.x = value;\n  }\n  /**\n   * Returns the minimum delay between glitch activations.\n   *\n   * @deprecated Use minDelay instead.\n   * @return {Number} The minimum delay in seconds.\n   */\n  getMinDelay() {\n    return this.delay.x;\n  }\n  /**\n   * Sets the minimum delay between glitch activations.\n   *\n   * @deprecated Use minDelay instead.\n   * @param {Number} value - The minimum delay in seconds.\n   */\n  setMinDelay(value) {\n    this.delay.x = value;\n  }\n  /**\n   * The maximum delay between glitch activations.\n   *\n   * @type {Number}\n   */\n  get maxDelay() {\n    return this.delay.y;\n  }\n  set maxDelay(value) {\n    this.delay.y = value;\n  }\n  /**\n   * Returns the maximum delay between glitch activations.\n   *\n   * @deprecated Use maxDelay instead.\n   * @return {Number} The maximum delay in seconds.\n   */\n  getMaxDelay() {\n    return this.delay.y;\n  }\n  /**\n   * Sets the maximum delay between glitch activations.\n   *\n   * @deprecated Use maxDelay instead.\n   * @param {Number} value - The maximum delay in seconds.\n   */\n  setMaxDelay(value) {\n    this.delay.y = value;\n  }\n  /**\n   * The minimum duration of sporadic glitches.\n   *\n   * @type {Number}\n   */\n  get minDuration() {\n    return this.duration.x;\n  }\n  set minDuration(value) {\n    this.duration.x = value;\n  }\n  /**\n   * Returns the minimum duration of sporadic glitches.\n   *\n   * @deprecated Use minDuration instead.\n   * @return {Number} The minimum duration in seconds.\n   */\n  getMinDuration() {\n    return this.duration.x;\n  }\n  /**\n   * Sets the minimum duration of sporadic glitches.\n   *\n   * @deprecated Use minDuration instead.\n   * @param {Number} value - The minimum duration in seconds.\n   */\n  setMinDuration(value) {\n    this.duration.x = value;\n  }\n  /**\n   * The maximum duration of sporadic glitches.\n   *\n   * @type {Number}\n   */\n  get maxDuration() {\n    return this.duration.y;\n  }\n  set maxDuration(value) {\n    this.duration.y = value;\n  }\n  /**\n   * Returns the maximum duration of sporadic glitches.\n   *\n   * @deprecated Use maxDuration instead.\n   * @return {Number} The maximum duration in seconds.\n   */\n  getMaxDuration() {\n    return this.duration.y;\n  }\n  /**\n   * Sets the maximum duration of sporadic glitches.\n   *\n   * @deprecated Use maxDuration instead.\n   * @param {Number} value - The maximum duration in seconds.\n   */\n  setMaxDuration(value) {\n    this.duration.y = value;\n  }\n  /**\n   * The strength of weak glitches.\n   *\n   * @type {Number}\n   */\n  get minStrength() {\n    return this.strength.x;\n  }\n  set minStrength(value) {\n    this.strength.x = value;\n  }\n  /**\n   * Returns the strength of weak glitches.\n   *\n   * @deprecated Use minStrength instead.\n   * @return {Number} The strength.\n   */\n  getMinStrength() {\n    return this.strength.x;\n  }\n  /**\n   * Sets the strength of weak glitches.\n   *\n   * @deprecated Use minStrength instead.\n   * @param {Number} value - The strength.\n   */\n  setMinStrength(value) {\n    this.strength.x = value;\n  }\n  /**\n   * The strength of strong glitches.\n   *\n   * @type {Number}\n   */\n  get maxStrength() {\n    return this.strength.y;\n  }\n  set maxStrength(value) {\n    this.strength.y = value;\n  }\n  /**\n   * Returns the strength of strong glitches.\n   *\n   * @deprecated Use maxStrength instead.\n   * @return {Number} The strength.\n   */\n  getMaxStrength() {\n    return this.strength.y;\n  }\n  /**\n   * Sets the strength of strong glitches.\n   *\n   * @deprecated Use maxStrength instead.\n   * @param {Number} value - The strength.\n   */\n  setMaxStrength(value) {\n    this.strength.y = value;\n  }\n  /**\n   * Returns the current glitch mode.\n   *\n   * @deprecated Use mode instead.\n   * @return {GlitchMode} The mode.\n   */\n  getMode() {\n    return this.mode;\n  }\n  /**\n   * Sets the current glitch mode.\n   *\n   * @deprecated Use mode instead.\n   * @param {GlitchMode} value - The mode.\n   */\n  setMode(value) {\n    this.mode = value;\n  }\n  /**\n   * Returns the glitch ratio.\n   *\n   * @deprecated Use ratio instead.\n   * @return {Number} The ratio.\n   */\n  getGlitchRatio() {\n    return 1 - this.ratio;\n  }\n  /**\n   * Sets the ratio of weak (0.0) and strong (1.0) glitches.\n   *\n   * @deprecated Use ratio instead.\n   * @param {Number} value - The ratio. Range is [0.0, 1.0].\n   */\n  setGlitchRatio(value) {\n    this.ratio = Math.min(Math.max(1 - value, 0), 1);\n  }\n  /**\n   * The glitch column size.\n   *\n   * @type {Number}\n   */\n  get columns() {\n    return this.uniforms.get(\"columns\").value;\n  }\n  set columns(value) {\n    this.uniforms.get(\"columns\").value = value;\n  }\n  /**\n   * Returns the glitch column size.\n   *\n   * @deprecated Use columns instead.\n   * @return {Number} The glitch column size.\n   */\n  getGlitchColumns() {\n    return this.columns;\n  }\n  /**\n   * Sets the glitch column size.\n   *\n   * @deprecated Use columns instead.\n   * @param {Number} value - The glitch column size.\n   */\n  setGlitchColumns(value) {\n    this.columns = value;\n  }\n  /**\n   * Returns the chromatic aberration offset.\n   *\n   * @deprecated Use chromaticAberrationOffset instead.\n   * @return {Vector2} The offset.\n   */\n  getChromaticAberrationOffset() {\n    return this.chromaticAberrationOffset;\n  }\n  /**\n   * Sets the chromatic aberration offset.\n   *\n   * @deprecated Use chromaticAberrationOffset instead.\n   * @param {Vector2} value - The offset.\n   */\n  setChromaticAberrationOffset(value) {\n    this.chromaticAberrationOffset = value;\n  }\n  /**\n   * The perturbation map.\n   *\n   * @type {Texture}\n   */\n  get perturbationMap() {\n    return this.uniforms.get(\"perturbationMap\").value;\n  }\n  set perturbationMap(value) {\n    const currentMap = this.perturbationMap;\n    if (currentMap !== null && currentMap.name === textureTag) {\n      currentMap.dispose();\n    }\n    value.minFilter = value.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n    value.wrapS = value.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n    value.generateMipmaps = false;\n    this.uniforms.get(\"perturbationMap\").value = value;\n  }\n  /**\n   * Returns the current perturbation map.\n   *\n   * @deprecated Use perturbationMap instead.\n   * @return {Texture} The current perturbation map.\n   */\n  getPerturbationMap() {\n    return this.perturbationMap;\n  }\n  /**\n   * Replaces the current perturbation map with the given one.\n   *\n   * The current map will be disposed if it was generated by this effect.\n   *\n   * @deprecated Use perturbationMap instead.\n   * @param {Texture} value - The new perturbation map.\n   */\n  setPerturbationMap(value) {\n    this.perturbationMap = value;\n  }\n  /**\n   * Generates a perturbation map.\n   *\n   * @deprecated Use NoiseTexture instead.\n   * @param {Number} [value=64] - The texture size.\n   * @return {DataTexture} The perturbation map.\n   */\n  generatePerturbationMap(value = 64) {\n    const map = new NoiseTexture(value, value, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);\n    map.name = textureTag;\n    return map;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const mode = this.mode;\n    const breakPoint = this.breakPoint;\n    const offset = this.chromaticAberrationOffset;\n    const s = this.strength;\n    let time = this.time;\n    let active = false;\n    let r = 0, a = 0;\n    let trigger;\n    if (mode !== GlitchMode.DISABLED) {\n      if (mode === GlitchMode.SPORADIC) {\n        time += deltaTime;\n        trigger = time > breakPoint.x;\n        if (time >= breakPoint.x + breakPoint.y) {\n          breakPoint.set(\n            randomFloat(this.delay.x, this.delay.y),\n            randomFloat(this.duration.x, this.duration.y)\n          );\n          time = 0;\n        }\n      }\n      r = Math.random();\n      this.uniforms.get(\"random\").value = r;\n      if (trigger && r > this.ratio || mode === GlitchMode.CONSTANT_WILD) {\n        active = true;\n        r *= s.y * 0.03;\n        a = randomFloat(-Math.PI, Math.PI);\n        this.seeds.set(randomFloat(-s.y, s.y), randomFloat(-s.y, s.y));\n        this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));\n      } else if (trigger || mode === GlitchMode.CONSTANT_MILD) {\n        active = true;\n        r *= s.x * 0.03;\n        a = randomFloat(-Math.PI, Math.PI);\n        this.seeds.set(randomFloat(-s.x, s.x), randomFloat(-s.x, s.x));\n        this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));\n      }\n      this.time = time;\n    }\n    if (offset !== null) {\n      if (active) {\n        offset.set(Math.cos(a), Math.sin(a)).multiplyScalar(r);\n      } else {\n        offset.set(0, 0);\n      }\n    }\n    this.uniforms.get(\"active\").value = active;\n  }\n  /**\n   * Deletes generated resources.\n   */\n  dispose() {\n    const map = this.perturbationMap;\n    if (map !== null && map.name === textureTag) {\n      map.dispose();\n    }\n  }\n};\n\n// src/effects/GodRaysEffect.js\n\n\n// src/materials/DepthMaskMaterial.js\n\n\n// src/enums/DepthTestStrategy.js\nvar DepthTestStrategy = {\n  DEFAULT: 0,\n  KEEP_MAX_DEPTH: 1,\n  DISCARD_MAX_DEPTH: 2\n};\n\n// src/materials/glsl/depth-mask.frag\nvar depth_mask_default = `#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;\n#else\nuniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;\n#endif\nuniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}varying vec2 vUv;void main(){vec2 depth;\n#if DEPTH_PACKING_0 == 3201\ndepth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));\n#else\ndepth.x=texture2D(depthBuffer0,vUv).r;\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;\n#endif\n#endif\n#if DEPTH_PACKING_1 == 3201\ndepth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));\n#else\ndepth.y=texture2D(depthBuffer1,vUv).r;\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;\n#endif\n#endif\nbool isMaxDepth=(depth.x==1.0);\n#ifdef PERSPECTIVE_CAMERA\ndepth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);\n#endif\n#if DEPTH_TEST_STRATEGY == 0\nbool keep=depthTest(depth.x,depth.y);\n#elif DEPTH_TEST_STRATEGY == 1\nbool keep=isMaxDepth||depthTest(depth.x,depth.y);\n#else\nbool keep=!isMaxDepth&&depthTest(depth.x,depth.y);\n#endif\nif(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}`;\n\n// src/materials/DepthMaskMaterial.js\nvar DepthMaskMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new depth mask material.\n   */\n  constructor() {\n    super({\n      name: \"DepthMaskMaterial\",\n      defines: {\n        DEPTH_EPSILON: \"0.0001\",\n        DEPTH_PACKING_0: \"0\",\n        DEPTH_PACKING_1: \"0\",\n        DEPTH_TEST_STRATEGY: DepthTestStrategy.KEEP_MAX_DEPTH\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        depthBuffer0: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        depthBuffer1: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        cameraNearFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1))\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: depth_mask_default,\n      vertexShader: common_default\n    });\n    this.depthMode = three__WEBPACK_IMPORTED_MODULE_0__.LessDepth;\n  }\n  /**\n   * The primary depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer0(value) {\n    this.uniforms.depthBuffer0.value = value;\n  }\n  /**\n   * The primary depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking0(value) {\n    this.defines.DEPTH_PACKING_0 = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the base depth buffer.\n   *\n   * @deprecated Use depthBuffer0 and depthPacking0 instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer0(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer0 = buffer;\n    this.depthPacking0 = depthPacking;\n  }\n  /**\n   * The secondary depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer1(value) {\n    this.uniforms.depthBuffer1.value = value;\n  }\n  /**\n   * The secondary depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking1(value) {\n    this.defines.DEPTH_PACKING_1 = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer that will be compared with the base depth buffer.\n   *\n   * @deprecated Use depthBuffer1 and depthPacking1 instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer1(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer1 = buffer;\n    this.depthPacking1 = depthPacking;\n  }\n  /**\n   * The strategy for handling maximum depth.\n   *\n   * @type {DepthTestStrategy}\n   */\n  get maxDepthStrategy() {\n    return Number(this.defines.DEPTH_TEST_STRATEGY);\n  }\n  set maxDepthStrategy(value) {\n    this.defines.DEPTH_TEST_STRATEGY = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Indicates whether maximum depth values should be preserved.\n   *\n   * @type {Boolean}\n   * @deprecated Use maxDepthStrategy instead.\n   */\n  get keepFar() {\n    return this.maxDepthStrategy;\n  }\n  set keepFar(value) {\n    this.maxDepthStrategy = value ? DepthTestStrategy.KEEP_MAX_DEPTH : DepthTestStrategy.DISCARD_MAX_DEPTH;\n  }\n  /**\n   * Returns the strategy for dealing with maximum depth values.\n   *\n   * @deprecated Use maxDepthStrategy instead.\n   * @return {DepthTestStrategy} The strategy.\n   */\n  getMaxDepthStrategy() {\n    return this.maxDepthStrategy;\n  }\n  /**\n   * Sets the strategy for dealing with maximum depth values.\n   *\n   * @deprecated Use maxDepthStrategy instead.\n   * @param {DepthTestStrategy} value - The strategy.\n   */\n  setMaxDepthStrategy(value) {\n    this.maxDepthStrategy = value;\n  }\n  /**\n   * A small error threshold that is used for `EqualDepth` and `NotEqualDepth` tests. Default is `1e-4`.\n   *\n   * @type {Number}\n   */\n  get epsilon() {\n    return Number(this.defines.DEPTH_EPSILON);\n  }\n  set epsilon(value) {\n    this.defines.DEPTH_EPSILON = value.toFixed(16);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the current error threshold for depth comparisons.\n   *\n   * @deprecated Use epsilon instead.\n   * @return {Number} The error threshold.\n   */\n  getEpsilon() {\n    return this.epsilon;\n  }\n  /**\n   * Sets the depth comparison error threshold.\n   *\n   * @deprecated Use epsilon instead.\n   * @param {Number} value - The new error threshold.\n   */\n  setEpsilon(value) {\n    this.epsilon = value;\n  }\n  /**\n   * The depth mode.\n   *\n   * @see https://threejs.org/docs/#api/en/constants/Materials\n   * @type {DepthModes}\n   */\n  get depthMode() {\n    return Number(this.defines.DEPTH_MODE);\n  }\n  set depthMode(value) {\n    let depthTest;\n    switch (value) {\n      case three__WEBPACK_IMPORTED_MODULE_0__.NeverDepth:\n        depthTest = \"false\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.AlwaysDepth:\n        depthTest = \"true\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.EqualDepth:\n        depthTest = \"abs(d1 - d0) <= DEPTH_EPSILON\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.NotEqualDepth:\n        depthTest = \"abs(d1 - d0) > DEPTH_EPSILON\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.LessDepth:\n        depthTest = \"d0 > d1\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.LessEqualDepth:\n        depthTest = \"d0 >= d1\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.GreaterEqualDepth:\n        depthTest = \"d0 <= d1\";\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.GreaterDepth:\n      default:\n        depthTest = \"d0 < d1\";\n        break;\n    }\n    this.defines.DEPTH_MODE = value.toFixed(0);\n    this.defines[\"depthTest(d0, d1)\"] = depthTest;\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the current depth mode.\n   *\n   * @deprecated Use depthMode instead.\n   * @return {DepthModes} The depth mode. Default is `LessDepth`.\n   */\n  getDepthMode() {\n    return this.depthMode;\n  }\n  /**\n   * Sets the depth mode.\n   *\n   * @deprecated Use depthMode instead.\n   * @param {DepthModes} mode - The depth mode.\n   */\n  setDepthMode(mode) {\n    this.depthMode = mode;\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */\n  adoptCameraSettings(camera) {\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  copyCameraSettings(camera) {\n    if (camera) {\n      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);\n      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n        this.defines.PERSPECTIVE_CAMERA = \"1\";\n      } else {\n        delete this.defines.PERSPECTIVE_CAMERA;\n      }\n      this.needsUpdate = true;\n    }\n  }\n};\n\n// src/materials/GodRaysMaterial.js\n\n\n// src/materials/glsl/convolution.god-rays.frag\nvar convolution_god_rays_default = `#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec2 lightPosition;uniform float exposure;uniform float decay;uniform float density;uniform float weight;uniform float clampMax;varying vec2 vUv;void main(){vec2 coord=vUv;vec2 delta=lightPosition-coord;delta*=1.0/SAMPLES_FLOAT*density;float illuminationDecay=1.0;vec4 color=vec4(0.0);for(int i=0;i<SAMPLES_INT;++i){coord+=delta;vec4 texel=texture2D(inputBuffer,coord);texel*=illuminationDecay*weight;color+=texel;illuminationDecay*=decay;}gl_FragColor=clamp(color*exposure,0.0,clampMax);\n#include <dithering_fragment>\n}`;\n\n// src/materials/GodRaysMaterial.js\nvar GodRaysMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new god rays material.\n   *\n   * TODO Remove lightPosition param.\n   * @param {Vector2} lightPosition - Deprecated.\n   */\n  constructor(lightPosition) {\n    super({\n      name: \"GodRaysMaterial\",\n      defines: {\n        SAMPLES_INT: \"60\",\n        SAMPLES_FLOAT: \"60.0\"\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        lightPosition: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(lightPosition),\n        density: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        decay: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        weight: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        exposure: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        clampMax: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_god_rays_default,\n      vertexShader: common_default\n    });\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The screen space position of the light source.\n   *\n   * @type {Vector2}\n   */\n  get lightPosition() {\n    return this.uniforms.lightPosition.value;\n  }\n  /**\n   * Returns the screen space position of the light source.\n   *\n   * @deprecated Use lightPosition instead.\n   * @return {Vector2} The position.\n   */\n  getLightPosition() {\n    return this.uniforms.lightPosition.value;\n  }\n  /**\n   * Sets the screen space position of the light source.\n   *\n   * @deprecated Use lightPosition instead.\n   * @param {Vector2} value - The position.\n   */\n  setLightPosition(value) {\n    this.uniforms.lightPosition.value = value;\n  }\n  /**\n   * The density.\n   *\n   * @type {Number}\n   */\n  get density() {\n    return this.uniforms.density.value;\n  }\n  set density(value) {\n    this.uniforms.density.value = value;\n  }\n  /**\n   * Returns the density.\n   *\n   * @deprecated Use density instead.\n   * @return {Number} The density.\n   */\n  getDensity() {\n    return this.uniforms.density.value;\n  }\n  /**\n   * Sets the density.\n   *\n   * @deprecated Use density instead.\n   * @param {Number} value - The density.\n   */\n  setDensity(value) {\n    this.uniforms.density.value = value;\n  }\n  /**\n   * The decay.\n   *\n   * @type {Number}\n   */\n  get decay() {\n    return this.uniforms.decay.value;\n  }\n  set decay(value) {\n    this.uniforms.decay.value = value;\n  }\n  /**\n   * Returns the decay.\n   *\n   * @deprecated Use decay instead.\n   * @return {Number} The decay.\n   */\n  getDecay() {\n    return this.uniforms.decay.value;\n  }\n  /**\n   * Sets the decay.\n   *\n   * @deprecated Use decay instead.\n   * @param {Number} value - The decay.\n   */\n  setDecay(value) {\n    this.uniforms.decay.value = value;\n  }\n  /**\n   * The weight.\n   *\n   * @type {Number}\n   */\n  get weight() {\n    return this.uniforms.weight.value;\n  }\n  set weight(value) {\n    this.uniforms.weight.value = value;\n  }\n  /**\n   * Returns the weight.\n   *\n   * @deprecated Use weight instead.\n   * @return {Number} The weight.\n   */\n  getWeight() {\n    return this.uniforms.weight.value;\n  }\n  /**\n   * Sets the weight.\n   *\n   * @deprecated Use weight instead.\n   * @param {Number} value - The weight.\n   */\n  setWeight(value) {\n    this.uniforms.weight.value = value;\n  }\n  /**\n   * The exposure.\n   *\n   * @type {Number}\n   */\n  get exposure() {\n    return this.uniforms.exposure.value;\n  }\n  set exposure(value) {\n    this.uniforms.exposure.value = value;\n  }\n  /**\n   * Returns the exposure.\n   *\n   * @deprecated Use exposure instead.\n   * @return {Number} The exposure.\n   */\n  getExposure() {\n    return this.uniforms.exposure.value;\n  }\n  /**\n   * Sets the exposure.\n   *\n   * @deprecated Use exposure instead.\n   * @param {Number} value - The exposure.\n   */\n  setExposure(value) {\n    this.uniforms.exposure.value = value;\n  }\n  /**\n   * The maximum light intensity.\n   *\n   * @type {Number}\n   */\n  get maxIntensity() {\n    return this.uniforms.clampMax.value;\n  }\n  set maxIntensity(value) {\n    this.uniforms.clampMax.value = value;\n  }\n  /**\n   * Returns the maximum light intensity.\n   *\n   * @deprecated Use maxIntensity instead.\n   * @return {Number} The maximum light intensity.\n   */\n  getMaxIntensity() {\n    return this.uniforms.clampMax.value;\n  }\n  /**\n   * Sets the maximum light intensity.\n   *\n   * @deprecated Use maxIntensity instead.\n   * @param {Number} value - The maximum light intensity.\n   */\n  setMaxIntensity(value) {\n    this.uniforms.clampMax.value = value;\n  }\n  /**\n   * The amount of samples per pixel.\n   *\n   * @type {Number}\n   */\n  get samples() {\n    return Number(this.defines.SAMPLES_INT);\n  }\n  set samples(value) {\n    const s = Math.floor(value);\n    this.defines.SAMPLES_INT = s.toFixed(0);\n    this.defines.SAMPLES_FLOAT = s.toFixed(1);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the amount of samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @return {Number} The sample count.\n   */\n  getSamples() {\n    return this.samples;\n  }\n  /**\n   * Sets the amount of samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @param {Number} value - The sample count.\n   */\n  setSamples(value) {\n    this.samples = value;\n  }\n};\n\n// src/passes/RenderPass.js\nvar RenderPass = class extends Pass {\n  /**\n   * Constructs a new render pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use to render the scene.\n   * @param {Material} [overrideMaterial=null] - An override material.\n   */\n  constructor(scene, camera, overrideMaterial = null) {\n    super(\"RenderPass\", scene, camera);\n    this.needsSwap = false;\n    this.clearPass = new ClearPass();\n    this.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);\n    this.ignoreBackground = false;\n    this.skipShadowMapUpdate = false;\n    this.selection = null;\n  }\n  set mainScene(value) {\n    this.scene = value;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n  }\n  get renderToScreen() {\n    return super.renderToScreen;\n  }\n  set renderToScreen(value) {\n    super.renderToScreen = value;\n    this.clearPass.renderToScreen = value;\n  }\n  /**\n   * The current override material.\n   *\n   * @type {Material}\n   */\n  get overrideMaterial() {\n    const manager = this.overrideMaterialManager;\n    return manager !== null ? manager.material : null;\n  }\n  set overrideMaterial(value) {\n    const manager = this.overrideMaterialManager;\n    if (value !== null) {\n      if (manager !== null) {\n        manager.setMaterial(value);\n      } else {\n        this.overrideMaterialManager = new OverrideMaterialManager(value);\n      }\n    } else if (manager !== null) {\n      manager.dispose();\n      this.overrideMaterialManager = null;\n    }\n  }\n  /**\n   * Returns the current override material.\n   *\n   * @deprecated Use overrideMaterial instead.\n   * @return {Material} The material.\n   */\n  getOverrideMaterial() {\n    return this.overrideMaterial;\n  }\n  /**\n   * Sets the override material.\n   *\n   * @deprecated Use overrideMaterial instead.\n   * @return {Material} value - The material.\n   */\n  setOverrideMaterial(value) {\n    this.overrideMaterial = value;\n  }\n  /**\n   * Indicates whether the target buffer should be cleared before rendering.\n   *\n   * @type {Boolean}\n   * @deprecated Use clearPass.enabled instead.\n   */\n  get clear() {\n    return this.clearPass.enabled;\n  }\n  set clear(value) {\n    this.clearPass.enabled = value;\n  }\n  /**\n   * Returns the selection. Default is `null` (no restriction).\n   *\n   * @deprecated Use selection instead.\n   * @return {Selection} The selection.\n   */\n  getSelection() {\n    return this.selection;\n  }\n  /**\n   * Sets the selection. Set to `null` to disable.\n   *\n   * @deprecated Use selection instead.\n   * @param {Selection} value - The selection.\n   */\n  setSelection(value) {\n    this.selection = value;\n  }\n  /**\n   * Indicates whether the scene background is disabled.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @return {Boolean} Whether the scene background is disabled.\n   */\n  isBackgroundDisabled() {\n    return this.ignoreBackground;\n  }\n  /**\n   * Enables or disables the scene background.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @param {Boolean} value - Whether the scene background should be disabled.\n   */\n  setBackgroundDisabled(value) {\n    this.ignoreBackground = value;\n  }\n  /**\n   * Indicates whether the shadow map auto update is disabled.\n   *\n   * @deprecated Use skipShadowMapUpdate instead.\n   * @return {Boolean} Whether the shadow map update is disabled.\n   */\n  isShadowMapDisabled() {\n    return this.skipShadowMapUpdate;\n  }\n  /**\n   * Enables or disables the shadow map auto update.\n   *\n   * @deprecated Use skipShadowMapUpdate instead.\n   * @param {Boolean} value - Whether the shadow map auto update should be disabled.\n   */\n  setShadowMapDisabled(value) {\n    this.skipShadowMapUpdate = value;\n  }\n  /**\n   * Returns the clear pass.\n   *\n   * @deprecated Use clearPass.enabled instead.\n   * @return {ClearPass} The clear pass.\n   */\n  getClearPass() {\n    return this.clearPass;\n  }\n  /**\n   * Renders the scene.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const selection = this.selection;\n    const mask = camera.layers.mask;\n    const background = scene.background;\n    const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;\n    const renderTarget = this.renderToScreen ? null : inputBuffer;\n    if (selection !== null) {\n      camera.layers.set(selection.getLayer());\n    }\n    if (this.skipShadowMapUpdate) {\n      renderer.shadowMap.autoUpdate = false;\n    }\n    if (this.ignoreBackground || this.clearPass.overrideClearColor !== null) {\n      scene.background = null;\n    }\n    if (this.clearPass.enabled) {\n      this.clearPass.render(renderer, inputBuffer);\n    }\n    renderer.setRenderTarget(renderTarget);\n    if (this.overrideMaterialManager !== null) {\n      this.overrideMaterialManager.render(renderer, scene, camera);\n    } else {\n      renderer.render(scene, camera);\n    }\n    camera.layers.mask = mask;\n    scene.background = background;\n    renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;\n  }\n};\n\n// src/effects/glsl/god-rays.frag\nvar god_rays_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv);}`;\n\n// src/effects/GodRaysEffect.js\nvar v = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar m = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nvar GodRaysEffect = class extends Effect {\n  /**\n   * Constructs a new god rays effect.\n   *\n   * @param {Camera} [camera] - The main camera.\n   * @param {Mesh|Points} [lightSource] - The light source. Must not write depth and has to be flagged as transparent.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.\n   * @param {Number} [options.samples=60.0] - The number of samples per pixel.\n   * @param {Number} [options.density=0.96] - The density of the light rays.\n   * @param {Number} [options.decay=0.9] - An illumination decay factor.\n   * @param {Number} [options.weight=0.4] - A light ray weight factor.\n   * @param {Number} [options.exposure=0.6] - A constant attenuation coefficient.\n   * @param {Number} [options.clampMax=1.0] - An upper bound for the saturation of the overall effect.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   * @param {KernelSize} [options.kernelSize=KernelSize.SMALL] - The blur kernel size. Has no effect if blur is disabled.\n   * @param {Boolean} [options.blur=true] - Whether the god rays should be blurred to reduce artifacts.\n   */\n  constructor(camera, lightSource, {\n    blendFunction = BlendFunction.SCREEN,\n    samples = 60,\n    density = 0.96,\n    decay = 0.9,\n    weight = 0.4,\n    exposure = 0.6,\n    clampMax = 1,\n    blur = true,\n    kernelSize = KernelSize.SMALL,\n    resolutionScale = 0.5,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"GodRaysEffect\", god_rays_default, {\n      blendFunction,\n      attributes: EffectAttribute.DEPTH,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"map\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    this.camera = camera;\n    this._lightSource = lightSource;\n    this.lightSource = lightSource;\n    this.lightScene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n    this.screenPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetA.texture.name = \"GodRays.Target.A\";\n    this.renderTargetB = this.renderTargetA.clone();\n    this.renderTargetB.texture.name = \"GodRays.Target.B\";\n    this.uniforms.get(\"map\").value = this.renderTargetB.texture;\n    this.renderTargetLight = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1);\n    this.renderTargetLight.texture.name = \"GodRays.Light\";\n    this.renderTargetLight.depthTexture = new three__WEBPACK_IMPORTED_MODULE_0__.DepthTexture();\n    this.renderPassLight = new RenderPass(this.lightScene, camera);\n    this.renderPassLight.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n    this.clearPass = new ClearPass(true, false, false);\n    this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n    this.blurPass = new KawaseBlurPass({ kernelSize });\n    this.blurPass.enabled = blur;\n    this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());\n    const depthMaskMaterial = this.depthMaskMaterial;\n    depthMaskMaterial.depthBuffer1 = this.renderTargetLight.depthTexture;\n    depthMaskMaterial.copyCameraSettings(camera);\n    this.godRaysPass = new ShaderPass(new GodRaysMaterial(this.screenPosition));\n    const godRaysMaterial = this.godRaysMaterial;\n    godRaysMaterial.density = density;\n    godRaysMaterial.decay = decay;\n    godRaysMaterial.weight = weight;\n    godRaysMaterial.exposure = exposure;\n    godRaysMaterial.maxIntensity = clampMax;\n    godRaysMaterial.samples = samples;\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n  }\n  set mainCamera(value) {\n    this.camera = value;\n    this.renderPassLight.mainCamera = value;\n    this.depthMaskMaterial.copyCameraSettings(value);\n  }\n  /**\n   * Sets the light source.\n   *\n   * @type {Mesh|Points}\n   */\n  get lightSource() {\n    return this._lightSource;\n  }\n  set lightSource(value) {\n    this._lightSource = value;\n    if (value !== null) {\n      value.material.depthWrite = false;\n      value.material.transparent = true;\n    }\n  }\n  /**\n   * Returns the blur pass that reduces aliasing artifacts and makes the light softer.\n   *\n   * @deprecated Use blurPass instead.\n   * @return {KawaseBlurPass} The blur pass.\n   */\n  getBlurPass() {\n    return this.blurPass;\n  }\n  /**\n   * A texture that contains the intermediate result of this effect.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTargetB.texture;\n  }\n  /**\n   * Returns the god rays texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.texture;\n  }\n  /**\n   * The depth mask material.\n   *\n   * @type {DepthMaskMaterial}\n   * @private\n   */\n  get depthMaskMaterial() {\n    return this.depthMaskPass.fullscreenMaterial;\n  }\n  /**\n   * The internal god rays material.\n   *\n   * @type {GodRaysMaterial}\n   */\n  get godRaysMaterial() {\n    return this.godRaysPass.fullscreenMaterial;\n  }\n  /**\n   * Returns the god rays material.\n   *\n   * @deprecated Use godRaysMaterial instead.\n   * @return {GodRaysMaterial} The material.\n   */\n  getGodRaysMaterial() {\n    return this.godRaysMaterial;\n  }\n  /**\n   * Returns the resolution of this effect.\n   *\n   * @deprecated Use resolution instead.\n   * @return {GodRaysMaterial} The material.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.width instead.\n   */\n  get width() {\n    return this.resolution.width;\n  }\n  set width(value) {\n    this.resolution.preferredWidth = value;\n  }\n  /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.height instead.\n   */\n  get height() {\n    return this.resolution.height;\n  }\n  set height(value) {\n    this.resolution.preferredHeight = value;\n  }\n  /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */\n  get dithering() {\n    return this.godRaysMaterial.dithering;\n  }\n  set dithering(value) {\n    const material = this.godRaysMaterial;\n    material.dithering = value;\n    material.needsUpdate = true;\n  }\n  /**\n   * Indicates whether the god rays should be blurred to reduce artifacts.\n   *\n   * @type {Boolean}\n   * @deprecated Use blurPass.enabled instead.\n   */\n  get blur() {\n    return this.blurPass.enabled;\n  }\n  set blur(value) {\n    this.blurPass.enabled = value;\n  }\n  /**\n   * The blur kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated Use blurPass.kernelSize instead.\n   */\n  get kernelSize() {\n    return this.blurPass.kernelSize;\n  }\n  set kernelSize(value) {\n    this.blurPass.kernelSize = value;\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  getResolutionScale() {\n    return this.resolution.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  setResolutionScale(scale) {\n    this.resolution.scale = scale;\n  }\n  /**\n   * The number of samples per pixel.\n   *\n   * @type {Number}\n   * @deprecated Use godRaysMaterial.samples instead.\n   */\n  get samples() {\n    return this.godRaysMaterial.samples;\n  }\n  /**\n   * A higher sample count improves quality at the cost of performance.\n   *\n   * @type {Number}\n   * @deprecated Use godRaysMaterial.samples instead.\n   */\n  set samples(value) {\n    this.godRaysMaterial.samples = value;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {Number} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthMaskPass.fullscreenMaterial.depthBuffer0 = depthTexture;\n    this.depthMaskPass.fullscreenMaterial.depthPacking0 = depthPacking;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const lightSource = this.lightSource;\n    const parent = lightSource.parent;\n    const matrixAutoUpdate = lightSource.matrixAutoUpdate;\n    const renderTargetA = this.renderTargetA;\n    const renderTargetLight = this.renderTargetLight;\n    lightSource.material.depthWrite = true;\n    lightSource.matrixAutoUpdate = false;\n    lightSource.updateWorldMatrix(true, false);\n    if (parent !== null) {\n      if (!matrixAutoUpdate) {\n        m.copy(lightSource.matrix);\n      }\n      lightSource.matrix.copy(lightSource.matrixWorld);\n    }\n    this.lightScene.add(lightSource);\n    this.renderPassLight.render(renderer, renderTargetLight);\n    this.clearPass.render(renderer, renderTargetA);\n    this.depthMaskPass.render(renderer, renderTargetLight, renderTargetA);\n    lightSource.material.depthWrite = false;\n    lightSource.matrixAutoUpdate = matrixAutoUpdate;\n    if (parent !== null) {\n      if (!matrixAutoUpdate) {\n        lightSource.matrix.copy(m);\n      }\n      parent.add(lightSource);\n    }\n    v.setFromMatrixPosition(lightSource.matrixWorld).project(this.camera);\n    this.screenPosition.set(\n      Math.min(Math.max((v.x + 1) * 0.5, -1), 2),\n      Math.min(Math.max((v.y + 1) * 0.5, -1), 2)\n    );\n    if (this.blurPass.enabled) {\n      this.blurPass.render(renderer, renderTargetA, renderTargetA);\n    }\n    this.godRaysPass.render(renderer, renderTargetA, this.renderTargetB);\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.renderTargetA.setSize(w, h);\n    this.renderTargetB.setSize(w, h);\n    this.renderTargetLight.setSize(w, h);\n    this.blurPass.resolution.copy(resolution);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.blurPass.initialize(renderer, alpha, frameBufferType);\n    this.renderPassLight.initialize(renderer, alpha, frameBufferType);\n    this.depthMaskPass.initialize(renderer, alpha, frameBufferType);\n    this.godRaysPass.initialize(renderer, alpha, frameBufferType);\n    if (frameBufferType !== void 0) {\n      this.renderTargetA.texture.type = frameBufferType;\n      this.renderTargetB.texture.type = frameBufferType;\n      this.renderTargetLight.texture.type = frameBufferType;\n      if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        this.renderTargetA.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        this.renderTargetB.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        this.renderTargetLight.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n      }\n    }\n  }\n};\n\n// src/effects/GridEffect.js\n\n\n// src/effects/glsl/grid.frag\nvar grid_default = `uniform vec2 scale;uniform float lineWidth;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float grid=0.5-max(abs(mod(uv.x*scale.x,1.0)-0.5),abs(mod(uv.y*scale.y,1.0)-0.5));outputColor=vec4(vec3(smoothstep(0.0,lineWidth,grid)),inputColor.a);}`;\n\n// src/effects/GridEffect.js\nvar GridEffect = class extends Effect {\n  /**\n   * Constructs a new grid effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.\n   * @param {Number} [options.scale=1.0] - The scale of the grid pattern.\n   * @param {Number} [options.lineWidth=0.0] - The line width of the grid pattern.\n   */\n  constructor({ blendFunction = BlendFunction.OVERLAY, scale = 1, lineWidth = 0 } = {}) {\n    super(\"GridEffect\", grid_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"scale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())],\n        [\"lineWidth\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(lineWidth)]\n      ])\n    });\n    this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.s = 0;\n    this.scale = scale;\n    this.l = 0;\n    this.lineWidth = lineWidth;\n  }\n  /**\n   * The scale.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.s;\n  }\n  set scale(value) {\n    this.s = Math.max(value, 1e-6);\n    this.setSize(this.resolution.width, this.resolution.height);\n  }\n  /**\n   * Returns the current grid scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The grid scale.\n   */\n  getScale() {\n    return this.scale;\n  }\n  /**\n   * Sets the grid scale.\n   *\n   * @deprecated Use scale instead.\n   * @param {Number} value - The new grid scale.\n   */\n  setScale(value) {\n    this.scale = value;\n  }\n  /**\n   * The line width.\n   *\n   * @type {Number}\n   */\n  get lineWidth() {\n    return this.l;\n  }\n  set lineWidth(value) {\n    this.l = value;\n    this.setSize(this.resolution.width, this.resolution.height);\n  }\n  /**\n   * Returns the current grid line width.\n   *\n   * @deprecated Use lineWidth instead.\n   * @return {Number} The grid line width.\n   */\n  getLineWidth() {\n    return this.lineWidth;\n  }\n  /**\n   * Sets the grid line width.\n   *\n   * @deprecated Use lineWidth instead.\n   * @param {Number} value - The new grid line width.\n   */\n  setLineWidth(value) {\n    this.lineWidth = value;\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.resolution.set(width, height);\n    const aspect = width / height;\n    const scale = this.scale * (height * 0.125);\n    this.uniforms.get(\"scale\").value.set(aspect * scale, scale);\n    this.uniforms.get(\"lineWidth\").value = scale / height + this.lineWidth;\n  }\n};\n\n// src/effects/HueSaturationEffect.js\n\n\n// src/effects/glsl/hue-saturation.frag\nvar hue_saturation_default = `uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}`;\n\n// src/effects/HueSaturationEffect.js\nvar HueSaturationEffect = class extends Effect {\n  /**\n   * Constructs a new hue/saturation effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Number} [options.hue=0.0] - The hue in radians.\n   * @param {Number} [options.saturation=0.0] - The saturation factor, ranging from -1 to 1, where 0 means no change.\n   */\n  constructor({ blendFunction = BlendFunction.SRC, hue = 0, saturation = 0 } = {}) {\n    super(\"HueSaturationEffect\", hue_saturation_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"hue\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())],\n        [\"saturation\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(saturation)]\n      ])\n    });\n    this.hue = hue;\n  }\n  /**\n   * The saturation.\n   *\n   * @type {Number}\n   */\n  get saturation() {\n    return this.uniforms.get(\"saturation\").value;\n  }\n  set saturation(value) {\n    this.uniforms.get(\"saturation\").value = value;\n  }\n  /**\n   * Returns the saturation.\n   *\n   * @deprecated Use saturation instead.\n   * @return {Number} The saturation.\n   */\n  getSaturation() {\n    return this.saturation;\n  }\n  /**\n   * Sets the saturation.\n   *\n   * @deprecated Use saturation instead.\n   * @param {Number} value - The saturation.\n   */\n  setSaturation(value) {\n    this.saturation = value;\n  }\n  /**\n   * The hue.\n   *\n   * @type {Number}\n   */\n  get hue() {\n    const hue = this.uniforms.get(\"hue\").value;\n    return Math.acos((hue.x * 3 - 1) / 2);\n  }\n  set hue(value) {\n    const s = Math.sin(value), c2 = Math.cos(value);\n    this.uniforms.get(\"hue\").value.set(\n      (2 * c2 + 1) / 3,\n      (-Math.sqrt(3) * s - c2 + 1) / 3,\n      (Math.sqrt(3) * s - c2 + 1) / 3\n    );\n  }\n  /**\n   * Returns the hue.\n   *\n   * @deprecated Use hue instead.\n   * @return {Number} The hue in radians.\n   */\n  getHue() {\n    return this.hue;\n  }\n  /**\n   * Sets the hue.\n   *\n   * @deprecated Use hue instead.\n   * @param {Number} value - The hue in radians.\n   */\n  setHue(value) {\n    this.hue = value;\n  }\n};\n\n// src/effects/LensDistortionEffect.js\n\n\n// src/effects/glsl/lens-distortion.frag\nvar lens_distortion_default = `uniform vec2 distortion;uniform vec2 principalPoint;uniform vec2 focalLength;uniform float skew;float mask(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void mainUv(inout vec2 uv){vec2 xn=2.0*(uv.st-0.5);vec3 xDistorted=vec3((1.0+distortion*dot(xn,xn))*xn,1.0);mat3 kk=mat3(vec3(focalLength.x,0.0,0.0),vec3(skew*focalLength.x,focalLength.y,0.0),vec3(principalPoint.x,principalPoint.y,1.0));uv=(kk*xDistorted).xy*0.5+0.5;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=mask(uv)*inputColor;}`;\n\n// src/effects/LensDistortionEffect.js\nvar LensDistortionEffect = class extends Effect {\n  /**\n   * Constructs a new lens distortion effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Vector2} [options.distortion] - The distortion value.\n   * @param {Vector2} [options.principalPoint] - The center point.\n   * @param {Vector2} [options.focalLength] - The focal length.\n   * @param {Number} [options.skew=0] - The skew value.\n   */\n  constructor({\n    distortion = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0),\n    principalPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0),\n    focalLength = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1),\n    skew = 0\n  } = {}) {\n    super(\"LensDistortionEffect\", lens_distortion_default, {\n      uniforms: /* @__PURE__ */ new Map([\n        [\"distortion\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(distortion)],\n        [\"principalPoint\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(principalPoint)],\n        [\"focalLength\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focalLength)],\n        [\"skew\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(skew)]\n      ])\n    });\n  }\n  /**\n   * The radial distortion coefficients. Default is (0, 0).\n   *\n   * @type {Vector2}\n   */\n  get distortion() {\n    return this.uniforms.get(\"distortion\").value;\n  }\n  set distortion(value) {\n    this.uniforms.get(\"distortion\").value = value;\n  }\n  /**\n   * The principal point. Default is (0, 0).\n   *\n   * @type {Vector2}\n   */\n  get principalPoint() {\n    return this.uniforms.get(\"principalPoint\").value;\n  }\n  set principalPoint(value) {\n    this.uniforms.get(\"principalPoint\").value = value;\n  }\n  /**\n   * The focal length. Default is (1, 1).\n   *\n   * @type {Vector2}\n   */\n  get focalLength() {\n    return this.uniforms.get(\"focalLength\").value;\n  }\n  set focalLength(value) {\n    this.uniforms.get(\"focalLength\").value = value;\n  }\n  /**\n   * The skew factor in radians.\n   *\n   * @type {Number}\n   */\n  get skew() {\n    return this.uniforms.get(\"skew\").value;\n  }\n  set skew(value) {\n    this.uniforms.get(\"skew\").value = value;\n  }\n};\n\n// src/effects/LUT1DEffect.js\n\n\n// src/effects/glsl/lut-1d.frag\nvar lut_1d_default = `#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D lut;\n#else\nuniform mediump sampler2D lut;\n#endif\n#else\nuniform lowp sampler2D lut;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(texture2D(lut,vec2(inputColor.r,0.5)).r,texture2D(lut,vec2(inputColor.g,0.5)).r,texture2D(lut,vec2(inputColor.b,0.5)).r,inputColor.a);}`;\n\n// src/effects/LUT1DEffect.js\nvar LUT1DEffect = class extends Effect {\n  /**\n   * Constructs a new color grading effect.\n   *\n   * @param {Texture} lut - The lookup texture.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   */\n  constructor(lut, { blendFunction = BlendFunction.SRC } = {}) {\n    super(\"LUT1DEffect\", lut_1d_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([[\"lut\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]])\n    });\n    this.lut = lut;\n  }\n  /**\n   * The LUT.\n   *\n   * @type {Texture}\n   */\n  get lut() {\n    return this.uniforms.get(\"lut\").value;\n  }\n  set lut(value) {\n    this.uniforms.get(\"lut\").value = value;\n    if (value !== null && (value.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType || value.type === three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType)) {\n      this.defines.set(\"LUT_PRECISION_HIGH\", \"1\");\n    }\n  }\n};\n\n// src/effects/LUT3DEffect.js\n\n\n// src/textures/lut/LookupTexture.js\n\n\n// src/enums/LUTOperation.js\nvar LUTOperation = {\n  SCALE_UP: \"lut.scaleup\"\n};\n\n// src/textures/RawImageData.js\nfunction createCanvas(width, height, data) {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  canvas.width = width;\n  canvas.height = height;\n  if (data instanceof Image) {\n    context.drawImage(data, 0, 0);\n  } else {\n    const imageData = context.createImageData(width, height);\n    imageData.data.set(data);\n    context.putImageData(imageData, 0, 0);\n  }\n  return canvas;\n}\nvar RawImageData = class _RawImageData {\n  /**\n   * Constructs a new image data container.\n   *\n   * @param {Number} [width=0] - The width of the image.\n   * @param {Number} [height=0] - The height of the image.\n   * @param {Uint8ClampedArray} [data=null] - The image data.\n   */\n  constructor(width = 0, height = 0, data = null) {\n    this.width = width;\n    this.height = height;\n    this.data = data;\n  }\n  /**\n   * Creates a canvas from this image data.\n   *\n   * @return {Canvas} The canvas, or null if it couldn't be created.\n   */\n  toCanvas() {\n    return typeof document === \"undefined\" ? null : createCanvas(this.width, this.height, this.data);\n  }\n  /**\n   * Creates a new image data container.\n   *\n   * @param {ImageData|Image} image - An image or plain image data.\n   * @return {RawImageData} The image data.\n   */\n  static from(image) {\n    const { width, height } = image;\n    let data;\n    if (image instanceof Image) {\n      const canvas = createCanvas(width, height, image);\n      if (canvas !== null) {\n        const context = canvas.getContext(\"2d\");\n        data = context.getImageData(0, 0, width, height).data;\n      }\n    } else {\n      data = image.data;\n    }\n    return new _RawImageData(width, height, data);\n  }\n};\n\n// temp/lut/worker.txt\nvar worker_default = '\"use strict\";(()=>{var O={SCALE_UP:\"lut.scaleup\"};var _=[new Float32Array(3),new Float32Array(3)],n=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],Z=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function d(a,t,r,m){let i=r[0]-t[0],e=r[1]-t[1],y=r[2]-t[2],h=a[0]-t[0],A=a[1]-t[1],w=a[2]-t[2],c=e*w-y*A,l=y*h-i*w,x=i*A-e*h,u=Math.sqrt(c*c+l*l+x*x),b=u*.5,s=c/u,F=l/u,f=x/u,p=-(a[0]*s+a[1]*F+a[2]*f),M=m[0]*s+m[1]*F+m[2]*f;return Math.abs(M+p)*b/3}function V(a,t,r,m,i,e){let y=(r+m*t+i*t*t)*4;e[0]=a[y+0],e[1]=a[y+1],e[2]=a[y+2]}function k(a,t,r,m,i,e){let y=r*(t-1),h=m*(t-1),A=i*(t-1),w=Math.floor(y),c=Math.floor(h),l=Math.floor(A),x=Math.ceil(y),u=Math.ceil(h),b=Math.ceil(A),s=y-w,F=h-c,f=A-l;if(w===y&&c===h&&l===A)V(a,t,y,h,A,e);else{let p;s>=F&&F>=f?p=Z[0]:s>=f&&f>=F?p=Z[1]:f>=s&&s>=F?p=Z[2]:F>=s&&s>=f?p=Z[3]:F>=f&&f>=s?p=Z[4]:f>=F&&F>=s&&(p=Z[5]);let[M,g,X,Y]=p,P=_[0];P[0]=s,P[1]=F,P[2]=f;let o=_[1],L=x-w,S=u-c,U=b-l;o[0]=L*M[0]+w,o[1]=S*M[1]+c,o[2]=U*M[2]+l,V(a,t,o[0],o[1],o[2],n[0]),o[0]=L*g[0]+w,o[1]=S*g[1]+c,o[2]=U*g[2]+l,V(a,t,o[0],o[1],o[2],n[1]),o[0]=L*X[0]+w,o[1]=S*X[1]+c,o[2]=U*X[2]+l,V(a,t,o[0],o[1],o[2],n[2]),o[0]=L*Y[0]+w,o[1]=S*Y[1]+c,o[2]=U*Y[2]+l,V(a,t,o[0],o[1],o[2],n[3]);let T=d(g,X,Y,P)*6,q=d(M,X,Y,P)*6,C=d(M,g,Y,P)*6,E=d(M,g,X,P)*6;n[0][0]*=T,n[0][1]*=T,n[0][2]*=T,n[1][0]*=q,n[1][1]*=q,n[1][2]*=q,n[2][0]*=C,n[2][1]*=C,n[2][2]*=C,n[3][0]*=E,n[3][1]*=E,n[3][2]*=E,e[0]=n[0][0]+n[1][0]+n[2][0]+n[3][0],e[1]=n[0][1]+n[1][1]+n[2][1]+n[3][1],e[2]=n[0][2]+n[1][2]+n[2][2]+n[3][2]}}var v=class{static expand(t,r){let m=Math.cbrt(t.length/4),i=new Float32Array(3),e=new t.constructor(r**3*4),y=t instanceof Uint8Array?255:1,h=r**2,A=1/(r-1);for(let w=0;w<r;++w)for(let c=0;c<r;++c)for(let l=0;l<r;++l){let x=l*A,u=c*A,b=w*A,s=Math.round(l+c*r+w*h)*4;k(t,m,x,u,b,i),e[s+0]=i[0],e[s+1]=i[1],e[s+2]=i[2],e[s+3]=y}return e}};self.addEventListener(\"message\",a=>{let t=a.data,r=t.data;switch(t.operation){case O.SCALE_UP:r=v.expand(r,t.size);break}postMessage(r,[r.buffer]),close()});})();\\n';\n\n// src/textures/lut/LookupTexture.js\nvar c = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Color();\nvar LookupTexture = class _LookupTexture extends three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture {\n  /**\n   * Constructs a cubic 3D lookup texture.\n   *\n   * @param {TypedArray} data - The pixel data. The default format is RGBA.\n   * @param {Number} size - The sidelength.\n   */\n  constructor(data, size) {\n    super(data, size, size, size);\n    this.type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n    this.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n    this.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n    this.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n    this.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n    this.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n    this.wrapR = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n    this.unpackAlignment = 1;\n    this.needsUpdate = true;\n    this.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n    this.domainMin = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    this.domainMax = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n  }\n  /**\n   * Indicates that this is an instance of LookupTexture3D.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */\n  get isLookupTexture3D() {\n    return true;\n  }\n  /**\n   * Scales this LUT up to a given target size using tetrahedral interpolation.\n   *\n   * @param {Number} size - The target sidelength.\n   * @param {Boolean} [transferData=true] - Extra fast mode. Set to false to keep the original data intact.\n   * @return {Promise<LookupTexture>} A promise that resolves with a new LUT upon completion.\n   */\n  scaleUp(size, transferData = true) {\n    const image = this.image;\n    let promise;\n    if (size <= image.width) {\n      promise = Promise.reject(new Error(\"The target size must be greater than the current size\"));\n    } else {\n      promise = new Promise((resolve, reject) => {\n        const workerURL = URL.createObjectURL(new Blob([worker_default], {\n          type: \"text/javascript\"\n        }));\n        const worker = new Worker(workerURL);\n        worker.addEventListener(\"error\", (event) => reject(event.error));\n        worker.addEventListener(\"message\", (event) => {\n          const lut = new _LookupTexture(event.data, size);\n          this.colorSpace = lut.colorSpace;\n          lut.type = this.type;\n          lut.name = this.name;\n          URL.revokeObjectURL(workerURL);\n          resolve(lut);\n        });\n        const transferList = transferData ? [image.data.buffer] : [];\n        worker.postMessage({\n          operation: LUTOperation.SCALE_UP,\n          data: image.data,\n          size\n        }, transferList);\n      });\n    }\n    return promise;\n  }\n  /**\n   * Applies the given LUT to this one.\n   *\n   * @param {LookupTexture} lut - A LUT. Must have the same dimensions, type and format as this LUT.\n   * @return {LookupTexture} This texture.\n   */\n  applyLUT(lut) {\n    const img0 = this.image;\n    const img1 = lut.image;\n    const size0 = Math.min(img0.width, img0.height, img0.depth);\n    const size1 = Math.min(img1.width, img1.height, img1.depth);\n    if (size0 !== size1) {\n      console.error(\"Size mismatch\");\n    } else if (lut.type !== three__WEBPACK_IMPORTED_MODULE_0__.FloatType || this.type !== three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n      console.error(\"Both LUTs must be FloatType textures\");\n    } else if (lut.format !== three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat || this.format !== three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat) {\n      console.error(\"Both LUTs must be RGBA textures\");\n    } else {\n      const data0 = img0.data;\n      const data1 = img1.data;\n      const size = size0;\n      const sizeSq = size ** 2;\n      const s = size - 1;\n      for (let i = 0, l = size ** 3; i < l; ++i) {\n        const i4 = i * 4;\n        const r = data0[i4 + 0] * s;\n        const g = data0[i4 + 1] * s;\n        const b = data0[i4 + 2] * s;\n        const iRGB = Math.round(r + g * size + b * sizeSq) * 4;\n        data0[i4 + 0] = data1[iRGB + 0];\n        data0[i4 + 1] = data1[iRGB + 1];\n        data0[i4 + 2] = data1[iRGB + 2];\n      }\n      this.needsUpdate = true;\n    }\n    return this;\n  }\n  /**\n   * Converts the LUT data into unsigned byte data.\n   *\n   * This is a lossy operation which should only be performed after all other transformations have been applied.\n   *\n   * @return {LookupTexture} This texture.\n   */\n  convertToUint8() {\n    if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n      const floatData = this.image.data;\n      const uint8Data = new Uint8Array(floatData.length);\n      for (let i = 0, l = floatData.length; i < l; ++i) {\n        uint8Data[i] = floatData[i] * 255 + 0.5;\n      }\n      this.image.data = uint8Data;\n      this.type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType;\n      this.needsUpdate = true;\n    }\n    return this;\n  }\n  /**\n   * Converts the LUT data into float data.\n   *\n   * @return {LookupTexture} This texture.\n   */\n  convertToFloat() {\n    if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n      const uint8Data = this.image.data;\n      const floatData = new Float32Array(uint8Data.length);\n      for (let i = 0, l = uint8Data.length; i < l; ++i) {\n        floatData[i] = uint8Data[i] / 255;\n      }\n      this.image.data = floatData;\n      this.type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n      this.needsUpdate = true;\n    }\n    return this;\n  }\n  /**\n   * Converts this LUT into RGBA data.\n   *\n   * @deprecated LUTs are RGBA by default since three r137.\n   * @return {LookupTexture} This texture.\n   */\n  convertToRGBA() {\n    console.warn(\"LookupTexture\", \"convertToRGBA() is deprecated, LUTs are now RGBA by default\");\n    return this;\n  }\n  /**\n   * Converts the output of this LUT into sRGB color space.\n   *\n   * @return {LookupTexture} This texture.\n   */\n  convertLinearToSRGB() {\n    const data = this.image.data;\n    if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n      for (let i = 0, l = data.length; i < l; i += 4) {\n        c.fromArray(data, i).convertLinearToSRGB().toArray(data, i);\n      }\n      this.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n      this.needsUpdate = true;\n    } else {\n      console.error(\"Color space conversion requires FloatType data\");\n    }\n    return this;\n  }\n  /**\n   * Converts the output of this LUT into linear color space.\n   *\n   * @return {LookupTexture} This texture.\n   */\n  convertSRGBToLinear() {\n    const data = this.image.data;\n    if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n      for (let i = 0, l = data.length; i < l; i += 4) {\n        c.fromArray(data, i).convertSRGBToLinear().toArray(data, i);\n      }\n      this.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n      this.needsUpdate = true;\n    } else {\n      console.error(\"Color space conversion requires FloatType data\");\n    }\n    return this;\n  }\n  /**\n   * Converts this LUT into a 2D data texture.\n   *\n   * Please note that custom input domains are not carried over to 2D textures.\n   *\n   * @return {DataTexture} The texture.\n   */\n  toDataTexture() {\n    const width = this.image.width;\n    const height = this.image.height * this.image.depth;\n    const texture = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(this.image.data, width, height);\n    texture.name = this.name;\n    texture.type = this.type;\n    texture.format = this.format;\n    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n    texture.wrapS = this.wrapS;\n    texture.wrapT = this.wrapT;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    this.colorSpace = texture.colorSpace;\n    return texture;\n  }\n  /**\n   * Creates a new 3D LUT by copying a given LUT.\n   *\n   * Common image-based textures will be converted into 3D data textures.\n   *\n   * @param {Texture} texture - The LUT. Assumed to be cubic.\n   * @return {LookupTexture} A new 3D LUT.\n   */\n  static from(texture) {\n    const image = texture.image;\n    const { width, height } = image;\n    const size = Math.min(width, height);\n    let data;\n    if (image instanceof Image) {\n      const rawImageData = RawImageData.from(image);\n      const src = rawImageData.data;\n      if (width > height) {\n        data = new Uint8Array(src.length);\n        for (let z = 0; z < size; ++z) {\n          for (let y = 0; y < size; ++y) {\n            for (let x = 0; x < size; ++x) {\n              const i4 = (x + z * size + y * size * size) * 4;\n              const j4 = (x + y * size + z * size * size) * 4;\n              data[j4 + 0] = src[i4 + 0];\n              data[j4 + 1] = src[i4 + 1];\n              data[j4 + 2] = src[i4 + 2];\n              data[j4 + 3] = src[i4 + 3];\n            }\n          }\n        }\n      } else {\n        data = new Uint8Array(src.buffer);\n      }\n    } else {\n      data = image.data.slice();\n    }\n    const lut = new _LookupTexture(data, size);\n    lut.type = texture.type;\n    lut.name = texture.name;\n    texture.colorSpace = lut.colorSpace;\n    return lut;\n  }\n  /**\n   * Creates a neutral 3D LUT.\n   *\n   * @param {Number} size - The sidelength.\n   * @return {LookupTexture} A neutral 3D LUT.\n   */\n  static createNeutral(size) {\n    const data = new Float32Array(size ** 3 * 4);\n    const sizeSq = size ** 2;\n    const s = 1 / (size - 1);\n    for (let r = 0; r < size; ++r) {\n      for (let g = 0; g < size; ++g) {\n        for (let b = 0; b < size; ++b) {\n          const i4 = (r + g * size + b * sizeSq) * 4;\n          data[i4 + 0] = r * s;\n          data[i4 + 1] = g * s;\n          data[i4 + 2] = b * s;\n          data[i4 + 3] = 1;\n        }\n      }\n    }\n    const lut = new _LookupTexture(data, size);\n    lut.name = \"neutral\";\n    return lut;\n  }\n};\n\n// src/effects/glsl/lut-3d.frag\nvar lut_3d_default = `uniform vec3 scale;uniform vec3 offset;\n#ifdef CUSTOM_INPUT_DOMAIN\nuniform vec3 domainMin;uniform vec3 domainMax;\n#endif\n#ifdef LUT_3D\n#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler3D lut;\n#else\nuniform mediump sampler3D lut;\n#endif\n#else\nuniform lowp sampler3D lut;\n#endif\nvec4 applyLUT(const in vec3 rgb){\n#ifdef TETRAHEDRAL_INTERPOLATION\nvec3 p=floor(rgb);vec3 f=rgb-p;vec3 v1=(p+0.5)*LUT_TEXEL_WIDTH;vec3 v4=(p+1.5)*LUT_TEXEL_WIDTH;vec3 v2,v3;vec3 frac;if(f.r>=f.g){if(f.g>f.b){frac=f.rgb;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else if(f.r>=f.b){frac=f.rbg;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v1.y,v4.z);}else{frac=f.brg;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v4.x,v1.y,v4.z);}}else{if(f.b>f.g){frac=f.bgr;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v1.x,v4.y,v4.z);}else if(f.r>=f.b){frac=f.grb;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else{frac=f.gbr;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v1.x,v4.y,v4.z);}}vec4 n1=texture(lut,v1);vec4 n2=texture(lut,v2);vec4 n3=texture(lut,v3);vec4 n4=texture(lut,v4);vec4 weights=vec4(1.0-frac.x,frac.x-frac.y,frac.y-frac.z,frac.z);vec4 result=weights*mat4(vec4(n1.r,n2.r,n3.r,n4.r),vec4(n1.g,n2.g,n3.g,n4.g),vec4(n1.b,n2.b,n3.b,n4.b),vec4(1.0));return vec4(result.rgb,1.0);\n#else\nreturn texture(lut,rgb);\n#endif\n}\n#else\n#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D lut;\n#else\nuniform mediump sampler2D lut;\n#endif\n#else\nuniform lowp sampler2D lut;\n#endif\nvec4 applyLUT(const in vec3 rgb){float slice=rgb.b*LUT_SIZE;float slice0=floor(slice);float interp=slice-slice0;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);\n#ifdef LUT_STRIP_HORIZONTAL\nfloat xOffset=clamp(rgb.r*LUT_TEXEL_HEIGHT,LUT_TEXEL_WIDTH*0.5,LUT_TEXEL_HEIGHT-LUT_TEXEL_WIDTH*0.5);vec2 uv0=vec2(slice0*LUT_TEXEL_HEIGHT+xOffset,rgb.g);vec2 uv1=vec2(slice1*LUT_TEXEL_HEIGHT+xOffset,rgb.g);\n#else\nfloat yOffset=clamp(rgb.g*LUT_TEXEL_WIDTH,LUT_TEXEL_HEIGHT*0.5,LUT_TEXEL_WIDTH-LUT_TEXEL_HEIGHT*0.5);vec2 uv0=vec2(rgb.r,slice0*LUT_TEXEL_WIDTH+yOffset);vec2 uv1=vec2(rgb.r,slice1*LUT_TEXEL_WIDTH+yOffset);\n#endif\nvec4 sample0=texture2D(lut,uv0);vec4 sample1=texture2D(lut,uv1);return mix(sample0,sample1,abs(centeredInterp));}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 c=inputColor.rgb;\n#ifdef CUSTOM_INPUT_DOMAIN\nif(c.r>=domainMin.r&&c.g>=domainMin.g&&c.b>=domainMin.b&&c.r<=domainMax.r&&c.g<=domainMax.g&&c.b<=domainMax.b){c=applyLUT(scale*c+offset).rgb;}else{c=inputColor.rgb;}\n#else\n#if !defined(LUT_3D) || defined(TETRAHEDRAL_INTERPOLATION)\nc=clamp(c,0.0,1.0);\n#endif\nc=applyLUT(scale*c+offset).rgb;\n#endif\noutputColor=vec4(c,inputColor.a);}`;\n\n// src/effects/LUT3DEffect.js\nvar LUT3DEffect = class extends Effect {\n  /**\n   * Constructs a new color grading effect.\n   *\n   * @param {Texture} lut - The lookup texture.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Boolean} [options.tetrahedralInterpolation=false] - Enables or disables tetrahedral interpolation.\n   * @param {ColorSpace} [options.inputColorSpace=SRGBColorSpace] - The input color space.\n   */\n  constructor(lut, {\n    blendFunction = BlendFunction.SRC,\n    tetrahedralInterpolation = false,\n    inputColorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace\n  } = {}) {\n    super(\"LUT3DEffect\", lut_3d_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"lut\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"scale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())],\n        [\"offset\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())],\n        [\"domainMin\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"domainMax\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    this.tetrahedralInterpolation = tetrahedralInterpolation;\n    this.inputColorSpace = inputColorSpace;\n    this.lut = lut;\n  }\n  /**\n   * The LUT.\n   *\n   * @type {Texture}\n   */\n  get lut() {\n    return this.uniforms.get(\"lut\").value;\n  }\n  set lut(value) {\n    const defines = this.defines;\n    const uniforms = this.uniforms;\n    if (this.lut !== value) {\n      uniforms.get(\"lut\").value = value;\n      if (value !== null) {\n        const image = value.image;\n        const tetrahedralInterpolation = this.tetrahedralInterpolation;\n        defines.clear();\n        defines.set(\"LUT_SIZE\", Math.min(image.width, image.height).toFixed(16));\n        defines.set(\"LUT_TEXEL_WIDTH\", (1 / image.width).toFixed(16));\n        defines.set(\"LUT_TEXEL_HEIGHT\", (1 / image.height).toFixed(16));\n        uniforms.get(\"domainMin\").value = null;\n        uniforms.get(\"domainMax\").value = null;\n        if (value.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType || value.type === three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType) {\n          defines.set(\"LUT_PRECISION_HIGH\", \"1\");\n        }\n        if (image.width > image.height) {\n          defines.set(\"LUT_STRIP_HORIZONTAL\", \"1\");\n        } else if (value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture) {\n          defines.set(\"LUT_3D\", \"1\");\n        }\n        if (value instanceof LookupTexture) {\n          const min = value.domainMin;\n          const max = value.domainMax;\n          if (min.x !== 0 || min.y !== 0 || min.z !== 0 || max.x !== 1 || max.y !== 1 || max.z !== 1) {\n            defines.set(\"CUSTOM_INPUT_DOMAIN\", \"1\");\n            uniforms.get(\"domainMin\").value = min.clone();\n            uniforms.get(\"domainMax\").value = max.clone();\n          }\n        }\n        this.tetrahedralInterpolation = tetrahedralInterpolation;\n      }\n    }\n  }\n  /**\n   * Returns the current LUT.\n   *\n   * @deprecated Use lut instead.\n   * @return {Texture} The LUT.\n   */\n  getLUT() {\n    return this.lut;\n  }\n  /**\n   * Sets the LUT.\n   *\n   * @deprecated Use lut instead.\n   * @param {Texture} value - The LUT.\n   */\n  setLUT(value) {\n    this.lut = value;\n  }\n  /**\n   * Updates the scale and offset for the LUT sampling coordinates.\n   *\n   * @private\n   */\n  updateScaleOffset() {\n    const lut = this.lut;\n    if (lut !== null) {\n      const size = Math.min(lut.image.width, lut.image.height);\n      const scale = this.uniforms.get(\"scale\").value;\n      const offset = this.uniforms.get(\"offset\").value;\n      if (this.tetrahedralInterpolation && lut instanceof three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture) {\n        if (this.defines.has(\"CUSTOM_INPUT_DOMAIN\")) {\n          const domainScale = lut.domainMax.clone().sub(lut.domainMin);\n          scale.setScalar(size - 1).divide(domainScale);\n          offset.copy(lut.domainMin).negate().multiply(scale);\n        } else {\n          scale.setScalar(size - 1);\n          offset.setScalar(0);\n        }\n      } else {\n        if (this.defines.has(\"CUSTOM_INPUT_DOMAIN\")) {\n          const domainScale = lut.domainMax.clone().sub(lut.domainMin).multiplyScalar(size);\n          scale.setScalar(size - 1).divide(domainScale);\n          offset.copy(lut.domainMin).negate().multiply(scale).addScalar(1 / (2 * size));\n        } else {\n          scale.setScalar((size - 1) / size);\n          offset.setScalar(1 / (2 * size));\n        }\n      }\n    }\n  }\n  /**\n   * Configures parameters for tetrahedral interpolation.\n   *\n   * @private\n   */\n  configureTetrahedralInterpolation() {\n    const lut = this.lut;\n    if (lut !== null) {\n      lut.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      lut.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      if (this.tetrahedralInterpolation) {\n        if (lut instanceof three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture) {\n          lut.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n          lut.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n        } else {\n          console.warn(\"Tetrahedral interpolation requires a 3D texture\");\n        }\n      }\n      lut.needsUpdate = true;\n    }\n  }\n  /**\n   * Indicates whether tetrahedral interpolation is enabled. Requires a 3D LUT, disabled by default.\n   *\n   * Tetrahedral interpolation produces highly accurate results but is slower than hardware interpolation.\n   *\n   * @type {Boolean}\n   */\n  get tetrahedralInterpolation() {\n    return this.defines.has(\"TETRAHEDRAL_INTERPOLATION\");\n  }\n  set tetrahedralInterpolation(value) {\n    if (value) {\n      this.defines.set(\"TETRAHEDRAL_INTERPOLATION\", \"1\");\n    } else {\n      this.defines.delete(\"TETRAHEDRAL_INTERPOLATION\");\n    }\n    this.configureTetrahedralInterpolation();\n    this.updateScaleOffset();\n    this.setChanged();\n  }\n  /**\n   * Enables or disables tetrahedral interpolation.\n   *\n   * @deprecated Use tetrahedralInterpolation instead.\n   * @param {Boolean} value - Whether tetrahedral interpolation should be enabled.\n   */\n  setTetrahedralInterpolationEnabled(value) {\n    this.tetrahedralInterpolation = value;\n  }\n};\n\n// src/enums/DepthCopyMode.js\nvar DepthCopyMode = {\n  FULL: 0,\n  SINGLE: 1\n};\n\n// src/enums/EdgeDetectionMode.js\nvar EdgeDetectionMode = {\n  DEPTH: 0,\n  LUMA: 1,\n  COLOR: 2\n};\n\n// src/enums/PredicationMode.js\nvar PredicationMode = {\n  DISABLED: 0,\n  DEPTH: 1,\n  CUSTOM: 2\n};\n\n// src/enums/SMAAPreset.js\nvar SMAAPreset = {\n  LOW: 0,\n  MEDIUM: 1,\n  HIGH: 2,\n  ULTRA: 3\n};\n\n// src/enums/ToneMappingMode.js\nvar ToneMappingMode = {\n  LINEAR: 0,\n  REINHARD: 1,\n  REINHARD2: 2,\n  REINHARD2_ADAPTIVE: 3,\n  UNCHARTED2: 4,\n  OPTIMIZED_CINEON: 5,\n  CINEON: 5,\n  ACES_FILMIC: 6,\n  AGX: 7,\n  NEUTRAL: 8\n};\n\n// src/enums/VignetteTechnique.js\nvar VignetteTechnique = {\n  DEFAULT: 0,\n  ESKIL: 1\n};\n\n// src/enums/WebGLExtension.js\nvar WebGLExtension = {\n  DERIVATIVES: \"derivatives\",\n  FRAG_DEPTH: \"fragDepth\",\n  DRAW_BUFFERS: \"drawBuffers\",\n  SHADER_TEXTURE_LOD: \"shaderTextureLOD\"\n};\n\n// src/effects/glsl/noise.frag\nvar noise_default = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));\n#ifdef PREMULTIPLY\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}`;\n\n// src/effects/NoiseEffect.js\nvar NoiseEffect = class extends Effect {\n  /**\n   * Constructs a new noise effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.\n   * @param {Boolean} [options.premultiply=false] - Whether the noise should be multiplied with the input colors prior to blending.\n   */\n  constructor({ blendFunction = BlendFunction.SCREEN, premultiply = false } = {}) {\n    super(\"NoiseEffect\", noise_default, { blendFunction });\n    this.premultiply = premultiply;\n  }\n  /**\n   * Indicates whether noise will be multiplied with the input colors prior to blending.\n   *\n   * @type {Boolean}\n   */\n  get premultiply() {\n    return this.defines.has(\"PREMULTIPLY\");\n  }\n  set premultiply(value) {\n    if (this.premultiply !== value) {\n      if (value) {\n        this.defines.set(\"PREMULTIPLY\", \"1\");\n      } else {\n        this.defines.delete(\"PREMULTIPLY\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether noise will be multiplied with the input colors prior to blending.\n   *\n   * @deprecated Use premultiply instead.\n   * @return {Boolean} Whether noise is premultiplied.\n   */\n  isPremultiplied() {\n    return this.premultiply;\n  }\n  /**\n   * Controls whether noise should be multiplied with the input colors prior to blending.\n   *\n   * @deprecated Use premultiply instead.\n   * @param {Boolean} value - Whether noise should be premultiplied.\n   */\n  setPremultiplied(value) {\n    this.premultiply = value;\n  }\n};\n\n// src/effects/OutlineEffect.js\n\n\n// src/materials/DepthComparisonMaterial.js\n\n\n// src/materials/glsl/depth-comparison.frag\nvar depth_comparison_default = `#include <packing>\n#include <clipping_planes_pars_fragment>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float cameraNear;uniform float cameraFar;centroid varying float vViewZ;centroid varying vec4 vProjTexCoord;void main(){\n#include <clipping_planes_fragment>\nvec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);\n#if DEPTH_PACKING == 3201\nfloat fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));\n#else\nfloat fragCoordZ=texture2D(depthBuffer,projTexCoord).r;\n#endif\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#else\nfloat viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#endif\nfloat depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}`;\n\n// src/materials/glsl/depth-comparison.vert\nvar depth_comparison_default2 = `#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\nvViewZ=mvPosition.z;vProjTexCoord=gl_Position;\n#include <clipping_planes_vertex>\n}`;\n\n// src/materials/DepthComparisonMaterial.js\nvar DepthComparisonMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new depth comparison material.\n   *\n   * @param {Texture} [depthTexture=null] - A depth texture.\n   * @param {PerspectiveCamera} [camera] - A camera.\n   */\n  constructor(depthTexture = null, camera) {\n    super({\n      name: \"DepthComparisonMaterial\",\n      defines: {\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        cameraNear: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.3),\n        cameraFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1e3)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: depth_comparison_default,\n      vertexShader: depth_comparison_default2\n    });\n    this.depthBuffer = depthTexture;\n    this.depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking;\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=RGBADepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking) {\n    this.depthBuffer = buffer;\n    this.depthPacking = depthPacking;\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */\n  adoptCameraSettings(camera) {\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  copyCameraSettings(camera) {\n    if (camera) {\n      this.uniforms.cameraNear.value = camera.near;\n      this.uniforms.cameraFar.value = camera.far;\n      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n        this.defines.PERSPECTIVE_CAMERA = \"1\";\n      } else {\n        delete this.defines.PERSPECTIVE_CAMERA;\n      }\n      this.needsUpdate = true;\n    }\n  }\n};\n\n// src/materials/OutlineMaterial.js\n\n\n// src/materials/glsl/outline.frag\nvar outline_default = `uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}`;\n\n// src/materials/glsl/outline.vert\nvar outline_default2 = `uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/OutlineMaterial.js\nvar OutlineMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new outline material.\n   *\n   * TODO Remove texelSize param.\n   * @param {Vector2} [texelSize] - The screen texel size.\n   */\n  constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()) {\n    super({\n      name: \"OutlineMaterial\",\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: outline_default,\n      vertexShader: outline_default2\n    });\n    this.uniforms.texelSize.value.set(texelSize.x, texelSize.y);\n    this.uniforms.maskTexture = this.uniforms.inputBuffer;\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */\n  setTexelSize(x, y) {\n    this.uniforms.texelSize.value.set(x, y);\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/passes/DepthPass.js\n\nvar DepthPass = class extends Pass {\n  /**\n   * Constructs a new depth pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use to render the scene.\n   * @param {Object} [options] - The options.\n   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor(scene, camera, {\n    renderTarget,\n    resolutionScale = 1,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"DepthPass\");\n    this.needsSwap = false;\n    this.renderPass = new RenderPass(scene, camera, new three__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial({\n      depthPacking: three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking\n    }));\n    const renderPass = this.renderPass;\n    renderPass.skipShadowMapUpdate = true;\n    renderPass.ignoreBackground = true;\n    const clearPass = renderPass.clearPass;\n    clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n    clearPass.overrideClearAlpha = 1;\n    this.renderTarget = renderTarget;\n    if (this.renderTarget === void 0) {\n      this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n        minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n        magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter\n      });\n      this.renderTarget.texture.name = \"DepthPass.Target\";\n    }\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n  }\n  set mainScene(value) {\n    this.renderPass.mainScene = value;\n  }\n  set mainCamera(value) {\n    this.renderPass.mainCamera = value;\n  }\n  /**\n   * The depth texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the depth texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  getResolutionScale() {\n    return this.resolution.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  setResolutionScale(scale) {\n    this.resolution.scale = scale;\n  }\n  /**\n   * Renders the scene depth.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const renderTarget = this.renderToScreen ? null : this.renderTarget;\n    this.renderPass.render(renderer, renderTarget);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    this.renderTarget.setSize(resolution.width, resolution.height);\n  }\n};\n\n// src/effects/glsl/outline.frag\nvar outline_default3 = `uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;\n#ifdef USE_PATTERN\nuniform lowp sampler2D patternTexture;varying vec2 vUvPattern;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;\n#ifndef X_RAY\nedge.y=0.0;\n#endif\nedge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;\n#ifdef USE_PATTERN\nvec4 patternColor=texture2D(patternTexture,vUvPattern);\n#ifdef X_RAY\nfloat hiddenFactor=0.5;\n#else\nfloat hiddenFactor=0.0;\n#endif\nvisibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;\n#endif\nfloat alpha=max(max(edge.x,edge.y),visibilityFactor);\n#ifdef ALPHA\noutputColor=vec4(color,alpha);\n#else\noutputColor=vec4(color,max(alpha,inputColor.a));\n#endif\n}`;\n\n// src/effects/glsl/outline.vert\nvar outline_default4 = `uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}`;\n\n// src/effects/OutlineEffect.js\nvar OutlineEffect = class extends Effect {\n  /**\n   * Constructs a new outline effect.\n   *\n   * @param {Scene} scene - The main scene.\n   * @param {Camera} camera - The main camera.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function. Use `BlendFunction.ALPHA` for dark outlines.\n   * @param {Texture} [options.patternTexture=null] - A pattern texture.\n   * @param {Number} [options.patternScale=1.0] - The pattern scale.\n   * @param {Number} [options.edgeStrength=1.0] - The edge strength.\n   * @param {Number} [options.pulseSpeed=0.0] - The pulse speed. A value of zero disables the pulse effect.\n   * @param {Number} [options.visibleEdgeColor=0xffffff] - The color of visible edges.\n   * @param {Number} [options.hiddenEdgeColor=0x22090a] - The color of hidden edges.\n   * @param {KernelSize} [options.kernelSize=KernelSize.VERY_SMALL] - The blur kernel size.\n   * @param {Boolean} [options.blur=false] - Whether the outline should be blurred.\n   * @param {Boolean} [options.xRay=true] - Whether occluded parts of selected objects should be visible.\n   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor(scene, camera, {\n    blendFunction = BlendFunction.SCREEN,\n    patternTexture = null,\n    patternScale = 1,\n    edgeStrength = 1,\n    pulseSpeed = 0,\n    visibleEdgeColor = 16777215,\n    hiddenEdgeColor = 2230538,\n    kernelSize = KernelSize.VERY_SMALL,\n    blur = false,\n    xRay = true,\n    multisampling = 0,\n    resolutionScale = 0.5,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"OutlineEffect\", outline_default3, {\n      uniforms: /* @__PURE__ */ new Map([\n        [\"maskTexture\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"edgeTexture\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"edgeStrength\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(edgeStrength)],\n        [\"visibleEdgeColor\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Color(visibleEdgeColor))],\n        [\"hiddenEdgeColor\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Color(hiddenEdgeColor))],\n        [\"pulse\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)],\n        [\"patternScale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(patternScale)],\n        [\"patternTexture\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    this.blendMode.addEventListener(\"change\", (event) => {\n      if (this.blendMode.blendFunction === BlendFunction.ALPHA) {\n        this.defines.set(\"ALPHA\", \"1\");\n      } else {\n        this.defines.delete(\"ALPHA\");\n      }\n      this.setChanged();\n    });\n    this.blendMode.blendFunction = blendFunction;\n    this.patternTexture = patternTexture;\n    this.xRay = xRay;\n    this.scene = scene;\n    this.camera = camera;\n    this.renderTargetMask = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1);\n    this.renderTargetMask.samples = multisampling;\n    this.renderTargetMask.texture.name = \"Outline.Mask\";\n    this.uniforms.get(\"maskTexture\").value = this.renderTargetMask.texture;\n    this.renderTargetOutline = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetOutline.texture.name = \"Outline.Edges\";\n    this.uniforms.get(\"edgeTexture\").value = this.renderTargetOutline.texture;\n    this.clearPass = new ClearPass();\n    this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n    this.clearPass.overrideClearAlpha = 1;\n    this.depthPass = new DepthPass(scene, camera);\n    this.maskPass = new RenderPass(scene, camera, new DepthComparisonMaterial(this.depthPass.texture, camera));\n    const clearPass = this.maskPass.clearPass;\n    clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n    clearPass.overrideClearAlpha = 1;\n    this.blurPass = new KawaseBlurPass({ resolutionScale, resolutionX, resolutionY, kernelSize });\n    this.blurPass.enabled = blur;\n    const resolution = this.blurPass.resolution;\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this.outlinePass = new ShaderPass(new OutlineMaterial());\n    const outlineMaterial = this.outlinePass.fullscreenMaterial;\n    outlineMaterial.inputBuffer = this.renderTargetMask.texture;\n    this.time = 0;\n    this.forceUpdate = true;\n    this.selection = new Selection();\n    this.pulseSpeed = pulseSpeed;\n  }\n  set mainScene(value) {\n    this.scene = value;\n    this.depthPass.mainScene = value;\n    this.maskPass.mainScene = value;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n    this.depthPass.mainCamera = value;\n    this.maskPass.mainCamera = value;\n    this.maskPass.overrideMaterial.copyCameraSettings(value);\n  }\n  /**\n   * The resolution of this effect.\n   *\n   * @type {Resolution}\n   */\n  get resolution() {\n    return this.blurPass.resolution;\n  }\n  /**\n   * Returns the resolution.\n   *\n   * @return {Resizer} The resolution.\n   */\n  getResolution() {\n    return this.blurPass.getResolution();\n  }\n  /**\n   * The amount of MSAA samples.\n   *\n   * Requires WebGL 2. Set to zero to disable multisampling.\n   *\n   * @experimental Requires three >= r138.\n   * @type {Number}\n   */\n  get multisampling() {\n    return this.renderTargetMask.samples;\n  }\n  set multisampling(value) {\n    this.renderTargetMask.samples = value;\n    this.renderTargetMask.dispose();\n  }\n  /**\n   * The pattern scale.\n   *\n   * @type {Number}\n   */\n  get patternScale() {\n    return this.uniforms.get(\"patternScale\").value;\n  }\n  set patternScale(value) {\n    this.uniforms.get(\"patternScale\").value = value;\n  }\n  /**\n   * The edge strength.\n   *\n   * @type {Number}\n   */\n  get edgeStrength() {\n    return this.uniforms.get(\"edgeStrength\").value;\n  }\n  set edgeStrength(value) {\n    this.uniforms.get(\"edgeStrength\").value = value;\n  }\n  /**\n   * The visible edge color.\n   *\n   * @type {Color}\n   */\n  get visibleEdgeColor() {\n    return this.uniforms.get(\"visibleEdgeColor\").value;\n  }\n  set visibleEdgeColor(value) {\n    this.uniforms.get(\"visibleEdgeColor\").value = value;\n  }\n  /**\n   * The hidden edge color.\n   *\n   * @type {Color}\n   */\n  get hiddenEdgeColor() {\n    return this.uniforms.get(\"hiddenEdgeColor\").value;\n  }\n  set hiddenEdgeColor(value) {\n    this.uniforms.get(\"hiddenEdgeColor\").value = value;\n  }\n  /**\n   * Returns the blur pass.\n   *\n   * @deprecated Use blurPass instead.\n   * @return {KawaseBlurPass} The blur pass.\n   */\n  getBlurPass() {\n    return this.blurPass;\n  }\n  /**\n   * Returns the selection.\n   *\n   * @deprecated Use selection instead.\n   * @return {Selection} The selection.\n   */\n  getSelection() {\n    return this.selection;\n  }\n  /**\n   * Returns the pulse speed.\n   *\n   * @deprecated Use pulseSpeed instead.\n   * @return {Number} The speed.\n   */\n  getPulseSpeed() {\n    return this.pulseSpeed;\n  }\n  /**\n   * Sets the pulse speed. Set to zero to disable.\n   *\n   * @deprecated Use pulseSpeed instead.\n   * @param {Number} value - The speed.\n   */\n  setPulseSpeed(value) {\n    this.pulseSpeed = value;\n  }\n  /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.width instead.\n   */\n  get width() {\n    return this.resolution.width;\n  }\n  set width(value) {\n    this.resolution.preferredWidth = value;\n  }\n  /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.height instead.\n   */\n  get height() {\n    return this.resolution.height;\n  }\n  set height(value) {\n    this.resolution.preferredHeight = value;\n  }\n  /**\n   * The selection layer.\n   *\n   * @type {Number}\n   * @deprecated Use selection.layer instead.\n   */\n  get selectionLayer() {\n    return this.selection.layer;\n  }\n  set selectionLayer(value) {\n    this.selection.layer = value;\n  }\n  /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */\n  get dithering() {\n    return this.blurPass.dithering;\n  }\n  set dithering(value) {\n    this.blurPass.dithering = value;\n  }\n  /**\n   * The blur kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated Use blurPass.kernelSize instead.\n   */\n  get kernelSize() {\n    return this.blurPass.kernelSize;\n  }\n  set kernelSize(value) {\n    this.blurPass.kernelSize = value;\n  }\n  /**\n   * Indicates whether the outlines should be blurred.\n   *\n   * @type {Boolean}\n   * @deprecated Use blurPass.enabled instead.\n   */\n  get blur() {\n    return this.blurPass.enabled;\n  }\n  set blur(value) {\n    this.blurPass.enabled = value;\n  }\n  /**\n   * Indicates whether X-ray mode is enabled.\n   *\n   * @type {Boolean}\n   */\n  get xRay() {\n    return this.defines.has(\"X_RAY\");\n  }\n  set xRay(value) {\n    if (this.xRay !== value) {\n      if (value) {\n        this.defines.set(\"X_RAY\", \"1\");\n      } else {\n        this.defines.delete(\"X_RAY\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether X-ray mode is enabled.\n   *\n   * @deprecated Use xRay instead.\n   * @return {Boolean} Whether X-ray mode is enabled.\n   */\n  isXRayEnabled() {\n    return this.xRay;\n  }\n  /**\n   * Enables or disables X-ray outlines.\n   *\n   * @deprecated Use xRay instead.\n   * @param {Boolean} value - Whether X-ray should be enabled.\n   */\n  setXRayEnabled(value) {\n    this.xRay = value;\n  }\n  /**\n   * The pattern texture. Set to `null` to disable.\n   *\n   * @type {Texture}\n   */\n  get patternTexture() {\n    return this.uniforms.get(\"patternTexture\").value;\n  }\n  set patternTexture(value) {\n    if (value !== null) {\n      value.wrapS = value.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      this.defines.set(\"USE_PATTERN\", \"1\");\n      this.setVertexShader(outline_default4);\n    } else {\n      this.defines.delete(\"USE_PATTERN\");\n      this.setVertexShader(null);\n    }\n    this.uniforms.get(\"patternTexture\").value = value;\n    this.setChanged();\n  }\n  /**\n   * Sets the pattern texture.\n   *\n   * @deprecated Use patternTexture instead.\n   * @param {Texture} value - The new texture.\n   */\n  setPatternTexture(value) {\n    this.patternTexture = value;\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  getResolutionScale() {\n    return this.resolution.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */\n  setResolutionScale(scale) {\n    this.resolution.scale = scale;\n  }\n  /**\n   * Clears the current selection and selects a list of objects.\n   *\n   * @param {Object3D[]} objects - The objects that should be outlined. This array will be copied.\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.set() instead.\n   */\n  setSelection(objects) {\n    this.selection.set(objects);\n    return this;\n  }\n  /**\n   * Clears the list of selected objects.\n   *\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.clear() instead.\n   */\n  clearSelection() {\n    this.selection.clear();\n    return this;\n  }\n  /**\n   * Selects an object.\n   *\n   * @param {Object3D} object - The object that should be outlined.\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.add() instead.\n   */\n  selectObject(object) {\n    this.selection.add(object);\n    return this;\n  }\n  /**\n   * Deselects an object.\n   *\n   * @param {Object3D} object - The object that should no longer be outlined.\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.delete() instead.\n   */\n  deselectObject(object) {\n    this.selection.delete(object);\n    return this;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const selection = this.selection;\n    const uniforms = this.uniforms;\n    const pulse = uniforms.get(\"pulse\");\n    const background = scene.background;\n    const mask = camera.layers.mask;\n    if (this.forceUpdate || selection.size > 0) {\n      scene.background = null;\n      pulse.value = 1;\n      if (this.pulseSpeed > 0) {\n        pulse.value = Math.cos(this.time * this.pulseSpeed * 10) * 0.375 + 0.625;\n      }\n      this.time += deltaTime;\n      selection.setVisible(false);\n      this.depthPass.render(renderer);\n      selection.setVisible(true);\n      camera.layers.set(selection.layer);\n      this.maskPass.render(renderer, this.renderTargetMask);\n      camera.layers.mask = mask;\n      scene.background = background;\n      this.outlinePass.render(renderer, null, this.renderTargetOutline);\n      if (this.blurPass.enabled) {\n        this.blurPass.render(renderer, this.renderTargetOutline, this.renderTargetOutline);\n      }\n    }\n    this.forceUpdate = selection.size > 0;\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.blurPass.setSize(width, height);\n    this.renderTargetMask.setSize(width, height);\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.depthPass.setSize(w, h);\n    this.renderTargetOutline.setSize(w, h);\n    this.outlinePass.fullscreenMaterial.setSize(w, h);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.blurPass.initialize(renderer, alpha, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType);\n    if (frameBufferType !== void 0) {\n      this.depthPass.initialize(renderer, alpha, frameBufferType);\n      this.maskPass.initialize(renderer, alpha, frameBufferType);\n      this.outlinePass.initialize(renderer, alpha, frameBufferType);\n    }\n  }\n};\n\n// src/effects/PixelationEffect.js\n\n\n// src/effects/glsl/pixelation.frag\nvar pixelation_default = `uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}`;\n\n// src/effects/PixelationEffect.js\nvar PixelationEffect = class extends Effect {\n  /**\n   * Constructs a new pixelation effect.\n   *\n   * @param {Object} [granularity=30.0] - The pixel granularity.\n   */\n  constructor(granularity = 30) {\n    super(\"PixelationEffect\", pixelation_default, {\n      uniforms: /* @__PURE__ */ new Map([\n        [\"active\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(false)],\n        [\"d\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4())]\n      ])\n    });\n    this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this._granularity = 0;\n    this.granularity = granularity;\n  }\n  /**\n   * The pixel granularity.\n   *\n   * A higher value yields coarser visuals.\n   *\n   * @type {Number}\n   */\n  get granularity() {\n    return this._granularity;\n  }\n  set granularity(value) {\n    let d = Math.floor(value);\n    if (d % 2 > 0) {\n      d += 1;\n    }\n    this._granularity = d;\n    this.uniforms.get(\"active\").value = d > 0;\n    this.setSize(this.resolution.width, this.resolution.height);\n  }\n  /**\n   * Returns the pixel granularity.\n   *\n   * @deprecated Use granularity instead.\n   * @return {Number} The granularity.\n   */\n  getGranularity() {\n    return this.granularity;\n  }\n  /**\n   * Sets the pixel granularity.\n   *\n   * @deprecated Use granularity instead.\n   * @param {Number} value - The new granularity.\n   */\n  setGranularity(value) {\n    this.granularity = value;\n  }\n  /**\n   * Updates the granularity.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.set(width, height);\n    const d = this.granularity;\n    const x = d / resolution.x;\n    const y = d / resolution.y;\n    this.uniforms.get(\"d\").value.set(x, y, 1 / x, 1 / y);\n  }\n};\n\n// src/effects/RealisticBokehEffect.js\n\n\n// src/effects/glsl/realistic-bokeh.frag\nvar realistic_bokeh_default = `uniform float focus;uniform float focalLength;uniform float fStop;uniform float maxBlur;uniform float luminanceThreshold;uniform float luminanceGain;uniform float bias;uniform float fringe;\n#ifdef MANUAL_DOF\nuniform vec4 dof;\n#endif\n#ifdef PENTAGON\nfloat pentagon(const in vec2 coords){const vec4 HS0=vec4(1.0,0.0,0.0,1.0);const vec4 HS1=vec4(0.309016994,0.951056516,0.0,1.0);const vec4 HS2=vec4(-0.809016994,0.587785252,0.0,1.0);const vec4 HS3=vec4(-0.809016994,-0.587785252,0.0,1.0);const vec4 HS4=vec4(0.309016994,-0.951056516,0.0,1.0);const vec4 HS5=vec4(0.0,0.0,1.0,1.0);const vec4 ONE=vec4(1.0);const float P_FEATHER=0.4;const float N_FEATHER=-P_FEATHER;float inOrOut=-4.0;vec4 P=vec4(coords,vec2(RINGS_FLOAT-1.3));vec4 dist=vec4(dot(P,HS0),dot(P,HS1),dot(P,HS2),dot(P,HS3));dist=smoothstep(N_FEATHER,P_FEATHER,dist);inOrOut+=dot(dist,ONE);dist.x=dot(P,HS4);dist.y=HS5.w-abs(P.z);dist=smoothstep(N_FEATHER,P_FEATHER,dist);inOrOut+=dist.x;return clamp(inOrOut,0.0,1.0);}\n#endif\nvec3 processTexel(const in vec2 coords,const in float blur){vec2 scale=texelSize*fringe*blur;vec3 c=vec3(texture2D(inputBuffer,coords+vec2(0.0,1.0)*scale).r,texture2D(inputBuffer,coords+vec2(-0.866,-0.5)*scale).g,texture2D(inputBuffer,coords+vec2(0.866,-0.5)*scale).b);float luminance=linearToRelativeLuminance(c);float threshold=max((luminance-luminanceThreshold)*luminanceGain,0.0);return c+mix(vec3(0.0),c,threshold*blur);}float gather(const in float i,const in float j,const in float ringSamples,const in vec2 uv,const in vec2 blurFactor,const in float blur,inout vec3 color){float step=PI2/ringSamples;vec2 wh=vec2(cos(j*step)*i,sin(j*step)*i);\n#ifdef PENTAGON\nfloat p=pentagon(wh);\n#else\nfloat p=1.0;\n#endif\ncolor+=processTexel(wh*blurFactor+uv,blur)*mix(1.0,i/RINGS_FLOAT,bias)*p;return mix(1.0,i/RINGS_FLOAT,bias)*p;}void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\n#ifdef MANUAL_DOF\nfloat focalPlane=linearDepth-focus;float farDoF=(focalPlane-dof.z)/dof.w;float nearDoF=(-focalPlane-dof.x)/dof.y;float blur=(focalPlane>0.0)?farDoF:nearDoF;\n#else\nconst float CIRCLE_OF_CONFUSION=0.03;float focalPlaneMM=focus*1000.0;float depthMM=linearDepth*1000.0;float focalPlane=(depthMM*focalLength)/(depthMM-focalLength);float farDoF=(focalPlaneMM*focalLength)/(focalPlaneMM-focalLength);float nearDoF=(focalPlaneMM-focalLength)/(focalPlaneMM*fStop*CIRCLE_OF_CONFUSION);float blur=abs(focalPlane-farDoF)*nearDoF;\n#endif\nconst int MAX_RING_SAMPLES=RINGS_INT*SAMPLES_INT;blur=clamp(blur,0.0,1.0);vec3 color=inputColor.rgb;if(blur>=0.05){vec2 blurFactor=blur*maxBlur*texelSize;float s=1.0;int ringSamples;for(int i=1;i<=RINGS_INT;i++){ringSamples=i*SAMPLES_INT;for(int j=0;j<MAX_RING_SAMPLES;j++){if(j>=ringSamples){break;}s+=gather(float(i),float(j),float(ringSamples),uv,blurFactor,blur,color);}}color/=s;}\n#ifdef SHOW_FOCUS\nfloat edge=0.002*linearDepth;float m=clamp(smoothstep(0.0,edge,blur),0.0,1.0);float e=clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);color=mix(color,vec3(1.0,0.5,0.0),(1.0-m)*0.6);color=mix(color,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\n#endif\noutputColor=vec4(color,inputColor.a);}`;\n\n// src/effects/RealisticBokehEffect.js\nvar RealisticBokehEffect = class extends Effect {\n  /**\n   * Constructs a new bokeh effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.focus=1.0] - The focus distance in world units.\n   * @param {Number} [options.focalLength=24.0] - The focal length of the main camera.\n   * @param {Number} [options.fStop=0.9] - The ratio of the lens focal length to the diameter of the entrance pupil (aperture).\n   * @param {Number} [options.luminanceThreshold=0.5] - A luminance threshold.\n   * @param {Number} [options.luminanceGain=2.0] - A luminance gain factor.\n   * @param {Number} [options.bias=0.5] - A blur bias.\n   * @param {Number} [options.fringe=0.7] - A blur offset.\n   * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.\n   * @param {Boolean} [options.rings=3] - The number of blur iterations.\n   * @param {Boolean} [options.samples=2] - The amount of samples taken per ring.\n   * @param {Boolean} [options.showFocus=false] - Whether the focal point should be highlighted. Useful for debugging.\n   * @param {Boolean} [options.manualDoF=false] - Enables manual control over the depth of field.\n   * @param {Boolean} [options.pentagon=false] - Enables pentagonal blur shapes. Requires a high number of rings and samples.\n   */\n  constructor({\n    blendFunction,\n    focus = 1,\n    focalLength = 24,\n    fStop = 0.9,\n    luminanceThreshold = 0.5,\n    luminanceGain = 2,\n    bias = 0.5,\n    fringe = 0.7,\n    maxBlur = 1,\n    rings = 3,\n    samples = 2,\n    showFocus = false,\n    manualDoF = false,\n    pentagon = false\n  } = {}) {\n    super(\"RealisticBokehEffect\", realistic_bokeh_default, {\n      blendFunction,\n      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"focus\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focus)],\n        [\"focalLength\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focalLength)],\n        [\"fStop\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(fStop)],\n        [\"luminanceThreshold\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(luminanceThreshold)],\n        [\"luminanceGain\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(luminanceGain)],\n        [\"bias\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(bias)],\n        [\"fringe\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(fringe)],\n        [\"maxBlur\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxBlur)],\n        [\"dof\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    this.rings = rings;\n    this.samples = samples;\n    this.showFocus = showFocus;\n    this.manualDoF = manualDoF;\n    this.pentagon = pentagon;\n  }\n  /**\n   * The amount of blur iterations.\n   *\n   * @type {Number}\n   */\n  get rings() {\n    return Number.parseInt(this.defines.get(\"RINGS_INT\"));\n  }\n  set rings(value) {\n    const r = Math.floor(value);\n    this.defines.set(\"RINGS_INT\", r.toFixed(0));\n    this.defines.set(\"RINGS_FLOAT\", r.toFixed(1));\n    this.setChanged();\n  }\n  /**\n   * The amount of blur samples per ring.\n   *\n   * @type {Number}\n   */\n  get samples() {\n    return Number.parseInt(this.defines.get(\"SAMPLES_INT\"));\n  }\n  set samples(value) {\n    const s = Math.floor(value);\n    this.defines.set(\"SAMPLES_INT\", s.toFixed(0));\n    this.defines.set(\"SAMPLES_FLOAT\", s.toFixed(1));\n    this.setChanged();\n  }\n  /**\n   * Indicates whether the focal point will be highlighted.\n   *\n   * @type {Boolean}\n   */\n  get showFocus() {\n    return this.defines.has(\"SHOW_FOCUS\");\n  }\n  set showFocus(value) {\n    if (this.showFocus !== value) {\n      if (value) {\n        this.defines.set(\"SHOW_FOCUS\", \"1\");\n      } else {\n        this.defines.delete(\"SHOW_FOCUS\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether the Depth of Field should be calculated manually.\n   *\n   * If enabled, the Depth of Field can be adjusted via the `dof` uniform.\n   *\n   * @type {Boolean}\n   */\n  get manualDoF() {\n    return this.defines.has(\"MANUAL_DOF\");\n  }\n  set manualDoF(value) {\n    if (this.manualDoF !== value) {\n      if (value) {\n        this.defines.set(\"MANUAL_DOF\", \"1\");\n        this.uniforms.get(\"dof\").value = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(0.2, 1, 0.2, 2);\n      } else {\n        this.defines.delete(\"MANUAL_DOF\");\n        this.uniforms.get(\"dof\").value = null;\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether the blur shape should be pentagonal.\n   *\n   * @type {Boolean}\n   */\n  get pentagon() {\n    return this.defines.has(\"PENTAGON\");\n  }\n  set pentagon(value) {\n    if (this.pentagon !== value) {\n      if (value) {\n        this.defines.set(\"PENTAGON\", \"1\");\n      } else {\n        this.defines.delete(\"PENTAGON\");\n      }\n      this.setChanged();\n    }\n  }\n};\n\n// src/effects/ScanlineEffect.js\n\n\n// src/effects/glsl/scanlines.frag\nvar scanlines_default = `uniform float count;\n#ifdef SCROLL\nuniform float scrollSpeed;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;\n#ifdef SCROLL\ny+=time*scrollSpeed;\n#endif\nvec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}`;\n\n// src/effects/ScanlineEffect.js\nvar ScanlineEffect = class extends Effect {\n  /**\n   * Constructs a new scanline effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.\n   * @param {Number} [options.density=1.25] - The scanline density.\n   * @param {Number} [options.scrollSpeed=0.0] - The scanline scroll speed.\n   */\n  constructor({ blendFunction = BlendFunction.OVERLAY, density = 1.25, scrollSpeed = 0 } = {}) {\n    super(\"ScanlineEffect\", scanlines_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"count\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)],\n        [\"scrollSpeed\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)]\n      ])\n    });\n    this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.d = density;\n    this.scrollSpeed = scrollSpeed;\n  }\n  /**\n   * The scanline density.\n   *\n   * @type {Number}\n   */\n  get density() {\n    return this.d;\n  }\n  set density(value) {\n    this.d = value;\n    this.setSize(this.resolution.width, this.resolution.height);\n  }\n  /**\n   * Returns the current scanline density.\n   *\n   * @deprecated Use density instead.\n   * @return {Number} The scanline density.\n   */\n  getDensity() {\n    return this.density;\n  }\n  /**\n   * Sets the scanline density.\n   *\n   * @deprecated Use density instead.\n   * @param {Number} value - The new scanline density.\n   */\n  setDensity(value) {\n    this.density = value;\n  }\n  /**\n   * The scanline scroll speed. Default is 0 (disabled).\n   *\n   * @type {Number}\n   */\n  get scrollSpeed() {\n    return this.uniforms.get(\"scrollSpeed\").value;\n  }\n  set scrollSpeed(value) {\n    this.uniforms.get(\"scrollSpeed\").value = value;\n    if (value === 0) {\n      if (this.defines.delete(\"SCROLL\")) {\n        this.setChanged();\n      }\n    } else if (!this.defines.has(\"SCROLL\")) {\n      this.defines.set(\"SCROLL\", \"1\");\n      this.setChanged();\n    }\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.resolution.set(width, height);\n    this.uniforms.get(\"count\").value = Math.round(height * this.density);\n  }\n};\n\n// src/effects/ShockWaveEffect.js\n\n\n// src/effects/glsl/shock-wave.frag\nvar shock_wave_default = `uniform bool active;uniform vec2 center;uniform float waveSize;uniform float radius;uniform float maxRadius;uniform float amplitude;varying float vSize;void mainUv(inout vec2 uv){if(active){vec2 aspectCorrection=vec2(aspect,1.0);vec2 difference=uv*aspectCorrection-center*aspectCorrection;float distance=sqrt(dot(difference,difference))*vSize;if(distance>radius){if(distance<radius+waveSize){float angle=(distance-radius)*PI2/waveSize;float cosSin=(1.0-cos(angle))*0.5;float extent=maxRadius+waveSize;float decay=max(extent-distance*distance,0.0)/extent;uv-=((cosSin*amplitude*difference)/distance)*decay;}}}}`;\n\n// src/effects/glsl/shock-wave.vert\nvar shock_wave_default2 = `uniform float size;uniform float cameraDistance;varying float vSize;void mainSupport(){vSize=(0.1*cameraDistance)/size;}`;\n\n// src/effects/ShockWaveEffect.js\nvar HALF_PI = Math.PI * 0.5;\nvar v2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar ab = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar ShockWaveEffect = class extends Effect {\n  /**\n   * Constructs a new shock wave effect.\n   *\n   * @param {Camera} camera - The main camera.\n   * @param {Vector3} [position] - The world position of the shock wave.\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.speed=2.0] - The animation speed.\n   * @param {Number} [options.maxRadius=1.0] - The extent of the shock wave.\n   * @param {Number} [options.waveSize=0.2] - The wave size.\n   * @param {Number} [options.amplitude=0.05] - The distortion amplitude.\n   */\n  constructor(camera, position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), {\n    speed = 2,\n    maxRadius = 1,\n    waveSize = 0.2,\n    amplitude = 0.05\n  } = {}) {\n    super(\"ShockWaveEffect\", shock_wave_default, {\n      vertexShader: shock_wave_default2,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"active\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(false)],\n        [\"center\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.5, 0.5))],\n        [\"cameraDistance\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)],\n        [\"size\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)],\n        [\"radius\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(-waveSize)],\n        [\"maxRadius\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxRadius)],\n        [\"waveSize\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(waveSize)],\n        [\"amplitude\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(amplitude)]\n      ])\n    });\n    this.position = position;\n    this.speed = speed;\n    this.camera = camera;\n    this.screenPosition = this.uniforms.get(\"center\").value;\n    this.time = 0;\n    this.active = false;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n  }\n  /**\n   * The amplitude.\n   *\n   * @type {Number}\n   */\n  get amplitude() {\n    return this.uniforms.get(\"amplitude\").value;\n  }\n  set amplitude(value) {\n    this.uniforms.get(\"amplitude\").value = value;\n  }\n  /**\n   * The wave size.\n   *\n   * @type {Number}\n   */\n  get waveSize() {\n    return this.uniforms.get(\"waveSize\").value;\n  }\n  set waveSize(value) {\n    this.uniforms.get(\"waveSize\").value = value;\n  }\n  /**\n   * The maximum radius.\n   *\n   * @type {Number}\n   */\n  get maxRadius() {\n    return this.uniforms.get(\"maxRadius\").value;\n  }\n  set maxRadius(value) {\n    this.uniforms.get(\"maxRadius\").value = value;\n  }\n  /**\n   * The position of the shock wave.\n   *\n   * @type {Vector3}\n   * @deprecated Use position instead.\n   */\n  get epicenter() {\n    return this.position;\n  }\n  set epicenter(value) {\n    this.position = value;\n  }\n  /**\n   * Returns the position of the shock wave.\n   *\n   * @deprecated Use position instead.\n   * @return {Vector3} The position.\n   */\n  getPosition() {\n    return this.position;\n  }\n  /**\n   * Sets the position of the shock wave.\n   *\n   * @deprecated Use position instead.\n   * @param {Vector3} value - The position.\n   */\n  setPosition(value) {\n    this.position = value;\n  }\n  /**\n   * Returns the speed of the shock wave.\n   *\n   * @deprecated Use speed instead.\n   * @return {Number} The speed.\n   */\n  getSpeed() {\n    return this.speed;\n  }\n  /**\n   * Sets the speed of the shock wave.\n   *\n   * @deprecated Use speed instead.\n   * @param {Number} value - The speed.\n   */\n  setSpeed(value) {\n    this.speed = value;\n  }\n  /**\n   * Emits the shock wave.\n   */\n  explode() {\n    this.time = 0;\n    this.active = true;\n    this.uniforms.get(\"active\").value = true;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [delta] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, delta) {\n    const position = this.position;\n    const camera = this.camera;\n    const uniforms = this.uniforms;\n    const uActive = uniforms.get(\"active\");\n    if (this.active) {\n      const waveSize = uniforms.get(\"waveSize\").value;\n      camera.getWorldDirection(v2);\n      ab.copy(camera.position).sub(position);\n      uActive.value = v2.angleTo(ab) > HALF_PI;\n      if (uActive.value) {\n        uniforms.get(\"cameraDistance\").value = camera.position.distanceTo(position);\n        v2.copy(position).project(camera);\n        this.screenPosition.set((v2.x + 1) * 0.5, (v2.y + 1) * 0.5);\n      }\n      this.time += delta * this.speed;\n      const radius = this.time - waveSize;\n      uniforms.get(\"radius\").value = radius;\n      if (radius >= (uniforms.get(\"maxRadius\").value + waveSize) * 2) {\n        this.active = false;\n        uActive.value = false;\n      }\n    }\n  }\n};\n\n// src/effects/SelectiveBloomEffect.js\n\nvar SelectiveBloomEffect = class extends BloomEffect {\n  /**\n   * Constructs a new selective bloom effect.\n   *\n   * @param {Scene} scene - The main scene.\n   * @param {Camera} camera - The main camera.\n   * @param {Object} [options] - The options. See {@link BloomEffect} for details.\n   */\n  constructor(scene, camera, options) {\n    super(options);\n    this.setAttributes(this.getAttributes() | EffectAttribute.DEPTH);\n    this.camera = camera;\n    this.depthPass = new DepthPass(scene, camera);\n    this.clearPass = new ClearPass(true, false, false);\n    this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n    this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());\n    const depthMaskMaterial = this.depthMaskMaterial;\n    depthMaskMaterial.copyCameraSettings(camera);\n    depthMaskMaterial.depthBuffer1 = this.depthPass.texture;\n    depthMaskMaterial.depthPacking1 = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking;\n    depthMaskMaterial.depthMode = three__WEBPACK_IMPORTED_MODULE_0__.EqualDepth;\n    this.renderTargetMasked = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetMasked.texture.name = \"Bloom.Masked\";\n    this.selection = new Selection();\n    this._inverted = false;\n    this._ignoreBackground = false;\n  }\n  set mainScene(value) {\n    this.depthPass.mainScene = value;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n    this.depthPass.mainCamera = value;\n    this.depthMaskMaterial.copyCameraSettings(value);\n  }\n  /**\n   * Returns the selection.\n   *\n   * @deprecated Use selection instead.\n   * @return {Selection} The selection.\n   */\n  getSelection() {\n    return this.selection;\n  }\n  /**\n   * The depth mask material.\n   *\n   * @type {DepthMaskMaterial}\n   * @private\n   */\n  get depthMaskMaterial() {\n    return this.depthMaskPass.fullscreenMaterial;\n  }\n  /**\n   * Indicates whether the selection should be considered inverted.\n   *\n   * @type {Boolean}\n   */\n  get inverted() {\n    return this._inverted;\n  }\n  set inverted(value) {\n    this._inverted = value;\n    this.depthMaskMaterial.depthMode = value ? three__WEBPACK_IMPORTED_MODULE_0__.NotEqualDepth : three__WEBPACK_IMPORTED_MODULE_0__.EqualDepth;\n  }\n  /**\n   * Indicates whether the mask is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the mask is inverted.\n   */\n  isInverted() {\n    return this.inverted;\n  }\n  /**\n   * Enables or disable mask inversion.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether the mask should be inverted.\n   */\n  setInverted(value) {\n    this.inverted = value;\n  }\n  /**\n   * Indicates whether the background colors will be ignored.\n   *\n   * @type {Boolean}\n   */\n  get ignoreBackground() {\n    return this._ignoreBackground;\n  }\n  set ignoreBackground(value) {\n    this._ignoreBackground = value;\n    this.depthMaskMaterial.maxDepthStrategy = value ? DepthTestStrategy.DISCARD_MAX_DEPTH : DepthTestStrategy.KEEP_MAX_DEPTH;\n  }\n  /**\n   * Indicates whether the background is disabled.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @return {Boolean} Whether the background is disabled.\n   */\n  isBackgroundDisabled() {\n    return this.ignoreBackground;\n  }\n  /**\n   * Enables or disables the background.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @param {Boolean} value - Whether the background should be disabled.\n   */\n  setBackgroundDisabled(value) {\n    this.ignoreBackground = value;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthMaskMaterial.depthBuffer0 = depthTexture;\n    this.depthMaskMaterial.depthPacking0 = depthPacking;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const camera = this.camera;\n    const selection = this.selection;\n    const inverted = this.inverted;\n    let renderTarget = inputBuffer;\n    if (this.ignoreBackground || !inverted || selection.size > 0) {\n      const mask = camera.layers.mask;\n      camera.layers.set(selection.layer);\n      this.depthPass.render(renderer);\n      camera.layers.mask = mask;\n      renderTarget = this.renderTargetMasked;\n      this.clearPass.render(renderer, renderTarget);\n      this.depthMaskPass.render(renderer, inputBuffer, renderTarget);\n    }\n    super.update(renderer, renderTarget, deltaTime);\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    super.setSize(width, height);\n    this.renderTargetMasked.setSize(width, height);\n    this.depthPass.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    super.initialize(renderer, alpha, frameBufferType);\n    this.clearPass.initialize(renderer, alpha, frameBufferType);\n    this.depthPass.initialize(renderer, alpha, frameBufferType);\n    this.depthMaskPass.initialize(renderer, alpha, frameBufferType);\n    if (renderer !== null && renderer.capabilities.logarithmicDepthBuffer) {\n      this.depthMaskPass.fullscreenMaterial.defines.LOG_DEPTH = \"1\";\n    }\n    if (frameBufferType !== void 0) {\n      this.renderTargetMasked.texture.type = frameBufferType;\n      if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        this.renderTargetMasked.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n      }\n    }\n  }\n};\n\n// src/effects/SepiaEffect.js\n\n\n// src/effects/glsl/sepia.frag\nvar sepia_default = `uniform vec3 weightsR;uniform vec3 weightsG;uniform vec3 weightsB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,weightsR),dot(inputColor.rgb,weightsG),dot(inputColor.rgb,weightsB));outputColor=vec4(color,inputColor.a);}`;\n\n// src/effects/SepiaEffect.js\nvar SepiaEffect = class extends Effect {\n  /**\n   * Constructs a new sepia effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.intensity=1.0] - The intensity of the effect.\n   */\n  constructor({ blendFunction, intensity = 1 } = {}) {\n    super(\"SepiaEffect\", sepia_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"weightsR\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.393, 0.769, 0.189))],\n        [\"weightsG\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.349, 0.686, 0.168))],\n        [\"weightsB\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.272, 0.534, 0.131))]\n      ])\n    });\n  }\n  /**\n   * The intensity.\n   *\n   * @deprecated Use blendMode.opacity instead.\n   * @type {Number}\n   */\n  get intensity() {\n    return this.blendMode.opacity.value;\n  }\n  set intensity(value) {\n    this.blendMode.opacity.value = value;\n  }\n  /**\n   * Returns the current sepia intensity.\n   *\n   * @deprecated Use blendMode.opacity instead.\n   * @return {Number} The intensity.\n   */\n  getIntensity() {\n    return this.intensity;\n  }\n  /**\n   * Sets the sepia intensity.\n   *\n   * @deprecated Use blendMode.opacity instead.\n   * @param {Number} value - The intensity.\n   */\n  setIntensity(value) {\n    this.intensity = value;\n  }\n  /**\n   * The weights for the red channel. Default is `(0.393, 0.769, 0.189)`.\n   *\n   * @type {Vector3}\n   */\n  get weightsR() {\n    return this.uniforms.get(\"weightsR\").value;\n  }\n  /**\n   * The weights for the green channel. Default is `(0.349, 0.686, 0.168)`.\n   *\n   * @type {Vector3}\n   */\n  get weightsG() {\n    return this.uniforms.get(\"weightsG\").value;\n  }\n  /**\n   * The weights for the blue channel. Default is `(0.272, 0.534, 0.131)`.\n   *\n   * @type {Vector3}\n   */\n  get weightsB() {\n    return this.uniforms.get(\"weightsB\").value;\n  }\n};\n\n// src/effects/SMAAEffect.js\n\n\n// src/materials/EdgeDetectionMaterial.js\n\n\n// src/materials/glsl/edge-detection.frag\nvar edge_detection_default = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}`;\n\n// src/materials/glsl/edge-detection.vert\nvar edge_detection_default2 = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/EdgeDetectionMaterial.js\nvar EdgeDetectionMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new edge detection material.\n   *\n   * TODO Remove parameters.\n   * @param {Vector2} [texelSize] - The screen texel size.\n   * @param {EdgeDetectionMode} [mode=EdgeDetectionMode.COLOR] - The edge detection mode.\n   */\n  constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(), mode = EdgeDetectionMode.COLOR) {\n    super({\n      name: \"EdgeDetectionMaterial\",\n      defines: {\n        THREE_REVISION: three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"),\n        LOCAL_CONTRAST_ADAPTATION_FACTOR: \"2.0\",\n        EDGE_THRESHOLD: \"0.1\",\n        DEPTH_THRESHOLD: \"0.01\",\n        PREDICATION_MODE: \"0\",\n        PREDICATION_THRESHOLD: \"0.01\",\n        PREDICATION_SCALE: \"2.0\",\n        PREDICATION_STRENGTH: \"1.0\",\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        predicationBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(texelSize)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: edge_detection_default,\n      vertexShader: edge_detection_default2\n    });\n    this.edgeDetectionMode = mode;\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer = buffer;\n    this.depthPacking = depthPacking;\n  }\n  /**\n   * The edge detection mode.\n   *\n   * @type {EdgeDetectionMode}\n   */\n  get edgeDetectionMode() {\n    return Number(this.defines.EDGE_DETECTION_MODE);\n  }\n  set edgeDetectionMode(value) {\n    this.defines.EDGE_DETECTION_MODE = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the edge detection mode.\n   *\n   * @deprecated Use edgeDetectionMode instead.\n   * @return {EdgeDetectionMode} The mode.\n   */\n  getEdgeDetectionMode() {\n    return this.edgeDetectionMode;\n  }\n  /**\n   * Sets the edge detection mode.\n   *\n   * @deprecated Use edgeDetectionMode instead.\n   * @param {EdgeDetectionMode} value - The edge detection mode.\n   */\n  setEdgeDetectionMode(value) {\n    this.edgeDetectionMode = value;\n  }\n  /**\n   * The local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH. Default is 2.0.\n   *\n   * If a neighbor edge has _factor_ times bigger contrast than the current edge, the edge will be discarded.\n   *\n   * This allows to eliminate spurious crossing edges and is based on the fact that if there is too much contrast in a\n   * direction, the perceptual contrast in the other neighbors will be hidden.\n   *\n   * @type {Number}\n   */\n  get localContrastAdaptationFactor() {\n    return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);\n  }\n  set localContrastAdaptationFactor(value) {\n    this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = value.toFixed(\"6\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the local contrast adaptation factor.\n   *\n   * @deprecated Use localContrastAdaptationFactor instead.\n   * @return {Number} The factor.\n   */\n  getLocalContrastAdaptationFactor() {\n    return this.localContrastAdaptationFactor;\n  }\n  /**\n   * Sets the local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH.\n   *\n   * @deprecated Use localContrastAdaptationFactor instead.\n   * @param {Number} value - The local contrast adaptation factor. Default is 2.0.\n   */\n  setLocalContrastAdaptationFactor(value) {\n    this.localContrastAdaptationFactor = value;\n  }\n  /**\n   * The edge detection threshold. Range: [0.0, 0.5].\n   *\n   * A lower value results in more edges being detected at the expense of performance.\n   *\n   * For luma- and chroma-based edge detection, 0.1 is a reasonable value and allows to catch most visible edges. 0.05\n   * is a rather overkill value that allows to catch 'em all. Darker scenes may require an even lower threshold.\n   *\n   * If depth-based edge detection is used, the threshold will depend on the scene depth.\n   *\n   * @type {Number}\n   */\n  get edgeDetectionThreshold() {\n    return Number(this.defines.EDGE_THRESHOLD);\n  }\n  set edgeDetectionThreshold(value) {\n    this.defines.EDGE_THRESHOLD = value.toFixed(\"6\");\n    this.defines.DEPTH_THRESHOLD = (value * 0.1).toFixed(\"6\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the edge detection threshold.\n   *\n   * @deprecated Use edgeDetectionThreshold instead.\n   * @return {Number} The threshold.\n   */\n  getEdgeDetectionThreshold() {\n    return this.edgeDetectionThreshold;\n  }\n  /**\n   * Sets the edge detection threshold.\n   *\n   * @deprecated Use edgeDetectionThreshold instead.\n   * @param {Number} value - The edge detection threshold. Range: [0.0, 0.5].\n   */\n  setEdgeDetectionThreshold(value) {\n    this.edgeDetectionThreshold = value;\n  }\n  /**\n   * The predication mode.\n   *\n   * Predicated thresholding allows to better preserve texture details and to improve edge detection using an additional\n   * buffer such as a light accumulation or depth buffer.\n   *\n   * @type {PredicationMode}\n   */\n  get predicationMode() {\n    return Number(this.defines.PREDICATION_MODE);\n  }\n  set predicationMode(value) {\n    this.defines.PREDICATION_MODE = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the predication mode.\n   *\n   * @deprecated Use predicationMode instead.\n   * @return {PredicationMode} The mode.\n   */\n  getPredicationMode() {\n    return this.predicationMode;\n  }\n  /**\n   * Sets the predication mode.\n   *\n   * @deprecated Use predicationMode instead.\n   * @param {PredicationMode} value - The predication mode.\n   */\n  setPredicationMode(value) {\n    this.predicationMode = value;\n  }\n  /**\n   * The predication buffer.\n   *\n   * @type {Texture}\n   */\n  set predicationBuffer(value) {\n    this.uniforms.predicationBuffer.value = value;\n  }\n  /**\n   * Sets a custom predication buffer.\n   *\n   * @deprecated Use predicationBuffer instead.\n   * @param {Texture} value - The predication buffer.\n   */\n  setPredicationBuffer(value) {\n    this.uniforms.predicationBuffer.value = value;\n  }\n  /**\n   * The predication threshold.\n   *\n   * @type {Number}\n   */\n  get predicationThreshold() {\n    return Number(this.defines.PREDICATION_THRESHOLD);\n  }\n  set predicationThreshold(value) {\n    this.defines.PREDICATION_THRESHOLD = value.toFixed(\"6\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the predication threshold.\n   *\n   * @deprecated Use predicationThreshold instead.\n   * @return {Number} The threshold.\n   */\n  getPredicationThreshold() {\n    return this.predicationThreshold;\n  }\n  /**\n   * Sets the predication threshold.\n   *\n   * @deprecated Use predicationThreshold instead.\n   * @param {Number} value - The threshold.\n   */\n  setPredicationThreshold(value) {\n    this.predicationThreshold = value;\n  }\n  /**\n   * The predication scale. Range: [1.0, 5.0].\n   *\n   * Determines how much the edge detection threshold should be scaled when using predication.\n   *\n   * @type {Boolean|Texture|Number}\n   */\n  get predicationScale() {\n    return Number(this.defines.PREDICATION_SCALE);\n  }\n  set predicationScale(value) {\n    this.defines.PREDICATION_SCALE = value.toFixed(\"6\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the predication scale.\n   *\n   * @deprecated Use predicationScale instead.\n   * @return {Number} The scale.\n   */\n  getPredicationScale() {\n    return this.predicationScale;\n  }\n  /**\n   * Sets the predication scale.\n   *\n   * @deprecated Use predicationScale instead.\n   * @param {Number} value - The scale. Range: [1.0, 5.0].\n   */\n  setPredicationScale(value) {\n    this.predicationScale = value;\n  }\n  /**\n   * The predication strength. Range: [0.0, 1.0].\n   *\n   * Determines how much the edge detection threshold should be decreased locally when using predication.\n   *\n   * @type {Number}\n   */\n  get predicationStrength() {\n    return Number(this.defines.PREDICATION_STRENGTH);\n  }\n  set predicationStrength(value) {\n    this.defines.PREDICATION_STRENGTH = value.toFixed(\"6\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the predication strength.\n   *\n   * @deprecated Use predicationStrength instead.\n   * @return {Number} The strength.\n   */\n  getPredicationStrength() {\n    return this.predicationStrength;\n  }\n  /**\n   * Sets the predication strength.\n   *\n   * @deprecated Use predicationStrength instead.\n   * @param {Number} value - The strength. Range: [0.0, 1.0].\n   */\n  setPredicationStrength(value) {\n    this.predicationStrength = value;\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/materials/SMAAWeightsMaterial.js\n\n\n// src/materials/glsl/smaa-weights.frag\nvar smaa_weights_default = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`;\n\n// src/materials/glsl/smaa-weights.vert\nvar smaa_weights_default2 = `uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/SMAAWeightsMaterial.js\nvar SMAAWeightsMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new SMAA weights material.\n   *\n   * @param {Vector2} [texelSize] - The absolute screen texel size.\n   * @param {Vector2} [resolution] - The resolution.\n   */\n  constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(), resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()) {\n    super({\n      name: \"SMAAWeightsMaterial\",\n      defines: {\n        // Configurable settings:\n        MAX_SEARCH_STEPS_INT: \"16\",\n        MAX_SEARCH_STEPS_FLOAT: \"16.0\",\n        MAX_SEARCH_STEPS_DIAG_INT: \"8\",\n        MAX_SEARCH_STEPS_DIAG_FLOAT: \"8.0\",\n        CORNER_ROUNDING: \"25\",\n        CORNER_ROUNDING_NORM: \"0.25\",\n        // Non-configurable settings:\n        AREATEX_MAX_DISTANCE: \"16.0\",\n        AREATEX_MAX_DISTANCE_DIAG: \"20.0\",\n        AREATEX_PIXEL_SIZE: \"(1.0 / vec2(160.0, 560.0))\",\n        AREATEX_SUBTEX_SIZE: \"(1.0 / 7.0)\",\n        SEARCHTEX_SIZE: \"vec2(66.0, 33.0)\",\n        SEARCHTEX_PACKED_SIZE: \"vec2(64.0, 16.0)\"\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        searchTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        areaTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(resolution),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(texelSize)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: smaa_weights_default,\n      vertexShader: smaa_weights_default2\n    });\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The search lookup texture.\n   *\n   * @type {Texture}\n   */\n  get searchTexture() {\n    return this.uniforms.searchTexture.value;\n  }\n  set searchTexture(value) {\n    this.uniforms.searchTexture.value = value;\n  }\n  /**\n   * The area lookup texture.\n   *\n   * @type {Texture}\n   */\n  get areaTexture() {\n    return this.uniforms.areaTexture.value;\n  }\n  set areaTexture(value) {\n    this.uniforms.areaTexture.value = value;\n  }\n  /**\n   * Sets the search and area lookup textures.\n   *\n   * @deprecated Use searchTexture and areaTexture instead.\n   * @param {Texture} search - The search lookup texture.\n   * @param {Texture} area - The area lookup texture.\n   */\n  setLookupTextures(search, area2) {\n    this.searchTexture = search;\n    this.areaTexture = area2;\n  }\n  /**\n   * The maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.\n   * Range: [0, 112].\n   *\n   * In number of pixels, it's actually the double. So the maximum line length perfectly handled by, for example 16, is\n   * 64 (perfectly means that longer lines won't look as good, but are still antialiased).\n   *\n   * @type {Number}\n   */\n  get orthogonalSearchSteps() {\n    return Number(this.defines.MAX_SEARCH_STEPS_INT);\n  }\n  set orthogonalSearchSteps(value) {\n    const s = Math.min(Math.max(value, 0), 112);\n    this.defines.MAX_SEARCH_STEPS_INT = s.toFixed(\"0\");\n    this.defines.MAX_SEARCH_STEPS_FLOAT = s.toFixed(\"1\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.\n   *\n   * @deprecated Use orthogonalSearchSteps instead.\n   * @param {Number} value - The search steps. Range: [0, 112].\n   */\n  setOrthogonalSearchSteps(value) {\n    this.orthogonalSearchSteps = value;\n  }\n  /**\n   * The maximum steps performed in the diagonal pattern searches, at each side of the pixel. This search\n   * jumps one pixel at a time. Range: [0, 20].\n   *\n   * On high-end machines this search is cheap (between 0.8x and 0.9x slower for 16 steps), but it can have a\n   * significant impact on older machines.\n   *\n   * @type {Number}\n   */\n  get diagonalSearchSteps() {\n    return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);\n  }\n  set diagonalSearchSteps(value) {\n    const s = Math.min(Math.max(value, 0), 20);\n    this.defines.MAX_SEARCH_STEPS_DIAG_INT = s.toFixed(\"0\");\n    this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = s.toFixed(\"1\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Specifies the maximum steps performed in the diagonal pattern searches, at each side of the pixel.\n   *\n   * @deprecated Use diagonalSearchSteps instead.\n   * @param {Number} value - The search steps. Range: [0, 20].\n   */\n  setDiagonalSearchSteps(value) {\n    this.diagonalSearchSteps = value;\n  }\n  /**\n   * Indicates whether diagonal pattern detection is enabled.\n   *\n   * @type {Boolean}\n   */\n  get diagonalDetection() {\n    return this.defines.DISABLE_DIAG_DETECTION === void 0;\n  }\n  set diagonalDetection(value) {\n    if (value) {\n      delete this.defines.DISABLE_DIAG_DETECTION;\n    } else {\n      this.defines.DISABLE_DIAG_DETECTION = \"1\";\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Indicates whether diagonal pattern detection is enabled.\n   *\n   * @deprecated Use diagonalDetection instead.\n   * @return {Boolean} Whether diagonal pattern detection is enabled.\n   */\n  isDiagonalDetectionEnabled() {\n    return this.diagonalDetection;\n  }\n  /**\n   * Enables or disables diagonal pattern detection.\n   *\n   * @deprecated Use diagonalDetection instead.\n   * @param {Boolean} value - Whether diagonal pattern detection should be enabled.\n   */\n  setDiagonalDetectionEnabled(value) {\n    this.diagonalDetection = value;\n  }\n  /**\n   * Specifies how much sharp corners will be rounded. Range: [0, 100].\n   *\n   * @type {Number}\n   */\n  get cornerRounding() {\n    return Number(this.defines.CORNER_ROUNDING);\n  }\n  set cornerRounding(value) {\n    const r = Math.min(Math.max(value, 0), 100);\n    this.defines.CORNER_ROUNDING = r.toFixed(\"4\");\n    this.defines.CORNER_ROUNDING_NORM = (r / 100).toFixed(\"4\");\n    this.needsUpdate = true;\n  }\n  /**\n   * Specifies how much sharp corners will be rounded.\n   *\n   * @deprecated Use cornerRounding instead.\n   * @param {Number} value - The corner rounding amount. Range: [0, 100].\n   */\n  setCornerRounding(value) {\n    this.cornerRounding = value;\n  }\n  /**\n   * Indicates whether corner detection is enabled.\n   *\n   * @type {Number}\n   */\n  get cornerDetection() {\n    return this.defines.DISABLE_CORNER_DETECTION === void 0;\n  }\n  set cornerDetection(value) {\n    if (value) {\n      delete this.defines.DISABLE_CORNER_DETECTION;\n    } else {\n      this.defines.DISABLE_CORNER_DETECTION = \"1\";\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Indicates whether corner rounding is enabled.\n   *\n   * @deprecated Use cornerDetection instead.\n   * @return {Boolean} Whether corner rounding is enabled.\n   */\n  isCornerRoundingEnabled() {\n    return this.cornerDetection;\n  }\n  /**\n   * Enables or disables corner rounding.\n   *\n   * @deprecated Use cornerDetection instead.\n   * @param {Boolean} value - Whether corner rounding should be enabled.\n   */\n  setCornerRoundingEnabled(value) {\n    this.cornerDetection = value;\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const uniforms = this.uniforms;\n    uniforms.texelSize.value.set(1 / width, 1 / height);\n    uniforms.resolution.value.set(width, height);\n  }\n};\n\n// src/textures/smaa/searchImageDataURL.js\nvar searchImageDataURL_default = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC\";\n\n// src/textures/smaa/areaImageDataURL.js\nvar areaImageDataURL_default = \"data:image/png;base64,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\";\n\n// src/effects/glsl/smaa.frag\nvar smaa_default = `uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}`;\n\n// src/effects/glsl/smaa.vert\nvar smaa_default2 = `varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}`;\n\n// src/effects/SMAAEffect.js\nvar SMAAEffect = class extends Effect {\n  /**\n   * Constructs a new SMAA effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {SMAAPreset} [options.preset=SMAAPreset.MEDIUM] - The quality preset.\n   * @param {EdgeDetectionMode} [options.edgeDetectionMode=EdgeDetectionMode.COLOR] - The edge detection mode.\n   * @param {PredicationMode} [options.predicationMode=PredicationMode.DISABLED] - The predication mode.\n   */\n  constructor({\n    blendFunction = BlendFunction.SRC,\n    preset = SMAAPreset.MEDIUM,\n    edgeDetectionMode = EdgeDetectionMode.COLOR,\n    predicationMode = PredicationMode.DISABLED\n  } = {}) {\n    super(\"SMAAEffect\", smaa_default, {\n      vertexShader: smaa_default2,\n      blendFunction,\n      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"weightMap\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    let searchImage, areaImage;\n    if (arguments.length > 1) {\n      searchImage = arguments[0];\n      areaImage = arguments[1];\n      if (arguments.length > 2) {\n        preset = arguments[2];\n      }\n      if (arguments.length > 3) {\n        edgeDetectionMode = arguments[3];\n      }\n    }\n    this.renderTargetEdges = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetEdges.texture.name = \"SMAA.Edges\";\n    this.renderTargetWeights = this.renderTargetEdges.clone();\n    this.renderTargetWeights.texture.name = \"SMAA.Weights\";\n    this.uniforms.get(\"weightMap\").value = this.renderTargetWeights.texture;\n    this.clearPass = new ClearPass(true, false, false);\n    this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n    this.clearPass.overrideClearAlpha = 1;\n    this.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial());\n    this.edgeDetectionMaterial.edgeDetectionMode = edgeDetectionMode;\n    this.edgeDetectionMaterial.predicationMode = predicationMode;\n    this.weightsPass = new ShaderPass(new SMAAWeightsMaterial());\n    const loadingManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    loadingManager.onLoad = () => {\n      const searchTexture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(searchImage);\n      searchTexture.name = \"SMAA.Search\";\n      searchTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n      searchTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n      searchTexture.generateMipmaps = false;\n      searchTexture.needsUpdate = true;\n      searchTexture.flipY = true;\n      this.weightsMaterial.searchTexture = searchTexture;\n      const areaTexture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(areaImage);\n      areaTexture.name = \"SMAA.Area\";\n      areaTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      areaTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      areaTexture.generateMipmaps = false;\n      areaTexture.needsUpdate = true;\n      areaTexture.flipY = false;\n      this.weightsMaterial.areaTexture = areaTexture;\n      this.dispatchEvent({ type: \"load\" });\n    };\n    loadingManager.itemStart(\"search\");\n    loadingManager.itemStart(\"area\");\n    if (searchImage !== void 0 && areaImage !== void 0) {\n      loadingManager.itemEnd(\"search\");\n      loadingManager.itemEnd(\"area\");\n    } else if (typeof Image !== \"undefined\") {\n      searchImage = new Image();\n      areaImage = new Image();\n      searchImage.addEventListener(\"load\", () => loadingManager.itemEnd(\"search\"));\n      areaImage.addEventListener(\"load\", () => loadingManager.itemEnd(\"area\"));\n      searchImage.src = searchImageDataURL_default;\n      areaImage.src = areaImageDataURL_default;\n    }\n    this.applyPreset(preset);\n  }\n  /**\n   * The edges texture.\n   *\n   * @type {Texture}\n   */\n  get edgesTexture() {\n    return this.renderTargetEdges.texture;\n  }\n  /**\n   * Returns the edges texture.\n   *\n   * @deprecated Use edgesTexture instead.\n   * @return {Texture} The texture.\n   */\n  getEdgesTexture() {\n    return this.edgesTexture;\n  }\n  /**\n   * The edge weights texture.\n   *\n   * @type {Texture}\n   */\n  get weightsTexture() {\n    return this.renderTargetWeights.texture;\n  }\n  /**\n   * Returns the edge weights texture.\n   *\n   * @deprecated Use weightsTexture instead.\n   * @return {Texture} The texture.\n   */\n  getWeightsTexture() {\n    return this.weightsTexture;\n  }\n  /**\n   * The edge detection material.\n   *\n   * @type {EdgeDetectionMaterial}\n   */\n  get edgeDetectionMaterial() {\n    return this.edgeDetectionPass.fullscreenMaterial;\n  }\n  /**\n   * The edge detection material.\n   *\n   * @type {EdgeDetectionMaterial}\n   * @deprecated Use edgeDetectionMaterial instead.\n   */\n  get colorEdgesMaterial() {\n    return this.edgeDetectionMaterial;\n  }\n  /**\n   * Returns the edge detection material.\n   *\n   * @deprecated Use edgeDetectionMaterial instead.\n   * @return {EdgeDetectionMaterial} The material.\n   */\n  getEdgeDetectionMaterial() {\n    return this.edgeDetectionMaterial;\n  }\n  /**\n   * The edge weights material.\n   *\n   * @type {SMAAWeightsMaterial}\n   */\n  get weightsMaterial() {\n    return this.weightsPass.fullscreenMaterial;\n  }\n  /**\n   * Returns the edge weights material.\n   *\n   * @deprecated Use weightsMaterial instead.\n   * @return {SMAAWeightsMaterial} The material.\n   */\n  getWeightsMaterial() {\n    return this.weightsMaterial;\n  }\n  /**\n   * Sets the edge detection sensitivity.\n   *\n   * See {@link EdgeDetectionMaterial#setEdgeDetectionThreshold} for more details.\n   *\n   * @deprecated Use edgeDetectionMaterial instead.\n   * @param {Number} threshold - The edge detection sensitivity. Range: [0.05, 0.5].\n   */\n  setEdgeDetectionThreshold(threshold) {\n    this.edgeDetectionMaterial.edgeDetectionThreshold = threshold;\n  }\n  /**\n   * Sets the maximum amount of horizontal/vertical search steps.\n   *\n   * See {@link SMAAWeightsMaterial#setOrthogonalSearchSteps} for more details.\n   *\n   * @deprecated Use weightsMaterial instead.\n   * @param {Number} steps - The search steps. Range: [0, 112].\n   */\n  setOrthogonalSearchSteps(steps) {\n    this.weightsMaterial.orthogonalSearchSteps = steps;\n  }\n  /**\n   * Applies the given quality preset.\n   *\n   * @param {SMAAPreset} preset - The preset.\n   */\n  applyPreset(preset) {\n    const edgeDetectionMaterial = this.edgeDetectionMaterial;\n    const weightsMaterial = this.weightsMaterial;\n    switch (preset) {\n      case SMAAPreset.LOW:\n        edgeDetectionMaterial.edgeDetectionThreshold = 0.15;\n        weightsMaterial.orthogonalSearchSteps = 4;\n        weightsMaterial.diagonalDetection = false;\n        weightsMaterial.cornerDetection = false;\n        break;\n      case SMAAPreset.MEDIUM:\n        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;\n        weightsMaterial.orthogonalSearchSteps = 8;\n        weightsMaterial.diagonalDetection = false;\n        weightsMaterial.cornerDetection = false;\n        break;\n      case SMAAPreset.HIGH:\n        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;\n        weightsMaterial.orthogonalSearchSteps = 16;\n        weightsMaterial.diagonalSearchSteps = 8;\n        weightsMaterial.cornerRounding = 25;\n        weightsMaterial.diagonalDetection = true;\n        weightsMaterial.cornerDetection = true;\n        break;\n      case SMAAPreset.ULTRA:\n        edgeDetectionMaterial.edgeDetectionThreshold = 0.05;\n        weightsMaterial.orthogonalSearchSteps = 32;\n        weightsMaterial.diagonalSearchSteps = 16;\n        weightsMaterial.cornerRounding = 25;\n        weightsMaterial.diagonalDetection = true;\n        weightsMaterial.cornerDetection = true;\n        break;\n    }\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.edgeDetectionMaterial.depthBuffer = depthTexture;\n    this.edgeDetectionMaterial.depthPacking = depthPacking;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    this.clearPass.render(renderer, this.renderTargetEdges);\n    this.edgeDetectionPass.render(renderer, inputBuffer, this.renderTargetEdges);\n    this.weightsPass.render(renderer, this.renderTargetEdges, this.renderTargetWeights);\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.edgeDetectionMaterial.setSize(width, height);\n    this.weightsMaterial.setSize(width, height);\n    this.renderTargetEdges.setSize(width, height);\n    this.renderTargetWeights.setSize(width, height);\n  }\n  /**\n   * Deletes internal render targets and textures.\n   */\n  dispose() {\n    const { searchTexture, areaTexture } = this.weightsMaterial;\n    if (searchTexture !== null && areaTexture !== null) {\n      searchTexture.dispose();\n      areaTexture.dispose();\n    }\n    super.dispose();\n  }\n  /**\n   * The SMAA search image, encoded as a base64 data URL.\n   *\n   * @type {String}\n   * @deprecated\n   */\n  static get searchImageDataURL() {\n    return searchImageDataURL_default;\n  }\n  /**\n   * The SMAA area image, encoded as a base64 data URL.\n   *\n   * @type {String}\n   * @deprecated\n   */\n  static get areaImageDataURL() {\n    return areaImageDataURL_default;\n  }\n};\n\n// src/effects/SSAOEffect.js\n\n\n// src/materials/SSAOMaterial.js\n\n\n// src/materials/glsl/ssao.frag\nvar ssao_default = `#include <common>\n#include <packing>\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\nuniform lowp sampler2D normalBuffer;\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nuniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearSampleDepth=sampleDepth;\n#endif\nfloat proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){\n#ifdef NORMAL_DEPTH\nvec4 normalDepth=texture2D(normalDepthBuffer,vUv);\n#else\nvec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));\n#endif\nfloat ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearDepth=depth;\n#endif\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);\n#ifdef LEGACY_INTENSITY\nao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);\n#endif\n}gl_FragColor.r=ao;}`;\n\n// src/materials/glsl/ssao.vert\nvar ssao_default2 = `uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/SSAOMaterial.js\nvar SSAOMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new SSAO material.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  constructor(camera) {\n    super({\n      name: \"SSAOMaterial\",\n      defines: {\n        SAMPLES_INT: \"0\",\n        INV_SAMPLES_FLOAT: \"0.0\",\n        SPIRAL_TURNS: \"0.0\",\n        RADIUS: \"1.0\",\n        RADIUS_SQ: \"1.0\",\n        DISTANCE_SCALING: \"1\",\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        normalBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        normalDepthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        noiseTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        inverseProjectionMatrix: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()),\n        projectionMatrix: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        cameraNearFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        distanceCutoff: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        proximityCutoff: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        noiseScale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        minRadiusScale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.33),\n        intensity: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        fade: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.01),\n        bias: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: ssao_default,\n      vertexShader: ssao_default2\n    });\n    this.copyCameraSettings(camera);\n    this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.r = 1;\n  }\n  /**\n   * The current near plane setting.\n   *\n   * @type {Number}\n   * @private\n   */\n  get near() {\n    return this.uniforms.cameraNearFar.value.x;\n  }\n  /**\n   * The current far plane setting.\n   *\n   * @type {Number}\n   * @private\n   */\n  get far() {\n    return this.uniforms.cameraNearFar.value.y;\n  }\n  /**\n   * A combined normal-depth buffer.\n   *\n   * @type {Texture}\n   */\n  set normalDepthBuffer(value) {\n    this.uniforms.normalDepthBuffer.value = value;\n    if (value !== null) {\n      this.defines.NORMAL_DEPTH = \"1\";\n    } else {\n      delete this.defines.NORMAL_DEPTH;\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the combined normal-depth buffer.\n   *\n   * @deprecated Use normalDepthBuffer instead.\n   * @param {Number} value - The buffer.\n   */\n  setNormalDepthBuffer(value) {\n    this.normalDepthBuffer = value;\n  }\n  /**\n   * The normal buffer.\n   *\n   * @type {Texture}\n   */\n  set normalBuffer(value) {\n    this.uniforms.normalBuffer.value = value;\n  }\n  /**\n   * Sets the normal buffer.\n   *\n   * @deprecated Use normalBuffer instead.\n   * @param {Number} value - The buffer.\n   */\n  setNormalBuffer(value) {\n    this.uniforms.normalBuffer.value = value;\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer = buffer;\n    this.depthPacking = depthPacking;\n  }\n  /**\n   * The noise texture.\n   *\n   * @type {Texture}\n   */\n  set noiseTexture(value) {\n    this.uniforms.noiseTexture.value = value;\n  }\n  /**\n   * Sets the noise texture.\n   *\n   * @deprecated Use noiseTexture instead.\n   * @param {Number} value - The texture.\n   */\n  setNoiseTexture(value) {\n    this.uniforms.noiseTexture.value = value;\n  }\n  /**\n   * The sample count.\n   *\n   * @type {Number}\n   */\n  get samples() {\n    return Number(this.defines.SAMPLES_INT);\n  }\n  set samples(value) {\n    this.defines.SAMPLES_INT = value.toFixed(0);\n    this.defines.INV_SAMPLES_FLOAT = (1 / value).toFixed(9);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the amount of occlusion samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @return {Number} The sample count.\n   */\n  getSamples() {\n    return this.samples;\n  }\n  /**\n   * Sets the amount of occlusion samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @param {Number} value - The sample count.\n   */\n  setSamples(value) {\n    this.samples = value;\n  }\n  /**\n   * The sampling spiral ring count.\n   *\n   * @type {Number}\n   */\n  get rings() {\n    return Number(this.defines.SPIRAL_TURNS);\n  }\n  set rings(value) {\n    this.defines.SPIRAL_TURNS = value.toFixed(1);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the amount of spiral turns in the occlusion sampling pattern.\n   *\n   * @deprecated Use rings instead.\n   * @return {Number} The radius.\n   */\n  getRings() {\n    return this.rings;\n  }\n  /**\n   * Sets the amount of spiral turns in the occlusion sampling pattern.\n   *\n   * @deprecated Use rings instead.\n   * @param {Number} value - The radius.\n   */\n  setRings(value) {\n    this.rings = value;\n  }\n  /**\n   * The intensity.\n   *\n   * @type {Number}\n   * @deprecated Use SSAOEffect.intensity instead.\n   */\n  get intensity() {\n    return this.uniforms.intensity.value;\n  }\n  set intensity(value) {\n    this.uniforms.intensity.value = value;\n    if (this.defines.LEGACY_INTENSITY === void 0) {\n      this.defines.LEGACY_INTENSITY = \"1\";\n      this.needsUpdate = true;\n    }\n  }\n  /**\n   * Returns the intensity.\n   *\n   * @deprecated Use SSAOEffect.intensity instead.\n   * @return {Number} The intensity.\n   */\n  getIntensity() {\n    return this.uniforms.intensity.value;\n  }\n  /**\n   * Sets the intensity.\n   *\n   * @deprecated Use SSAOEffect.intensity instead.\n   * @param {Number} value - The intensity.\n   */\n  setIntensity(value) {\n    this.uniforms.intensity.value = value;\n  }\n  /**\n   * The depth fade factor.\n   *\n   * @type {Number}\n   */\n  get fade() {\n    return this.uniforms.fade.value;\n  }\n  set fade(value) {\n    this.uniforms.fade.value = value;\n  }\n  /**\n   * Returns the depth fade factor.\n   *\n   * @deprecated Use fade instead.\n   * @return {Number} The fade factor.\n   */\n  getFade() {\n    return this.uniforms.fade.value;\n  }\n  /**\n   * Sets the depth fade factor.\n   *\n   * @deprecated Use fade instead.\n   * @param {Number} value - The fade factor.\n   */\n  setFade(value) {\n    this.uniforms.fade.value = value;\n  }\n  /**\n   * The depth bias. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get bias() {\n    return this.uniforms.bias.value;\n  }\n  set bias(value) {\n    this.uniforms.bias.value = value;\n  }\n  /**\n   * Returns the depth bias.\n   *\n   * @deprecated Use bias instead.\n   * @return {Number} The bias.\n   */\n  getBias() {\n    return this.uniforms.bias.value;\n  }\n  /**\n   * Sets the depth bias.\n   *\n   * @deprecated Use bias instead.\n   * @param {Number} value - The bias.\n   */\n  setBias(value) {\n    this.uniforms.bias.value = value;\n  }\n  /**\n   * The minimum radius scale for distance scaling. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get minRadiusScale() {\n    return this.uniforms.minRadiusScale.value;\n  }\n  set minRadiusScale(value) {\n    this.uniforms.minRadiusScale.value = value;\n  }\n  /**\n   * Returns the minimum radius scale for distance scaling.\n   *\n   * @deprecated Use minRadiusScale instead.\n   * @return {Number} The minimum radius scale.\n   */\n  getMinRadiusScale() {\n    return this.uniforms.minRadiusScale.value;\n  }\n  /**\n   * Sets the minimum radius scale for distance scaling.\n   *\n   * @deprecated Use minRadiusScale instead.\n   * @param {Number} value - The minimum radius scale.\n   */\n  setMinRadiusScale(value) {\n    this.uniforms.minRadiusScale.value = value;\n  }\n  /**\n   * Updates the absolute radius.\n   *\n   * @private\n   */\n  updateRadius() {\n    const radius = this.r * this.resolution.height;\n    this.defines.RADIUS = radius.toFixed(11);\n    this.defines.RADIUS_SQ = (radius * radius).toFixed(11);\n    this.needsUpdate = true;\n  }\n  /**\n   * The occlusion sampling radius. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get radius() {\n    return this.r;\n  }\n  set radius(value) {\n    this.r = Math.min(Math.max(value, 1e-6), 1);\n    this.updateRadius();\n  }\n  /**\n   * Returns the occlusion sampling radius.\n   *\n   * @deprecated Use radius instead.\n   * @return {Number} The radius.\n   */\n  getRadius() {\n    return this.radius;\n  }\n  /**\n   * Sets the occlusion sampling radius.\n   *\n   * @deprecated Use radius instead.\n   * @param {Number} value - The radius. Range [1e-6, 1.0].\n   */\n  setRadius(value) {\n    this.radius = value;\n  }\n  /**\n   * Indicates whether distance-based radius scaling is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */\n  get distanceScaling() {\n    return true;\n  }\n  set distanceScaling(value) {\n  }\n  /**\n   * Indicates whether distance-based radius scaling is enabled.\n   *\n   * @deprecated\n   * @return {Boolean} Whether distance scaling is enabled.\n   */\n  isDistanceScalingEnabled() {\n    return this.distanceScaling;\n  }\n  /**\n   * Enables or disables distance-based radius scaling.\n   *\n   * @deprecated\n   * @param {Boolean} value - Whether distance scaling should be enabled.\n   */\n  setDistanceScalingEnabled(value) {\n    this.distanceScaling = value;\n  }\n  /**\n   * The occlusion distance threshold. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get distanceThreshold() {\n    return this.uniforms.distanceCutoff.value.x;\n  }\n  set distanceThreshold(value) {\n    this.uniforms.distanceCutoff.value.set(\n      Math.min(Math.max(value, 0), 1),\n      Math.min(Math.max(value + this.distanceFalloff, 0), 1)\n    );\n  }\n  /**\n   * The occlusion distance threshold in world units.\n   *\n   * @type {Number}\n   */\n  get worldDistanceThreshold() {\n    return -orthographicDepthToViewZ(this.distanceThreshold, this.near, this.far);\n  }\n  set worldDistanceThreshold(value) {\n    this.distanceThreshold = viewZToOrthographicDepth(-value, this.near, this.far);\n  }\n  /**\n   * The occlusion distance falloff. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get distanceFalloff() {\n    return this.uniforms.distanceCutoff.value.y - this.distanceThreshold;\n  }\n  set distanceFalloff(value) {\n    this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + value, 0), 1);\n  }\n  /**\n   * The occlusion distance falloff in world units.\n   *\n   * @type {Number}\n   */\n  get worldDistanceFalloff() {\n    return -orthographicDepthToViewZ(this.distanceFalloff, this.near, this.far);\n  }\n  set worldDistanceFalloff(value) {\n    this.distanceFalloff = viewZToOrthographicDepth(-value, this.near, this.far);\n  }\n  /**\n   * Sets the occlusion distance cutoff.\n   *\n   * @deprecated Use distanceThreshold and distanceFalloff instead.\n   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */\n  setDistanceCutoff(threshold, falloff) {\n    this.uniforms.distanceCutoff.value.set(\n      Math.min(Math.max(threshold, 0), 1),\n      Math.min(Math.max(threshold + falloff, 0), 1)\n    );\n  }\n  /**\n   * The occlusion proximity threshold. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get proximityThreshold() {\n    return this.uniforms.proximityCutoff.value.x;\n  }\n  set proximityThreshold(value) {\n    this.uniforms.proximityCutoff.value.set(\n      Math.min(Math.max(value, 0), 1),\n      Math.min(Math.max(value + this.proximityFalloff, 0), 1)\n    );\n  }\n  /**\n   * The occlusion proximity threshold in world units.\n   *\n   * @type {Number}\n   */\n  get worldProximityThreshold() {\n    return -orthographicDepthToViewZ(this.proximityThreshold, this.near, this.far);\n  }\n  set worldProximityThreshold(value) {\n    this.proximityThreshold = viewZToOrthographicDepth(-value, this.near, this.far);\n  }\n  /**\n   * The occlusion proximity falloff. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */\n  get proximityFalloff() {\n    return this.uniforms.proximityCutoff.value.y - this.proximityThreshold;\n  }\n  set proximityFalloff(value) {\n    this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + value, 0), 1);\n  }\n  /**\n   * The occlusion proximity falloff in world units.\n   *\n   * @type {Number}\n   */\n  get worldProximityFalloff() {\n    return -orthographicDepthToViewZ(this.proximityFalloff, this.near, this.far);\n  }\n  set worldProximityFalloff(value) {\n    this.proximityFalloff = viewZToOrthographicDepth(-value, this.near, this.far);\n  }\n  /**\n   * Sets the occlusion proximity cutoff.\n   *\n   * @deprecated Use proximityThreshold and proximityFalloff instead.\n   * @param {Number} threshold - The range threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */\n  setProximityCutoff(threshold, falloff) {\n    this.uniforms.proximityCutoff.value.set(\n      Math.min(Math.max(threshold, 0), 1),\n      Math.min(Math.max(threshold + falloff, 0), 1)\n    );\n  }\n  /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */\n  setTexelSize(x, y) {\n    this.uniforms.texelSize.value.set(x, y);\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */\n  adoptCameraSettings(camera) {\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  copyCameraSettings(camera) {\n    if (camera) {\n      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);\n      this.uniforms.projectionMatrix.value.copy(camera.projectionMatrix);\n      this.uniforms.inverseProjectionMatrix.value.copy(camera.projectionMatrix).invert();\n      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n        this.defines.PERSPECTIVE_CAMERA = \"1\";\n      } else {\n        delete this.defines.PERSPECTIVE_CAMERA;\n      }\n      this.needsUpdate = true;\n    }\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const uniforms = this.uniforms;\n    const noiseTexture = uniforms.noiseTexture.value;\n    if (noiseTexture !== null) {\n      uniforms.noiseScale.value.set(\n        width / noiseTexture.image.width,\n        height / noiseTexture.image.height\n      );\n    }\n    uniforms.texelSize.value.set(1 / width, 1 / height);\n    this.resolution.set(width, height);\n    this.updateRadius();\n  }\n};\n\n// src/passes/DepthDownsamplingPass.js\n\n\n// src/materials/DepthDownsamplingMaterial.js\n\n\n// src/materials/glsl/depth-downsampling.frag\nvar depth_downsampling_default = `#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\n#ifdef DOWNSAMPLE_NORMALS\nuniform lowp sampler2D normalBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);\n#ifdef DOWNSAMPLE_NORMALS\nvec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;\n#else\nvec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);\n#endif\ngl_FragColor=vec4(n[index],d[index]);}`;\n\n// src/materials/glsl/depth-downsampling.vert\nvar depth_downsampling_default2 = `uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/DepthDownsamplingMaterial.js\nvar DepthDownsamplingMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new depth downsampling material.\n   */\n  constructor() {\n    super({\n      name: \"DepthDownsamplingMaterial\",\n      defines: {\n        DEPTH_PACKING: \"0\"\n      },\n      uniforms: {\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        normalBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: depth_downsampling_default,\n      vertexShader: depth_downsampling_default2\n    });\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer = buffer;\n    this.depthPacking = depthPacking;\n  }\n  /**\n   * The normal buffer.\n   *\n   * @type {Texture}\n   */\n  set normalBuffer(value) {\n    this.uniforms.normalBuffer.value = value;\n    if (value !== null) {\n      this.defines.DOWNSAMPLE_NORMALS = \"1\";\n    } else {\n      delete this.defines.DOWNSAMPLE_NORMALS;\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the normal buffer.\n   *\n   * @deprecated Use normalBuffer instead.\n   * @param {Texture} value - The normal buffer.\n   */\n  setNormalBuffer(value) {\n    this.normalBuffer = value;\n  }\n  /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */\n  setTexelSize(x, y) {\n    this.uniforms.texelSize.value.set(x, y);\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/passes/DepthDownsamplingPass.js\nvar DepthDownsamplingPass = class extends Pass {\n  /**\n   * Constructs a new depth downsampling pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Texture} [options.normalBuffer=null] - A texture that contains view space normals. See {@link NormalPass}.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor({\n    normalBuffer = null,\n    resolutionScale = 0.5,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"DepthDownsamplingPass\");\n    const material = new DepthDownsamplingMaterial();\n    material.normalBuffer = normalBuffer;\n    this.fullscreenMaterial = material;\n    this.needsDepthTexture = true;\n    this.needsSwap = false;\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n      minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n      magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n      depthBuffer: false,\n      type: three__WEBPACK_IMPORTED_MODULE_0__.FloatType\n    });\n    this.renderTarget.texture.name = \"DepthDownsamplingPass.Target\";\n    this.renderTarget.texture.generateMipmaps = false;\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n  }\n  /**\n   * The normal(RGB) + depth(A) texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the normal(RGB) + depth(A) texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.fullscreenMaterial.depthBuffer = depthTexture;\n    this.fullscreenMaterial.depthPacking = depthPacking;\n  }\n  /**\n   * Downsamples depth and scene normals.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n    renderer.render(this.scene, this.camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    this.renderTarget.setSize(resolution.width, resolution.height);\n    this.fullscreenMaterial.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    const gl = renderer.getContext();\n    const renderable = gl.getExtension(\"EXT_color_buffer_float\") || gl.getExtension(\"EXT_color_buffer_half_float\");\n    if (!renderable) {\n      throw new Error(\"Rendering to float texture is not supported.\");\n    }\n  }\n};\n\n// src/effects/glsl/ssao.frag\nvar ssao_default3 = `uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\n#endif\n#ifdef COLORIZE\nuniform vec3 color;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300\nvec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);\n#else\nfloat ao=aoLinear;\n#endif\nfloat l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);\n#ifdef COLORIZE\noutputColor=vec4(1.0-ao*(1.0-color),inputColor.a);\n#else\noutputColor=vec4(vec3(1.0-ao),inputColor.a);\n#endif\n}`;\n\n// src/effects/SSAOEffect.js\nvar NOISE_TEXTURE_SIZE = 64;\nvar SSAOEffect = class extends Effect {\n  /**\n   * Constructs a new SSAO effect.\n   *\n   * @todo Move normalBuffer to options.\n   * @param {Camera} [camera] - The main camera.\n   * @param {Texture} [normalBuffer] - A texture that contains the scene normals.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.MULTIPLY] - The blend function of this effect.\n   * @param {Boolean} [options.distanceScaling=true] - Deprecated.\n   * @param {Boolean} [options.depthAwareUpsampling=true] - Enables or disables depth-aware upsampling. Has no effect if WebGL 2 is not supported.\n   * @param {Texture} [options.normalDepthBuffer=null] - Deprecated.\n   * @param {Number} [options.samples=9] - The amount of samples per pixel. Should not be a multiple of the ring count.\n   * @param {Number} [options.rings=7] - The amount of spiral turns in the occlusion sampling pattern. Should be a prime number.\n   * @param {Number} [options.worldDistanceThreshold] - The world distance threshold at which the occlusion effect starts to fade out.\n   * @param {Number} [options.worldDistanceFalloff] - The world distance falloff. Influences the smoothness of the occlusion cutoff.\n   * @param {Number} [options.worldProximityThreshold] - The world proximity threshold at which the occlusion starts to fade out.\n   * @param {Number} [options.worldProximityFalloff] - The world proximity falloff. Influences the smoothness of the proximity cutoff.\n   * @param {Number} [options.distanceThreshold=0.97] - Deprecated.\n   * @param {Number} [options.distanceFalloff=0.03] - Deprecated.\n   * @param {Number} [options.rangeThreshold=0.0005] - Deprecated.\n   * @param {Number} [options.rangeFalloff=0.001] - Deprecated.\n   * @param {Number} [options.minRadiusScale=0.1] - The minimum radius scale.\n   * @param {Number} [options.luminanceInfluence=0.7] - Determines how much the luminance of the scene influences the ambient occlusion.\n   * @param {Number} [options.radius=0.1825] - The occlusion sampling radius, expressed as a scale relative to the resolution. Range [1e-6, 1.0].\n   * @param {Number} [options.intensity=1.0] - The intensity of the ambient occlusion.\n   * @param {Number} [options.bias=0.025] - An occlusion bias. Eliminates artifacts caused by depth discontinuities.\n   * @param {Number} [options.fade=0.01] - Influences the smoothness of the shadows. A lower value results in higher contrast.\n   * @param {Color} [options.color=null] - The color of the ambient occlusion.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor(camera, normalBuffer, {\n    blendFunction = BlendFunction.MULTIPLY,\n    samples = 9,\n    rings = 7,\n    normalDepthBuffer = null,\n    depthAwareUpsampling = true,\n    worldDistanceThreshold,\n    worldDistanceFalloff,\n    worldProximityThreshold,\n    worldProximityFalloff,\n    distanceThreshold = 0.97,\n    distanceFalloff = 0.03,\n    rangeThreshold = 5e-4,\n    rangeFalloff = 1e-3,\n    minRadiusScale = 0.1,\n    luminanceInfluence = 0.7,\n    radius = 0.1825,\n    intensity = 1,\n    bias = 0.025,\n    fade = 0.01,\n    color: color2 = null,\n    resolutionScale = 1,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"SSAOEffect\", ssao_default3, {\n      blendFunction,\n      attributes: EffectAttribute.DEPTH,\n      defines: /* @__PURE__ */ new Map([\n        [\"THRESHOLD\", \"0.997\"]\n      ]),\n      uniforms: /* @__PURE__ */ new Map([\n        [\"aoBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"normalDepthBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(normalDepthBuffer)],\n        [\"luminanceInfluence\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(luminanceInfluence)],\n        [\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"intensity\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(intensity)],\n        [\"scale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)]\n        // Unused.\n      ])\n    });\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTarget.texture.name = \"AO.Target\";\n    this.uniforms.get(\"aoBuffer\").value = this.renderTarget.texture;\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this.camera = camera;\n    this.depthDownsamplingPass = new DepthDownsamplingPass({ normalBuffer, resolutionScale });\n    this.depthDownsamplingPass.enabled = normalDepthBuffer === null;\n    this.ssaoPass = new ShaderPass(new SSAOMaterial(camera));\n    const noiseTexture = new NoiseTexture(NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);\n    noiseTexture.wrapS = noiseTexture.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n    const ssaoMaterial = this.ssaoMaterial;\n    ssaoMaterial.normalBuffer = normalBuffer;\n    ssaoMaterial.noiseTexture = noiseTexture;\n    ssaoMaterial.minRadiusScale = minRadiusScale;\n    ssaoMaterial.samples = samples;\n    ssaoMaterial.radius = radius;\n    ssaoMaterial.rings = rings;\n    ssaoMaterial.fade = fade;\n    ssaoMaterial.bias = bias;\n    ssaoMaterial.distanceThreshold = distanceThreshold;\n    ssaoMaterial.distanceFalloff = distanceFalloff;\n    ssaoMaterial.proximityThreshold = rangeThreshold;\n    ssaoMaterial.proximityFalloff = rangeFalloff;\n    if (worldDistanceThreshold !== void 0) {\n      ssaoMaterial.worldDistanceThreshold = worldDistanceThreshold;\n    }\n    if (worldDistanceFalloff !== void 0) {\n      ssaoMaterial.worldDistanceFalloff = worldDistanceFalloff;\n    }\n    if (worldProximityThreshold !== void 0) {\n      ssaoMaterial.worldProximityThreshold = worldProximityThreshold;\n    }\n    if (worldProximityFalloff !== void 0) {\n      ssaoMaterial.worldProximityFalloff = worldProximityFalloff;\n    }\n    if (normalDepthBuffer !== null) {\n      this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;\n      this.defines.set(\"NORMAL_DEPTH\", \"1\");\n    }\n    this.depthAwareUpsampling = depthAwareUpsampling;\n    this.color = color2;\n  }\n  set mainCamera(value) {\n    this.camera = value;\n    this.ssaoMaterial.copyCameraSettings(value);\n  }\n  /**\n   * Sets the normal buffer.\n   *\n   * @type {Texture}\n   */\n  get normalBuffer() {\n    return this.ssaoMaterial.normalBuffer;\n  }\n  set normalBuffer(value) {\n    this.ssaoMaterial.normalBuffer = value;\n    this.depthDownsamplingPass.fullscreenMaterial.normalBuffer = value;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * The SSAO material.\n   *\n   * @type {SSAOMaterial}\n   */\n  get ssaoMaterial() {\n    return this.ssaoPass.fullscreenMaterial;\n  }\n  /**\n   * Returns the SSAO material.\n   *\n   * @deprecated Use ssaoMaterial instead.\n   * @return {SSAOMaterial} The material.\n   */\n  getSSAOMaterial() {\n    return this.ssaoMaterial;\n  }\n  /**\n   * The amount of occlusion samples per pixel.\n   *\n   * @type {Number}\n   * @deprecated Use ssaoMaterial.samples instead.\n   */\n  get samples() {\n    return this.ssaoMaterial.samples;\n  }\n  set samples(value) {\n    this.ssaoMaterial.samples = value;\n  }\n  /**\n   * The amount of spiral turns in the occlusion sampling pattern.\n   *\n   * @type {Number}\n   * @deprecated Use ssaoMaterial.rings instead.\n   */\n  get rings() {\n    return this.ssaoMaterial.rings;\n  }\n  set rings(value) {\n    this.ssaoMaterial.rings = value;\n  }\n  /**\n   * The occlusion sampling radius.\n   *\n   * @type {Number}\n   * @deprecated Use ssaoMaterial.radius instead.\n   */\n  get radius() {\n    return this.ssaoMaterial.radius;\n  }\n  set radius(value) {\n    this.ssaoMaterial.radius = value;\n  }\n  /**\n   * Indicates whether depth-aware upsampling is enabled.\n   *\n   * @type {Boolean}\n   */\n  get depthAwareUpsampling() {\n    return this.defines.has(\"DEPTH_AWARE_UPSAMPLING\");\n  }\n  set depthAwareUpsampling(value) {\n    if (this.depthAwareUpsampling !== value) {\n      if (value) {\n        this.defines.set(\"DEPTH_AWARE_UPSAMPLING\", \"1\");\n      } else {\n        this.defines.delete(\"DEPTH_AWARE_UPSAMPLING\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether depth-aware upsampling is enabled.\n   *\n   * @deprecated Use depthAwareUpsampling instead.\n   * @return {Boolean} Whether depth-aware upsampling is enabled.\n   */\n  isDepthAwareUpsamplingEnabled() {\n    return this.depthAwareUpsampling;\n  }\n  /**\n   * Enables or disables depth-aware upsampling.\n   *\n   * @deprecated Use depthAwareUpsampling instead.\n   * @param {Boolean} value - Whether depth-aware upsampling should be enabled.\n   */\n  setDepthAwareUpsamplingEnabled(value) {\n    this.depthAwareUpsampling = value;\n  }\n  /**\n   * Indicates whether distance-based radius scaling is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */\n  get distanceScaling() {\n    return true;\n  }\n  set distanceScaling(value) {\n  }\n  /**\n   * The color of the ambient occlusion. Set to `null` to disable.\n   *\n   * @type {Color}\n   */\n  get color() {\n    return this.uniforms.get(\"color\").value;\n  }\n  set color(value) {\n    const uniforms = this.uniforms;\n    const defines = this.defines;\n    if (value !== null) {\n      if (defines.has(\"COLORIZE\")) {\n        uniforms.get(\"color\").value.set(value);\n      } else {\n        defines.set(\"COLORIZE\", \"1\");\n        uniforms.get(\"color\").value = new three__WEBPACK_IMPORTED_MODULE_0__.Color(value);\n        this.setChanged();\n      }\n    } else if (defines.has(\"COLORIZE\")) {\n      defines.delete(\"COLORIZE\");\n      uniforms.get(\"color\").value = null;\n      this.setChanged();\n    }\n  }\n  /**\n   * The luminance influence factor. Range: [0.0, 1.0].\n   *\n   * @type {Boolean}\n   */\n  get luminanceInfluence() {\n    return this.uniforms.get(\"luminanceInfluence\").value;\n  }\n  set luminanceInfluence(value) {\n    this.uniforms.get(\"luminanceInfluence\").value = value;\n  }\n  /**\n   * The intensity.\n   *\n   * @type {Number}\n   */\n  get intensity() {\n    return this.uniforms.get(\"intensity\").value;\n  }\n  set intensity(value) {\n    this.uniforms.get(\"intensity\").value = value;\n  }\n  /**\n   * Returns the color of the ambient occlusion.\n   *\n   * @deprecated Use color instead.\n   * @return {Color} The color.\n   */\n  getColor() {\n    return this.color;\n  }\n  /**\n   * Sets the color of the ambient occlusion. Set to `null` to disable colorization.\n   *\n   * @deprecated Use color instead.\n   * @param {Color} value - The color.\n   */\n  setColor(value) {\n    this.color = value;\n  }\n  /**\n   * Sets the occlusion distance cutoff.\n   *\n   * @deprecated Use ssaoMaterial instead.\n   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */\n  setDistanceCutoff(threshold, falloff) {\n    this.ssaoMaterial.distanceThreshold = threshold;\n    this.ssaoMaterial.distanceFalloff = falloff;\n  }\n  /**\n   * Sets the occlusion proximity cutoff.\n   *\n   * @deprecated Use ssaoMaterial instead.\n   * @param {Number} threshold - The proximity threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */\n  setProximityCutoff(threshold, falloff) {\n    this.ssaoMaterial.proximityThreshold = threshold;\n    this.ssaoMaterial.proximityFalloff = falloff;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthDownsamplingPass.setDepthTexture(depthTexture, depthPacking);\n    this.ssaoMaterial.depthBuffer = depthTexture;\n    this.ssaoMaterial.depthPacking = depthPacking;\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    const renderTarget = this.renderTarget;\n    if (this.depthDownsamplingPass.enabled) {\n      this.depthDownsamplingPass.render(renderer);\n    }\n    this.ssaoPass.render(renderer, null, renderTarget);\n  }\n  /**\n   * Sets the size.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.ssaoMaterial.copyCameraSettings(this.camera);\n    this.ssaoMaterial.setSize(w, h);\n    this.renderTarget.setSize(w, h);\n    this.depthDownsamplingPass.resolution.scale = resolution.scale;\n    this.depthDownsamplingPass.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    try {\n      let normalDepthBuffer = this.uniforms.get(\"normalDepthBuffer\").value;\n      if (normalDepthBuffer === null) {\n        this.depthDownsamplingPass.initialize(renderer, alpha, frameBufferType);\n        normalDepthBuffer = this.depthDownsamplingPass.texture;\n        this.uniforms.get(\"normalDepthBuffer\").value = normalDepthBuffer;\n        this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;\n        this.defines.set(\"NORMAL_DEPTH\", \"1\");\n      }\n    } catch (e) {\n      this.depthDownsamplingPass.enabled = false;\n    }\n  }\n};\n\n// src/effects/TextureEffect.js\n\n\n// src/effects/glsl/texture.frag\nvar texture_default = `#ifdef TEXTURE_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nvarying vec2 vUv2;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#ifdef UV_TRANSFORM\nvec4 texel=texture2D(map,vUv2);\n#else\nvec4 texel=texture2D(map,uv);\n#endif\noutputColor=TEXEL;outputColor.a=max(inputColor.a,outputColor.a);}`;\n\n// src/effects/glsl/texture.vert\nvar texture_default2 = `#ifdef ASPECT_CORRECTION\nuniform float scale;\n#else\nuniform mat3 uvTransform;\n#endif\nvarying vec2 vUv2;void mainSupport(const in vec2 uv){\n#ifdef ASPECT_CORRECTION\nvUv2=uv*vec2(aspect,1.0)*scale;\n#else\nvUv2=(uvTransform*vec3(uv,1.0)).xy;\n#endif\n}`;\n\n// src/effects/TextureEffect.js\nvar TextureEffect = class extends Effect {\n  /**\n   * Constructs a new texture effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Texture} [options.texture] - A texture.\n   * @param {Boolean} [options.aspectCorrection=false] - Deprecated. Adjust the texture's offset, repeat and center instead.\n   */\n  constructor({ blendFunction, texture = null, aspectCorrection = false } = {}) {\n    super(\"TextureEffect\", texture_default, {\n      blendFunction,\n      defines: /* @__PURE__ */ new Map([\n        [\"TEXEL\", \"texel\"]\n      ]),\n      uniforms: /* @__PURE__ */ new Map([\n        [\"map\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"scale\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)],\n        [\"uvTransform\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    this.texture = texture;\n    this.aspectCorrection = aspectCorrection;\n  }\n  /**\n   * The texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.uniforms.get(\"map\").value;\n  }\n  set texture(value) {\n    const prevTexture = this.texture;\n    const uniforms = this.uniforms;\n    const defines = this.defines;\n    if (prevTexture !== value) {\n      uniforms.get(\"map\").value = value;\n      uniforms.get(\"uvTransform\").value = value.matrix;\n      defines.delete(\"TEXTURE_PRECISION_HIGH\");\n      if (value !== null) {\n        if (value.matrixAutoUpdate) {\n          defines.set(\"UV_TRANSFORM\", \"1\");\n          this.setVertexShader(texture_default2);\n        } else {\n          defines.delete(\"UV_TRANSFORM\");\n          this.setVertexShader(null);\n        }\n        if (value.type !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n          defines.set(\"TEXTURE_PRECISION_HIGH\", \"1\");\n        }\n        if (prevTexture === null || prevTexture.type !== value.type || prevTexture.encoding !== value.encoding) {\n          this.setChanged();\n        }\n      }\n    }\n  }\n  /**\n   * Returns the texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.texture;\n  }\n  /**\n   * Sets the texture.\n   *\n   * @deprecated Use texture instead.\n   * @param {Texture} value - The texture.\n   */\n  setTexture(value) {\n    this.texture = value;\n  }\n  /**\n   * Indicates whether aspect correction is enabled.\n   *\n   * @type {Number}\n   * @deprecated Adjust the texture's offset, repeat, rotation and center instead.\n   */\n  get aspectCorrection() {\n    return this.defines.has(\"ASPECT_CORRECTION\");\n  }\n  set aspectCorrection(value) {\n    if (this.aspectCorrection !== value) {\n      if (value) {\n        this.defines.set(\"ASPECT_CORRECTION\", \"1\");\n      } else {\n        this.defines.delete(\"ASPECT_CORRECTION\");\n      }\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether the texture UV coordinates will be transformed using the transformation matrix of the texture.\n   *\n   * @type {Boolean}\n   * @deprecated Use texture.matrixAutoUpdate instead.\n   */\n  get uvTransform() {\n    const texture = this.texture;\n    return texture !== null && texture.matrixAutoUpdate;\n  }\n  set uvTransform(value) {\n    const texture = this.texture;\n    if (texture !== null) {\n      texture.matrixAutoUpdate = value;\n    }\n  }\n  /**\n   * Sets the swizzles that will be applied to the components of a texel before it is written to the output color.\n   *\n   * @param {ColorChannel} r - The swizzle for the `r` component.\n   * @param {ColorChannel} [g=r] - The swizzle for the `g` component.\n   * @param {ColorChannel} [b=r] - The swizzle for the `b` component.\n   * @param {ColorChannel} [a=r] - The swizzle for the `a` component.\n   */\n  setTextureSwizzleRGBA(r, g = r, b = r, a = r) {\n    const rgba = \"rgba\";\n    let swizzle = \"\";\n    if (r !== ColorChannel.RED || g !== ColorChannel.GREEN || b !== ColorChannel.BLUE || a !== ColorChannel.ALPHA) {\n      swizzle = [\".\", rgba[r], rgba[g], rgba[b], rgba[a]].join(\"\");\n    }\n    this.defines.set(\"TEXEL\", \"texel\" + swizzle);\n    this.setChanged();\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    if (this.texture.matrixAutoUpdate) {\n      this.texture.updateMatrix();\n    }\n  }\n};\n\n// src/effects/TiltShiftEffect.js\n\n\n// src/materials/TiltShiftBlurMaterial.js\n\n\n// src/materials/glsl/convolution.tilt-shift.frag\nvar convolution_tilt_shift_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec4 maskParams;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void main(){vec2 dUv=vOffset*(1.0-linearGradientMask(vUv2.y));vec4 sum=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y-dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y-dUv.y));gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}`;\n\n// src/materials/glsl/convolution.tilt-shift.vert\nvar convolution_tilt_shift_default2 = `uniform vec4 texelSize;uniform float kernel;uniform float scale;uniform float aspect;uniform vec2 rotation;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;void main(){vec2 uv=position.xy*0.5+0.5;vUv=uv;vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));vOffset=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;gl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/TiltShiftBlurMaterial.js\nvar TiltShiftBlurMaterial = class extends KawaseBlurMaterial {\n  /**\n   * Constructs a new tilt shift blur material.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.\n   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.\n   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.\n   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.\n   */\n  constructor({\n    kernelSize = KernelSize.MEDIUM,\n    offset = 0,\n    rotation = 0,\n    focusArea = 0.4,\n    feather = 0.3\n  } = {}) {\n    super();\n    this.fragmentShader = convolution_tilt_shift_default;\n    this.vertexShader = convolution_tilt_shift_default2;\n    this.kernelSize = kernelSize;\n    this.uniforms.aspect = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1);\n    this.uniforms.rotation = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n    this.uniforms.maskParams = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4());\n    this._offset = offset;\n    this._focusArea = focusArea;\n    this._feather = feather;\n    this.rotation = rotation;\n    this.updateParams();\n  }\n  /**\n   * The relative offset of the focus area.\n   *\n   * @private\n   */\n  updateParams() {\n    const params = this.uniforms.maskParams.value;\n    const a = Math.max(this.focusArea, 0);\n    const b = Math.max(a - this.feather, 0);\n    params.set(\n      this.offset - a,\n      this.offset - b,\n      this.offset + a,\n      this.offset + b\n    );\n  }\n  /**\n   * The rotation of the focus area in radians.\n   *\n   * @type {Number}\n   */\n  get rotation() {\n    return Math.acos(this.uniforms.rotation.value.x);\n  }\n  set rotation(value) {\n    this.uniforms.rotation.value.set(Math.cos(value), Math.sin(value));\n  }\n  /**\n   * The relative offset of the focus area.\n   *\n   * @type {Number}\n   */\n  get offset() {\n    return this._offset;\n  }\n  set offset(value) {\n    this._offset = value;\n    this.updateParams();\n  }\n  /**\n   * The relative size of the focus area.\n   *\n   * @type {Number}\n   */\n  get focusArea() {\n    return this._focusArea;\n  }\n  set focusArea(value) {\n    this._focusArea = value;\n    this.updateParams();\n  }\n  /**\n   * The softness of the focus area edges.\n   *\n   * @type {Number}\n   */\n  get feather() {\n    return this._feather;\n  }\n  set feather(value) {\n    this._feather = value;\n    this.updateParams();\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    super.setSize(width, height);\n    this.uniforms.aspect.value = width / height;\n  }\n};\n\n// src/passes/TiltShiftBlurPass.js\nvar TiltShiftBlurPass = class extends KawaseBlurPass {\n  /**\n   * Constructs a new Kawase blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.\n   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.\n   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.\n   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.\n   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */\n  constructor({\n    offset = 0,\n    rotation = 0,\n    focusArea = 0.4,\n    feather = 0.3,\n    kernelSize = KernelSize.MEDIUM,\n    resolutionScale = 0.5,\n    resolutionX = Resolution.AUTO_SIZE,\n    resolutionY = Resolution.AUTO_SIZE\n  } = {}) {\n    super({ kernelSize, resolutionScale, resolutionX, resolutionY });\n    this.blurMaterial = new TiltShiftBlurMaterial({ kernelSize, offset, rotation, focusArea, feather });\n  }\n};\n\n// src/effects/glsl/tilt-shift.frag\nvar tilt_shift_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform vec2 maskParams;varying vec2 vUv2;float linearGradientMask(const in float x){return step(maskParams.x,x)-step(maskParams.y,x);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float mask=linearGradientMask(vUv2.y);vec4 texel=texture2D(map,uv);outputColor=mix(texel,inputColor,mask);}`;\n\n// src/effects/glsl/tilt-shift.vert\nvar tilt_shift_default2 = `uniform vec2 rotation;varying vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));}`;\n\n// src/effects/TiltShiftEffect.js\nvar TiltShiftEffect = class extends Effect {\n  /**\n   * Constructs a new tilt shift Effect\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.\n   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.\n   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.\n   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.\n   * @param {Number} [options.bias=0.06] - Deprecated.\n   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */\n  constructor({\n    blendFunction,\n    offset = 0,\n    rotation = 0,\n    focusArea = 0.4,\n    feather = 0.3,\n    kernelSize = KernelSize.MEDIUM,\n    resolutionScale = 0.5,\n    resolutionX = Resolution.AUTO_SIZE,\n    resolutionY = Resolution.AUTO_SIZE\n  } = {}) {\n    super(\"TiltShiftEffect\", tilt_shift_default, {\n      vertexShader: tilt_shift_default2,\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"rotation\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())],\n        [\"maskParams\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())],\n        [\"map\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)]\n      ])\n    });\n    this._offset = offset;\n    this._focusArea = focusArea;\n    this._feather = feather;\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTarget.texture.name = \"TiltShift.Target\";\n    this.uniforms.get(\"map\").value = this.renderTarget.texture;\n    this.blurPass = new TiltShiftBlurPass({\n      kernelSize,\n      resolutionScale,\n      resolutionX,\n      resolutionY,\n      offset,\n      rotation,\n      focusArea,\n      feather\n    });\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this.rotation = rotation;\n    this.updateParams();\n  }\n  /**\n   * Updates the mask params.\n   *\n   * @private\n   */\n  updateParams() {\n    const params = this.uniforms.get(\"maskParams\").value;\n    const x = Math.max(this.focusArea - this.feather, 0);\n    params.set(this.offset - x, this.offset + x);\n  }\n  /**\n   * The rotation of the focus area in radians.\n   *\n   * @type {Number}\n   */\n  get rotation() {\n    return Math.acos(this.uniforms.get(\"rotation\").value.x);\n  }\n  set rotation(value) {\n    this.uniforms.get(\"rotation\").value.set(Math.cos(value), Math.sin(value));\n    this.blurPass.blurMaterial.rotation = value;\n  }\n  /**\n   * The relative offset of the focus area.\n   *\n   * @type {Number}\n   */\n  get offset() {\n    return this._offset;\n  }\n  set offset(value) {\n    this._offset = value;\n    this.blurPass.blurMaterial.offset = value;\n    this.updateParams();\n  }\n  /**\n   * The relative size of the focus area.\n   *\n   * @type {Number}\n   */\n  get focusArea() {\n    return this._focusArea;\n  }\n  set focusArea(value) {\n    this._focusArea = value;\n    this.blurPass.blurMaterial.focusArea = value;\n    this.updateParams();\n  }\n  /**\n   * The softness of the focus area edges.\n   *\n   * @type {Number}\n   */\n  get feather() {\n    return this._feather;\n  }\n  set feather(value) {\n    this._feather = value;\n    this.blurPass.blurMaterial.feather = value;\n    this.updateParams();\n  }\n  /**\n   * A blend bias.\n   *\n   * @type {Number}\n   * @deprecated\n   */\n  get bias() {\n    return 0;\n  }\n  set bias(value) {\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    this.blurPass.render(renderer, inputBuffer, this.renderTarget);\n  }\n  /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    this.renderTarget.setSize(resolution.width, resolution.height);\n    this.blurPass.resolution.copy(resolution);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.blurPass.initialize(renderer, alpha, frameBufferType);\n    if (frameBufferType !== void 0) {\n      this.renderTarget.texture.type = frameBufferType;\n      if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        this.renderTarget.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n      }\n    }\n  }\n};\n\n// src/effects/ToneMappingEffect.js\n\n\n// src/passes/AdaptiveLuminancePass.js\n\n\n// src/materials/AdaptiveLuminanceMaterial.js\n\n\n// src/materials/glsl/adaptive-luminance.frag\nvar adaptive_luminance_default = `#include <packing>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\n#if __VERSION__ < 300\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#else\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#endif\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}`;\n\n// src/materials/AdaptiveLuminanceMaterial.js\nvar AdaptiveLuminanceMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new adaptive luminance material.\n   */\n  constructor() {\n    super({\n      name: \"AdaptiveLuminanceMaterial\",\n      defines: {\n        MIP_LEVEL_1X1: \"0.0\"\n      },\n      uniforms: {\n        luminanceBuffer0: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        luminanceBuffer1: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        minLuminance: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.01),\n        deltaTime: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n        tau: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      extensions: {\n        shaderTextureLOD: true\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: adaptive_luminance_default,\n      vertexShader: common_default\n    });\n  }\n  /**\n   * The primary luminance buffer that contains the downsampled average luminance.\n   *\n   * @type {Texture}\n   */\n  set luminanceBuffer0(value) {\n    this.uniforms.luminanceBuffer0.value = value;\n  }\n  /**\n   * Sets the primary luminance buffer that contains the downsampled average luminance.\n   *\n   * @deprecated Use luminanceBuffer0 instead.\n   * @param {Texture} value - The buffer.\n   */\n  setLuminanceBuffer0(value) {\n    this.uniforms.luminanceBuffer0.value = value;\n  }\n  /**\n   * The secondary luminance buffer.\n   *\n   * @type {Texture}\n   */\n  set luminanceBuffer1(value) {\n    this.uniforms.luminanceBuffer1.value = value;\n  }\n  /**\n   * Sets the secondary luminance buffer.\n   *\n   * @deprecated Use luminanceBuffer1 instead.\n   * @param {Texture} value - The buffer.\n   */\n  setLuminanceBuffer1(value) {\n    this.uniforms.luminanceBuffer1.value = value;\n  }\n  /**\n   * The 1x1 mipmap level.\n   *\n   * This level is used to identify the smallest mipmap of the primary luminance buffer.\n   *\n   * @type {Number}\n   */\n  set mipLevel1x1(value) {\n    this.defines.MIP_LEVEL_1X1 = value.toFixed(1);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the 1x1 mipmap level.\n   *\n   * @deprecated Use mipLevel1x1 instead.\n   * @param {Number} value - The level.\n   */\n  setMipLevel1x1(value) {\n    this.mipLevel1x1 = value;\n  }\n  /**\n   * The delta time.\n   *\n   * @type {Number}\n   */\n  set deltaTime(value) {\n    this.uniforms.deltaTime.value = value;\n  }\n  /**\n   * Sets the delta time.\n   *\n   * @deprecated Use deltaTime instead.\n   * @param {Number} value - The delta time.\n   */\n  setDeltaTime(value) {\n    this.uniforms.deltaTime.value = value;\n  }\n  /**\n   * The lowest possible luminance value.\n   *\n   * @type {Number}\n   */\n  get minLuminance() {\n    return this.uniforms.minLuminance.value;\n  }\n  set minLuminance(value) {\n    this.uniforms.minLuminance.value = value;\n  }\n  /**\n   * Returns the lowest possible luminance value.\n   *\n   * @deprecated Use minLuminance instead.\n   * @return {Number} The minimum luminance.\n   */\n  getMinLuminance() {\n    return this.uniforms.minLuminance.value;\n  }\n  /**\n   * Sets the minimum luminance.\n   *\n   * @deprecated Use minLuminance instead.\n   * @param {Number} value - The minimum luminance.\n   */\n  setMinLuminance(value) {\n    this.uniforms.minLuminance.value = value;\n  }\n  /**\n   * The luminance adaptation rate.\n   *\n   * @type {Number}\n   */\n  get adaptationRate() {\n    return this.uniforms.tau.value;\n  }\n  set adaptationRate(value) {\n    this.uniforms.tau.value = value;\n  }\n  /**\n   * Returns the luminance adaptation rate.\n   *\n   * @deprecated Use adaptationRate instead.\n   * @return {Number} The adaptation rate.\n   */\n  getAdaptationRate() {\n    return this.uniforms.tau.value;\n  }\n  /**\n   * Sets the luminance adaptation rate.\n   *\n   * @deprecated Use adaptationRate instead.\n   * @param {Number} value - The adaptation rate.\n   */\n  setAdaptationRate(value) {\n    this.uniforms.tau.value = value;\n  }\n};\n\n// src/passes/AdaptiveLuminancePass.js\nvar AdaptiveLuminancePass = class extends Pass {\n  /**\n   * Constructs a new adaptive luminance pass.\n   *\n   * @param {Texture} luminanceBuffer - A buffer that contains the current scene luminance.\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.minLuminance=0.01] - The minimum luminance.\n   * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.\n   */\n  constructor(luminanceBuffer, { minLuminance = 0.01, adaptationRate = 1 } = {}) {\n    super(\"AdaptiveLuminancePass\");\n    this.fullscreenMaterial = new AdaptiveLuminanceMaterial();\n    this.needsSwap = false;\n    this.renderTargetPrevious = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n      minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n      magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n      depthBuffer: false\n    });\n    this.renderTargetPrevious.texture.name = \"Luminance.Previous\";\n    const material = this.fullscreenMaterial;\n    material.luminanceBuffer0 = this.renderTargetPrevious.texture;\n    material.luminanceBuffer1 = luminanceBuffer;\n    material.minLuminance = minLuminance;\n    material.adaptationRate = adaptationRate;\n    this.renderTargetAdapted = this.renderTargetPrevious.clone();\n    this.renderTargetAdapted.texture.name = \"Luminance.Adapted\";\n    this.copyPass = new CopyPass(this.renderTargetPrevious, false);\n  }\n  /**\n   * The adaptive luminance texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTargetAdapted.texture;\n  }\n  /**\n   * Returns the adaptive 1x1 luminance texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTargetAdapted.texture;\n  }\n  /**\n   * Sets the 1x1 mipmap level.\n   *\n   * This level is used to identify the smallest mipmap of the main luminance texture which contains the downsampled\n   * average scene luminance.\n   *\n   * @type {Number}\n   * @deprecated Use fullscreenMaterial.mipLevel1x1 instead.\n   */\n  set mipLevel1x1(value) {\n    this.fullscreenMaterial.mipLevel1x1 = value;\n  }\n  /**\n   * The luminance adaptation rate.\n   *\n   * @type {Number}\n   * @deprecated Use fullscreenMaterial.adaptationRate instead.\n   */\n  get adaptationRate() {\n    return this.fullscreenMaterial.adaptationRate;\n  }\n  /**\n   * @type {Number}\n   * @deprecated Use fullscreenMaterial.adaptationRate instead.\n   */\n  set adaptationRate(value) {\n    this.fullscreenMaterial.adaptationRate = value;\n  }\n  /**\n   * Renders the scene normals.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    this.fullscreenMaterial.deltaTime = deltaTime;\n    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted);\n    renderer.render(this.scene, this.camera);\n    this.copyPass.render(renderer, this.renderTargetAdapted);\n  }\n};\n\n// src/effects/glsl/tone-mapping.frag\nvar tone_mapping_default = `#include <tonemapping_pars_fragment>\nuniform float whitePoint;\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\nuniform float middleGrey;\n#if TONE_MAPPING_MODE == 3\nuniform lowp sampler2D luminanceBuffer;\n#else\nuniform float averageLuminance;\n#endif\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\n#if TONE_MAPPING_MODE == 3\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\n#else\nfloat lumAvg=averageLuminance;\n#endif\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}\n#elif TONE_MAPPING_MODE == 4\n#define A 0.15\n#define B 0.50\n#define C 0.10\n#define D 0.20\n#define E 0.02\n#define F 0.30\nvec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\n#elif TONE_MAPPING_MODE == 4\noutputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);\n#else\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\n#endif\n}`;\n\n// src/effects/ToneMappingEffect.js\nvar ToneMappingEffect = class extends Effect {\n  /**\n   * Constructs a new tone mapping effect.\n   *\n   * The additional parameters only affect the Reinhard2 operator.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Boolean} [options.adaptive=false] - Deprecated. Use mode instead.\n   * @param {ToneMappingMode} [options.mode=ToneMappingMode.AGX] - The tone mapping mode.\n   * @param {Number} [options.resolution=256] - The resolution of the luminance texture. Must be a power of two.\n   * @param {Number} [options.maxLuminance=4.0] - Deprecated. Same as whitePoint.\n   * @param {Number} [options.whitePoint=4.0] - The white point.\n   * @param {Number} [options.middleGrey=0.6] - The middle grey factor.\n   * @param {Number} [options.minLuminance=0.01] - The minimum luminance. Prevents very high exposure in dark scenes.\n   * @param {Number} [options.averageLuminance=1.0] - The average luminance. Used for the non-adaptive Reinhard operator.\n   * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.\n   */\n  constructor({\n    blendFunction = BlendFunction.SRC,\n    adaptive = false,\n    mode = adaptive ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.AGX,\n    resolution = 256,\n    maxLuminance = 4,\n    whitePoint = maxLuminance,\n    middleGrey = 0.6,\n    minLuminance = 0.01,\n    averageLuminance = 1,\n    adaptationRate = 1\n  } = {}) {\n    super(\"ToneMappingEffect\", tone_mapping_default, {\n      blendFunction,\n      uniforms: /* @__PURE__ */ new Map([\n        [\"luminanceBuffer\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)],\n        [\"maxLuminance\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxLuminance)],\n        // Unused\n        [\"whitePoint\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(whitePoint)],\n        [\"middleGrey\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(middleGrey)],\n        [\"averageLuminance\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(averageLuminance)]\n      ])\n    });\n    this.renderTargetLuminance = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n      minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter,\n      depthBuffer: false\n    });\n    this.renderTargetLuminance.texture.generateMipmaps = true;\n    this.renderTargetLuminance.texture.name = \"Luminance\";\n    this.luminancePass = new LuminancePass({\n      renderTarget: this.renderTargetLuminance\n    });\n    this.adaptiveLuminancePass = new AdaptiveLuminancePass(this.luminancePass.texture, {\n      minLuminance,\n      adaptationRate\n    });\n    this.uniforms.get(\"luminanceBuffer\").value = this.adaptiveLuminancePass.texture;\n    this.resolution = resolution;\n    this.mode = mode;\n  }\n  /**\n   * The tone mapping mode.\n   *\n   * @type {ToneMappingMode}\n   */\n  get mode() {\n    return Number(this.defines.get(\"TONE_MAPPING_MODE\"));\n  }\n  set mode(value) {\n    if (this.mode === value) {\n      return;\n    }\n    const revision = three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\");\n    const cineonToneMapping = revision >= 168 ? \"CineonToneMapping(texel)\" : \"OptimizedCineonToneMapping(texel)\";\n    this.defines.clear();\n    this.defines.set(\"TONE_MAPPING_MODE\", value.toFixed(0));\n    switch (value) {\n      case ToneMappingMode.LINEAR:\n        this.defines.set(\"toneMapping(texel)\", \"LinearToneMapping(texel)\");\n        break;\n      case ToneMappingMode.REINHARD:\n        this.defines.set(\"toneMapping(texel)\", \"ReinhardToneMapping(texel)\");\n        break;\n      case ToneMappingMode.CINEON:\n      case ToneMappingMode.OPTIMIZED_CINEON:\n        this.defines.set(\"toneMapping(texel)\", cineonToneMapping);\n        break;\n      case ToneMappingMode.ACES_FILMIC:\n        this.defines.set(\"toneMapping(texel)\", \"ACESFilmicToneMapping(texel)\");\n        break;\n      case ToneMappingMode.AGX:\n        this.defines.set(\"toneMapping(texel)\", \"AgXToneMapping(texel)\");\n        break;\n      case ToneMappingMode.NEUTRAL:\n        this.defines.set(\"toneMapping(texel)\", \"NeutralToneMapping(texel)\");\n        break;\n      default:\n        this.defines.set(\"toneMapping(texel)\", \"texel\");\n        break;\n    }\n    this.adaptiveLuminancePass.enabled = value === ToneMappingMode.REINHARD2_ADAPTIVE;\n    this.setChanged();\n  }\n  /**\n   * Returns the current tone mapping mode.\n   *\n   * @deprecated Use mode instead.\n   * @return {ToneMappingMode} The tone mapping mode.\n   */\n  getMode() {\n    return this.mode;\n  }\n  /**\n   * Sets the tone mapping mode.\n   *\n   * @deprecated Use mode instead.\n   * @param {ToneMappingMode} value - The tone mapping mode.\n   */\n  setMode(value) {\n    this.mode = value;\n  }\n  /**\n   * The white point. Default is `4.0`.\n   *\n   * Only applies to Reinhard2 (Modified & Adaptive).\n   *\n   * @type {Number}\n   */\n  get whitePoint() {\n    return this.uniforms.get(\"whitePoint\").value;\n  }\n  set whitePoint(value) {\n    this.uniforms.get(\"whitePoint\").value = value;\n  }\n  /**\n   * The middle grey factor. Default is `0.6`.\n   *\n   * Only applies to Reinhard2 (Modified & Adaptive).\n   *\n   * @type {Number}\n   */\n  get middleGrey() {\n    return this.uniforms.get(\"middleGrey\").value;\n  }\n  set middleGrey(value) {\n    this.uniforms.get(\"middleGrey\").value = value;\n  }\n  /**\n   * The average luminance.\n   *\n   * Only applies to Reinhard2 (Modified).\n   *\n   * @type {Number}\n   */\n  get averageLuminance() {\n    return this.uniforms.get(\"averageLuminance\").value;\n  }\n  set averageLuminance(value) {\n    this.uniforms.get(\"averageLuminance\").value = value;\n  }\n  /**\n   * The adaptive luminance material.\n   *\n   * @type {AdaptiveLuminanceMaterial}\n   */\n  get adaptiveLuminanceMaterial() {\n    return this.adaptiveLuminancePass.fullscreenMaterial;\n  }\n  /**\n   * Returns the adaptive luminance material.\n   *\n   * @deprecated Use adaptiveLuminanceMaterial instead.\n   * @return {AdaptiveLuminanceMaterial} The material.\n   */\n  getAdaptiveLuminanceMaterial() {\n    return this.adaptiveLuminanceMaterial;\n  }\n  /**\n   * The resolution of the luminance texture. Must be a power of two.\n   *\n   * @type {Number}\n   */\n  get resolution() {\n    return this.luminancePass.resolution.width;\n  }\n  set resolution(value) {\n    const exponent = Math.max(0, Math.ceil(Math.log2(value)));\n    const size = Math.pow(2, exponent);\n    this.luminancePass.resolution.setPreferredSize(size, size);\n    this.adaptiveLuminanceMaterial.mipLevel1x1 = exponent;\n  }\n  /**\n   * Returns the resolution of the luminance texture.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Number} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * Sets the resolution of the luminance texture. Must be a power of two.\n   *\n   * @deprecated Use resolution instead.\n   * @param {Number} value - The resolution.\n   */\n  setResolution(value) {\n    this.resolution = value;\n  }\n  /**\n   * Indicates whether this pass uses adaptive luminance.\n   *\n   * @type {Boolean}\n   * @deprecated Use mode instead.\n   */\n  get adaptive() {\n    return this.mode === ToneMappingMode.REINHARD2_ADAPTIVE;\n  }\n  set adaptive(value) {\n    this.mode = value ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.REINHARD2;\n  }\n  /**\n   * The luminance adaptation rate.\n   *\n   * @type {Number}\n   * @deprecated Use adaptiveLuminanceMaterial.adaptationRate instead.\n   */\n  get adaptationRate() {\n    return this.adaptiveLuminanceMaterial.adaptationRate;\n  }\n  set adaptationRate(value) {\n    this.adaptiveLuminanceMaterial.adaptationRate = value;\n  }\n  /**\n   * @type {Number}\n   * @deprecated\n   */\n  get distinction() {\n    console.warn(this.name, \"distinction was removed.\");\n    return 1;\n  }\n  set distinction(value) {\n    console.warn(this.name, \"distinction was removed.\");\n  }\n  /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */\n  update(renderer, inputBuffer, deltaTime) {\n    if (this.adaptiveLuminancePass.enabled) {\n      this.luminancePass.render(renderer, inputBuffer);\n      this.adaptiveLuminancePass.render(renderer, null, null, deltaTime);\n    }\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.adaptiveLuminancePass.initialize(renderer, alpha, frameBufferType);\n  }\n};\n\n// src/effects/VignetteEffect.js\n\n\n// src/effects/glsl/vignette.frag\nvar vignette_default = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#if VIGNETTE_TECHNIQUE == 0\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#else\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#endif\noutputColor=vec4(color,inputColor.a);}`;\n\n// src/effects/VignetteEffect.js\nvar VignetteEffect = class extends Effect {\n  /**\n   * Constructs a new Vignette effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {VignetteTechnique} [options.technique=VignetteTechnique.DEFAULT] - The Vignette technique.\n   * @param {Boolean} [options.eskil=false] - Deprecated. Use technique instead.\n   * @param {Number} [options.offset=0.5] - The Vignette offset.\n   * @param {Number} [options.darkness=0.5] - The Vignette darkness.\n   */\n  constructor({\n    blendFunction,\n    eskil = false,\n    technique = eskil ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT,\n    offset = 0.5,\n    darkness = 0.5\n  } = {}) {\n    super(\"VignetteEffect\", vignette_default, {\n      blendFunction,\n      defines: /* @__PURE__ */ new Map([\n        [\"VIGNETTE_TECHNIQUE\", technique.toFixed(0)]\n      ]),\n      uniforms: /* @__PURE__ */ new Map([\n        [\"offset\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(offset)],\n        [\"darkness\", new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(darkness)]\n      ])\n    });\n  }\n  /**\n   * The Vignette technique.\n   *\n   * @type {VignetteTechnique}\n   */\n  get technique() {\n    return Number(this.defines.get(\"VIGNETTE_TECHNIQUE\"));\n  }\n  set technique(value) {\n    if (this.technique !== value) {\n      this.defines.set(\"VIGNETTE_TECHNIQUE\", value.toFixed(0));\n      this.setChanged();\n    }\n  }\n  /**\n   * Indicates whether Eskil's Vignette technique is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use technique instead.\n   */\n  get eskil() {\n    return this.technique === VignetteTechnique.ESKIL;\n  }\n  /**\n   * Indicates whether Eskil's Vignette technique is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use technique instead.\n   */\n  set eskil(value) {\n    this.technique = value ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT;\n  }\n  /**\n   * Returns the Vignette technique.\n   *\n   * @deprecated Use technique instead.\n   * @return {VignetteTechnique} The technique.\n   */\n  getTechnique() {\n    return this.technique;\n  }\n  /**\n   * Sets the Vignette technique.\n   *\n   * @deprecated Use technique instead.\n   * @param {VignetteTechnique} value - The technique.\n   */\n  setTechnique(value) {\n    this.technique = value;\n  }\n  /**\n   * The Vignette offset.\n   *\n   * @type {Number}\n   */\n  get offset() {\n    return this.uniforms.get(\"offset\").value;\n  }\n  set offset(value) {\n    this.uniforms.get(\"offset\").value = value;\n  }\n  /**\n   * Returns the Vignette offset.\n   *\n   * @deprecated Use offset instead.\n   * @return {Number} The offset.\n   */\n  getOffset() {\n    return this.offset;\n  }\n  /**\n   * Sets the Vignette offset.\n   *\n   * @deprecated Use offset instead.\n   * @param {Number} value - The offset.\n   */\n  setOffset(value) {\n    this.offset = value;\n  }\n  /**\n   * The Vignette darkness.\n   *\n   * @type {Number}\n   */\n  get darkness() {\n    return this.uniforms.get(\"darkness\").value;\n  }\n  set darkness(value) {\n    this.uniforms.get(\"darkness\").value = value;\n  }\n  /**\n   * Returns the Vignette darkness.\n   *\n   * @deprecated Use darkness instead.\n   * @return {Number} The darkness.\n   */\n  getDarkness() {\n    return this.darkness;\n  }\n  /**\n   * Sets the Vignette darkness.\n   *\n   * @deprecated Use darkness instead.\n   * @param {Number} value - The darkness.\n   */\n  setDarkness(value) {\n    this.darkness = value;\n  }\n};\n\n// src/loaders/LUT3dlLoader.js\n\nvar LUT3dlLoader = class extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  /**\n   * Loads a LUT.\n   *\n   * @param {String} url - The URL of the 3dl-file.\n   * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.\n   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.\n   * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.\n   * @return {Promise<LookupTexture>} A promise that returns the lookup texture.\n   */\n  load(url, onLoad = () => {\n  }, onProgress = () => {\n  }, onError = null) {\n    const externalManager = this.manager;\n    const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(internalManager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"text\");\n    return new Promise((resolve, reject) => {\n      internalManager.onError = (url2) => {\n        externalManager.itemError(url2);\n        if (onError !== null) {\n          onError(`Failed to load ${url2}`);\n          resolve();\n        } else {\n          reject(`Failed to load ${url2}`);\n        }\n      };\n      externalManager.itemStart(url);\n      loader.load(url, (data) => {\n        try {\n          const result = this.parse(data);\n          externalManager.itemEnd(url);\n          onLoad(result);\n          resolve(result);\n        } catch (e) {\n          console.error(e);\n          internalManager.onError(url);\n        }\n      }, onProgress);\n    });\n  }\n  /**\n   * Parses the given data.\n   *\n   * @param {String} input - The LUT data.\n   * @return {LookupTexture} The lookup texture.\n   * @throws {Error} Fails if the data is invalid.\n   */\n  parse(input) {\n    const regExpGridInfo = /^[\\d ]+$/m;\n    const regExpDataPoints = /^([\\d.e+-]+) +([\\d.e+-]+) +([\\d.e+-]+) *$/gm;\n    let result = regExpGridInfo.exec(input);\n    if (result === null) {\n      throw new Error(\"Missing grid information\");\n    }\n    const gridLines = result[0].trim().split(/\\s+/g).map((n) => Number(n));\n    const gridStep = gridLines[1] - gridLines[0];\n    const size = gridLines.length;\n    const sizeSq = size ** 2;\n    for (let i = 1, l = gridLines.length; i < l; ++i) {\n      if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n        throw new Error(\"Inconsistent grid size\");\n      }\n    }\n    const data = new Float32Array(size ** 3 * 4);\n    let maxValue = 0;\n    let index = 0;\n    while ((result = regExpDataPoints.exec(input)) !== null) {\n      const r = Number(result[1]);\n      const g = Number(result[2]);\n      const b = Number(result[3]);\n      maxValue = Math.max(maxValue, r, g, b);\n      const bLayer = index % size;\n      const gLayer = Math.floor(index / size) % size;\n      const rLayer = Math.floor(index / sizeSq) % size;\n      const d4 = (bLayer * sizeSq + gLayer * size + rLayer) * 4;\n      data[d4 + 0] = r;\n      data[d4 + 1] = g;\n      data[d4 + 2] = b;\n      data[d4 + 3] = 1;\n      ++index;\n    }\n    const bits = Math.ceil(Math.log2(maxValue));\n    const maxBitValue = Math.pow(2, bits);\n    for (let i = 0, l = data.length; i < l; i += 4) {\n      data[i + 0] /= maxBitValue;\n      data[i + 1] /= maxBitValue;\n      data[i + 2] /= maxBitValue;\n    }\n    return new LookupTexture(data, size);\n  }\n};\n\n// src/loaders/LUTCubeLoader.js\n\nvar LUTCubeLoader = class extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  /**\n   * Loads a LUT.\n   *\n   * @param {String} url - The URL of the CUBE-file.\n   * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.\n   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.\n   * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.\n   * @return {Promise<LookupTexture>} A promise that returns the lookup texture.\n   */\n  load(url, onLoad = () => {\n  }, onProgress = () => {\n  }, onError = null) {\n    const externalManager = this.manager;\n    const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(internalManager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"text\");\n    return new Promise((resolve, reject) => {\n      internalManager.onError = (url2) => {\n        externalManager.itemError(url2);\n        if (onError !== null) {\n          onError(`Failed to load ${url2}`);\n          resolve();\n        } else {\n          reject(`Failed to load ${url2}`);\n        }\n      };\n      externalManager.itemStart(url);\n      loader.load(url, (data) => {\n        try {\n          const result = this.parse(data);\n          externalManager.itemEnd(url);\n          onLoad(result);\n          resolve(result);\n        } catch (e) {\n          console.error(e);\n          internalManager.onError(url);\n        }\n      }, onProgress);\n    });\n  }\n  /**\n   * Parses the given data.\n   *\n   * @param {String} input - The LUT data.\n   * @return {LookupTexture} The lookup texture.\n   * @throws {Error} Fails if the data is invalid.\n   */\n  parse(input) {\n    const regExpTitle = /TITLE +\"([^\"]*)\"/;\n    const regExpSize = /LUT_3D_SIZE +(\\d+)/;\n    const regExpDomainMin = /DOMAIN_MIN +([\\d.]+) +([\\d.]+) +([\\d.]+)/;\n    const regExpDomainMax = /DOMAIN_MAX +([\\d.]+) +([\\d.]+) +([\\d.]+)/;\n    const regExpDataPoints = /^([\\d.e+-]+) +([\\d.e+-]+) +([\\d.e+-]+) *$/gm;\n    let result = regExpTitle.exec(input);\n    const title = result !== null ? result[1] : null;\n    result = regExpSize.exec(input);\n    if (result === null) {\n      throw new Error(\"Missing LUT_3D_SIZE information\");\n    }\n    const size = Number(result[1]);\n    const data = new Float32Array(size ** 3 * 4);\n    const domainMin = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    const domainMax = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n    result = regExpDomainMin.exec(input);\n    if (result !== null) {\n      domainMin.set(Number(result[1]), Number(result[2]), Number(result[3]));\n    }\n    result = regExpDomainMax.exec(input);\n    if (result !== null) {\n      domainMax.set(Number(result[1]), Number(result[2]), Number(result[3]));\n    }\n    if (domainMin.x > domainMax.x || domainMin.y > domainMax.y || domainMin.z > domainMax.z) {\n      domainMin.set(0, 0, 0);\n      domainMax.set(1, 1, 1);\n      throw new Error(\"Invalid input domain\");\n    }\n    let i = 0;\n    while ((result = regExpDataPoints.exec(input)) !== null) {\n      data[i++] = Number(result[1]);\n      data[i++] = Number(result[2]);\n      data[i++] = Number(result[3]);\n      data[i++] = 1;\n    }\n    const lut = new LookupTexture(data, size);\n    lut.domainMin.copy(domainMin);\n    lut.domainMax.copy(domainMax);\n    if (title !== null) {\n      lut.name = title;\n    }\n    return lut;\n  }\n};\n\n// src/loaders/SMAAImageLoader.js\n\nvar SMAAImageLoader = class extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  /**\n   * Loads the SMAA data images.\n   *\n   * @param {Function} [onLoad] - A callback that receives the search image and area image as a pair.\n   * @param {Function} [onError] - An error callback that receives the URL of the image that failed to load.\n   * @return {Promise<Image[]>} A promise that returns the search image and area image as a pair.\n   */\n  load(onLoad = () => {\n  }, onError = null) {\n    if (arguments.length === 4) {\n      onLoad = arguments[1];\n      onError = arguments[3];\n    } else if (arguments.length === 3 || typeof arguments[0] !== \"function\") {\n      onLoad = arguments[1];\n      onError = null;\n    }\n    const externalManager = this.manager;\n    const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    return new Promise((resolve, reject) => {\n      const searchImage = new Image();\n      const areaImage = new Image();\n      internalManager.onError = (url) => {\n        externalManager.itemError(url);\n        if (onError !== null) {\n          onError(`Failed to load ${url}`);\n          resolve();\n        } else {\n          reject(`Failed to load ${url}`);\n        }\n      };\n      internalManager.onLoad = () => {\n        const result = [searchImage, areaImage];\n        onLoad(result);\n        resolve(result);\n      };\n      searchImage.addEventListener(\"error\", (e) => {\n        internalManager.itemError(\"smaa-search\");\n      });\n      areaImage.addEventListener(\"error\", (e) => {\n        internalManager.itemError(\"smaa-area\");\n      });\n      searchImage.addEventListener(\"load\", () => {\n        externalManager.itemEnd(\"smaa-search\");\n        internalManager.itemEnd(\"smaa-search\");\n      });\n      areaImage.addEventListener(\"load\", () => {\n        externalManager.itemEnd(\"smaa-area\");\n        internalManager.itemEnd(\"smaa-area\");\n      });\n      externalManager.itemStart(\"smaa-search\");\n      externalManager.itemStart(\"smaa-area\");\n      internalManager.itemStart(\"smaa-search\");\n      internalManager.itemStart(\"smaa-area\");\n      searchImage.src = searchImageDataURL_default;\n      areaImage.src = areaImageDataURL_default;\n    });\n  }\n};\n\n// src/materials/BoxBlurMaterial.js\n\n\n// src/materials/glsl/convolution.box.frag\nvar convolution_box_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef BILATERAL\n#include <packing>\nuniform vec2 cameraNearFar;\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nfloat getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}\n#ifdef PERSPECTIVE_CAMERA\n#define linearDepth(v) viewZToOrthographicDepth(getViewZ(readDepth(v)), cameraNearFar.x, cameraNearFar.y)\n#else\n#define linearDepth(v) readDepth(v)\n#endif\n#endif\n#define getTexel(v) texture2D(inputBuffer, v)\n#if KERNEL_SIZE == 3\nvarying vec2 vUv00,vUv01,vUv02;varying vec2 vUv03,vUv04,vUv05;varying vec2 vUv06,vUv07,vUv08;\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\nvarying vec2 vUv00,vUv01,vUv02,vUv03,vUv04;varying vec2 vUv05,vUv06,vUv07,vUv08,vUv09;varying vec2 vUv10,vUv11,vUv12,vUv13,vUv14;varying vec2 vUv15,vUv16,vUv17,vUv18,vUv19;varying vec2 vUv20,vUv21,vUv22,vUv23,vUv24;\n#else\nuniform vec2 texelSize;uniform float scale;varying vec2 vUv;\n#endif\nvoid main(){\n#if KERNEL_SIZE == 3\nvec4 c[]=vec4[KERNEL_SIZE_SQ](getTexel(vUv00),getTexel(vUv01),getTexel(vUv02),getTexel(vUv03),getTexel(vUv04),getTexel(vUv05),getTexel(vUv06),getTexel(vUv07),getTexel(vUv08));\n#ifdef BILATERAL\nfloat z[]=float[KERNEL_SIZE_SQ](linearDepth(vUv00),linearDepth(vUv01),linearDepth(vUv02),linearDepth(vUv03),linearDepth(vUv04),linearDepth(vUv05),linearDepth(vUv06),linearDepth(vUv07),linearDepth(vUv08));\n#endif\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\nvec4 c[]=vec4[KERNEL_SIZE_SQ](getTexel(vUv00),getTexel(vUv01),getTexel(vUv02),getTexel(vUv03),getTexel(vUv04),getTexel(vUv05),getTexel(vUv06),getTexel(vUv07),getTexel(vUv08),getTexel(vUv09),getTexel(vUv10),getTexel(vUv11),getTexel(vUv12),getTexel(vUv13),getTexel(vUv14),getTexel(vUv15),getTexel(vUv16),getTexel(vUv17),getTexel(vUv18),getTexel(vUv19),getTexel(vUv20),getTexel(vUv21),getTexel(vUv22),getTexel(vUv23),getTexel(vUv24));\n#ifdef BILATERAL\nfloat z[]=float[KERNEL_SIZE_SQ](linearDepth(vUv00),linearDepth(vUv01),linearDepth(vUv02),linearDepth(vUv03),linearDepth(vUv04),linearDepth(vUv05),linearDepth(vUv06),linearDepth(vUv07),linearDepth(vUv08),linearDepth(vUv09),linearDepth(vUv10),linearDepth(vUv11),linearDepth(vUv12),linearDepth(vUv13),linearDepth(vUv14),linearDepth(vUv15),linearDepth(vUv16),linearDepth(vUv17),linearDepth(vUv18),linearDepth(vUv19),linearDepth(vUv20),linearDepth(vUv21),linearDepth(vUv22),linearDepth(vUv23),linearDepth(vUv24));\n#endif\n#endif\nvec4 result=vec4(0.0);\n#ifdef BILATERAL\nfloat w=0.0;\n#if KERNEL_SIZE == 3 || (KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13)\nfloat centerDepth=z[KERNEL_SIZE_SQ_HALF];for(int i=0;i<KERNEL_SIZE_SQ;++i){float d=step(abs(z[i]-centerDepth),DISTANCE_THRESHOLD);result+=c[i]*d;w+=d;}\n#else\nfloat centerDepth=linearDepth(vUv);vec2 s=texelSize*scale;for(int x=-KERNEL_SIZE_HALF;x<=KERNEL_SIZE_HALF;++x){for(int y=-KERNEL_SIZE_HALF;y<=KERNEL_SIZE_HALF;++y){vec2 coords=vUv+vec2(x,y)*s;vec4 c=getTexel(coords);float z=(x==0&&y==0)?centerDepth:linearDepth(coords);float d=step(abs(z-centerDepth),DISTANCE_THRESHOLD);result+=c*d;w+=d;}}\n#endif\ngl_FragColor=result/max(w,1.0);\n#else\n#if KERNEL_SIZE == 3 || (KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13)\nfor(int i=0;i<KERNEL_SIZE_SQ;++i){result+=c[i];}\n#else\nvec2 s=texelSize*scale;for(int x=-KERNEL_SIZE_HALF;x<=KERNEL_SIZE_HALF;++x){for(int y=-KERNEL_SIZE_HALF;y<=KERNEL_SIZE_HALF;++y){result+=getTexel(uv+vec2(x,y)*s);}}\n#endif\ngl_FragColor=result*INV_KERNEL_SIZE_SQ;\n#endif\n}`;\n\n// src/materials/glsl/convolution.box.vert\nvar convolution_box_default2 = `uniform vec2 texelSize;uniform float scale;\n#if KERNEL_SIZE == 3\nvarying vec2 vUv00,vUv01,vUv02;varying vec2 vUv03,vUv04,vUv05;varying vec2 vUv06,vUv07,vUv08;\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\nvarying vec2 vUv00,vUv01,vUv02,vUv03,vUv04;varying vec2 vUv05,vUv06,vUv07,vUv08,vUv09;varying vec2 vUv10,vUv11,vUv12,vUv13,vUv14;varying vec2 vUv15,vUv16,vUv17,vUv18,vUv19;varying vec2 vUv20,vUv21,vUv22,vUv23,vUv24;\n#else\nvarying vec2 vUv;\n#endif\nvoid main(){vec2 uv=position.xy*0.5+0.5;\n#if KERNEL_SIZE == 3\nvec2 s=texelSize*scale;vUv00=uv+s*vec2(-1.0,-1.0);vUv01=uv+s*vec2(0.0,-1.0);vUv02=uv+s*vec2(1.0,-1.0);vUv03=uv+s*vec2(-1.0,0.0);vUv04=uv;vUv05=uv+s*vec2(1.0,0.0);vUv06=uv+s*vec2(-1.0,1.0);vUv07=uv+s*vec2(0.0,1.0);vUv08=uv+s*vec2(1.0,1.0);\n#elif KERNEL_SIZE == 5\nvec2 s=texelSize*scale;vUv00=uv+s*vec2(-2.0,-2.0);vUv01=uv+s*vec2(-1.0,-2.0);vUv02=uv+s*vec2(0.0,-2.0);vUv03=uv+s*vec2(1.0,-2.0);vUv04=uv+s*vec2(2.0,-2.0);vUv05=uv+s*vec2(-2.0,-1.0);vUv06=uv+s*vec2(-1.0,-1.0);vUv07=uv+s*vec2(0.0,-1.0);vUv08=uv+s*vec2(1.0,-1.0);vUv09=uv+s*vec2(2.0,-1.0);vUv10=uv+s*vec2(-2.0,0.0);vUv11=uv+s*vec2(-1.0,0.0);vUv12=uv;vUv13=uv+s*vec2(1.0,0.0);vUv14=uv+s*vec2(2.0,0.0);vUv15=uv+s*vec2(-2.0,1.0);vUv16=uv+s*vec2(-1.0,1.0);vUv17=uv+s*vec2(0.0,1.0);vUv18=uv+s*vec2(1.0,1.0);vUv19=uv+s*vec2(2.0,1.0);vUv20=uv+s*vec2(-2.0,2.0);vUv21=uv+s*vec2(-1.0,2.0);vUv22=uv+s*vec2(0.0,2.0);vUv23=uv+s*vec2(1.0,2.0);vUv24=uv+s*vec2(2.0,2.0);\n#else\nvUv=uv;\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/BoxBlurMaterial.js\nvar BoxBlurMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new box blur material.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.bilateral=false] - Enables or disables bilateral blurring.\n   * @param {Number} [options.kernelSize=5] - The kernel size.\n   */\n  constructor({ bilateral = false, kernelSize = 5 } = {}) {\n    super({\n      name: \"BoxBlurMaterial\",\n      defines: {\n        DEPTH_PACKING: \"0\",\n        DISTANCE_THRESHOLD: \"0.1\"\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        normalDepthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        cameraNearFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_box_default,\n      vertexShader: convolution_box_default2\n    });\n    this.bilateral = bilateral;\n    this.kernelSize = kernelSize;\n    this.maxVaryingVectors = 8;\n  }\n  /**\n   * The maximum amount of varying vectors.\n   *\n   * Should be synced with `renderer.capabilities.maxVaryings`. Default is 8.\n   *\n   * @type {Number}\n   */\n  set maxVaryingVectors(value) {\n    this.defines.MAX_VARYING_VECTORS = value.toFixed(0);\n  }\n  /**\n   * The kernel size.\n   *\n   * - Must be an odd number\n   * - Kernel size 3 and 5 use optimized code paths\n   * - Default is 5\n   *\n   * @type {Number}\n   */\n  get kernelSize() {\n    return Number(this.defines.KERNEL_SIZE);\n  }\n  set kernelSize(value) {\n    if (value % 2 === 0) {\n      throw new Error(\"The kernel size must be an odd number\");\n    }\n    this.defines.KERNEL_SIZE = value.toFixed(0);\n    this.defines.KERNEL_SIZE_HALF = Math.floor(value / 2).toFixed(0);\n    this.defines.KERNEL_SIZE_SQ = (value ** 2).toFixed(0);\n    this.defines.KERNEL_SIZE_SQ_HALF = Math.floor(value ** 2 / 2).toFixed(0);\n    this.defines.INV_KERNEL_SIZE_SQ = (1 / value ** 2).toFixed(6);\n    this.needsUpdate = true;\n  }\n  /**\n   * The blur scale.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.uniforms.scale.value;\n  }\n  set scale(value) {\n    this.uniforms.scale.value = value;\n  }\n  /**\n   * The current near plane setting.\n   *\n   * @type {Number}\n   * @private\n   */\n  get near() {\n    return this.uniforms.cameraNearFar.value.x;\n  }\n  /**\n   * The current far plane setting.\n   *\n   * @type {Number}\n   * @private\n   */\n  get far() {\n    return this.uniforms.cameraNearFar.value.y;\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * A combined normal-depth buffer. Overrides {@link depthBuffer} if set.\n   *\n   * @type {Texture}\n   */\n  set normalDepthBuffer(value) {\n    this.uniforms.normalDepthBuffer.value = value;\n    if (value !== null) {\n      this.defines.NORMAL_DEPTH = \"1\";\n    } else {\n      delete this.defines.NORMAL_DEPTH;\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Indicates whether bilateral filtering is enabled.\n   *\n   * @type {Boolean}\n   */\n  get bilateral() {\n    return this.defines.BILATERAL !== void 0;\n  }\n  set bilateral(value) {\n    if (value !== null) {\n      this.defines.BILATERAL = \"1\";\n    } else {\n      delete this.defines.BILATERAL;\n    }\n    this.needsUpdate = true;\n  }\n  /**\n   * The bilateral filter distance threshold in world units.\n   *\n   * @type {Number}\n   */\n  get worldDistanceThreshold() {\n    return -orthographicDepthToViewZ(Number(this.defines.DISTANCE_THRESHOLD), this.near, this.far);\n  }\n  set worldDistanceThreshold(value) {\n    const threshold = viewZToOrthographicDepth(-value, this.near, this.far);\n    this.defines.DISTANCE_THRESHOLD = threshold.toFixed(12);\n    this.needsUpdate = true;\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  copyCameraSettings(camera) {\n    if (camera) {\n      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);\n      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n        this.defines.PERSPECTIVE_CAMERA = \"1\";\n      } else {\n        delete this.defines.PERSPECTIVE_CAMERA;\n      }\n      this.needsUpdate = true;\n    }\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/materials/DepthCopyMaterial.js\n\n\n// src/materials/glsl/depth-copy.frag\nvar depth_copy_default = `#include <packing>\nvarying vec2 vUv;\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\n#if INPUT_DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if INPUT_DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nvoid main(){\n#if INPUT_DEPTH_PACKING == OUTPUT_DEPTH_PACKING\ngl_FragColor=texture2D(depthBuffer,vUv);\n#else\nfloat depth=readDepth(vUv);\n#if OUTPUT_DEPTH_PACKING == 3201\ngl_FragColor=(depth==1.0)?vec4(1.0):packDepthToRGBA(depth);\n#else\ngl_FragColor=vec4(vec3(depth),1.0);\n#endif\n#endif\n}`;\n\n// src/materials/glsl/depth-copy.vert\nvar depth_copy_default2 = `varying vec2 vUv;\n#if DEPTH_COPY_MODE == 1\nuniform vec2 texelPosition;\n#endif\nvoid main(){\n#if DEPTH_COPY_MODE == 1\nvUv=texelPosition;\n#else\nvUv=position.xy*0.5+0.5;\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/DepthCopyMaterial.js\nvar DepthCopyMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new depth copy material.\n   */\n  constructor() {\n    super({\n      name: \"DepthCopyMaterial\",\n      defines: {\n        INPUT_DEPTH_PACKING: \"0\",\n        OUTPUT_DEPTH_PACKING: \"0\",\n        DEPTH_COPY_MODE: \"0\"\n      },\n      uniforms: {\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelPosition: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: depth_copy_default,\n      vertexShader: depth_copy_default2\n    });\n    this.depthCopyMode = DepthCopyMode.FULL;\n  }\n  /**\n   * The input depth buffer.\n   *\n   * @type {Texture}\n   */\n  get depthBuffer() {\n    return this.uniforms.depthBuffer.value;\n  }\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The input depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  set inputDepthPacking(value) {\n    this.defines.INPUT_DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * The output depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  get outputDepthPacking() {\n    return Number(this.defines.OUTPUT_DEPTH_PACKING);\n  }\n  set outputDepthPacking(value) {\n    this.defines.OUTPUT_DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the input depth buffer.\n   *\n   * @deprecated Use depthBuffer and inputDepthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer = buffer;\n    this.inputDepthPacking = depthPacking;\n  }\n  /**\n   * Returns the current input depth packing strategy.\n   *\n   * @deprecated\n   * @return {DepthPackingStrategies} The input depth packing strategy.\n   */\n  getInputDepthPacking() {\n    return Number(this.defines.INPUT_DEPTH_PACKING);\n  }\n  /**\n   * Sets the input depth packing strategy.\n   *\n   * @deprecated Use inputDepthPacking instead.\n   * @param {DepthPackingStrategies} value - The new input depth packing strategy.\n   */\n  setInputDepthPacking(value) {\n    this.defines.INPUT_DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the current output depth packing strategy.\n   *\n   * @deprecated Use outputDepthPacking instead.\n   * @return {DepthPackingStrategies} The output depth packing strategy.\n   */\n  getOutputDepthPacking() {\n    return Number(this.defines.OUTPUT_DEPTH_PACKING);\n  }\n  /**\n   * Sets the output depth packing strategy.\n   *\n   * @deprecated Use outputDepthPacking instead.\n   * @param {DepthPackingStrategies} value - The new output depth packing strategy.\n   */\n  setOutputDepthPacking(value) {\n    this.defines.OUTPUT_DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * The screen space position used for single-texel copy operations.\n   *\n   * @type {Vector2}\n   */\n  get texelPosition() {\n    return this.uniforms.texelPosition.value;\n  }\n  /**\n   * Returns the screen space position used for single-texel copy operations.\n   *\n   * @deprecated Use texelPosition instead.\n   * @return {Vector2} The position.\n   */\n  getTexelPosition() {\n    return this.uniforms.texelPosition.value;\n  }\n  /**\n   * Sets the screen space position used for single-texel copy operations.\n   *\n   * @deprecated\n   * @param {Vector2} value - The position.\n   */\n  setTexelPosition(value) {\n    this.uniforms.texelPosition.value = value;\n  }\n  /**\n   * The depth copy mode.\n   *\n   * @type {DepthCopyMode}\n   */\n  get mode() {\n    return this.depthCopyMode;\n  }\n  set mode(value) {\n    this.depthCopyMode = value;\n    this.defines.DEPTH_COPY_MODE = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Returns the depth copy mode.\n   *\n   * @deprecated Use mode instead.\n   * @return {DepthCopyMode} The depth copy mode.\n   */\n  getMode() {\n    return this.mode;\n  }\n  /**\n   * Sets the depth copy mode.\n   *\n   * @deprecated Use mode instead.\n   * @param {DepthCopyMode} value - The new mode.\n   */\n  setMode(value) {\n    this.mode = value;\n  }\n};\n\n// src/materials/EffectMaterial.js\n\n\n// src/materials/glsl/effect.frag\nvar effect_default = `#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}`;\n\n// src/materials/glsl/effect.vert\nvar effect_default2 = `uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/EffectMaterial.js\nvar EffectMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new effect material.\n   *\n   * @param {Map<String, String>} [shaderParts] - Deprecated. Use setShaderData instead.\n   * @param {Map<String, String>} [defines] - Deprecated. Use setShaderData instead.\n   * @param {Map<String, Uniform>} [uniforms] - Deprecated. Use setShaderData instead.\n   * @param {Camera} [camera] - A camera.\n   * @param {Boolean} [dithering=false] - Deprecated.\n   */\n  constructor(shaderParts, defines, uniforms, camera, dithering = false) {\n    super({\n      name: \"EffectMaterial\",\n      defines: {\n        THREE_REVISION: three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"),\n        DEPTH_PACKING: \"0\",\n        ENCODE_OUTPUT: \"1\"\n      },\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        cameraNear: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.3),\n        cameraFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1e3),\n        aspect: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n        time: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      dithering\n    });\n    if (shaderParts) {\n      this.setShaderParts(shaderParts);\n    }\n    if (defines) {\n      this.setDefines(defines);\n    }\n    if (uniforms) {\n      this.setUniforms(uniforms);\n    }\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */\n  setInputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */\n  get depthBuffer() {\n    return this.uniforms.depthBuffer.value;\n  }\n  set depthBuffer(value) {\n    this.uniforms.depthBuffer.value = value;\n  }\n  /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  get depthPacking() {\n    return Number(this.defines.DEPTH_PACKING);\n  }\n  set depthPacking(value) {\n    this.defines.DEPTH_PACKING = value.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.depthBuffer = buffer;\n    this.depthPacking = depthPacking;\n  }\n  /**\n   * Sets the shader data.\n   *\n   * @param {EffectShaderData} data - The shader data.\n   * @return {EffectMaterial} This material.\n   */\n  setShaderData(data) {\n    this.setShaderParts(data.shaderParts);\n    this.setDefines(data.defines);\n    this.setUniforms(data.uniforms);\n    this.setExtensions(data.extensions);\n  }\n  /**\n   * Sets the shader parts.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Map<String, String>} shaderParts - A collection of shader snippets. See {@link EffectShaderSection}.\n   * @return {EffectMaterial} This material.\n   */\n  setShaderParts(shaderParts) {\n    this.fragmentShader = effect_default.replace(EffectShaderSection.FRAGMENT_HEAD, shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || \"\").replace(EffectShaderSection.FRAGMENT_MAIN_UV, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || \"\").replace(EffectShaderSection.FRAGMENT_MAIN_IMAGE, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || \"\");\n    this.vertexShader = effect_default2.replace(EffectShaderSection.VERTEX_HEAD, shaderParts.get(EffectShaderSection.VERTEX_HEAD) || \"\").replace(EffectShaderSection.VERTEX_MAIN_SUPPORT, shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || \"\");\n    this.needsUpdate = true;\n    return this;\n  }\n  /**\n   * Sets the shader macros.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Map<String, String>} defines - A collection of preprocessor macro definitions.\n   * @return {EffectMaterial} This material.\n   */\n  setDefines(defines) {\n    for (const entry of defines.entries()) {\n      this.defines[entry[0]] = entry[1];\n    }\n    this.needsUpdate = true;\n    return this;\n  }\n  /**\n   * Sets the shader uniforms.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Map<String, Uniform>} uniforms - A collection of uniforms.\n   * @return {EffectMaterial} This material.\n   */\n  setUniforms(uniforms) {\n    for (const entry of uniforms.entries()) {\n      this.uniforms[entry[0]] = entry[1];\n    }\n    return this;\n  }\n  /**\n   * Sets the required shader extensions.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Set<WebGLExtension>} extensions - A collection of extensions.\n   * @return {EffectMaterial} This material.\n   */\n  setExtensions(extensions) {\n    this.extensions = {};\n    for (const extension of extensions) {\n      this.extensions[extension] = true;\n    }\n    return this;\n  }\n  /**\n   * Indicates whether output encoding is enabled.\n   *\n   * @type {Boolean}\n   */\n  get encodeOutput() {\n    return this.defines.ENCODE_OUTPUT !== void 0;\n  }\n  set encodeOutput(value) {\n    if (this.encodeOutput !== value) {\n      if (value) {\n        this.defines.ENCODE_OUTPUT = \"1\";\n      } else {\n        delete this.defines.ENCODE_OUTPUT;\n      }\n      this.needsUpdate = true;\n    }\n  }\n  /**\n   * Indicates whether output encoding is enabled.\n   *\n   * @deprecated Use encodeOutput instead.\n   * @return {Boolean} Whether output encoding is enabled.\n   */\n  isOutputEncodingEnabled(value) {\n    return this.encodeOutput;\n  }\n  /**\n   * Enables or disables output encoding.\n   *\n   * @deprecated Use encodeOutput instead.\n   * @param {Boolean} value - Whether output encoding should be enabled.\n   */\n  setOutputEncodingEnabled(value) {\n    this.encodeOutput = value;\n  }\n  /**\n   * The time in seconds.\n   *\n   * @type {Number}\n   */\n  get time() {\n    return this.uniforms.time.value;\n  }\n  set time(value) {\n    this.uniforms.time.value = value;\n  }\n  /**\n   * Sets the delta time.\n   *\n   * @deprecated Use time instead.\n   * @param {Number} value - The delta time in seconds.\n   */\n  setDeltaTime(value) {\n    this.uniforms.time.value += value;\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */\n  adoptCameraSettings(camera) {\n    this.copyCameraSettings(camera);\n  }\n  /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */\n  copyCameraSettings(camera) {\n    if (camera) {\n      this.uniforms.cameraNear.value = camera.near;\n      this.uniforms.cameraFar.value = camera.far;\n      if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n        this.defines.PERSPECTIVE_CAMERA = \"1\";\n      } else {\n        delete this.defines.PERSPECTIVE_CAMERA;\n      }\n      this.needsUpdate = true;\n    }\n  }\n  /**\n   * Sets the resolution.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const uniforms = this.uniforms;\n    uniforms.resolution.value.set(width, height);\n    uniforms.texelSize.value.set(1 / width, 1 / height);\n    uniforms.aspect.value = width / height;\n  }\n  /**\n   * An enumeration of shader code placeholders.\n   *\n   * @deprecated Use EffectShaderSection instead.\n   * @type {Object}\n   */\n  static get Section() {\n    return EffectShaderSection;\n  }\n};\n\n// src/materials/GaussianBlurMaterial.js\n\n\n// src/materials/glsl/convolution.gaussian.frag\nvar convolution_gaussian_default = `#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform vec2 kernel[STEPS];varying vec2 vOffset;varying vec2 vUv;void main(){vec4 result=texture2D(inputBuffer,vUv)*kernel[0].y;for(int i=1;i<STEPS;++i){vec2 offset=kernel[i].x*vOffset;vec4 c0=texture2D(inputBuffer,vUv+offset);vec4 c1=texture2D(inputBuffer,vUv-offset);result+=(c0+c1)*kernel[i].y;}gl_FragColor=result;\n#include <colorspace_fragment>\n}`;\n\n// src/materials/glsl/convolution.gaussian.vert\nvar convolution_gaussian_default2 = `uniform vec2 texelSize;uniform vec2 direction;uniform float scale;varying vec2 vOffset;varying vec2 vUv;void main(){vOffset=direction*texelSize*scale;vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}`;\n\n// src/materials/GaussianBlurMaterial.js\nvar GaussianBlurMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n  /**\n   * Constructs a new convolution material.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.kernelSize=35] - The kernel size.\n   */\n  constructor({ kernelSize = 35 } = {}) {\n    super({\n      name: \"GaussianBlurMaterial\",\n      uniforms: {\n        inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        direction: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n        kernel: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n        scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n      },\n      blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n      toneMapped: false,\n      depthWrite: false,\n      depthTest: false,\n      fragmentShader: convolution_gaussian_default,\n      vertexShader: convolution_gaussian_default2\n    });\n    this._kernelSize = 0;\n    this.kernelSize = kernelSize;\n  }\n  /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */\n  set inputBuffer(value) {\n    this.uniforms.inputBuffer.value = value;\n  }\n  /**\n   * The kernel size.\n   *\n   * @type {Number}\n   */\n  get kernelSize() {\n    return this._kernelSize;\n  }\n  set kernelSize(value) {\n    this._kernelSize = value;\n    this.generateKernel(value);\n  }\n  /**\n   * The blur direction.\n   *\n   * @type {Vector2}\n   */\n  get direction() {\n    return this.uniforms.direction.value;\n  }\n  /**\n   * The blur kernel scale. Values greater than 1.0 may introduce artifacts.\n   *\n   * @type {Number}\n   */\n  get scale() {\n    return this.uniforms.scale.value;\n  }\n  set scale(value) {\n    this.uniforms.scale.value = value;\n  }\n  /**\n   * Generates the Gauss kernel.\n   *\n   * @param {KernelSize} kernelSize - The kernel size. Should be an odd number.\n   * @private\n   */\n  generateKernel(kernelSize) {\n    const kernel = new GaussKernel(kernelSize);\n    const steps = kernel.linearSteps;\n    const kernelData = new Float64Array(steps * 2);\n    for (let i = 0, j = 0; i < steps; ++i) {\n      kernelData[j++] = kernel.linearOffsets[i];\n      kernelData[j++] = kernel.linearWeights[i];\n    }\n    this.uniforms.kernel.value = kernelData;\n    this.defines.STEPS = steps.toFixed(0);\n    this.needsUpdate = true;\n  }\n  /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.uniforms.texelSize.value.set(1 / width, 1 / height);\n  }\n};\n\n// src/passes/BoxBlurPass.js\n\nvar BoxBlurPass = class extends Pass {\n  /**\n   * Constructs a new box blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.kernelSize=5] - Must be an odd number. The sizes 3 and 5 use optimized code paths.\n   * @param {Number} [options.iterations=1] - The amount of times the blur should be applied.\n   * @param {Number} [options.bilateral=false] - Enables or disables bilateral blurring.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */\n  constructor({\n    kernelSize = 5,\n    iterations = 1,\n    bilateral = false,\n    resolutionScale = 1,\n    resolutionX = Resolution.AUTO_SIZE,\n    resolutionY = Resolution.AUTO_SIZE\n  } = {}) {\n    super(\"BoxBlurPass\");\n    this.needsDepthTexture = bilateral;\n    this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetA.texture.name = \"Blur.Target.A\";\n    this.renderTargetB = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetB.texture.name = \"Blur.Target.B\";\n    this.blurMaterial = new BoxBlurMaterial({ bilateral, kernelSize });\n    this.copyMaterial = new CopyMaterial();\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this.iterations = iterations;\n  }\n  set mainCamera(value) {\n    this.blurMaterial.copyCameraSettings(value);\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.blurMaterial.depthBuffer = depthTexture;\n    this.blurMaterial.depthPacking = depthPacking;\n  }\n  /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const renderTargetA = this.renderTargetA;\n    const renderTargetB = this.renderTargetB;\n    const blurMaterial = this.blurMaterial;\n    this.fullscreenMaterial = blurMaterial;\n    let previousBuffer = inputBuffer;\n    for (let i = 0, l = Math.max(this.iterations, 1); i < l; ++i) {\n      const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;\n      blurMaterial.inputBuffer = previousBuffer.texture;\n      renderer.setRenderTarget(buffer);\n      renderer.render(scene, camera);\n      previousBuffer = buffer;\n    }\n    this.copyMaterial.inputBuffer = previousBuffer.texture;\n    this.fullscreenMaterial = this.copyMaterial;\n    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n    renderer.render(scene, camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.renderTargetA.setSize(w, h);\n    this.renderTargetB.setSize(w, h);\n    this.blurMaterial.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (renderer !== null) {\n      this.blurMaterial.maxVaryingVectors = renderer.capabilities.maxVaryings;\n    }\n    if (frameBufferType !== void 0) {\n      this.renderTargetA.texture.type = frameBufferType;\n      this.renderTargetB.texture.type = frameBufferType;\n      if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n      } else if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        this.renderTargetA.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        this.renderTargetB.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n      }\n    }\n  }\n};\n\n// src/passes/DepthPickingPass.js\n\n\n// src/passes/DepthCopyPass.js\n\nvar DepthCopyPass = class extends Pass {\n  /**\n   * Constructs a new depth save pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The output depth packing.\n   */\n  constructor({ depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking } = {}) {\n    super(\"DepthCopyPass\");\n    const material = new DepthCopyMaterial();\n    material.outputDepthPacking = depthPacking;\n    this.fullscreenMaterial = material;\n    this.needsDepthTexture = true;\n    this.needsSwap = false;\n    this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n      type: depthPacking === three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking ? three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType : three__WEBPACK_IMPORTED_MODULE_0__.FloatType,\n      minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n      magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n      depthBuffer: false\n    });\n    this.renderTarget.texture.name = \"DepthCopyPass.Target\";\n  }\n  /**\n   * The output depth texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the output depth texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * The output depth packing.\n   *\n   * @type {DepthPackingStrategies}\n   */\n  get depthPacking() {\n    return this.fullscreenMaterial.outputDepthPacking;\n  }\n  /**\n   * Returns the output depth packing.\n   *\n   * @deprecated Use depthPacking instead.\n   * @return {DepthPackingStrategies} The depth packing.\n   */\n  getDepthPacking() {\n    return this.fullscreenMaterial.outputDepthPacking;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.fullscreenMaterial.depthBuffer = depthTexture;\n    this.fullscreenMaterial.inputDepthPacking = depthPacking;\n  }\n  /**\n   * Copies depth from a depth texture.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n    renderer.render(this.scene, this.camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.renderTarget.setSize(width, height);\n  }\n};\n\n// src/passes/DepthPickingPass.js\nvar threeRevision = Number(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\nvar unpackDownscale = 255 / 256;\nvar unpackFactorsLegacy = new Float32Array([\n  unpackDownscale / 256 ** 3,\n  unpackDownscale / 256 ** 2,\n  unpackDownscale / 256,\n  unpackDownscale\n]);\nvar unpackFactors = new Float32Array([\n  unpackDownscale,\n  unpackDownscale / 256,\n  unpackDownscale / 256 ** 2,\n  1 / 256 ** 3\n]);\nfunction unpackRGBAToDepth(packedDepth) {\n  const f = threeRevision >= 167 ? unpackFactors : unpackFactorsLegacy;\n  return (packedDepth[0] * f[0] + packedDepth[1] * f[1] + packedDepth[2] * f[2] + packedDepth[3] * f[3]) / 255;\n}\nvar DepthPickingPass = class extends DepthCopyPass {\n  /**\n   * Constructs a new depth picking pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The depth packing.\n   * @param {Number} [options.mode=DepthCopyMode.SINGLE] - The depth copy mode.\n   */\n  constructor({ depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking, mode = DepthCopyMode.SINGLE } = {}) {\n    if (depthPacking !== three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking && depthPacking !== three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n      throw new Error(`Unsupported depth packing: ${depthPacking}`);\n    }\n    super({ depthPacking });\n    this.name = \"DepthPickingPass\";\n    this.fullscreenMaterial.mode = mode;\n    this.pixelBuffer = depthPacking === three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking ? new Uint8Array(4) : new Float32Array(4);\n    this.callback = null;\n  }\n  /**\n   * Reads depth at a specific screen position.\n   *\n   * Only one depth value can be picked per frame. Calling this method multiple times per frame will overwrite the\n   * picking coordinates. Unresolved promises will be abandoned.\n   *\n   * @example\n   * const ndc = new Vector3();\n   * const clientRect = myViewport.getBoundingClientRect();\n   * const clientX = pointerEvent.clientX - clientRect.left;\n   * const clientY = pointerEvent.clientY - clientRect.top;\n   * ndc.x = (clientX / myViewport.clientWidth) * 2.0 - 1.0;\n   * ndc.y = -(clientY / myViewport.clientHeight) * 2.0 + 1.0;\n   * const depth = await depthPickingPass.readDepth(ndc);\n   * ndc.z = depth * 2.0 - 1.0;\n   *\n   * const worldPosition = ndc.unproject(camera);\n   *\n   * @param {Vector2|Vector3} ndc - Normalized device coordinates. Only X and Y are relevant.\n   * @return {Promise<Number>} A promise that returns the depth on the next frame.\n   */\n  readDepth(ndc) {\n    this.fullscreenMaterial.texelPosition.set(ndc.x * 0.5 + 0.5, ndc.y * 0.5 + 0.5);\n    return new Promise((resolve) => {\n      this.callback = resolve;\n    });\n  }\n  /**\n   * Copies depth and resolves depth picking promises.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const material = this.fullscreenMaterial;\n    const mode = material.mode;\n    if (mode === DepthCopyMode.FULL) {\n      super.render(renderer);\n    }\n    if (this.callback !== null) {\n      const renderTarget = this.renderTarget;\n      const pixelBuffer = this.pixelBuffer;\n      const packed = renderTarget.texture.type !== three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n      let x = 0, y = 0;\n      if (mode === DepthCopyMode.SINGLE) {\n        super.render(renderer);\n      } else {\n        const texelPosition = material.texelPosition;\n        x = Math.round(texelPosition.x * renderTarget.width);\n        y = Math.round(texelPosition.y * renderTarget.height);\n      }\n      renderer.readRenderTargetPixels(renderTarget, x, y, 1, 1, pixelBuffer);\n      this.callback(packed ? unpackRGBAToDepth(pixelBuffer) : pixelBuffer[0]);\n      this.callback = null;\n    }\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    if (this.fullscreenMaterial.mode === DepthCopyMode.FULL) {\n      super.setSize(width, height);\n    }\n  }\n};\n\n// src/passes/EffectPass.js\n\nfunction prefixSubstrings(prefix, substrings, strings) {\n  for (const substring of substrings) {\n    const prefixed = \"$1\" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);\n    const regExp = new RegExp(\"([^\\\\.])(\\\\b\" + substring + \"\\\\b)\", \"g\");\n    for (const entry of strings.entries()) {\n      if (entry[1] !== null) {\n        strings.set(entry[0], entry[1].replace(regExp, prefixed));\n      }\n    }\n  }\n}\nfunction integrateEffect(prefix, effect, data) {\n  let fragmentShader = effect.getFragmentShader();\n  let vertexShader = effect.getVertexShader();\n  const mainImageExists = fragmentShader !== void 0 && /mainImage/.test(fragmentShader);\n  const mainUvExists = fragmentShader !== void 0 && /mainUv/.test(fragmentShader);\n  data.attributes |= effect.getAttributes();\n  if (fragmentShader === void 0) {\n    throw new Error(`Missing fragment shader (${effect.name})`);\n  } else if (mainUvExists && (data.attributes & EffectAttribute.CONVOLUTION) !== 0) {\n    throw new Error(`Effects that transform UVs are incompatible with convolution effects (${effect.name})`);\n  } else if (!mainImageExists && !mainUvExists) {\n    throw new Error(`Could not find mainImage or mainUv function (${effect.name})`);\n  } else {\n    const functionRegExp = /\\w+\\s+(\\w+)\\([\\w\\s,]*\\)\\s*{/g;\n    const shaderParts = data.shaderParts;\n    let fragmentHead = shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || \"\";\n    let fragmentMainUv = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || \"\";\n    let fragmentMainImage = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || \"\";\n    let vertexHead = shaderParts.get(EffectShaderSection.VERTEX_HEAD) || \"\";\n    let vertexMainSupport = shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || \"\";\n    const varyings = /* @__PURE__ */ new Set();\n    const names = /* @__PURE__ */ new Set();\n    if (mainUvExists) {\n      fragmentMainUv += `\t${prefix}MainUv(UV);\n`;\n      data.uvTransformation = true;\n    }\n    if (vertexShader !== null && /mainSupport/.test(vertexShader)) {\n      const needsUv = /mainSupport *\\([\\w\\s]*?uv\\s*?\\)/.test(vertexShader);\n      vertexMainSupport += `\t${prefix}MainSupport(`;\n      vertexMainSupport += needsUv ? \"vUv);\\n\" : \");\\n\";\n      for (const m2 of vertexShader.matchAll(/(?:varying\\s+\\w+\\s+([\\S\\s]*?);)/g)) {\n        for (const n of m2[1].split(/\\s*,\\s*/)) {\n          data.varyings.add(n);\n          varyings.add(n);\n          names.add(n);\n        }\n      }\n      for (const m2 of vertexShader.matchAll(functionRegExp)) {\n        names.add(m2[1]);\n      }\n    }\n    for (const m2 of fragmentShader.matchAll(functionRegExp)) {\n      names.add(m2[1]);\n    }\n    for (const d of effect.defines.keys()) {\n      names.add(d.replace(/\\([\\w\\s,]*\\)/g, \"\"));\n    }\n    for (const u of effect.uniforms.keys()) {\n      names.add(u);\n    }\n    names.delete(\"while\");\n    names.delete(\"for\");\n    names.delete(\"if\");\n    effect.uniforms.forEach((val, key) => data.uniforms.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));\n    effect.defines.forEach((val, key) => data.defines.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));\n    const shaders = /* @__PURE__ */ new Map([[\"fragment\", fragmentShader], [\"vertex\", vertexShader]]);\n    prefixSubstrings(prefix, names, data.defines);\n    prefixSubstrings(prefix, names, shaders);\n    fragmentShader = shaders.get(\"fragment\");\n    vertexShader = shaders.get(\"vertex\");\n    const blendMode = effect.blendMode;\n    data.blendModes.set(blendMode.blendFunction, blendMode);\n    if (mainImageExists) {\n      if (effect.inputColorSpace !== null && effect.inputColorSpace !== data.colorSpace) {\n        fragmentMainImage += effect.inputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace ? \"color0 = sRGBTransferOETF(color0);\\n\t\" : \"color0 = sRGBToLinear(color0);\\n\t\";\n      }\n      if (effect.outputColorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace) {\n        data.colorSpace = effect.outputColorSpace;\n      } else if (effect.inputColorSpace !== null) {\n        data.colorSpace = effect.inputColorSpace;\n      }\n      const depthParamRegExp = /MainImage *\\([\\w\\s,]*?depth[\\w\\s,]*?\\)/;\n      fragmentMainImage += `${prefix}MainImage(color0, UV, `;\n      if ((data.attributes & EffectAttribute.DEPTH) !== 0 && depthParamRegExp.test(fragmentShader)) {\n        fragmentMainImage += \"depth, \";\n        data.readDepth = true;\n      }\n      fragmentMainImage += \"color1);\\n\t\";\n      const blendOpacity = prefix + \"BlendOpacity\";\n      data.uniforms.set(blendOpacity, blendMode.opacity);\n      fragmentMainImage += `color0 = blend${blendMode.blendFunction}(color0, color1, ${blendOpacity});\n\n\t`;\n      fragmentHead += `uniform float ${blendOpacity};\n\n`;\n    }\n    fragmentHead += fragmentShader + \"\\n\";\n    if (vertexShader !== null) {\n      vertexHead += vertexShader + \"\\n\";\n    }\n    shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);\n    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);\n    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);\n    shaderParts.set(EffectShaderSection.VERTEX_HEAD, vertexHead);\n    shaderParts.set(EffectShaderSection.VERTEX_MAIN_SUPPORT, vertexMainSupport);\n    if (effect.extensions !== null) {\n      for (const extension of effect.extensions) {\n        data.extensions.add(extension);\n      }\n    }\n  }\n}\nvar EffectPass = class extends Pass {\n  /**\n   * Constructs a new effect pass.\n   *\n   * @param {Camera} camera - The main camera.\n   * @param {...Effect} effects - The effects that will be rendered by this pass.\n   */\n  constructor(camera, ...effects) {\n    super(\"EffectPass\");\n    this.fullscreenMaterial = new EffectMaterial(null, null, null, camera);\n    this.listener = (event) => this.handleEvent(event);\n    this.effects = [];\n    this.setEffects(effects);\n    this.skipRendering = false;\n    this.minTime = 1;\n    this.maxTime = Number.POSITIVE_INFINITY;\n    this.timeScale = 1;\n  }\n  set mainScene(value) {\n    for (const effect of this.effects) {\n      effect.mainScene = value;\n    }\n  }\n  set mainCamera(value) {\n    this.fullscreenMaterial.copyCameraSettings(value);\n    for (const effect of this.effects) {\n      effect.mainCamera = value;\n    }\n  }\n  /**\n   * Indicates whether this pass encodes its output when rendering to screen.\n   *\n   * @type {Boolean}\n   * @deprecated Use fullscreenMaterial.encodeOutput instead.\n   */\n  get encodeOutput() {\n    return this.fullscreenMaterial.encodeOutput;\n  }\n  set encodeOutput(value) {\n    this.fullscreenMaterial.encodeOutput = value;\n  }\n  /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   */\n  get dithering() {\n    return this.fullscreenMaterial.dithering;\n  }\n  set dithering(value) {\n    const material = this.fullscreenMaterial;\n    material.dithering = value;\n    material.needsUpdate = true;\n  }\n  /**\n   * Sets the effects.\n   *\n   * @param {Effect[]} effects - The effects.\n   * @protected\n   */\n  setEffects(effects) {\n    for (const effect of this.effects) {\n      effect.removeEventListener(\"change\", this.listener);\n    }\n    this.effects = effects.sort((a, b) => b.attributes - a.attributes);\n    for (const effect of this.effects) {\n      effect.addEventListener(\"change\", this.listener);\n    }\n  }\n  /**\n   * Updates the compound shader material.\n   *\n   * @protected\n   */\n  updateMaterial() {\n    const data = new EffectShaderData();\n    let id = 0;\n    for (const effect of this.effects) {\n      if (effect.blendMode.blendFunction === BlendFunction.DST) {\n        data.attributes |= effect.getAttributes() & EffectAttribute.DEPTH;\n      } else if ((data.attributes & effect.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) {\n        throw new Error(`Convolution effects cannot be merged (${effect.name})`);\n      } else {\n        integrateEffect(\"e\" + id++, effect, data);\n      }\n    }\n    let fragmentHead = data.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD);\n    let fragmentMainImage = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE);\n    let fragmentMainUv = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV);\n    const blendRegExp = /\\bblend\\b/g;\n    for (const blendMode of data.blendModes.values()) {\n      fragmentHead += blendMode.getShaderCode().replace(blendRegExp, `blend${blendMode.blendFunction}`) + \"\\n\";\n    }\n    if ((data.attributes & EffectAttribute.DEPTH) !== 0) {\n      if (data.readDepth) {\n        fragmentMainImage = \"float depth = readDepth(UV);\\n\\n\t\" + fragmentMainImage;\n      }\n      this.needsDepthTexture = this.getDepthTexture() === null;\n    } else {\n      this.needsDepthTexture = false;\n    }\n    if (data.colorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n      fragmentMainImage += \"color0 = sRGBToLinear(color0);\\n\t\";\n    }\n    if (data.uvTransformation) {\n      fragmentMainUv = \"vec2 transformedUv = vUv;\\n\" + fragmentMainUv;\n      data.defines.set(\"UV\", \"transformedUv\");\n    } else {\n      data.defines.set(\"UV\", \"vUv\");\n    }\n    data.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);\n    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);\n    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);\n    for (const [key, value] of data.shaderParts) {\n      if (value !== null) {\n        data.shaderParts.set(key, value.trim().replace(/^#/, \"\\n#\"));\n      }\n    }\n    this.skipRendering = id === 0;\n    this.needsSwap = !this.skipRendering;\n    this.fullscreenMaterial.setShaderData(data);\n  }\n  /**\n   * Rebuilds the shader material.\n   */\n  recompile() {\n    this.updateMaterial();\n  }\n  /**\n   * Returns the current depth texture.\n   *\n   * @return {Texture} The current depth texture, or null if there is none.\n   */\n  getDepthTexture() {\n    return this.fullscreenMaterial.depthBuffer;\n  }\n  /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */\n  setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n    this.fullscreenMaterial.depthBuffer = depthTexture;\n    this.fullscreenMaterial.depthPacking = depthPacking;\n    for (const effect of this.effects) {\n      effect.setDepthTexture(depthTexture, depthPacking);\n    }\n  }\n  /**\n   * Renders the effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    for (const effect of this.effects) {\n      effect.update(renderer, inputBuffer, deltaTime);\n    }\n    if (!this.skipRendering || this.renderToScreen) {\n      const material = this.fullscreenMaterial;\n      material.inputBuffer = inputBuffer.texture;\n      material.time += deltaTime * this.timeScale;\n      renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n      renderer.render(this.scene, this.camera);\n    }\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    this.fullscreenMaterial.setSize(width, height);\n    for (const effect of this.effects) {\n      effect.setSize(width, height);\n    }\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    this.renderer = renderer;\n    for (const effect of this.effects) {\n      effect.initialize(renderer, alpha, frameBufferType);\n    }\n    this.updateMaterial();\n    if (frameBufferType !== void 0 && frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n    }\n  }\n  /**\n   * Deletes disposable objects.\n   */\n  dispose() {\n    super.dispose();\n    for (const effect of this.effects) {\n      effect.removeEventListener(\"change\", this.listener);\n      effect.dispose();\n    }\n  }\n  /**\n   * Handles events.\n   *\n   * @param {Event} event - An event.\n   */\n  handleEvent(event) {\n    switch (event.type) {\n      case \"change\":\n        this.recompile();\n        break;\n    }\n  }\n};\n\n// src/passes/GaussianBlurPass.js\n\nvar GaussianBlurPass = class extends Pass {\n  /**\n   * Constructs a new Gaussian blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.kernelSize=35] - The kernel size. Should be an odd number in the range [3, 1020].\n   * @param {Number} [options.iterations=1] - The amount of times the blur should be applied.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */\n  constructor({\n    kernelSize = 35,\n    iterations = 1,\n    resolutionScale = 1,\n    resolutionX = Resolution.AUTO_SIZE,\n    resolutionY = Resolution.AUTO_SIZE\n  } = {}) {\n    super(\"GaussianBlurPass\");\n    this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, { depthBuffer: false });\n    this.renderTargetA.texture.name = \"Blur.Target.A\";\n    this.renderTargetB = this.renderTargetA.clone();\n    this.renderTargetB.texture.name = \"Blur.Target.B\";\n    this.blurMaterial = new GaussianBlurMaterial({ kernelSize });\n    this.copyMaterial = new CopyMaterial();\n    this.copyMaterial.inputBuffer = this.renderTargetB.texture;\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n    this.iterations = iterations;\n  }\n  /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const renderTargetA = this.renderTargetA;\n    const renderTargetB = this.renderTargetB;\n    const blurMaterial = this.blurMaterial;\n    this.fullscreenMaterial = blurMaterial;\n    let previousBuffer = inputBuffer;\n    for (let i = 0, l = Math.max(this.iterations, 1); i < l; ++i) {\n      blurMaterial.direction.set(1, 0);\n      blurMaterial.inputBuffer = previousBuffer.texture;\n      renderer.setRenderTarget(renderTargetA);\n      renderer.render(scene, camera);\n      blurMaterial.direction.set(0, 1);\n      blurMaterial.inputBuffer = renderTargetA.texture;\n      renderer.setRenderTarget(renderTargetB);\n      renderer.render(scene, camera);\n      if (i === 0 && l > 1) {\n        previousBuffer = renderTargetB;\n      }\n    }\n    this.fullscreenMaterial = this.copyMaterial;\n    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n    renderer.render(scene, camera);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    const w = resolution.width, h = resolution.height;\n    this.renderTargetA.setSize(w, h);\n    this.renderTargetB.setSize(w, h);\n    this.blurMaterial.setSize(width, height);\n  }\n  /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */\n  initialize(renderer, alpha, frameBufferType) {\n    if (frameBufferType !== void 0) {\n      this.renderTargetA.texture.type = frameBufferType;\n      this.renderTargetB.texture.type = frameBufferType;\n      if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n        this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n      } else if (renderer !== null && renderer.outputColorSpace === three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        this.renderTargetA.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        this.renderTargetB.texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n      }\n    }\n  }\n};\n\n// src/passes/LambdaPass.js\nvar LambdaPass = class extends Pass {\n  /**\n   * Constructs a new lambda pass.\n   *\n   * @param {Function} f - A function.\n   */\n  constructor(f) {\n    super(\"LambdaPass\", null, null);\n    this.needsSwap = false;\n    this.f = f;\n  }\n  /**\n   * Executes the function.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    this.f();\n  }\n};\n\n// src/passes/NormalPass.js\n\nvar NormalPass = class extends Pass {\n  /**\n   * Constructs a new normal pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use to render the scene.\n   * @param {Object} [options] - The options.\n   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */\n  constructor(scene, camera, {\n    renderTarget,\n    resolutionScale = 1,\n    width = Resolution.AUTO_SIZE,\n    height = Resolution.AUTO_SIZE,\n    resolutionX = width,\n    resolutionY = height\n  } = {}) {\n    super(\"NormalPass\");\n    this.needsSwap = false;\n    this.renderPass = new RenderPass(scene, camera, new three__WEBPACK_IMPORTED_MODULE_0__.MeshNormalMaterial());\n    const renderPass = this.renderPass;\n    renderPass.ignoreBackground = true;\n    renderPass.skipShadowMapUpdate = true;\n    const clearPass = renderPass.getClearPass();\n    clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(7829503);\n    clearPass.overrideClearAlpha = 1;\n    this.renderTarget = renderTarget;\n    if (this.renderTarget === void 0) {\n      this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n        minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n        magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter\n      });\n      this.renderTarget.texture.name = \"NormalPass.Target\";\n    }\n    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n    resolution.addEventListener(\"change\", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));\n  }\n  set mainScene(value) {\n    this.renderPass.mainScene = value;\n  }\n  set mainCamera(value) {\n    this.renderPass.mainCamera = value;\n  }\n  /**\n   * The normal texture.\n   *\n   * @type {Texture}\n   */\n  get texture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * The normal texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */\n  getTexture() {\n    return this.renderTarget.texture;\n  }\n  /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */\n  getResolution() {\n    return this.resolution;\n  }\n  /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.\n   */\n  getResolutionScale() {\n    return this.resolution.scale;\n  }\n  /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.\n   */\n  setResolutionScale(scale) {\n    this.resolution.scale = scale;\n  }\n  /**\n   * Renders the scene normals.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */\n  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n    const renderTarget = this.renderToScreen ? null : this.renderTarget;\n    this.renderPass.render(renderer, renderTarget, renderTarget);\n  }\n  /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */\n  setSize(width, height) {\n    const resolution = this.resolution;\n    resolution.setBaseSize(width, height);\n    this.renderTarget.setSize(resolution.width, resolution.height);\n  }\n};\n\n// src/textures/lut/TetrahedralUpscaler.js\nvar P = [\n  new Float32Array(3),\n  new Float32Array(3)\n];\nvar C = [\n  new Float32Array(3),\n  new Float32Array(3),\n  new Float32Array(3),\n  new Float32Array(3)\n];\nvar T = [\n  [\n    new Float32Array([0, 0, 0]),\n    new Float32Array([1, 0, 0]),\n    new Float32Array([1, 1, 0]),\n    new Float32Array([1, 1, 1])\n  ],\n  [\n    new Float32Array([0, 0, 0]),\n    new Float32Array([1, 0, 0]),\n    new Float32Array([1, 0, 1]),\n    new Float32Array([1, 1, 1])\n  ],\n  [\n    new Float32Array([0, 0, 0]),\n    new Float32Array([0, 0, 1]),\n    new Float32Array([1, 0, 1]),\n    new Float32Array([1, 1, 1])\n  ],\n  [\n    new Float32Array([0, 0, 0]),\n    new Float32Array([0, 1, 0]),\n    new Float32Array([1, 1, 0]),\n    new Float32Array([1, 1, 1])\n  ],\n  [\n    new Float32Array([0, 0, 0]),\n    new Float32Array([0, 1, 0]),\n    new Float32Array([0, 1, 1]),\n    new Float32Array([1, 1, 1])\n  ],\n  [\n    new Float32Array([0, 0, 0]),\n    new Float32Array([0, 0, 1]),\n    new Float32Array([0, 1, 1]),\n    new Float32Array([1, 1, 1])\n  ]\n];\nfunction calculateTetrahedronVolume(a, b, c2, d) {\n  const bcX = c2[0] - b[0];\n  const bcY = c2[1] - b[1];\n  const bcZ = c2[2] - b[2];\n  const baX = a[0] - b[0];\n  const baY = a[1] - b[1];\n  const baZ = a[2] - b[2];\n  const crossX = bcY * baZ - bcZ * baY;\n  const crossY = bcZ * baX - bcX * baZ;\n  const crossZ = bcX * baY - bcY * baX;\n  const length = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\n  const triangleArea = length * 0.5;\n  const normalX = crossX / length;\n  const normalY = crossY / length;\n  const normalZ = crossZ / length;\n  const constant = -(a[0] * normalX + a[1] * normalY + a[2] * normalZ);\n  const dot = d[0] * normalX + d[1] * normalY + d[2] * normalZ;\n  const height = Math.abs(dot + constant);\n  return height * triangleArea / 3;\n}\nfunction sample(data, size, x, y, z, color2) {\n  const i4 = (x + y * size + z * size * size) * 4;\n  color2[0] = data[i4 + 0];\n  color2[1] = data[i4 + 1];\n  color2[2] = data[i4 + 2];\n}\nfunction tetrahedralSample(data, size, u, v3, w, color2) {\n  const px = u * (size - 1);\n  const py = v3 * (size - 1);\n  const pz = w * (size - 1);\n  const minX = Math.floor(px);\n  const minY = Math.floor(py);\n  const minZ = Math.floor(pz);\n  const maxX = Math.ceil(px);\n  const maxY = Math.ceil(py);\n  const maxZ = Math.ceil(pz);\n  const su = px - minX;\n  const sv = py - minY;\n  const sw = pz - minZ;\n  if (minX === px && minY === py && minZ === pz) {\n    sample(data, size, px, py, pz, color2);\n  } else {\n    let vertices;\n    if (su >= sv && sv >= sw) {\n      vertices = T[0];\n    } else if (su >= sw && sw >= sv) {\n      vertices = T[1];\n    } else if (sw >= su && su >= sv) {\n      vertices = T[2];\n    } else if (sv >= su && su >= sw) {\n      vertices = T[3];\n    } else if (sv >= sw && sw >= su) {\n      vertices = T[4];\n    } else if (sw >= sv && sv >= su) {\n      vertices = T[5];\n    }\n    const [P0, P1, P2, P3] = vertices;\n    const coords = P[0];\n    coords[0] = su;\n    coords[1] = sv;\n    coords[2] = sw;\n    const tmp = P[1];\n    const diffX = maxX - minX;\n    const diffY = maxY - minY;\n    const diffZ = maxZ - minZ;\n    tmp[0] = diffX * P0[0] + minX;\n    tmp[1] = diffY * P0[1] + minY;\n    tmp[2] = diffZ * P0[2] + minZ;\n    sample(data, size, tmp[0], tmp[1], tmp[2], C[0]);\n    tmp[0] = diffX * P1[0] + minX;\n    tmp[1] = diffY * P1[1] + minY;\n    tmp[2] = diffZ * P1[2] + minZ;\n    sample(data, size, tmp[0], tmp[1], tmp[2], C[1]);\n    tmp[0] = diffX * P2[0] + minX;\n    tmp[1] = diffY * P2[1] + minY;\n    tmp[2] = diffZ * P2[2] + minZ;\n    sample(data, size, tmp[0], tmp[1], tmp[2], C[2]);\n    tmp[0] = diffX * P3[0] + minX;\n    tmp[1] = diffY * P3[1] + minY;\n    tmp[2] = diffZ * P3[2] + minZ;\n    sample(data, size, tmp[0], tmp[1], tmp[2], C[3]);\n    const V0 = calculateTetrahedronVolume(P1, P2, P3, coords) * 6;\n    const V1 = calculateTetrahedronVolume(P0, P2, P3, coords) * 6;\n    const V2 = calculateTetrahedronVolume(P0, P1, P3, coords) * 6;\n    const V3 = calculateTetrahedronVolume(P0, P1, P2, coords) * 6;\n    C[0][0] *= V0;\n    C[0][1] *= V0;\n    C[0][2] *= V0;\n    C[1][0] *= V1;\n    C[1][1] *= V1;\n    C[1][2] *= V1;\n    C[2][0] *= V2;\n    C[2][1] *= V2;\n    C[2][2] *= V2;\n    C[3][0] *= V3;\n    C[3][1] *= V3;\n    C[3][2] *= V3;\n    color2[0] = C[0][0] + C[1][0] + C[2][0] + C[3][0];\n    color2[1] = C[0][1] + C[1][1] + C[2][1] + C[3][1];\n    color2[2] = C[0][2] + C[1][2] + C[2][2] + C[3][2];\n  }\n}\nvar TetrahedralUpscaler = class {\n  /**\n   * Expands the given data to the target size.\n   *\n   * @param {TypedArray} data - The input RGBA data. Assumed to be cubic.\n   * @param {Number} size - The target size.\n   * @return {TypedArray} The new data.\n   */\n  static expand(data, size) {\n    const originalSize = Math.cbrt(data.length / 4);\n    const rgb = new Float32Array(3);\n    const array = new data.constructor(size ** 3 * 4);\n    const maxValue = data instanceof Uint8Array ? 255 : 1;\n    const sizeSq = size ** 2;\n    const s = 1 / (size - 1);\n    for (let z = 0; z < size; ++z) {\n      for (let y = 0; y < size; ++y) {\n        for (let x = 0; x < size; ++x) {\n          const u = x * s;\n          const v3 = y * s;\n          const w = z * s;\n          const i4 = Math.round(x + y * size + z * sizeSq) * 4;\n          tetrahedralSample(data, originalSize, u, v3, w, rgb);\n          array[i4 + 0] = rgb[0];\n          array[i4 + 1] = rgb[1];\n          array[i4 + 2] = rgb[2];\n          array[i4 + 3] = maxValue;\n        }\n      }\n    }\n    return array;\n  }\n};\n\n// src/textures/smaa/SMAAAreaImageData.js\nvar area = [\n  new Float32Array(2),\n  new Float32Array(2)\n];\nvar ORTHOGONAL_SIZE = 16;\nvar DIAGONAL_SIZE = 20;\nvar DIAGONAL_SAMPLES = 30;\nvar SMOOTH_MAX_DISTANCE = 32;\nvar orthogonalSubsamplingOffsets = new Float32Array([\n  0,\n  -0.25,\n  0.25,\n  -0.125,\n  0.125,\n  -0.375,\n  0.375\n]);\nvar diagonalSubsamplingOffsets = [\n  new Float32Array([0, 0]),\n  new Float32Array([0.25, -0.25]),\n  new Float32Array([-0.25, 0.25]),\n  new Float32Array([0.125, -0.125]),\n  new Float32Array([-0.125, 0.125])\n];\nvar orthogonalEdges = [\n  new Uint8Array([0, 0]),\n  new Uint8Array([3, 0]),\n  new Uint8Array([0, 3]),\n  new Uint8Array([3, 3]),\n  new Uint8Array([1, 0]),\n  new Uint8Array([4, 0]),\n  new Uint8Array([1, 3]),\n  new Uint8Array([4, 3]),\n  new Uint8Array([0, 1]),\n  new Uint8Array([3, 1]),\n  new Uint8Array([0, 4]),\n  new Uint8Array([3, 4]),\n  new Uint8Array([1, 1]),\n  new Uint8Array([4, 1]),\n  new Uint8Array([1, 4]),\n  new Uint8Array([4, 4])\n];\nvar diagonalEdges = [\n  new Uint8Array([0, 0]),\n  new Uint8Array([1, 0]),\n  new Uint8Array([0, 2]),\n  new Uint8Array([1, 2]),\n  new Uint8Array([2, 0]),\n  new Uint8Array([3, 0]),\n  new Uint8Array([2, 2]),\n  new Uint8Array([3, 2]),\n  new Uint8Array([0, 1]),\n  new Uint8Array([1, 1]),\n  new Uint8Array([0, 3]),\n  new Uint8Array([1, 3]),\n  new Uint8Array([2, 1]),\n  new Uint8Array([3, 1]),\n  new Uint8Array([2, 3]),\n  new Uint8Array([3, 3])\n];\nfunction lerp(a, b, p) {\n  return a + (b - a) * p;\n}\nfunction saturate(a) {\n  return Math.min(Math.max(a, 0), 1);\n}\nfunction smoothArea(d) {\n  const a1 = area[0];\n  const a2 = area[1];\n  const b1X = Math.sqrt(a1[0] * 2) * 0.5;\n  const b1Y = Math.sqrt(a1[1] * 2) * 0.5;\n  const b2X = Math.sqrt(a2[0] * 2) * 0.5;\n  const b2Y = Math.sqrt(a2[1] * 2) * 0.5;\n  const p = saturate(d / SMOOTH_MAX_DISTANCE);\n  a1[0] = lerp(b1X, a1[0], p);\n  a1[1] = lerp(b1Y, a1[1], p);\n  a2[0] = lerp(b2X, a2[0], p);\n  a2[1] = lerp(b2Y, a2[1], p);\n}\nfunction getOrthArea(p1X, p1Y, p2X, p2Y, x, result) {\n  const dX = p2X - p1X;\n  const dY = p2Y - p1Y;\n  const x1 = x;\n  const x2 = x + 1;\n  const y1 = p1Y + dY * (x1 - p1X) / dX;\n  const y2 = p1Y + dY * (x2 - p1X) / dX;\n  if (x1 >= p1X && x1 < p2X || x2 > p1X && x2 <= p2X) {\n    if (Math.sign(y1) === Math.sign(y2) || Math.abs(y1) < 1e-4 || Math.abs(y2) < 1e-4) {\n      const a = (y1 + y2) / 2;\n      if (a < 0) {\n        result[0] = Math.abs(a);\n        result[1] = 0;\n      } else {\n        result[0] = 0;\n        result[1] = Math.abs(a);\n      }\n    } else {\n      const t = -p1Y * dX / dY + p1X;\n      const tInt = Math.trunc(t);\n      const a1 = t > p1X ? y1 * (t - tInt) / 2 : 0;\n      const a2 = t < p2X ? y2 * (1 - (t - tInt)) / 2 : 0;\n      const a = Math.abs(a1) > Math.abs(a2) ? a1 : -a2;\n      if (a < 0) {\n        result[0] = Math.abs(a1);\n        result[1] = Math.abs(a2);\n      } else {\n        result[0] = Math.abs(a2);\n        result[1] = Math.abs(a1);\n      }\n    }\n  } else {\n    result[0] = 0;\n    result[1] = 0;\n  }\n  return result;\n}\nfunction getOrthAreaForPattern(pattern, left, right, offset, result) {\n  const a1 = area[0];\n  const a2 = area[1];\n  const o1 = 0.5 + offset;\n  const o2 = 0.5 + offset - 1;\n  const d = left + right + 1;\n  switch (pattern) {\n    case 0: {\n      result[0] = 0;\n      result[1] = 0;\n      break;\n    }\n    case 1: {\n      if (left <= right) {\n        getOrthArea(0, o2, d / 2, 0, left, result);\n      } else {\n        result[0] = 0;\n        result[1] = 0;\n      }\n      break;\n    }\n    case 2: {\n      if (left >= right) {\n        getOrthArea(d / 2, 0, d, o2, left, result);\n      } else {\n        result[0] = 0;\n        result[1] = 0;\n      }\n      break;\n    }\n    case 3: {\n      getOrthArea(0, o2, d / 2, 0, left, a1);\n      getOrthArea(d / 2, 0, d, o2, left, a2);\n      smoothArea(d, area);\n      result[0] = a1[0] + a2[0];\n      result[1] = a1[1] + a2[1];\n      break;\n    }\n    case 4: {\n      if (left <= right) {\n        getOrthArea(0, o1, d / 2, 0, left, result);\n      } else {\n        result[0] = 0;\n        result[1] = 0;\n      }\n      break;\n    }\n    case 5: {\n      result[0] = 0;\n      result[1] = 0;\n      break;\n    }\n    case 6: {\n      if (Math.abs(offset) > 0) {\n        getOrthArea(0, o1, d, o2, left, a1);\n        getOrthArea(0, o1, d / 2, 0, left, a2);\n        getOrthArea(d / 2, 0, d, o2, left, result);\n        a2[0] = a2[0] + result[0];\n        a2[1] = a2[1] + result[1];\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n      } else {\n        getOrthArea(0, o1, d, o2, left, result);\n      }\n      break;\n    }\n    case 7: {\n      getOrthArea(0, o1, d, o2, left, result);\n      break;\n    }\n    case 8: {\n      if (left >= right) {\n        getOrthArea(d / 2, 0, d, o1, left, result);\n      } else {\n        result[0] = 0;\n        result[1] = 0;\n      }\n      break;\n    }\n    case 9: {\n      if (Math.abs(offset) > 0) {\n        getOrthArea(0, o2, d, o1, left, a1);\n        getOrthArea(0, o2, d / 2, 0, left, a2);\n        getOrthArea(d / 2, 0, d, o1, left, result);\n        a2[0] = a2[0] + result[0];\n        a2[1] = a2[1] + result[1];\n        result[0] = (a1[0] + a2[0]) / 2;\n        result[1] = (a1[1] + a2[1]) / 2;\n      } else {\n        getOrthArea(0, o2, d, o1, left, result);\n      }\n      break;\n    }\n    case 10: {\n      result[0] = 0;\n      result[1] = 0;\n      break;\n    }\n    case 11: {\n      getOrthArea(0, o2, d, o1, left, result);\n      break;\n    }\n    case 12: {\n      getOrthArea(0, o1, d / 2, 0, left, a1);\n      getOrthArea(d / 2, 0, d, o1, left, a2);\n      smoothArea(d, area);\n      result[0] = a1[0] + a2[0];\n      result[1] = a1[1] + a2[1];\n      break;\n    }\n    case 13: {\n      getOrthArea(0, o2, d, o1, left, result);\n      break;\n    }\n    case 14: {\n      getOrthArea(0, o1, d, o2, left, result);\n      break;\n    }\n    case 15: {\n      result[0] = 0;\n      result[1] = 0;\n      break;\n    }\n  }\n  return result;\n}\nfunction isInsideArea(a1X, a1Y, a2X, a2Y, x, y) {\n  let result = a1X === a2X && a1Y === a2Y;\n  if (!result) {\n    const xm = (a1X + a2X) / 2;\n    const ym = (a1Y + a2Y) / 2;\n    const a = a2Y - a1Y;\n    const b = a1X - a2X;\n    const c2 = a * (x - xm) + b * (y - ym);\n    result = c2 > 0;\n  }\n  return result;\n}\nfunction getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, pX, pY) {\n  let n = 0;\n  for (let y = 0; y < DIAGONAL_SAMPLES; ++y) {\n    for (let x = 0; x < DIAGONAL_SAMPLES; ++x) {\n      const offsetX = x / (DIAGONAL_SAMPLES - 1);\n      const offsetY = y / (DIAGONAL_SAMPLES - 1);\n      if (isInsideArea(a1X, a1Y, a2X, a2Y, pX + offsetX, pY + offsetY)) {\n        ++n;\n      }\n    }\n  }\n  return n / (DIAGONAL_SAMPLES * DIAGONAL_SAMPLES);\n}\nfunction getDiagArea(pattern, a1X, a1Y, a2X, a2Y, left, offset, result) {\n  const e = diagonalEdges[pattern];\n  const e1 = e[0];\n  const e2 = e[1];\n  if (e1 > 0) {\n    a1X += offset[0];\n    a1Y += offset[1];\n  }\n  if (e2 > 0) {\n    a2X += offset[0];\n    a2Y += offset[1];\n  }\n  result[0] = 1 - getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 0 + left);\n  result[1] = getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 1 + left);\n  return result;\n}\nfunction getDiagAreaForPattern(pattern, left, right, offset, result) {\n  const a1 = area[0];\n  const a2 = area[1];\n  const d = left + right + 1;\n  switch (pattern) {\n    case 0: {\n      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 1: {\n      getDiagArea(pattern, 1, 0, 0 + d, 0 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 2: {\n      getDiagArea(pattern, 0, 0, 1 + d, 0 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 3: {\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, result);\n      break;\n    }\n    case 4: {\n      getDiagArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 5: {\n      getDiagArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 6: {\n      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, result);\n      break;\n    }\n    case 7: {\n      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 8: {\n      getDiagArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 9: {\n      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);\n      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);\n      break;\n    }\n    case 10: {\n      getDiagArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 11: {\n      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 12: {\n      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, result);\n      break;\n    }\n    case 13: {\n      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 14: {\n      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n    case 15: {\n      getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n      getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n      result[0] = (a1[0] + a2[0]) / 2;\n      result[1] = (a1[1] + a2[1]) / 2;\n      break;\n    }\n  }\n  return result;\n}\nfunction generatePatterns(patterns, offset, orthogonal) {\n  const result = new Float32Array(2);\n  for (let i = 0, l = patterns.length; i < l; ++i) {\n    const pattern = patterns[i];\n    const data = pattern.data;\n    const size = pattern.width;\n    for (let y = 0; y < size; ++y) {\n      for (let x = 0; x < size; ++x) {\n        if (orthogonal) {\n          getOrthAreaForPattern(i, x, y, offset, result);\n        } else {\n          getDiagAreaForPattern(i, x, y, offset, result);\n        }\n        const c2 = (y * size + x) * 2;\n        data[c2] = result[0] * 255;\n        data[c2 + 1] = result[1] * 255;\n      }\n    }\n  }\n}\nfunction assemble(baseX, baseY, patterns, edges2, size, orthogonal, target) {\n  const dstData = target.data;\n  const dstWidth = target.width;\n  for (let i = 0, l = patterns.length; i < l; ++i) {\n    const edge = edges2[i];\n    const pattern = patterns[i];\n    const srcData = pattern.data;\n    const srcWidth = pattern.width;\n    for (let y = 0; y < size; ++y) {\n      for (let x = 0; x < size; ++x) {\n        const pX = edge[0] * size + baseX + x;\n        const pY = edge[1] * size + baseY + y;\n        const c2 = (pY * dstWidth + pX) * 4;\n        const d = orthogonal ? (y * y * srcWidth + x * x) * 2 : (y * srcWidth + x) * 2;\n        dstData[c2] = srcData[d];\n        dstData[c2 + 1] = srcData[d + 1];\n        dstData[c2 + 2] = 0;\n        dstData[c2 + 3] = 255;\n      }\n    }\n  }\n}\nvar SMAAAreaImageData = class {\n  /**\n   * Creates a new area image.\n   *\n   * @return {RawImageData} The generated image data.\n   */\n  static generate() {\n    const width = 2 * 5 * ORTHOGONAL_SIZE;\n    const height = orthogonalSubsamplingOffsets.length * 5 * ORTHOGONAL_SIZE;\n    const data = new Uint8ClampedArray(width * height * 4);\n    const result = new RawImageData(width, height, data);\n    const orthPatternSize = Math.pow(ORTHOGONAL_SIZE - 1, 2) + 1;\n    const diagPatternSize = DIAGONAL_SIZE;\n    const orthogonalPatterns = [];\n    const diagonalPatterns = [];\n    for (let i = 3, l = data.length; i < l; i += 4) {\n      data[i] = 255;\n    }\n    for (let i = 0; i < 16; ++i) {\n      orthogonalPatterns.push(new RawImageData(\n        orthPatternSize,\n        orthPatternSize,\n        new Uint8ClampedArray(orthPatternSize * orthPatternSize * 2),\n        2\n      ));\n      diagonalPatterns.push(new RawImageData(\n        diagPatternSize,\n        diagPatternSize,\n        new Uint8ClampedArray(diagPatternSize * diagPatternSize * 2),\n        2\n      ));\n    }\n    for (let i = 0, l = orthogonalSubsamplingOffsets.length; i < l; ++i) {\n      generatePatterns(orthogonalPatterns, orthogonalSubsamplingOffsets[i], true);\n      assemble(\n        0,\n        5 * ORTHOGONAL_SIZE * i,\n        orthogonalPatterns,\n        orthogonalEdges,\n        ORTHOGONAL_SIZE,\n        true,\n        result\n      );\n    }\n    for (let i = 0, l = diagonalSubsamplingOffsets.length; i < l; ++i) {\n      generatePatterns(diagonalPatterns, diagonalSubsamplingOffsets[i], false);\n      assemble(\n        5 * ORTHOGONAL_SIZE,\n        4 * DIAGONAL_SIZE * i,\n        diagonalPatterns,\n        diagonalEdges,\n        DIAGONAL_SIZE,\n        false,\n        result\n      );\n    }\n    return result;\n  }\n};\n\n// src/textures/smaa/SMAAImageGenerator.js\n\n\n// temp/smaa/worker.txt\nvar worker_default2 = '\"use strict\";(()=>{function q(t,a,s){let e=document.createElement(\"canvas\"),n=e.getContext(\"2d\");if(e.width=t,e.height=a,s instanceof Image)n.drawImage(s,0,0);else{let r=n.createImageData(t,a);r.data.set(s),n.putImageData(r,0,0)}return e}var F=class t{constructor(a=0,s=0,e=null){this.width=a,this.height=s,this.data=e}toCanvas(){return typeof document==\"undefined\"?null:q(this.width,this.height,this.data)}static from(a){let{width:s,height:e}=a,n;if(a instanceof Image){let r=q(s,e,a);r!==null&&(n=r.getContext(\"2d\").getImageData(0,0,s,e).data)}else n=a.data;return new t(s,e,n)}};var M=[new Float32Array(2),new Float32Array(2)],D=16,W=20,I=30,j=32,v=new Float32Array([0,-.25,.25,-.125,.125,-.375,.375]),N=[new Float32Array([0,0]),new Float32Array([.25,-.25]),new Float32Array([-.25,.25]),new Float32Array([.125,-.125]),new Float32Array([-.125,.125])],z=[new Uint8Array([0,0]),new Uint8Array([3,0]),new Uint8Array([0,3]),new Uint8Array([3,3]),new Uint8Array([1,0]),new Uint8Array([4,0]),new Uint8Array([1,3]),new Uint8Array([4,3]),new Uint8Array([0,1]),new Uint8Array([3,1]),new Uint8Array([0,4]),new Uint8Array([3,4]),new Uint8Array([1,1]),new Uint8Array([4,1]),new Uint8Array([1,4]),new Uint8Array([4,4])],p=[new Uint8Array([0,0]),new Uint8Array([1,0]),new Uint8Array([0,2]),new Uint8Array([1,2]),new Uint8Array([2,0]),new Uint8Array([3,0]),new Uint8Array([2,2]),new Uint8Array([3,2]),new Uint8Array([0,1]),new Uint8Array([1,1]),new Uint8Array([0,3]),new Uint8Array([1,3]),new Uint8Array([2,1]),new Uint8Array([3,1]),new Uint8Array([2,3]),new Uint8Array([3,3])];function C(t,a,s){return t+(a-t)*s}function B(t){return Math.min(Math.max(t,0),1)}function _(t){let a=M[0],s=M[1],e=Math.sqrt(a[0]*2)*.5,n=Math.sqrt(a[1]*2)*.5,r=Math.sqrt(s[0]*2)*.5,o=Math.sqrt(s[1]*2)*.5,c=B(t/j);a[0]=C(e,a[0],c),a[1]=C(n,a[1],c),s[0]=C(r,s[0],c),s[1]=C(o,s[1],c)}function d(t,a,s,e,n,r){let o=s-t,c=e-a,h=n,i=n+1,w=a+c*(h-t)/o,b=a+c*(i-t)/o;if(h>=t&&h<s||i>t&&i<=s)if(Math.sign(w)===Math.sign(b)||Math.abs(w)<1e-4||Math.abs(b)<1e-4){let g=(w+b)/2;g<0?(r[0]=Math.abs(g),r[1]=0):(r[0]=0,r[1]=Math.abs(g))}else{let g=-a*o/c+t,k=Math.trunc(g),m=g>t?w*(g-k)/2:0,U=g<s?b*(1-(g-k))/2:0;(Math.abs(m)>Math.abs(U)?m:-U)<0?(r[0]=Math.abs(m),r[1]=Math.abs(U)):(r[0]=Math.abs(U),r[1]=Math.abs(m))}else r[0]=0,r[1]=0;return r}function J(t,a,s,e,n){let r=M[0],o=M[1],c=.5+e,h=.5+e-1,i=a+s+1;switch(t){case 0:{n[0]=0,n[1]=0;break}case 1:{a<=s?d(0,h,i/2,0,a,n):(n[0]=0,n[1]=0);break}case 2:{a>=s?d(i/2,0,i,h,a,n):(n[0]=0,n[1]=0);break}case 3:{d(0,h,i/2,0,a,r),d(i/2,0,i,h,a,o),_(i,M),n[0]=r[0]+o[0],n[1]=r[1]+o[1];break}case 4:{a<=s?d(0,c,i/2,0,a,n):(n[0]=0,n[1]=0);break}case 5:{n[0]=0,n[1]=0;break}case 6:{Math.abs(e)>0?(d(0,c,i,h,a,r),d(0,c,i/2,0,a,o),d(i/2,0,i,h,a,n),o[0]=o[0]+n[0],o[1]=o[1]+n[1],n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2):d(0,c,i,h,a,n);break}case 7:{d(0,c,i,h,a,n);break}case 8:{a>=s?d(i/2,0,i,c,a,n):(n[0]=0,n[1]=0);break}case 9:{Math.abs(e)>0?(d(0,h,i,c,a,r),d(0,h,i/2,0,a,o),d(i/2,0,i,c,a,n),o[0]=o[0]+n[0],o[1]=o[1]+n[1],n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2):d(0,h,i,c,a,n);break}case 10:{n[0]=0,n[1]=0;break}case 11:{d(0,h,i,c,a,n);break}case 12:{d(0,c,i/2,0,a,r),d(i/2,0,i,c,a,o),_(i,M),n[0]=r[0]+o[0],n[1]=r[1]+o[1];break}case 13:{d(0,h,i,c,a,n);break}case 14:{d(0,c,i,h,a,n);break}case 15:{n[0]=0,n[1]=0;break}}return n}function K(t,a,s,e,n,r){let o=t===s&&a===e;if(!o){let c=(t+s)/2,h=(a+e)/2,i=e-a,w=t-s;o=i*(n-c)+w*(r-h)>0}return o}function G(t,a,s,e,n,r){let o=0;for(let c=0;c<I;++c)for(let h=0;h<I;++h){let i=h/(I-1),w=c/(I-1);K(t,a,s,e,n+i,r+w)&&++o}return o/(I*I)}function A(t,a,s,e,n,r,o,c){let h=p[t],i=h[0],w=h[1];return i>0&&(a+=o[0],s+=o[1]),w>0&&(e+=o[0],n+=o[1]),c[0]=1-G(a,s,e,n,1+r,0+r),c[1]=G(a,s,e,n,1+r,1+r),c}function Q(t,a,s,e,n){let r=M[0],o=M[1],c=a+s+1;switch(t){case 0:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 1:{A(t,1,0,0+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 2:{A(t,0,0,1+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 3:{A(t,1,0,1+c,0+c,a,e,n);break}case 4:{A(t,1,1,0+c,0+c,a,e,r),A(t,1,1,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 5:{A(t,1,1,0+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 6:{A(t,1,1,1+c,0+c,a,e,n);break}case 7:{A(t,1,1,1+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 8:{A(t,0,0,1+c,1+c,a,e,r),A(t,1,0,1+c,1+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 9:{A(t,1,0,1+c,1+c,a,e,n),A(t,1,0,1+c,1+c,a,e,n);break}case 10:{A(t,0,0,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 11:{A(t,1,0,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 12:{A(t,1,1,1+c,1+c,a,e,n);break}case 13:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,1+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 14:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,1,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 15:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}}return n}function R(t,a,s){let e=new Float32Array(2);for(let n=0,r=t.length;n<r;++n){let o=t[n],c=o.data,h=o.width;for(let i=0;i<h;++i)for(let w=0;w<h;++w){s?J(n,w,i,a,e):Q(n,w,i,a,e);let b=(i*h+w)*2;c[b]=e[0]*255,c[b+1]=e[1]*255}}}function T(t,a,s,e,n,r,o){let c=o.data,h=o.width;for(let i=0,w=s.length;i<w;++i){let b=e[i],g=s[i],k=g.data,m=g.width;for(let U=0;U<n;++U)for(let x=0;x<n;++x){let Z=b[0]*n+t+x,O=((b[1]*n+a+U)*h+Z)*4,L=r?(U*U*m+x*x)*2:(U*m+x)*2;c[O]=k[L],c[O+1]=k[L+1],c[O+2]=0,c[O+3]=255}}}var S=class{static generate(){let a=10*D,s=v.length*5*D,e=new Uint8ClampedArray(a*s*4),n=new F(a,s,e),r=Math.pow(D-1,2)+1,o=W,c=[],h=[];for(let i=3,w=e.length;i<w;i+=4)e[i]=255;for(let i=0;i<16;++i)c.push(new F(r,r,new Uint8ClampedArray(r*r*2),2)),h.push(new F(o,o,new Uint8ClampedArray(o*o*2),2));for(let i=0,w=v.length;i<w;++i)R(c,v[i],!0),T(0,5*D*i,c,z,D,!0,n);for(let i=0,w=N.length;i<w;++i)R(h,N[i],!1),T(5*D,4*W*i,h,p,W,!1,n);return n}};var P=new Map([[y(0,0,0,0),new Float32Array([0,0,0,0])],[y(0,0,0,1),new Float32Array([0,0,0,1])],[y(0,0,1,0),new Float32Array([0,0,1,0])],[y(0,0,1,1),new Float32Array([0,0,1,1])],[y(0,1,0,0),new Float32Array([0,1,0,0])],[y(0,1,0,1),new Float32Array([0,1,0,1])],[y(0,1,1,0),new Float32Array([0,1,1,0])],[y(0,1,1,1),new Float32Array([0,1,1,1])],[y(1,0,0,0),new Float32Array([1,0,0,0])],[y(1,0,0,1),new Float32Array([1,0,0,1])],[y(1,0,1,0),new Float32Array([1,0,1,0])],[y(1,0,1,1),new Float32Array([1,0,1,1])],[y(1,1,0,0),new Float32Array([1,1,0,0])],[y(1,1,0,1),new Float32Array([1,1,0,1])],[y(1,1,1,0),new Float32Array([1,1,1,0])],[y(1,1,1,1),new Float32Array([1,1,1,1])]]);function H(t,a,s){return t+(a-t)*s}function y(t,a,s,e){let n=H(t,a,.75),r=H(s,e,1-.25);return H(n,r,1-.125)}function V(t,a){let s=0;return a[3]===1&&(s+=1),s===1&&a[2]===1&&t[1]!==1&&t[3]!==1&&(s+=1),s}function $(t,a){let s=0;return a[3]===1&&t[1]!==1&&t[3]!==1&&(s+=1),s===1&&a[2]===1&&t[0]!==1&&t[2]!==1&&(s+=1),s}var E=class{static generate(){let o=new Uint8ClampedArray(2178),c=new Uint8ClampedArray(64*16*4);for(let h=0;h<33;++h)for(let i=0;i<66;++i){let w=.03125*i,b=.03125*h;if(P.has(w)&&P.has(b)){let g=P.get(w),k=P.get(b),m=h*66+i;o[m]=127*V(g,k),o[m+33]=127*$(g,k)}}for(let h=0,i=17;i<33;++i)for(let w=0;w<64;++w,h+=4)c[h]=o[i*66+w],c[h+3]=255;return new F(64,16,c)}};self.addEventListener(\"message\",t=>{let a=S.generate(),s=E.generate();postMessage({areaImageData:a,searchImageData:s},[a.data.buffer,s.data.buffer]),close()});})();\\n';\n\n// src/textures/smaa/SMAAImageGenerator.js\nfunction generate(useCache = true) {\n  const workerURL = URL.createObjectURL(new Blob([worker_default2], {\n    type: \"text/javascript\"\n  }));\n  const worker = new Worker(workerURL);\n  URL.revokeObjectURL(workerURL);\n  return new Promise((resolve, reject) => {\n    worker.addEventListener(\"error\", (event) => reject(event.error));\n    worker.addEventListener(\"message\", (event) => {\n      const searchImageData = RawImageData.from(event.data.searchImageData);\n      const areaImageData = RawImageData.from(event.data.areaImageData);\n      const urls = [\n        searchImageData.toCanvas().toDataURL(\"image/png\", 1),\n        areaImageData.toCanvas().toDataURL(\"image/png\", 1)\n      ];\n      if (useCache) {\n        localStorage.setItem(\"smaa-search\", urls[0]);\n        localStorage.setItem(\"smaa-area\", urls[1]);\n      }\n      resolve(urls);\n    });\n    worker.postMessage(null);\n  });\n}\nvar SMAAImageGenerator = class {\n  /**\n   * Constructs a new SMAA image generator.\n   */\n  constructor() {\n    this.disableCache = false;\n  }\n  /**\n   * Enables or disables caching via localStorage.\n   *\n   * @param {Boolean} value - Whether the cache should be enabled.\n   */\n  setCacheEnabled(value) {\n    this.disableCache = !value;\n  }\n  /**\n   * Generates the SMAA data images.\n   *\n   * @example\n   * SMAAImageGenerator.generate().then(([search, area]) => {\n   *   const smaaEffect = new SMAAEffect(search, area);\n   * });\n   * @return {Promise<Image[]>} A promise that returns the search image and area image as a pair.\n   */\n  generate() {\n    const useCache = !this.disableCache && window.localStorage !== void 0;\n    const cachedURLs = useCache ? [\n      localStorage.getItem(\"smaa-search\"),\n      localStorage.getItem(\"smaa-area\")\n    ] : [null, null];\n    const promise = cachedURLs[0] !== null && cachedURLs[1] !== null ? Promise.resolve(cachedURLs) : generate(useCache);\n    return promise.then((urls) => {\n      return new Promise((resolve, reject) => {\n        const searchImage = new Image();\n        const areaImage = new Image();\n        const manager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n        manager.onLoad = () => resolve([searchImage, areaImage]);\n        manager.onError = reject;\n        searchImage.addEventListener(\"error\", (e) => manager.itemError(\"smaa-search\"));\n        areaImage.addEventListener(\"error\", (e) => manager.itemError(\"smaa-area\"));\n        searchImage.addEventListener(\"load\", () => manager.itemEnd(\"smaa-search\"));\n        areaImage.addEventListener(\"load\", () => manager.itemEnd(\"smaa-area\"));\n        manager.itemStart(\"smaa-search\");\n        manager.itemStart(\"smaa-area\");\n        searchImage.src = urls[0];\n        areaImage.src = urls[1];\n      });\n    });\n  }\n};\n\n// src/textures/smaa/SMAASearchImageData.js\nvar edges = /* @__PURE__ */ new Map([\n  [bilinear(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])],\n  [bilinear(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])],\n  [bilinear(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])],\n  [bilinear(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])],\n  [bilinear(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])],\n  [bilinear(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])],\n  [bilinear(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])],\n  [bilinear(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])],\n  [bilinear(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])],\n  [bilinear(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])],\n  [bilinear(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])],\n  [bilinear(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])],\n  [bilinear(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])],\n  [bilinear(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])],\n  [bilinear(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])],\n  [bilinear(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]\n]);\nfunction lerp2(a, b, p) {\n  return a + (b - a) * p;\n}\nfunction bilinear(e0, e1, e2, e3) {\n  const a = lerp2(e0, e1, 1 - 0.25);\n  const b = lerp2(e2, e3, 1 - 0.25);\n  return lerp2(a, b, 1 - 0.125);\n}\nfunction deltaLeft(left, top) {\n  let d = 0;\n  if (top[3] === 1) {\n    d += 1;\n  }\n  if (d === 1 && top[2] === 1 && left[1] !== 1 && left[3] !== 1) {\n    d += 1;\n  }\n  return d;\n}\nfunction deltaRight(left, top) {\n  let d = 0;\n  if (top[3] === 1 && left[1] !== 1 && left[3] !== 1) {\n    d += 1;\n  }\n  if (d === 1 && top[2] === 1 && left[0] !== 1 && left[2] !== 1) {\n    d += 1;\n  }\n  return d;\n}\nvar SMAASearchImageData = class {\n  /**\n   * Creates a new search image.\n   *\n   * @return {RawImageData} The generated image data.\n   */\n  static generate() {\n    const width = 66;\n    const height = 33;\n    const halfWidth = width / 2;\n    const croppedWidth = 64;\n    const croppedHeight = 16;\n    const data = new Uint8ClampedArray(width * height);\n    const croppedData = new Uint8ClampedArray(croppedWidth * croppedHeight * 4);\n    for (let y = 0; y < height; ++y) {\n      for (let x = 0; x < width; ++x) {\n        const s = 0.03125 * x;\n        const t = 0.03125 * y;\n        if (edges.has(s) && edges.has(t)) {\n          const e1 = edges.get(s);\n          const e2 = edges.get(t);\n          const i = y * width + x;\n          data[i] = 127 * deltaLeft(e1, e2);\n          data[i + halfWidth] = 127 * deltaRight(e1, e2);\n        }\n      }\n    }\n    for (let i = 0, y = height - croppedHeight; y < height; ++y) {\n      for (let x = 0; x < croppedWidth; ++x, i += 4) {\n        croppedData[i] = data[y * width + x];\n        croppedData[i + 3] = 255;\n      }\n    }\n    return new RawImageData(croppedWidth, croppedHeight, croppedData);\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9idWlsZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFXZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBV2U7QUFDZjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQWM7QUFDckMsd0NBQXdDLGtEQUFlO0FBQ3ZELGtDQUFrQyxrREFBZTtBQUNqRDtBQUNBLENB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBDQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDBDQUFPO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3QkFBd0I7QUFDM0U7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsd0JBQXdCO0FBQzNFO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHdCQUF3QjtBQUMzRTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHdCQUF3QjtBQUMzRTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdCQUF3QjtBQUNwRTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNB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QTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFB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QSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlEQUFlO0FBQ2pEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtSTs7QUFFbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUNBQXFDLHVCQUF1Qix3QkFBd0IsaUJBQWlCLHdCQUF3Qix1QkFBdUIscUVBQXFFLFFBQVEsb0JBQW9CLFFBQVEscUJBQXFCLHFFQUFxRSxpQ0FBaUMsa0NBQWtDLHlDQUF5Qyw4QkFBOEIsaUJBQWlCLHlDQUF5QyxpQ0FBaUMsaUJBQWlCLHNFQUFzRSxtQ0FBbUMsMkJBQTJCLFlBQVksdUJBQXVCLEtBQUssK0RBQStELE9BQU8sb0NBQW9DLHFDQUFxQywwQkFBMEIsaUJBQWlCLHNFQUFzRSxtQ0FBbUMsMEJBQTBCLDJCQUEyQixZQUFZLHVCQUF1QixLQUFLLCtEQUErRCxPQUFPLG9DQUFvQyxxQ0FBcUMsOEJBQThCLDBCQUEwQixpQkFBaUIsd0VBQXdFLCtFQUErRSw0REFBNEQsZ0JBQWdCLHVDQUF1QywyQ0FBMkMsaUdBQWlHLHVCQUF1QixPQUFPLFNBQVMsWUFBWSw4Q0FBOEMsdUJBQXVCLEtBQUssZ0JBQWdCLDhDQUE4QyxnQkFBZ0IsMkVBQTJFLE9BQU8sZ0VBQWdFLCtEQUErRCx3Q0FBd0MsNEJBQTRCLDBDQUEwQywrQ0FBK0MsK0NBQStDLGdFQUFnRSx5Q0FBeUMsdUJBQXVCLEtBQUssZ0JBQWdCLGdCQUFnQixpRUFBaUUsT0FBTyw4REFBOEQsOERBQThELCtEQUErRCw0QkFBNEIsMENBQTBDLGtEQUFrRCxnQkFBZ0IsMERBQTBELHlDQUF5QywwQ0FBMEMsc0JBQXNCLHFCQUFxQixpQ0FBaUMsZ0NBQWdDLGdEQUFnRCx1REFBdUQscUJBQXFCLFlBQVksdUJBQXVCLEtBQUssNENBQTRDLE9BQU8scUNBQXFDLDRDQUE0QyxxREFBcUQsc0NBQXNDLHFEQUFxRCxxQkFBcUIsWUFBWSx1QkFBdUIsS0FBSyw0Q0FBNEMsT0FBTyxxQ0FBcUMsOENBQThDLHFEQUFxRCxzQ0FBc0Msa0RBQWtELHFCQUFxQixZQUFZLHVCQUF1QixLQUFLLDRDQUE0QyxPQUFPLHFDQUFxQywrQ0FBK0Msd0RBQXdELHNDQUFzQyxvREFBb0QscUJBQXFCLFlBQVksdUJBQXVCLEtBQUssNENBQTRDLE9BQU8scUNBQXFDLDhDQUE4Qyx3REFBd0Qsc0NBQXNDLHdGQUF3RixxRUFBcUUsNERBQTRELGlEQUFpRCwyQ0FBMkM7QUFDLzBKO0FBQ0EsK0JBQStCLG1EQUFtRCxrQ0FBa0Msc0JBQXNCLGdGQUFnRixnRkFBZ0YsaUZBQWlGLGlGQUFpRjtBQUM1YztBQUNBLENBQUM7QUFDRDtBQUNBLCtCQUErQixtREFBbUQsa0NBQWtDLHNCQUFzQixnRkFBZ0YsZ0ZBQWdGLGlGQUFpRixpRkFBaUY7QUFDNWM7QUFDQSxDQUFDLFlBQVksdUJBQXVCLGdDQUFnQyxxQ0FBcUM7QUFDekc7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxPQUFPLFlBQVksaURBQWlELHNCQUFzQixhQUFhLDRDQUE0QyxrREFBa0QsYUFBYSx1Q0FBdUMsd0JBQXdCLGtFQUFrRSxnREFBZ0QsZUFBZTtBQUNsWjtBQUNBLENBQUMsS0FBSztBQUNOO0FBQ0EsQ0FBQyxZQUFZLE9BQU8sWUFBWSwrQ0FBK0Msc0JBQXNCLGFBQWEsNENBQTRDLGlEQUFpRCxhQUFhLHNDQUFzQyx3QkFBd0Isa0VBQWtFLGdEQUFnRCxlQUFlLHVEQUF1RCxzQkFBc0I7O0FBRXhlO0FBQ0Esb0RBQW9ELHdCQUF3QixpQkFBaUIsd0JBQXdCLHVCQUF1QixZQUFZLHdCQUF3Qix5QkFBeUIsa0VBQWtFLGtFQUFrRSwyR0FBMkcsdUNBQXVDOztBQUUvZDtBQUNBLHdDQUF3QyxpREFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBLDhCQUE4QiwwQ0FBUyxxQkFBcUIsMENBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHlCQUF5QiwwQ0FBUztBQUNsQywyQkFBMkIsMENBQVM7QUFDcEMseUJBQXlCLDBDQUFTO0FBQ2xDLHdCQUF3QiwwQ0FBUztBQUNqQyx1QkFBdUIsMENBQVM7QUFDaEMsT0FBTztBQUNQLGdCQUFnQiw2Q0FBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBLGdEQUFnRCxzQkFBc0Isc0JBQXNCLHFFQUFxRSxRQUFRLG9CQUFvQixRQUFRLHFCQUFxQixxRUFBcUUsaUNBQWlDLGtDQUFrQywrRUFBK0UsT0FBTyxvQ0FBb0Msb0NBQW9DLGdDQUFnQyxzQkFBc0IsMkJBQTJCLGlDQUFpQywwQ0FBMEMseUJBQXlCLHFEQUFxRCxvQ0FBb0MsOENBQThDLHFFQUFxRSwrREFBK0QsaUVBQWlFLG1CQUFtQjs7QUFFcGhDO0FBQ0EsMkNBQTJDLHNCQUFzQixtQ0FBbUMsb0NBQW9DLHFDQUFxQzs7QUFFN0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMENBQVM7QUFDbkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvREFBbUIsU0FBUyxvQkFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3Q0FBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUFjO0FBQzdDO0FBQ0EsZ0NBQWdDLDBDQUFRO0FBQ3hDO0FBQ0EsZ0NBQWdDLGdEQUFjO0FBQzlDLGdDQUFnQyxnREFBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQ0FBUTtBQUN0QztBQUNBLDhCQUE4QiwrQ0FBYTtBQUMzQyw4QkFBOEIsK0NBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVEQUF1RDtBQUNqRTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBb0Q7QUFDOUQ7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0EsK0NBQStDLG9EQUFrQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNnTjs7QUFFaE47QUFDMk87O0FBRTNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFDQUFxQyw4QkFBOEIsdUJBQXVCLDJCQUEyQix3QkFBd0IsNkJBQTZCLG1CQUFtQixtQkFBbUIsNEJBQTRCLDZCQUE2QixpQkFBaUIsa0JBQWtCO0FBQ2hWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDZGQUE2RiwrREFBK0QsZ0VBQWdFLG9CQUFvQixrREFBa0QsaUdBQWlHLDZEQUE2RCw0REFBNEQsZ0NBQWdDLDJDQUEyQywwQkFBMEIsNkJBQTZCLG9CQUFvQixXQUFXLFlBQVksY0FBYyxLQUFLLDZDQUE2QyxrQ0FBa0MsMENBQTBDLCtDQUErQywyREFBMkQsVUFBVSxvQ0FBb0M7QUFDOThCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0NBQWdDLDRFQUE0RSxpREFBaUQsV0FBVyxrQkFBa0IsdUJBQXVCLHdDQUF3QyxrREFBa0QsUUFBUSw2Q0FBNkM7QUFDN1k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbURBQW1ELG1EQUFtRCxpRUFBaUUsa0VBQWtFO0FBQzFRO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1COztBQUVwQjtBQUNBLDZDQUE2QyxpQkFBaUIsa0JBQWtCLFlBQVksd0JBQXdCLG9CQUFvQix1Q0FBdUM7O0FBRS9LO0FBQ0EsaUNBQWlDLGlEQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUJBQXlCLDBDQUFTO0FBQ2xDLDBCQUEwQiwwQ0FBUztBQUNuQywrQkFBK0IsMENBQVM7QUFDeEMsMEJBQTBCLDBDQUFTO0FBQ25DLHFDQUFxQywwQ0FBUyxLQUFLLDBDQUFRO0FBQzNELDhCQUE4QiwwQ0FBUyxLQUFLLDBDQUFRO0FBQ3BELHVCQUF1QiwwQ0FBUyxLQUFLLDBDQUFTO0FBQzlDLDJCQUEyQiwwQ0FBUyxLQUFLLDBDQUFTO0FBQ2xELDRCQUE0QiwwQ0FBUyxLQUFLLDBDQUFTO0FBQ25ELDZCQUE2QiwwQ0FBUyxLQUFLLDBDQUFTO0FBQ3BELHdCQUF3QiwwQ0FBUyxLQUFLLDBDQUFTO0FBQy9DLDRCQUE0QiwwQ0FBUztBQUNyQyx1QkFBdUIsMENBQVM7QUFDaEMsa0JBQWtCLDBDQUFTO0FBQzNCLGtCQUFrQiwwQ0FBUztBQUMzQixPQUFPO0FBQ1AsZ0JBQWdCLDZDQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsMENBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0Esd0NBQXdDLG9EQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvREFBa0I7QUFDOUM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLHdDQUFNO0FBQ2hE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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QyxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDTixjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaURBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RCxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaUlFIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3NpbmcvYnVpbGQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBwb3N0cHJvY2Vzc2luZyB2Ni4zNy42IGJ1aWxkIEZyaSBKdWwgMDQgMjAyNVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9wb3N0cHJvY2Vzc2luZ1xuICogQ29weXJpZ2h0IDIwMTUtMjAyNSBSYW91bCB2YW4gUsO8c2NoZW5cbiAqIEBsaWNlbnNlIFpsaWJcbiAqL1xuXG4vLyBwYWNrYWdlLmpzb25cbnZhciB2ZXJzaW9uID0gXCI2LjM3LjZcIjtcblxuLy8gc3JjL2NvcmUvRGlzcG9zYWJsZS5qc1xudmFyIERpc3Bvc2FibGUgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBGcmVlcyBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9FZmZlY3RDb21wb3Nlci5qc1xuaW1wb3J0IHtcbiAgRGVwdGhTdGVuY2lsRm9ybWF0LFxuICBEZXB0aFRleHR1cmUsXG4gIExpbmVhckZpbHRlciBhcyBMaW5lYXJGaWx0ZXIyLFxuICBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTIsXG4gIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTIsXG4gIFVuc2lnbmVkSW50VHlwZSxcbiAgVW5zaWduZWRJbnQyNDhUeXBlLFxuICBWZWN0b3IyLFxuICBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDNcbn0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9jb3JlL1RpbWVyLmpzXG52YXIgTUlMTElTRUNPTkRTX1RPX1NFQ09ORFMgPSAxIC8gMWUzO1xudmFyIFNFQ09ORFNfVE9fTUlMTElTRUNPTkRTID0gMWUzO1xudmFyIFRpbWVyID0gY2xhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyB0aW1lci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5wcmV2aW91c1RpbWUgPSAwO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuX2RlbHRhID0gMDtcbiAgICB0aGlzLl9lbGFwc2VkID0gMDtcbiAgICB0aGlzLl9maXhlZERlbHRhID0gMWUzIC8gNjA7XG4gICAgdGhpcy50aW1lc2NhbGUgPSAxO1xuICAgIHRoaXMudXNlRml4ZWREZWx0YSA9IGZhbHNlO1xuICAgIHRoaXMuX2F1dG9SZXNldCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGF1dG8gcmVzZXQgYmFzZWQgb24gcGFnZSB2aXNpYmlsaXR5LlxuICAgKlxuICAgKiBJZiBlbmFibGVkLCB0aGUgdGltZXIgd2lsbCBiZSByZXNldCB3aGVuIHRoZSBwYWdlIGJlY29tZXMgdmlzaWJsZS4gVGhpcyBlZmZlY3RpdmVseSBwYXVzZXMgdGhlIHRpbWVyIHdoZW4gdGhlIHBhZ2VcbiAgICogaXMgaGlkZGVuLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBBUEkgaXMgbm90IHN1cHBvcnRlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BhZ2VfVmlzaWJpbGl0eV9BUElcbiAgICovXG4gIGdldCBhdXRvUmVzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9SZXNldDtcbiAgfVxuICBzZXQgYXV0b1Jlc2V0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5oaWRkZW4gIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hdXRvUmVzZXQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGRlbHRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWx0YSAqIE1JTExJU0VDT05EU19UT19TRUNPTkRTO1xuICB9XG4gIGdldCBmaXhlZERlbHRhKCkge1xuICAgIHJldHVybiB0aGlzLl9maXhlZERlbHRhICogTUlMTElTRUNPTkRTX1RPX1NFQ09ORFM7XG4gIH1cbiAgc2V0IGZpeGVkRGVsdGEodmFsdWUpIHtcbiAgICB0aGlzLl9maXhlZERlbHRhID0gdmFsdWUgKiBTRUNPTkRTX1RPX01JTExJU0VDT05EUztcbiAgfVxuICBnZXQgZWxhcHNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxhcHNlZCAqIE1JTExJU0VDT05EU19UT19TRUNPTkRTO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgdGltZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RpbWVzdGFtcF0gLSBUaGUgY3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZSh0aW1lc3RhbXApIHtcbiAgICBpZiAodGhpcy51c2VGaXhlZERlbHRhKSB7XG4gICAgICB0aGlzLl9kZWx0YSA9IHRoaXMuZml4ZWREZWx0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmV2aW91c1RpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5jdXJyZW50VGltZSA9ICh0aW1lc3RhbXAgIT09IHZvaWQgMCA/IHRpbWVzdGFtcCA6IHBlcmZvcm1hbmNlLm5vdygpKSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgICAgdGhpcy5fZGVsdGEgPSB0aGlzLmN1cnJlbnRUaW1lIC0gdGhpcy5wcmV2aW91c1RpbWU7XG4gICAgfVxuICAgIHRoaXMuX2RlbHRhICo9IHRoaXMudGltZXNjYWxlO1xuICAgIHRoaXMuX2VsYXBzZWQgKz0gdGhpcy5fZGVsdGE7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGlzIHRpbWVyLlxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fZGVsdGEgPSAwO1xuICAgIHRoaXMuX2VsYXBzZWQgPSAwO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xuICB9XG4gIGdldERlbHRhKCkge1xuICAgIHJldHVybiB0aGlzLmRlbHRhO1xuICB9XG4gIGdldEVsYXBzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxhcHNlZDtcbiAgfVxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgaWYgKCFkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgIHRoaXMuY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuYXV0b1Jlc2V0ID0gZmFsc2U7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvUGFzcy5qc1xuaW1wb3J0IHtcbiAgQmFzaWNEZXB0aFBhY2tpbmcsXG4gIEJ1ZmZlckF0dHJpYnV0ZSxcbiAgQnVmZmVyR2VvbWV0cnksXG4gIENhbWVyYSxcbiAgTWF0ZXJpYWwsXG4gIE1lc2gsXG4gIFNjZW5lLFxuICBUZXh0dXJlLFxuICBXZWJHTFJlbmRlclRhcmdldFxufSBmcm9tIFwidGhyZWVcIjtcbnZhciBmdWxsc2NyZWVuR2VvbWV0cnkgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgY29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsIDAsIDMsIC0xLCAwLCAtMSwgMywgMF0pO1xuICBjb25zdCB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAyLCAwLCAwLCAyXSk7XG4gIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsIG5ldyBCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcbiAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwidXZcIiwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcbiAgcmV0dXJuIGdlb21ldHJ5O1xufSkoKTtcbnZhciBQYXNzID0gY2xhc3MgX1Bhc3Mge1xuICAvKipcbiAgICogQSBzaGFyZWQgZnVsbHNjcmVlbiB0cmlhbmdsZS5cbiAgICpcbiAgICogVGhlIHNjcmVlbiBzaXplIGlzIDJ4MiB1bml0cyAoTkRDKS4gQSB0cmlhbmdsZSBuZWVkcyB0byBiZSA0eDQgdW5pdHMgdG8gZmlsbCB0aGUgc2NyZWVuLlxuICAgKiBAc2VlIGh0dHBzOi8vbWljaGFsZHJvYm90LmNvbS8yMDE0LzA0LzAxL2djbi1leGVjdXRpb24tcGF0dGVybnMtaW4tZnVsbC1zY3JlZW4tcGFzc2VzL1xuICAgKiBAdHlwZSB7QnVmZmVyR2VvbWV0cnl9XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGdldCBmdWxsc2NyZWVuR2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIGZ1bGxzY3JlZW5HZW9tZXRyeTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gVGhlIG5hbWUgb2YgdGhpcyBwYXNzLiBEb2VzIG5vdCBoYXZlIHRvIGJlIHVuaXF1ZS5cbiAgICogQHBhcmFtIHtTY2VuZX0gW3NjZW5lXSAtIFRoZSBzY2VuZSB0byByZW5kZXIuIFRoZSBkZWZhdWx0IHNjZW5lIGNvbnRhaW5zIGEgc2luZ2xlIG1lc2ggdGhhdCBmaWxscyB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gW2NhbWVyYV0gLSBBIGNhbWVyYS4gRnVsbHNjcmVlbiBlZmZlY3QgcGFzc2VzIGRvbid0IHJlcXVpcmUgYSBjYW1lcmEuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuYW1lID0gXCJQYXNzXCIsIHNjZW5lID0gbmV3IFNjZW5lKCksIGNhbWVyYSA9IG5ldyBDYW1lcmEoKSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuc2NyZWVuID0gbnVsbDtcbiAgICB0aGlzLnJ0dCA9IHRydWU7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xuICAgIHRoaXMubmVlZHNEZXB0aFRleHR1cmUgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXIgdG8gc2NyZWVuIGZsYWcuXG4gICAqXG4gICAqIElmIHRoaXMgZmxhZyBpcyBjaGFuZ2VkLCB0aGUgZnVsbHNjcmVlbiBtYXRlcmlhbCB3aWxsIGJlIHVwZGF0ZWQgYXMgd2VsbC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgcmVuZGVyVG9TY3JlZW4oKSB7XG4gICAgcmV0dXJuICF0aGlzLnJ0dDtcbiAgfVxuICBzZXQgcmVuZGVyVG9TY3JlZW4odmFsdWUpIHtcbiAgICBpZiAodGhpcy5ydHQgPT09IHZhbHVlKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICAgICAgaWYgKG1hdGVyaWFsICE9PSBudWxsKSB7XG4gICAgICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnR0ID0gIXZhbHVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWFpbiBzY2VuZS5cbiAgICpcbiAgICogQHR5cGUge1NjZW5lfVxuICAgKi9cbiAgc2V0IG1haW5TY2VuZSh2YWx1ZSkge1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYWluIGNhbWVyYS5cbiAgICpcbiAgICogQHR5cGUge0NhbWVyYX1cbiAgICovXG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlbmRlcmVyXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqL1xuICBzZXRSZW5kZXJlcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBwYXNzIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlbmFibGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhpcyBwYXNzIGlzIGVuYWJsZWQuXG4gICAqL1xuICBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlbmFibGVkIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRoZSBwYXNzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZnVsbHNjcmVlbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge01hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IGZ1bGxzY3JlZW5NYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JlZW4gIT09IG51bGwgPyB0aGlzLnNjcmVlbi5tYXRlcmlhbCA6IG51bGw7XG4gIH1cbiAgc2V0IGZ1bGxzY3JlZW5NYXRlcmlhbCh2YWx1ZSkge1xuICAgIGxldCBzY3JlZW4gPSB0aGlzLnNjcmVlbjtcbiAgICBpZiAoc2NyZWVuICE9PSBudWxsKSB7XG4gICAgICBzY3JlZW4ubWF0ZXJpYWwgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NyZWVuID0gbmV3IE1lc2goX1Bhc3MuZnVsbHNjcmVlbkdlb21ldHJ5LCB2YWx1ZSk7XG4gICAgICBzY3JlZW4uZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuc2NlbmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBTY2VuZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zY2VuZS5hZGQoc2NyZWVuKTtcbiAgICAgIHRoaXMuc2NyZWVuID0gc2NyZWVuO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBmdWxsc2NyZWVuIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZnVsbHNjcmVlbk1hdGVyaWFsIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge01hdGVyaWFsfSBUaGUgY3VycmVudCBmdWxsc2NyZWVuIG1hdGVyaWFsLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAqL1xuICBnZXRGdWxsc2NyZWVuTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmdWxsc2NyZWVuIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZnVsbHNjcmVlbk1hdGVyaWFsIGluc3RlYWQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtNYXRlcmlhbH0gdmFsdWUgLSBBIGZ1bGxzY3JlZW4gbWF0ZXJpYWwuXG4gICAqL1xuICBzZXRGdWxsc2NyZWVuTWF0ZXJpYWwodmFsdWUpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSBjdXJyZW50IGRlcHRoIHRleHR1cmUsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZS5cbiAgICovXG4gIGdldERlcHRoVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUge0BsaW5rIEVmZmVjdENvbXBvc2VyfS5cbiAgICogWW91IG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3VyIHBhc3MgcmVsaWVzIG9uIHRoZSBkZXB0aCBpbmZvcm1hdGlvbiBvZiBhIHByZWNlZGluZyB7QGxpbmsgUmVuZGVyUGFzc30uXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWd5fSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcpIHtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIHBhc3MuXG4gICAqXG4gICAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgbWV0aG9kIHRoYXQgbXVzdCBiZSBvdmVycmlkZGVuLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHRocm93cyB7RXJyb3J9IEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgbWV0aG9kIGlzIG5vdCBvdmVycmlkZGVuLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZW5kZXIgbWV0aG9kIG5vdCBpbXBsZW1lbnRlZCFcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUuXG4gICAqXG4gICAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgeW91IHdhbnQgdG8gYmUgaW5mb3JtZWQgYWJvdXQgdGhlIHNpemUgb2YgdGhlIGJhY2tidWZmZXIvY2FudmFzLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYmVmb3JlIHtAbGluayBpbml0aWFsaXplfSBhbmQgZXZlcnkgdGltZSB0aGUgc2l6ZSBvZiB0aGUge0BsaW5rIEVmZmVjdENvbXBvc2VyfSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGlzIHBhc3MgaXMgYWRkZWQgdG8gYW4ge0BsaW5rIEVmZmVjdENvbXBvc2VyfS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgYSBzaGFsbG93IHNlYXJjaCBmb3IgZGlzcG9zYWJsZSBwcm9wZXJ0aWVzIGFuZCBkZWxldGVzIHRoZW0uXG4gICAqXG4gICAqIFRoZSB7QGxpbmsgRWZmZWN0Q29tcG9zZXJ9IGNhbGxzIHRoaXMgbWV0aG9kIHdoZW4gaXQgaXMgYmVpbmcgZGVzdHJveWVkLiBZb3UgY2FuIHVzZSBpdCBpbmRlcGVuZGVudGx5IHRvIGZyZWVcbiAgICogbWVtb3J5IHdoZW4geW91J3JlIGNlcnRhaW4gdGhhdCB5b3UgZG9uJ3QgbmVlZCB0aGlzIHBhc3MgYW55bW9yZS5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcykpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpc1trZXldO1xuICAgICAgY29uc3QgaXNEaXNwb3NhYmxlID0gcHJvcGVydHkgaW5zdGFuY2VvZiBXZWJHTFJlbmRlclRhcmdldCB8fCBwcm9wZXJ0eSBpbnN0YW5jZW9mIE1hdGVyaWFsIHx8IHByb3BlcnR5IGluc3RhbmNlb2YgVGV4dHVyZSB8fCBwcm9wZXJ0eSBpbnN0YW5jZW9mIF9QYXNzO1xuICAgICAgaWYgKGlzRGlzcG9zYWJsZSkge1xuICAgICAgICB0aGlzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvQ2xlYXJNYXNrUGFzcy5qc1xudmFyIENsZWFyTWFza1Bhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjbGVhciBtYXNrIHBhc3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkNsZWFyTWFza1Bhc3NcIiwgbnVsbCwgbnVsbCk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIGdsb2JhbCBzdGVuY2lsIHRlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IHN0ZW5jaWwgPSByZW5kZXJlci5zdGF0ZS5idWZmZXJzLnN0ZW5jaWw7XG4gICAgc3RlbmNpbC5zZXRMb2NrZWQoZmFsc2UpO1xuICAgIHN0ZW5jaWwuc2V0VGVzdChmYWxzZSk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvQ29weVBhc3MuanNcbmltcG9ydCB7IExpbmVhckZpbHRlciwgU1JHQkNvbG9yU3BhY2UsIFVuc2lnbmVkQnl0ZVR5cGUsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0NvcHlNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZywgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0gfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvcHkuZnJhZ1xudmFyIGNvcHlfZGVmYXVsdCA9IGAjaW5jbHVkZSA8Y29tbW9uPlxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxuI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZW5kaWZcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTt2YXJ5aW5nIHZlYzIgdlV2O3ZvaWQgbWFpbigpe3ZlYzQgdGV4ZWw9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdik7Z2xfRnJhZ0NvbG9yPW9wYWNpdHkqdGV4ZWw7XG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cbiNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XG59YDtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbW1vbi52ZXJ0XG52YXIgY29tbW9uX2RlZmF1bHQgPSBgdmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0NvcHlNYXRlcmlhbC5qc1xudmFyIENvcHlNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjb3B5IG1hdGVyaWFsLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJDb3B5TWF0ZXJpYWxcIixcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybShudWxsKSxcbiAgICAgICAgb3BhY2l0eTogbmV3IFVuaWZvcm0oMSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZyxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGNvcHlfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29tbW9uX2RlZmF1bHRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3BhY2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG9wYWNpdHkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgb3BhY2l0eS5cbiAgICovXG4gIGdldE9wYWNpdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5vcGFjaXR5LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcGFjaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3BhY2l0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgb3BhY2l0eS5cbiAgICovXG4gIHNldE9wYWNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9Db3B5UGFzcy5qc1xudmFyIENvcHlQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgc2F2ZSBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBbcmVuZGVyVGFyZ2V0XSAtIEEgcmVuZGVyIHRhcmdldC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbYXV0b1Jlc2l6ZT10cnVlXSAtIFdoZXRoZXIgdGhlIHJlbmRlciB0YXJnZXQgc2l6ZSBzaG91bGQgYmUgdXBkYXRlZCBhdXRvbWF0aWNhbGx5LlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyVGFyZ2V0LCBhdXRvUmVzaXplID0gdHJ1ZSkge1xuICAgIHN1cGVyKFwiQ29weVBhc3NcIik7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBuZXcgQ29weU1hdGVyaWFsKCk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcbiAgICBpZiAocmVuZGVyVGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MigxLCAxLCB7XG4gICAgICAgIG1pbkZpbHRlcjogTGluZWFyRmlsdGVyLFxuICAgICAgICBtYWdGaWx0ZXI6IExpbmVhckZpbHRlcixcbiAgICAgICAgc3RlbmNpbEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgIGRlcHRoQnVmZmVyOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkNvcHlQYXNzLlRhcmdldFwiO1xuICAgIH1cbiAgICB0aGlzLmF1dG9SZXNpemUgPSBhdXRvUmVzaXplO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGF1dG8gcmVzaXppbmcgb2YgdGhlIHJlbmRlciB0YXJnZXQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBhdXRvUmVzaXplIGluc3RlYWQuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHJlc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRvUmVzaXplO1xuICB9XG4gIHNldCByZXNpemUodmFsdWUpIHtcbiAgICB0aGlzLmF1dG9SZXNpemUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG91dHB1dCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvdXRwdXQgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGF1dG8gcmVzaXppbmcgb2YgdGhlIHJlbmRlciB0YXJnZXQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBhdXRvUmVzaXplIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRoZSByZW5kZXIgdGFyZ2V0IHNpemUgc2hvdWxkIGJlIHVwZGF0ZWQgYXV0b21hdGljYWxseS5cbiAgICovXG4gIHNldEF1dG9SZXNpemVFbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5hdXRvUmVzaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmlucHV0QnVmZmVyID0gaW5wdXRCdWZmZXIudGV4dHVyZTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB0aGlzLnJlbmRlclRhcmdldCk7XG4gICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5hdXRvUmVzaXplKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBBIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlKSB7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlZmluZXMuRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0ggPSBcIjFcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVuZGVyZXIgIT09IG51bGwgJiYgcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0NsZWFyUGFzcy5qc1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBjb2xvciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgQ29sb3IoKTtcbnZhciBDbGVhclBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjbGVhciBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb2xvcj10cnVlXSAtIERldGVybWluZXMgd2hldGhlciB0aGUgY29sb3IgYnVmZmVyIHNob3VsZCBiZSBjbGVhcmVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZXB0aD10cnVlXSAtIERldGVybWluZXMgd2hldGhlciB0aGUgZGVwdGggYnVmZmVyIHNob3VsZCBiZSBjbGVhcmVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsPWZhbHNlXSAtIERldGVybWluZXMgd2hldGhlciB0aGUgc3RlbmNpbCBidWZmZXIgc2hvdWxkIGJlIGNsZWFyZWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2xvcjIgPSB0cnVlLCBkZXB0aCA9IHRydWUsIHN0ZW5jaWwgPSBmYWxzZSkge1xuICAgIHN1cGVyKFwiQ2xlYXJQYXNzXCIsIG51bGwsIG51bGwpO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yMjtcbiAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgdGhpcy5zdGVuY2lsID0gc3RlbmNpbDtcbiAgICB0aGlzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG51bGw7XG4gICAgdGhpcy5vdmVycmlkZUNsZWFyQWxwaGEgPSAtMTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY2xlYXIgZmxhZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sb3IgLSBXaGV0aGVyIHRoZSBjb2xvciBidWZmZXIgc2hvdWxkIGJlIGNsZWFyZWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVwdGggLSBXaGV0aGVyIHRoZSBkZXB0aCBidWZmZXIgc2hvdWxkIGJlIGNsZWFyZWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RlbmNpbCAtIFdoZXRoZXIgdGhlIHN0ZW5jaWwgYnVmZmVyIHNob3VsZCBiZSBjbGVhcmVkLlxuICAgKi9cbiAgc2V0Q2xlYXJGbGFncyhjb2xvcjIsIGRlcHRoLCBzdGVuY2lsKSB7XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yMjtcbiAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgdGhpcy5zdGVuY2lsID0gc3RlbmNpbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3ZlcnJpZGUgY2xlYXIgY29sb3IuIERlZmF1bHQgaXMgbnVsbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlQ2xlYXJDb2xvciBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtDb2xvcn0gVGhlIGNsZWFyIGNvbG9yLlxuICAgKi9cbiAgZ2V0T3ZlcnJpZGVDbGVhckNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJyaWRlQ2xlYXJDb2xvcjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgb3ZlcnJpZGUgY2xlYXIgY29sb3IuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZUNsZWFyQ29sb3IgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDb2xvcn0gdmFsdWUgLSBUaGUgY2xlYXIgY29sb3IuXG4gICAqL1xuICBzZXRPdmVycmlkZUNsZWFyQ29sb3IodmFsdWUpIHtcbiAgICB0aGlzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvdmVycmlkZSBjbGVhciBhbHBoYS4gRGVmYXVsdCBpcyAtMS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlQ2xlYXJBbHBoYSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjbGVhciBhbHBoYS5cbiAgICovXG4gIGdldE92ZXJyaWRlQ2xlYXJBbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVycmlkZUNsZWFyQWxwaGE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG92ZXJyaWRlIGNsZWFyIGFscGhhLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVDbGVhckFscGhhIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBjbGVhciBhbHBoYS5cbiAgICovXG4gIHNldE92ZXJyaWRlQ2xlYXJBbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMub3ZlcnJpZGVDbGVhckFscGhhID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgaW5wdXQgYnVmZmVyIG9yIHRoZSBzY3JlZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IG92ZXJyaWRlQ2xlYXJDb2xvciA9IHRoaXMub3ZlcnJpZGVDbGVhckNvbG9yO1xuICAgIGNvbnN0IG92ZXJyaWRlQ2xlYXJBbHBoYSA9IHRoaXMub3ZlcnJpZGVDbGVhckFscGhhO1xuICAgIGNvbnN0IGNsZWFyQWxwaGEgPSByZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG4gICAgY29uc3QgaGFzT3ZlcnJpZGVDbGVhckNvbG9yID0gb3ZlcnJpZGVDbGVhckNvbG9yICE9PSBudWxsO1xuICAgIGNvbnN0IGhhc092ZXJyaWRlQ2xlYXJBbHBoYSA9IG92ZXJyaWRlQ2xlYXJBbHBoYSA+PSAwO1xuICAgIGlmIChoYXNPdmVycmlkZUNsZWFyQ29sb3IpIHtcbiAgICAgIHJlbmRlcmVyLmdldENsZWFyQ29sb3IoY29sb3IpO1xuICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcihvdmVycmlkZUNsZWFyQ29sb3IsIGhhc092ZXJyaWRlQ2xlYXJBbHBoYSA/IG92ZXJyaWRlQ2xlYXJBbHBoYSA6IGNsZWFyQWxwaGEpO1xuICAgIH0gZWxzZSBpZiAoaGFzT3ZlcnJpZGVDbGVhckFscGhhKSB7XG4gICAgICByZW5kZXJlci5zZXRDbGVhckFscGhhKG92ZXJyaWRlQ2xlYXJBbHBoYSk7XG4gICAgfVxuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IGlucHV0QnVmZmVyKTtcbiAgICByZW5kZXJlci5jbGVhcih0aGlzLmNvbG9yLCB0aGlzLmRlcHRoLCB0aGlzLnN0ZW5jaWwpO1xuICAgIGlmIChoYXNPdmVycmlkZUNsZWFyQ29sb3IpIHtcbiAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoY29sb3IsIGNsZWFyQWxwaGEpO1xuICAgIH0gZWxzZSBpZiAoaGFzT3ZlcnJpZGVDbGVhckFscGhhKSB7XG4gICAgICByZW5kZXJlci5zZXRDbGVhckFscGhhKGNsZWFyQWxwaGEpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9NYXNrUGFzcy5qc1xudmFyIE1hc2tQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbWFzayBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBzY2VuZSB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhIHRvIHVzZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNjZW5lLCBjYW1lcmEpIHtcbiAgICBzdXBlcihcIk1hc2tQYXNzXCIsIHNjZW5lLCBjYW1lcmEpO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhclBhc3MgPSBuZXcgQ2xlYXJQYXNzKGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5pbnZlcnNlID0gZmFsc2U7XG4gIH1cbiAgc2V0IG1haW5TY2VuZSh2YWx1ZSkge1xuICAgIHRoaXMuc2NlbmUgPSB2YWx1ZTtcbiAgfVxuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICAgIHRoaXMuY2FtZXJhID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtYXNrIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaW52ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52ZXJzZTtcbiAgfVxuICBzZXQgaW52ZXJ0ZWQodmFsdWUpIHtcbiAgICB0aGlzLmludmVyc2UgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBwYXNzIHNob3VsZCBjbGVhciB0aGUgc3RlbmNpbCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY2xlYXJQYXNzLmVuYWJsZWQgaW5zdGVhZC5cbiAgICovXG4gIGdldCBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5jbGVhclBhc3MuZW5hYmxlZDtcbiAgfVxuICBzZXQgY2xlYXIodmFsdWUpIHtcbiAgICB0aGlzLmNsZWFyUGFzcy5lbmFibGVkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGludGVybmFsIGNsZWFyIHBhc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjbGVhclBhc3MuZW5hYmxlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtDbGVhclBhc3N9IFRoZSBjbGVhciBwYXNzLlxuICAgKi9cbiAgZ2V0Q2xlYXJQYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNsZWFyUGFzcztcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1hc2sgaXMgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnZlcnRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBtYXNrIGlzIGludmVydGVkLlxuICAgKi9cbiAgaXNJbnZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZlcnRlZDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlIG1hc2sgaW52ZXJzaW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW52ZXJ0ZWQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIG1hc2sgc2hvdWxkIGJlIGludmVydGVkLlxuICAgKi9cbiAgc2V0SW52ZXJ0ZWQodmFsdWUpIHtcbiAgICB0aGlzLmludmVydGVkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3QgY29udGV4dCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcbiAgICBjb25zdCBidWZmZXJzID0gcmVuZGVyZXIuc3RhdGUuYnVmZmVycztcbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuc2NlbmU7XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgY29uc3QgY2xlYXJQYXNzID0gdGhpcy5jbGVhclBhc3M7XG4gICAgY29uc3Qgd3JpdGVWYWx1ZSA9IHRoaXMuaW52ZXJ0ZWQgPyAwIDogMTtcbiAgICBjb25zdCBjbGVhclZhbHVlID0gMSAtIHdyaXRlVmFsdWU7XG4gICAgYnVmZmVycy5jb2xvci5zZXRNYXNrKGZhbHNlKTtcbiAgICBidWZmZXJzLmRlcHRoLnNldE1hc2soZmFsc2UpO1xuICAgIGJ1ZmZlcnMuY29sb3Iuc2V0TG9ja2VkKHRydWUpO1xuICAgIGJ1ZmZlcnMuZGVwdGguc2V0TG9ja2VkKHRydWUpO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRUZXN0KHRydWUpO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRPcChjb250ZXh0LlJFUExBQ0UsIGNvbnRleHQuUkVQTEFDRSwgY29udGV4dC5SRVBMQUNFKTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0RnVuYyhjb250ZXh0LkFMV0FZUywgd3JpdGVWYWx1ZSwgNDI5NDk2NzI5NSk7XG4gICAgYnVmZmVycy5zdGVuY2lsLnNldENsZWFyKGNsZWFyVmFsdWUpO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRMb2NrZWQodHJ1ZSk7XG4gICAgaWYgKHRoaXMuY2xlYXJQYXNzLmVuYWJsZWQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlclRvU2NyZWVuKSB7XG4gICAgICAgIGNsZWFyUGFzcy5yZW5kZXIocmVuZGVyZXIsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIpO1xuICAgICAgICBjbGVhclBhc3MucmVuZGVyKHJlbmRlcmVyLCBvdXRwdXRCdWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5yZW5kZXJUb1NjcmVlbikge1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoaW5wdXRCdWZmZXIpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG91dHB1dEJ1ZmZlcik7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgfVxuICAgIGJ1ZmZlcnMuY29sb3Iuc2V0TG9ja2VkKGZhbHNlKTtcbiAgICBidWZmZXJzLmRlcHRoLnNldExvY2tlZChmYWxzZSk7XG4gICAgYnVmZmVycy5zdGVuY2lsLnNldExvY2tlZChmYWxzZSk7XG4gICAgYnVmZmVycy5zdGVuY2lsLnNldEZ1bmMoY29udGV4dC5FUVVBTCwgMSwgNDI5NDk2NzI5NSk7XG4gICAgYnVmZmVycy5zdGVuY2lsLnNldE9wKGNvbnRleHQuS0VFUCwgY29udGV4dC5LRUVQLCBjb250ZXh0LktFRVApO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRMb2NrZWQodHJ1ZSk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL0VmZmVjdENvbXBvc2VyLmpzXG52YXIgRWZmZWN0Q29tcG9zZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGVmZmVjdCBjb21wb3Nlci5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGF0IHNob3VsZCBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGVwdGhCdWZmZXI9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBtYWluIHJlbmRlciB0YXJnZXRzIHNob3VsZCBoYXZlIGEgZGVwdGggYnVmZmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0ZW5jaWxCdWZmZXI9ZmFsc2VdIC0gV2hldGhlciB0aGUgbWFpbiByZW5kZXIgdGFyZ2V0cyBzaG91bGQgaGF2ZSBhIHN0ZW5jaWwgYnVmZmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFscGhhXSAtIERlcHJlY2F0ZWQuIEJ1ZmZlcnMgYXJlIGFsd2F5cyBSR0JBIHNpbmNlIHRocmVlIHIxMzcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXNhbXBsaW5nPTBdIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzIHVzZWQgZm9yIG11bHRpc2FtcGxlIGFudGlhbGlhc2luZy4gUmVxdWlyZXMgV2ViR0wgMi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZyYW1lQnVmZmVyVHlwZV0gLSBUaGUgdHlwZSBvZiB0aGUgaW50ZXJuYWwgZnJhbWUgYnVmZmVycy4gSXQncyByZWNvbW1lbmRlZCB0byB1c2UgSGFsZkZsb2F0VHlwZSBpZiBwb3NzaWJsZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyID0gbnVsbCwge1xuICAgIGRlcHRoQnVmZmVyID0gdHJ1ZSxcbiAgICBzdGVuY2lsQnVmZmVyID0gZmFsc2UsXG4gICAgbXVsdGlzYW1wbGluZyA9IDAsXG4gICAgZnJhbWVCdWZmZXJUeXBlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuaW5wdXRCdWZmZXIgPSB0aGlzLmNyZWF0ZUJ1ZmZlcihkZXB0aEJ1ZmZlciwgc3RlbmNpbEJ1ZmZlciwgZnJhbWVCdWZmZXJUeXBlLCBtdWx0aXNhbXBsaW5nKTtcbiAgICB0aGlzLm91dHB1dEJ1ZmZlciA9IHRoaXMuaW5wdXRCdWZmZXIuY2xvbmUoKTtcbiAgICB0aGlzLmNvcHlQYXNzID0gbmV3IENvcHlQYXNzKCk7XG4gICAgdGhpcy5kZXB0aFRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMucGFzc2VzID0gW107XG4gICAgdGhpcy50aW1lciA9IG5ldyBUaW1lcigpO1xuICAgIHRoaXMuYXV0b1JlbmRlclRvU2NyZWVuID0gdHJ1ZTtcbiAgICB0aGlzLnNldFJlbmRlcmVyKHJlbmRlcmVyKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgYW1vdW50IG9mIHNhbXBsZXMgdXNlZCBmb3IgbXVsdGlzYW1wbGUgYW50aS1hbGlhc2luZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtdWx0aXNhbXBsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0QnVmZmVyLnNhbXBsZXMgfHwgMDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYW1vdW50IG9mIE1TQUEgc2FtcGxlcy5cbiAgICpcbiAgICogUmVxdWlyZXMgV2ViR0wgMi4gU2V0IHRvIHplcm8gdG8gZGlzYWJsZSBtdWx0aXNhbXBsaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IG11bHRpc2FtcGxpbmcodmFsdWUpIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLmlucHV0QnVmZmVyO1xuICAgIGNvbnN0IG11bHRpc2FtcGxpbmcgPSB0aGlzLm11bHRpc2FtcGxpbmc7XG4gICAgaWYgKG11bHRpc2FtcGxpbmcgPiAwICYmIHZhbHVlID4gMCkge1xuICAgICAgdGhpcy5pbnB1dEJ1ZmZlci5zYW1wbGVzID0gdmFsdWU7XG4gICAgICB0aGlzLm91dHB1dEJ1ZmZlci5zYW1wbGVzID0gdmFsdWU7XG4gICAgICB0aGlzLmlucHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMub3V0cHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICB9IGVsc2UgaWYgKG11bHRpc2FtcGxpbmcgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmlucHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMub3V0cHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuaW5wdXRCdWZmZXIgPSB0aGlzLmNyZWF0ZUJ1ZmZlcihcbiAgICAgICAgYnVmZmVyLmRlcHRoQnVmZmVyLFxuICAgICAgICBidWZmZXIuc3RlbmNpbEJ1ZmZlcixcbiAgICAgICAgYnVmZmVyLnRleHR1cmUudHlwZSxcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICB0aGlzLmlucHV0QnVmZmVyLmRlcHRoVGV4dHVyZSA9IHRoaXMuZGVwdGhUZXh0dXJlO1xuICAgICAgdGhpcy5vdXRwdXRCdWZmZXIgPSB0aGlzLmlucHV0QnVmZmVyLmNsb25lKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCB0aW1lci5cbiAgICpcbiAgICogQHJldHVybiB7VGltZXJ9IFRoZSB0aW1lci5cbiAgICovXG4gIGdldFRpbWVyKCkge1xuICAgIHJldHVybiB0aGlzLnRpbWVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQHJldHVybiB7V2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyLlxuICAgKi9cbiAgZ2V0UmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKi9cbiAgc2V0UmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgaWYgKHJlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBzaXplID0gcmVuZGVyZXIuZ2V0U2l6ZShuZXcgVmVjdG9yMigpKTtcbiAgICAgIGNvbnN0IGFscGhhID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpLmdldENvbnRleHRBdHRyaWJ1dGVzKCkuYWxwaGE7XG4gICAgICBjb25zdCBmcmFtZUJ1ZmZlclR5cGUgPSB0aGlzLmlucHV0QnVmZmVyLnRleHR1cmUudHlwZTtcbiAgICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgPT09IFVuc2lnbmVkQnl0ZVR5cGUyICYmIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlMikge1xuICAgICAgICB0aGlzLmlucHV0QnVmZmVyLnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlMjtcbiAgICAgICAgdGhpcy5vdXRwdXRCdWZmZXIudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UyO1xuICAgICAgICB0aGlzLmlucHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vdXRwdXRCdWZmZXIuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgcmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7XG4gICAgICB0aGlzLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgZm9yIChjb25zdCBwYXNzIG9mIHRoaXMucGFzc2VzKSB7XG4gICAgICAgIHBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvbmUuXG4gICAqXG4gICAqIFRoZSBhdXRvIGNsZWFyIG1lY2hhbmlzbSBvZiB0aGUgcHJvdmlkZWQgcmVuZGVyZXIgd2lsbCBiZSBkaXNhYmxlZC4gSWYgdGhlIG5ldyByZW5kZXIgc2l6ZSBkaWZmZXJzIGZyb20gdGhlXG4gICAqIHByZXZpb3VzIG9uZSwgYWxsIHBhc3NlcyB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBET00gZWxlbWVudCBvZiB0aGUgY3VycmVudCByZW5kZXJlciB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgbm9kZSBhbmQgdGhlIERPTVxuICAgKiBlbGVtZW50IG9mIHRoZSBuZXcgcmVuZGVyZXIgd2lsbCB0YWtlIGl0cyBwbGFjZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFJlbmRlcmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgbmV3IHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVwZGF0ZURPTSAtIEluZGljYXRlcyB3aGV0aGVyIHRoZSBvbGQgY2FudmFzIHNob3VsZCBiZSByZXBsYWNlZCBieSB0aGUgbmV3IG9uZSBpbiB0aGUgRE9NLlxuICAgKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmVyfSBUaGUgb2xkIHJlbmRlcmVyLlxuICAgKi9cbiAgcmVwbGFjZVJlbmRlcmVyKHJlbmRlcmVyLCB1cGRhdGVET00gPSB0cnVlKSB7XG4gICAgY29uc3Qgb2xkUmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IHBhcmVudCA9IG9sZFJlbmRlcmVyLmRvbUVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB0aGlzLnNldFJlbmRlcmVyKHJlbmRlcmVyKTtcbiAgICBpZiAodXBkYXRlRE9NICYmIHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG9sZFJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gb2xkUmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkZXB0aCB0ZXh0dXJlIGF0dGFjaG1lbnQgdGhhdCB3aWxsIGJlIHByb3ZpZGVkIHRvIGFsbCBwYXNzZXMuXG4gICAqXG4gICAqIE5vdGU6IFdoZW4gYSBzaGFkZXIgcmVhZHMgZnJvbSBhIGRlcHRoIHRleHR1cmUgYW5kIHdyaXRlcyB0byBhIHJlbmRlciB0YXJnZXQgdGhhdCB1c2VzIHRoZSBzYW1lIGRlcHRoIHRleHR1cmVcbiAgICogYXR0YWNobWVudCwgdGhlIGRlcHRoIGluZm9ybWF0aW9uIHdpbGwgYmUgbG9zdC4gVGhpcyBoYXBwZW5zIGV2ZW4gaWYgYGRlcHRoV3JpdGVgIGlzIGRpc2FibGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtEZXB0aFRleHR1cmV9IFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKi9cbiAgY3JlYXRlRGVwdGhUZXh0dXJlKCkge1xuICAgIGNvbnN0IGRlcHRoVGV4dHVyZSA9IHRoaXMuZGVwdGhUZXh0dXJlID0gbmV3IERlcHRoVGV4dHVyZSgpO1xuICAgIHRoaXMuaW5wdXRCdWZmZXIuZGVwdGhUZXh0dXJlID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuaW5wdXRCdWZmZXIuZGlzcG9zZSgpO1xuICAgIGlmICh0aGlzLmlucHV0QnVmZmVyLnN0ZW5jaWxCdWZmZXIpIHtcbiAgICAgIGRlcHRoVGV4dHVyZS5mb3JtYXQgPSBEZXB0aFN0ZW5jaWxGb3JtYXQ7XG4gICAgICBkZXB0aFRleHR1cmUudHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVwdGhUZXh0dXJlLnR5cGUgPSBVbnNpZ25lZEludFR5cGU7XG4gICAgfVxuICAgIHJldHVybiBkZXB0aFRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIGN1cnJlbnQgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlbGV0ZURlcHRoVGV4dHVyZSgpIHtcbiAgICBpZiAodGhpcy5kZXB0aFRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZGVwdGhUZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuZGVwdGhUZXh0dXJlID0gbnVsbDtcbiAgICAgIHRoaXMuaW5wdXRCdWZmZXIuZGVwdGhUZXh0dXJlID0gbnVsbDtcbiAgICAgIHRoaXMuaW5wdXRCdWZmZXIuZGlzcG9zZSgpO1xuICAgICAgZm9yIChjb25zdCBwYXNzIG9mIHRoaXMucGFzc2VzKSB7XG4gICAgICAgIHBhc3Muc2V0RGVwdGhUZXh0dXJlKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyByZW5kZXIgdGFyZ2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBDcmVhdGUgYnVmZmVycyBtYW51YWxseSB2aWEgV2ViR0xSZW5kZXJUYXJnZXQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBkZXB0aEJ1ZmZlciAtIFdoZXRoZXIgdGhlIHJlbmRlciB0YXJnZXQgc2hvdWxkIGhhdmUgYSBkZXB0aCBidWZmZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RlbmNpbEJ1ZmZlciAtIFdoZXRoZXIgdGhlIHJlbmRlciB0YXJnZXQgc2hvdWxkIGhhdmUgYSBzdGVuY2lsIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgLSBUaGUgZnJhbWUgYnVmZmVyIHR5cGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtdWx0aXNhbXBsaW5nIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzIHRvIHVzZSBmb3IgYW50aWFsaWFzaW5nLlxuICAgKiBAcmV0dXJuIHtXZWJHTFJlbmRlclRhcmdldH0gQSBuZXcgcmVuZGVyIHRhcmdldCB0aGF0IGVxdWFscyB0aGUgcmVuZGVyZXIncyBjYW52YXMuXG4gICAqL1xuICBjcmVhdGVCdWZmZXIoZGVwdGhCdWZmZXIsIHN0ZW5jaWxCdWZmZXIsIHR5cGUsIG11bHRpc2FtcGxpbmcpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3Qgc2l6ZSA9IHJlbmRlcmVyID09PSBudWxsID8gbmV3IFZlY3RvcjIoKSA6IHJlbmRlcmVyLmdldERyYXdpbmdCdWZmZXJTaXplKG5ldyBWZWN0b3IyKCkpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtaW5GaWx0ZXI6IExpbmVhckZpbHRlcjIsXG4gICAgICBtYWdGaWx0ZXI6IExpbmVhckZpbHRlcjIsXG4gICAgICBzdGVuY2lsQnVmZmVyLFxuICAgICAgZGVwdGhCdWZmZXIsXG4gICAgICB0eXBlXG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQzKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCBvcHRpb25zKTtcbiAgICBpZiAobXVsdGlzYW1wbGluZyA+IDApIHtcbiAgICAgIHJlbmRlclRhcmdldC5pZ25vcmVEZXB0aEZvck11bHRpc2FtcGxlQ29weSA9IGZhbHNlO1xuICAgICAgcmVuZGVyVGFyZ2V0LnNhbXBsZXMgPSBtdWx0aXNhbXBsaW5nO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gVW5zaWduZWRCeXRlVHlwZTIgJiYgcmVuZGVyZXIgIT09IG51bGwgJiYgcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UyKSB7XG4gICAgICByZW5kZXJUYXJnZXQudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UyO1xuICAgIH1cbiAgICByZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJFZmZlY3RDb21wb3Nlci5CdWZmZXJcIjtcbiAgICByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVuZGVyVGFyZ2V0O1xuICB9XG4gIC8qKlxuICAgKiBDYW4gYmUgdXNlZCB0byBjaGFuZ2UgdGhlIG1haW4gc2NlbmUgZm9yIGFsbCByZWdpc3RlcmVkIHBhc3NlcyBhbmQgZWZmZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgc2NlbmUuXG4gICAqL1xuICBzZXRNYWluU2NlbmUoc2NlbmUpIHtcbiAgICBmb3IgKGNvbnN0IHBhc3Mgb2YgdGhpcy5wYXNzZXMpIHtcbiAgICAgIHBhc3MubWFpblNjZW5lID0gc2NlbmU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYW4gYmUgdXNlZCB0byBjaGFuZ2UgdGhlIG1haW4gY2FtZXJhIGZvciBhbGwgcmVnaXN0ZXJlZCBwYXNzZXMgYW5kIGVmZmVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhLlxuICAgKi9cbiAgc2V0TWFpbkNhbWVyYShjYW1lcmEpIHtcbiAgICBmb3IgKGNvbnN0IHBhc3Mgb2YgdGhpcy5wYXNzZXMpIHtcbiAgICAgIHBhc3MubWFpbkNhbWVyYSA9IGNhbWVyYTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBwYXNzLCBvcHRpb25hbGx5IGF0IGEgc3BlY2lmaWMgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7UGFzc30gcGFzcyAtIEEgbmV3IHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdIC0gQW4gaW5kZXggYXQgd2hpY2ggdGhlIHBhc3Mgc2hvdWxkIGJlIGluc2VydGVkLlxuICAgKi9cbiAgYWRkUGFzcyhwYXNzLCBpbmRleCkge1xuICAgIGNvbnN0IHBhc3NlcyA9IHRoaXMucGFzc2VzO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBkcmF3aW5nQnVmZmVyU2l6ZSA9IHJlbmRlcmVyLmdldERyYXdpbmdCdWZmZXJTaXplKG5ldyBWZWN0b3IyKCkpO1xuICAgIGNvbnN0IGFscGhhID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpLmdldENvbnRleHRBdHRyaWJ1dGVzKCkuYWxwaGE7XG4gICAgY29uc3QgZnJhbWVCdWZmZXJUeXBlID0gdGhpcy5pbnB1dEJ1ZmZlci50ZXh0dXJlLnR5cGU7XG4gICAgcGFzcy5zZXRSZW5kZXJlcihyZW5kZXJlcik7XG4gICAgcGFzcy5zZXRTaXplKGRyYXdpbmdCdWZmZXJTaXplLndpZHRoLCBkcmF3aW5nQnVmZmVyU2l6ZS5oZWlnaHQpO1xuICAgIHBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgaWYgKHRoaXMuYXV0b1JlbmRlclRvU2NyZWVuKSB7XG4gICAgICBpZiAocGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFzc2VzW3Bhc3Nlcy5sZW5ndGggLSAxXS5yZW5kZXJUb1NjcmVlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHBhc3MucmVuZGVyVG9TY3JlZW4pIHtcbiAgICAgICAgdGhpcy5hdXRvUmVuZGVyVG9TY3JlZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgIHBhc3Nlcy5zcGxpY2UoaW5kZXgsIDAsIHBhc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXNzZXMucHVzaChwYXNzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0b1JlbmRlclRvU2NyZWVuKSB7XG4gICAgICBwYXNzZXNbcGFzc2VzLmxlbmd0aCAtIDFdLnJlbmRlclRvU2NyZWVuID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBhc3MubmVlZHNEZXB0aFRleHR1cmUgfHwgdGhpcy5kZXB0aFRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmRlcHRoVGV4dHVyZSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkZXB0aFRleHR1cmUgPSB0aGlzLmNyZWF0ZURlcHRoVGV4dHVyZSgpO1xuICAgICAgICBmb3IgKHBhc3Mgb2YgcGFzc2VzKSB7XG4gICAgICAgICAgcGFzcy5zZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFzcy5zZXREZXB0aFRleHR1cmUodGhpcy5kZXB0aFRleHR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGFzc30gcGFzcyAtIFRoZSBwYXNzLlxuICAgKi9cbiAgcmVtb3ZlUGFzcyhwYXNzKSB7XG4gICAgY29uc3QgcGFzc2VzID0gdGhpcy5wYXNzZXM7XG4gICAgY29uc3QgaW5kZXggPSBwYXNzZXMuaW5kZXhPZihwYXNzKTtcbiAgICBjb25zdCBleGlzdHMgPSBpbmRleCAhPT0gLTE7XG4gICAgY29uc3QgcmVtb3ZlZCA9IGV4aXN0cyAmJiBwYXNzZXMuc3BsaWNlKGluZGV4LCAxKS5sZW5ndGggPiAwO1xuICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICBpZiAodGhpcy5kZXB0aFRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IChhLCBiKSA9PiBhIHx8IGIubmVlZHNEZXB0aFRleHR1cmU7XG4gICAgICAgIGNvbnN0IGRlcHRoVGV4dHVyZVJlcXVpcmVkID0gcGFzc2VzLnJlZHVjZShyZWR1Y2VyLCBmYWxzZSk7XG4gICAgICAgIGlmICghZGVwdGhUZXh0dXJlUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocGFzcy5nZXREZXB0aFRleHR1cmUoKSA9PT0gdGhpcy5kZXB0aFRleHR1cmUpIHtcbiAgICAgICAgICAgIHBhc3Muc2V0RGVwdGhUZXh0dXJlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmRlbGV0ZURlcHRoVGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hdXRvUmVuZGVyVG9TY3JlZW4pIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSBwYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcGFzcy5yZW5kZXJUb1NjcmVlbiA9IGZhbHNlO1xuICAgICAgICAgIGlmIChwYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFzc2VzW3Bhc3Nlcy5sZW5ndGggLSAxXS5yZW5kZXJUb1NjcmVlbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBwYXNzZXMuXG4gICAqL1xuICByZW1vdmVBbGxQYXNzZXMoKSB7XG4gICAgY29uc3QgcGFzc2VzID0gdGhpcy5wYXNzZXM7XG4gICAgdGhpcy5kZWxldGVEZXB0aFRleHR1cmUoKTtcbiAgICBpZiAocGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0aGlzLmF1dG9SZW5kZXJUb1NjcmVlbikge1xuICAgICAgICBwYXNzZXNbcGFzc2VzLmxlbmd0aCAtIDFdLnJlbmRlclRvU2NyZWVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnBhc3NlcyA9IFtdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVuZGVycyBhbGwgZW5hYmxlZCBwYXNzZXMgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgZnJhbWUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHJlbmRlcihkZWx0YVRpbWUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgY29weVBhc3MgPSB0aGlzLmNvcHlQYXNzO1xuICAgIGxldCBpbnB1dEJ1ZmZlciA9IHRoaXMuaW5wdXRCdWZmZXI7XG4gICAgbGV0IG91dHB1dEJ1ZmZlciA9IHRoaXMub3V0cHV0QnVmZmVyO1xuICAgIGxldCBzdGVuY2lsVGVzdCA9IGZhbHNlO1xuICAgIGxldCBjb250ZXh0LCBzdGVuY2lsLCBidWZmZXI7XG4gICAgaWYgKGRlbHRhVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRpbWVyLnVwZGF0ZSgpO1xuICAgICAgZGVsdGFUaW1lID0gdGhpcy50aW1lci5nZXREZWx0YSgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhc3Mgb2YgdGhpcy5wYXNzZXMpIHtcbiAgICAgIGlmIChwYXNzLmVuYWJsZWQpIHtcbiAgICAgICAgcGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpO1xuICAgICAgICBpZiAocGFzcy5uZWVkc1N3YXApIHtcbiAgICAgICAgICBpZiAoc3RlbmNpbFRlc3QpIHtcbiAgICAgICAgICAgIGNvcHlQYXNzLnJlbmRlclRvU2NyZWVuID0gcGFzcy5yZW5kZXJUb1NjcmVlbjtcbiAgICAgICAgICAgIGNvbnRleHQgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBzdGVuY2lsID0gcmVuZGVyZXIuc3RhdGUuYnVmZmVycy5zdGVuY2lsO1xuICAgICAgICAgICAgc3RlbmNpbC5zZXRGdW5jKGNvbnRleHQuTk9URVFVQUwsIDEsIDQyOTQ5NjcyOTUpO1xuICAgICAgICAgICAgY29weVBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KTtcbiAgICAgICAgICAgIHN0ZW5jaWwuc2V0RnVuYyhjb250ZXh0LkVRVUFMLCAxLCA0Mjk0OTY3Mjk1KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyID0gaW5wdXRCdWZmZXI7XG4gICAgICAgICAgaW5wdXRCdWZmZXIgPSBvdXRwdXRCdWZmZXI7XG4gICAgICAgICAgb3V0cHV0QnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXNzIGluc3RhbmNlb2YgTWFza1Bhc3MpIHtcbiAgICAgICAgICBzdGVuY2lsVGVzdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocGFzcyBpbnN0YW5jZW9mIENsZWFyTWFza1Bhc3MpIHtcbiAgICAgICAgICBzdGVuY2lsVGVzdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoZSBidWZmZXJzLCBwYXNzZXMgYW5kIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbdXBkYXRlU3R5bGVdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdHlsZSBvZiB0aGUgY2FudmFzIHNob3VsZCBiZSB1cGRhdGVkLlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBjdXJyZW50U2l6ZSA9IHJlbmRlcmVyLmdldFNpemUobmV3IFZlY3RvcjIoKSk7XG4gICAgaWYgKHdpZHRoID09PSB2b2lkIDAgfHwgaGVpZ2h0ID09PSB2b2lkIDApIHtcbiAgICAgIHdpZHRoID0gY3VycmVudFNpemUud2lkdGg7XG4gICAgICBoZWlnaHQgPSBjdXJyZW50U2l6ZS5oZWlnaHQ7XG4gICAgfVxuICAgIGlmIChjdXJyZW50U2l6ZS53aWR0aCAhPT0gd2lkdGggfHwgY3VycmVudFNpemUuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUpO1xuICAgIH1cbiAgICBjb25zdCBkcmF3aW5nQnVmZmVyU2l6ZSA9IHJlbmRlcmVyLmdldERyYXdpbmdCdWZmZXJTaXplKG5ldyBWZWN0b3IyKCkpO1xuICAgIHRoaXMuaW5wdXRCdWZmZXIuc2V0U2l6ZShkcmF3aW5nQnVmZmVyU2l6ZS53aWR0aCwgZHJhd2luZ0J1ZmZlclNpemUuaGVpZ2h0KTtcbiAgICB0aGlzLm91dHB1dEJ1ZmZlci5zZXRTaXplKGRyYXdpbmdCdWZmZXJTaXplLndpZHRoLCBkcmF3aW5nQnVmZmVyU2l6ZS5oZWlnaHQpO1xuICAgIGZvciAoY29uc3QgcGFzcyBvZiB0aGlzLnBhc3Nlcykge1xuICAgICAgcGFzcy5zZXRTaXplKGRyYXdpbmdCdWZmZXJTaXplLndpZHRoLCBkcmF3aW5nQnVmZmVyU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgY29tcG9zZXIgYnkgZGVsZXRpbmcgYWxsIHBhc3NlcyBhbmQgY3JlYXRpbmcgbmV3IGJ1ZmZlcnMuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmF1dG9SZW5kZXJUb1NjcmVlbiA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgY29tcG9zZXIgYW5kIGFsbCBwYXNzZXMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGZvciAoY29uc3QgcGFzcyBvZiB0aGlzLnBhc3Nlcykge1xuICAgICAgcGFzcy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHRoaXMucGFzc2VzID0gW107XG4gICAgaWYgKHRoaXMuaW5wdXRCdWZmZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW5wdXRCdWZmZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vdXRwdXRCdWZmZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMub3V0cHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5kZWxldGVEZXB0aFRleHR1cmUoKTtcbiAgICB0aGlzLmNvcHlQYXNzLmRpc3Bvc2UoKTtcbiAgICB0aGlzLnRpbWVyLmRpc3Bvc2UoKTtcbiAgICBQYXNzLmZ1bGxzY3JlZW5HZW9tZXRyeS5kaXNwb3NlKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL0VmZmVjdFNoYWRlckRhdGEuanNcbmltcG9ydCB7IExpbmVhclNSR0JDb2xvclNwYWNlIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lbnVtcy9FZmZlY3RBdHRyaWJ1dGUuanNcbnZhciBFZmZlY3RBdHRyaWJ1dGUgPSB7XG4gIE5PTkU6IDAsXG4gIERFUFRIOiAxLFxuICBDT05WT0xVVElPTjogMlxufTtcblxuLy8gc3JjL2VudW1zL0VmZmVjdFNoYWRlclNlY3Rpb24uanNcbnZhciBFZmZlY3RTaGFkZXJTZWN0aW9uID0ge1xuICBGUkFHTUVOVF9IRUFEOiBcIkZSQUdNRU5UX0hFQURcIixcbiAgRlJBR01FTlRfTUFJTl9VVjogXCJGUkFHTUVOVF9NQUlOX1VWXCIsXG4gIEZSQUdNRU5UX01BSU5fSU1BR0U6IFwiRlJBR01FTlRfTUFJTl9JTUFHRVwiLFxuICBWRVJURVhfSEVBRDogXCJWRVJURVhfSEVBRFwiLFxuICBWRVJURVhfTUFJTl9TVVBQT1JUOiBcIlZFUlRFWF9NQUlOX1NVUFBPUlRcIlxufTtcblxuLy8gc3JjL2NvcmUvRWZmZWN0U2hhZGVyRGF0YS5qc1xudmFyIEVmZmVjdFNoYWRlckRhdGEgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIG5ldyBzaGFkZXIgZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2hhZGVyUGFydHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICBbRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9IRUFELCBudWxsXSxcbiAgICAgIFtFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fVVYsIG51bGxdLFxuICAgICAgW0VmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9JTUFHRSwgbnVsbF0sXG4gICAgICBbRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfSEVBRCwgbnVsbF0sXG4gICAgICBbRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfTUFJTl9TVVBQT1JULCBudWxsXVxuICAgIF0pO1xuICAgIHRoaXMuZGVmaW5lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy51bmlmb3JtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5ibGVuZE1vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IEVmZmVjdEF0dHJpYnV0ZS5OT05FO1xuICAgIHRoaXMudmFyeWluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMudXZUcmFuc2Zvcm1hdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMucmVhZERlcHRoID0gZmFsc2U7XG4gICAgdGhpcy5jb2xvclNwYWNlID0gTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL0dhdXNzS2VybmVsLmpzXG5mdW5jdGlvbiBnZXRDb2VmZmljaWVudHMobikge1xuICBsZXQgcmVzdWx0O1xuICBpZiAobiA9PT0gMCkge1xuICAgIHJlc3VsdCA9IG5ldyBGbG9hdDY0QXJyYXkoMCk7XG4gIH0gZWxzZSBpZiAobiA9PT0gMSkge1xuICAgIHJlc3VsdCA9IG5ldyBGbG9hdDY0QXJyYXkoWzFdKTtcbiAgfSBlbHNlIGlmIChuID4gMSkge1xuICAgIGxldCByb3cwID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICBsZXQgcm93MSA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gICAgZm9yIChsZXQgeSA9IDE7IHkgPD0gbjsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHk7ICsreCkge1xuICAgICAgICByb3cxW3hdID0geCA9PT0gMCB8fCB4ID09PSB5IC0gMSA/IDEgOiByb3cwW3ggLSAxXSArIHJvdzBbeF07XG4gICAgICB9XG4gICAgICByZXN1bHQgPSByb3cxO1xuICAgICAgcm93MSA9IHJvdzA7XG4gICAgICByb3cwID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEdhdXNzS2VybmVsID0gY2xhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBHYXVzcyBrZXJuZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBrZXJuZWxTaXplIC0gVGhlIGtlcm5lbCBzaXplLiBTaG91bGQgYmUgYW4gb2RkIG51bWJlciBpbiB0aGUgcmFuZ2UgWzMsIDEwMjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2VkZ2VCaWFzPTJdIC0gRGV0ZXJtaW5lcyBob3cgbWFueSBlZGdlIGNvZWZmaWNpZW50cyBzaG91bGQgYmUgY3V0IG9mZiBmb3IgaW5jcmVhc2VkIGFjY3VyYWN5LlxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2VybmVsU2l6ZSwgZWRnZUJpYXMgPSAyKSB7XG4gICAgdGhpcy53ZWlnaHRzID0gbnVsbDtcbiAgICB0aGlzLm9mZnNldHMgPSBudWxsO1xuICAgIHRoaXMubGluZWFyV2VpZ2h0cyA9IG51bGw7XG4gICAgdGhpcy5saW5lYXJPZmZzZXRzID0gbnVsbDtcbiAgICB0aGlzLmdlbmVyYXRlKGtlcm5lbFNpemUsIGVkZ2VCaWFzKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBzdGVwcyBmb3IgZGlzY3JldGUgc2FtcGxpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc3RlcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0cyA9PT0gbnVsbCA/IDAgOiB0aGlzLm9mZnNldHMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHN0ZXBzIGZvciBsaW5lYXIgc2FtcGxpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbGluZWFyU3RlcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZWFyT2Zmc2V0cyA9PT0gbnVsbCA/IDAgOiB0aGlzLmxpbmVhck9mZnNldHMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIGtlcm5lbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGtlcm5lbFNpemUgLSBUaGUga2VybmVsIHNpemUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlZGdlQmlhcyAtIFRoZSBhbW91bnQgb2YgZWRnZSBjb2VmZmljaWVudHMgdG8gaWdub3JlLlxuICAgKi9cbiAgZ2VuZXJhdGUoa2VybmVsU2l6ZSwgZWRnZUJpYXMpIHtcbiAgICBpZiAoa2VybmVsU2l6ZSA8IDMgfHwga2VybmVsU2l6ZSA+IDEwMjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBrZXJuZWwgc2l6ZSBtdXN0IGJlIGluIHRoZSByYW5nZSBbMywgMTAyMF1cIik7XG4gICAgfVxuICAgIGNvbnN0IG4gPSBrZXJuZWxTaXplICsgZWRnZUJpYXMgKiAyO1xuICAgIGNvbnN0IGNvZWZmaWNpZW50cyA9IGVkZ2VCaWFzID4gMCA/IGdldENvZWZmaWNpZW50cyhuKS5zbGljZShlZGdlQmlhcywgLWVkZ2VCaWFzKSA6IGdldENvZWZmaWNpZW50cyhuKTtcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChjb2VmZmljaWVudHMubGVuZ3RoIC0gMSkgLyAyKTtcbiAgICBjb25zdCBzdW0gPSBjb2VmZmljaWVudHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IGNvZWZmaWNpZW50cy5zbGljZShtaWQpO1xuICAgIGNvbnN0IG9mZnNldHMgPSBbLi4uQXJyYXkobWlkICsgMSkua2V5cygpXTtcbiAgICBjb25zdCBsaW5lYXJXZWlnaHRzID0gbmV3IEZsb2F0NjRBcnJheShNYXRoLmZsb29yKG9mZnNldHMubGVuZ3RoIC8gMikpO1xuICAgIGNvbnN0IGxpbmVhck9mZnNldHMgPSBuZXcgRmxvYXQ2NEFycmF5KGxpbmVhcldlaWdodHMubGVuZ3RoKTtcbiAgICBsaW5lYXJXZWlnaHRzWzBdID0gd2VpZ2h0c1swXSAvIHN1bTtcbiAgICBmb3IgKGxldCBpID0gMSwgaiA9IDEsIGwgPSBvZmZzZXRzLmxlbmd0aCAtIDE7IGkgPCBsOyBpICs9IDIsICsraikge1xuICAgICAgY29uc3Qgb2Zmc2V0MCA9IG9mZnNldHNbaV0sIG9mZnNldDEgPSBvZmZzZXRzW2kgKyAxXTtcbiAgICAgIGNvbnN0IHdlaWdodDAgPSB3ZWlnaHRzW2ldLCB3ZWlnaHQxID0gd2VpZ2h0c1tpICsgMV07XG4gICAgICBjb25zdCB3ID0gd2VpZ2h0MCArIHdlaWdodDE7XG4gICAgICBjb25zdCBvID0gKG9mZnNldDAgKiB3ZWlnaHQwICsgb2Zmc2V0MSAqIHdlaWdodDEpIC8gdztcbiAgICAgIGxpbmVhcldlaWdodHNbal0gPSB3IC8gc3VtO1xuICAgICAgbGluZWFyT2Zmc2V0c1tqXSA9IG87XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gd2VpZ2h0cy5sZW5ndGgsIHMgPSAxIC8gc3VtOyBpIDwgbDsgKytpKSB7XG4gICAgICB3ZWlnaHRzW2ldICo9IHM7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVhcldlaWdodFN1bSA9IChsaW5lYXJXZWlnaHRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC0gbGluZWFyV2VpZ2h0c1swXSAqIDAuNSkgKiAyO1xuICAgIGlmIChsaW5lYXJXZWlnaHRTdW0gIT09IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGluZWFyV2VpZ2h0cy5sZW5ndGgsIHMgPSAxIC8gbGluZWFyV2VpZ2h0U3VtOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGxpbmVhcldlaWdodHNbaV0gKj0gcztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vZmZzZXRzID0gb2Zmc2V0cztcbiAgICB0aGlzLndlaWdodHMgPSB3ZWlnaHRzO1xuICAgIHRoaXMubGluZWFyT2Zmc2V0cyA9IGxpbmVhck9mZnNldHM7XG4gICAgdGhpcy5saW5lYXJXZWlnaHRzID0gbGluZWFyV2VpZ2h0cztcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvSW1tdXRhYmxlVGltZXIuanNcbnZhciBJbW11dGFibGVUaW1lciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGRlbHRhIHRpbWUgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldERlbHRhKCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlbGFwc2VkIHRpbWUgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldEVsYXBzZWQoKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvSW5pdGlhbGl6YWJsZS5qc1xudmFyIEluaXRpYWxpemFibGUgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvT3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIuanNcbmltcG9ydCB7IEJhY2tTaWRlLCBEb3VibGVTaWRlLCBGcm9udFNpZGUsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMiB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIHdvcmthcm91bmRFbmFibGVkID0gZmFsc2U7XG52YXIgT3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG92ZXJyaWRlIG1hdGVyaWFsIG1hbmFnZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0ZXJpYWx9IFttYXRlcmlhbD1udWxsXSAtIEFuIG92ZXJyaWRlIG1hdGVyaWFsLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWF0ZXJpYWwgPSBudWxsKSB7XG4gICAgdGhpcy5vcmlnaW5hbE1hdGVyaWFscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5tYXRlcmlhbHMgPSBudWxsO1xuICAgIHRoaXMubWF0ZXJpYWxzQmFja1NpZGUgPSBudWxsO1xuICAgIHRoaXMubWF0ZXJpYWxzRG91YmxlU2lkZSA9IG51bGw7XG4gICAgdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkID0gbnVsbDtcbiAgICB0aGlzLm1hdGVyaWFsc0ZsYXRTaGFkZWRCYWNrU2lkZSA9IG51bGw7XG4gICAgdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkRG91YmxlU2lkZSA9IG51bGw7XG4gICAgdGhpcy5zZXRNYXRlcmlhbChtYXRlcmlhbCk7XG4gICAgdGhpcy5tZXNoQ291bnQgPSAwO1xuICAgIHRoaXMucmVwbGFjZU1hdGVyaWFsID0gKG5vZGUpID0+IHtcbiAgICAgIGlmIChub2RlLmlzTWVzaCkge1xuICAgICAgICBsZXQgbWF0ZXJpYWxzO1xuICAgICAgICBpZiAobm9kZS5tYXRlcmlhbC5mbGF0U2hhZGluZykge1xuICAgICAgICAgIHN3aXRjaCAobm9kZS5tYXRlcmlhbC5zaWRlKSB7XG4gICAgICAgICAgICBjYXNlIERvdWJsZVNpZGU6XG4gICAgICAgICAgICAgIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZERvdWJsZVNpZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCYWNrU2lkZTpcbiAgICAgICAgICAgICAgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkQmFja1NpZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChub2RlLm1hdGVyaWFsLnNpZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRG91YmxlU2lkZTpcbiAgICAgICAgICAgICAgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHNEb3VibGVTaWRlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmFja1NpZGU6XG4gICAgICAgICAgICAgIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzQmFja1NpZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9yaWdpbmFsTWF0ZXJpYWxzLnNldChub2RlLCBub2RlLm1hdGVyaWFsKTtcbiAgICAgICAgaWYgKG5vZGUuaXNTa2lubmVkTWVzaCkge1xuICAgICAgICAgIG5vZGUubWF0ZXJpYWwgPSBtYXRlcmlhbHNbMl07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5pc0luc3RhbmNlZE1lc2gpIHtcbiAgICAgICAgICBub2RlLm1hdGVyaWFsID0gbWF0ZXJpYWxzWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUubWF0ZXJpYWwgPSBtYXRlcmlhbHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgKyt0aGlzLm1lc2hDb3VudDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIGdpdmVuIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbCAtIFRoZSBtYXRlcmlhbC5cbiAgICogQHJldHVybiB7TWF0ZXJpYWx9IFRoZSBjbG9uZWQgbWF0ZXJpYWwuXG4gICAqL1xuICBjbG9uZU1hdGVyaWFsKG1hdGVyaWFsKSB7XG4gICAgaWYgKCEobWF0ZXJpYWwgaW5zdGFuY2VvZiBTaGFkZXJNYXRlcmlhbDIpKSB7XG4gICAgICByZXR1cm4gbWF0ZXJpYWwuY2xvbmUoKTtcbiAgICB9XG4gICAgY29uc3QgdW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3JtcztcbiAgICBjb25zdCB0ZXh0dXJlVW5pZm9ybXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHVuaWZvcm1zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHVuaWZvcm1zW2tleV0udmFsdWU7XG4gICAgICBpZiAodmFsdWUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlKSB7XG4gICAgICAgIHVuaWZvcm1zW2tleV0udmFsdWUgPSBudWxsO1xuICAgICAgICB0ZXh0dXJlVW5pZm9ybXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjbG9uZSA9IG1hdGVyaWFsLmNsb25lKCk7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB0ZXh0dXJlVW5pZm9ybXMpIHtcbiAgICAgIHVuaWZvcm1zW2VudHJ5WzBdXS52YWx1ZSA9IGVudHJ5WzFdO1xuICAgICAgY2xvbmUudW5pZm9ybXNbZW50cnlbMF1dLnZhbHVlID0gZW50cnlbMV07XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgb3ZlcnJpZGUgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsIC0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgc2V0TWF0ZXJpYWwobWF0ZXJpYWwpIHtcbiAgICB0aGlzLmRpc3Bvc2VNYXRlcmlhbHMoKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgaWYgKG1hdGVyaWFsICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbHMgPSB0aGlzLm1hdGVyaWFscyA9IFtcbiAgICAgICAgdGhpcy5jbG9uZU1hdGVyaWFsKG1hdGVyaWFsKSxcbiAgICAgICAgdGhpcy5jbG9uZU1hdGVyaWFsKG1hdGVyaWFsKSxcbiAgICAgICAgdGhpcy5jbG9uZU1hdGVyaWFsKG1hdGVyaWFsKVxuICAgICAgXTtcbiAgICAgIGZvciAoY29uc3QgbTIgb2YgbWF0ZXJpYWxzKSB7XG4gICAgICAgIG0yLnVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0ZXJpYWwudW5pZm9ybXMpO1xuICAgICAgICBtMi5zaWRlID0gRnJvbnRTaWRlO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxzWzJdLnNraW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMubWF0ZXJpYWxzQmFja1NpZGUgPSBtYXRlcmlhbHMubWFwKChtMikgPT4ge1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuY2xvbmVNYXRlcmlhbChtMik7XG4gICAgICAgIGMyLnVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0ZXJpYWwudW5pZm9ybXMpO1xuICAgICAgICBjMi5zaWRlID0gQmFja1NpZGU7XG4gICAgICAgIHJldHVybiBjMjtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYXRlcmlhbHNEb3VibGVTaWRlID0gbWF0ZXJpYWxzLm1hcCgobTIpID0+IHtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLmNsb25lTWF0ZXJpYWwobTIpO1xuICAgICAgICBjMi51bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hdGVyaWFsLnVuaWZvcm1zKTtcbiAgICAgICAgYzIuc2lkZSA9IERvdWJsZVNpZGU7XG4gICAgICAgIHJldHVybiBjMjtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkID0gbWF0ZXJpYWxzLm1hcCgobTIpID0+IHtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLmNsb25lTWF0ZXJpYWwobTIpO1xuICAgICAgICBjMi51bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hdGVyaWFsLnVuaWZvcm1zKTtcbiAgICAgICAgYzIuZmxhdFNoYWRpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYzI7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZEJhY2tTaWRlID0gbWF0ZXJpYWxzLm1hcCgobTIpID0+IHtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLmNsb25lTWF0ZXJpYWwobTIpO1xuICAgICAgICBjMi51bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hdGVyaWFsLnVuaWZvcm1zKTtcbiAgICAgICAgYzIuZmxhdFNoYWRpbmcgPSB0cnVlO1xuICAgICAgICBjMi5zaWRlID0gQmFja1NpZGU7XG4gICAgICAgIHJldHVybiBjMjtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkRG91YmxlU2lkZSA9IG1hdGVyaWFscy5tYXAoKG0yKSA9PiB7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5jbG9uZU1hdGVyaWFsKG0yKTtcbiAgICAgICAgYzIudW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXRlcmlhbC51bmlmb3Jtcyk7XG4gICAgICAgIGMyLmZsYXRTaGFkaW5nID0gdHJ1ZTtcbiAgICAgICAgYzIuc2lkZSA9IERvdWJsZVNpZGU7XG4gICAgICAgIHJldHVybiBjMjtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc2NlbmUgd2l0aCB0aGUgb3ZlcnJpZGUgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gQSBzY2VuZS5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhKSB7XG4gICAgY29uc3Qgc2hhZG93TWFwRW5hYmxlZCA9IHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkO1xuICAgIHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkID0gZmFsc2U7XG4gICAgaWYgKHdvcmthcm91bmRFbmFibGVkKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbE1hdGVyaWFscyA9IHRoaXMub3JpZ2luYWxNYXRlcmlhbHM7XG4gICAgICB0aGlzLm1lc2hDb3VudCA9IDA7XG4gICAgICBzY2VuZS50cmF2ZXJzZSh0aGlzLnJlcGxhY2VNYXRlcmlhbCk7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG9yaWdpbmFsTWF0ZXJpYWxzKSB7XG4gICAgICAgIGVudHJ5WzBdLm1hdGVyaWFsID0gZW50cnlbMV07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tZXNoQ291bnQgIT09IG9yaWdpbmFsTWF0ZXJpYWxzLnNpemUpIHtcbiAgICAgICAgb3JpZ2luYWxNYXRlcmlhbHMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XG4gICAgICBzY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsO1xuICAgIH1cbiAgICByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IHNoYWRvd01hcEVuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgY2xvbmVkIG92ZXJyaWRlIG1hdGVyaWFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3Bvc2VNYXRlcmlhbHMoKSB7XG4gICAgaWYgKHRoaXMubWF0ZXJpYWwgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzLmNvbmNhdCh0aGlzLm1hdGVyaWFsc0JhY2tTaWRlKS5jb25jYXQodGhpcy5tYXRlcmlhbHNEb3VibGVTaWRlKS5jb25jYXQodGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkKS5jb25jYXQodGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkQmFja1NpZGUpLmNvbmNhdCh0aGlzLm1hdGVyaWFsc0ZsYXRTaGFkZWREb3VibGVTaWRlKTtcbiAgICAgIGZvciAoY29uc3QgbTIgb2YgbWF0ZXJpYWxzKSB7XG4gICAgICAgIG0yLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGNsZWFudXAgdGFza3MuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMub3JpZ2luYWxNYXRlcmlhbHMuY2xlYXIoKTtcbiAgICB0aGlzLmRpc3Bvc2VNYXRlcmlhbHMoKTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG92ZXJyaWRlIG1hdGVyaWFsIHdvcmthcm91bmQgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IHdvcmthcm91bmRFbmFibGVkKCkge1xuICAgIHJldHVybiB3b3JrYXJvdW5kRW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgb3ZlcnJpZGUgbWF0ZXJpYWwgd29ya2Fyb3VuZCBnbG9iYWxseS5cbiAgICpcbiAgICogVGhpcyBvbmx5IGFmZmVjdHMgcG9zdCBwcm9jZXNzaW5nIHBhc3NlcyBhbmQgZWZmZWN0cy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgc2V0IHdvcmthcm91bmRFbmFibGVkKHZhbHVlKSB7XG4gICAgd29ya2Fyb3VuZEVuYWJsZWQgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvUmVzaXphYmxlLmpzXG52YXIgUmVzaXphYmxlID0gY2xhc3Mge1xuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9SZXNvbHV0aW9uLmpzXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIsIFZlY3RvcjIgYXMgVmVjdG9yMjIgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBBVVRPX1NJWkUgPSAtMTtcbnZhciBSZXNvbHV0aW9uID0gY2xhc3MgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyByZXNvbHV0aW9uLlxuICAgKlxuICAgKiBUT0RPIFJlbW92ZSByZXNpemFibGUgcGFyYW0uXG4gICAqIEBwYXJhbSB7UmVzaXphYmxlfSByZXNpemFibGUgLSBBIHJlc2l6YWJsZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHByZWZlcnJlZCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHByZWZlcnJlZCBoZWlnaHQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGU9MS4wXSAtIEEgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlc2l6YWJsZSwgd2lkdGggPSBBVVRPX1NJWkUsIGhlaWdodCA9IEFVVE9fU0laRSwgc2NhbGUgPSAxKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJlc2l6YWJsZSA9IHJlc2l6YWJsZTtcbiAgICB0aGlzLmJhc2VTaXplID0gbmV3IFZlY3RvcjIyKDEsIDEpO1xuICAgIHRoaXMucHJlZmVycmVkU2l6ZSA9IG5ldyBWZWN0b3IyMih3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnRhcmdldCA9IHRoaXMucHJlZmVycmVkU2l6ZTtcbiAgICB0aGlzLnMgPSBzY2FsZTtcbiAgICB0aGlzLmVmZmVjdGl2ZVNpemUgPSBuZXcgVmVjdG9yMjIoKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKCkgPT4gdGhpcy51cGRhdGVFZmZlY3RpdmVTaXplKCkpO1xuICAgIHRoaXMudXBkYXRlRWZmZWN0aXZlU2l6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBlZmZlY3RpdmUgc2l6ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUVmZmVjdGl2ZVNpemUoKSB7XG4gICAgY29uc3QgYmFzZSA9IHRoaXMuYmFzZVNpemU7XG4gICAgY29uc3QgcHJlZmVycmVkID0gdGhpcy5wcmVmZXJyZWRTaXplO1xuICAgIGNvbnN0IGVmZmVjdGl2ZSA9IHRoaXMuZWZmZWN0aXZlU2l6ZTtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgaWYgKHByZWZlcnJlZC53aWR0aCAhPT0gQVVUT19TSVpFKSB7XG4gICAgICBlZmZlY3RpdmUud2lkdGggPSBwcmVmZXJyZWQud2lkdGg7XG4gICAgfSBlbHNlIGlmIChwcmVmZXJyZWQuaGVpZ2h0ICE9PSBBVVRPX1NJWkUpIHtcbiAgICAgIGVmZmVjdGl2ZS53aWR0aCA9IE1hdGgucm91bmQocHJlZmVycmVkLmhlaWdodCAqIChiYXNlLndpZHRoIC8gTWF0aC5tYXgoYmFzZS5oZWlnaHQsIDEpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVmZmVjdGl2ZS53aWR0aCA9IE1hdGgucm91bmQoYmFzZS53aWR0aCAqIHNjYWxlKTtcbiAgICB9XG4gICAgaWYgKHByZWZlcnJlZC5oZWlnaHQgIT09IEFVVE9fU0laRSkge1xuICAgICAgZWZmZWN0aXZlLmhlaWdodCA9IHByZWZlcnJlZC5oZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChwcmVmZXJyZWQud2lkdGggIT09IEFVVE9fU0laRSkge1xuICAgICAgZWZmZWN0aXZlLmhlaWdodCA9IE1hdGgucm91bmQocHJlZmVycmVkLndpZHRoIC8gTWF0aC5tYXgoYmFzZS53aWR0aCAvIE1hdGgubWF4KGJhc2UuaGVpZ2h0LCAxKSwgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3RpdmUuaGVpZ2h0ID0gTWF0aC5yb3VuZChiYXNlLmhlaWdodCAqIHNjYWxlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZmZlY3RpdmUgd2lkdGguXG4gICAqXG4gICAqIElmIHRoZSBwcmVmZXJyZWQgd2lkdGggYW5kIGhlaWdodCBhcmUgc2V0IHRvIHtAbGluayBSZXNpemVyLkFVVE9fU0laRX0sIHRoZSBiYXNlIHdpZHRoIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWZmZWN0aXZlU2l6ZS53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnByZWZlcnJlZFdpZHRoID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZmZlY3RpdmUgaGVpZ2h0LlxuICAgKlxuICAgKiBJZiB0aGUgcHJlZmVycmVkIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHNldCB0byB7QGxpbmsgUmVzaXplci5BVVRPX1NJWkV9LCB0aGUgYmFzZSBoZWlnaHQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWZmZWN0aXZlU2l6ZS5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMucHJlZmVycmVkSGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSB3aWR0aC5cbiAgICpcbiAgICogSWYgdGhlIHByZWZlcnJlZCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBzZXQgdG8ge0BsaW5rIFJlc2l6ZXIuQVVUT19TSVpFfSwgdGhlIGJhc2Ugd2lkdGggd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHdpZHRoIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGVmZmVjdGl2ZSB3aWR0aC5cbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZmZlY3RpdmUgaGVpZ2h0LlxuICAgKlxuICAgKiBJZiB0aGUgcHJlZmVycmVkIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHNldCB0byB7QGxpbmsgUmVzaXplci5BVVRPX1NJWkV9LCB0aGUgYmFzZSBoZWlnaHQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGhlaWdodCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBlZmZlY3RpdmUgaGVpZ2h0LlxuICAgKi9cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgfVxuICAvKipcbiAgICogVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucztcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5zID0gdmFsdWU7XG4gICAgICB0aGlzLnByZWZlcnJlZFNpemUuc2V0U2NhbGFyKEFVVE9fU0laRSk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICAgICAgdGhpcy5yZXNpemFibGUuc2V0U2l6ZSh0aGlzLmJhc2VTaXplLndpZHRoLCB0aGlzLmJhc2VTaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzY2FsZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzY2FsZS5cbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBBbHNvIHNldHMgdGhlIHByZWZlcnJlZCByZXNvbHV0aW9uIHRvIHtAbGluayBSZXNpemVyLkFVVE9fU0laRX0uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzY2FsZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc2NhbGUuXG4gICAqL1xuICBzZXRTY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMuc2NhbGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2Ugd2lkdGguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYmFzZVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmJhc2VTaXplLndpZHRoO1xuICB9XG4gIHNldCBiYXNlV2lkdGgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5iYXNlU2l6ZS53aWR0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuYmFzZVNpemUud2lkdGggPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY2hhbmdlXCIgfSk7XG4gICAgICB0aGlzLnJlc2l6YWJsZS5zZXRTaXplKHRoaXMuYmFzZVNpemUud2lkdGgsIHRoaXMuYmFzZVNpemUuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJhc2Ugd2lkdGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBiYXNlV2lkdGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYmFzZSB3aWR0aC5cbiAgICovXG4gIGdldEJhc2VXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlV2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJhc2Ugd2lkdGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBiYXNlV2lkdGggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHdpZHRoLlxuICAgKi9cbiAgc2V0QmFzZVdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5iYXNlV2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaGVpZ2h0LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJhc2VIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVNpemUuaGVpZ2h0O1xuICB9XG4gIHNldCBiYXNlSGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuYmFzZVNpemUuaGVpZ2h0ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5iYXNlU2l6ZS5oZWlnaHQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY2hhbmdlXCIgfSk7XG4gICAgICB0aGlzLnJlc2l6YWJsZS5zZXRTaXplKHRoaXMuYmFzZVNpemUud2lkdGgsIHRoaXMuYmFzZVNpemUuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJhc2UgaGVpZ2h0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmFzZUhlaWdodCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBiYXNlIGhlaWdodC5cbiAgICovXG4gIGdldEJhc2VIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZUhlaWdodDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmFzZSBoZWlnaHQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBiYXNlSGVpZ2h0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRCYXNlSGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5iYXNlSGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJhc2Ugc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5iYXNlU2l6ZS53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgdGhpcy5iYXNlU2l6ZS5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICAgICAgdGhpcy5yZXNpemFibGUuc2V0U2l6ZSh0aGlzLmJhc2VTaXplLndpZHRoLCB0aGlzLmJhc2VTaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGUgcHJlZmVycmVkIHdpZHRoLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHByZWZlcnJlZFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnByZWZlcnJlZFNpemUud2lkdGg7XG4gIH1cbiAgc2V0IHByZWZlcnJlZFdpZHRoKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucHJlZmVycmVkU2l6ZS53aWR0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMucHJlZmVycmVkU2l6ZS53aWR0aCA9IHZhbHVlO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJjaGFuZ2VcIiB9KTtcbiAgICAgIHRoaXMucmVzaXphYmxlLnNldFNpemUodGhpcy5iYXNlU2l6ZS53aWR0aCwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJlZmVycmVkIHdpZHRoLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZmVycmVkV2lkdGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcHJlZmVycmVkIHdpZHRoLlxuICAgKi9cbiAgZ2V0UHJlZmVycmVkV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZmVycmVkV2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByZWZlcnJlZCB3aWR0aC5cbiAgICpcbiAgICogVXNlIHtAbGluayBSZXNpemVyLkFVVE9fU0laRX0gdG8gYXV0b21hdGljYWxseSBjYWxjdWxhdGUgdGhlIHdpZHRoIGJhc2VkIG9uIHRoZSBoZWlnaHQgYW5kIGFzcGVjdCByYXRpby5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWZlcnJlZFdpZHRoIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSB3aWR0aC5cbiAgICovXG4gIHNldFByZWZlcnJlZFdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcHJlZmVycmVkIGhlaWdodC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBwcmVmZXJyZWRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZmVycmVkU2l6ZS5oZWlnaHQ7XG4gIH1cbiAgc2V0IHByZWZlcnJlZEhlaWdodCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnByZWZlcnJlZFNpemUuaGVpZ2h0ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5wcmVmZXJyZWRTaXplLmhlaWdodCA9IHZhbHVlO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJjaGFuZ2VcIiB9KTtcbiAgICAgIHRoaXMucmVzaXphYmxlLnNldFNpemUodGhpcy5iYXNlU2l6ZS53aWR0aCwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJlZmVycmVkIGhlaWdodC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWZlcnJlZEhlaWdodCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBwcmVmZXJyZWQgaGVpZ2h0LlxuICAgKi9cbiAgZ2V0UHJlZmVycmVkSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnByZWZlcnJlZEhlaWdodDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZmVycmVkIGhlaWdodC5cbiAgICpcbiAgICogVXNlIHtAbGluayBSZXNpemVyLkFVVE9fU0laRX0gdG8gYXV0b21hdGljYWxseSBjYWxjdWxhdGUgdGhlIGhlaWdodCBiYXNlZCBvbiB0aGUgd2lkdGggYW5kIGFzcGVjdCByYXRpby5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWZlcnJlZEhlaWdodCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0UHJlZmVycmVkSGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5wcmVmZXJyZWRIZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZmVycmVkIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRQcmVmZXJyZWRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5wcmVmZXJyZWRTaXplLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLnByZWZlcnJlZFNpemUuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgIHRoaXMucHJlZmVycmVkU2l6ZS5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICAgICAgdGhpcy5yZXNpemFibGUuc2V0U2l6ZSh0aGlzLmJhc2VTaXplLndpZHRoLCB0aGlzLmJhc2VTaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIGdpdmVuIHJlc29sdXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7UmVzb2x1dGlvbn0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgY29weShyZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zID0gcmVzb2x1dGlvbi5zY2FsZTtcbiAgICB0aGlzLmJhc2VTaXplLnNldChyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KTtcbiAgICB0aGlzLnByZWZlcnJlZFNpemUuc2V0KHJlc29sdXRpb24ucHJlZmVycmVkV2lkdGgsIHJlc29sdXRpb24ucHJlZmVycmVkSGVpZ2h0KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICAgIHRoaXMucmVzaXphYmxlLnNldFNpemUodGhpcy5iYXNlU2l6ZS53aWR0aCwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBBbiBhdXRvIHNpemluZyBjb25zdGFudC5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgdG8gYXV0b21hdGljYWxseSBjYWxjdWxhdGUgdGhlIHdpZHRoIG9yIGhlaWdodCBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgYXNwZWN0IHJhdGlvLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBBVVRPX1NJWkUoKSB7XG4gICAgcmV0dXJuIEFVVE9fU0laRTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL0lkTWFuYWdlci5qc1xudmFyIElkTWFuYWdlciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgSUQgbWFuYWdlci5cbiAgICpcbiAgICogQHBhcmFtIGluaXRpYWxJZCAtIFRoZSBmaXJzdCBJRC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGluaXRpYWxJZCA9IDApIHtcbiAgICB0aGlzLm5leHRJZCA9IGluaXRpYWxJZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgSUQuXG4gICAqXG4gICAqIEByZXR1cm4gVGhlIElELlxuICAgKi9cbiAgZ2V0TmV4dElkKCkge1xuICAgIHJldHVybiB0aGlzLm5leHRJZCsrO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIElEIGNvdW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBpbml0aWFsSWQgLSBUaGUgZmlyc3QgSUQuXG4gICAqIEByZXR1cm4gVGhpcyBtYW5hZ2VyLlxuICAgKi9cbiAgcmVzZXQoaW5pdGlhbElkID0gMCkge1xuICAgIHRoaXMubmV4dElkID0gaW5pdGlhbElkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9TZWxlY3Rpb24uanNcbnZhciBpZE1hbmFnZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IElkTWFuYWdlcigyKTtcbnZhciBTZWxlY3Rpb24gPSBjbGFzcyBleHRlbmRzIFNldCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHNlbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZTxPYmplY3QzRD59IFtpdGVyYWJsZV0gLSBBIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGlzIHNlbGVjdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtsYXllcl0gLSBBIGRlZGljYXRlZCByZW5kZXIgbGF5ZXIgZm9yIHNlbGVjdGVkIG9iamVjdHMuIFJhbmdlIGlzIGBbMiwgMzFdYC4gU3RhcnRzIGF0IDIgaWYgb21pdHRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGl0ZXJhYmxlLCBsYXllciA9IGlkTWFuYWdlci5nZXROZXh0SWQoKSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5leGNsdXNpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXllciA9IGxheWVyO1xuICAgIGlmICh0aGlzLl9sYXllciA8IDEgfHwgdGhpcy5fbGF5ZXIgPiAzMSkge1xuICAgICAgY29uc29sZS53YXJuKFwiTGF5ZXIgb3V0IG9mIHJhbmdlLCByZXNldHRpbmcgdG8gMlwiKTtcbiAgICAgIGlkTWFuYWdlci5yZXNldCgyKTtcbiAgICAgIHRoaXMuX2xheWVyID0gaWRNYW5hZ2VyLmdldE5leHRJZCgpO1xuICAgIH1cbiAgICBpZiAoaXRlcmFibGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5zZXQoaXRlcmFibGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhlIHJlbmRlciBsYXllciBmb3Igc2VsZWN0ZWQgb2JqZWN0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBsYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGF5ZXI7XG4gIH1cbiAgc2V0IGxheWVyKHZhbHVlKSB7XG4gICAgY29uc3QgY3VycmVudExheWVyID0gdGhpcy5fbGF5ZXI7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgdGhpcykge1xuICAgICAgb2JqZWN0LmxheWVycy5kaXNhYmxlKGN1cnJlbnRMYXllcik7XG4gICAgICBvYmplY3QubGF5ZXJzLmVuYWJsZSh2YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMuX2xheWVyID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVuZGVyIGxheWVyIGZvciBzZWxlY3RlZCBvYmplY3RzLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBsYXllciBpcyAyLiBJZiB0aGlzIGNvbGxpZGVzIHdpdGggeW91ciBvd24gY3VzdG9tIGxheWVycywgcGxlYXNlIGNoYW5nZSBpdCBiZWZvcmUgcmVuZGVyaW5nIVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbGF5ZXIgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbGF5ZXIuXG4gICAqL1xuICBnZXRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllcjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVuZGVyIGxheWVyIGZvciBzZWxlY3RlZCBvYmplY3RzLlxuICAgKlxuICAgKiBUaGUgY3VycmVudCBzZWxlY3Rpb24gd2lsbCBiZSB1cGRhdGVkIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbGF5ZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGxheWVyLiBSYW5nZSBpcyBbMCwgMzFdLlxuICAgKi9cbiAgc2V0TGF5ZXIodmFsdWUpIHtcbiAgICB0aGlzLmxheWVyID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdHMgdGhhdCBhcmUgYWRkZWQgdG8gdGhpcyBzZWxlY3Rpb24gd2lsbCBiZSByZW1vdmVkIGZyb20gYWxsIG90aGVyIGxheWVycy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGV4Y2x1c2l2ZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFdoZXRoZXIgdGhpcyBzZWxlY3Rpb24gaXMgZXhjbHVzaXZlLiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgKi9cbiAgaXNFeGNsdXNpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhjbHVzaXZlO1xuICB9XG4gIC8qKlxuICAgKiBDb250cm9scyB3aGV0aGVyIG9iamVjdHMgdGhhdCBhcmUgYWRkZWQgdG8gdGhpcyBzZWxlY3Rpb24gc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBhbGwgb3RoZXIgbGF5ZXJzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXhjbHVzaXZlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFdoZXRoZXIgdGhpcyBzZWxlY3Rpb24gc2hvdWxkIGJlIGV4Y2x1c2l2ZS5cbiAgICovXG4gIHNldEV4Y2x1c2l2ZSh2YWx1ZSkge1xuICAgIHRoaXMuZXhjbHVzaXZlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGlzIHNlbGVjdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBUaGlzIHNlbGVjdGlvbi5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcjtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiB0aGlzKSB7XG4gICAgICBvYmplY3QubGF5ZXJzLmRpc2FibGUobGF5ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuY2xlYXIoKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHRoaXMgc2VsZWN0aW9uIGFuZCBhZGRzIHRoZSBnaXZlbiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZXJhYmxlPE9iamVjdDNEPn0gb2JqZWN0cyAtIFRoZSBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIHNlbGVjdGVkLlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFRoaXMgc2VsZWN0aW9uLlxuICAgKi9cbiAgc2V0KG9iamVjdHMpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2Ygb2JqZWN0cykge1xuICAgICAgdGhpcy5hZGQob2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFuIGFsaWFzIGZvciB7QGxpbmsgaGFzfS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gQW4gb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgMCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGN1cnJlbnRseSBzZWxlY3RlZCwgb3IgLTEgb3RoZXJ3aXNlLlxuICAgKiBAZGVwcmVjYXRlZCBBZGRlZCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eS5cbiAgICovXG4gIGluZGV4T2Yob2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKG9iamVjdCkgPyAwIDogLTE7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gb2JqZWN0IHRvIHRoaXMgc2VsZWN0aW9uLlxuICAgKlxuICAgKiBJZiB7QGxpbmsgZXhjbHVzaXZlfSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgb2JqZWN0IHdpbGwgYWxzbyBiZSByZW1vdmVkIGZyb20gYWxsIG90aGVyIGxheWVycy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0aGF0IHNob3VsZCBiZSBzZWxlY3RlZC5cbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBUaGlzIHNlbGVjdGlvbi5cbiAgICovXG4gIGFkZChvYmplY3QpIHtcbiAgICBpZiAodGhpcy5leGNsdXNpdmUpIHtcbiAgICAgIG9iamVjdC5sYXllcnMuc2V0KHRoaXMubGF5ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3QubGF5ZXJzLmVuYWJsZSh0aGlzLmxheWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmFkZChvYmplY3QpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIG9iamVjdCBmcm9tIHRoaXMgc2VsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdDNEfSBvYmplY3QgLSBUaGUgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGRlc2VsZWN0ZWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbiBvYmplY3QgaGFzIHN1Y2Nlc3NmdWxseSBiZWVuIHJlbW92ZWQgZnJvbSB0aGlzIHNlbGVjdGlvbjsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgZGVsZXRlKG9iamVjdCkge1xuICAgIGlmICh0aGlzLmhhcyhvYmplY3QpKSB7XG4gICAgICBvYmplY3QubGF5ZXJzLmRpc2FibGUodGhpcy5sYXllcik7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5kZWxldGUob2JqZWN0KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBleGlzdGluZyBvYmplY3QgZnJvbSB0aGUgc2VsZWN0aW9uLiBJZiB0aGUgb2JqZWN0IGRvZXNuJ3QgZXhpc3QgaXQncyBhZGRlZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdDNEfSBvYmplY3QgLSBUaGUgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhZGRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgdG9nZ2xlKG9iamVjdCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHRoaXMuaGFzKG9iamVjdCkpIHtcbiAgICAgIHRoaXMuZGVsZXRlKG9iamVjdCk7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQob2JqZWN0KTtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZpc2liaWxpdHkgb2YgYWxsIHNlbGVjdGVkIG9iamVjdHMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGVuYWJsZXMgb3IgZGlzYWJsZXMgcmVuZGVyIGxheWVyIDAgb2YgYWxsIHNlbGVjdGVkIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSAtIFdoZXRoZXIgdGhlIHNlbGVjdGVkIG9iamVjdHMgc2hvdWxkIGJlIHZpc2libGUuXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gVGhpcyBzZWxlY3Rpb24uXG4gICAqL1xuICBzZXRWaXNpYmxlKHZpc2libGUpIHtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiB0aGlzKSB7XG4gICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICBvYmplY3QubGF5ZXJzLmVuYWJsZSgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdC5sYXllcnMuZGlzYWJsZSgwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL0JsZW5kTW9kZS5qc1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIGFzIEV2ZW50RGlzcGF0Y2hlcjIsIFVuaWZvcm0gYXMgVW5pZm9ybTIgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VudW1zL0JsZW5kRnVuY3Rpb24uanNcbnZhciBCbGVuZEZ1bmN0aW9uID0ge1xuICBTS0lQOiA5LFxuICBTRVQ6IDMwLFxuICBBREQ6IDAsXG4gIEFMUEhBOiAxLFxuICBBVkVSQUdFOiAyLFxuICBDT0xPUjogMyxcbiAgQ09MT1JfQlVSTjogNCxcbiAgQ09MT1JfRE9ER0U6IDUsXG4gIERBUktFTjogNixcbiAgRElGRkVSRU5DRTogNyxcbiAgRElWSURFOiA4LFxuICBEU1Q6IDksXG4gIEVYQ0xVU0lPTjogMTAsXG4gIEhBUkRfTElHSFQ6IDExLFxuICBIQVJEX01JWDogMTIsXG4gIEhVRTogMTMsXG4gIElOVkVSVDogMTQsXG4gIElOVkVSVF9SR0I6IDE1LFxuICBMSUdIVEVOOiAxNixcbiAgTElORUFSX0JVUk46IDE3LFxuICBMSU5FQVJfRE9ER0U6IDE4LFxuICBMSU5FQVJfTElHSFQ6IDE5LFxuICBMVU1JTk9TSVRZOiAyMCxcbiAgTVVMVElQTFk6IDIxLFxuICBORUdBVElPTjogMjIsXG4gIE5PUk1BTDogMjMsXG4gIE9WRVJMQVk6IDI0LFxuICBQSU5fTElHSFQ6IDI1LFxuICBSRUZMRUNUOiAyNixcbiAgU0FUVVJBVElPTjogMjcsXG4gIFNDUkVFTjogMjgsXG4gIFNPRlRfTElHSFQ6IDI5LFxuICBTUkM6IDMwLFxuICBTVUJUUkFDVDogMzEsXG4gIFZJVklEX0xJR0hUOiAzMlxufTtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9hZGQuZnJhZ1xudmFyIGFkZF9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsdmVjNCh4LnJnYit5LnJnYix5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2FscGhhLmZyYWdcbnZhciBhbHBoYV9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgseSx5LmEqb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvYXZlcmFnZS5mcmFnXG52YXIgYXZlcmFnZV9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsdmVjNCgoeC5yZ2IreS5yZ2IpKjAuNSx5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2NvbG9yLmZyYWdcbnZhciBjb2xvcl9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIHhIU0w9UkdCVG9IU0woeC5yZ2IpO3ZlYzMgeUhTTD1SR0JUb0hTTCh5LnJnYik7dmVjMyB6PUhTTFRvUkdCKHZlYzMoeUhTTC54eSx4SFNMLnopKTtyZXR1cm4gbWl4KHgsdmVjNCh6LHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvY29sb3ItYnVybi5mcmFnXG52YXIgY29sb3JfYnVybl9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIGE9eC5yZ2IsYj15LnJnYjt2ZWMzIHo9bWl4KHN0ZXAoMC4wLGIpKigxLjAtbWluKHZlYzMoMS4wKSwoMS4wLWEpL2IpKSx2ZWMzKDEuMCksc3RlcCgxLjAsYSkpO3JldHVybiBtaXgoeCx2ZWM0KHoseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9jb2xvci1kb2RnZS5mcmFnXG52YXIgY29sb3JfZG9kZ2VfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjMyBhPXgucmdiLGI9eS5yZ2I7dmVjMyB6PXN0ZXAoMC4wLGEpKm1peChtaW4odmVjMygxLjApLGEvbWF4KDEuMC1iLDFlLTkpKSx2ZWMzKDEuMCksc3RlcCgxLjAsYikpO3JldHVybiBtaXgoeCx2ZWM0KHoseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9kYXJrZW4uZnJhZ1xudmFyIGRhcmtlbl9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsdmVjNChtaW4oeC5yZ2IseS5yZ2IpLHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvZGlmZmVyZW5jZS5mcmFnXG52YXIgZGlmZmVyZW5jZV9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsdmVjNChhYnMoeC5yZ2IteS5yZ2IpLHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvZGl2aWRlLmZyYWdcbnZhciBkaXZpZGVfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQoeC5yZ2IvbWF4KHkucmdiLDFlLTEyKSx5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2V4Y2x1c2lvbi5mcmFnXG52YXIgZXhjbHVzaW9uX2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCx2ZWM0KCh4LnJnYit5LnJnYi0yLjAqeC5yZ2IqeS5yZ2IpLHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvaGFyZC1saWdodC5mcmFnXG52YXIgaGFyZF9saWdodF9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIGE9bWluKHgucmdiLDEuMCk7dmVjMyBiPW1pbih5LnJnYiwxLjApO3ZlYzMgej1taXgoMi4wKmEqYiwxLjAtMi4wKigxLjAtYSkqKDEuMC1iKSxzdGVwKDAuNSxiKSk7cmV0dXJuIG1peCh4LHZlYzQoeix5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2hhcmQtbWl4LmZyYWdcbnZhciBoYXJkX21peF9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsdmVjNChzdGVwKDEuMCx4LnJnYit5LnJnYikseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9odWUuZnJhZ1xudmFyIGh1ZV9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIHhIU0w9UkdCVG9IU0woeC5yZ2IpO3ZlYzMgeUhTTD1SR0JUb0hTTCh5LnJnYik7dmVjMyB6PUhTTFRvUkdCKHZlYzMoeUhTTC54LHhIU0wueXopKTtyZXR1cm4gbWl4KHgsdmVjNCh6LHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvaW52ZXJ0LmZyYWdcbnZhciBpbnZlcnRfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQoMS4wLXkucmdiLHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvaW52ZXJ0LXJnYi5mcmFnXG52YXIgaW52ZXJ0X3JnYl9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsdmVjNCh5LnJnYiooMS4wLXgucmdiKSx5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2xpZ2h0ZW4uZnJhZ1xudmFyIGxpZ2h0ZW5fZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQobWF4KHgucmdiLHkucmdiKSx5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2xpbmVhci1idXJuLmZyYWdcbnZhciBsaW5lYXJfYnVybl9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsdmVjNChjbGFtcCh5LnJnYit4LnJnYi0xLjAsMC4wLDEuMCkseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9saW5lYXItZG9kZ2UuZnJhZ1xudmFyIGxpbmVhcl9kb2RnZV9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsdmVjNChtaW4oeC5yZ2IreS5yZ2IsMS4wKSx5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2xpbmVhci1saWdodC5mcmFnXG52YXIgbGluZWFyX2xpZ2h0X2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCx2ZWM0KGNsYW1wKDIuMCp5LnJnYit4LnJnYi0xLjAsMC4wLDEuMCkseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9sdW1pbm9zaXR5LmZyYWdcbnZhciBsdW1pbm9zaXR5X2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzMgeEhTTD1SR0JUb0hTTCh4LnJnYik7dmVjMyB5SFNMPVJHQlRvSFNMKHkucmdiKTt2ZWMzIHo9SFNMVG9SR0IodmVjMyh4SFNMLnh5LHlIU0wueikpO3JldHVybiBtaXgoeCx2ZWM0KHoseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9tdWx0aXBseS5mcmFnXG52YXIgbXVsdGlwbHlfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQoeC5yZ2IqeS5yZ2IseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9uZWdhdGlvbi5mcmFnXG52YXIgbmVnYXRpb25fZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQoMS4wLWFicygxLjAteC5yZ2IteS5yZ2IpLHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvbm9ybWFsLmZyYWdcbnZhciBub3JtYWxfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvb3ZlcmxheS5mcmFnXG52YXIgb3ZlcmxheV9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIHo9bWl4KDIuMCp5LnJnYip4LnJnYiwxLjAtMi4wKigxLjAteS5yZ2IpKigxLjAteC5yZ2IpLHN0ZXAoMC41LHgucmdiKSk7cmV0dXJuIG1peCh4LHZlYzQoeix5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL3Bpbi1saWdodC5mcmFnXG52YXIgcGluX2xpZ2h0X2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzMgeTI9Mi4wKnkucmdiO3ZlYzMgej1taXgobWl4KHkyLHgucmdiLHN0ZXAoMC41KngucmdiLHkucmdiKSksbWF4KHkyLTEuMCx2ZWMzKDAuMCkpLHN0ZXAoeC5yZ2IseTItMS4wKSk7cmV0dXJuIG1peCh4LHZlYzQoeix5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL3JlZmxlY3QuZnJhZ1xudmFyIHJlZmxlY3RfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjMyB6PW1peChtaW4oeC5yZ2IqeC5yZ2IvbWF4KDEuMC15LnJnYiwxZS0xMiksMS4wKSx5LnJnYixzdGVwKDEuMCx5LnJnYikpO3JldHVybiBtaXgoeCx2ZWM0KHoseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9zYXR1cmF0aW9uLmZyYWdcbnZhciBzYXR1cmF0aW9uX2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzMgeEhTTD1SR0JUb0hTTCh4LnJnYik7dmVjMyB5SFNMPVJHQlRvSFNMKHkucmdiKTt2ZWMzIHo9SFNMVG9SR0IodmVjMyh4SFNMLngseUhTTC55LHhIU0wueikpO3JldHVybiBtaXgoeCx2ZWM0KHoseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9zY3JlZW4uZnJhZ1xudmFyIHNjcmVlbl9kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsdmVjNCh4LnJnYit5LnJnYi1taW4oeC5yZ2IqeS5yZ2IsMS4wKSx5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL3NvZnQtbGlnaHQuZnJhZ1xudmFyIHNvZnRfbGlnaHRfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjMyBhPXgucmdiO3ZlYzMgYj15LnJnYjt2ZWMzIHkyPTIuMCpiO3ZlYzMgdz1zdGVwKDAuNSxiKTt2ZWMzIGM9YS0oMS4wLXkyKSphKigxLjAtYSk7dmVjMyBkPW1peChhKyh5Mi0xLjApKihzcXJ0KGEpLWEpLGErKHkyLTEuMCkqYSooKDE2LjAqYS0xMi4wKSphKzMuMCksdyooMS4wLXN0ZXAoMC4yNSxhKSkpO3ZlYzMgej1taXgoYyxkLHcpO3JldHVybiBtaXgoeCx2ZWM0KHoseS5hKSxvcGFjaXR5KTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9zcmMuZnJhZ1xudmFyIHNyY19kZWZhdWx0ID0gYHZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4geTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9zdWJ0cmFjdC5mcmFnXG52YXIgc3VidHJhY3RfZGVmYXVsdCA9IGB2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHZlYzQobWF4KHgucmdiK3kucmdiLTEuMCwwLjApLHkuYSksb3BhY2l0eSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvdml2aWQtbGlnaHQuZnJhZ1xudmFyIHZpdmlkX2xpZ2h0X2RlZmF1bHQgPSBgdmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzMgej1taXgobWF4KDEuMC1taW4oKDEuMC14LnJnYikvKDIuMCp5LnJnYiksMS4wKSwwLjApLG1pbih4LnJnYi8oMi4wKigxLjAteS5yZ2IpKSwxLjApLHN0ZXAoMC41LHkucmdiKSk7cmV0dXJuIG1peCh4LHZlYzQoeix5LmEpLG9wYWNpdHkpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9CbGVuZE1vZGUuanNcbnZhciBibGVuZEZ1bmN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW0JsZW5kRnVuY3Rpb24uQURELCBhZGRfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkFMUEhBLCBhbHBoYV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uQVZFUkFHRSwgYXZlcmFnZV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uQ09MT1IsIGNvbG9yX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5DT0xPUl9CVVJOLCBjb2xvcl9idXJuX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5DT0xPUl9ET0RHRSwgY29sb3JfZG9kZ2VfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkRBUktFTiwgZGFya2VuX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5ESUZGRVJFTkNFLCBkaWZmZXJlbmNlX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5ESVZJREUsIGRpdmlkZV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uRFNULCBudWxsXSxcbiAgW0JsZW5kRnVuY3Rpb24uRVhDTFVTSU9OLCBleGNsdXNpb25fZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkhBUkRfTElHSFQsIGhhcmRfbGlnaHRfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkhBUkRfTUlYLCBoYXJkX21peF9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uSFVFLCBodWVfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLklOVkVSVCwgaW52ZXJ0X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5JTlZFUlRfUkdCLCBpbnZlcnRfcmdiX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5MSUdIVEVOLCBsaWdodGVuX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5MSU5FQVJfQlVSTiwgbGluZWFyX2J1cm5fZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkxJTkVBUl9ET0RHRSwgbGluZWFyX2RvZGdlX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5MSU5FQVJfTElHSFQsIGxpbmVhcl9saWdodF9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uTFVNSU5PU0lUWSwgbHVtaW5vc2l0eV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uTVVMVElQTFksIG11bHRpcGx5X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5ORUdBVElPTiwgbmVnYXRpb25fZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLk5PUk1BTCwgbm9ybWFsX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5PVkVSTEFZLCBvdmVybGF5X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5QSU5fTElHSFQsIHBpbl9saWdodF9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uUkVGTEVDVCwgcmVmbGVjdF9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uU0FUVVJBVElPTiwgc2F0dXJhdGlvbl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uU0NSRUVOLCBzY3JlZW5fZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLlNPRlRfTElHSFQsIHNvZnRfbGlnaHRfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLlNSQywgc3JjX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5TVUJUUkFDVCwgc3VidHJhY3RfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLlZJVklEX0xJR0hULCB2aXZpZF9saWdodF9kZWZhdWx0XVxuXSk7XG52YXIgQmxlbmRNb2RlID0gY2xhc3MgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYmxlbmQgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBibGVuZEZ1bmN0aW9uIC0gVGhlIGJsZW5kIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gb3BhY2l0eSAtIFRoZSBvcGFjaXR5IG9mIHRoZSBjb2xvciB0aGF0IHdpbGwgYmUgYmxlbmRlZCB3aXRoIHRoZSBiYXNlIGNvbG9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoYmxlbmRGdW5jdGlvbiwgb3BhY2l0eSA9IDEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2JsZW5kRnVuY3Rpb24gPSBibGVuZEZ1bmN0aW9uO1xuICAgIHRoaXMub3BhY2l0eSA9IG5ldyBVbmlmb3JtMihvcGFjaXR5KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3BhY2l0eS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgb3BhY2l0eS5cbiAgICovXG4gIGdldE9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BhY2l0eS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgb3BhY2l0eS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG9wYWNpdHkuXG4gICAqL1xuICBzZXRPcGFjaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5vcGFjaXR5LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibGVuZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHR5cGUge0JsZW5kRnVuY3Rpb259XG4gICAqL1xuICBnZXQgYmxlbmRGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRGdW5jdGlvbjtcbiAgfVxuICBzZXQgYmxlbmRGdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX2JsZW5kRnVuY3Rpb24gPSB2YWx1ZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBibGVuZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsZW5kRnVuY3Rpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7QmxlbmRGdW5jdGlvbn0gVGhlIGJsZW5kIGZ1bmN0aW9uLlxuICAgKi9cbiAgZ2V0QmxlbmRGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ibGVuZEZ1bmN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibGVuZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsZW5kRnVuY3Rpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSB2YWx1ZSAtIFRoZSBibGVuZCBmdW5jdGlvbi5cbiAgICovXG4gIHNldEJsZW5kRnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLmJsZW5kRnVuY3Rpb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmxlbmQgZnVuY3Rpb24gc2hhZGVyIGNvZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGJsZW5kIGZ1bmN0aW9uIHNoYWRlciBjb2RlLlxuICAgKi9cbiAgZ2V0U2hhZGVyQ29kZSgpIHtcbiAgICByZXR1cm4gYmxlbmRGdW5jdGlvbnMuZ2V0KHRoaXMuYmxlbmRGdW5jdGlvbik7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0FTQ0lJRWZmZWN0LmpzXG5pbXBvcnQgeyBDb2xvciBhcyBDb2xvcjIsIFVuaWZvcm0gYXMgVW5pZm9ybTMsIFZlY3RvcjIgYXMgVmVjdG9yMjMsIFZlY3RvcjQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL3RleHR1cmVzL0FTQ0lJVGV4dHVyZS5qc1xuaW1wb3J0IHsgQ2FudmFzVGV4dHVyZSwgUmVwZWF0V3JhcHBpbmcgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBBU0NJSVRleHR1cmUgPSBjbGFzcyBleHRlbmRzIENhbnZhc1RleHR1cmUge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBBU0NJSSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jaGFyYWN0ZXJzXSAtIFRoZSBjaGFyYWN0ZXIgc2V0IHRvIHJlbmRlci4gRGVmYXVsdHMgdG8gYSBjb21tb24gQVNDSUkgYXJ0IGNoYXJzZXQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5mb250PVwiQXJpYWxcIl0gLSBUaGUgZm9udC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvbnRTaXplPTU0XSAtIFRoZSBmb250IHNpemUgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2l6ZT0xMDI0XSAtIFRoZSB0ZXh0dXJlIHNpemUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jZWxsQ291bnQ9MTZdIC0gVGhlIGNlbGwgY291bnQgYWxvbmcgZWFjaCBzaWRlIG9mIHRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGNoYXJhY3RlcnMgPSBcIiAuOiwnLV49Kis/IXwwI1glV01AXCIsXG4gICAgZm9udCA9IFwiQXJpYWxcIixcbiAgICBmb250U2l6ZSA9IDU0LFxuICAgIHNpemUgPSAxMDI0LFxuICAgIGNlbGxDb3VudCA9IDE2XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFxuICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIFJlcGVhdFdyYXBwaW5nLFxuICAgICAgUmVwZWF0V3JhcHBpbmdcbiAgICApO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuaW1hZ2U7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IHNpemU7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY29uc3QgY2VsbFNpemUgPSBzaXplIC8gY2VsbENvdW50O1xuICAgIGNvbnRleHQuZm9udCA9IGAke2ZvbnRTaXplfXB4ICR7Zm9udH1gO1xuICAgIGNvbnRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNmZmZmZmZcIjtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNoYXJhY3RlcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICBjb25zdCBjaGFyID0gY2hhcmFjdGVyc1tpXTtcbiAgICAgIGNvbnN0IHggPSBpICUgY2VsbENvdW50O1xuICAgICAgY29uc3QgeSA9IE1hdGguZmxvb3IoaSAvIGNlbGxDb3VudCk7XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KGNoYXIsIHggKiBjZWxsU2l6ZSArIGNlbGxTaXplIC8gMiwgeSAqIGNlbGxTaXplICsgY2VsbFNpemUgLyAyKTtcbiAgICB9XG4gICAgdGhpcy5jaGFyYWN0ZXJDb3VudCA9IGNoYXJhY3RlcnMubGVuZ3RoO1xuICAgIHRoaXMuY2VsbENvdW50ID0gY2VsbENvdW50O1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9FZmZlY3QuanNcbmltcG9ydCB7XG4gIEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMixcbiAgRXZlbnREaXNwYXRjaGVyIGFzIEV2ZW50RGlzcGF0Y2hlcjMsXG4gIExpbmVhclNSR0JDb2xvclNwYWNlIGFzIExpbmVhclNSR0JDb2xvclNwYWNlMixcbiAgTWF0ZXJpYWwgYXMgTWF0ZXJpYWwyLFxuICBOb0NvbG9yU3BhY2UsXG4gIFRleHR1cmUgYXMgVGV4dHVyZTIsXG4gIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0NFxufSBmcm9tIFwidGhyZWVcIjtcbnZhciBFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcjMge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhpcyBlZmZlY3QuIERvZXNuJ3QgaGF2ZSB0byBiZSB1bmlxdWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmcmFnbWVudFNoYWRlciAtIFRoZSBmcmFnbWVudCBzaGFkZXIuIFRoaXMgc2hhZGVyIGlzIHJlcXVpcmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0VmZmVjdEF0dHJpYnV0ZX0gW29wdGlvbnMuYXR0cmlidXRlcz1FZmZlY3RBdHRyaWJ1dGUuTk9ORV0gLSBUaGUgZWZmZWN0IGF0dHJpYnV0ZXMgdGhhdCBkZXRlcm1pbmUgdGhlIGV4ZWN1dGlvbiBwcmlvcml0eSBhbmQgcmVzb3VyY2UgcmVxdWlyZW1lbnRzLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5OT1JNQUxdIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge01hcDxTdHJpbmcsIFN0cmluZz59IFtvcHRpb25zLmRlZmluZXNdIC0gQ3VzdG9tIHByZXByb2Nlc3NvciBtYWNybyBkZWZpbml0aW9ucy4gS2V5cyBhcmUgbmFtZXMgYW5kIHZhbHVlcyBhcmUgY29kZS5cbiAgICogQHBhcmFtIHtNYXA8U3RyaW5nLCBVbmlmb3JtPn0gW29wdGlvbnMudW5pZm9ybXNdIC0gQ3VzdG9tIHNoYWRlciB1bmlmb3Jtcy4gS2V5cyBhcmUgbmFtZXMgYW5kIHZhbHVlcyBhcmUgdW5pZm9ybXMuXG4gICAqIEBwYXJhbSB7U2V0PFdlYkdMRXh0ZW5zaW9uPn0gW29wdGlvbnMuZXh0ZW5zaW9uc10gLSBXZWJHTCBleHRlbnNpb25zLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudmVydGV4U2hhZGVyPW51bGxdIC0gVGhlIHZlcnRleCBzaGFkZXIuIE1vc3QgZWZmZWN0cyBkb24ndCBuZWVkIG9uZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG5hbWUsIGZyYWdtZW50U2hhZGVyLCB7XG4gICAgYXR0cmlidXRlcyA9IEVmZmVjdEF0dHJpYnV0ZS5OT05FLFxuICAgIGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLk5PUk1BTCxcbiAgICBkZWZpbmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICB1bmlmb3JtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgZXh0ZW5zaW9ucyA9IG51bGwsXG4gICAgdmVydGV4U2hhZGVyID0gbnVsbFxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXI7XG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XG4gICAgdGhpcy5kZWZpbmVzID0gZGVmaW5lcztcbiAgICB0aGlzLnVuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB0aGlzLmJsZW5kTW9kZSA9IG5ldyBCbGVuZE1vZGUoYmxlbmRGdW5jdGlvbik7XG4gICAgdGhpcy5ibGVuZE1vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQpID0+IHRoaXMuc2V0Q2hhbmdlZCgpKTtcbiAgICB0aGlzLl9pbnB1dENvbG9yU3BhY2UgPSBMaW5lYXJTUkdCQ29sb3JTcGFjZTI7XG4gICAgdGhpcy5fb3V0cHV0Q29sb3JTcGFjZSA9IE5vQ29sb3JTcGFjZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGNvbG9yIHNwYWNlLlxuICAgKlxuICAgKiBAdHlwZSB7Q29sb3JTcGFjZX1cbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgZ2V0IGlucHV0Q29sb3JTcGFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXRDb2xvclNwYWNlO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7Q29sb3JTcGFjZX1cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXQgaW5wdXRDb2xvclNwYWNlKHZhbHVlKSB7XG4gICAgdGhpcy5faW5wdXRDb2xvclNwYWNlID0gdmFsdWU7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvdXRwdXQgY29sb3Igc3BhY2UuXG4gICAqXG4gICAqIFNob3VsZCBvbmx5IGJlIGNoYW5nZWQgaWYgdGhpcyBlZmZlY3QgY29udmVydHMgdGhlIGlucHV0IGNvbG9ycyB0byBhIGRpZmZlcmVudCBjb2xvciBzcGFjZS5cbiAgICpcbiAgICogQHR5cGUge0NvbG9yU3BhY2V9XG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIGdldCBvdXRwdXRDb2xvclNwYWNlKCkge1xuICAgIHJldHVybiB0aGlzLl9vdXRwdXRDb2xvclNwYWNlO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7Q29sb3JTcGFjZX1cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXQgb3V0cHV0Q29sb3JTcGFjZSh2YWx1ZSkge1xuICAgIHRoaXMuX291dHB1dENvbG9yU3BhY2UgPSB2YWx1ZTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWFpbiBzY2VuZS5cbiAgICpcbiAgICogQHR5cGUge1NjZW5lfVxuICAgKi9cbiAgc2V0IG1haW5TY2VuZSh2YWx1ZSkge1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYWluIGNhbWVyYS5cbiAgICpcbiAgICogQHR5cGUge0NhbWVyYX1cbiAgICovXG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBuYW1lIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5hbWUuXG4gICAqL1xuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKi9cbiAgc2V0UmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZXByb2Nlc3NvciBtYWNybyBkZWZpbml0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlZmluZXMgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TWFwPFN0cmluZywgU3RyaW5nPn0gVGhlIGV4dGVuc2lvbnMuXG4gICAqL1xuICBnZXREZWZpbmVzKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuaWZvcm1zIG9mIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdW5pZm9ybXMgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TWFwPFN0cmluZywgVW5pZm9ybT59IFRoZSBleHRlbnNpb25zLlxuICAgKi9cbiAgZ2V0VW5pZm9ybXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFdlYkdMIGV4dGVuc2lvbnMgdGhhdCBhcmUgcmVxdWlyZWQgYnkgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBleHRlbnNpb25zIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1NldDxXZWJHTEV4dGVuc2lvbj59IFRoZSBleHRlbnNpb25zLlxuICAgKi9cbiAgZ2V0RXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBibGVuZCBtb2RlLlxuICAgKlxuICAgKiBUaGUgcmVzdWx0IG9mIHRoaXMgZWZmZWN0IHdpbGwgYmUgYmxlbmRlZCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIGVmZmVjdCB1c2luZyB0aGlzIGJsZW5kIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibGVuZE1vZGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7QmxlbmRNb2RlfSBUaGUgYmxlbmQgbW9kZS5cbiAgICovXG4gIGdldEJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibGVuZE1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVmZmVjdCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFZmZlY3RBdHRyaWJ1dGV9IFRoZSBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgZ2V0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBlZmZlY3QgYXR0cmlidXRlcy5cbiAgICpcbiAgICogRWZmZWN0cyB0aGF0IGhhdmUgdGhlIHNhbWUgYXR0cmlidXRlcyB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgcmVnaXN0ZXJlZC4gU29tZSBhdHRyaWJ1dGVzXG4gICAqIGltcGx5IGEgaGlnaGVyIHByaW9yaXR5LlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7RWZmZWN0QXR0cmlidXRlfSBhdHRyaWJ1dGVzIC0gVGhlIGF0dHJpYnV0ZXMuXG4gICAqL1xuICBzZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICovXG4gIGdldEZyYWdtZW50U2hhZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50U2hhZGVyO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZyYWdtZW50U2hhZGVyIC0gVGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICovXG4gIHNldEZyYWdtZW50U2hhZGVyKGZyYWdtZW50U2hhZGVyKSB7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgKi9cbiAgZ2V0VmVydGV4U2hhZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnRleFNoYWRlcjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdmVydGV4IHNoYWRlci5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmVydGV4U2hhZGVyIC0gVGhlIHZlcnRleCBzaGFkZXIuXG4gICAqL1xuICBzZXRWZXJ0ZXhTaGFkZXIodmVydGV4U2hhZGVyKSB7XG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluZm9ybXMgdGhlIGFzc29jaWF0ZWQge0BsaW5rIEVmZmVjdFBhc3N9IHRoYXQgdGhpcyBlZmZlY3QgcmVxdWlyZXMgYSBzaGFkZXIgcmVjb21waWxhdGlvbi5cbiAgICpcbiAgICogU2hvdWxkIGJlIGNhbGxlZCBhZnRlciBjaGFuZ2luZyBtYWNyb3Mgb3IgZXh0ZW5zaW9ucyBhbmQgYWZ0ZXIgYWRkaW5nL3JlbW92aW5nIHVuaWZvcm1zLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzZXRDaGFuZ2VkKCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY2hhbmdlXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgeW91ciBlZmZlY3QgcmVxdWlyZXMgZGlyZWN0IGFjY2VzcyB0byB0aGUgZGVwdGggdGV4dHVyZSB0aGF0IGlzIGJvdW5kIHRvIHRoZVxuICAgKiBhc3NvY2lhdGVkIHtAbGluayBFZmZlY3RQYXNzfS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMikge1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0IGJ5IHBlcmZvcm1pbmcgc3VwcG9ydGluZyBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIHtAbGluayBFZmZlY3RQYXNzfSByaWdodCBiZWZvcmUgdGhlIG1haW4gZnVsbHNjcmVlbiByZW5kZXIgb3BlcmF0aW9uLCBldmVuIGlmIHRoZVxuICAgKiBibGVuZCBmdW5jdGlvbiBpcyBzZXQgdG8gYFNLSVBgLlxuICAgKlxuICAgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdSBuZWVkIHRvIHVwZGF0ZSBjdXN0b20gdW5pZm9ybXMgb3IgcmVuZGVyIGFkZGl0aW9uYWwgb2ZmLXNjcmVlbiB0ZXh0dXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgeW91IHdhbnQgdG8gYmUgaW5mb3JtZWQgYWJvdXQgdGhlIHNpemUgb2YgdGhlIGJhY2tidWZmZXIvY2FudmFzLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYmVmb3JlIHtAbGluayBpbml0aWFsaXplfSBhbmQgZXZlcnkgdGltZSB0aGUgc2l6ZSBvZiB0aGUge0BsaW5rIEVmZmVjdENvbXBvc2VyfSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgRWZmZWN0UGFzc30gaXMgYWRkZWQgdG8gYW4ge0BsaW5rIEVmZmVjdENvbXBvc2VyfS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICogQGV4YW1wbGUgaWYoIWFscGhhICYmIGZyYW1lQnVmZmVyVHlwZSA9PT0gVW5zaWduZWRCeXRlVHlwZSkgeyB0aGlzLm15UmVuZGVyVGFyZ2V0LnRleHR1cmUuZm9ybWF0ID0gUkdCRm9ybWF0OyB9XG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgc2hhbGxvdyBzZWFyY2ggZm9yIHByb3BlcnRpZXMgdGhhdCBkZWZpbmUgYSBkaXNwb3NlIG1ldGhvZCBhbmQgZGVsZXRlcyB0aGVtLlxuICAgKlxuICAgKiBUaGUge0BsaW5rIEVmZmVjdENvbXBvc2VyfSBjYWxscyB0aGlzIG1ldGhvZCB3aGVuIGl0IGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcykpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpc1trZXldO1xuICAgICAgY29uc3QgaXNEaXNwb3NhYmxlID0gcHJvcGVydHkgaW5zdGFuY2VvZiBXZWJHTFJlbmRlclRhcmdldDQgfHwgcHJvcGVydHkgaW5zdGFuY2VvZiBNYXRlcmlhbDIgfHwgcHJvcGVydHkgaW5zdGFuY2VvZiBUZXh0dXJlMiB8fCBwcm9wZXJ0eSBpbnN0YW5jZW9mIFBhc3M7XG4gICAgICBpZiAoaXNEaXNwb3NhYmxlKSB7XG4gICAgICAgIHRoaXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2FzY2lpLmZyYWdcbnZhciBhc2NpaV9kZWZhdWx0ID0gYHVuaWZvcm0gc2FtcGxlcjJEIGFzY2lpVGV4dHVyZTt1bmlmb3JtIHZlYzQgY2VsbENvdW50O1xuI2lmZGVmIFVTRV9DT0xPUlxudW5pZm9ybSB2ZWMzIGNvbG9yO1xuI2VuZGlmXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMiBwaXhlbGl6ZWRVdj1jZWxsQ291bnQuencqKDAuNStmbG9vcih1dipjZWxsQ291bnQueHkpKTt2ZWM0IHRleGVsPXRleHR1cmUoaW5wdXRCdWZmZXIscGl4ZWxpemVkVXYpO2Zsb2F0IGx1bT1taW4obHVtaW5hbmNlKHRleGVsLnJnYiksMS4wKTtcbiNpZmRlZiBJTlZFUlRFRFxubHVtPTEuMC1sdW07XG4jZW5kaWZcbmZsb2F0IGNoYXJhY3RlckluZGV4PWZsb29yKENIQVJfQ09VTlRfTUlOVVNfT05FKmx1bSk7dmVjMiBjaGFyYWN0ZXJQb3NpdGlvbj12ZWMyKG1vZChjaGFyYWN0ZXJJbmRleCxURVhfQ0VMTF9DT1VOVCksZmxvb3IoY2hhcmFjdGVySW5kZXgqSU5WX1RFWF9DRUxMX0NPVU5UKSk7dmVjMiBvZmZzZXQ9dmVjMihjaGFyYWN0ZXJQb3NpdGlvbi54LC1jaGFyYWN0ZXJQb3NpdGlvbi55KSpJTlZfVEVYX0NFTExfQ09VTlQ7dmVjMiBjaGFyYWN0ZXJVdj1tb2QodXYqKGNlbGxDb3VudC54eSpJTlZfVEVYX0NFTExfQ09VTlQpLElOVl9URVhfQ0VMTF9DT1VOVCk7Y2hhcmFjdGVyVXY9Y2hhcmFjdGVyVXYtdmVjMigwLjAsSU5WX1RFWF9DRUxMX0NPVU5UKStvZmZzZXQ7ZmxvYXQgYXNjaWlDaGFyYWN0ZXI9dGV4dHVyZShhc2NpaVRleHR1cmUsY2hhcmFjdGVyVXYpLnI7XG4jaWZkZWYgVVNFX0NPTE9SXG5vdXRwdXRDb2xvcj12ZWM0KGNvbG9yKmFzY2lpQ2hhcmFjdGVyLGlucHV0Q29sb3IuYSk7XG4jZWxzZVxub3V0cHV0Q29sb3I9dmVjNCh0ZXhlbC5yZ2IqYXNjaWlDaGFyYWN0ZXIsaW5wdXRDb2xvci5hKTtcbiNlbmRpZlxufWA7XG5cbi8vIHNyYy9lZmZlY3RzL0FTQ0lJRWZmZWN0LmpzXG52YXIgQVNDSUlFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEFTQ0lJIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0FTQ0lJVGV4dHVyZX0gW29wdGlvbnMuYXNjaWlUZXh0dXJlXSAtIEFuIEFTQ0lJIGNoYXJhY3RlciBsb29rdXAgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNlbGxTaXplPTE2XSAtIFRoZSBjZWxsIHNpemUuIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIGV2ZW4gbnVtYmVycy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbG9yPW51bGxdIC0gQSBjb2xvciB0byB1c2UgaW5zdGVhZCBvZiB0aGUgc2NlbmUgY29sb3JzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmludmVydGVkPWZhbHNlXSAtIEludmVydHMgdGhlIGVmZmVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBhc2NpaVRleHR1cmUgPSBuZXcgQVNDSUlUZXh0dXJlKCksXG4gICAgY2VsbFNpemUgPSAxNixcbiAgICBjb2xvcjogY29sb3IyID0gbnVsbCxcbiAgICBpbnZlcnRlZCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiQVNDSUlFZmZlY3RcIiwgYXNjaWlfZGVmYXVsdCwge1xuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiYXNjaWlUZXh0dXJlXCIsIG5ldyBVbmlmb3JtMyhudWxsKV0sXG4gICAgICAgIFtcImNlbGxDb3VudFwiLCBuZXcgVW5pZm9ybTMobmV3IFZlY3RvcjQoKSldLFxuICAgICAgICBbXCJjb2xvclwiLCBuZXcgVW5pZm9ybTMobmV3IENvbG9yMigpKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5fY2VsbFNpemUgPSAtMTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBuZXcgVmVjdG9yMjMoKTtcbiAgICB0aGlzLmFzY2lpVGV4dHVyZSA9IGFzY2lpVGV4dHVyZTtcbiAgICB0aGlzLmNlbGxTaXplID0gY2VsbFNpemU7XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yMjtcbiAgICB0aGlzLmludmVydGVkID0gaW52ZXJ0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IEFTQ0lJIGxvb2t1cCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7QVNDSUlUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IGFzY2lpVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJhc2NpaVRleHR1cmVcIikudmFsdWU7XG4gIH1cbiAgc2V0IGFzY2lpVGV4dHVyZSh2YWx1ZSkge1xuICAgIGNvbnN0IGN1cnJlbnRUZXh0dXJlID0gdGhpcy51bmlmb3Jtcy5nZXQoXCJhc2NpaVRleHR1cmVcIikudmFsdWU7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJhc2NpaVRleHR1cmVcIikudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAoY3VycmVudFRleHR1cmUgIT09IG51bGwgJiYgY3VycmVudFRleHR1cmUgIT09IHZhbHVlKSB7XG4gICAgICBjdXJyZW50VGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY2VsbENvdW50ID0gdmFsdWUuY2VsbENvdW50O1xuICAgICAgdGhpcy5kZWZpbmVzLnNldChcIkNIQVJfQ09VTlRfTUlOVVNfT05FXCIsICh2YWx1ZS5jaGFyYWN0ZXJDb3VudCAtIDEpLnRvRml4ZWQoMSkpO1xuICAgICAgdGhpcy5kZWZpbmVzLnNldChcIlRFWF9DRUxMX0NPVU5UXCIsIGNlbGxDb3VudC50b0ZpeGVkKDEpKTtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJJTlZfVEVYX0NFTExfQ09VTlRcIiwgKDEgLyBjZWxsQ291bnQpLnRvRml4ZWQoOSkpO1xuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBIGNvbG9yIHRoYXQgb3ZlcnJpZGVzIHRoZSBzY2VuZSBjb2xvcnMuXG4gICAqXG4gICAqIEB0eXBlIHtDb2xvciB8IFN0cmluZyB8IE51bWJlciB8IG51bGx9XG4gICAqL1xuICBnZXQgY29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiY29sb3JcIikudmFsdWU7XG4gIH1cbiAgc2V0IGNvbG9yKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmdldChcImNvbG9yXCIpLnZhbHVlLnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlZmluZXMuaGFzKFwiVVNFX0NPTE9SXCIpICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiVVNFX0NPTE9SXCIpO1xuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5kZWZpbmVzLmhhcyhcIlVTRV9DT0xPUlwiKSAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLnNldChcIlVTRV9DT0xPUlwiLCBcIjFcIik7XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoZXRoZXIgdGhlIGVmZmVjdCBzaG91bGQgYmUgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGludmVydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiSU5WRVJURURcIik7XG4gIH1cbiAgc2V0IGludmVydGVkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52ZXJ0ZWQgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIklOVkVSVEVEXCIsIFwiMVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJJTlZFUlRFRFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhlIGNlbGwgc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjZWxsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2VsbFNpemU7XG4gIH1cbiAgc2V0IGNlbGxTaXplKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2NlbGxTaXplICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fY2VsbFNpemUgPSB2YWx1ZTtcbiAgICAgIHRoaXMudXBkYXRlQ2VsbENvdW50KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjZWxsIGNvdW50IHVuaWZvcm0uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVDZWxsQ291bnQoKSB7XG4gICAgY29uc3QgY2VsbENvdW50ID0gdGhpcy51bmlmb3Jtcy5nZXQoXCJjZWxsQ291bnRcIikudmFsdWU7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICBjZWxsQ291bnQueCA9IHJlc29sdXRpb24ud2lkdGggLyB0aGlzLmNlbGxTaXplO1xuICAgIGNlbGxDb3VudC55ID0gcmVzb2x1dGlvbi5oZWlnaHQgLyB0aGlzLmNlbGxTaXplO1xuICAgIGNlbGxDb3VudC56ID0gMSAvIGNlbGxDb3VudC54O1xuICAgIGNlbGxDb3VudC53ID0gMSAvIGNlbGxDb3VudC55O1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy51cGRhdGVDZWxsQ291bnQoKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cyBhbmQgdGV4dHVyZXMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLmFzY2lpVGV4dHVyZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hc2NpaVRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0Jsb29tRWZmZWN0LmpzXG5pbXBvcnQgeyBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTUsIFVuaWZvcm0gYXMgVW5pZm9ybTgsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0OCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZW51bXMvS2VybmVsU2l6ZS5qc1xudmFyIEtlcm5lbFNpemUgPSB7XG4gIFZFUllfU01BTEw6IDAsXG4gIFNNQUxMOiAxLFxuICBNRURJVU06IDIsXG4gIExBUkdFOiAzLFxuICBWRVJZX0xBUkdFOiA0LFxuICBIVUdFOiA1XG59O1xuXG4vLyBzcmMvcGFzc2VzL0thd2FzZUJsdXJQYXNzLmpzXG5pbXBvcnQgeyBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTMsIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTMsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0NSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0thd2FzZUJsdXJNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMiwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwzLCBVbmlmb3JtIGFzIFVuaWZvcm00LCBWZWN0b3I0IGFzIFZlY3RvcjQyIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5rYXdhc2UuZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2thd2FzZV9kZWZhdWx0ID0gYCNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2VuZGlmXG52YXJ5aW5nIHZlYzIgdlV2MDt2YXJ5aW5nIHZlYzIgdlV2MTt2YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdlV2Mzt2b2lkIG1haW4oKXt2ZWM0IHN1bT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MCk7c3VtKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MSk7c3VtKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2Mik7c3VtKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2Myk7Z2xfRnJhZ0NvbG9yPXN1bSowLjI1O1xuI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XG59YDtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLmthd2FzZS52ZXJ0XG52YXIgY29udm9sdXRpb25fa2F3YXNlX2RlZmF1bHQyID0gYHVuaWZvcm0gdmVjNCB0ZXhlbFNpemU7dW5pZm9ybSBmbG9hdCBrZXJuZWw7dW5pZm9ybSBmbG9hdCBzY2FsZTt2YXJ5aW5nIHZlYzIgdlV2MDt2YXJ5aW5nIHZlYzIgdlV2MTt2YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdlV2Mzt2b2lkIG1haW4oKXt2ZWMyIHV2PXBvc2l0aW9uLnh5KjAuNSswLjU7dmVjMiBkVXY9KHRleGVsU2l6ZS54eSp2ZWMyKGtlcm5lbCkrdGV4ZWxTaXplLnp3KSpzY2FsZTt2VXYwPXZlYzIodXYueC1kVXYueCx1di55K2RVdi55KTt2VXYxPXZlYzIodXYueCtkVXYueCx1di55K2RVdi55KTt2VXYyPXZlYzIodXYueCtkVXYueCx1di55LWRVdi55KTt2VXYzPXZlYzIodXYueC1kVXYueCx1di55LWRVdi55KTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0thd2FzZUJsdXJNYXRlcmlhbC5qc1xudmFyIGtlcm5lbFByZXNldHMgPSBbXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDBdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMV0pLFxuICBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAxLCAyXSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDIsIDIsIDNdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMiwgMywgNCwgNCwgNV0pLFxuICBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAyLCAzLCA0LCA1LCA3LCA4LCA5LCAxMF0pXG5dO1xudmFyIEthd2FzZUJsdXJNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgY29udm9sdXRpb24gbWF0ZXJpYWwuXG4gICAqXG4gICAqIFRPRE8gUmVtb3ZlIHRleGVsU2l6ZSBwYXJhbS5cbiAgICogQHBhcmFtIHtWZWN0b3I0fSBbdGV4ZWxTaXplXSAtIERlcHJlY2F0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXhlbFNpemUgPSBuZXcgVmVjdG9yNDIoKSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiS2F3YXNlQmx1ck1hdGVyaWFsXCIsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm00KG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtNChuZXcgVmVjdG9yNDIoKSksXG4gICAgICAgIHNjYWxlOiBuZXcgVW5pZm9ybTQoMSksXG4gICAgICAgIGtlcm5lbDogbmV3IFVuaWZvcm00KDApXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcyLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fa2F3YXNlX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbnZvbHV0aW9uX2thd2FzZV9kZWZhdWx0MlxuICAgIH0pO1xuICAgIHRoaXMuc2V0VGV4ZWxTaXplKHRleGVsU2l6ZS54LCB0ZXhlbFNpemUueSk7XG4gICAgdGhpcy5rZXJuZWxTaXplID0gS2VybmVsU2l6ZS5NRURJVU07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGlucHV0IGJ1ZmZlci5cbiAgICovXG4gIHNldElucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy5pbnB1dEJ1ZmZlciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUga2VybmVsIHNlcXVlbmNlIGZvciB0aGUgY3VycmVudCBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge0Zsb2F0MzJBcnJheX1cbiAgICovXG4gIGdldCBrZXJuZWxTZXF1ZW5jZSgpIHtcbiAgICByZXR1cm4ga2VybmVsUHJlc2V0c1t0aGlzLmtlcm5lbFNpemVdO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZTtcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzY2FsZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzY2FsZS5cbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzY2FsZS5cbiAgICovXG4gIHNldFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXJuZWwuXG4gICAqXG4gICAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gVGhlIGtlcm5lbC5cbiAgICogQGRlcHJlY2F0ZWQgSW1wbGVtZW50YXRpb24gZGV0YWlsLCByZW1vdmVkIHdpdGggbm8gcmVwbGFjZW1lbnQuXG4gICAqL1xuICBnZXRLZXJuZWwoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGtlcm5lbC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBrZXJuZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMua2VybmVsLnZhbHVlO1xuICB9XG4gIHNldCBrZXJuZWwodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmtlcm5lbC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IGtlcm5lbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGtlcm5lbCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUga2VybmVsLlxuICAgKi9cbiAgc2V0S2VybmVsKHZhbHVlKSB7XG4gICAgdGhpcy5rZXJuZWwgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNpemUoKSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxuICAgKi9cbiAgc2V0VGV4ZWxTaXplKHgsIHkpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSwgeCAqIDAuNSwgeSAqIDAuNSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB4ID0gMSAvIHdpZHRoLCB5ID0gMSAvIGhlaWdodDtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSwgeCAqIDAuNSwgeSAqIDAuNSk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvS2F3YXNlQmx1clBhc3MuanNcbnZhciBLYXdhc2VCbHVyUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEthd2FzZSBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtLZXJuZWxTaXplfSBbb3B0aW9ucy5rZXJuZWxTaXplPUtlcm5lbFNpemUuTUVESVVNXSAtIFRoZSBibHVyIGtlcm5lbCBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTAuNV0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWSBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGtlcm5lbFNpemUgPSBLZXJuZWxTaXplLk1FRElVTSxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAwLjUsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiS2F3YXNlQmx1clBhc3NcIik7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0NSgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5uYW1lID0gXCJCbHVyLlRhcmdldC5BXCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCID0gdGhpcy5yZW5kZXJUYXJnZXRBLmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUubmFtZSA9IFwiQmx1ci5UYXJnZXQuQlwiO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICAgIHRoaXMuX2JsdXJNYXRlcmlhbCA9IG5ldyBLYXdhc2VCbHVyTWF0ZXJpYWwoKTtcbiAgICB0aGlzLl9ibHVyTWF0ZXJpYWwua2VybmVsU2l6ZSA9IGtlcm5lbFNpemU7XG4gICAgdGhpcy5jb3B5TWF0ZXJpYWwgPSBuZXcgQ29weU1hdGVyaWFsKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24gc2V0dGluZ3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1Jlc29sdXRpb259IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge0thd2FzZUJsdXJNYXRlcmlhbH1cbiAgICovXG4gIGdldCBibHVyTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsdXJNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtLYXdhc2VCbHVyTWF0ZXJpYWx9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHNldCBibHVyTWF0ZXJpYWwodmFsdWUpIHtcbiAgICB0aGlzLl9ibHVyTWF0ZXJpYWwgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGl0aGVyaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29weU1hdGVyaWFsLmRpdGhlcmluZyBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGRpdGhlcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb3B5TWF0ZXJpYWwuZGl0aGVyaW5nO1xuICB9XG4gIHNldCBkaXRoZXJpbmcodmFsdWUpIHtcbiAgICB0aGlzLmNvcHlNYXRlcmlhbC5kaXRoZXJpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGtlcm5lbCBzaXplLlxuICAgKlxuICAgKiBAdHlwZSB7S2VybmVsU2l6ZX1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJNYXRlcmlhbC5rZXJuZWxTaXplIGluc3RlYWQuXG4gICAqL1xuICBnZXQga2VybmVsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyTWF0ZXJpYWwua2VybmVsU2l6ZTtcbiAgfVxuICBzZXQga2VybmVsU2l6ZSh2YWx1ZSkge1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsLmtlcm5lbFNpemUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi53aWR0aCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24ud2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlbmRlciB3aWR0aC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24ucHJlZmVycmVkV2lkdGggaW5zdGVhZC5cbiAgICovXG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi5oZWlnaHQgaW5zdGVhZC5cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlbmRlciBoZWlnaHQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uLnByZWZlcnJlZEhlaWdodCBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJNYXRlcmlhbC5zY2FsZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJNYXRlcmlhbC5zY2FsZTtcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5zY2FsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyTWF0ZXJpYWwuc2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2NhbGUuXG4gICAqL1xuICBnZXRTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyTWF0ZXJpYWwuc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyTWF0ZXJpYWwuc2NhbGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNjYWxlLlxuICAgKi9cbiAgc2V0U2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5zY2FsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJNYXRlcmlhbC5rZXJuZWxTaXplIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0tlcm5lbFNpemV9IFRoZSBrZXJuZWwgc2l6ZS5cbiAgICovXG4gIGdldEtlcm5lbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMua2VybmVsU2l6ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUga2VybmVsIHNpemUuXG4gICAqXG4gICAqIExhcmdlciBrZXJuZWxzIHJlcXVpcmUgbW9yZSBwcm9jZXNzaW5nIHBvd2VyIGJ1dCBzY2FsZSB3ZWxsIHdpdGggbGFyZ2VyIHJlbmRlciByZXNvbHV0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJNYXRlcmlhbC5rZXJuZWxTaXplIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7S2VybmVsU2l6ZX0gdmFsdWUgLSBUaGUga2VybmVsIHNpemUuXG4gICAqL1xuICBzZXRLZXJuZWxTaXplKHZhbHVlKSB7XG4gICAgdGhpcy5rZXJuZWxTaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICovXG4gIGdldFJlc29sdXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgbmV3IHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2NhbGUgPSBzY2FsZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYmx1ci5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldEEgPSB0aGlzLnJlbmRlclRhcmdldEE7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0QiA9IHRoaXMucmVuZGVyVGFyZ2V0QjtcbiAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuYmx1ck1hdGVyaWFsO1xuICAgIGNvbnN0IGtlcm5lbFNlcXVlbmNlID0gbWF0ZXJpYWwua2VybmVsU2VxdWVuY2U7XG4gICAgbGV0IHByZXZpb3VzQnVmZmVyID0gaW5wdXRCdWZmZXI7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtlcm5lbFNlcXVlbmNlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgY29uc3QgYnVmZmVyID0gKGkgJiAxKSA9PT0gMCA/IHJlbmRlclRhcmdldEEgOiByZW5kZXJUYXJnZXRCO1xuICAgICAgbWF0ZXJpYWwua2VybmVsID0ga2VybmVsU2VxdWVuY2VbaV07XG4gICAgICBtYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHByZXZpb3VzQnVmZmVyLnRleHR1cmU7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoYnVmZmVyKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIHByZXZpb3VzQnVmZmVyID0gYnVmZmVyO1xuICAgIH1cbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IHRoaXMuY29weU1hdGVyaWFsO1xuICAgIHRoaXMuY29weU1hdGVyaWFsLmlucHV0QnVmZmVyID0gcHJldmlvdXNCdWZmZXIudGV4dHVyZTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiBvdXRwdXRCdWZmZXIpO1xuICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0QS50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTMpIHtcbiAgICAgICAgdGhpcy5ibHVyTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgICAgICB0aGlzLmNvcHlNYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlbmRlcmVyICE9PSBudWxsICYmIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlMykge1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UzO1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQW4gYXV0byBzaXppbmcgZmxhZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBSZXNvbHV0aW9uLkFVVE9fU0laRX0gaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBnZXQgQVVUT19TSVpFKCkge1xuICAgIHJldHVybiBSZXNvbHV0aW9uLkFVVE9fU0laRTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9MdW1pbmFuY2VQYXNzLmpzXG5pbXBvcnQgeyBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGU0LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDYgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9MdW1pbmFuY2VNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMywgUkVWSVNJT04sIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsNCwgVW5pZm9ybSBhcyBVbmlmb3JtNSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvbHVtaW5hbmNlLmZyYWdcbnZhciBsdW1pbmFuY2VfZGVmYXVsdCA9IGAjaW5jbHVkZSA8Y29tbW9uPlxuI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZW5kaWZcbiNpZmRlZiBSQU5HRVxudW5pZm9ybSB2ZWMyIHJhbmdlO1xuI2VsaWYgZGVmaW5lZChUSFJFU0hPTEQpXG51bmlmb3JtIGZsb2F0IHRocmVzaG9sZDt1bmlmb3JtIGZsb2F0IHNtb290aGluZztcbiNlbmRpZlxudmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXt2ZWM0IHRleGVsPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpO2Zsb2F0IGw9bHVtaW5hbmNlKHRleGVsLnJnYik7XG4jaWZkZWYgUkFOR0VcbmZsb2F0IGxvdz1zdGVwKHJhbmdlLngsbCk7ZmxvYXQgaGlnaD1zdGVwKGwscmFuZ2UueSk7bCo9bG93KmhpZ2g7XG4jZWxpZiBkZWZpbmVkKFRIUkVTSE9MRClcbmw9c21vb3Roc3RlcCh0aHJlc2hvbGQsdGhyZXNob2xkK3Ntb290aGluZyxsKSpsO1xuI2VuZGlmXG4jaWZkZWYgQ09MT1JcbmdsX0ZyYWdDb2xvcj12ZWM0KHRleGVsLnJnYipjbGFtcChsLDAuMCwxLjApLGwpO1xuI2Vsc2VcbmdsX0ZyYWdDb2xvcj12ZWM0KGwpO1xuI2VuZGlmXG59YDtcblxuLy8gc3JjL21hdGVyaWFscy9MdW1pbmFuY2VNYXRlcmlhbC5qc1xudmFyIEx1bWluYW5jZU1hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDQge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBsdW1pbmFuY2UgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbG9yT3V0cHV0PWZhbHNlXSAtIERlZmluZXMgd2hldGhlciB0aGUgc2hhZGVyIHNob3VsZCBvdXRwdXQgY29sb3JzIHNjYWxlZCB3aXRoIHRoZWlyIGx1bWluYW5jZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbbHVtaW5hbmNlUmFuZ2VdIC0gSWYgcHJvdmlkZWQsIHRoZSBzaGFkZXIgd2lsbCBtYXNrIG91dCB0ZXhlbHMgdGhhdCBhcmVuJ3QgaW4gdGhlIHNwZWNpZmllZCBsdW1pbmFuY2UgcmFuZ2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2xvck91dHB1dCA9IGZhbHNlLCBsdW1pbmFuY2VSYW5nZSA9IG51bGwpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkx1bWluYW5jZU1hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIFRIUkVFX1JFVklTSU9OOiBSRVZJU0lPTi5yZXBsYWNlKC9cXEQrL2csIFwiXCIpXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtNShudWxsKSxcbiAgICAgICAgdGhyZXNob2xkOiBuZXcgVW5pZm9ybTUoMCksXG4gICAgICAgIHNtb290aGluZzogbmV3IFVuaWZvcm01KDEpLFxuICAgICAgICByYW5nZTogbmV3IFVuaWZvcm01KG51bGwpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmczLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogbHVtaW5hbmNlX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbW1vbl9kZWZhdWx0XG4gICAgfSk7XG4gICAgdGhpcy5jb2xvck91dHB1dCA9IGNvbG9yT3V0cHV0O1xuICAgIHRoaXMubHVtaW5hbmNlUmFuZ2UgPSBsdW1pbmFuY2VSYW5nZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKi9cbiAgc2V0SW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsdW1pbmFuY2UgdGhyZXNob2xkLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy50aHJlc2hvbGQudmFsdWU7XG4gIH1cbiAgc2V0IHRocmVzaG9sZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnNtb290aGluZyA+IDAgfHwgdmFsdWUgPiAwKSB7XG4gICAgICB0aGlzLmRlZmluZXMuVEhSRVNIT0xEID0gXCIxXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuVEhSRVNIT0xEO1xuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLnRocmVzaG9sZC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgdGhyZXNob2xkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhyZXNob2xkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHRocmVzaG9sZC5cbiAgICovXG4gIGdldFRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy50aHJlc2hvbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGx1bWluYW5jZSB0aHJlc2hvbGQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aHJlc2hvbGQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHRocmVzaG9sZC5cbiAgICovXG4gIHNldFRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMudGhyZXNob2xkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsdW1pbmFuY2UgdGhyZXNob2xkIHNtb290aGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzbW9vdGhpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc21vb3RoaW5nLnZhbHVlO1xuICB9XG4gIHNldCBzbW9vdGhpbmcodmFsdWUpIHtcbiAgICBpZiAodGhpcy50aHJlc2hvbGQgPiAwIHx8IHZhbHVlID4gMCkge1xuICAgICAgdGhpcy5kZWZpbmVzLlRIUkVTSE9MRCA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlRIUkVTSE9MRDtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5zbW9vdGhpbmcudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbHVtaW5hbmNlIHRocmVzaG9sZCBzbW9vdGhpbmcgZmFjdG9yLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc21vb3RoaW5nIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNtb290aGluZyBmYWN0b3IuXG4gICAqL1xuICBnZXRTbW9vdGhpbmdGYWN0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuc21vb3RoaW5nO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsdW1pbmFuY2UgdGhyZXNob2xkIHNtb290aGluZyBmYWN0b3IuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzbW9vdGhpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNtb290aGluZyBmYWN0b3IuXG4gICAqL1xuICBzZXRTbW9vdGhpbmdGYWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLnNtb290aGluZyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbHVtaW5hbmNlIHRocmVzaG9sZCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgQWRqdXN0IHRoZSB0aHJlc2hvbGQgb3Igc21vb3RoaW5nIGZhY3RvciBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHVzZVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gdGhpcy50aHJlc2hvbGQgPiAwIHx8IHRoaXMuc21vb3RoaW5nID4gMDtcbiAgfVxuICBzZXQgdXNlVGhyZXNob2xkKHZhbHVlKSB7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGNvbG9yIG91dHB1dCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBjb2xvck91dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLkNPTE9SICE9PSB2b2lkIDA7XG4gIH1cbiAgc2V0IGNvbG9yT3V0cHV0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmRlZmluZXMuQ09MT1IgPSBcIjFcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5DT0xPUjtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGNvbG9yIG91dHB1dCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29sb3JPdXRwdXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBjb2xvciBvdXRwdXQgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzQ29sb3JPdXRwdXRFbmFibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JPdXRwdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgY29sb3Igb3V0cHV0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29sb3JPdXRwdXQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgY29sb3Igb3V0cHV0IHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0Q29sb3JPdXRwdXRFbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5jb2xvck91dHB1dCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBsdW1pbmFuY2UgbWFza2luZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCB1c2VSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sdW1pbmFuY2VSYW5nZSAhPT0gbnVsbDtcbiAgfVxuICBzZXQgdXNlUmFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLmx1bWluYW5jZVJhbmdlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSByYW5nZS4gU2V0IHRvIG51bGwgdG8gZGlzYWJsZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgbHVtaW5hbmNlUmFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucmFuZ2UudmFsdWU7XG4gIH1cbiAgc2V0IGx1bWluYW5jZVJhbmdlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmRlZmluZXMuUkFOR0UgPSBcIjFcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5SQU5HRTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5yYW5nZS52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGx1bWluYW5jZSByYW5nZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGx1bWluYW5jZVJhbmdlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9IFRoZSBsdW1pbmFuY2UgcmFuZ2UuXG4gICAqL1xuICBnZXRMdW1pbmFuY2VSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sdW1pbmFuY2VSYW5nZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIGx1bWluYW5jZSByYW5nZS4gU2V0IHRvIG51bGwgdG8gZGlzYWJsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGx1bWluYW5jZVJhbmdlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdmFsdWUgLSBUaGUgbHVtaW5hbmNlIHJhbmdlLlxuICAgKi9cbiAgc2V0THVtaW5hbmNlUmFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLmx1bWluYW5jZVJhbmdlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvTHVtaW5hbmNlUGFzcy5qc1xudmFyIEx1bWluYW5jZVBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBsdW1pbmFuY2UgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLiBTZWUge0BsaW5rIEx1bWluYW5jZU1hdGVyaWFsfSBmb3IgYWRkaXRpb25hbCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBbb3B0aW9ucy5yZW5kZXJUYXJnZXRdIC0gQSBjdXN0b20gcmVuZGVyIHRhcmdldC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0xLjBdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICByZW5kZXJUYXJnZXQsXG4gICAgbHVtaW5hbmNlUmFuZ2UsXG4gICAgY29sb3JPdXRwdXQsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMSxcbiAgICB3aWR0aCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIGhlaWdodCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25YID0gd2lkdGgsXG4gICAgcmVzb2x1dGlvblkgPSBoZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJMdW1pbmFuY2VQYXNzXCIpO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gbmV3IEx1bWluYW5jZU1hdGVyaWFsKGNvbG9yT3V0cHV0LCBsdW1pbmFuY2VSYW5nZSk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcbiAgICBpZiAodGhpcy5yZW5kZXJUYXJnZXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQ2KDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJMdW1pbmFuY2VQYXNzLlRhcmdldFwiO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtSZXNvbHV0aW9ufSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbHVtaW5hbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICAgIG1hdGVyaWFsLmlucHV0QnVmZmVyID0gaW5wdXRCdWZmZXIudGV4dHVyZTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB0aGlzLnJlbmRlclRhcmdldCk7XG4gICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZShyZXNvbHV0aW9uLndpZHRoLCByZXNvbHV0aW9uLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gQSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCAmJiBmcmFtZUJ1ZmZlclR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGU0KSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL01pcG1hcEJsdXJQYXNzLmpzXG5pbXBvcnQgeyBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTQsIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTUsIFZlY3RvcjIgYXMgVmVjdG9yMjYsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0NyB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0Rvd25zYW1wbGluZ01hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmc0LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDUsIFVuaWZvcm0gYXMgVW5pZm9ybTYsIFZlY3RvcjIgYXMgVmVjdG9yMjQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLmRvd25zYW1wbGluZy5mcmFnXG52YXIgY29udm9sdXRpb25fZG93bnNhbXBsaW5nX2RlZmF1bHQgPSBgI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZW5kaWZcbiNkZWZpbmUgV0VJR0hUX0lOTkVSIDAuMTI1XG4jZGVmaW5lIFdFSUdIVF9PVVRFUiAwLjA1NTU1NTVcbnZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjAwO3ZhcnlpbmcgdmVjMiB2VXYwMTt2YXJ5aW5nIHZlYzIgdlV2MDI7dmFyeWluZyB2ZWMyIHZVdjAzO3ZhcnlpbmcgdmVjMiB2VXYwNDt2YXJ5aW5nIHZlYzIgdlV2MDU7dmFyeWluZyB2ZWMyIHZVdjA2O3ZhcnlpbmcgdmVjMiB2VXYwNzt2YXJ5aW5nIHZlYzIgdlV2MDg7dmFyeWluZyB2ZWMyIHZVdjA5O3ZhcnlpbmcgdmVjMiB2VXYxMDt2YXJ5aW5nIHZlYzIgdlV2MTE7ZmxvYXQgY2xhbXBUb0JvcmRlcihjb25zdCBpbiB2ZWMyIHV2KXtyZXR1cm4gZmxvYXQodXYucz49MC4wJiZ1di5zPD0xLjAmJnV2LnQ+PTAuMCYmdXYudDw9MS4wKTt9dm9pZCBtYWluKCl7dmVjNCBjPXZlYzQoMC4wKTt2ZWM0IHc9V0VJR0hUX0lOTkVSKnZlYzQoY2xhbXBUb0JvcmRlcih2VXYwMCksY2xhbXBUb0JvcmRlcih2VXYwMSksY2xhbXBUb0JvcmRlcih2VXYwMiksY2xhbXBUb0JvcmRlcih2VXYwMykpO2MrPXcueCp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDApO2MrPXcueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDEpO2MrPXcueip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDIpO2MrPXcudyp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDMpO3c9V0VJR0hUX09VVEVSKnZlYzQoY2xhbXBUb0JvcmRlcih2VXYwNCksY2xhbXBUb0JvcmRlcih2VXYwNSksY2xhbXBUb0JvcmRlcih2VXYwNiksY2xhbXBUb0JvcmRlcih2VXYwNykpO2MrPXcueCp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDQpO2MrPXcueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDUpO2MrPXcueip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDYpO2MrPXcudyp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDcpO3c9V0VJR0hUX09VVEVSKnZlYzQoY2xhbXBUb0JvcmRlcih2VXYwOCksY2xhbXBUb0JvcmRlcih2VXYwOSksY2xhbXBUb0JvcmRlcih2VXYxMCksY2xhbXBUb0JvcmRlcih2VXYxMSkpO2MrPXcueCp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDgpO2MrPXcueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDkpO2MrPXcueip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MTApO2MrPXcudyp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MTEpO2MrPVdFSUdIVF9PVVRFUip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtnbF9GcmFnQ29sb3I9YztcbiNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxufWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5kb3duc2FtcGxpbmcudmVydFxudmFyIGNvbnZvbHV0aW9uX2Rvd25zYW1wbGluZ19kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3ZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjAwO3ZhcnlpbmcgdmVjMiB2VXYwMTt2YXJ5aW5nIHZlYzIgdlV2MDI7dmFyeWluZyB2ZWMyIHZVdjAzO3ZhcnlpbmcgdmVjMiB2VXYwNDt2YXJ5aW5nIHZlYzIgdlV2MDU7dmFyeWluZyB2ZWMyIHZVdjA2O3ZhcnlpbmcgdmVjMiB2VXYwNzt2YXJ5aW5nIHZlYzIgdlV2MDg7dmFyeWluZyB2ZWMyIHZVdjA5O3ZhcnlpbmcgdmVjMiB2VXYxMDt2YXJ5aW5nIHZlYzIgdlV2MTE7dm9pZCBtYWluKCl7dlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7dlV2MDA9dlV2K3RleGVsU2l6ZSp2ZWMyKC0xLjAsMS4wKTt2VXYwMT12VXYrdGV4ZWxTaXplKnZlYzIoMS4wLDEuMCk7dlV2MDI9dlV2K3RleGVsU2l6ZSp2ZWMyKC0xLjAsLTEuMCk7dlV2MDM9dlV2K3RleGVsU2l6ZSp2ZWMyKDEuMCwtMS4wKTt2VXYwND12VXYrdGV4ZWxTaXplKnZlYzIoLTIuMCwyLjApO3ZVdjA1PXZVdit0ZXhlbFNpemUqdmVjMigwLjAsMi4wKTt2VXYwNj12VXYrdGV4ZWxTaXplKnZlYzIoMi4wLDIuMCk7dlV2MDc9dlV2K3RleGVsU2l6ZSp2ZWMyKC0yLjAsMC4wKTt2VXYwOD12VXYrdGV4ZWxTaXplKnZlYzIoMi4wLDAuMCk7dlV2MDk9dlV2K3RleGVsU2l6ZSp2ZWMyKC0yLjAsLTIuMCk7dlV2MTA9dlV2K3RleGVsU2l6ZSp2ZWMyKDAuMCwtMi4wKTt2VXYxMT12VXYrdGV4ZWxTaXplKnZlYzIoMi4wLC0yLjApO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRG93bnNhbXBsaW5nTWF0ZXJpYWwuanNcbnZhciBEb3duc2FtcGxpbmdNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWw1IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZG93bnNhbXBsaW5nIG1hdGVyaWFsLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJEb3duc2FtcGxpbmdNYXRlcmlhbFwiLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtNihudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTYobmV3IFZlY3RvcjI0KCkpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc0LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fZG93bnNhbXBsaW5nX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbnZvbHV0aW9uX2Rvd25zYW1wbGluZ19kZWZhdWx0MlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL1Vwc2FtcGxpbmdNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nNSwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWw2LCBVbmlmb3JtIGFzIFVuaWZvcm03LCBWZWN0b3IyIGFzIFZlY3RvcjI1IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi51cHNhbXBsaW5nLmZyYWdcbnZhciBjb252b2x1dGlvbl91cHNhbXBsaW5nX2RlZmF1bHQgPSBgI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO3VuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgc3VwcG9ydEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO3VuaWZvcm0gbG93cCBzYW1wbGVyMkQgc3VwcG9ydEJ1ZmZlcjtcbiNlbmRpZlxudW5pZm9ybSBmbG9hdCByYWRpdXM7dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzIgdlV2MDt2YXJ5aW5nIHZlYzIgdlV2MTt2YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdlV2Mzt2YXJ5aW5nIHZlYzIgdlV2NDt2YXJ5aW5nIHZlYzIgdlV2NTt2YXJ5aW5nIHZlYzIgdlV2Njt2YXJ5aW5nIHZlYzIgdlV2Nzt2b2lkIG1haW4oKXt2ZWM0IGM9dmVjNCgwLjApO2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYwKSowLjA2MjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjEpKjAuMTI1O2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYyKSowLjA2MjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjMpKjAuMTI1O2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpKjAuMjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjQpKjAuMTI1O2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXY1KSowLjA2MjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjYpKjAuMTI1O2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXY3KSowLjA2MjU7dmVjNCBiYXNlQ29sb3I9dGV4dHVyZTJEKHN1cHBvcnRCdWZmZXIsdlV2KTtnbF9GcmFnQ29sb3I9bWl4KGJhc2VDb2xvcixjLHJhZGl1cyk7XG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cbn1gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24udXBzYW1wbGluZy52ZXJ0XG52YXIgY29udm9sdXRpb25fdXBzYW1wbGluZ19kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3ZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dmFyeWluZyB2ZWMyIHZVdjQ7dmFyeWluZyB2ZWMyIHZVdjU7dmFyeWluZyB2ZWMyIHZVdjY7dmFyeWluZyB2ZWMyIHZVdjc7dm9pZCBtYWluKCl7dlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7dlV2MD12VXYrdGV4ZWxTaXplKnZlYzIoLTEuMCwxLjApO3ZVdjE9dlV2K3RleGVsU2l6ZSp2ZWMyKDAuMCwxLjApO3ZVdjI9dlV2K3RleGVsU2l6ZSp2ZWMyKDEuMCwxLjApO3ZVdjM9dlV2K3RleGVsU2l6ZSp2ZWMyKC0xLjAsMC4wKTt2VXY0PXZVdit0ZXhlbFNpemUqdmVjMigxLjAsMC4wKTt2VXY1PXZVdit0ZXhlbFNpemUqdmVjMigtMS4wLC0xLjApO3ZVdjY9dlV2K3RleGVsU2l6ZSp2ZWMyKDAuMCwtMS4wKTt2VXY3PXZVdit0ZXhlbFNpemUqdmVjMigxLjAsLTEuMCk7Z2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9VcHNhbXBsaW5nTWF0ZXJpYWwuanNcbnZhciBVcHNhbXBsaW5nTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsNiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHVwc2FtcGxpbmcgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIlVwc2FtcGxpbmdNYXRlcmlhbFwiLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtNyhudWxsKSxcbiAgICAgICAgc3VwcG9ydEJ1ZmZlcjogbmV3IFVuaWZvcm03KG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtNyhuZXcgVmVjdG9yMjUoKSksXG4gICAgICAgIHJhZGl1czogbmV3IFVuaWZvcm03KDAuODUpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc1LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fdXBzYW1wbGluZ19kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb252b2x1dGlvbl91cHNhbXBsaW5nX2RlZmF1bHQyXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBBIHN1cHBvcnQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBzdXBwb3J0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zdXBwb3J0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIHJhZGl1cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucmFkaXVzLnZhbHVlO1xuICB9XG4gIHNldCByYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KDEgLyB3aWR0aCwgMSAvIGhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvTWlwbWFwQmx1clBhc3MuanNcbnZhciBNaXBtYXBCbHVyUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG1pcG1hcCBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiTWlwbWFwQmx1clBhc3NcIik7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDcoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJVcHNhbXBsaW5nLk1pcG1hcDBcIjtcbiAgICB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHMgPSBbXTtcbiAgICB0aGlzLnVwc2FtcGxpbmdNaXBtYXBzID0gW107XG4gICAgdGhpcy5kb3duc2FtcGxpbmdNYXRlcmlhbCA9IG5ldyBEb3duc2FtcGxpbmdNYXRlcmlhbCgpO1xuICAgIHRoaXMudXBzYW1wbGluZ01hdGVyaWFsID0gbmV3IFVwc2FtcGxpbmdNYXRlcmlhbCgpO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IG5ldyBWZWN0b3IyNigpO1xuICB9XG4gIC8qKlxuICAgKiBBIHRleHR1cmUgdGhhdCBjb250YWlucyB0aGUgYmx1cnJlZCByZXN1bHQuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBNSVAgbGV2ZWxzLiBEZWZhdWx0IGlzIDguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbGV2ZWxzKCkge1xuICAgIHJldHVybiB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHMubGVuZ3RoO1xuICB9XG4gIHNldCBsZXZlbHModmFsdWUpIHtcbiAgICBpZiAodGhpcy5sZXZlbHMgIT09IHZhbHVlKSB7XG4gICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5kb3duc2FtcGxpbmdNaXBtYXBzID0gW107XG4gICAgICB0aGlzLnVwc2FtcGxpbmdNaXBtYXBzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlOyArK2kpIHtcbiAgICAgICAgY29uc3QgbWlwbWFwID0gcmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgICAgIG1pcG1hcC50ZXh0dXJlLm5hbWUgPSBcIkRvd25zYW1wbGluZy5NaXBtYXBcIiArIGk7XG4gICAgICAgIHRoaXMuZG93bnNhbXBsaW5nTWlwbWFwcy5wdXNoKG1pcG1hcCk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwc2FtcGxpbmdNaXBtYXBzLnB1c2gocmVuZGVyVGFyZ2V0KTtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gdmFsdWUgLSAxOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGNvbnN0IG1pcG1hcCA9IHJlbmRlclRhcmdldC5jbG9uZSgpO1xuICAgICAgICBtaXBtYXAudGV4dHVyZS5uYW1lID0gXCJVcHNhbXBsaW5nLk1pcG1hcFwiICsgaTtcbiAgICAgICAgdGhpcy51cHNhbXBsaW5nTWlwbWFwcy5wdXNoKG1pcG1hcCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFNpemUodGhpcy5yZXNvbHV0aW9uLngsIHRoaXMucmVzb2x1dGlvbi55KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIHJhZGl1cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBzYW1wbGluZ01hdGVyaWFsLnJhZGl1cztcbiAgfVxuICBzZXQgcmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy51cHNhbXBsaW5nTWF0ZXJpYWwucmFkaXVzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGJsdXIuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IHsgc2NlbmUsIGNhbWVyYSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGRvd25zYW1wbGluZ01hdGVyaWFsLCB1cHNhbXBsaW5nTWF0ZXJpYWwgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBkb3duc2FtcGxpbmdNaXBtYXBzLCB1cHNhbXBsaW5nTWlwbWFwcyB9ID0gdGhpcztcbiAgICBsZXQgcHJldmlvdXNCdWZmZXIgPSBpbnB1dEJ1ZmZlcjtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IGRvd25zYW1wbGluZ01hdGVyaWFsO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZG93bnNhbXBsaW5nTWlwbWFwcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGNvbnN0IG1pcG1hcCA9IGRvd25zYW1wbGluZ01pcG1hcHNbaV07XG4gICAgICBkb3duc2FtcGxpbmdNYXRlcmlhbC5zZXRTaXplKHByZXZpb3VzQnVmZmVyLndpZHRoLCBwcmV2aW91c0J1ZmZlci5oZWlnaHQpO1xuICAgICAgZG93bnNhbXBsaW5nTWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSBwcmV2aW91c0J1ZmZlci50ZXh0dXJlO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG1pcG1hcCk7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICBwcmV2aW91c0J1ZmZlciA9IG1pcG1hcDtcbiAgICB9XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSB1cHNhbXBsaW5nTWF0ZXJpYWw7XG4gICAgZm9yIChsZXQgaSA9IHVwc2FtcGxpbmdNaXBtYXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBtaXBtYXAgPSB1cHNhbXBsaW5nTWlwbWFwc1tpXTtcbiAgICAgIHVwc2FtcGxpbmdNYXRlcmlhbC5zZXRTaXplKHByZXZpb3VzQnVmZmVyLndpZHRoLCBwcmV2aW91c0J1ZmZlci5oZWlnaHQpO1xuICAgICAgdXBzYW1wbGluZ01hdGVyaWFsLmlucHV0QnVmZmVyID0gcHJldmlvdXNCdWZmZXIudGV4dHVyZTtcbiAgICAgIHVwc2FtcGxpbmdNYXRlcmlhbC5zdXBwb3J0QnVmZmVyID0gZG93bnNhbXBsaW5nTWlwbWFwc1tpXS50ZXh0dXJlO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG1pcG1hcCk7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICBwcmV2aW91c0J1ZmZlciA9IG1pcG1hcDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBsZXQgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuZG93bnNhbXBsaW5nTWlwbWFwcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIHcgPSBNYXRoLnJvdW5kKHcgKiAwLjUpO1xuICAgICAgaCA9IE1hdGgucm91bmQoaCAqIDAuNSk7XG4gICAgICB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHNbaV0uc2V0U2l6ZSh3LCBoKTtcbiAgICAgIGlmIChpIDwgdGhpcy51cHNhbXBsaW5nTWlwbWFwcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy51cHNhbXBsaW5nTWlwbWFwc1tpXS5zZXRTaXplKHcsIGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBtaXBtYXBzID0gdGhpcy5kb3duc2FtcGxpbmdNaXBtYXBzLmNvbmNhdCh0aGlzLnVwc2FtcGxpbmdNaXBtYXBzKTtcbiAgICAgIGZvciAoY29uc3QgbWlwbWFwIG9mIG1pcG1hcHMpIHtcbiAgICAgICAgbWlwbWFwLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGU1KSB7XG4gICAgICAgIHRoaXMuZG93bnNhbXBsaW5nTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgICAgICB0aGlzLnVwc2FtcGxpbmdNYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlbmRlcmVyICE9PSBudWxsICYmIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlNCkge1xuICAgICAgICBmb3IgKGNvbnN0IG1pcG1hcCBvZiBtaXBtYXBzKSB7XG4gICAgICAgICAgbWlwbWFwLnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cyBhbmQgdGV4dHVyZXMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICBmb3IgKGNvbnN0IG1pcG1hcCBvZiB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHMuY29uY2F0KHRoaXMudXBzYW1wbGluZ01pcG1hcHMpKSB7XG4gICAgICBtaXBtYXAuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9ibG9vbS5mcmFnXG52YXIgYmxvb21fZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbWFwO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbWFwO1xuI2VuZGlmXG51bmlmb3JtIGZsb2F0IGludGVuc2l0eTt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjNCB0ZXhlbD10ZXh0dXJlMkQobWFwLHV2KTtvdXRwdXRDb2xvcj12ZWM0KHRleGVsLnJnYippbnRlbnNpdHksbWF4KGlucHV0Q29sb3IuYSx0ZXhlbC5hKSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0Jsb29tRWZmZWN0LmpzXG52YXIgQmxvb21FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJsb29tIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TQ1JFRU5dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubHVtaW5hbmNlVGhyZXNob2xkPTEuMF0gLSBUaGUgbHVtaW5hbmNlIHRocmVzaG9sZC4gUmFpc2UgdGhpcyB2YWx1ZSB0byBtYXNrIG91dCBkYXJrZXIgZWxlbWVudHMgaW4gdGhlIHNjZW5lLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubHVtaW5hbmNlU21vb3RoaW5nPTAuMDNdIC0gQ29udHJvbHMgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGx1bWluYW5jZSB0aHJlc2hvbGQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWlwbWFwQmx1cj10cnVlXSAtIEVuYWJsZXMgb3IgZGlzYWJsZXMgbWlwbWFwIGJsdXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pbnRlbnNpdHk9MS4wXSAtIFRoZSBibG9vbSBpbnRlbnNpdHkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MC44NV0gLSBUaGUgYmx1ciByYWRpdXMuIE9ubHkgYXBwbGllcyB0byBtaXBtYXAgYmx1ci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxldmVscz04XSAtIFRoZSBhbW91bnQgb2YgTUlQIGxldmVscy4gT25seSBhcHBsaWVzIHRvIG1pcG1hcCBibHVyLlxuICAgKiBAcGFyYW0ge0tlcm5lbFNpemV9IFtvcHRpb25zLmtlcm5lbFNpemU9S2VybmVsU2l6ZS5MQVJHRV0gLSBEZXByZWNhdGVkLiBVc2UgbWlwbWFwQmx1ciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTAuNV0gLSBEZXByZWNhdGVkLiBVc2UgbWlwbWFwQmx1ciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIG1pcG1hcEJsdXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSBtaXBtYXBCbHVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgbWlwbWFwQmx1ciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSBtaXBtYXBCbHVyIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU0NSRUVOLFxuICAgIGx1bWluYW5jZVRocmVzaG9sZCA9IDEsXG4gICAgbHVtaW5hbmNlU21vb3RoaW5nID0gMC4wMyxcbiAgICBtaXBtYXBCbHVyID0gdHJ1ZSxcbiAgICBpbnRlbnNpdHkgPSAxLFxuICAgIHJhZGl1cyA9IDAuODUsXG4gICAgbGV2ZWxzID0gOCxcbiAgICBrZXJuZWxTaXplID0gS2VybmVsU2l6ZS5MQVJHRSxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAwLjUsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiQmxvb21FZmZlY3RcIiwgYmxvb21fZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm1hcFwiLCBuZXcgVW5pZm9ybTgobnVsbCldLFxuICAgICAgICBbXCJpbnRlbnNpdHlcIiwgbmV3IFVuaWZvcm04KGludGVuc2l0eSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0OCgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkJsb29tLlRhcmdldFwiO1xuICAgIHRoaXMuYmx1clBhc3MgPSBuZXcgS2F3YXNlQmx1clBhc3MoeyBrZXJuZWxTaXplIH0pO1xuICAgIHRoaXMubHVtaW5hbmNlUGFzcyA9IG5ldyBMdW1pbmFuY2VQYXNzKHsgY29sb3JPdXRwdXQ6IHRydWUgfSk7XG4gICAgdGhpcy5sdW1pbmFuY2VNYXRlcmlhbC50aHJlc2hvbGQgPSBsdW1pbmFuY2VUaHJlc2hvbGQ7XG4gICAgdGhpcy5sdW1pbmFuY2VNYXRlcmlhbC5zbW9vdGhpbmcgPSBsdW1pbmFuY2VTbW9vdGhpbmc7XG4gICAgdGhpcy5taXBtYXBCbHVyUGFzcyA9IG5ldyBNaXBtYXBCbHVyUGFzcygpO1xuICAgIHRoaXMubWlwbWFwQmx1clBhc3MuZW5hYmxlZCA9IG1pcG1hcEJsdXI7XG4gICAgdGhpcy5taXBtYXBCbHVyUGFzcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5taXBtYXBCbHVyUGFzcy5sZXZlbHMgPSBsZXZlbHM7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXBcIikudmFsdWUgPSBtaXBtYXBCbHVyID8gdGhpcy5taXBtYXBCbHVyUGFzcy50ZXh0dXJlIDogdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgfVxuICAvKipcbiAgICogQSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIGludGVybWVkaWF0ZSByZXN1bHQgb2YgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlwbWFwQmx1clBhc3MuZW5hYmxlZCA/IHRoaXMubWlwbWFwQmx1clBhc3MudGV4dHVyZSA6IHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBibG9vbSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7UmVzb2x1dGlvbn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsdXIgcGFzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHJldHVybiB7S2F3YXNlQmx1clBhc3N9IFRoZSBibHVyIHBhc3MuXG4gICAqL1xuICBnZXRCbHVyUGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbHVtaW5hbmNlIHBhc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsdW1pbmFuY2VQYXNzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0x1bWluYW5jZVBhc3N9IFRoZSBsdW1pbmFuY2UgcGFzcy5cbiAgICovXG4gIGdldEx1bWluYW5jZVBhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubHVtaW5hbmNlUGFzcztcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge0x1bWluYW5jZU1hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IGx1bWluYW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmx1bWluYW5jZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsdW1pbmFuY2VNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtMdW1pbmFuY2VNYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0THVtaW5hbmNlTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubHVtaW5hbmNlUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLmhlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnByZWZlcnJlZEhlaWdodCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXRoZXJpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSBFZmZlY3RQYXNzLmRpdGhlcmluZyBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGRpdGhlcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcy5kaXRoZXJpbmc7XG4gIH1cbiAgc2V0IGRpdGhlcmluZyh2YWx1ZSkge1xuICAgIHRoaXMuYmx1clBhc3MuZGl0aGVyaW5nID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIGtlcm5lbCBzaXplLlxuICAgKlxuICAgKiBAdHlwZSB7S2VybmVsU2l6ZX1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBrZXJuZWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemU7XG4gIH1cbiAgc2V0IGtlcm5lbFNpemUodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBkaXN0aW5jdGlvbigpIHtcbiAgICBjb25zb2xlLndhcm4odGhpcy5uYW1lLCBcImRpc3RpbmN0aW9uIHdhcyByZW1vdmVkXCIpO1xuICAgIHJldHVybiAxO1xuICB9XG4gIHNldCBkaXN0aW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnNvbGUud2Fybih0aGlzLm5hbWUsIFwiZGlzdGluY3Rpb24gd2FzIHJlbW92ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibG9vbSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgaW50ZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImludGVuc2l0eVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgaW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJpbnRlbnNpdHlcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsb29tIGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbnRlbnNpdHkuXG4gICAqL1xuICBnZXRJbnRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZW5zaXR5O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibG9vbSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnRlbnNpdHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGludGVuc2l0eS5cbiAgICovXG4gIHNldEludGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMuaW50ZW5zaXR5ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldFJlc29sdXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgbmV3IHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2NhbGUgPSBzY2FsZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG4gICAgY29uc3QgbHVtaW5hbmNlUGFzcyA9IHRoaXMubHVtaW5hbmNlUGFzcztcbiAgICBpZiAobHVtaW5hbmNlUGFzcy5lbmFibGVkKSB7XG4gICAgICBsdW1pbmFuY2VQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIpO1xuICAgICAgaWYgKHRoaXMubWlwbWFwQmx1clBhc3MuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLm1pcG1hcEJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgbHVtaW5hbmNlUGFzcy5yZW5kZXJUYXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ibHVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIGx1bWluYW5jZVBhc3MucmVuZGVyVGFyZ2V0LCByZW5kZXJUYXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5taXBtYXBCbHVyUGFzcy5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMubWlwbWFwQmx1clBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIHJlbmRlclRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUocmVzb2x1dGlvbi53aWR0aCwgcmVzb2x1dGlvbi5oZWlnaHQpO1xuICAgIHRoaXMuYmx1clBhc3MucmVzb2x1dGlvbi5jb3B5KHJlc29sdXRpb24pO1xuICAgIHRoaXMubHVtaW5hbmNlUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMubWlwbWFwQmx1clBhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmx1bWluYW5jZVBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5taXBtYXBCbHVyUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChyZW5kZXJlciAhPT0gbnVsbCAmJiByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZTUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U1O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvQm9rZWhFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTkgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9ib2tlaC5mcmFnXG52YXIgYm9rZWhfZGVmYXVsdCA9IGB1bmlmb3JtIGZsb2F0IGZvY3VzO3VuaWZvcm0gZmxvYXQgZG9mO3VuaWZvcm0gZmxvYXQgYXBlcnR1cmU7dW5pZm9ybSBmbG9hdCBtYXhCbHVyO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LGNvbnN0IGluIGZsb2F0IGRlcHRoLG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWMyIGFzcGVjdENvcnJlY3Rpb249dmVjMigxLjAsYXNwZWN0KTtcbiNpZmRlZiBQRVJTUEVDVElWRV9DQU1FUkFcbmZsb2F0IHZpZXdaPXBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtmbG9hdCBsaW5lYXJEZXB0aD12aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgodmlld1osY2FtZXJhTmVhcixjYW1lcmFGYXIpO1xuI2Vsc2VcbmZsb2F0IGxpbmVhckRlcHRoPWRlcHRoO1xuI2VuZGlmXG5mbG9hdCBmb2N1c05lYXI9Y2xhbXAoZm9jdXMtZG9mLDAuMCwxLjApO2Zsb2F0IGZvY3VzRmFyPWNsYW1wKGZvY3VzK2RvZiwwLjAsMS4wKTtmbG9hdCBsb3c9c3RlcChsaW5lYXJEZXB0aCxmb2N1c05lYXIpO2Zsb2F0IGhpZ2g9c3RlcChmb2N1c0ZhcixsaW5lYXJEZXB0aCk7ZmxvYXQgZmFjdG9yPShsaW5lYXJEZXB0aC1mb2N1c05lYXIpKmxvdysobGluZWFyRGVwdGgtZm9jdXNGYXIpKmhpZ2g7dmVjMiBkb2ZCbHVyPXZlYzIoY2xhbXAoZmFjdG9yKmFwZXJ0dXJlLC1tYXhCbHVyLG1heEJsdXIpKTt2ZWMyIGRvZmJsdXI5PWRvZkJsdXIqMC45O3ZlYzIgZG9mYmx1cjc9ZG9mQmx1ciowLjc7dmVjMiBkb2ZibHVyND1kb2ZCbHVyKjAuNDt2ZWM0IGNvbG9yPWlucHV0Q29sb3I7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjAsMC40KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMTUsMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjI5LDAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMzcsMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjQwLDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjM3LC0wLjE1KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksLTAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMTUsLTAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4wLC0wLjQpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMTUsMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwwLjI5KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMzcsMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC40LDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4zNywtMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwtMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjE1LC0wLjM3KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMTUsMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMzcsMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4zNywtMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMTUsLTAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI5KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjE1LDAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI5KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMzcsMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMzcsLTAuMTUpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI5KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMTUsLTAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI5KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjcpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC40MCwwLjApKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksLTAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMCwtMC40KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNyk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwwLjI5KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNyk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC40LDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjcpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMjksLTAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMCwwLjQpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC40LDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4yOSwtMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4wLC0wLjQpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI0KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjI5LDAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI0KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjQsMC4wKSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNCk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwtMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4wLDAuNCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO291dHB1dENvbG9yPWNvbG9yLzQxLjA7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0Jva2VoRWZmZWN0LmpzXG52YXIgQm9rZWhFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJva2VoIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb25dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXM9MC41XSAtIFRoZSBmb2N1cyBkaXN0YW5jZSByYXRpbywgcmFuZ2luZyBmcm9tIDAuMCB0byAxLjAuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kb2Y9MC4wMl0gLSBEZXB0aCBvZiBmaWVsZC4gQW4gYXJlYSBpbiBmcm9udCBvZiBhbmQgYmVoaW5kIHRoZSBmb2NhbCBwb2ludCB0aGF0IHN0aWxsIGFwcGVhcnMgc2hhcnAuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hcGVydHVyZT0wLjAxNV0gLSBDYW1lcmEgYXBlcnR1cmUgc2NhbGUuIEJpZ2dlciB2YWx1ZXMgZm9yIHN0cm9uZ2VyIGJsdXIgYW5kIHNoYWxsb3dlciBkZXB0aCBvZiBmaWVsZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEJsdXI9MS4wXSAtIFRoZSBtYXhpbXVtIGJsdXIgc3RyZW5ndGguXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmxlbmRGdW5jdGlvbixcbiAgICBmb2N1cyA9IDAuNSxcbiAgICBkb2YgPSAwLjAyLFxuICAgIGFwZXJ0dXJlID0gMC4wMTUsXG4gICAgbWF4Qmx1ciA9IDFcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJCb2tlaEVmZmVjdFwiLCBib2tlaF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgYXR0cmlidXRlczogRWZmZWN0QXR0cmlidXRlLkNPTlZPTFVUSU9OIHwgRWZmZWN0QXR0cmlidXRlLkRFUFRILFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiZm9jdXNcIiwgbmV3IFVuaWZvcm05KGZvY3VzKV0sXG4gICAgICAgIFtcImRvZlwiLCBuZXcgVW5pZm9ybTkoZG9mKV0sXG4gICAgICAgIFtcImFwZXJ0dXJlXCIsIG5ldyBVbmlmb3JtOShhcGVydHVyZSldLFxuICAgICAgICBbXCJtYXhCbHVyXCIsIG5ldyBVbmlmb3JtOShtYXhCbHVyKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0JyaWdodG5lc3NDb250cmFzdEVmZmVjdC5qc1xuaW1wb3J0IHsgU1JHQkNvbG9yU3BhY2UgYXMgU1JHQkNvbG9yU3BhY2U2LCBVbmlmb3JtIGFzIFVuaWZvcm0xMCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2JyaWdodG5lc3MtY29udHJhc3QuZnJhZ1xudmFyIGJyaWdodG5lc3NfY29udHJhc3RfZGVmYXVsdCA9IGB1bmlmb3JtIGZsb2F0IGJyaWdodG5lc3M7dW5pZm9ybSBmbG9hdCBjb250cmFzdDt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMyBjb2xvcj1pbnB1dENvbG9yLnJnYit2ZWMzKGJyaWdodG5lc3MtMC41KTtpZihjb250cmFzdD4wLjApe2NvbG9yLz12ZWMzKDEuMC1jb250cmFzdCk7fWVsc2V7Y29sb3IqPXZlYzMoMS4wK2NvbnRyYXN0KTt9b3V0cHV0Q29sb3I9dmVjNChjb2xvcit2ZWMzKDAuNSksaW5wdXRDb2xvci5hKTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvQnJpZ2h0bmVzc0NvbnRyYXN0RWZmZWN0LmpzXG52YXIgQnJpZ2h0bmVzc0NvbnRyYXN0RWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBicmlnaHRuZXNzL2NvbnRyYXN0IGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TUkNdIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnJpZ2h0bmVzcz0wLjBdIC0gVGhlIGJyaWdodG5lc3MgZmFjdG9yLCByYW5naW5nIGZyb20gLTEgdG8gMSwgd2hlcmUgMCBtZWFucyBubyBjaGFuZ2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb250cmFzdD0wLjBdIC0gVGhlIGNvbnRyYXN0IGZhY3RvciwgcmFuZ2luZyBmcm9tIC0xIHRvIDEsIHdoZXJlIDAgbWVhbnMgbm8gY2hhbmdlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsIGJyaWdodG5lc3MgPSAwLCBjb250cmFzdCA9IDAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJCcmlnaHRuZXNzQ29udHJhc3RFZmZlY3RcIiwgYnJpZ2h0bmVzc19jb250cmFzdF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiYnJpZ2h0bmVzc1wiLCBuZXcgVW5pZm9ybTEwKGJyaWdodG5lc3MpXSxcbiAgICAgICAgW1wiY29udHJhc3RcIiwgbmV3IFVuaWZvcm0xMChjb250cmFzdCldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuaW5wdXRDb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U2O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYnJpZ2h0bmVzcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBicmlnaHRuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImJyaWdodG5lc3NcIikudmFsdWU7XG4gIH1cbiAgc2V0IGJyaWdodG5lc3ModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImJyaWdodG5lc3NcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYnJpZ2h0bmVzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJyaWdodG5lc3MgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYnJpZ2h0bmVzcy5cbiAgICovXG4gIGdldEJyaWdodG5lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnJpZ2h0bmVzcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYnJpZ2h0bmVzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJyaWdodG5lc3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGJyaWdodG5lc3MuXG4gICAqL1xuICBzZXRCcmlnaHRuZXNzKHZhbHVlKSB7XG4gICAgdGhpcy5icmlnaHRuZXNzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjb250cmFzdC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb250cmFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJjb250cmFzdFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgY29udHJhc3QodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImNvbnRyYXN0XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRyYXN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29udHJhc3QgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY29udHJhc3QuXG4gICAqL1xuICBnZXRDb250cmFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cmFzdDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY29udHJhc3QuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb250cmFzdCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgY29udHJhc3QuXG4gICAqL1xuICBzZXRDb250cmFzdCh2YWx1ZSkge1xuICAgIHRoaXMuY29udHJhc3QgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9jb2xvci1hdmVyYWdlLmZyYWdcbnZhciBjb2xvcl9hdmVyYWdlX2RlZmF1bHQgPSBgdm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe291dHB1dENvbG9yPXZlYzQodmVjMyhhdmVyYWdlKGlucHV0Q29sb3IucmdiKSksaW5wdXRDb2xvci5hKTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvQ29sb3JBdmVyYWdlRWZmZWN0LmpzXG52YXIgQ29sb3JBdmVyYWdlRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjb2xvciBhdmVyYWdlIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihibGVuZEZ1bmN0aW9uKSB7XG4gICAgc3VwZXIoXCJDb2xvckF2ZXJhZ2VFZmZlY3RcIiwgY29sb3JfYXZlcmFnZV9kZWZhdWx0LCB7IGJsZW5kRnVuY3Rpb24gfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0NvbG9yRGVwdGhFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTExIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvY29sb3ItZGVwdGguZnJhZ1xudmFyIGNvbG9yX2RlcHRoX2RlZmF1bHQgPSBgdW5pZm9ybSBmbG9hdCBmYWN0b3I7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe291dHB1dENvbG9yPXZlYzQoZmxvb3IoaW5wdXRDb2xvci5yZ2IqZmFjdG9yKzAuNSkvZmFjdG9yLGlucHV0Q29sb3IuYSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0NvbG9yRGVwdGhFZmZlY3QuanNcbnZhciBDb2xvckRlcHRoRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjb2xvciBkZXB0aCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJpdHM9MTZdIC0gVGhlIGNvbG9yIGJpdCBkZXB0aC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiwgYml0cyA9IDE2IH0gPSB7fSkge1xuICAgIHN1cGVyKFwiQ29sb3JEZXB0aEVmZmVjdFwiLCBjb2xvcl9kZXB0aF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiZmFjdG9yXCIsIG5ldyBVbmlmb3JtMTEoMSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuYml0cyA9IDA7XG4gICAgdGhpcy5iaXREZXB0aCA9IGJpdHM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB2aXJ0dWFsIGFtb3VudCBvZiBjb2xvciBiaXRzLlxuICAgKlxuICAgKiBFYWNoIGNvbG9yIGNoYW5uZWwgZWZmZWN0aXZlbHkgdXNlcyBhIGZvdXJ0aCBvZiB0aGUgdG90YWwgYW1vdW50IG9mIGJpdHMuIEFscGhhIHJlbWFpbnMgdW5hZmZlY3RlZC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBiaXREZXB0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5iaXRzO1xuICB9XG4gIHNldCBiaXREZXB0aCh2YWx1ZSkge1xuICAgIHRoaXMuYml0cyA9IHZhbHVlO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZmFjdG9yXCIpLnZhbHVlID0gTWF0aC5wb3coMiwgdmFsdWUgLyAzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBjb2xvciBiaXQgZGVwdGguXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGJpdCBkZXB0aC5cbiAgICovXG4gIGdldEJpdERlcHRoKCkge1xuICAgIHJldHVybiB0aGlzLmJpdERlcHRoO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2aXJ0dWFsIGFtb3VudCBvZiBjb2xvciBiaXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgYml0IGRlcHRoLlxuICAgKi9cbiAgc2V0Qml0RGVwdGgodmFsdWUpIHtcbiAgICB0aGlzLmJpdERlcHRoID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0Nocm9tYXRpY0FiZXJyYXRpb25FZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTEyLCBWZWN0b3IyIGFzIFZlY3RvcjI3IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvY2hyb21hdGljLWFiZXJyYXRpb24uZnJhZ1xudmFyIGNocm9tYXRpY19hYmVycmF0aW9uX2RlZmF1bHQgPSBgI2lmZGVmIFJBRElBTF9NT0RVTEFUSU9OXG51bmlmb3JtIGZsb2F0IG1vZHVsYXRpb25PZmZzZXQ7XG4jZW5kaWZcbnZhcnlpbmcgZmxvYXQgdkFjdGl2ZTt2YXJ5aW5nIHZlYzIgdlV2Ujt2YXJ5aW5nIHZlYzIgdlV2Qjt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMiByYT1pbnB1dENvbG9yLnJhO3ZlYzIgYmE9aW5wdXRDb2xvci5iYTtcbiNpZmRlZiBSQURJQUxfTU9EVUxBVElPTlxuY29uc3QgdmVjMiBjZW50ZXI9dmVjMigwLjUpO2Zsb2F0IGQ9ZGlzdGFuY2UodXYsY2VudGVyKSoyLjA7ZD1tYXgoZC1tb2R1bGF0aW9uT2Zmc2V0LDAuMCk7aWYodkFjdGl2ZT4wLjAmJmQ+MC4wKXtyYT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsbWl4KHV2LHZVdlIsZCkpLnJhO2JhPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixtaXgodXYsdlV2QixkKSkuYmE7fVxuI2Vsc2VcbmlmKHZBY3RpdmU+MC4wKXtyYT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2UikucmE7YmE9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdkIpLmJhO31cbiNlbmRpZlxub3V0cHV0Q29sb3I9dmVjNChyYS54LGlucHV0Q29sb3IuZyxiYS54LG1heChtYXgocmEueSxiYS55KSxpbnB1dENvbG9yLmEpKTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9jaHJvbWF0aWMtYWJlcnJhdGlvbi52ZXJ0XG52YXIgY2hyb21hdGljX2FiZXJyYXRpb25fZGVmYXVsdDIgPSBgdW5pZm9ybSB2ZWMyIG9mZnNldDt2YXJ5aW5nIGZsb2F0IHZBY3RpdmU7dmFyeWluZyB2ZWMyIHZVdlI7dmFyeWluZyB2ZWMyIHZVdkI7dm9pZCBtYWluU3VwcG9ydChjb25zdCBpbiB2ZWMyIHV2KXt2ZWMyIHNoaWZ0PW9mZnNldCp2ZWMyKDEuMCxhc3BlY3QpO3ZBY3RpdmU9KHNoaWZ0LnghPTAuMHx8c2hpZnQueSE9MC4wKT8xLjA6MC4wO3ZVdlI9dXYrc2hpZnQ7dlV2Qj11di1zaGlmdDt9YDtcblxuLy8gc3JjL2VmZmVjdHMvQ2hyb21hdGljQWJlcnJhdGlvbkVmZmVjdC5qc1xudmFyIENocm9tYXRpY0FiZXJyYXRpb25FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNocm9tYXRpYyBhYmVycmF0aW9uIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLm9mZnNldF0gLSBUaGUgY29sb3Igb2Zmc2V0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJhZGlhbE1vZHVsYXRpb249ZmFsc2VdIC0gV2hldGhlciB0aGUgZWZmZWN0IHNob3VsZCBiZSBtb2R1bGF0ZWQgd2l0aCBhIHJhZGlhbCBncmFkaWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1vZHVsYXRpb25PZmZzZXQ9MC4xNV0gLSBUaGUgbW9kdWxhdGlvbiBvZmZzZXQuIE9ubHkgYXBwbGllcyBpZiBgcmFkaWFsTW9kdWxhdGlvbmAgaXMgZW5hYmxlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvZmZzZXQgPSBuZXcgVmVjdG9yMjcoMWUtMywgNWUtNCksXG4gICAgcmFkaWFsTW9kdWxhdGlvbiA9IGZhbHNlLFxuICAgIG1vZHVsYXRpb25PZmZzZXQgPSAwLjE1XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiQ2hyb21hdGljQWJlcnJhdGlvbkVmZmVjdFwiLCBjaHJvbWF0aWNfYWJlcnJhdGlvbl9kZWZhdWx0LCB7XG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNocm9tYXRpY19hYmVycmF0aW9uX2RlZmF1bHQyLFxuICAgICAgYXR0cmlidXRlczogRWZmZWN0QXR0cmlidXRlLkNPTlZPTFVUSU9OLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wib2Zmc2V0XCIsIG5ldyBVbmlmb3JtMTIob2Zmc2V0KV0sXG4gICAgICAgIFtcIm1vZHVsYXRpb25PZmZzZXRcIiwgbmV3IFVuaWZvcm0xMihtb2R1bGF0aW9uT2Zmc2V0KV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yYWRpYWxNb2R1bGF0aW9uID0gcmFkaWFsTW9kdWxhdGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mZnNldC5cbiAgICpcbiAgICogQHR5cGUge1ZlY3RvcjJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIm9mZnNldFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgb2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJvZmZzZXRcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgcmFkaWFsIG1vZHVsYXRpb24gaXMgZW5hYmxlZC5cbiAgICpcbiAgICogV2hlbiBlbmFibGVkLCB0aGUgZWZmZWN0IHdpbGwgYmUgd2Vha2VyIGluIHRoZSBtaWRkbGUgYW5kIHN0cm9uZ2VyIHRvd2FyZHMgdGhlIHNjcmVlbiBlZGdlcy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgcmFkaWFsTW9kdWxhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLmhhcyhcIlJBRElBTF9NT0RVTEFUSU9OXCIpO1xuICB9XG4gIHNldCByYWRpYWxNb2R1bGF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiUkFESUFMX01PRFVMQVRJT05cIiwgXCIxXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiUkFESUFMX01PRFVMQVRJT05cIik7XG4gICAgfVxuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbW9kdWxhdGlvbiBvZmZzZXQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbW9kdWxhdGlvbk9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJtb2R1bGF0aW9uT2Zmc2V0XCIpLnZhbHVlO1xuICB9XG4gIHNldCBtb2R1bGF0aW9uT2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJtb2R1bGF0aW9uT2Zmc2V0XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbG9yIG9mZnNldCB2ZWN0b3IuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvZmZzZXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yMn0gVGhlIG9mZnNldC5cbiAgICovXG4gIGdldE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbG9yIG9mZnNldCB2ZWN0b3IuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvZmZzZXQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2YWx1ZSAtIFRoZSBvZmZzZXQuXG4gICAqL1xuICBzZXRPZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLm9mZnNldCA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2RlcHRoLmZyYWdcbnZhciBkZXB0aF9kZWZhdWx0ID0gYHZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LGNvbnN0IGluIGZsb2F0IGRlcHRoLG91dCB2ZWM0IG91dHB1dENvbG9yKXtcbiNpZmRlZiBJTlZFUlRFRFxudmVjMyBjb2xvcj12ZWMzKDEuMC1kZXB0aCk7XG4jZWxzZVxudmVjMyBjb2xvcj12ZWMzKGRlcHRoKTtcbiNlbmRpZlxub3V0cHV0Q29sb3I9dmVjNChjb2xvcixpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9EZXB0aEVmZmVjdC5qc1xudmFyIERlcHRoRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbnZlcnRlZD1mYWxzZV0gLSBXaGV0aGVyIHRoZSBkZXB0aCBzaG91bGQgYmUgaW52ZXJ0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLlNSQywgaW52ZXJ0ZWQgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBzdXBlcihcIkRlcHRoRWZmZWN0XCIsIGRlcHRoX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBhdHRyaWJ1dGVzOiBFZmZlY3RBdHRyaWJ1dGUuREVQVEhcbiAgICB9KTtcbiAgICB0aGlzLmludmVydGVkID0gaW52ZXJ0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRlcHRoIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaW52ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJJTlZFUlRFRFwiKTtcbiAgfVxuICBzZXQgaW52ZXJ0ZWQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pbnZlcnRlZCAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiSU5WRVJURURcIiwgXCIxXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIklOVkVSVEVEXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVuZGVyZWQgZGVwdGggaXMgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnZlcnRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSByZW5kZXJlZCBkZXB0aCBpcyBpbnZlcnRlZC5cbiAgICovXG4gIGlzSW52ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52ZXJ0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgZGVwdGggaW52ZXJzaW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW52ZXJ0ZWQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgZGVwdGggc2hvdWxkIGJlIGludmVydGVkLlxuICAgKi9cbiAgc2V0SW52ZXJ0ZWQodmFsdWUpIHtcbiAgICB0aGlzLmludmVydGVkID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0RlcHRoT2ZGaWVsZEVmZmVjdC5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmc0LCBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTcsIFVuaWZvcm0gYXMgVW5pZm9ybTE2LCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGU4LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDkgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VudW1zL0NvbG9yQ2hhbm5lbC5qc1xudmFyIENvbG9yQ2hhbm5lbCA9IHtcbiAgUkVEOiAwLFxuICBHUkVFTjogMSxcbiAgQkxVRTogMixcbiAgQUxQSEE6IDNcbn07XG5cbi8vIHNyYy9lbnVtcy9NYXNrRnVuY3Rpb24uanNcbnZhciBNYXNrRnVuY3Rpb24gPSB7XG4gIERJU0NBUkQ6IDAsXG4gIE1VTFRJUExZOiAxLFxuICBNVUxUSVBMWV9SR0JfU0VUX0FMUEhBOiAyLFxuICBNVUxUSVBMWV9SR0I6IDNcbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvQm9rZWhNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nNiwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWw3LCBVbmlmb3JtIGFzIFVuaWZvcm0xMywgVmVjdG9yMiBhcyBWZWN0b3IyOCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uYm9rZWguZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2Jva2VoX2RlZmF1bHQgPSBgI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZW5kaWZcbiNpZiBQQVNTID09IDFcbnVuaWZvcm0gdmVjNCBrZXJuZWw2NFszMl07XG4jZWxzZVxudW5pZm9ybSB2ZWM0IGtlcm5lbDE2WzhdO1xuI2VuZGlmXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGNvY0J1ZmZlcjt1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQgc2NhbGU7dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXtcbiNpZmRlZiBGT1JFR1JPVU5EXG52ZWMyIGNvY05lYXJGYXI9dGV4dHVyZTJEKGNvY0J1ZmZlcix2VXYpLnJnKnNjYWxlO2Zsb2F0IGNvYz1jb2NOZWFyRmFyLng7XG4jZWxzZVxuZmxvYXQgY29jPXRleHR1cmUyRChjb2NCdWZmZXIsdlV2KS5nKnNjYWxlO1xuI2VuZGlmXG5pZihjb2M9PTAuMCl7Z2xfRnJhZ0NvbG9yPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpO31lbHNle1xuI2lmZGVmIEZPUkVHUk9VTkRcbnZlYzIgc3RlcD10ZXhlbFNpemUqbWF4KGNvY05lYXJGYXIueCxjb2NOZWFyRmFyLnkpO1xuI2Vsc2VcbnZlYzIgc3RlcD10ZXhlbFNpemUqY29jO1xuI2VuZGlmXG4jaWYgUEFTUyA9PSAxXG52ZWM0IGFjYz12ZWM0KDAuMCk7Zm9yKGludCBpPTA7aTwzMjsrK2kpe3ZlYzQga2VybmVsPWtlcm5lbDY0W2ldO3ZlYzIgdXY9c3RlcCprZXJuZWwueHkrdlV2O2FjYys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2KTt1dj1zdGVwKmtlcm5lbC56dyt2VXY7YWNjKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYpO31nbF9GcmFnQ29sb3I9YWNjLzY0LjA7XG4jZWxzZVxudmVjNCBtYXhWYWx1ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtmb3IoaW50IGk9MDtpPDg7KytpKXt2ZWM0IGtlcm5lbD1rZXJuZWwxNltpXTt2ZWMyIHV2PXN0ZXAqa2VybmVsLnh5K3ZVdjttYXhWYWx1ZT1tYXgodGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2KSxtYXhWYWx1ZSk7dXY9c3RlcCprZXJuZWwuencrdlV2O21heFZhbHVlPW1heCh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYpLG1heFZhbHVlKTt9Z2xfRnJhZ0NvbG9yPW1heFZhbHVlO1xuI2VuZGlmXG59fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvQm9rZWhNYXRlcmlhbC5qc1xudmFyIEJva2VoTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsNyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJva2VoIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmaWxsPWZhbHNlXSAtIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGJva2VoIGhpZ2hsaWdodCBmaWxsIG1vZGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmVncm91bmQ9ZmFsc2VdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgbWF0ZXJpYWwgd2lsbCBiZSBhcHBsaWVkIHRvIGZvcmVncm91bmQgY29sb3JzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZmlsbCA9IGZhbHNlLCBmb3JlZ3JvdW5kID0gZmFsc2UpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkJva2VoTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgUEFTUzogZmlsbCA/IFwiMlwiIDogXCIxXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0xMyhudWxsKSxcbiAgICAgICAgY29jQnVmZmVyOiBuZXcgVW5pZm9ybTEzKG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtMTMobmV3IFZlY3RvcjI4KCkpLFxuICAgICAgICBrZXJuZWw2NDogbmV3IFVuaWZvcm0xMyhudWxsKSxcbiAgICAgICAga2VybmVsMTY6IG5ldyBVbmlmb3JtMTMobnVsbCksXG4gICAgICAgIHNjYWxlOiBuZXcgVW5pZm9ybTEzKDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc2LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fYm9rZWhfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29tbW9uX2RlZmF1bHRcbiAgICB9KTtcbiAgICBpZiAoZm9yZWdyb3VuZCkge1xuICAgICAgdGhpcy5kZWZpbmVzLkZPUkVHUk9VTkQgPSBcIjFcIjtcbiAgICB9XG4gICAgdGhpcy5nZW5lcmF0ZUtlcm5lbCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGNpcmNsZSBvZiBjb25mdXNpb24gYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBjb2NCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmNvY0J1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjaXJjbGUgb2YgY29uZnVzaW9uIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvY0J1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGJ1ZmZlci5cbiAgICovXG4gIHNldENvQ0J1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuY29jQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlO1xuICB9XG4gIHNldCBzY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNjYWxlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNjYWxlLlxuICAgKi9cbiAgZ2V0U2NhbGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNjYWxlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzY2FsZS5cbiAgICovXG4gIHNldFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5zY2FsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIGJsdXIga2VybmVsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2VuZXJhdGVLZXJuZWwoKSB7XG4gICAgY29uc3QgR09MREVOX0FOR0xFID0gMi4zOTk5NjMyMztcbiAgICBjb25zdCBwb2ludHM2NCA9IG5ldyBGbG9hdDY0QXJyYXkoMTI4KTtcbiAgICBjb25zdCBwb2ludHMxNiA9IG5ldyBGbG9hdDY0QXJyYXkoMzIpO1xuICAgIGxldCBpNjQgPSAwLCBpMTYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBzcXJ0ODAgPSBNYXRoLnNxcnQoODApOyBpIDwgODA7ICsraSkge1xuICAgICAgY29uc3QgdGhldGEgPSBpICogR09MREVOX0FOR0xFO1xuICAgICAgY29uc3QgciA9IE1hdGguc3FydChpKSAvIHNxcnQ4MDtcbiAgICAgIGNvbnN0IHUgPSByICogTWF0aC5jb3ModGhldGEpLCB2MyA9IHIgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICBpZiAoaSAlIDUgPT09IDApIHtcbiAgICAgICAgcG9pbnRzMTZbaTE2KytdID0gdTtcbiAgICAgICAgcG9pbnRzMTZbaTE2KytdID0gdjM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ludHM2NFtpNjQrK10gPSB1O1xuICAgICAgICBwb2ludHM2NFtpNjQrK10gPSB2MztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5rZXJuZWw2NC52YWx1ZSA9IHBvaW50czY0O1xuICAgIHRoaXMudW5pZm9ybXMua2VybmVsMTYudmFsdWUgPSBwb2ludHMxNjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNpemUoKSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxuICAgKi9cbiAgc2V0VGV4ZWxTaXplKHgsIHkpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9DaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsLmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzMsIE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzcsIFBlcnNwZWN0aXZlQ2FtZXJhLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDgsIFVuaWZvcm0gYXMgVW5pZm9ybTE0IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy91dGlscy9vcnRob2dyYXBoaWNEZXB0aFRvVmlld1ouanNcbmZ1bmN0aW9uIG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WihkZXB0aCwgbmVhciwgZmFyKSB7XG4gIHJldHVybiBkZXB0aCAqIChuZWFyIC0gZmFyKSAtIG5lYXI7XG59XG5cbi8vIHNyYy91dGlscy92aWV3WlRvT3J0aG9ncmFwaGljRGVwdGguanNcbmZ1bmN0aW9uIHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCh2aWV3WiwgbmVhciwgZmFyKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCgodmlld1ogKyBuZWFyKSAvIChuZWFyIC0gZmFyKSwgMCksIDEpO1xufVxuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY2lyY2xlLW9mLWNvbmZ1c2lvbi5mcmFnXG52YXIgY2lyY2xlX29mX2NvbmZ1c2lvbl9kZWZhdWx0ID0gYCNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8cGFja2luZz5cbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbmRpZlxudW5pZm9ybSBmbG9hdCBmb2N1c0Rpc3RhbmNlO3VuaWZvcm0gZmxvYXQgZm9jdXNSYW5nZTt1bmlmb3JtIGZsb2F0IGNhbWVyYU5lYXI7dW5pZm9ybSBmbG9hdCBjYW1lcmFGYXI7dmFyeWluZyB2ZWMyIHZVdjtmbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXG5mbG9hdCBkZXB0aD11bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpKTtcbiNlbHNlXG5mbG9hdCBkZXB0aD10ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XG4jZW5kaWZcbiNpZmRlZiBMT0dfREVQVEhcbmZsb2F0IGQ9cG93KDIuMCxkZXB0aCpsb2cyKGNhbWVyYUZhcisxLjApKS0xLjA7ZmxvYXQgYT1jYW1lcmFGYXIvKGNhbWVyYUZhci1jYW1lcmFOZWFyKTtmbG9hdCBiPWNhbWVyYUZhcipjYW1lcmFOZWFyLyhjYW1lcmFOZWFyLWNhbWVyYUZhcik7ZGVwdGg9YStiL2Q7XG4jZW5kaWZcbnJldHVybiBkZXB0aDt9dm9pZCBtYWluKCl7ZmxvYXQgZGVwdGg9cmVhZERlcHRoKHZVdik7XG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXG5mbG9hdCB2aWV3Wj1wZXJzcGVjdGl2ZURlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyLGNhbWVyYUZhcik7ZmxvYXQgbGluZWFyRGVwdGg9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKHZpZXdaLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcbiNlbHNlXG5mbG9hdCBsaW5lYXJEZXB0aD1kZXB0aDtcbiNlbmRpZlxuZmxvYXQgc2lnbmVkRGlzdGFuY2U9bGluZWFyRGVwdGgtZm9jdXNEaXN0YW5jZTtmbG9hdCBtYWduaXR1ZGU9c21vb3Roc3RlcCgwLjAsZm9jdXNSYW5nZSxhYnMoc2lnbmVkRGlzdGFuY2UpKTtnbF9GcmFnQ29sb3Iucmc9bWFnbml0dWRlKnZlYzIoc3RlcChzaWduZWREaXN0YW5jZSwwLjApLHN0ZXAoMC4wLHNpZ25lZERpc3RhbmNlKSk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvQ2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbC5qc1xudmFyIENpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsOCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENvQyBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FtZXJhKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJDaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIERFUFRIX1BBQ0tJTkc6IFwiMFwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMTQobnVsbCksXG4gICAgICAgIGZvY3VzRGlzdGFuY2U6IG5ldyBVbmlmb3JtMTQoMCksXG4gICAgICAgIGZvY3VzUmFuZ2U6IG5ldyBVbmlmb3JtMTQoMCksXG4gICAgICAgIGNhbWVyYU5lYXI6IG5ldyBVbmlmb3JtMTQoMC4zKSxcbiAgICAgICAgY2FtZXJhRmFyOiBuZXcgVW5pZm9ybTE0KDFlMylcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzcsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBjaXJjbGVfb2ZfY29uZnVzaW9uX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbW1vbl9kZWZhdWx0XG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3Jtcy5mb2NhbExlbmd0aCA9IHRoaXMudW5pZm9ybXMuZm9jdXNSYW5nZTtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBuZWFyIHBsYW5lIHNldHRpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgbmVhcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBmYXIgcGxhbmUgc2V0dGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBmYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhCdWZmZXIgYW5kIGRlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMykge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyBkaXN0YW5jZS4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZm9jdXNEaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5mb2N1c0Rpc3RhbmNlLnZhbHVlO1xuICB9XG4gIHNldCBmb2N1c0Rpc3RhbmNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5mb2N1c0Rpc3RhbmNlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyBkaXN0YW5jZSBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZEZvY3VzRGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5mb2N1c0Rpc3RhbmNlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGRGb2N1c0Rpc3RhbmNlKHZhbHVlKSB7XG4gICAgdGhpcy5mb2N1c0Rpc3RhbmNlID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvY3VzIGRpc3RhbmNlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZm9jdXNEaXN0YW5jZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmb2N1cyBkaXN0YW5jZS5cbiAgICovXG4gIGdldEZvY3VzRGlzdGFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmZvY3VzRGlzdGFuY2UudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZm9jdXMgZGlzdGFuY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBmb2N1c0Rpc3RhbmNlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBmb2N1cyBkaXN0YW5jZS5cbiAgICovXG4gIHNldEZvY3VzRGlzdGFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmZvY3VzRGlzdGFuY2UudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvY2FsIGxlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBmb2N1c1JhbmdlLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZvY2FsTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzUmFuZ2U7XG4gIH1cbiAgc2V0IGZvY2FsTGVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5mb2N1c1JhbmdlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyByYW5nZS4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZm9jdXNSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5mb2N1c1JhbmdlLnZhbHVlO1xuICB9XG4gIHNldCBmb2N1c1JhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5mb2N1c1JhbmdlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyByYW5nZSBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZEZvY3VzUmFuZ2UoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5mb2N1c1JhbmdlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGRGb2N1c1JhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy5mb2N1c1JhbmdlID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvY2FsIGxlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZvY3VzUmFuZ2UgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZm9jYWwgbGVuZ3RoLlxuICAgKi9cbiAgZ2V0Rm9jYWxMZW5ndGgodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5mb2N1c1JhbmdlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmb2NhbCBsZW5ndGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBmb2N1c1JhbmdlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBmb2NhbCBsZW5ndGguXG4gICAqL1xuICBzZXRGb2NhbExlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMuZm9jdXNSYW5nZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3B5Q2FtZXJhU2V0dGluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBID0gXCIxXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9NYXNrTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzgsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsOSwgVW5pZm9ybSBhcyBVbmlmb3JtMTUsIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTYgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL21hc2suZnJhZ1xudmFyIG1hc2tfZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbmRpZlxuI2lmZGVmIE1BU0tfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbWFza1RleHR1cmU7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBtYXNrVGV4dHVyZTtcbiNlbmRpZlxuI2lmIE1BU0tfRlVOQ1RJT04gIT0gMFxudW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcbiNlbmRpZlxudmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXtcbiNpZiBDT0xPUl9DSEFOTkVMID09IDBcbmZsb2F0IG1hc2s9dGV4dHVyZTJEKG1hc2tUZXh0dXJlLHZVdikucjtcbiNlbGlmIENPTE9SX0NIQU5ORUwgPT0gMVxuZmxvYXQgbWFzaz10ZXh0dXJlMkQobWFza1RleHR1cmUsdlV2KS5nO1xuI2VsaWYgQ09MT1JfQ0hBTk5FTCA9PSAyXG5mbG9hdCBtYXNrPXRleHR1cmUyRChtYXNrVGV4dHVyZSx2VXYpLmI7XG4jZWxzZVxuZmxvYXQgbWFzaz10ZXh0dXJlMkQobWFza1RleHR1cmUsdlV2KS5hO1xuI2VuZGlmXG4jaWYgTUFTS19GVU5DVElPTiA9PSAwXG4jaWZkZWYgSU5WRVJURURcbm1hc2s9c3RlcChtYXNrLDAuMCk7XG4jZWxzZVxubWFzaz0xLjAtc3RlcChtYXNrLDAuMCk7XG4jZW5kaWZcbiNlbHNlXG5tYXNrPWNsYW1wKG1hc2sqc3RyZW5ndGgsMC4wLDEuMCk7XG4jaWZkZWYgSU5WRVJURURcbm1hc2s9MS4wLW1hc2s7XG4jZW5kaWZcbiNlbmRpZlxuI2lmIE1BU0tfRlVOQ1RJT04gPT0gM1xudmVjNCB0ZXhlbD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtnbF9GcmFnQ29sb3I9dmVjNChtYXNrKnRleGVsLnJnYix0ZXhlbC5hKTtcbiNlbGlmIE1BU0tfRlVOQ1RJT04gPT0gMlxuZ2xfRnJhZ0NvbG9yPXZlYzQobWFzayp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KS5yZ2IsbWFzayk7XG4jZWxzZVxuZ2xfRnJhZ0NvbG9yPW1hc2sqdGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdik7XG4jZW5kaWZcbn1gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL01hc2tNYXRlcmlhbC5qc1xudmFyIE1hc2tNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWw5IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbWFzayBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbbWFza1RleHR1cmVdIC0gVGhlIG1hc2sgdGV4dHVyZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hc2tUZXh0dXJlID0gbnVsbCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiTWFza01hdGVyaWFsXCIsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBtYXNrVGV4dHVyZTogbmV3IFVuaWZvcm0xNShtYXNrVGV4dHVyZSksXG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTE1KG51bGwpLFxuICAgICAgICBzdHJlbmd0aDogbmV3IFVuaWZvcm0xNSgxKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nOCxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IG1hc2tfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29tbW9uX2RlZmF1bHRcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yQ2hhbm5lbCA9IENvbG9yQ2hhbm5lbC5SRUQ7XG4gICAgdGhpcy5tYXNrRnVuY3Rpb24gPSBNYXNrRnVuY3Rpb24uRElTQ0FSRDtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKi9cbiAgc2V0SW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXNrIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IG1hc2tUZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5tYXNrVGV4dHVyZS52YWx1ZSA9IHZhbHVlO1xuICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuTUFTS19QUkVDSVNJT05fSElHSDtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTYpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5NQVNLX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgfVxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXNrIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXNrVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBzZXRNYXNrVGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMubWFza1RleHR1cmUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY29sb3IgY2hhbm5lbCB0byB1c2UgZm9yIG1hc2tpbmcuIERlZmF1bHQgaXMgYENvbG9yQ2hhbm5lbC5SRURgLlxuICAgKlxuICAgKiBAdHlwZSB7Q29sb3JDaGFubmVsfVxuICAgKi9cbiAgc2V0IGNvbG9yQ2hhbm5lbCh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5DT0xPUl9DSEFOTkVMID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY29sb3IgY2hhbm5lbCB0byB1c2UgZm9yIG1hc2tpbmcuIERlZmF1bHQgaXMgYENvbG9yQ2hhbm5lbC5SRURgLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29sb3JDaGFubmVsIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Q29sb3JDaGFubmVsfSB2YWx1ZSAtIFRoZSBjaGFubmVsLlxuICAgKi9cbiAgc2V0Q29sb3JDaGFubmVsKHZhbHVlKSB7XG4gICAgdGhpcy5jb2xvckNoYW5uZWwgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1hc2tpbmcgdGVjaG5pcXVlLiBEZWZhdWx0IGlzIGBNYXNrRnVuY3Rpb24uRElTQ0FSRGAuXG4gICAqXG4gICAqIEB0eXBlIHtNYXNrRnVuY3Rpb259XG4gICAqL1xuICBzZXQgbWFza0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLk1BU0tfRlVOQ1RJT04gPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXNraW5nIHRlY2huaXF1ZS4gRGVmYXVsdCBpcyBgTWFza0Z1bmN0aW9uLkRJU0NBUkRgLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWFza0Z1bmN0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TWFza0Z1bmN0aW9ufSB2YWx1ZSAtIFRoZSBmdW5jdGlvbi5cbiAgICovXG4gIHNldE1hc2tGdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMubWFza0Z1bmN0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtYXNraW5nIGlzIGludmVydGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpbnZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLklOVkVSVEVEICE9PSB2b2lkIDA7XG4gIH1cbiAgc2V0IGludmVydGVkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52ZXJ0ZWQgJiYgIXZhbHVlKSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLklOVkVSVEVEO1xuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5JTlZFUlRFRCA9IFwiMVwiO1xuICAgIH1cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1hc2tpbmcgaXMgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnZlcnRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBtYXNraW5nIGlzIGludmVydGVkLlxuICAgKi9cbiAgaXNJbnZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZlcnRlZDtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtYXNraW5nIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludmVydGVkIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRoZSBtYXNraW5nIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICovXG4gIHNldEludmVydGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pbnZlcnRlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBtYXNrIHN0cmVuZ3RoLlxuICAgKlxuICAgKiBJbmRpdmlkdWFsIG1hc2sgdmFsdWVzIHdpbGwgYmUgY2xhbXBlZCB0byBbMC4wLCAxLjBdLiBIYXMgbm8gZWZmZWN0IHdoZW4gdGhlIG1hc2sgZnVuY3Rpb24gaXMgc2V0IHRvIGBESVNDQVJEYC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zdHJlbmd0aC52YWx1ZTtcbiAgfVxuICBzZXQgc3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWFzayBzdHJlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHN0cmVuZ3RoIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1hc2sgc3RyZW5ndGguXG4gICAqL1xuICBnZXRTdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlbmd0aDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWFzayBzdHJlbmd0aC5cbiAgICpcbiAgICogSGFzIG5vIGVmZmVjdCB3aGVuIHRoZSBtYXNrIGZ1bmN0aW9uIGlzIHNldCB0byBgRElTQ0FSRGAuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzdHJlbmd0aCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWFzayBzdHJlbmd0aC5cbiAgICovXG4gIHNldFN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5zdHJlbmd0aCA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL1NoYWRlclBhc3MuanNcbmltcG9ydCB7IFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTcgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBTaGFkZXJQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgc2hhZGVyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U2hhZGVyTWF0ZXJpYWx9IG1hdGVyaWFsIC0gQSBzaGFkZXIgbWF0ZXJpYWwuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbaW5wdXQ9XCJpbnB1dEJ1ZmZlclwiXSAtIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCBidWZmZXIgdW5pZm9ybS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hdGVyaWFsLCBpbnB1dCA9IFwiaW5wdXRCdWZmZXJcIikge1xuICAgIHN1cGVyKFwiU2hhZGVyUGFzc1wiKTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbmFtZSBvZiB0aGUgaW5wdXQgYnVmZmVyIHVuaWZvcm0uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCAtIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCBidWZmZXIgdW5pZm9ybS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0IGluc3RlYWQuXG4gICAqL1xuICBzZXRJbnB1dChpbnB1dCkge1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLnVuaWZvcm1zO1xuICAgIGlmIChpbnB1dEJ1ZmZlciAhPT0gbnVsbCAmJiB1bmlmb3JtcyAhPT0gdm9pZCAwICYmIHVuaWZvcm1zW3RoaXMuaW5wdXRdICE9PSB2b2lkIDApIHtcbiAgICAgIHVuaWZvcm1zW3RoaXMuaW5wdXRdLnZhbHVlID0gaW5wdXRCdWZmZXIudGV4dHVyZTtcbiAgICB9XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogb3V0cHV0QnVmZmVyKTtcbiAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDAgJiYgZnJhbWVCdWZmZXJUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlNykge1xuICAgICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9kZXB0aC1vZi1maWVsZC5mcmFnXG52YXIgZGVwdGhfb2ZfZmllbGRfZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbmVhckNvbG9yQnVmZmVyO3VuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZmFyQ29sb3JCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBuZWFyQ29sb3JCdWZmZXI7dW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBmYXJDb2xvckJ1ZmZlcjtcbiNlbmRpZlxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBuZWFyQ29DQnVmZmVyO3VuaWZvcm0gbG93cCBzYW1wbGVyMkQgZmFyQ29DQnVmZmVyO3VuaWZvcm0gZmxvYXQgc2NhbGU7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsY29uc3QgaW4gZmxvYXQgZGVwdGgsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzQgY29sb3JOZWFyPXRleHR1cmUyRChuZWFyQ29sb3JCdWZmZXIsdXYpO3ZlYzQgY29sb3JGYXI9dGV4dHVyZTJEKGZhckNvbG9yQnVmZmVyLHV2KTtcbiNpZiBNQVNLX0ZVTkNUSU9OID09IDFcbnZlYzIgY29jTmVhckZhcj12ZWMyKHRleHR1cmUyRChuZWFyQ29DQnVmZmVyLHV2KS5yLGNvbG9yRmFyLmEpO2NvY05lYXJGYXIueD1taW4oY29jTmVhckZhci54KnNjYWxlLDEuMCk7XG4jZWxzZVxudmVjMiBjb2NOZWFyRmFyPXZlYzIodGV4dHVyZTJEKG5lYXJDb0NCdWZmZXIsdXYpLnIsdGV4dHVyZTJEKGZhckNvQ0J1ZmZlcix1dikuZyk7Y29jTmVhckZhcj1taW4oY29jTmVhckZhcipzY2FsZSwxLjApO1xuI2VuZGlmXG52ZWM0IHJlc3VsdD1pbnB1dENvbG9yKigxLjAtY29jTmVhckZhci55KStjb2xvckZhcjtyZXN1bHQ9bWl4KHJlc3VsdCxjb2xvck5lYXIsY29jTmVhckZhci54KTtvdXRwdXRDb2xvcj1yZXN1bHQ7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0RlcHRoT2ZGaWVsZEVmZmVjdC5qc1xudmFyIERlcHRoT2ZGaWVsZEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggb2YgZmllbGQgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53b3JsZEZvY3VzRGlzdGFuY2VdIC0gVGhlIGZvY3VzIGRpc3RhbmNlIGluIHdvcmxkIHVuaXRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud29ybGRGb2N1c1JhbmdlXSAtIFRoZSBmb2N1cyBkaXN0YW5jZSBpbiB3b3JsZCB1bml0cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvY3VzRGlzdGFuY2U9MC4wXSAtIFRoZSBub3JtYWxpemVkIGZvY3VzIGRpc3RhbmNlLiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXNSYW5nZT0wLjFdIC0gVGhlIGZvY3VzIHJhbmdlLiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jYWxMZW5ndGg9MC4xXSAtIERlcHJlY2F0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ib2tlaFNjYWxlPTEuMF0gLSBUaGUgc2NhbGUgb2YgdGhlIGJva2VoIGJsdXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MC41XSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25YIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25ZIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYW1lcmEsIHtcbiAgICBibGVuZEZ1bmN0aW9uLFxuICAgIHdvcmxkRm9jdXNEaXN0YW5jZSxcbiAgICB3b3JsZEZvY3VzUmFuZ2UsXG4gICAgZm9jdXNEaXN0YW5jZSA9IDAsXG4gICAgZm9jYWxMZW5ndGggPSAwLjEsXG4gICAgZm9jdXNSYW5nZSA9IGZvY2FsTGVuZ3RoLFxuICAgIGJva2VoU2NhbGUgPSAxLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDEsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiRGVwdGhPZkZpZWxkRWZmZWN0XCIsIGRlcHRoX29mX2ZpZWxkX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBhdHRyaWJ1dGVzOiBFZmZlY3RBdHRyaWJ1dGUuREVQVEgsXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJuZWFyQ29sb3JCdWZmZXJcIiwgbmV3IFVuaWZvcm0xNihudWxsKV0sXG4gICAgICAgIFtcImZhckNvbG9yQnVmZmVyXCIsIG5ldyBVbmlmb3JtMTYobnVsbCldLFxuICAgICAgICBbXCJuZWFyQ29DQnVmZmVyXCIsIG5ldyBVbmlmb3JtMTYobnVsbCldLFxuICAgICAgICBbXCJmYXJDb0NCdWZmZXJcIiwgbmV3IFVuaWZvcm0xNihudWxsKV0sXG4gICAgICAgIFtcInNjYWxlXCIsIG5ldyBVbmlmb3JtMTYoMSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0OSgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkRvRi5JbnRlcm1lZGlhdGVcIjtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2tlZCA9IHRoaXMucmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQudGV4dHVyZS5uYW1lID0gXCJEb0YuTWFza2VkLkZhclwiO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TmVhciA9IHRoaXMucmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXROZWFyLnRleHR1cmUubmFtZSA9IFwiRG9GLkJva2VoLk5lYXJcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIm5lYXJDb2xvckJ1ZmZlclwiKS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0TmVhci50ZXh0dXJlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0RmFyID0gdGhpcy5yZW5kZXJUYXJnZXQuY2xvbmUoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEZhci50ZXh0dXJlLm5hbWUgPSBcIkRvRi5Cb2tlaC5GYXJcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImZhckNvbG9yQnVmZmVyXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRGYXIudGV4dHVyZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldENvQyA9IHRoaXMucmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRDb0MudGV4dHVyZS5uYW1lID0gXCJEb0YuQ29DXCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJmYXJDb0NCdWZmZXJcIikudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldENvQy50ZXh0dXJlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Q29DQmx1cnJlZCA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DLmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRDb0NCbHVycmVkLnRleHR1cmUubmFtZSA9IFwiRG9GLkNvQy5CbHVycmVkXCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJuZWFyQ29DQnVmZmVyXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRDb0NCbHVycmVkLnRleHR1cmU7XG4gICAgdGhpcy5jb2NQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IENpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwoY2FtZXJhKSk7XG4gICAgY29uc3QgY29jTWF0ZXJpYWwgPSB0aGlzLmNvY01hdGVyaWFsO1xuICAgIGNvY01hdGVyaWFsLmZvY3VzRGlzdGFuY2UgPSBmb2N1c0Rpc3RhbmNlO1xuICAgIGNvY01hdGVyaWFsLmZvY3VzUmFuZ2UgPSBmb2N1c1JhbmdlO1xuICAgIGlmICh3b3JsZEZvY3VzRGlzdGFuY2UgIT09IHZvaWQgMCkge1xuICAgICAgY29jTWF0ZXJpYWwud29ybGRGb2N1c0Rpc3RhbmNlID0gd29ybGRGb2N1c0Rpc3RhbmNlO1xuICAgIH1cbiAgICBpZiAod29ybGRGb2N1c1JhbmdlICE9PSB2b2lkIDApIHtcbiAgICAgIGNvY01hdGVyaWFsLndvcmxkRm9jdXNSYW5nZSA9IHdvcmxkRm9jdXNSYW5nZTtcbiAgICB9XG4gICAgdGhpcy5ibHVyUGFzcyA9IG5ldyBLYXdhc2VCbHVyUGFzcyh7IHJlc29sdXRpb25TY2FsZSwgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCBrZXJuZWxTaXplOiBLZXJuZWxTaXplLk1FRElVTSB9KTtcbiAgICB0aGlzLm1hc2tQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IE1hc2tNYXRlcmlhbCh0aGlzLnJlbmRlclRhcmdldENvQy50ZXh0dXJlKSk7XG4gICAgY29uc3QgbWFza01hdGVyaWFsID0gdGhpcy5tYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gICAgbWFza01hdGVyaWFsLmNvbG9yQ2hhbm5lbCA9IENvbG9yQ2hhbm5lbC5HUkVFTjtcbiAgICB0aGlzLm1hc2tGdW5jdGlvbiA9IE1hc2tGdW5jdGlvbi5NVUxUSVBMWV9SR0I7XG4gICAgdGhpcy5ib2tlaE5lYXJCYXNlUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBCb2tlaE1hdGVyaWFsKGZhbHNlLCB0cnVlKSk7XG4gICAgdGhpcy5ib2tlaE5lYXJCYXNlUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuY29jQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXRDb0NCbHVycmVkLnRleHR1cmU7XG4gICAgdGhpcy5ib2tlaE5lYXJGaWxsUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBCb2tlaE1hdGVyaWFsKHRydWUsIHRydWUpKTtcbiAgICB0aGlzLmJva2VoTmVhckZpbGxQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5jb2NCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldENvQ0JsdXJyZWQudGV4dHVyZTtcbiAgICB0aGlzLmJva2VoRmFyQmFzZVBhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgQm9rZWhNYXRlcmlhbChmYWxzZSwgZmFsc2UpKTtcbiAgICB0aGlzLmJva2VoRmFyQmFzZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmNvY0J1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DLnRleHR1cmU7XG4gICAgdGhpcy5ib2tlaEZhckZpbGxQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IEJva2VoTWF0ZXJpYWwodHJ1ZSwgZmFsc2UpKTtcbiAgICB0aGlzLmJva2VoRmFyRmlsbFBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmNvY0J1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DLnRleHR1cmU7XG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICAgIHRoaXMuYm9rZWhTY2FsZSA9IGJva2VoU2NhbGU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICAgIHRoaXMuY29jTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGNpcmNsZSBvZiBjb25mdXNpb24gdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgY29jVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXRDb0MudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1hc2sgZnVuY3Rpb24uIERlZmF1bHQgaXMgYE1VTFRJUExZX1JHQmAuXG4gICAqXG4gICAqIEB0eXBlIHtNYXNrRnVuY3Rpb259XG4gICAqL1xuICBnZXQgbWFza0Z1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hc2tQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5tYXNrRnVuY3Rpb247XG4gIH1cbiAgc2V0IG1hc2tGdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLm1hc2tGdW5jdGlvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJNQVNLX0ZVTkNUSU9OXCIsIHZhbHVlLnRvRml4ZWQoMCkpO1xuICAgICAgdGhpcy5tYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwubWFza0Z1bmN0aW9uID0gdmFsdWU7XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjaXJjbGUgb2YgY29uZnVzaW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbH1cbiAgICovXG4gIGdldCBjb2NNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2NQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGNpcmNsZSBvZiBjb25mdXNpb24gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb2NNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbH1cbiAgICovXG4gIGdldCBjaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmNvY01hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaXJjbGUgb2YgY29uZnVzaW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29jTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2NNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFzcyB0aGF0IGJsdXJzIHRoZSBmb3JlZ3JvdW5kIENvQyBidWZmZXIgdG8gc29mdGVuIGVkZ2VzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3MgaW5zdGVhZC5cbiAgICogQHJldHVybiB7S2F3YXNlQmx1clBhc3N9IFRoZSBibHVyIHBhc3MuXG4gICAqL1xuICBnZXRCbHVyUGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7UmVzb2x1dGlvbn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGJva2VoIHNjYWxlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJva2VoU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwic2NhbGVcIikudmFsdWU7XG4gIH1cbiAgc2V0IGJva2VoU2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLmJva2VoTmVhckJhc2VQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zY2FsZSA9IHZhbHVlO1xuICAgIHRoaXMuYm9rZWhOZWFyRmlsbFBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLnNjYWxlID0gdmFsdWU7XG4gICAgdGhpcy5ib2tlaEZhckJhc2VQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zY2FsZSA9IHZhbHVlO1xuICAgIHRoaXMuYm9rZWhGYXJGaWxsUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2NhbGUgPSB2YWx1ZTtcbiAgICB0aGlzLm1hc2tQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zdHJlbmd0aCA9IHZhbHVlO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwic2NhbGVcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBib2tlaCBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJva2VoU2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2NhbGUuXG4gICAqL1xuICBnZXRCb2tlaFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmJva2VoU2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJva2VoIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYm9rZWhTY2FsZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc2NhbGUuXG4gICAqL1xuICBzZXRCb2tlaFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5ib2tlaFNjYWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYXV0byBmb2N1cyB0YXJnZXQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0YXJnZXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yM30gVGhlIHRhcmdldC5cbiAgICovXG4gIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGF1dG8gZm9jdXMgdGFyZ2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGFyZ2V0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdmFsdWUgLSBUaGUgdGFyZ2V0LlxuICAgKi9cbiAgc2V0VGFyZ2V0KHZhbHVlKSB7XG4gICAgdGhpcy50YXJnZXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZm9jdXMgZGlzdGFuY2UgZnJvbSB0aGUgY2FtZXJhIHRvIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0LlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBub3JtYWxpemVkIGZvY3VzIGRpc3RhbmNlLlxuICAgKi9cbiAgY2FsY3VsYXRlRm9jdXNEaXN0YW5jZSh0YXJnZXQpIHtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IGNhbWVyYS5wb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldCk7XG4gICAgcmV0dXJuIHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCgtZGlzdGFuY2UsIGNhbWVyYS5uZWFyLCBjYW1lcmEuZmFyKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nNCkge1xuICAgIHRoaXMuY29jTWF0ZXJpYWwuZGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5jb2NNYXRlcmlhbC5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgIGNvbnN0IHJlbmRlclRhcmdldENvQyA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldENvQ0JsdXJyZWQgPSB0aGlzLnJlbmRlclRhcmdldENvQ0JsdXJyZWQ7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0TWFza2VkID0gdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQ7XG4gICAgaWYgKHRoaXMudGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlRm9jdXNEaXN0YW5jZSh0aGlzLnRhcmdldCk7XG4gICAgICB0aGlzLmNvY01hdGVyaWFsLmZvY3VzRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB9XG4gICAgdGhpcy5jb2NQYXNzLnJlbmRlcihyZW5kZXJlciwgbnVsbCwgcmVuZGVyVGFyZ2V0Q29DKTtcbiAgICB0aGlzLmJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0Q29DLCByZW5kZXJUYXJnZXRDb0NCbHVycmVkKTtcbiAgICB0aGlzLm1hc2tQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIHJlbmRlclRhcmdldE1hc2tlZCk7XG4gICAgdGhpcy5ib2tlaEZhckJhc2VQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0TWFza2VkLCByZW5kZXJUYXJnZXQpO1xuICAgIHRoaXMuYm9rZWhGYXJGaWxsUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCwgdGhpcy5yZW5kZXJUYXJnZXRGYXIpO1xuICAgIHRoaXMuYm9rZWhOZWFyQmFzZVBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgcmVuZGVyVGFyZ2V0KTtcbiAgICB0aGlzLmJva2VoTmVhckZpbGxQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0LCB0aGlzLnJlbmRlclRhcmdldE5lYXIpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHcgPSByZXNvbHV0aW9uLndpZHRoLCBoID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgdGhpcy5jb2NQYXNzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5ibHVyUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMubWFza1Bhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEZhci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Q29DLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TmVhci5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Q29DQmx1cnJlZC5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMuYm9rZWhOZWFyQmFzZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5ib2tlaE5lYXJGaWxsUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmJva2VoRmFyQmFzZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5ib2tlaEZhckZpbGxQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICB0aGlzLmNvY1Bhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5tYXNrUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmJva2VoTmVhckJhc2VQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuYm9rZWhOZWFyRmlsbFBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5ib2tlaEZhckJhc2VQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuYm9rZWhGYXJGaWxsUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmJsdXJQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBVbnNpZ25lZEJ5dGVUeXBlOCk7XG4gICAgaWYgKHJlbmRlcmVyLmNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyKSB7XG4gICAgICB0aGlzLmNvY1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmRlZmluZXMuTE9HX0RFUFRIID0gXCIxXCI7XG4gICAgfVxuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXROZWFyLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0RmFyLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChyZW5kZXJlciAhPT0gbnVsbCAmJiByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZTcpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U3O1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldE5lYXIudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U3O1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldEZhci50ZXh0dXJlLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTc7XG4gICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlNztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0RvdFNjcmVlbkVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtMTcsIFZlY3RvcjIgYXMgVmVjdG9yMjkgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9kb3Qtc2NyZWVuLmZyYWdcbnZhciBkb3Rfc2NyZWVuX2RlZmF1bHQgPSBgdW5pZm9ybSB2ZWMyIGFuZ2xlO3VuaWZvcm0gZmxvYXQgc2NhbGU7ZmxvYXQgcGF0dGVybihjb25zdCBpbiB2ZWMyIHV2KXt2ZWMyIHBvaW50PXNjYWxlKnZlYzIoZG90KGFuZ2xlLnl4LHZlYzIodXYueCwtdXYueSkpLGRvdChhbmdsZSx1dikpO3JldHVybihzaW4ocG9pbnQueCkqc2luKHBvaW50LnkpKSo0LjA7fXZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWMzIGNvbG9yPXZlYzMoaW5wdXRDb2xvci5yZ2IqMTAuMC01LjArcGF0dGVybih1dipyZXNvbHV0aW9uKSk7b3V0cHV0Q29sb3I9dmVjNChjb2xvcixpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9Eb3RTY3JlZW5FZmZlY3QuanNcbnZhciBEb3RTY3JlZW5FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRvdCBzY3JlZW4gZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZT0xLjU3XSAtIFRoZSBhbmdsZSBvZiB0aGUgZG90IHBhdHRlcm4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZT0xLjBdIC0gVGhlIHNjYWxlIG9mIHRoZSBkb3QgcGF0dGVybi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiwgYW5nbGUgPSBNYXRoLlBJICogMC41LCBzY2FsZSA9IDEgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJEb3RTY3JlZW5FZmZlY3RcIiwgZG90X3NjcmVlbl9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiYW5nbGVcIiwgbmV3IFVuaWZvcm0xNyhuZXcgVmVjdG9yMjkoKSldLFxuICAgICAgICBbXCJzY2FsZVwiLCBuZXcgVW5pZm9ybTE3KHNjYWxlKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW5nbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYW5nbGUoKSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyh0aGlzLnVuaWZvcm1zLmdldChcImFuZ2xlXCIpLnZhbHVlLnkpO1xuICB9XG4gIHNldCBhbmdsZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYW5nbGVcIikudmFsdWUuc2V0KE1hdGguc2luKHZhbHVlKSwgTWF0aC5jb3ModmFsdWUpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGF0dGVybiBhbmdsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFuZ2xlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAqL1xuICBnZXRBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmdsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcGF0dGVybiBhbmdsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFuZ2xlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICAgKi9cbiAgc2V0QW5nbGUodmFsdWUpIHtcbiAgICB0aGlzLmFuZ2xlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJzY2FsZVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInNjYWxlXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvZnhhYS5mcmFnXG52YXIgZnhhYV9kZWZhdWx0ID0gYCNkZWZpbmUgUVVBTElUWShxKSAoKHEpIDwgNSA/IDEuMCA6ICgocSkgPiA1ID8gKChxKSA8IDEwID8gMi4wIDogKChxKSA8IDExID8gNC4wIDogOC4wKSkgOiAxLjUpKVxuI2RlZmluZSBPTkVfT1ZFUl9UV0VMVkUgMC4wODMzMzMzMzMzMzMzMzMzM1xudmFyeWluZyB2ZWMyIHZVdkRvd247dmFyeWluZyB2ZWMyIHZVdlVwO3ZhcnlpbmcgdmVjMiB2VXZMZWZ0O3ZhcnlpbmcgdmVjMiB2VXZSaWdodDt2YXJ5aW5nIHZlYzIgdlV2RG93bkxlZnQ7dmFyeWluZyB2ZWMyIHZVdlVwUmlnaHQ7dmFyeWluZyB2ZWMyIHZVdlVwTGVmdDt2YXJ5aW5nIHZlYzIgdlV2RG93blJpZ2h0O3ZlYzQgZnhhYShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dil7ZmxvYXQgbHVtYUNlbnRlcj1sdW1pbmFuY2UoaW5wdXRDb2xvci5yZ2IpO2Zsb2F0IGx1bWFEb3duPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2RG93bikucmdiKTtmbG9hdCBsdW1hVXA9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZVcCkucmdiKTtmbG9hdCBsdW1hTGVmdD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdkxlZnQpLnJnYik7ZmxvYXQgbHVtYVJpZ2h0PWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2UmlnaHQpLnJnYik7ZmxvYXQgbHVtYU1pbj1taW4obHVtYUNlbnRlcixtaW4obWluKGx1bWFEb3duLGx1bWFVcCksbWluKGx1bWFMZWZ0LGx1bWFSaWdodCkpKTtmbG9hdCBsdW1hTWF4PW1heChsdW1hQ2VudGVyLG1heChtYXgobHVtYURvd24sbHVtYVVwKSxtYXgobHVtYUxlZnQsbHVtYVJpZ2h0KSkpO2Zsb2F0IGx1bWFSYW5nZT1sdW1hTWF4LWx1bWFNaW47aWYobHVtYVJhbmdlPG1heChFREdFX1RIUkVTSE9MRF9NSU4sbHVtYU1heCpFREdFX1RIUkVTSE9MRF9NQVgpKXtyZXR1cm4gaW5wdXRDb2xvcjt9ZmxvYXQgbHVtYURvd25MZWZ0PWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2RG93bkxlZnQpLnJnYik7ZmxvYXQgbHVtYVVwUmlnaHQ9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZVcFJpZ2h0KS5yZ2IpO2Zsb2F0IGx1bWFVcExlZnQ9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZVcExlZnQpLnJnYik7ZmxvYXQgbHVtYURvd25SaWdodD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdkRvd25SaWdodCkucmdiKTtmbG9hdCBsdW1hRG93blVwPWx1bWFEb3duK2x1bWFVcDtmbG9hdCBsdW1hTGVmdFJpZ2h0PWx1bWFMZWZ0K2x1bWFSaWdodDtmbG9hdCBsdW1hTGVmdENvcm5lcnM9bHVtYURvd25MZWZ0K2x1bWFVcExlZnQ7ZmxvYXQgbHVtYURvd25Db3JuZXJzPWx1bWFEb3duTGVmdCtsdW1hRG93blJpZ2h0O2Zsb2F0IGx1bWFSaWdodENvcm5lcnM9bHVtYURvd25SaWdodCtsdW1hVXBSaWdodDtmbG9hdCBsdW1hVXBDb3JuZXJzPWx1bWFVcFJpZ2h0K2x1bWFVcExlZnQ7ZmxvYXQgZWRnZUhvcml6b250YWw9KGFicygtMi4wKmx1bWFMZWZ0K2x1bWFMZWZ0Q29ybmVycykrYWJzKC0yLjAqbHVtYUNlbnRlcitsdW1hRG93blVwKSoyLjArYWJzKC0yLjAqbHVtYVJpZ2h0K2x1bWFSaWdodENvcm5lcnMpKTtmbG9hdCBlZGdlVmVydGljYWw9KGFicygtMi4wKmx1bWFVcCtsdW1hVXBDb3JuZXJzKSthYnMoLTIuMCpsdW1hQ2VudGVyK2x1bWFMZWZ0UmlnaHQpKjIuMCthYnMoLTIuMCpsdW1hRG93bitsdW1hRG93bkNvcm5lcnMpKTtib29sIGlzSG9yaXpvbnRhbD0oZWRnZUhvcml6b250YWw+PWVkZ2VWZXJ0aWNhbCk7ZmxvYXQgc3RlcExlbmd0aD1pc0hvcml6b250YWw/dGV4ZWxTaXplLnk6dGV4ZWxTaXplLng7ZmxvYXQgbHVtYTE9aXNIb3Jpem9udGFsP2x1bWFEb3duOmx1bWFMZWZ0O2Zsb2F0IGx1bWEyPWlzSG9yaXpvbnRhbD9sdW1hVXA6bHVtYVJpZ2h0O2Zsb2F0IGdyYWRpZW50MT1hYnMobHVtYTEtbHVtYUNlbnRlcik7ZmxvYXQgZ3JhZGllbnQyPWFicyhsdW1hMi1sdW1hQ2VudGVyKTtib29sIGlzMVN0ZWVwZXN0PWdyYWRpZW50MT49Z3JhZGllbnQyO2Zsb2F0IGdyYWRpZW50U2NhbGVkPTAuMjUqbWF4KGdyYWRpZW50MSxncmFkaWVudDIpO2Zsb2F0IGx1bWFMb2NhbEF2ZXJhZ2U9MC4wO2lmKGlzMVN0ZWVwZXN0KXtzdGVwTGVuZ3RoPS1zdGVwTGVuZ3RoO2x1bWFMb2NhbEF2ZXJhZ2U9MC41KihsdW1hMStsdW1hQ2VudGVyKTt9ZWxzZXtsdW1hTG9jYWxBdmVyYWdlPTAuNSoobHVtYTIrbHVtYUNlbnRlcik7fXZlYzIgY3VycmVudFV2PXV2O2lmKGlzSG9yaXpvbnRhbCl7Y3VycmVudFV2LnkrPXN0ZXBMZW5ndGgqMC41O31lbHNle2N1cnJlbnRVdi54Kz1zdGVwTGVuZ3RoKjAuNTt9dmVjMiBvZmZzZXQ9aXNIb3Jpem9udGFsP3ZlYzIodGV4ZWxTaXplLngsMC4wKTp2ZWMyKDAuMCx0ZXhlbFNpemUueSk7dmVjMiB1djE9Y3VycmVudFV2LW9mZnNldCpRVUFMSVRZKDApO3ZlYzIgdXYyPWN1cnJlbnRVditvZmZzZXQqUVVBTElUWSgwKTtmbG9hdCBsdW1hRW5kMT1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2MSkucmdiKTtmbG9hdCBsdW1hRW5kMj1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2MikucmdiKTtsdW1hRW5kMS09bHVtYUxvY2FsQXZlcmFnZTtsdW1hRW5kMi09bHVtYUxvY2FsQXZlcmFnZTtib29sIHJlYWNoZWQxPWFicyhsdW1hRW5kMSk+PWdyYWRpZW50U2NhbGVkO2Jvb2wgcmVhY2hlZDI9YWJzKGx1bWFFbmQyKT49Z3JhZGllbnRTY2FsZWQ7Ym9vbCByZWFjaGVkQm90aD1yZWFjaGVkMSYmcmVhY2hlZDI7aWYoIXJlYWNoZWQxKXt1djEtPW9mZnNldCpRVUFMSVRZKDEpO31pZighcmVhY2hlZDIpe3V2Mis9b2Zmc2V0KlFVQUxJVFkoMSk7fWlmKCFyZWFjaGVkQm90aCl7Zm9yKGludCBpPTI7aTxTQU1QTEVTOysraSl7aWYoIXJlYWNoZWQxKXtsdW1hRW5kMT1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2MSkucmdiKTtsdW1hRW5kMT1sdW1hRW5kMS1sdW1hTG9jYWxBdmVyYWdlO31pZighcmVhY2hlZDIpe2x1bWFFbmQyPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYyKS5yZ2IpO2x1bWFFbmQyPWx1bWFFbmQyLWx1bWFMb2NhbEF2ZXJhZ2U7fXJlYWNoZWQxPWFicyhsdW1hRW5kMSk+PWdyYWRpZW50U2NhbGVkO3JlYWNoZWQyPWFicyhsdW1hRW5kMik+PWdyYWRpZW50U2NhbGVkO3JlYWNoZWRCb3RoPXJlYWNoZWQxJiZyZWFjaGVkMjtpZighcmVhY2hlZDEpe3V2MS09b2Zmc2V0KlFVQUxJVFkoaSk7fWlmKCFyZWFjaGVkMil7dXYyKz1vZmZzZXQqUVVBTElUWShpKTt9aWYocmVhY2hlZEJvdGgpe2JyZWFrO319fWZsb2F0IGRpc3RhbmNlMT1pc0hvcml6b250YWw/KHV2LngtdXYxLngpOih1di55LXV2MS55KTtmbG9hdCBkaXN0YW5jZTI9aXNIb3Jpem9udGFsPyh1djIueC11di54KToodXYyLnktdXYueSk7Ym9vbCBpc0RpcmVjdGlvbjE9ZGlzdGFuY2UxPGRpc3RhbmNlMjtmbG9hdCBkaXN0YW5jZUZpbmFsPW1pbihkaXN0YW5jZTEsZGlzdGFuY2UyKTtmbG9hdCBlZGdlVGhpY2tuZXNzPShkaXN0YW5jZTErZGlzdGFuY2UyKTtib29sIGlzTHVtYUNlbnRlclNtYWxsZXI9bHVtYUNlbnRlcjxsdW1hTG9jYWxBdmVyYWdlO2Jvb2wgY29ycmVjdFZhcmlhdGlvbjE9KGx1bWFFbmQxPDAuMCkhPWlzTHVtYUNlbnRlclNtYWxsZXI7Ym9vbCBjb3JyZWN0VmFyaWF0aW9uMj0obHVtYUVuZDI8MC4wKSE9aXNMdW1hQ2VudGVyU21hbGxlcjtib29sIGNvcnJlY3RWYXJpYXRpb249aXNEaXJlY3Rpb24xP2NvcnJlY3RWYXJpYXRpb24xOmNvcnJlY3RWYXJpYXRpb24yO2Zsb2F0IHBpeGVsT2Zmc2V0PS1kaXN0YW5jZUZpbmFsL2VkZ2VUaGlja25lc3MrMC41O2Zsb2F0IGZpbmFsT2Zmc2V0PWNvcnJlY3RWYXJpYXRpb24/cGl4ZWxPZmZzZXQ6MC4wO2Zsb2F0IGx1bWFBdmVyYWdlPU9ORV9PVkVSX1RXRUxWRSooMi4wKihsdW1hRG93blVwK2x1bWFMZWZ0UmlnaHQpK2x1bWFMZWZ0Q29ybmVycytsdW1hUmlnaHRDb3JuZXJzKTtmbG9hdCBzdWJQaXhlbE9mZnNldDE9Y2xhbXAoYWJzKGx1bWFBdmVyYWdlLWx1bWFDZW50ZXIpL2x1bWFSYW5nZSwwLjAsMS4wKTtmbG9hdCBzdWJQaXhlbE9mZnNldDI9KC0yLjAqc3ViUGl4ZWxPZmZzZXQxKzMuMCkqc3ViUGl4ZWxPZmZzZXQxKnN1YlBpeGVsT2Zmc2V0MTtmbG9hdCBzdWJQaXhlbE9mZnNldEZpbmFsPXN1YlBpeGVsT2Zmc2V0MipzdWJQaXhlbE9mZnNldDIqU1VCUElYRUxfUVVBTElUWTtmaW5hbE9mZnNldD1tYXgoZmluYWxPZmZzZXQsc3ViUGl4ZWxPZmZzZXRGaW5hbCk7dmVjMiBmaW5hbFV2PXV2O2lmKGlzSG9yaXpvbnRhbCl7ZmluYWxVdi55Kz1maW5hbE9mZnNldCpzdGVwTGVuZ3RoO31lbHNle2ZpbmFsVXYueCs9ZmluYWxPZmZzZXQqc3RlcExlbmd0aDt9cmV0dXJuIHRleHR1cmUyRChpbnB1dEJ1ZmZlcixmaW5hbFV2KTt9dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe291dHB1dENvbG9yPWZ4YWEoaW5wdXRDb2xvcix1dik7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvZnhhYS52ZXJ0XG52YXIgZnhhYV9kZWZhdWx0MiA9IGB2YXJ5aW5nIHZlYzIgdlV2RG93bjt2YXJ5aW5nIHZlYzIgdlV2VXA7dmFyeWluZyB2ZWMyIHZVdkxlZnQ7dmFyeWluZyB2ZWMyIHZVdlJpZ2h0O3ZhcnlpbmcgdmVjMiB2VXZEb3duTGVmdDt2YXJ5aW5nIHZlYzIgdlV2VXBSaWdodDt2YXJ5aW5nIHZlYzIgdlV2VXBMZWZ0O3ZhcnlpbmcgdmVjMiB2VXZEb3duUmlnaHQ7dm9pZCBtYWluU3VwcG9ydChjb25zdCBpbiB2ZWMyIHV2KXt2VXZEb3duPXV2K3ZlYzIoMC4wLC0xLjApKnRleGVsU2l6ZTt2VXZVcD11dit2ZWMyKDAuMCwxLjApKnRleGVsU2l6ZTt2VXZSaWdodD11dit2ZWMyKDEuMCwwLjApKnRleGVsU2l6ZTt2VXZMZWZ0PXV2K3ZlYzIoLTEuMCwwLjApKnRleGVsU2l6ZTt2VXZEb3duTGVmdD11dit2ZWMyKC0xLjAsLTEuMCkqdGV4ZWxTaXplO3ZVdlVwUmlnaHQ9dXYrdmVjMigxLjAsMS4wKSp0ZXhlbFNpemU7dlV2VXBMZWZ0PXV2K3ZlYzIoLTEuMCwxLjApKnRleGVsU2l6ZTt2VXZEb3duUmlnaHQ9dXYrdmVjMigxLjAsLTEuMCkqdGV4ZWxTaXplO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9GWEFBRWZmZWN0LmpzXG52YXIgRlhBQUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgRlhBQSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU1JDIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiRlhBQUVmZmVjdFwiLCBmeGFhX2RlZmF1bHQsIHtcbiAgICAgIHZlcnRleFNoYWRlcjogZnhhYV9kZWZhdWx0MixcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBkZWZpbmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIkVER0VfVEhSRVNIT0xEX01JTlwiLCBcIjAuMDMxMlwiXSxcbiAgICAgICAgW1wiRURHRV9USFJFU0hPTERfTUFYXCIsIFwiMC4xMjVcIl0sXG4gICAgICAgIFtcIlNVQlBJWEVMX1FVQUxJVFlcIiwgXCIwLjc1XCJdLFxuICAgICAgICBbXCJTQU1QTEVTXCIsIFwiMTJcIl1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZC4gUmFuZ2UgaXMgWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtaW5FZGdlVGhyZXNob2xkKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLmdldChcIkVER0VfVEhSRVNIT0xEX01JTlwiKSk7XG4gIH1cbiAgc2V0IG1pbkVkZ2VUaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiRURHRV9USFJFU0hPTERfTUlOXCIsIHZhbHVlLnRvRml4ZWQoMTIpKTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gZWRnZSBkZXRlY3Rpb24gdGhyZXNob2xkLiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1heEVkZ2VUaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuZ2V0KFwiRURHRV9USFJFU0hPTERfTUFYXCIpKTtcbiAgfVxuICBzZXQgbWF4RWRnZVRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJFREdFX1RIUkVTSE9MRF9NQVhcIiwgdmFsdWUudG9GaXhlZCgxMikpO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3VicGl4ZWwgYmxlbmQgcXVhbGl0eS4gUmFuZ2UgaXMgWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzdWJwaXhlbFF1YWxpdHkoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuZ2V0KFwiU1VCUElYRUxfUVVBTElUWVwiKSk7XG4gIH1cbiAgc2V0IHN1YnBpeGVsUXVhbGl0eSh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJTVUJQSVhFTF9RVUFMSVRZXCIsIHZhbHVlLnRvRml4ZWQoMTIpKTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIGVkZ2UgZGV0ZWN0aW9uIHNhbXBsZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2FtcGxlcygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5nZXQoXCJTQU1QTEVTXCIpKTtcbiAgfVxuICBzZXQgc2FtcGxlcyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJTQU1QTEVTXCIsIHZhbHVlLnRvRml4ZWQoMCkpO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9HYW1tYUNvcnJlY3Rpb25FZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTE4IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvZ2FtbWEtY29ycmVjdGlvbi5mcmFnXG52YXIgZ2FtbWFfY29ycmVjdGlvbl9kZWZhdWx0ID0gYHVuaWZvcm0gZmxvYXQgZ2FtbWE7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe291dHB1dENvbG9yPUxpbmVhclRvR2FtbWEobWF4KGlucHV0Q29sb3IsMC4wKSxnYW1tYSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0dhbW1hQ29ycmVjdGlvbkVmZmVjdC5qc1xudmFyIEdhbW1hQ29ycmVjdGlvbkVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZ2FtbWEgY29ycmVjdGlvbiBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdhbW1hPTIuMF0gLSBUaGUgZ2FtbWEgZmFjdG9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsIGdhbW1hID0gMiB9ID0ge30pIHtcbiAgICBzdXBlcihcIkdhbW1hQ29ycmVjdGlvbkVmZmVjdFwiLCBnYW1tYV9jb3JyZWN0aW9uX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJnYW1tYVwiLCBuZXcgVW5pZm9ybTE4KGdhbW1hKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0dsaXRjaEVmZmVjdC5qc1xuaW1wb3J0IHsgTmVhcmVzdEZpbHRlciwgUmVwZWF0V3JhcHBpbmcgYXMgUmVwZWF0V3JhcHBpbmcyLCBSR0JBRm9ybWF0IGFzIFJHQkFGb3JtYXQyLCBVbmlmb3JtIGFzIFVuaWZvcm0xOSwgVmVjdG9yMiBhcyBWZWN0b3IyMTAgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VudW1zL0dsaXRjaE1vZGUuanNcbnZhciBHbGl0Y2hNb2RlID0ge1xuICBESVNBQkxFRDogMCxcbiAgU1BPUkFESUM6IDEsXG4gIENPTlNUQU5UX01JTEQ6IDIsXG4gIENPTlNUQU5UX1dJTEQ6IDNcbn07XG5cbi8vIHNyYy90ZXh0dXJlcy9Ob2lzZVRleHR1cmUuanNcbmltcG9ydCB7XG4gIERhdGFUZXh0dXJlLFxuICBSZWRGb3JtYXQsXG4gIFJHRm9ybWF0LFxuICBSR0JBRm9ybWF0LFxuICBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGU5XG59IGZyb20gXCJ0aHJlZVwiO1xuZnVuY3Rpb24gZ2V0Tm9pc2Uoc2l6ZSwgZm9ybWF0LCB0eXBlKSB7XG4gIGNvbnN0IGNoYW5uZWxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgIFtSZWRGb3JtYXQsIDFdLFxuICAgIFtSR0Zvcm1hdCwgMl0sXG4gICAgW1JHQkFGb3JtYXQsIDRdXG4gIF0pO1xuICBsZXQgZGF0YTtcbiAgaWYgKCFjaGFubmVscy5oYXMoZm9ybWF0KSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG5vaXNlIHRleHR1cmUgZm9ybWF0XCIpO1xuICB9XG4gIGlmICh0eXBlID09PSBVbnNpZ25lZEJ5dGVUeXBlOSkge1xuICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplICogY2hhbm5lbHMuZ2V0KGZvcm1hdCkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGRhdGFbaV0gPSBNYXRoLnJhbmRvbSgpICogMjU1ICsgMC41O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShzaXplICogY2hhbm5lbHMuZ2V0KGZvcm1hdCkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGRhdGFbaV0gPSBNYXRoLnJhbmRvbSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbnZhciBOb2lzZVRleHR1cmUgPSBjbGFzcyBleHRlbmRzIERhdGFUZXh0dXJlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbm9pc2UgdGV4dHVyZS5cbiAgICpcbiAgICogU3VwcG9ydGVkIGZvcm1hdHMgYXJlIGBSR0JBRm9ybWF0YCwgYFJlZEZvcm1hdGAgYW5kIGBSR0Zvcm1hdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZm9ybWF0PVJlZEZvcm1hdF0gLSBUaGUgdGV4dHVyZSBmb3JtYXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdHlwZT1VbnNpZ25lZEJ5dGVUeXBlXSAtIFRoZSB0ZXh0dXJlIHR5cGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBmb3JtYXQgPSBSZWRGb3JtYXQsIHR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlOSkge1xuICAgIHN1cGVyKGdldE5vaXNlKHdpZHRoICogaGVpZ2h0LCBmb3JtYXQsIHR5cGUpLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2dsaXRjaC5mcmFnXG52YXIgZ2xpdGNoX2RlZmF1bHQgPSBgdW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBwZXJ0dXJiYXRpb25NYXA7dW5pZm9ybSBib29sIGFjdGl2ZTt1bmlmb3JtIGZsb2F0IGNvbHVtbnM7dW5pZm9ybSBmbG9hdCByYW5kb207dW5pZm9ybSB2ZWMyIHNlZWRzO3VuaWZvcm0gdmVjMiBkaXN0b3J0aW9uO3ZvaWQgbWFpblV2KGlub3V0IHZlYzIgdXYpe2lmKGFjdGl2ZSl7aWYodXYueTxkaXN0b3J0aW9uLngrY29sdW1ucyYmdXYueT5kaXN0b3J0aW9uLngtY29sdW1ucypyYW5kb20pe2Zsb2F0IHN4PWNsYW1wKGNlaWwoc2VlZHMueCksMC4wLDEuMCk7dXYueT1zeCooMS4wLSh1di55K2Rpc3RvcnRpb24ueSkpKygxLjAtc3gpKmRpc3RvcnRpb24ueTt9aWYodXYueDxkaXN0b3J0aW9uLnkrY29sdW1ucyYmdXYueD5kaXN0b3J0aW9uLnktY29sdW1ucypyYW5kb20pe2Zsb2F0IHN5PWNsYW1wKGNlaWwoc2VlZHMueSksMC4wLDEuMCk7dXYueD1zeSpkaXN0b3J0aW9uLngrKDEuMC1zeSkqKDEuMC0odXYueCtkaXN0b3J0aW9uLngpKTt9dmVjMiBub3JtYWw9dGV4dHVyZTJEKHBlcnR1cmJhdGlvbk1hcCx1dipyYW5kb20qcmFuZG9tKS5yZzt1dis9bm9ybWFsKnNlZWRzKihyYW5kb20qMC4yKTt9fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0dsaXRjaEVmZmVjdC5qc1xudmFyIHRleHR1cmVUYWcgPSBcIkdsaXRjaC5HZW5lcmF0ZWRcIjtcbmZ1bmN0aW9uIHJhbmRvbUZsb2F0KGxvdywgaGlnaCkge1xuICByZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KTtcbn1cbnZhciBHbGl0Y2hFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGdsaXRjaCBlZmZlY3QuXG4gICAqXG4gICAqIFRPRE8gQ2hhbmdlIHJhdGlvIHRvIDAuMTUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy5jaHJvbWF0aWNBYmVycmF0aW9uT2Zmc2V0XSAtIEEgY2hyb21hdGljIGFiZXJyYXRpb24gb2Zmc2V0LiBJZiBwcm92aWRlZCwgdGhlIGdsaXRjaCBlZmZlY3Qgd2lsbCBpbmZsdWVuY2UgdGhpcyBvZmZzZXQuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gW29wdGlvbnMuZGVsYXldIC0gVGhlIG1pbmltdW0gYW5kIG1heGltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy5kdXJhdGlvbl0gLSBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBkdXJhdGlvbiBvZiBhIGdsaXRjaCBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLnN0cmVuZ3RoXSAtIFRoZSBzdHJlbmd0aCBvZiB3ZWFrIGFuZCBzdHJvbmcgZ2xpdGNoZXMuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gW29wdGlvbnMucGVydHVyYmF0aW9uTWFwXSAtIEEgcGVydHVyYmF0aW9uIG1hcC4gSWYgbm9uZSBpcyBwcm92aWRlZCwgYSBub2lzZSB0ZXh0dXJlIHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR0U2l6ZT02NF0gLSBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIG5vaXNlIG1hcC4gV2lsbCBiZSBpZ25vcmVkIGlmIGEgcGVydHVyYmF0aW9uIG1hcCBpcyBwcm92aWRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbHVtbnM9MC4wNV0gLSBUaGUgc2NhbGUgb2YgdGhlIGJsb2NreSBnbGl0Y2ggY29sdW1ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhdGlvPTAuODVdIC0gVGhlIHRocmVzaG9sZCBmb3Igc3Ryb25nIGdsaXRjaGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQgPSBudWxsLFxuICAgIGRlbGF5ID0gbmV3IFZlY3RvcjIxMCgxLjUsIDMuNSksXG4gICAgZHVyYXRpb24gPSBuZXcgVmVjdG9yMjEwKDAuNiwgMSksXG4gICAgc3RyZW5ndGggPSBuZXcgVmVjdG9yMjEwKDAuMywgMSksXG4gICAgY29sdW1ucyA9IDAuMDUsXG4gICAgcmF0aW8gPSAwLjg1LFxuICAgIHBlcnR1cmJhdGlvbk1hcCA9IG51bGwsXG4gICAgZHRTaXplID0gNjRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJHbGl0Y2hFZmZlY3RcIiwgZ2xpdGNoX2RlZmF1bHQsIHtcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcInBlcnR1cmJhdGlvbk1hcFwiLCBuZXcgVW5pZm9ybTE5KG51bGwpXSxcbiAgICAgICAgW1wiY29sdW1uc1wiLCBuZXcgVW5pZm9ybTE5KGNvbHVtbnMpXSxcbiAgICAgICAgW1wiYWN0aXZlXCIsIG5ldyBVbmlmb3JtMTkoZmFsc2UpXSxcbiAgICAgICAgW1wicmFuZG9tXCIsIG5ldyBVbmlmb3JtMTkoMSldLFxuICAgICAgICBbXCJzZWVkc1wiLCBuZXcgVW5pZm9ybTE5KG5ldyBWZWN0b3IyMTAoKSldLFxuICAgICAgICBbXCJkaXN0b3J0aW9uXCIsIG5ldyBVbmlmb3JtMTkobmV3IFZlY3RvcjIxMCgpKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgaWYgKHBlcnR1cmJhdGlvbk1hcCA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgbWFwID0gbmV3IE5vaXNlVGV4dHVyZShkdFNpemUsIGR0U2l6ZSwgUkdCQUZvcm1hdDIpO1xuICAgICAgbWFwLm5hbWUgPSB0ZXh0dXJlVGFnO1xuICAgICAgdGhpcy5wZXJ0dXJiYXRpb25NYXAgPSBtYXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGVydHVyYmF0aW9uTWFwID0gcGVydHVyYmF0aW9uTWFwO1xuICAgIH1cbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuZGlzdG9ydGlvbiA9IHRoaXMudW5pZm9ybXMuZ2V0KFwiZGlzdG9ydGlvblwiKS52YWx1ZTtcbiAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuYnJlYWtQb2ludCA9IG5ldyBWZWN0b3IyMTAoXG4gICAgICByYW5kb21GbG9hdCh0aGlzLmRlbGF5LngsIHRoaXMuZGVsYXkueSksXG4gICAgICByYW5kb21GbG9hdCh0aGlzLmR1cmF0aW9uLngsIHRoaXMuZHVyYXRpb24ueSlcbiAgICApO1xuICAgIHRoaXMuc3RyZW5ndGggPSBzdHJlbmd0aDtcbiAgICB0aGlzLm1vZGUgPSBHbGl0Y2hNb2RlLlNQT1JBRElDO1xuICAgIHRoaXMucmF0aW8gPSByYXRpbztcbiAgICB0aGlzLmNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQgPSBjaHJvbWF0aWNBYmVycmF0aW9uT2Zmc2V0O1xuICB9XG4gIC8qKlxuICAgKiBSYW5kb20gbnVtYmVyIHNlZWRzLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBzZWVkcygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJzZWVkc1wiKS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGdsaXRjaCBlZmZlY3QgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImFjdGl2ZVwiKS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGdsaXRjaCBlZmZlY3QgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFjdGl2ZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBnbGl0Y2ggZWZmZWN0IGlzIGFjdGl2ZS5cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1pbmltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluRGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsYXkueDtcbiAgfVxuICBzZXQgbWluRGVsYXkodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5LnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWluaW11bSBkZWxheSBiZXR3ZWVuIGdsaXRjaCBhY3RpdmF0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pbkRlbGF5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1pbmltdW0gZGVsYXkgaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldE1pbkRlbGF5KCkge1xuICAgIHJldHVybiB0aGlzLmRlbGF5Lng7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1pbmltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtaW5EZWxheSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWluaW11bSBkZWxheSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0TWluRGVsYXkodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5LnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4RGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsYXkueTtcbiAgfVxuICBzZXQgbWF4RGVsYXkodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5LnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIGdsaXRjaCBhY3RpdmF0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heERlbGF5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1heGltdW0gZGVsYXkgaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldE1heERlbGF5KCkge1xuICAgIHJldHVybiB0aGlzLmRlbGF5Lnk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiBnbGl0Y2ggYWN0aXZhdGlvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEZWxheSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWF4aW11bSBkZWxheSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0TWF4RGVsYXkodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5LnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1pbmltdW0gZHVyYXRpb24gb2Ygc3BvcmFkaWMgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24ueDtcbiAgfVxuICBzZXQgbWluRHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWluaW11bSBkdXJhdGlvbiBvZiBzcG9yYWRpYyBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pbkR1cmF0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1pbmltdW0gZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldE1pbkR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmR1cmF0aW9uLng7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1pbmltdW0gZHVyYXRpb24gb2Ygc3BvcmFkaWMgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtaW5EdXJhdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWluaW11bSBkdXJhdGlvbiBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0TWluRHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gZHVyYXRpb24gb2Ygc3BvcmFkaWMgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4RHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24ueTtcbiAgfVxuICBzZXQgbWF4RHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uLnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSBkdXJhdGlvbiBvZiBzcG9yYWRpYyBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heER1cmF0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1heGltdW0gZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldE1heER1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmR1cmF0aW9uLnk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heGltdW0gZHVyYXRpb24gb2Ygc3BvcmFkaWMgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEdXJhdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWF4aW11bSBkdXJhdGlvbiBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0TWF4RHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uLnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHN0cmVuZ3RoIG9mIHdlYWsgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluU3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGgueDtcbiAgfVxuICBzZXQgbWluU3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnN0cmVuZ3RoLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyZW5ndGggb2Ygd2VhayBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pblN0cmVuZ3RoIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHN0cmVuZ3RoLlxuICAgKi9cbiAgZ2V0TWluU3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGgueDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3RyZW5ndGggb2Ygd2VhayBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pblN0cmVuZ3RoIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzdHJlbmd0aC5cbiAgICovXG4gIHNldE1pblN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5zdHJlbmd0aC54ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzdHJlbmd0aCBvZiBzdHJvbmcgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4U3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGgueTtcbiAgfVxuICBzZXQgbWF4U3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnN0cmVuZ3RoLnkgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyZW5ndGggb2Ygc3Ryb25nIGdsaXRjaGVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWF4U3RyZW5ndGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3RyZW5ndGguXG4gICAqL1xuICBnZXRNYXhTdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlbmd0aC55O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiBzdHJvbmcgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhTdHJlbmd0aCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc3RyZW5ndGguXG4gICAqL1xuICBzZXRNYXhTdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMuc3RyZW5ndGgueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGdsaXRjaCBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbW9kZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtHbGl0Y2hNb2RlfSBUaGUgbW9kZS5cbiAgICovXG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBnbGl0Y2ggbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1vZGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtHbGl0Y2hNb2RlfSB2YWx1ZSAtIFRoZSBtb2RlLlxuICAgKi9cbiAgc2V0TW9kZSh2YWx1ZSkge1xuICAgIHRoaXMubW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnbGl0Y2ggcmF0aW8uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByYXRpbyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByYXRpby5cbiAgICovXG4gIGdldEdsaXRjaFJhdGlvKCkge1xuICAgIHJldHVybiAxIC0gdGhpcy5yYXRpbztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmF0aW8gb2Ygd2VhayAoMC4wKSBhbmQgc3Ryb25nICgxLjApIGdsaXRjaGVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmF0aW8gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHJhdGlvLiBSYW5nZSBpcyBbMC4wLCAxLjBdLlxuICAgKi9cbiAgc2V0R2xpdGNoUmF0aW8odmFsdWUpIHtcbiAgICB0aGlzLnJhdGlvID0gTWF0aC5taW4oTWF0aC5tYXgoMSAtIHZhbHVlLCAwKSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBnbGl0Y2ggY29sdW1uIHNpemUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29sdW1ucygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJjb2x1bW5zXCIpLnZhbHVlO1xuICB9XG4gIHNldCBjb2x1bW5zKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJjb2x1bW5zXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdsaXRjaCBjb2x1bW4gc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvbHVtbnMgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZ2xpdGNoIGNvbHVtbiBzaXplLlxuICAgKi9cbiAgZ2V0R2xpdGNoQ29sdW1ucygpIHtcbiAgICByZXR1cm4gdGhpcy5jb2x1bW5zO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnbGl0Y2ggY29sdW1uIHNpemUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb2x1bW5zIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBnbGl0Y2ggY29sdW1uIHNpemUuXG4gICAqL1xuICBzZXRHbGl0Y2hDb2x1bW5zKHZhbHVlKSB7XG4gICAgdGhpcy5jb2x1bW5zID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNocm9tYXRpYyBhYmVycmF0aW9uIG9mZnNldC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yMn0gVGhlIG9mZnNldC5cbiAgICovXG4gIGdldENocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hyb21hdGljQWJlcnJhdGlvbk9mZnNldDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY2hyb21hdGljIGFiZXJyYXRpb24gb2Zmc2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY2hyb21hdGljQWJlcnJhdGlvbk9mZnNldCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZhbHVlIC0gVGhlIG9mZnNldC5cbiAgICovXG4gIHNldENocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLmNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBlcnR1cmJhdGlvbiBtYXAuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHBlcnR1cmJhdGlvbk1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJwZXJ0dXJiYXRpb25NYXBcIikudmFsdWU7XG4gIH1cbiAgc2V0IHBlcnR1cmJhdGlvbk1hcCh2YWx1ZSkge1xuICAgIGNvbnN0IGN1cnJlbnRNYXAgPSB0aGlzLnBlcnR1cmJhdGlvbk1hcDtcbiAgICBpZiAoY3VycmVudE1hcCAhPT0gbnVsbCAmJiBjdXJyZW50TWFwLm5hbWUgPT09IHRleHR1cmVUYWcpIHtcbiAgICAgIGN1cnJlbnRNYXAuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB2YWx1ZS5taW5GaWx0ZXIgPSB2YWx1ZS5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuICAgIHZhbHVlLndyYXBTID0gdmFsdWUud3JhcFQgPSBSZXBlYXRXcmFwcGluZzI7XG4gICAgdmFsdWUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJwZXJ0dXJiYXRpb25NYXBcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBwZXJ0dXJiYXRpb24gbWFwLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcGVydHVyYmF0aW9uTWFwIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSBjdXJyZW50IHBlcnR1cmJhdGlvbiBtYXAuXG4gICAqL1xuICBnZXRQZXJ0dXJiYXRpb25NYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVydHVyYmF0aW9uTWFwO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBwZXJ0dXJiYXRpb24gbWFwIHdpdGggdGhlIGdpdmVuIG9uZS5cbiAgICpcbiAgICogVGhlIGN1cnJlbnQgbWFwIHdpbGwgYmUgZGlzcG9zZWQgaWYgaXQgd2FzIGdlbmVyYXRlZCBieSB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHBlcnR1cmJhdGlvbk1hcCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIG5ldyBwZXJ0dXJiYXRpb24gbWFwLlxuICAgKi9cbiAgc2V0UGVydHVyYmF0aW9uTWFwKHZhbHVlKSB7XG4gICAgdGhpcy5wZXJ0dXJiYXRpb25NYXAgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcGVydHVyYmF0aW9uIG1hcC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIE5vaXNlVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ZhbHVlPTY0XSAtIFRoZSB0ZXh0dXJlIHNpemUuXG4gICAqIEByZXR1cm4ge0RhdGFUZXh0dXJlfSBUaGUgcGVydHVyYmF0aW9uIG1hcC5cbiAgICovXG4gIGdlbmVyYXRlUGVydHVyYmF0aW9uTWFwKHZhbHVlID0gNjQpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgTm9pc2VUZXh0dXJlKHZhbHVlLCB2YWx1ZSwgUkdCQUZvcm1hdDIpO1xuICAgIG1hcC5uYW1lID0gdGV4dHVyZVRhZztcbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBjb25zdCBtb2RlID0gdGhpcy5tb2RlO1xuICAgIGNvbnN0IGJyZWFrUG9pbnQgPSB0aGlzLmJyZWFrUG9pbnQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5jaHJvbWF0aWNBYmVycmF0aW9uT2Zmc2V0O1xuICAgIGNvbnN0IHMgPSB0aGlzLnN0cmVuZ3RoO1xuICAgIGxldCB0aW1lID0gdGhpcy50aW1lO1xuICAgIGxldCBhY3RpdmUgPSBmYWxzZTtcbiAgICBsZXQgciA9IDAsIGEgPSAwO1xuICAgIGxldCB0cmlnZ2VyO1xuICAgIGlmIChtb2RlICE9PSBHbGl0Y2hNb2RlLkRJU0FCTEVEKSB7XG4gICAgICBpZiAobW9kZSA9PT0gR2xpdGNoTW9kZS5TUE9SQURJQykge1xuICAgICAgICB0aW1lICs9IGRlbHRhVGltZTtcbiAgICAgICAgdHJpZ2dlciA9IHRpbWUgPiBicmVha1BvaW50Lng7XG4gICAgICAgIGlmICh0aW1lID49IGJyZWFrUG9pbnQueCArIGJyZWFrUG9pbnQueSkge1xuICAgICAgICAgIGJyZWFrUG9pbnQuc2V0KFxuICAgICAgICAgICAgcmFuZG9tRmxvYXQodGhpcy5kZWxheS54LCB0aGlzLmRlbGF5LnkpLFxuICAgICAgICAgICAgcmFuZG9tRmxvYXQodGhpcy5kdXJhdGlvbi54LCB0aGlzLmR1cmF0aW9uLnkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgciA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB0aGlzLnVuaWZvcm1zLmdldChcInJhbmRvbVwiKS52YWx1ZSA9IHI7XG4gICAgICBpZiAodHJpZ2dlciAmJiByID4gdGhpcy5yYXRpbyB8fCBtb2RlID09PSBHbGl0Y2hNb2RlLkNPTlNUQU5UX1dJTEQpIHtcbiAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgciAqPSBzLnkgKiAwLjAzO1xuICAgICAgICBhID0gcmFuZG9tRmxvYXQoLU1hdGguUEksIE1hdGguUEkpO1xuICAgICAgICB0aGlzLnNlZWRzLnNldChyYW5kb21GbG9hdCgtcy55LCBzLnkpLCByYW5kb21GbG9hdCgtcy55LCBzLnkpKTtcbiAgICAgICAgdGhpcy5kaXN0b3J0aW9uLnNldChyYW5kb21GbG9hdCgwLCAxKSwgcmFuZG9tRmxvYXQoMCwgMSkpO1xuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyIHx8IG1vZGUgPT09IEdsaXRjaE1vZGUuQ09OU1RBTlRfTUlMRCkge1xuICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICByICo9IHMueCAqIDAuMDM7XG4gICAgICAgIGEgPSByYW5kb21GbG9hdCgtTWF0aC5QSSwgTWF0aC5QSSk7XG4gICAgICAgIHRoaXMuc2VlZHMuc2V0KHJhbmRvbUZsb2F0KC1zLngsIHMueCksIHJhbmRvbUZsb2F0KC1zLngsIHMueCkpO1xuICAgICAgICB0aGlzLmRpc3RvcnRpb24uc2V0KHJhbmRvbUZsb2F0KDAsIDEpLCByYW5kb21GbG9hdCgwLCAxKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ICE9PSBudWxsKSB7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIG9mZnNldC5zZXQoTWF0aC5jb3MoYSksIE1hdGguc2luKGEpKS5tdWx0aXBseVNjYWxhcihyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldC5zZXQoMCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYWN0aXZlXCIpLnZhbHVlID0gYWN0aXZlO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGdlbmVyYXRlZCByZXNvdXJjZXMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMucGVydHVyYmF0aW9uTWFwO1xuICAgIGlmIChtYXAgIT09IG51bGwgJiYgbWFwLm5hbWUgPT09IHRleHR1cmVUYWcpIHtcbiAgICAgIG1hcC5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9Hb2RSYXlzRWZmZWN0LmpzXG5pbXBvcnQge1xuICBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzYsXG4gIENvbG9yIGFzIENvbG9yMyxcbiAgRGVwdGhUZXh0dXJlIGFzIERlcHRoVGV4dHVyZTIsXG4gIE1hdHJpeDQsXG4gIFNjZW5lIGFzIFNjZW5lMixcbiAgU1JHQkNvbG9yU3BhY2UgYXMgU1JHQkNvbG9yU3BhY2U4LFxuICBVbmlmb3JtIGFzIFVuaWZvcm0yMixcbiAgVmVjdG9yMiBhcyBWZWN0b3IyMTIsXG4gIFZlY3RvcjMsXG4gIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTBcbn0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhNYXNrTWF0ZXJpYWwuanNcbmltcG9ydCB7XG4gIEFsd2F5c0RlcHRoLFxuICBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzUsXG4gIEVxdWFsRGVwdGgsXG4gIEdyZWF0ZXJEZXB0aCxcbiAgR3JlYXRlckVxdWFsRGVwdGgsXG4gIExlc3NEZXB0aCxcbiAgTGVzc0VxdWFsRGVwdGgsXG4gIE5ldmVyRGVwdGgsXG4gIE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzksXG4gIE5vdEVxdWFsRGVwdGgsXG4gIFBlcnNwZWN0aXZlQ2FtZXJhIGFzIFBlcnNwZWN0aXZlQ2FtZXJhMixcbiAgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxMCxcbiAgVW5pZm9ybSBhcyBVbmlmb3JtMjAsXG4gIFZlY3RvcjIgYXMgVmVjdG9yMjExXG59IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZW51bXMvRGVwdGhUZXN0U3RyYXRlZ3kuanNcbnZhciBEZXB0aFRlc3RTdHJhdGVneSA9IHtcbiAgREVGQVVMVDogMCxcbiAgS0VFUF9NQVhfREVQVEg6IDEsXG4gIERJU0NBUkRfTUFYX0RFUFRIOiAyXG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvZGVwdGgtbWFzay5mcmFnXG52YXIgZGVwdGhfbWFza19kZWZhdWx0ID0gYCNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8cGFja2luZz5cbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhCdWZmZXIwO3VuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyMTtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyMDt1bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyMTtcbiNlbmRpZlxudW5pZm9ybSBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7dW5pZm9ybSB2ZWMyIGNhbWVyYU5lYXJGYXI7ZmxvYXQgZ2V0Vmlld1ooY29uc3QgaW4gZmxvYXQgZGVwdGgpe1xuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxucmV0dXJuIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xuI2Vsc2VcbnJldHVybiBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7XG4jZW5kaWZcbn12YXJ5aW5nIHZlYzIgdlV2O3ZvaWQgbWFpbigpe3ZlYzIgZGVwdGg7XG4jaWYgREVQVEhfUEFDS0lOR18wID09IDMyMDFcbmRlcHRoLng9dW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyMCx2VXYpKTtcbiNlbHNlXG5kZXB0aC54PXRleHR1cmUyRChkZXB0aEJ1ZmZlcjAsdlV2KS5yO1xuI2lmZGVmIExPR19ERVBUSFxuZmxvYXQgZD1wb3coMi4wLGRlcHRoLngqbG9nMihjYW1lcmFOZWFyRmFyLnkrMS4wKSktMS4wO2Zsb2F0IGE9Y2FtZXJhTmVhckZhci55LyhjYW1lcmFOZWFyRmFyLnktY2FtZXJhTmVhckZhci54KTtmbG9hdCBiPWNhbWVyYU5lYXJGYXIueSpjYW1lcmFOZWFyRmFyLngvKGNhbWVyYU5lYXJGYXIueC1jYW1lcmFOZWFyRmFyLnkpO2RlcHRoLng9YStiL2Q7XG4jZW5kaWZcbiNlbmRpZlxuI2lmIERFUFRIX1BBQ0tJTkdfMSA9PSAzMjAxXG5kZXB0aC55PXVucGFja1JHQkFUb0RlcHRoKHRleHR1cmUyRChkZXB0aEJ1ZmZlcjEsdlV2KSk7XG4jZWxzZVxuZGVwdGgueT10ZXh0dXJlMkQoZGVwdGhCdWZmZXIxLHZVdikucjtcbiNpZmRlZiBMT0dfREVQVEhcbmZsb2F0IGQ9cG93KDIuMCxkZXB0aC55KmxvZzIoY2FtZXJhTmVhckZhci55KzEuMCkpLTEuMDtmbG9hdCBhPWNhbWVyYU5lYXJGYXIueS8oY2FtZXJhTmVhckZhci55LWNhbWVyYU5lYXJGYXIueCk7ZmxvYXQgYj1jYW1lcmFOZWFyRmFyLnkqY2FtZXJhTmVhckZhci54LyhjYW1lcmFOZWFyRmFyLngtY2FtZXJhTmVhckZhci55KTtkZXB0aC55PWErYi9kO1xuI2VuZGlmXG4jZW5kaWZcbmJvb2wgaXNNYXhEZXB0aD0oZGVwdGgueD09MS4wKTtcbiNpZmRlZiBQRVJTUEVDVElWRV9DQU1FUkFcbmRlcHRoLng9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKGdldFZpZXdaKGRlcHRoLngpLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO2RlcHRoLnk9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKGdldFZpZXdaKGRlcHRoLnkpLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xuI2VuZGlmXG4jaWYgREVQVEhfVEVTVF9TVFJBVEVHWSA9PSAwXG5ib29sIGtlZXA9ZGVwdGhUZXN0KGRlcHRoLngsZGVwdGgueSk7XG4jZWxpZiBERVBUSF9URVNUX1NUUkFURUdZID09IDFcbmJvb2wga2VlcD1pc01heERlcHRofHxkZXB0aFRlc3QoZGVwdGgueCxkZXB0aC55KTtcbiNlbHNlXG5ib29sIGtlZXA9IWlzTWF4RGVwdGgmJmRlcHRoVGVzdChkZXB0aC54LGRlcHRoLnkpO1xuI2VuZGlmXG5pZihrZWVwKXtnbF9GcmFnQ29sb3I9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdik7fWVsc2V7ZGlzY2FyZDt9fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhNYXNrTWF0ZXJpYWwuanNcbnZhciBEZXB0aE1hc2tNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxMCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRlcHRoIG1hc2sgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkRlcHRoTWFza01hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIERFUFRIX0VQU0lMT046IFwiMC4wMDAxXCIsXG4gICAgICAgIERFUFRIX1BBQ0tJTkdfMDogXCIwXCIsXG4gICAgICAgIERFUFRIX1BBQ0tJTkdfMTogXCIwXCIsXG4gICAgICAgIERFUFRIX1RFU1RfU1RSQVRFR1k6IERlcHRoVGVzdFN0cmF0ZWd5LktFRVBfTUFYX0RFUFRIXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMjAobnVsbCksXG4gICAgICAgIGRlcHRoQnVmZmVyMDogbmV3IFVuaWZvcm0yMChudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXIxOiBuZXcgVW5pZm9ybTIwKG51bGwpLFxuICAgICAgICBjYW1lcmFOZWFyRmFyOiBuZXcgVW5pZm9ybTIwKG5ldyBWZWN0b3IyMTEoMSwgMSkpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc5LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhfbWFza19kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb21tb25fZGVmYXVsdFxuICAgIH0pO1xuICAgIHRoaXMuZGVwdGhNb2RlID0gTGVzc0RlcHRoO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcHJpbWFyeSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGRlcHRoQnVmZmVyMCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIwLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmltYXJ5IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZzAodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lOR18wID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmFzZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlcjAgYW5kIGRlcHRoUGFja2luZzAgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIwKGJ1ZmZlciwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc1KSB7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlcjAgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcwID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2Vjb25kYXJ5IGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgZGVwdGhCdWZmZXIxKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlcjEudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNlY29uZGFyeSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcxKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1BBQ0tJTkdfMSA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlciB0aGF0IHdpbGwgYmUgY29tcGFyZWQgd2l0aCB0aGUgYmFzZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlcjEgYW5kIGRlcHRoUGFja2luZzEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIxKGJ1ZmZlciwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc1KSB7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlcjEgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcxID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3RyYXRlZ3kgZm9yIGhhbmRsaW5nIG1heGltdW0gZGVwdGguXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFRlc3RTdHJhdGVneX1cbiAgICovXG4gIGdldCBtYXhEZXB0aFN0cmF0ZWd5KCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkRFUFRIX1RFU1RfU1RSQVRFR1kpO1xuICB9XG4gIHNldCBtYXhEZXB0aFN0cmF0ZWd5KHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1RFU1RfU1RSQVRFR1kgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBtYXhpbXVtIGRlcHRoIHZhbHVlcyBzaG91bGQgYmUgcHJlc2VydmVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heERlcHRoU3RyYXRlZ3kgaW5zdGVhZC5cbiAgICovXG4gIGdldCBrZWVwRmFyKCkge1xuICAgIHJldHVybiB0aGlzLm1heERlcHRoU3RyYXRlZ3k7XG4gIH1cbiAgc2V0IGtlZXBGYXIodmFsdWUpIHtcbiAgICB0aGlzLm1heERlcHRoU3RyYXRlZ3kgPSB2YWx1ZSA/IERlcHRoVGVzdFN0cmF0ZWd5LktFRVBfTUFYX0RFUFRIIDogRGVwdGhUZXN0U3RyYXRlZ3kuRElTQ0FSRF9NQVhfREVQVEg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmF0ZWd5IGZvciBkZWFsaW5nIHdpdGggbWF4aW11bSBkZXB0aCB2YWx1ZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEZXB0aFN0cmF0ZWd5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0RlcHRoVGVzdFN0cmF0ZWd5fSBUaGUgc3RyYXRlZ3kuXG4gICAqL1xuICBnZXRNYXhEZXB0aFN0cmF0ZWd5KCkge1xuICAgIHJldHVybiB0aGlzLm1heERlcHRoU3RyYXRlZ3k7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0cmF0ZWd5IGZvciBkZWFsaW5nIHdpdGggbWF4aW11bSBkZXB0aCB2YWx1ZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEZXB0aFN0cmF0ZWd5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhUZXN0U3RyYXRlZ3l9IHZhbHVlIC0gVGhlIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0TWF4RGVwdGhTdHJhdGVneSh2YWx1ZSkge1xuICAgIHRoaXMubWF4RGVwdGhTdHJhdGVneSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBBIHNtYWxsIGVycm9yIHRocmVzaG9sZCB0aGF0IGlzIHVzZWQgZm9yIGBFcXVhbERlcHRoYCBhbmQgYE5vdEVxdWFsRGVwdGhgIHRlc3RzLiBEZWZhdWx0IGlzIGAxZS00YC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBlcHNpbG9uKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkRFUFRIX0VQU0lMT04pO1xuICB9XG4gIHNldCBlcHNpbG9uKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX0VQU0lMT04gPSB2YWx1ZS50b0ZpeGVkKDE2KTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBlcnJvciB0aHJlc2hvbGQgZm9yIGRlcHRoIGNvbXBhcmlzb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXBzaWxvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBlcnJvciB0aHJlc2hvbGQuXG4gICAqL1xuICBnZXRFcHNpbG9uKCkge1xuICAgIHJldHVybiB0aGlzLmVwc2lsb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGNvbXBhcmlzb24gZXJyb3IgdGhyZXNob2xkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXBzaWxvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IGVycm9yIHRocmVzaG9sZC5cbiAgICovXG4gIHNldEVwc2lsb24odmFsdWUpIHtcbiAgICB0aGlzLmVwc2lsb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIG1vZGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvZW4vY29uc3RhbnRzL01hdGVyaWFsc1xuICAgKiBAdHlwZSB7RGVwdGhNb2Rlc31cbiAgICovXG4gIGdldCBkZXB0aE1vZGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuREVQVEhfTU9ERSk7XG4gIH1cbiAgc2V0IGRlcHRoTW9kZSh2YWx1ZSkge1xuICAgIGxldCBkZXB0aFRlc3Q7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBOZXZlckRlcHRoOlxuICAgICAgICBkZXB0aFRlc3QgPSBcImZhbHNlXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbHdheXNEZXB0aDpcbiAgICAgICAgZGVwdGhUZXN0ID0gXCJ0cnVlXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcXVhbERlcHRoOlxuICAgICAgICBkZXB0aFRlc3QgPSBcImFicyhkMSAtIGQwKSA8PSBERVBUSF9FUFNJTE9OXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBOb3RFcXVhbERlcHRoOlxuICAgICAgICBkZXB0aFRlc3QgPSBcImFicyhkMSAtIGQwKSA+IERFUFRIX0VQU0lMT05cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExlc3NEZXB0aDpcbiAgICAgICAgZGVwdGhUZXN0ID0gXCJkMCA+IGQxXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZXNzRXF1YWxEZXB0aDpcbiAgICAgICAgZGVwdGhUZXN0ID0gXCJkMCA+PSBkMVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR3JlYXRlckVxdWFsRGVwdGg6XG4gICAgICAgIGRlcHRoVGVzdCA9IFwiZDAgPD0gZDFcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdyZWF0ZXJEZXB0aDpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGRlcHRoVGVzdCA9IFwiZDAgPCBkMVwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX01PREUgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMuZGVmaW5lc1tcImRlcHRoVGVzdChkMCwgZDEpXCJdID0gZGVwdGhUZXN0O1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlcHRoIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aE1vZGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7RGVwdGhNb2Rlc30gVGhlIGRlcHRoIG1vZGUuIERlZmF1bHQgaXMgYExlc3NEZXB0aGAuXG4gICAqL1xuICBnZXREZXB0aE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwdGhNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhNb2RlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhNb2Rlc30gbW9kZSAtIFRoZSBkZXB0aCBtb2RlLlxuICAgKi9cbiAgc2V0RGVwdGhNb2RlKG1vZGUpIHtcbiAgICB0aGlzLmRlcHRoTW9kZSA9IG1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcHlDYW1lcmFTZXR0aW5ncyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSBjYW1lcmEuXG4gICAqL1xuICBhZG9wdENhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIHRoaXMuY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIGlmIChjYW1lcmEpIHtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhckZhci52YWx1ZS5zZXQoY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIpO1xuICAgICAgaWYgKGNhbWVyYSBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhMikge1xuICAgICAgICB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBID0gXCIxXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9Hb2RSYXlzTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzEwLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDExLCBVbmlmb3JtIGFzIFVuaWZvcm0yMSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uZ29kLXJheXMuZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2dvZF9yYXlzX2RlZmF1bHQgPSBgI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cbiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2VuZGlmXG51bmlmb3JtIHZlYzIgbGlnaHRQb3NpdGlvbjt1bmlmb3JtIGZsb2F0IGV4cG9zdXJlO3VuaWZvcm0gZmxvYXQgZGVjYXk7dW5pZm9ybSBmbG9hdCBkZW5zaXR5O3VuaWZvcm0gZmxvYXQgd2VpZ2h0O3VuaWZvcm0gZmxvYXQgY2xhbXBNYXg7dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXt2ZWMyIGNvb3JkPXZVdjt2ZWMyIGRlbHRhPWxpZ2h0UG9zaXRpb24tY29vcmQ7ZGVsdGEqPTEuMC9TQU1QTEVTX0ZMT0FUKmRlbnNpdHk7ZmxvYXQgaWxsdW1pbmF0aW9uRGVjYXk9MS4wO3ZlYzQgY29sb3I9dmVjNCgwLjApO2ZvcihpbnQgaT0wO2k8U0FNUExFU19JTlQ7KytpKXtjb29yZCs9ZGVsdGE7dmVjNCB0ZXhlbD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmQpO3RleGVsKj1pbGx1bWluYXRpb25EZWNheSp3ZWlnaHQ7Y29sb3IrPXRleGVsO2lsbHVtaW5hdGlvbkRlY2F5Kj1kZWNheTt9Z2xfRnJhZ0NvbG9yPWNsYW1wKGNvbG9yKmV4cG9zdXJlLDAuMCxjbGFtcE1heCk7XG4jaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50PlxufWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvR29kUmF5c01hdGVyaWFsLmpzXG52YXIgR29kUmF5c01hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDExIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZ29kIHJheXMgbWF0ZXJpYWwuXG4gICAqXG4gICAqIFRPRE8gUmVtb3ZlIGxpZ2h0UG9zaXRpb24gcGFyYW0uXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gbGlnaHRQb3NpdGlvbiAtIERlcHJlY2F0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsaWdodFBvc2l0aW9uKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJHb2RSYXlzTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgU0FNUExFU19JTlQ6IFwiNjBcIixcbiAgICAgICAgU0FNUExFU19GTE9BVDogXCI2MC4wXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0yMShudWxsKSxcbiAgICAgICAgbGlnaHRQb3NpdGlvbjogbmV3IFVuaWZvcm0yMShsaWdodFBvc2l0aW9uKSxcbiAgICAgICAgZGVuc2l0eTogbmV3IFVuaWZvcm0yMSgxKSxcbiAgICAgICAgZGVjYXk6IG5ldyBVbmlmb3JtMjEoMSksXG4gICAgICAgIHdlaWdodDogbmV3IFVuaWZvcm0yMSgxKSxcbiAgICAgICAgZXhwb3N1cmU6IG5ldyBVbmlmb3JtMjEoMSksXG4gICAgICAgIGNsYW1wTWF4OiBuZXcgVW5pZm9ybTIxKDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcxMCxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGNvbnZvbHV0aW9uX2dvZF9yYXlzX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbW1vbl9kZWZhdWx0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGlucHV0IGJ1ZmZlci5cbiAgICovXG4gIHNldElucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2NyZWVuIHNwYWNlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0IGxpZ2h0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubGlnaHRQb3NpdGlvbi52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2NyZWVuIHNwYWNlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsaWdodFBvc2l0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9IFRoZSBwb3NpdGlvbi5cbiAgICovXG4gIGdldExpZ2h0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubGlnaHRQb3NpdGlvbi52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2NyZWVuIHNwYWNlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsaWdodFBvc2l0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdmFsdWUgLSBUaGUgcG9zaXRpb24uXG4gICAqL1xuICBzZXRMaWdodFBvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5saWdodFBvc2l0aW9uLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZW5zaXR5LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGVuc2l0eS52YWx1ZTtcbiAgfVxuICBzZXQgZGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVuc2l0eS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkZW5zaXR5LlxuICAgKi9cbiAgZ2V0RGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kZW5zaXR5LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgZGVuc2l0eS5cbiAgICovXG4gIHNldERlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlbnNpdHkudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlY2F5LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRlY2F5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRlY2F5LnZhbHVlO1xuICB9XG4gIHNldCBkZWNheSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVjYXkudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVjYXkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZWNheSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkZWNheS5cbiAgICovXG4gIGdldERlY2F5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRlY2F5LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZWNheS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlY2F5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBkZWNheS5cbiAgICovXG4gIHNldERlY2F5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZWNheS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2VpZ2h0LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy53ZWlnaHQudmFsdWU7XG4gIH1cbiAgc2V0IHdlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMud2VpZ2h0LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdlaWdodC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHdlaWdodCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB3ZWlnaHQuXG4gICAqL1xuICBnZXRXZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMud2VpZ2h0LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB3ZWlnaHQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB3ZWlnaHQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHdlaWdodC5cbiAgICovXG4gIHNldFdlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMud2VpZ2h0LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBleHBvc3VyZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBleHBvc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5leHBvc3VyZS52YWx1ZTtcbiAgfVxuICBzZXQgZXhwb3N1cmUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmV4cG9zdXJlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV4cG9zdXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXhwb3N1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZXhwb3N1cmUuXG4gICAqL1xuICBnZXRFeHBvc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5leHBvc3VyZS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZXhwb3N1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBleHBvc3VyZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgZXhwb3N1cmUuXG4gICAqL1xuICBzZXRFeHBvc3VyZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZXhwb3N1cmUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gbGlnaHQgaW50ZW5zaXR5LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1heEludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jbGFtcE1heC52YWx1ZTtcbiAgfVxuICBzZXQgbWF4SW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5jbGFtcE1heC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIGxpZ2h0IGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heEludGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBtYXhpbXVtIGxpZ2h0IGludGVuc2l0eS5cbiAgICovXG4gIGdldE1heEludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jbGFtcE1heC52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWF4aW11bSBsaWdodCBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhJbnRlbnNpdHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG1heGltdW0gbGlnaHQgaW50ZW5zaXR5LlxuICAgKi9cbiAgc2V0TWF4SW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5jbGFtcE1heC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNhbXBsZXMoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuU0FNUExFU19JTlQpO1xuICB9XG4gIHNldCBzYW1wbGVzKHZhbHVlKSB7XG4gICAgY29uc3QgcyA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgIHRoaXMuZGVmaW5lcy5TQU1QTEVTX0lOVCA9IHMudG9GaXhlZCgwKTtcbiAgICB0aGlzLmRlZmluZXMuU0FNUExFU19GTE9BVCA9IHMudG9GaXhlZCgxKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2FtcGxlcyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzYW1wbGUgY291bnQuXG4gICAqL1xuICBnZXRTYW1wbGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNhbXBsZXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFtb3VudCBvZiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNhbXBsZXMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNhbXBsZSBjb3VudC5cbiAgICovXG4gIHNldFNhbXBsZXModmFsdWUpIHtcbiAgICB0aGlzLnNhbXBsZXMgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9SZW5kZXJQYXNzLmpzXG52YXIgUmVuZGVyUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJlbmRlciBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBzY2VuZSB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhIHRvIHVzZSB0byByZW5kZXIgdGhlIHNjZW5lLlxuICAgKiBAcGFyYW0ge01hdGVyaWFsfSBbb3ZlcnJpZGVNYXRlcmlhbD1udWxsXSAtIEFuIG92ZXJyaWRlIG1hdGVyaWFsLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCA9IG51bGwpIHtcbiAgICBzdXBlcihcIlJlbmRlclBhc3NcIiwgc2NlbmUsIGNhbWVyYSk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyUGFzcyA9IG5ldyBDbGVhclBhc3MoKTtcbiAgICB0aGlzLm92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyID0gb3ZlcnJpZGVNYXRlcmlhbCA9PT0gbnVsbCA/IG51bGwgOiBuZXcgT3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIob3ZlcnJpZGVNYXRlcmlhbCk7XG4gICAgdGhpcy5pZ25vcmVCYWNrZ3JvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5za2lwU2hhZG93TWFwVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBudWxsO1xuICB9XG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgICB0aGlzLnNjZW5lID0gdmFsdWU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICB9XG4gIGdldCByZW5kZXJUb1NjcmVlbigpIHtcbiAgICByZXR1cm4gc3VwZXIucmVuZGVyVG9TY3JlZW47XG4gIH1cbiAgc2V0IHJlbmRlclRvU2NyZWVuKHZhbHVlKSB7XG4gICAgc3VwZXIucmVuZGVyVG9TY3JlZW4gPSB2YWx1ZTtcbiAgICB0aGlzLmNsZWFyUGFzcy5yZW5kZXJUb1NjcmVlbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBvdmVycmlkZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge01hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IG92ZXJyaWRlTWF0ZXJpYWwoKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHRoaXMub3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXI7XG4gICAgcmV0dXJuIG1hbmFnZXIgIT09IG51bGwgPyBtYW5hZ2VyLm1hdGVyaWFsIDogbnVsbDtcbiAgfVxuICBzZXQgb3ZlcnJpZGVNYXRlcmlhbCh2YWx1ZSkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG1hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgICAgbWFuYWdlci5zZXRNYXRlcmlhbCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyID0gbmV3IE92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgIG1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5vdmVycmlkZU1hdGVyaWFsTWFuYWdlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG92ZXJyaWRlIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtNYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0T3ZlcnJpZGVNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVycmlkZU1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvdmVycmlkZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TWF0ZXJpYWx9IHZhbHVlIC0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgc2V0T3ZlcnJpZGVNYXRlcmlhbCh2YWx1ZSkge1xuICAgIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGFyZ2V0IGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNsZWFyUGFzcy5lbmFibGVkIGluc3RlYWQuXG4gICAqL1xuICBnZXQgY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xlYXJQYXNzLmVuYWJsZWQ7XG4gIH1cbiAgc2V0IGNsZWFyKHZhbHVlKSB7XG4gICAgdGhpcy5jbGVhclBhc3MuZW5hYmxlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzZWxlY3Rpb24uIERlZmF1bHQgaXMgYG51bGxgIChubyByZXN0cmljdGlvbikuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBUaGUgc2VsZWN0aW9uLlxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2VsZWN0aW9uLiBTZXQgdG8gYG51bGxgIHRvIGRpc2FibGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHZhbHVlIC0gVGhlIHNlbGVjdGlvbi5cbiAgICovXG4gIHNldFNlbGVjdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuc2VsZWN0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzY2VuZSBiYWNrZ3JvdW5kIGlzIGRpc2FibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaWdub3JlQmFja2dyb3VuZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBzY2VuZSBiYWNrZ3JvdW5kIGlzIGRpc2FibGVkLlxuICAgKi9cbiAgaXNCYWNrZ3JvdW5kRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWdub3JlQmFja2dyb3VuZDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2NlbmUgYmFja2dyb3VuZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlnbm9yZUJhY2tncm91bmQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIHNjZW5lIGJhY2tncm91bmQgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgc2V0QmFja2dyb3VuZERpc2FibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pZ25vcmVCYWNrZ3JvdW5kID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzaGFkb3cgbWFwIGF1dG8gdXBkYXRlIGlzIGRpc2FibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2tpcFNoYWRvd01hcFVwZGF0ZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBzaGFkb3cgbWFwIHVwZGF0ZSBpcyBkaXNhYmxlZC5cbiAgICovXG4gIGlzU2hhZG93TWFwRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2tpcFNoYWRvd01hcFVwZGF0ZTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93IG1hcCBhdXRvIHVwZGF0ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNraXBTaGFkb3dNYXBVcGRhdGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIHNoYWRvdyBtYXAgYXV0byB1cGRhdGUgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgc2V0U2hhZG93TWFwRGlzYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLnNraXBTaGFkb3dNYXBVcGRhdGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xlYXIgcGFzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNsZWFyUGFzcy5lbmFibGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0NsZWFyUGFzc30gVGhlIGNsZWFyIHBhc3MuXG4gICAqL1xuICBnZXRDbGVhclBhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xlYXJQYXNzO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBzY2VuZS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgIGNvbnN0IG1hc2sgPSBjYW1lcmEubGF5ZXJzLm1hc2s7XG4gICAgY29uc3QgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XG4gICAgY29uc3Qgc2hhZG93TWFwQXV0b1VwZGF0ZSA9IHJlbmRlcmVyLnNoYWRvd01hcC5hdXRvVXBkYXRlO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogaW5wdXRCdWZmZXI7XG4gICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgY2FtZXJhLmxheWVycy5zZXQoc2VsZWN0aW9uLmdldExheWVyKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5za2lwU2hhZG93TWFwVXBkYXRlKSB7XG4gICAgICByZW5kZXJlci5zaGFkb3dNYXAuYXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pZ25vcmVCYWNrZ3JvdW5kIHx8IHRoaXMuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciAhPT0gbnVsbCkge1xuICAgICAgc2NlbmUuYmFja2dyb3VuZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmNsZWFyUGFzcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmNsZWFyUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyKTtcbiAgICB9XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgaWYgKHRoaXMub3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMub3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIucmVuZGVyKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgIH1cbiAgICBjYW1lcmEubGF5ZXJzLm1hc2sgPSBtYXNrO1xuICAgIHNjZW5lLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICAgIHJlbmRlcmVyLnNoYWRvd01hcC5hdXRvVXBkYXRlID0gc2hhZG93TWFwQXV0b1VwZGF0ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9nb2QtcmF5cy5mcmFnXG52YXIgZ29kX3JheXNfZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbWFwO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbWFwO1xuI2VuZGlmXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7b3V0cHV0Q29sb3I9dGV4dHVyZTJEKG1hcCx1dik7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL0dvZFJheXNFZmZlY3QuanNcbnZhciB2ID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG52YXIgbSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWF0cml4NCgpO1xudmFyIEdvZFJheXNFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGdvZCByYXlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IFtjYW1lcmFdIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge01lc2h8UG9pbnRzfSBbbGlnaHRTb3VyY2VdIC0gVGhlIGxpZ2h0IHNvdXJjZS4gTXVzdCBub3Qgd3JpdGUgZGVwdGggYW5kIGhhcyB0byBiZSBmbGFnZ2VkIGFzIHRyYW5zcGFyZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNDUkVFTl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYW1wbGVzPTYwLjBdIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlbnNpdHk9MC45Nl0gLSBUaGUgZGVuc2l0eSBvZiB0aGUgbGlnaHQgcmF5cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlY2F5PTAuOV0gLSBBbiBpbGx1bWluYXRpb24gZGVjYXkgZmFjdG9yLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2VpZ2h0PTAuNF0gLSBBIGxpZ2h0IHJheSB3ZWlnaHQgZmFjdG9yLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZXhwb3N1cmU9MC42XSAtIEEgY29uc3RhbnQgYXR0ZW51YXRpb24gY29lZmZpY2llbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jbGFtcE1heD0xLjBdIC0gQW4gdXBwZXIgYm91bmQgZm9yIHRoZSBzYXR1cmF0aW9uIG9mIHRoZSBvdmVyYWxsIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtLZXJuZWxTaXplfSBbb3B0aW9ucy5rZXJuZWxTaXplPUtlcm5lbFNpemUuU01BTExdIC0gVGhlIGJsdXIga2VybmVsIHNpemUuIEhhcyBubyBlZmZlY3QgaWYgYmx1ciBpcyBkaXNhYmxlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ibHVyPXRydWVdIC0gV2hldGhlciB0aGUgZ29kIHJheXMgc2hvdWxkIGJlIGJsdXJyZWQgdG8gcmVkdWNlIGFydGlmYWN0cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbWVyYSwgbGlnaHRTb3VyY2UsIHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TQ1JFRU4sXG4gICAgc2FtcGxlcyA9IDYwLFxuICAgIGRlbnNpdHkgPSAwLjk2LFxuICAgIGRlY2F5ID0gMC45LFxuICAgIHdlaWdodCA9IDAuNCxcbiAgICBleHBvc3VyZSA9IDAuNixcbiAgICBjbGFtcE1heCA9IDEsXG4gICAgYmx1ciA9IHRydWUsXG4gICAga2VybmVsU2l6ZSA9IEtlcm5lbFNpemUuU01BTEwsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMC41LFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkdvZFJheXNFZmZlY3RcIiwgZ29kX3JheXNfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIGF0dHJpYnV0ZXM6IEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm1hcFwiLCBuZXcgVW5pZm9ybTIyKG51bGwpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLl9saWdodFNvdXJjZSA9IGxpZ2h0U291cmNlO1xuICAgIHRoaXMubGlnaHRTb3VyY2UgPSBsaWdodFNvdXJjZTtcbiAgICB0aGlzLmxpZ2h0U2NlbmUgPSBuZXcgU2NlbmUyKCk7XG4gICAgdGhpcy5zY3JlZW5Qb3NpdGlvbiA9IG5ldyBWZWN0b3IyMTIoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxMCgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5uYW1lID0gXCJHb2RSYXlzLlRhcmdldC5BXCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCID0gdGhpcy5yZW5kZXJUYXJnZXRBLmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUubmFtZSA9IFwiR29kUmF5cy5UYXJnZXQuQlwiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibWFwXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmU7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRMaWdodCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDEwKDEsIDEpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TGlnaHQudGV4dHVyZS5uYW1lID0gXCJHb2RSYXlzLkxpZ2h0XCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRMaWdodC5kZXB0aFRleHR1cmUgPSBuZXcgRGVwdGhUZXh0dXJlMigpO1xuICAgIHRoaXMucmVuZGVyUGFzc0xpZ2h0ID0gbmV3IFJlbmRlclBhc3ModGhpcy5saWdodFNjZW5lLCBjYW1lcmEpO1xuICAgIHRoaXMucmVuZGVyUGFzc0xpZ2h0LmNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQ29sb3IgPSBuZXcgQ29sb3IzKDApO1xuICAgIHRoaXMuY2xlYXJQYXNzID0gbmV3IENsZWFyUGFzcyh0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjMoMCk7XG4gICAgdGhpcy5ibHVyUGFzcyA9IG5ldyBLYXdhc2VCbHVyUGFzcyh7IGtlcm5lbFNpemUgfSk7XG4gICAgdGhpcy5ibHVyUGFzcy5lbmFibGVkID0gYmx1cjtcbiAgICB0aGlzLmRlcHRoTWFza1Bhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgRGVwdGhNYXNrTWF0ZXJpYWwoKSk7XG4gICAgY29uc3QgZGVwdGhNYXNrTWF0ZXJpYWwgPSB0aGlzLmRlcHRoTWFza01hdGVyaWFsO1xuICAgIGRlcHRoTWFza01hdGVyaWFsLmRlcHRoQnVmZmVyMSA9IHRoaXMucmVuZGVyVGFyZ2V0TGlnaHQuZGVwdGhUZXh0dXJlO1xuICAgIGRlcHRoTWFza01hdGVyaWFsLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICAgIHRoaXMuZ29kUmF5c1Bhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgR29kUmF5c01hdGVyaWFsKHRoaXMuc2NyZWVuUG9zaXRpb24pKTtcbiAgICBjb25zdCBnb2RSYXlzTWF0ZXJpYWwgPSB0aGlzLmdvZFJheXNNYXRlcmlhbDtcbiAgICBnb2RSYXlzTWF0ZXJpYWwuZGVuc2l0eSA9IGRlbnNpdHk7XG4gICAgZ29kUmF5c01hdGVyaWFsLmRlY2F5ID0gZGVjYXk7XG4gICAgZ29kUmF5c01hdGVyaWFsLndlaWdodCA9IHdlaWdodDtcbiAgICBnb2RSYXlzTWF0ZXJpYWwuZXhwb3N1cmUgPSBleHBvc3VyZTtcbiAgICBnb2RSYXlzTWF0ZXJpYWwubWF4SW50ZW5zaXR5ID0gY2xhbXBNYXg7XG4gICAgZ29kUmF5c01hdGVyaWFsLnNhbXBsZXMgPSBzYW1wbGVzO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5jYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLnJlbmRlclBhc3NMaWdodC5tYWluQ2FtZXJhID0gdmFsdWU7XG4gICAgdGhpcy5kZXB0aE1hc2tNYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3ModmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaWdodCBzb3VyY2UuXG4gICAqXG4gICAqIEB0eXBlIHtNZXNofFBvaW50c31cbiAgICovXG4gIGdldCBsaWdodFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGlnaHRTb3VyY2U7XG4gIH1cbiAgc2V0IGxpZ2h0U291cmNlKHZhbHVlKSB7XG4gICAgdGhpcy5fbGlnaHRTb3VyY2UgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHZhbHVlLm1hdGVyaWFsLmRlcHRoV3JpdGUgPSBmYWxzZTtcbiAgICAgIHZhbHVlLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsdXIgcGFzcyB0aGF0IHJlZHVjZXMgYWxpYXNpbmcgYXJ0aWZhY3RzIGFuZCBtYWtlcyB0aGUgbGlnaHQgc29mdGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3MgaW5zdGVhZC5cbiAgICogQHJldHVybiB7S2F3YXNlQmx1clBhc3N9IFRoZSBibHVyIHBhc3MuXG4gICAqL1xuICBnZXRCbHVyUGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcztcbiAgfVxuICAvKipcbiAgICogQSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIGludGVybWVkaWF0ZSByZXN1bHQgb2YgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnb2QgcmF5cyB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIG1hc2sgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aE1hc2tNYXRlcmlhbH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBkZXB0aE1hc2tNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZXB0aE1hc2tQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGludGVybmFsIGdvZCByYXlzIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7R29kUmF5c01hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IGdvZFJheXNNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nb2RSYXlzUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdvZCByYXlzIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZ29kUmF5c01hdGVyaWFsIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0dvZFJheXNNYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0R29kUmF5c01hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmdvZFJheXNNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7R29kUmF5c01hdGVyaWFsfSBUaGUgbWF0ZXJpYWwuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24ud2lkdGggaW5zdGVhZC5cbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi5oZWlnaHQgaW5zdGVhZC5cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGl0aGVyaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGRpdGhlcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5nb2RSYXlzTWF0ZXJpYWwuZGl0aGVyaW5nO1xuICB9XG4gIHNldCBkaXRoZXJpbmcodmFsdWUpIHtcbiAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZ29kUmF5c01hdGVyaWFsO1xuICAgIG1hdGVyaWFsLmRpdGhlcmluZyA9IHZhbHVlO1xuICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGdvZCByYXlzIHNob3VsZCBiZSBibHVycmVkIHRvIHJlZHVjZSBhcnRpZmFjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3MuZW5hYmxlZCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGJsdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3MuZW5hYmxlZDtcbiAgfVxuICBzZXQgYmx1cih2YWx1ZSkge1xuICAgIHRoaXMuYmx1clBhc3MuZW5hYmxlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge0tlcm5lbFNpemV9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyUGFzcy5rZXJuZWxTaXplIGluc3RlYWQuXG4gICAqL1xuICBnZXQga2VybmVsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcy5rZXJuZWxTaXplO1xuICB9XG4gIHNldCBrZXJuZWxTaXplKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5rZXJuZWxTaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICovXG4gIGdldFJlc29sdXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgbmV3IHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2NhbGUgPSBzY2FsZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGdvZFJheXNNYXRlcmlhbC5zYW1wbGVzIGluc3RlYWQuXG4gICAqL1xuICBnZXQgc2FtcGxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nb2RSYXlzTWF0ZXJpYWwuc2FtcGxlcztcbiAgfVxuICAvKipcbiAgICogQSBoaWdoZXIgc2FtcGxlIGNvdW50IGltcHJvdmVzIHF1YWxpdHkgYXQgdGhlIGNvc3Qgb2YgcGVyZm9ybWFuY2UuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBnb2RSYXlzTWF0ZXJpYWwuc2FtcGxlcyBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IHNhbXBsZXModmFsdWUpIHtcbiAgICB0aGlzLmdvZFJheXNNYXRlcmlhbC5zYW1wbGVzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nNikge1xuICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVwdGhCdWZmZXIwID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVwdGhQYWNraW5nMCA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgY29uc3QgbGlnaHRTb3VyY2UgPSB0aGlzLmxpZ2h0U291cmNlO1xuICAgIGNvbnN0IHBhcmVudCA9IGxpZ2h0U291cmNlLnBhcmVudDtcbiAgICBjb25zdCBtYXRyaXhBdXRvVXBkYXRlID0gbGlnaHRTb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRBID0gdGhpcy5yZW5kZXJUYXJnZXRBO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldExpZ2h0ID0gdGhpcy5yZW5kZXJUYXJnZXRMaWdodDtcbiAgICBsaWdodFNvdXJjZS5tYXRlcmlhbC5kZXB0aFdyaXRlID0gdHJ1ZTtcbiAgICBsaWdodFNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgbGlnaHRTb3VyY2UudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmICghbWF0cml4QXV0b1VwZGF0ZSkge1xuICAgICAgICBtLmNvcHkobGlnaHRTb3VyY2UubWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGxpZ2h0U291cmNlLm1hdHJpeC5jb3B5KGxpZ2h0U291cmNlLm1hdHJpeFdvcmxkKTtcbiAgICB9XG4gICAgdGhpcy5saWdodFNjZW5lLmFkZChsaWdodFNvdXJjZSk7XG4gICAgdGhpcy5yZW5kZXJQYXNzTGlnaHQucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRMaWdodCk7XG4gICAgdGhpcy5jbGVhclBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRBKTtcbiAgICB0aGlzLmRlcHRoTWFza1Bhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRMaWdodCwgcmVuZGVyVGFyZ2V0QSk7XG4gICAgbGlnaHRTb3VyY2UubWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgIGxpZ2h0U291cmNlLm1hdHJpeEF1dG9VcGRhdGUgPSBtYXRyaXhBdXRvVXBkYXRlO1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmICghbWF0cml4QXV0b1VwZGF0ZSkge1xuICAgICAgICBsaWdodFNvdXJjZS5tYXRyaXguY29weShtKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5hZGQobGlnaHRTb3VyY2UpO1xuICAgIH1cbiAgICB2LnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodFNvdXJjZS5tYXRyaXhXb3JsZCkucHJvamVjdCh0aGlzLmNhbWVyYSk7XG4gICAgdGhpcy5zY3JlZW5Qb3NpdGlvbi5zZXQoXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCgodi54ICsgMSkgKiAwLjUsIC0xKSwgMiksXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCgodi55ICsgMSkgKiAwLjUsIC0xKSwgMilcbiAgICApO1xuICAgIGlmICh0aGlzLmJsdXJQYXNzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuYmx1clBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRBLCByZW5kZXJUYXJnZXRBKTtcbiAgICB9XG4gICAgdGhpcy5nb2RSYXlzUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldEEsIHRoaXMucmVuZGVyVGFyZ2V0Qik7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldExpZ2h0LnNldFNpemUodywgaCk7XG4gICAgdGhpcy5ibHVyUGFzcy5yZXNvbHV0aW9uLmNvcHkocmVzb2x1dGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRoaXMuYmx1clBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5yZW5kZXJQYXNzTGlnaHQuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5kZXB0aE1hc2tQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuZ29kUmF5c1Bhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0TGlnaHQudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKHJlbmRlcmVyICE9PSBudWxsICYmIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlOCkge1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U4O1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U4O1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldExpZ2h0LnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlODtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0dyaWRFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTIzLCBWZWN0b3IyIGFzIFZlY3RvcjIxMyB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2dyaWQuZnJhZ1xudmFyIGdyaWRfZGVmYXVsdCA9IGB1bmlmb3JtIHZlYzIgc2NhbGU7dW5pZm9ybSBmbG9hdCBsaW5lV2lkdGg7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe2Zsb2F0IGdyaWQ9MC41LW1heChhYnMobW9kKHV2Lngqc2NhbGUueCwxLjApLTAuNSksYWJzKG1vZCh1di55KnNjYWxlLnksMS4wKS0wLjUpKTtvdXRwdXRDb2xvcj12ZWM0KHZlYzMoc21vb3Roc3RlcCgwLjAsbGluZVdpZHRoLGdyaWQpKSxpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9HcmlkRWZmZWN0LmpzXG52YXIgR3JpZEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZ3JpZCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uT1ZFUkxBWV0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZT0xLjBdIC0gVGhlIHNjYWxlIG9mIHRoZSBncmlkIHBhdHRlcm4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5saW5lV2lkdGg9MC4wXSAtIFRoZSBsaW5lIHdpZHRoIG9mIHRoZSBncmlkIHBhdHRlcm4uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLk9WRVJMQVksIHNjYWxlID0gMSwgbGluZVdpZHRoID0gMCB9ID0ge30pIHtcbiAgICBzdXBlcihcIkdyaWRFZmZlY3RcIiwgZ3JpZF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wic2NhbGVcIiwgbmV3IFVuaWZvcm0yMyhuZXcgVmVjdG9yMjEzKCkpXSxcbiAgICAgICAgW1wibGluZVdpZHRoXCIsIG5ldyBVbmlmb3JtMjMobGluZVdpZHRoKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIxMygpO1xuICAgIHRoaXMucyA9IDA7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMubCA9IDA7XG4gICAgdGhpcy5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zO1xuICB9XG4gIHNldCBzY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMucyA9IE1hdGgubWF4KHZhbHVlLCAxZS02KTtcbiAgICB0aGlzLnNldFNpemUodGhpcy5yZXNvbHV0aW9uLndpZHRoLCB0aGlzLnJlc29sdXRpb24uaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBncmlkIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZ3JpZCBzY2FsZS5cbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBncmlkIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyBncmlkIHNjYWxlLlxuICAgKi9cbiAgc2V0U2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnNjYWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsaW5lIHdpZHRoLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxpbmVXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5sO1xuICB9XG4gIHNldCBsaW5lV2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLmwgPSB2YWx1ZTtcbiAgICB0aGlzLnNldFNpemUodGhpcy5yZXNvbHV0aW9uLndpZHRoLCB0aGlzLnJlc29sdXRpb24uaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBncmlkIGxpbmUgd2lkdGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsaW5lV2lkdGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZ3JpZCBsaW5lIHdpZHRoLlxuICAgKi9cbiAgZ2V0TGluZVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmxpbmVXaWR0aDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZ3JpZCBsaW5lIHdpZHRoLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbGluZVdpZHRoIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBuZXcgZ3JpZCBsaW5lIHdpZHRoLlxuICAgKi9cbiAgc2V0TGluZVdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5saW5lV2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZSAqIChoZWlnaHQgKiAwLjEyNSk7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJzY2FsZVwiKS52YWx1ZS5zZXQoYXNwZWN0ICogc2NhbGUsIHNjYWxlKTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImxpbmVXaWR0aFwiKS52YWx1ZSA9IHNjYWxlIC8gaGVpZ2h0ICsgdGhpcy5saW5lV2lkdGg7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0h1ZVNhdHVyYXRpb25FZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTI0LCBWZWN0b3IzIGFzIFZlY3RvcjMyIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvaHVlLXNhdHVyYXRpb24uZnJhZ1xudmFyIGh1ZV9zYXR1cmF0aW9uX2RlZmF1bHQgPSBgdW5pZm9ybSB2ZWMzIGh1ZTt1bmlmb3JtIGZsb2F0IHNhdHVyYXRpb247dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzMgY29sb3I9dmVjMyhkb3QoaW5wdXRDb2xvci5yZ2IsaHVlLnh5eiksZG90KGlucHV0Q29sb3IucmdiLGh1ZS56eHkpLGRvdChpbnB1dENvbG9yLnJnYixodWUueXp4KSk7ZmxvYXQgYXZlcmFnZT0oY29sb3Iucitjb2xvci5nK2NvbG9yLmIpLzMuMDt2ZWMzIGRpZmY9YXZlcmFnZS1jb2xvcjtpZihzYXR1cmF0aW9uPjAuMCl7Y29sb3IrPWRpZmYqKDEuMC0xLjAvKDEuMDAxLXNhdHVyYXRpb24pKTt9ZWxzZXtjb2xvcis9ZGlmZiotc2F0dXJhdGlvbjt9b3V0cHV0Q29sb3I9dmVjNChtaW4oY29sb3IsMS4wKSxpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9IdWVTYXR1cmF0aW9uRWZmZWN0LmpzXG52YXIgSHVlU2F0dXJhdGlvbkVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgaHVlL3NhdHVyYXRpb24gZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNSQ10gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5odWU9MC4wXSAtIFRoZSBodWUgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhdHVyYXRpb249MC4wXSAtIFRoZSBzYXR1cmF0aW9uIGZhY3RvciwgcmFuZ2luZyBmcm9tIC0xIHRvIDEsIHdoZXJlIDAgbWVhbnMgbm8gY2hhbmdlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsIGh1ZSA9IDAsIHNhdHVyYXRpb24gPSAwIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiSHVlU2F0dXJhdGlvbkVmZmVjdFwiLCBodWVfc2F0dXJhdGlvbl9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiaHVlXCIsIG5ldyBVbmlmb3JtMjQobmV3IFZlY3RvcjMyKCkpXSxcbiAgICAgICAgW1wic2F0dXJhdGlvblwiLCBuZXcgVW5pZm9ybTI0KHNhdHVyYXRpb24pXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLmh1ZSA9IGh1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNhdHVyYXRpb24uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2F0dXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJzYXR1cmF0aW9uXCIpLnZhbHVlO1xuICB9XG4gIHNldCBzYXR1cmF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJzYXR1cmF0aW9uXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNhdHVyYXRpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzYXR1cmF0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNhdHVyYXRpb24uXG4gICAqL1xuICBnZXRTYXR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNhdHVyYXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNhdHVyYXRpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzYXR1cmF0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzYXR1cmF0aW9uLlxuICAgKi9cbiAgc2V0U2F0dXJhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuc2F0dXJhdGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGh1ZSgpIHtcbiAgICBjb25zdCBodWUgPSB0aGlzLnVuaWZvcm1zLmdldChcImh1ZVwiKS52YWx1ZTtcbiAgICByZXR1cm4gTWF0aC5hY29zKChodWUueCAqIDMgLSAxKSAvIDIpO1xuICB9XG4gIHNldCBodWUodmFsdWUpIHtcbiAgICBjb25zdCBzID0gTWF0aC5zaW4odmFsdWUpLCBjMiA9IE1hdGguY29zKHZhbHVlKTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImh1ZVwiKS52YWx1ZS5zZXQoXG4gICAgICAoMiAqIGMyICsgMSkgLyAzLFxuICAgICAgKC1NYXRoLnNxcnQoMykgKiBzIC0gYzIgKyAxKSAvIDMsXG4gICAgICAoTWF0aC5zcXJ0KDMpICogcyAtIGMyICsgMSkgLyAzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaHVlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaHVlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGh1ZSBpbiByYWRpYW5zLlxuICAgKi9cbiAgZ2V0SHVlKCkge1xuICAgIHJldHVybiB0aGlzLmh1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaHVlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaHVlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBodWUgaW4gcmFkaWFucy5cbiAgICovXG4gIHNldEh1ZSh2YWx1ZSkge1xuICAgIHRoaXMuaHVlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0xlbnNEaXN0b3J0aW9uRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0yNSwgVmVjdG9yMiBhcyBWZWN0b3IyMTQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9sZW5zLWRpc3RvcnRpb24uZnJhZ1xudmFyIGxlbnNfZGlzdG9ydGlvbl9kZWZhdWx0ID0gYHVuaWZvcm0gdmVjMiBkaXN0b3J0aW9uO3VuaWZvcm0gdmVjMiBwcmluY2lwYWxQb2ludDt1bmlmb3JtIHZlYzIgZm9jYWxMZW5ndGg7dW5pZm9ybSBmbG9hdCBza2V3O2Zsb2F0IG1hc2soY29uc3QgaW4gdmVjMiB1dil7cmV0dXJuIGZsb2F0KHV2LnM+PTAuMCYmdXYuczw9MS4wJiZ1di50Pj0wLjAmJnV2LnQ8PTEuMCk7fXZvaWQgbWFpblV2KGlub3V0IHZlYzIgdXYpe3ZlYzIgeG49Mi4wKih1di5zdC0wLjUpO3ZlYzMgeERpc3RvcnRlZD12ZWMzKCgxLjArZGlzdG9ydGlvbipkb3QoeG4seG4pKSp4biwxLjApO21hdDMga2s9bWF0Myh2ZWMzKGZvY2FsTGVuZ3RoLngsMC4wLDAuMCksdmVjMyhza2V3KmZvY2FsTGVuZ3RoLngsZm9jYWxMZW5ndGgueSwwLjApLHZlYzMocHJpbmNpcGFsUG9pbnQueCxwcmluY2lwYWxQb2ludC55LDEuMCkpO3V2PShrayp4RGlzdG9ydGVkKS54eSowLjUrMC41O312b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7b3V0cHV0Q29sb3I9bWFzayh1dikqaW5wdXRDb2xvcjt9YDtcblxuLy8gc3JjL2VmZmVjdHMvTGVuc0Rpc3RvcnRpb25FZmZlY3QuanNcbnZhciBMZW5zRGlzdG9ydGlvbkVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbGVucyBkaXN0b3J0aW9uIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLmRpc3RvcnRpb25dIC0gVGhlIGRpc3RvcnRpb24gdmFsdWUuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gW29wdGlvbnMucHJpbmNpcGFsUG9pbnRdIC0gVGhlIGNlbnRlciBwb2ludC5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy5mb2NhbExlbmd0aF0gLSBUaGUgZm9jYWwgbGVuZ3RoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2tldz0wXSAtIFRoZSBza2V3IHZhbHVlLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGRpc3RvcnRpb24gPSBuZXcgVmVjdG9yMjE0KDAsIDApLFxuICAgIHByaW5jaXBhbFBvaW50ID0gbmV3IFZlY3RvcjIxNCgwLCAwKSxcbiAgICBmb2NhbExlbmd0aCA9IG5ldyBWZWN0b3IyMTQoMSwgMSksXG4gICAgc2tldyA9IDBcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJMZW5zRGlzdG9ydGlvbkVmZmVjdFwiLCBsZW5zX2Rpc3RvcnRpb25fZGVmYXVsdCwge1xuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiZGlzdG9ydGlvblwiLCBuZXcgVW5pZm9ybTI1KGRpc3RvcnRpb24pXSxcbiAgICAgICAgW1wicHJpbmNpcGFsUG9pbnRcIiwgbmV3IFVuaWZvcm0yNShwcmluY2lwYWxQb2ludCldLFxuICAgICAgICBbXCJmb2NhbExlbmd0aFwiLCBuZXcgVW5pZm9ybTI1KGZvY2FsTGVuZ3RoKV0sXG4gICAgICAgIFtcInNrZXdcIiwgbmV3IFVuaWZvcm0yNShza2V3KV1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByYWRpYWwgZGlzdG9ydGlvbiBjb2VmZmljaWVudHMuIERlZmF1bHQgaXMgKDAsIDApLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICovXG4gIGdldCBkaXN0b3J0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImRpc3RvcnRpb25cIikudmFsdWU7XG4gIH1cbiAgc2V0IGRpc3RvcnRpb24odmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImRpc3RvcnRpb25cIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByaW5jaXBhbCBwb2ludC4gRGVmYXVsdCBpcyAoMCwgMCkuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0IHByaW5jaXBhbFBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInByaW5jaXBhbFBvaW50XCIpLnZhbHVlO1xuICB9XG4gIHNldCBwcmluY2lwYWxQb2ludCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwicHJpbmNpcGFsUG9pbnRcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvY2FsIGxlbmd0aC4gRGVmYXVsdCBpcyAoMSwgMSkuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0IGZvY2FsTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImZvY2FsTGVuZ3RoXCIpLnZhbHVlO1xuICB9XG4gIHNldCBmb2NhbExlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZm9jYWxMZW5ndGhcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNrZXcgZmFjdG9yIGluIHJhZGlhbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2tldygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJza2V3XCIpLnZhbHVlO1xuICB9XG4gIHNldCBza2V3KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJza2V3XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0xVVDFERWZmZWN0LmpzXG5pbXBvcnQgeyBGbG9hdFR5cGUsIEhhbGZGbG9hdFR5cGUsIFVuaWZvcm0gYXMgVW5pZm9ybTI2IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvbHV0LTFkLmZyYWdcbnZhciBsdXRfMWRfZGVmYXVsdCA9IGAjaWZkZWYgTFVUX1BSRUNJU0lPTl9ISUdIXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGx1dDtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGx1dDtcbiNlbmRpZlxuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbHV0O1xuI2VuZGlmXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7b3V0cHV0Q29sb3I9dmVjNCh0ZXh0dXJlMkQobHV0LHZlYzIoaW5wdXRDb2xvci5yLDAuNSkpLnIsdGV4dHVyZTJEKGx1dCx2ZWMyKGlucHV0Q29sb3IuZywwLjUpKS5yLHRleHR1cmUyRChsdXQsdmVjMihpbnB1dENvbG9yLmIsMC41KSkucixpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9MVVQxREVmZmVjdC5qc1xudmFyIExVVDFERWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjb2xvciBncmFkaW5nIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBsdXQgLSBUaGUgbG9va3VwIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGx1dCwgeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJMVVQxREVmZmVjdFwiLCBsdXRfMWRfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW1wibHV0XCIsIG5ldyBVbmlmb3JtMjYobnVsbCldXSlcbiAgICB9KTtcbiAgICB0aGlzLmx1dCA9IGx1dDtcbiAgfVxuICAvKipcbiAgICogVGhlIExVVC5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgbHV0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImx1dFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgbHV0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJsdXRcIikudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgKHZhbHVlLnR5cGUgPT09IEZsb2F0VHlwZSB8fCB2YWx1ZS50eXBlID09PSBIYWxmRmxvYXRUeXBlKSkge1xuICAgICAgdGhpcy5kZWZpbmVzLnNldChcIkxVVF9QUkVDSVNJT05fSElHSFwiLCBcIjFcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9MVVQzREVmZmVjdC5qc1xuaW1wb3J0IHtcbiAgRGF0YTNEVGV4dHVyZSBhcyBEYXRhM0RUZXh0dXJlMixcbiAgRmxvYXRUeXBlIGFzIEZsb2F0VHlwZTMsXG4gIEhhbGZGbG9hdFR5cGUgYXMgSGFsZkZsb2F0VHlwZTIsXG4gIExpbmVhckZpbHRlciBhcyBMaW5lYXJGaWx0ZXI0LFxuICBOZWFyZXN0RmlsdGVyIGFzIE5lYXJlc3RGaWx0ZXIyLFxuICBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTEwLFxuICBVbmlmb3JtIGFzIFVuaWZvcm0yNyxcbiAgVmVjdG9yMyBhcyBWZWN0b3IzNFxufSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL3RleHR1cmVzL2x1dC9Mb29rdXBUZXh0dXJlLmpzXG5pbXBvcnQge1xuICBDb2xvciBhcyBDb2xvcjQsXG4gIENsYW1wVG9FZGdlV3JhcHBpbmcsXG4gIERhdGFUZXh0dXJlIGFzIERhdGFUZXh0dXJlMixcbiAgRGF0YTNEVGV4dHVyZSxcbiAgRmxvYXRUeXBlIGFzIEZsb2F0VHlwZTIsXG4gIExpbmVhckZpbHRlciBhcyBMaW5lYXJGaWx0ZXIzLFxuICBMaW5lYXJTUkdCQ29sb3JTcGFjZSBhcyBMaW5lYXJTUkdCQ29sb3JTcGFjZTMsXG4gIFJHQkFGb3JtYXQgYXMgUkdCQUZvcm1hdDMsXG4gIFNSR0JDb2xvclNwYWNlIGFzIFNSR0JDb2xvclNwYWNlOSxcbiAgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlMTAsXG4gIFZlY3RvcjMgYXMgVmVjdG9yMzNcbn0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lbnVtcy9MVVRPcGVyYXRpb24uanNcbnZhciBMVVRPcGVyYXRpb24gPSB7XG4gIFNDQUxFX1VQOiBcImx1dC5zY2FsZXVwXCJcbn07XG5cbi8vIHNyYy90ZXh0dXJlcy9SYXdJbWFnZURhdGEuanNcbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0LCBkYXRhKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBJbWFnZSkge1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKGRhdGEsIDAsIDApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgIGltYWdlRGF0YS5kYXRhLnNldChkYXRhKTtcbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICB9XG4gIHJldHVybiBjYW52YXM7XG59XG52YXIgUmF3SW1hZ2VEYXRhID0gY2xhc3MgX1Jhd0ltYWdlRGF0YSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGltYWdlIGRhdGEgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIC0gVGhlIHdpZHRoIG9mIHRoZSBpbWFnZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gLSBUaGUgaGVpZ2h0IG9mIHRoZSBpbWFnZS5cbiAgICogQHBhcmFtIHtVaW50OENsYW1wZWRBcnJheX0gW2RhdGE9bnVsbF0gLSBUaGUgaW1hZ2UgZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpZHRoID0gMCwgaGVpZ2h0ID0gMCwgZGF0YSA9IG51bGwpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhbnZhcyBmcm9tIHRoaXMgaW1hZ2UgZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7Q2FudmFzfSBUaGUgY2FudmFzLCBvciBudWxsIGlmIGl0IGNvdWxkbid0IGJlIGNyZWF0ZWQuXG4gICAqL1xuICB0b0NhbnZhcygpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IGNyZWF0ZUNhbnZhcyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5kYXRhKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbWFnZSBkYXRhIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtJbWFnZURhdGF8SW1hZ2V9IGltYWdlIC0gQW4gaW1hZ2Ugb3IgcGxhaW4gaW1hZ2UgZGF0YS5cbiAgICogQHJldHVybiB7UmF3SW1hZ2VEYXRhfSBUaGUgaW1hZ2UgZGF0YS5cbiAgICovXG4gIHN0YXRpYyBmcm9tKGltYWdlKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBpbWFnZTtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZSkge1xuICAgICAgY29uc3QgY2FudmFzID0gY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQsIGltYWdlKTtcbiAgICAgIGlmIChjYW52YXMgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gaW1hZ2UuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfUmF3SW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQsIGRhdGEpO1xuICB9XG59O1xuXG4vLyB0ZW1wL2x1dC93b3JrZXIudHh0XG52YXIgd29ya2VyX2RlZmF1bHQgPSAnXCJ1c2Ugc3RyaWN0XCI7KCgpPT57dmFyIE89e1NDQUxFX1VQOlwibHV0LnNjYWxldXBcIn07dmFyIF89W25ldyBGbG9hdDMyQXJyYXkoMyksbmV3IEZsb2F0MzJBcnJheSgzKV0sbj1bbmV3IEZsb2F0MzJBcnJheSgzKSxuZXcgRmxvYXQzMkFycmF5KDMpLG5ldyBGbG9hdDMyQXJyYXkoMyksbmV3IEZsb2F0MzJBcnJheSgzKV0sWj1bW25ldyBGbG9hdDMyQXJyYXkoWzAsMCwwXSksbmV3IEZsb2F0MzJBcnJheShbMSwwLDBdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxXSldLFtuZXcgRmxvYXQzMkFycmF5KFswLDAsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwwXSksbmV3IEZsb2F0MzJBcnJheShbMSwwLDFdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMV0pXSxbbmV3IEZsb2F0MzJBcnJheShbMCwwLDBdKSxuZXcgRmxvYXQzMkFycmF5KFswLDAsMV0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwxXSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDFdKV0sW25ldyBGbG9hdDMyQXJyYXkoWzAsMCwwXSksbmV3IEZsb2F0MzJBcnJheShbMCwxLDBdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxXSldLFtuZXcgRmxvYXQzMkFycmF5KFswLDAsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzAsMSwwXSksbmV3IEZsb2F0MzJBcnJheShbMCwxLDFdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMV0pXSxbbmV3IEZsb2F0MzJBcnJheShbMCwwLDBdKSxuZXcgRmxvYXQzMkFycmF5KFswLDAsMV0pLG5ldyBGbG9hdDMyQXJyYXkoWzAsMSwxXSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDFdKV1dO2Z1bmN0aW9uIGQoYSx0LHIsbSl7bGV0IGk9clswXS10WzBdLGU9clsxXS10WzFdLHk9clsyXS10WzJdLGg9YVswXS10WzBdLEE9YVsxXS10WzFdLHc9YVsyXS10WzJdLGM9ZSp3LXkqQSxsPXkqaC1pKncseD1pKkEtZSpoLHU9TWF0aC5zcXJ0KGMqYytsKmwreCp4KSxiPXUqLjUscz1jL3UsRj1sL3UsZj14L3UscD0tKGFbMF0qcythWzFdKkYrYVsyXSpmKSxNPW1bMF0qcyttWzFdKkYrbVsyXSpmO3JldHVybiBNYXRoLmFicyhNK3ApKmIvM31mdW5jdGlvbiBWKGEsdCxyLG0saSxlKXtsZXQgeT0ocittKnQraSp0KnQpKjQ7ZVswXT1hW3krMF0sZVsxXT1hW3krMV0sZVsyXT1hW3krMl19ZnVuY3Rpb24gayhhLHQscixtLGksZSl7bGV0IHk9cioodC0xKSxoPW0qKHQtMSksQT1pKih0LTEpLHc9TWF0aC5mbG9vcih5KSxjPU1hdGguZmxvb3IoaCksbD1NYXRoLmZsb29yKEEpLHg9TWF0aC5jZWlsKHkpLHU9TWF0aC5jZWlsKGgpLGI9TWF0aC5jZWlsKEEpLHM9eS13LEY9aC1jLGY9QS1sO2lmKHc9PT15JiZjPT09aCYmbD09PUEpVihhLHQseSxoLEEsZSk7ZWxzZXtsZXQgcDtzPj1GJiZGPj1mP3A9WlswXTpzPj1mJiZmPj1GP3A9WlsxXTpmPj1zJiZzPj1GP3A9WlsyXTpGPj1zJiZzPj1mP3A9WlszXTpGPj1mJiZmPj1zP3A9Wls0XTpmPj1GJiZGPj1zJiYocD1aWzVdKTtsZXRbTSxnLFgsWV09cCxQPV9bMF07UFswXT1zLFBbMV09RixQWzJdPWY7bGV0IG89X1sxXSxMPXgtdyxTPXUtYyxVPWItbDtvWzBdPUwqTVswXSt3LG9bMV09UypNWzFdK2Msb1syXT1VKk1bMl0rbCxWKGEsdCxvWzBdLG9bMV0sb1syXSxuWzBdKSxvWzBdPUwqZ1swXSt3LG9bMV09UypnWzFdK2Msb1syXT1VKmdbMl0rbCxWKGEsdCxvWzBdLG9bMV0sb1syXSxuWzFdKSxvWzBdPUwqWFswXSt3LG9bMV09UypYWzFdK2Msb1syXT1VKlhbMl0rbCxWKGEsdCxvWzBdLG9bMV0sb1syXSxuWzJdKSxvWzBdPUwqWVswXSt3LG9bMV09UypZWzFdK2Msb1syXT1VKllbMl0rbCxWKGEsdCxvWzBdLG9bMV0sb1syXSxuWzNdKTtsZXQgVD1kKGcsWCxZLFApKjYscT1kKE0sWCxZLFApKjYsQz1kKE0sZyxZLFApKjYsRT1kKE0sZyxYLFApKjY7blswXVswXSo9VCxuWzBdWzFdKj1ULG5bMF1bMl0qPVQsblsxXVswXSo9cSxuWzFdWzFdKj1xLG5bMV1bMl0qPXEsblsyXVswXSo9QyxuWzJdWzFdKj1DLG5bMl1bMl0qPUMsblszXVswXSo9RSxuWzNdWzFdKj1FLG5bM11bMl0qPUUsZVswXT1uWzBdWzBdK25bMV1bMF0rblsyXVswXStuWzNdWzBdLGVbMV09blswXVsxXStuWzFdWzFdK25bMl1bMV0rblszXVsxXSxlWzJdPW5bMF1bMl0rblsxXVsyXStuWzJdWzJdK25bM11bMl19fXZhciB2PWNsYXNze3N0YXRpYyBleHBhbmQodCxyKXtsZXQgbT1NYXRoLmNicnQodC5sZW5ndGgvNCksaT1uZXcgRmxvYXQzMkFycmF5KDMpLGU9bmV3IHQuY29uc3RydWN0b3IocioqMyo0KSx5PXQgaW5zdGFuY2VvZiBVaW50OEFycmF5PzI1NToxLGg9cioqMixBPTEvKHItMSk7Zm9yKGxldCB3PTA7dzxyOysrdylmb3IobGV0IGM9MDtjPHI7KytjKWZvcihsZXQgbD0wO2w8cjsrK2wpe2xldCB4PWwqQSx1PWMqQSxiPXcqQSxzPU1hdGgucm91bmQobCtjKnIrdypoKSo0O2sodCxtLHgsdSxiLGkpLGVbcyswXT1pWzBdLGVbcysxXT1pWzFdLGVbcysyXT1pWzJdLGVbcyszXT15fXJldHVybiBlfX07c2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGE9PntsZXQgdD1hLmRhdGEscj10LmRhdGE7c3dpdGNoKHQub3BlcmF0aW9uKXtjYXNlIE8uU0NBTEVfVVA6cj12LmV4cGFuZChyLHQuc2l6ZSk7YnJlYWt9cG9zdE1lc3NhZ2Uocixbci5idWZmZXJdKSxjbG9zZSgpfSk7fSkoKTtcXG4nO1xuXG4vLyBzcmMvdGV4dHVyZXMvbHV0L0xvb2t1cFRleHR1cmUuanNcbnZhciBjID0gLyogQF9fUFVSRV9fICovIG5ldyBDb2xvcjQoKTtcbnZhciBMb29rdXBUZXh0dXJlID0gY2xhc3MgX0xvb2t1cFRleHR1cmUgZXh0ZW5kcyBEYXRhM0RUZXh0dXJlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBjdWJpYyAzRCBsb29rdXAgdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUeXBlZEFycmF5fSBkYXRhIC0gVGhlIHBpeGVsIGRhdGEuIFRoZSBkZWZhdWx0IGZvcm1hdCBpcyBSR0JBLlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSAtIFRoZSBzaWRlbGVuZ3RoLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSwgc2l6ZSkge1xuICAgIHN1cGVyKGRhdGEsIHNpemUsIHNpemUsIHNpemUpO1xuICAgIHRoaXMudHlwZSA9IEZsb2F0VHlwZTI7XG4gICAgdGhpcy5mb3JtYXQgPSBSR0JBRm9ybWF0MztcbiAgICB0aGlzLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjM7XG4gICAgdGhpcy5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXIzO1xuICAgIHRoaXMud3JhcFMgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuICAgIHRoaXMud3JhcFQgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuICAgIHRoaXMud3JhcFIgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuICAgIHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmNvbG9yU3BhY2UgPSBMaW5lYXJTUkdCQ29sb3JTcGFjZTM7XG4gICAgdGhpcy5kb21haW5NaW4gPSBuZXcgVmVjdG9yMzMoMCwgMCwgMCk7XG4gICAgdGhpcy5kb21haW5NYXggPSBuZXcgVmVjdG9yMzMoMSwgMSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgTG9va3VwVGV4dHVyZTNELlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBpc0xvb2t1cFRleHR1cmUzRCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2NhbGVzIHRoaXMgTFVUIHVwIHRvIGEgZ2l2ZW4gdGFyZ2V0IHNpemUgdXNpbmcgdGV0cmFoZWRyYWwgaW50ZXJwb2xhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgLSBUaGUgdGFyZ2V0IHNpZGVsZW5ndGguXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RyYW5zZmVyRGF0YT10cnVlXSAtIEV4dHJhIGZhc3QgbW9kZS4gU2V0IHRvIGZhbHNlIHRvIGtlZXAgdGhlIG9yaWdpbmFsIGRhdGEgaW50YWN0LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPExvb2t1cFRleHR1cmU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgbmV3IExVVCB1cG9uIGNvbXBsZXRpb24uXG4gICAqL1xuICBzY2FsZVVwKHNpemUsIHRyYW5zZmVyRGF0YSA9IHRydWUpIHtcbiAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKHNpemUgPD0gaW1hZ2Uud2lkdGgpIHtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJUaGUgdGFyZ2V0IHNpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gdGhlIGN1cnJlbnQgc2l6ZVwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHdvcmtlclVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dvcmtlcl9kZWZhdWx0XSwge1xuICAgICAgICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVSTCk7XG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGV2ZW50KSA9PiByZWplY3QoZXZlbnQuZXJyb3IpKTtcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGx1dCA9IG5ldyBfTG9va3VwVGV4dHVyZShldmVudC5kYXRhLCBzaXplKTtcbiAgICAgICAgICB0aGlzLmNvbG9yU3BhY2UgPSBsdXQuY29sb3JTcGFjZTtcbiAgICAgICAgICBsdXQudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgICBsdXQubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlclVSTCk7XG4gICAgICAgICAgcmVzb2x2ZShsdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHJhbnNmZXJMaXN0ID0gdHJhbnNmZXJEYXRhID8gW2ltYWdlLmRhdGEuYnVmZmVyXSA6IFtdO1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIG9wZXJhdGlvbjogTFVUT3BlcmF0aW9uLlNDQUxFX1VQLFxuICAgICAgICAgIGRhdGE6IGltYWdlLmRhdGEsXG4gICAgICAgICAgc2l6ZVxuICAgICAgICB9LCB0cmFuc2Zlckxpc3QpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBnaXZlbiBMVVQgdG8gdGhpcyBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TG9va3VwVGV4dHVyZX0gbHV0IC0gQSBMVVQuIE11c3QgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zLCB0eXBlIGFuZCBmb3JtYXQgYXMgdGhpcyBMVVQuXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoaXMgdGV4dHVyZS5cbiAgICovXG4gIGFwcGx5TFVUKGx1dCkge1xuICAgIGNvbnN0IGltZzAgPSB0aGlzLmltYWdlO1xuICAgIGNvbnN0IGltZzEgPSBsdXQuaW1hZ2U7XG4gICAgY29uc3Qgc2l6ZTAgPSBNYXRoLm1pbihpbWcwLndpZHRoLCBpbWcwLmhlaWdodCwgaW1nMC5kZXB0aCk7XG4gICAgY29uc3Qgc2l6ZTEgPSBNYXRoLm1pbihpbWcxLndpZHRoLCBpbWcxLmhlaWdodCwgaW1nMS5kZXB0aCk7XG4gICAgaWYgKHNpemUwICE9PSBzaXplMSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlNpemUgbWlzbWF0Y2hcIik7XG4gICAgfSBlbHNlIGlmIChsdXQudHlwZSAhPT0gRmxvYXRUeXBlMiB8fCB0aGlzLnR5cGUgIT09IEZsb2F0VHlwZTIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJCb3RoIExVVHMgbXVzdCBiZSBGbG9hdFR5cGUgdGV4dHVyZXNcIik7XG4gICAgfSBlbHNlIGlmIChsdXQuZm9ybWF0ICE9PSBSR0JBRm9ybWF0MyB8fCB0aGlzLmZvcm1hdCAhPT0gUkdCQUZvcm1hdDMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJCb3RoIExVVHMgbXVzdCBiZSBSR0JBIHRleHR1cmVzXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkYXRhMCA9IGltZzAuZGF0YTtcbiAgICAgIGNvbnN0IGRhdGExID0gaW1nMS5kYXRhO1xuICAgICAgY29uc3Qgc2l6ZSA9IHNpemUwO1xuICAgICAgY29uc3Qgc2l6ZVNxID0gc2l6ZSAqKiAyO1xuICAgICAgY29uc3QgcyA9IHNpemUgLSAxO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzaXplICoqIDM7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgY29uc3QgaTQgPSBpICogNDtcbiAgICAgICAgY29uc3QgciA9IGRhdGEwW2k0ICsgMF0gKiBzO1xuICAgICAgICBjb25zdCBnID0gZGF0YTBbaTQgKyAxXSAqIHM7XG4gICAgICAgIGNvbnN0IGIgPSBkYXRhMFtpNCArIDJdICogcztcbiAgICAgICAgY29uc3QgaVJHQiA9IE1hdGgucm91bmQociArIGcgKiBzaXplICsgYiAqIHNpemVTcSkgKiA0O1xuICAgICAgICBkYXRhMFtpNCArIDBdID0gZGF0YTFbaVJHQiArIDBdO1xuICAgICAgICBkYXRhMFtpNCArIDFdID0gZGF0YTFbaVJHQiArIDFdO1xuICAgICAgICBkYXRhMFtpNCArIDJdID0gZGF0YTFbaVJHQiArIDJdO1xuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTFVUIGRhdGEgaW50byB1bnNpZ25lZCBieXRlIGRhdGEuXG4gICAqXG4gICAqIFRoaXMgaXMgYSBsb3NzeSBvcGVyYXRpb24gd2hpY2ggc2hvdWxkIG9ubHkgYmUgcGVyZm9ybWVkIGFmdGVyIGFsbCBvdGhlciB0cmFuc2Zvcm1hdGlvbnMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoaXMgdGV4dHVyZS5cbiAgICovXG4gIGNvbnZlcnRUb1VpbnQ4KCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IEZsb2F0VHlwZTIpIHtcbiAgICAgIGNvbnN0IGZsb2F0RGF0YSA9IHRoaXMuaW1hZ2UuZGF0YTtcbiAgICAgIGNvbnN0IHVpbnQ4RGF0YSA9IG5ldyBVaW50OEFycmF5KGZsb2F0RGF0YS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBmbG9hdERhdGEubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIHVpbnQ4RGF0YVtpXSA9IGZsb2F0RGF0YVtpXSAqIDI1NSArIDAuNTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW1hZ2UuZGF0YSA9IHVpbnQ4RGF0YTtcbiAgICAgIHRoaXMudHlwZSA9IFVuc2lnbmVkQnl0ZVR5cGUxMDtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIExVVCBkYXRhIGludG8gZmxvYXQgZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7TG9va3VwVGV4dHVyZX0gVGhpcyB0ZXh0dXJlLlxuICAgKi9cbiAgY29udmVydFRvRmxvYXQoKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gVW5zaWduZWRCeXRlVHlwZTEwKSB7XG4gICAgICBjb25zdCB1aW50OERhdGEgPSB0aGlzLmltYWdlLmRhdGE7XG4gICAgICBjb25zdCBmbG9hdERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHVpbnQ4RGF0YS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB1aW50OERhdGEubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGZsb2F0RGF0YVtpXSA9IHVpbnQ4RGF0YVtpXSAvIDI1NTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW1hZ2UuZGF0YSA9IGZsb2F0RGF0YTtcbiAgICAgIHRoaXMudHlwZSA9IEZsb2F0VHlwZTI7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTFVUIGludG8gUkdCQSBkYXRhLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBMVVRzIGFyZSBSR0JBIGJ5IGRlZmF1bHQgc2luY2UgdGhyZWUgcjEzNy5cbiAgICogQHJldHVybiB7TG9va3VwVGV4dHVyZX0gVGhpcyB0ZXh0dXJlLlxuICAgKi9cbiAgY29udmVydFRvUkdCQSgpIHtcbiAgICBjb25zb2xlLndhcm4oXCJMb29rdXBUZXh0dXJlXCIsIFwiY29udmVydFRvUkdCQSgpIGlzIGRlcHJlY2F0ZWQsIExVVHMgYXJlIG5vdyBSR0JBIGJ5IGRlZmF1bHRcIik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBvdXRwdXQgb2YgdGhpcyBMVVQgaW50byBzUkdCIGNvbG9yIHNwYWNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtMb29rdXBUZXh0dXJlfSBUaGlzIHRleHR1cmUuXG4gICAqL1xuICBjb252ZXJ0TGluZWFyVG9TUkdCKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmltYWdlLmRhdGE7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gRmxvYXRUeXBlMikge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgICBjLmZyb21BcnJheShkYXRhLCBpKS5jb252ZXJ0TGluZWFyVG9TUkdCKCkudG9BcnJheShkYXRhLCBpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlOTtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ29sb3Igc3BhY2UgY29udmVyc2lvbiByZXF1aXJlcyBGbG9hdFR5cGUgZGF0YVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBvdXRwdXQgb2YgdGhpcyBMVVQgaW50byBsaW5lYXIgY29sb3Igc3BhY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoaXMgdGV4dHVyZS5cbiAgICovXG4gIGNvbnZlcnRTUkdCVG9MaW5lYXIoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuaW1hZ2UuZGF0YTtcbiAgICBpZiAodGhpcy50eXBlID09PSBGbG9hdFR5cGUyKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICAgIGMuZnJvbUFycmF5KGRhdGEsIGkpLmNvbnZlcnRTUkdCVG9MaW5lYXIoKS50b0FycmF5KGRhdGEsIGkpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb2xvclNwYWNlID0gTGluZWFyU1JHQkNvbG9yU3BhY2UzO1xuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb2xvciBzcGFjZSBjb252ZXJzaW9uIHJlcXVpcmVzIEZsb2F0VHlwZSBkYXRhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMVVQgaW50byBhIDJEIGRhdGEgdGV4dHVyZS5cbiAgICpcbiAgICogUGxlYXNlIG5vdGUgdGhhdCBjdXN0b20gaW5wdXQgZG9tYWlucyBhcmUgbm90IGNhcnJpZWQgb3ZlciB0byAyRCB0ZXh0dXJlcy5cbiAgICpcbiAgICogQHJldHVybiB7RGF0YVRleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgdG9EYXRhVGV4dHVyZSgpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuaW1hZ2Uud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5pbWFnZS5oZWlnaHQgKiB0aGlzLmltYWdlLmRlcHRoO1xuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUyKHRoaXMuaW1hZ2UuZGF0YSwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGV4dHVyZS5uYW1lID0gdGhpcy5uYW1lO1xuICAgIHRleHR1cmUudHlwZSA9IHRoaXMudHlwZTtcbiAgICB0ZXh0dXJlLmZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyMztcbiAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IExpbmVhckZpbHRlcjM7XG4gICAgdGV4dHVyZS53cmFwUyA9IHRoaXMud3JhcFM7XG4gICAgdGV4dHVyZS53cmFwVCA9IHRoaXMud3JhcFQ7XG4gICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmNvbG9yU3BhY2UgPSB0ZXh0dXJlLmNvbG9yU3BhY2U7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgM0QgTFVUIGJ5IGNvcHlpbmcgYSBnaXZlbiBMVVQuXG4gICAqXG4gICAqIENvbW1vbiBpbWFnZS1iYXNlZCB0ZXh0dXJlcyB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIDNEIGRhdGEgdGV4dHVyZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBMVVQuIEFzc3VtZWQgdG8gYmUgY3ViaWMuXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IEEgbmV3IDNEIExVVC5cbiAgICovXG4gIHN0YXRpYyBmcm9tKHRleHR1cmUpIHtcbiAgICBjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBpbWFnZTtcbiAgICBjb25zdCBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKGltYWdlIGluc3RhbmNlb2YgSW1hZ2UpIHtcbiAgICAgIGNvbnN0IHJhd0ltYWdlRGF0YSA9IFJhd0ltYWdlRGF0YS5mcm9tKGltYWdlKTtcbiAgICAgIGNvbnN0IHNyYyA9IHJhd0ltYWdlRGF0YS5kYXRhO1xuICAgICAgaWYgKHdpZHRoID4gaGVpZ2h0KSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShzcmMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCBzaXplOyArK3opIHtcbiAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemU7ICsreSkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplOyArK3gpIHtcbiAgICAgICAgICAgICAgY29uc3QgaTQgPSAoeCArIHogKiBzaXplICsgeSAqIHNpemUgKiBzaXplKSAqIDQ7XG4gICAgICAgICAgICAgIGNvbnN0IGo0ID0gKHggKyB5ICogc2l6ZSArIHogKiBzaXplICogc2l6ZSkgKiA0O1xuICAgICAgICAgICAgICBkYXRhW2o0ICsgMF0gPSBzcmNbaTQgKyAwXTtcbiAgICAgICAgICAgICAgZGF0YVtqNCArIDFdID0gc3JjW2k0ICsgMV07XG4gICAgICAgICAgICAgIGRhdGFbajQgKyAyXSA9IHNyY1tpNCArIDJdO1xuICAgICAgICAgICAgICBkYXRhW2o0ICsgM10gPSBzcmNbaTQgKyAzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShzcmMuYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGltYWdlLmRhdGEuc2xpY2UoKTtcbiAgICB9XG4gICAgY29uc3QgbHV0ID0gbmV3IF9Mb29rdXBUZXh0dXJlKGRhdGEsIHNpemUpO1xuICAgIGx1dC50eXBlID0gdGV4dHVyZS50eXBlO1xuICAgIGx1dC5uYW1lID0gdGV4dHVyZS5uYW1lO1xuICAgIHRleHR1cmUuY29sb3JTcGFjZSA9IGx1dC5jb2xvclNwYWNlO1xuICAgIHJldHVybiBsdXQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXV0cmFsIDNEIExVVC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgLSBUaGUgc2lkZWxlbmd0aC5cbiAgICogQHJldHVybiB7TG9va3VwVGV4dHVyZX0gQSBuZXV0cmFsIDNEIExVVC5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVOZXV0cmFsKHNpemUpIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShzaXplICoqIDMgKiA0KTtcbiAgICBjb25zdCBzaXplU3EgPSBzaXplICoqIDI7XG4gICAgY29uc3QgcyA9IDEgLyAoc2l6ZSAtIDEpO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgc2l6ZTsgKytyKSB7XG4gICAgICBmb3IgKGxldCBnID0gMDsgZyA8IHNpemU7ICsrZykge1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IHNpemU7ICsrYikge1xuICAgICAgICAgIGNvbnN0IGk0ID0gKHIgKyBnICogc2l6ZSArIGIgKiBzaXplU3EpICogNDtcbiAgICAgICAgICBkYXRhW2k0ICsgMF0gPSByICogcztcbiAgICAgICAgICBkYXRhW2k0ICsgMV0gPSBnICogcztcbiAgICAgICAgICBkYXRhW2k0ICsgMl0gPSBiICogcztcbiAgICAgICAgICBkYXRhW2k0ICsgM10gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGx1dCA9IG5ldyBfTG9va3VwVGV4dHVyZShkYXRhLCBzaXplKTtcbiAgICBsdXQubmFtZSA9IFwibmV1dHJhbFwiO1xuICAgIHJldHVybiBsdXQ7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvbHV0LTNkLmZyYWdcbnZhciBsdXRfM2RfZGVmYXVsdCA9IGB1bmlmb3JtIHZlYzMgc2NhbGU7dW5pZm9ybSB2ZWMzIG9mZnNldDtcbiNpZmRlZiBDVVNUT01fSU5QVVRfRE9NQUlOXG51bmlmb3JtIHZlYzMgZG9tYWluTWluO3VuaWZvcm0gdmVjMyBkb21haW5NYXg7XG4jZW5kaWZcbiNpZmRlZiBMVVRfM0RcbiNpZmRlZiBMVVRfUFJFQ0lTSU9OX0hJR0hcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBoaWdocCBzYW1wbGVyM0QgbHV0O1xuI2Vsc2VcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyM0QgbHV0O1xuI2VuZGlmXG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIzRCBsdXQ7XG4jZW5kaWZcbnZlYzQgYXBwbHlMVVQoY29uc3QgaW4gdmVjMyByZ2Ipe1xuI2lmZGVmIFRFVFJBSEVEUkFMX0lOVEVSUE9MQVRJT05cbnZlYzMgcD1mbG9vcihyZ2IpO3ZlYzMgZj1yZ2ItcDt2ZWMzIHYxPShwKzAuNSkqTFVUX1RFWEVMX1dJRFRIO3ZlYzMgdjQ9KHArMS41KSpMVVRfVEVYRUxfV0lEVEg7dmVjMyB2Mix2Mzt2ZWMzIGZyYWM7aWYoZi5yPj1mLmcpe2lmKGYuZz5mLmIpe2ZyYWM9Zi5yZ2I7djI9dmVjMyh2NC54LHYxLnksdjEueik7djM9dmVjMyh2NC54LHY0LnksdjEueik7fWVsc2UgaWYoZi5yPj1mLmIpe2ZyYWM9Zi5yYmc7djI9dmVjMyh2NC54LHYxLnksdjEueik7djM9dmVjMyh2NC54LHYxLnksdjQueik7fWVsc2V7ZnJhYz1mLmJyZzt2Mj12ZWMzKHYxLngsdjEueSx2NC56KTt2Mz12ZWMzKHY0LngsdjEueSx2NC56KTt9fWVsc2V7aWYoZi5iPmYuZyl7ZnJhYz1mLmJncjt2Mj12ZWMzKHYxLngsdjEueSx2NC56KTt2Mz12ZWMzKHYxLngsdjQueSx2NC56KTt9ZWxzZSBpZihmLnI+PWYuYil7ZnJhYz1mLmdyYjt2Mj12ZWMzKHYxLngsdjQueSx2MS56KTt2Mz12ZWMzKHY0LngsdjQueSx2MS56KTt9ZWxzZXtmcmFjPWYuZ2JyO3YyPXZlYzModjEueCx2NC55LHYxLnopO3YzPXZlYzModjEueCx2NC55LHY0LnopO319dmVjNCBuMT10ZXh0dXJlKGx1dCx2MSk7dmVjNCBuMj10ZXh0dXJlKGx1dCx2Mik7dmVjNCBuMz10ZXh0dXJlKGx1dCx2Myk7dmVjNCBuND10ZXh0dXJlKGx1dCx2NCk7dmVjNCB3ZWlnaHRzPXZlYzQoMS4wLWZyYWMueCxmcmFjLngtZnJhYy55LGZyYWMueS1mcmFjLnosZnJhYy56KTt2ZWM0IHJlc3VsdD13ZWlnaHRzKm1hdDQodmVjNChuMS5yLG4yLnIsbjMucixuNC5yKSx2ZWM0KG4xLmcsbjIuZyxuMy5nLG40LmcpLHZlYzQobjEuYixuMi5iLG4zLmIsbjQuYiksdmVjNCgxLjApKTtyZXR1cm4gdmVjNChyZXN1bHQucmdiLDEuMCk7XG4jZWxzZVxucmV0dXJuIHRleHR1cmUobHV0LHJnYik7XG4jZW5kaWZcbn1cbiNlbHNlXG4jaWZkZWYgTFVUX1BSRUNJU0lPTl9ISUdIXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGx1dDtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGx1dDtcbiNlbmRpZlxuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbHV0O1xuI2VuZGlmXG52ZWM0IGFwcGx5TFVUKGNvbnN0IGluIHZlYzMgcmdiKXtmbG9hdCBzbGljZT1yZ2IuYipMVVRfU0laRTtmbG9hdCBzbGljZTA9Zmxvb3Ioc2xpY2UpO2Zsb2F0IGludGVycD1zbGljZS1zbGljZTA7ZmxvYXQgY2VudGVyZWRJbnRlcnA9aW50ZXJwLTAuNTtmbG9hdCBzbGljZTE9c2xpY2UwK3NpZ24oY2VudGVyZWRJbnRlcnApO1xuI2lmZGVmIExVVF9TVFJJUF9IT1JJWk9OVEFMXG5mbG9hdCB4T2Zmc2V0PWNsYW1wKHJnYi5yKkxVVF9URVhFTF9IRUlHSFQsTFVUX1RFWEVMX1dJRFRIKjAuNSxMVVRfVEVYRUxfSEVJR0hULUxVVF9URVhFTF9XSURUSCowLjUpO3ZlYzIgdXYwPXZlYzIoc2xpY2UwKkxVVF9URVhFTF9IRUlHSFQreE9mZnNldCxyZ2IuZyk7dmVjMiB1djE9dmVjMihzbGljZTEqTFVUX1RFWEVMX0hFSUdIVCt4T2Zmc2V0LHJnYi5nKTtcbiNlbHNlXG5mbG9hdCB5T2Zmc2V0PWNsYW1wKHJnYi5nKkxVVF9URVhFTF9XSURUSCxMVVRfVEVYRUxfSEVJR0hUKjAuNSxMVVRfVEVYRUxfV0lEVEgtTFVUX1RFWEVMX0hFSUdIVCowLjUpO3ZlYzIgdXYwPXZlYzIocmdiLnIsc2xpY2UwKkxVVF9URVhFTF9XSURUSCt5T2Zmc2V0KTt2ZWMyIHV2MT12ZWMyKHJnYi5yLHNsaWNlMSpMVVRfVEVYRUxfV0lEVEgreU9mZnNldCk7XG4jZW5kaWZcbnZlYzQgc2FtcGxlMD10ZXh0dXJlMkQobHV0LHV2MCk7dmVjNCBzYW1wbGUxPXRleHR1cmUyRChsdXQsdXYxKTtyZXR1cm4gbWl4KHNhbXBsZTAsc2FtcGxlMSxhYnMoY2VudGVyZWRJbnRlcnApKTt9XG4jZW5kaWZcbnZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWMzIGM9aW5wdXRDb2xvci5yZ2I7XG4jaWZkZWYgQ1VTVE9NX0lOUFVUX0RPTUFJTlxuaWYoYy5yPj1kb21haW5NaW4uciYmYy5nPj1kb21haW5NaW4uZyYmYy5iPj1kb21haW5NaW4uYiYmYy5yPD1kb21haW5NYXguciYmYy5nPD1kb21haW5NYXguZyYmYy5iPD1kb21haW5NYXguYil7Yz1hcHBseUxVVChzY2FsZSpjK29mZnNldCkucmdiO31lbHNle2M9aW5wdXRDb2xvci5yZ2I7fVxuI2Vsc2VcbiNpZiAhZGVmaW5lZChMVVRfM0QpIHx8IGRlZmluZWQoVEVUUkFIRURSQUxfSU5URVJQT0xBVElPTilcbmM9Y2xhbXAoYywwLjAsMS4wKTtcbiNlbmRpZlxuYz1hcHBseUxVVChzY2FsZSpjK29mZnNldCkucmdiO1xuI2VuZGlmXG5vdXRwdXRDb2xvcj12ZWM0KGMsaW5wdXRDb2xvci5hKTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvTFVUM0RFZmZlY3QuanNcbnZhciBMVVQzREVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgY29sb3IgZ3JhZGluZyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gbHV0IC0gVGhlIGxvb2t1cCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNSQ10gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uPWZhbHNlXSAtIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGV0cmFoZWRyYWwgaW50ZXJwb2xhdGlvbi5cbiAgICogQHBhcmFtIHtDb2xvclNwYWNlfSBbb3B0aW9ucy5pbnB1dENvbG9yU3BhY2U9U1JHQkNvbG9yU3BhY2VdIC0gVGhlIGlucHV0IGNvbG9yIHNwYWNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IobHV0LCB7XG4gICAgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU1JDLFxuICAgIHRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbiA9IGZhbHNlLFxuICAgIGlucHV0Q29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlMTBcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJMVVQzREVmZmVjdFwiLCBsdXRfM2RfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImx1dFwiLCBuZXcgVW5pZm9ybTI3KG51bGwpXSxcbiAgICAgICAgW1wic2NhbGVcIiwgbmV3IFVuaWZvcm0yNyhuZXcgVmVjdG9yMzQoKSldLFxuICAgICAgICBbXCJvZmZzZXRcIiwgbmV3IFVuaWZvcm0yNyhuZXcgVmVjdG9yMzQoKSldLFxuICAgICAgICBbXCJkb21haW5NaW5cIiwgbmV3IFVuaWZvcm0yNyhudWxsKV0sXG4gICAgICAgIFtcImRvbWFpbk1heFwiLCBuZXcgVW5pZm9ybTI3KG51bGwpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLnRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbiA9IHRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbjtcbiAgICB0aGlzLmlucHV0Q29sb3JTcGFjZSA9IGlucHV0Q29sb3JTcGFjZTtcbiAgICB0aGlzLmx1dCA9IGx1dDtcbiAgfVxuICAvKipcbiAgICogVGhlIExVVC5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgbHV0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImx1dFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgbHV0KHZhbHVlKSB7XG4gICAgY29uc3QgZGVmaW5lcyA9IHRoaXMuZGVmaW5lcztcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gICAgaWYgKHRoaXMubHV0ICE9PSB2YWx1ZSkge1xuICAgICAgdW5pZm9ybXMuZ2V0KFwibHV0XCIpLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSB2YWx1ZS5pbWFnZTtcbiAgICAgICAgY29uc3QgdGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uID0gdGhpcy50ZXRyYWhlZHJhbEludGVycG9sYXRpb247XG4gICAgICAgIGRlZmluZXMuY2xlYXIoKTtcbiAgICAgICAgZGVmaW5lcy5zZXQoXCJMVVRfU0laRVwiLCBNYXRoLm1pbihpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KS50b0ZpeGVkKDE2KSk7XG4gICAgICAgIGRlZmluZXMuc2V0KFwiTFVUX1RFWEVMX1dJRFRIXCIsICgxIC8gaW1hZ2Uud2lkdGgpLnRvRml4ZWQoMTYpKTtcbiAgICAgICAgZGVmaW5lcy5zZXQoXCJMVVRfVEVYRUxfSEVJR0hUXCIsICgxIC8gaW1hZ2UuaGVpZ2h0KS50b0ZpeGVkKDE2KSk7XG4gICAgICAgIHVuaWZvcm1zLmdldChcImRvbWFpbk1pblwiKS52YWx1ZSA9IG51bGw7XG4gICAgICAgIHVuaWZvcm1zLmdldChcImRvbWFpbk1heFwiKS52YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBGbG9hdFR5cGUzIHx8IHZhbHVlLnR5cGUgPT09IEhhbGZGbG9hdFR5cGUyKSB7XG4gICAgICAgICAgZGVmaW5lcy5zZXQoXCJMVVRfUFJFQ0lTSU9OX0hJR0hcIiwgXCIxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZS53aWR0aCA+IGltYWdlLmhlaWdodCkge1xuICAgICAgICAgIGRlZmluZXMuc2V0KFwiTFVUX1NUUklQX0hPUklaT05UQUxcIiwgXCIxXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YTNEVGV4dHVyZTIpIHtcbiAgICAgICAgICBkZWZpbmVzLnNldChcIkxVVF8zRFwiLCBcIjFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9va3VwVGV4dHVyZSkge1xuICAgICAgICAgIGNvbnN0IG1pbiA9IHZhbHVlLmRvbWFpbk1pbjtcbiAgICAgICAgICBjb25zdCBtYXggPSB2YWx1ZS5kb21haW5NYXg7XG4gICAgICAgICAgaWYgKG1pbi54ICE9PSAwIHx8IG1pbi55ICE9PSAwIHx8IG1pbi56ICE9PSAwIHx8IG1heC54ICE9PSAxIHx8IG1heC55ICE9PSAxIHx8IG1heC56ICE9PSAxKSB7XG4gICAgICAgICAgICBkZWZpbmVzLnNldChcIkNVU1RPTV9JTlBVVF9ET01BSU5cIiwgXCIxXCIpO1xuICAgICAgICAgICAgdW5pZm9ybXMuZ2V0KFwiZG9tYWluTWluXCIpLnZhbHVlID0gbWluLmNsb25lKCk7XG4gICAgICAgICAgICB1bmlmb3Jtcy5nZXQoXCJkb21haW5NYXhcIikudmFsdWUgPSBtYXguY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXRyYWhlZHJhbEludGVycG9sYXRpb24gPSB0ZXRyYWhlZHJhbEludGVycG9sYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IExVVC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGx1dCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgTFVULlxuICAgKi9cbiAgZ2V0TFVUKCkge1xuICAgIHJldHVybiB0aGlzLmx1dDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgTFVULlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbHV0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgTFVULlxuICAgKi9cbiAgc2V0TFVUKHZhbHVlKSB7XG4gICAgdGhpcy5sdXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2NhbGUgYW5kIG9mZnNldCBmb3IgdGhlIExVVCBzYW1wbGluZyBjb29yZGluYXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVNjYWxlT2Zmc2V0KCkge1xuICAgIGNvbnN0IGx1dCA9IHRoaXMubHV0O1xuICAgIGlmIChsdXQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbihsdXQuaW1hZ2Uud2lkdGgsIGx1dC5pbWFnZS5oZWlnaHQpO1xuICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnVuaWZvcm1zLmdldChcInNjYWxlXCIpLnZhbHVlO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy51bmlmb3Jtcy5nZXQoXCJvZmZzZXRcIikudmFsdWU7XG4gICAgICBpZiAodGhpcy50ZXRyYWhlZHJhbEludGVycG9sYXRpb24gJiYgbHV0IGluc3RhbmNlb2YgRGF0YTNEVGV4dHVyZTIpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmaW5lcy5oYXMoXCJDVVNUT01fSU5QVVRfRE9NQUlOXCIpKSB7XG4gICAgICAgICAgY29uc3QgZG9tYWluU2NhbGUgPSBsdXQuZG9tYWluTWF4LmNsb25lKCkuc3ViKGx1dC5kb21haW5NaW4pO1xuICAgICAgICAgIHNjYWxlLnNldFNjYWxhcihzaXplIC0gMSkuZGl2aWRlKGRvbWFpblNjYWxlKTtcbiAgICAgICAgICBvZmZzZXQuY29weShsdXQuZG9tYWluTWluKS5uZWdhdGUoKS5tdWx0aXBseShzY2FsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NhbGUuc2V0U2NhbGFyKHNpemUgLSAxKTtcbiAgICAgICAgICBvZmZzZXQuc2V0U2NhbGFyKDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5kZWZpbmVzLmhhcyhcIkNVU1RPTV9JTlBVVF9ET01BSU5cIikpIHtcbiAgICAgICAgICBjb25zdCBkb21haW5TY2FsZSA9IGx1dC5kb21haW5NYXguY2xvbmUoKS5zdWIobHV0LmRvbWFpbk1pbikubXVsdGlwbHlTY2FsYXIoc2l6ZSk7XG4gICAgICAgICAgc2NhbGUuc2V0U2NhbGFyKHNpemUgLSAxKS5kaXZpZGUoZG9tYWluU2NhbGUpO1xuICAgICAgICAgIG9mZnNldC5jb3B5KGx1dC5kb21haW5NaW4pLm5lZ2F0ZSgpLm11bHRpcGx5KHNjYWxlKS5hZGRTY2FsYXIoMSAvICgyICogc2l6ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjYWxlLnNldFNjYWxhcigoc2l6ZSAtIDEpIC8gc2l6ZSk7XG4gICAgICAgICAgb2Zmc2V0LnNldFNjYWxhcigxIC8gKDIgKiBzaXplKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgcGFyYW1ldGVycyBmb3IgdGV0cmFoZWRyYWwgaW50ZXJwb2xhdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbmZpZ3VyZVRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbigpIHtcbiAgICBjb25zdCBsdXQgPSB0aGlzLmx1dDtcbiAgICBpZiAobHV0ICE9PSBudWxsKSB7XG4gICAgICBsdXQubWluRmlsdGVyID0gTGluZWFyRmlsdGVyNDtcbiAgICAgIGx1dC5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI0O1xuICAgICAgaWYgKHRoaXMudGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgIGlmIChsdXQgaW5zdGFuY2VvZiBEYXRhM0RUZXh0dXJlMikge1xuICAgICAgICAgIGx1dC5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyMjtcbiAgICAgICAgICBsdXQubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVGV0cmFoZWRyYWwgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyBhIDNEIHRleHR1cmVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGx1dC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0ZXRyYWhlZHJhbCBpbnRlcnBvbGF0aW9uIGlzIGVuYWJsZWQuIFJlcXVpcmVzIGEgM0QgTFVULCBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBUZXRyYWhlZHJhbCBpbnRlcnBvbGF0aW9uIHByb2R1Y2VzIGhpZ2hseSBhY2N1cmF0ZSByZXN1bHRzIGJ1dCBpcyBzbG93ZXIgdGhhbiBoYXJkd2FyZSBpbnRlcnBvbGF0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB0ZXRyYWhlZHJhbEludGVycG9sYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJURVRSQUhFRFJBTF9JTlRFUlBPTEFUSU9OXCIpO1xuICB9XG4gIHNldCB0ZXRyYWhlZHJhbEludGVycG9sYXRpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJURVRSQUhFRFJBTF9JTlRFUlBPTEFUSU9OXCIsIFwiMVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIlRFVFJBSEVEUkFMX0lOVEVSUE9MQVRJT05cIik7XG4gICAgfVxuICAgIHRoaXMuY29uZmlndXJlVGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uKCk7XG4gICAgdGhpcy51cGRhdGVTY2FsZU9mZnNldCgpO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRldHJhaGVkcmFsIGludGVycG9sYXRpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXRyYWhlZHJhbEludGVycG9sYXRpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGV0cmFoZWRyYWwgaW50ZXJwb2xhdGlvbiBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldFRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbkVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLnRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbiA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZW51bXMvRGVwdGhDb3B5TW9kZS5qc1xudmFyIERlcHRoQ29weU1vZGUgPSB7XG4gIEZVTEw6IDAsXG4gIFNJTkdMRTogMVxufTtcblxuLy8gc3JjL2VudW1zL0VkZ2VEZXRlY3Rpb25Nb2RlLmpzXG52YXIgRWRnZURldGVjdGlvbk1vZGUgPSB7XG4gIERFUFRIOiAwLFxuICBMVU1BOiAxLFxuICBDT0xPUjogMlxufTtcblxuLy8gc3JjL2VudW1zL1ByZWRpY2F0aW9uTW9kZS5qc1xudmFyIFByZWRpY2F0aW9uTW9kZSA9IHtcbiAgRElTQUJMRUQ6IDAsXG4gIERFUFRIOiAxLFxuICBDVVNUT006IDJcbn07XG5cbi8vIHNyYy9lbnVtcy9TTUFBUHJlc2V0LmpzXG52YXIgU01BQVByZXNldCA9IHtcbiAgTE9XOiAwLFxuICBNRURJVU06IDEsXG4gIEhJR0g6IDIsXG4gIFVMVFJBOiAzXG59O1xuXG4vLyBzcmMvZW51bXMvVG9uZU1hcHBpbmdNb2RlLmpzXG52YXIgVG9uZU1hcHBpbmdNb2RlID0ge1xuICBMSU5FQVI6IDAsXG4gIFJFSU5IQVJEOiAxLFxuICBSRUlOSEFSRDI6IDIsXG4gIFJFSU5IQVJEMl9BREFQVElWRTogMyxcbiAgVU5DSEFSVEVEMjogNCxcbiAgT1BUSU1JWkVEX0NJTkVPTjogNSxcbiAgQ0lORU9OOiA1LFxuICBBQ0VTX0ZJTE1JQzogNixcbiAgQUdYOiA3LFxuICBORVVUUkFMOiA4XG59O1xuXG4vLyBzcmMvZW51bXMvVmlnbmV0dGVUZWNobmlxdWUuanNcbnZhciBWaWduZXR0ZVRlY2huaXF1ZSA9IHtcbiAgREVGQVVMVDogMCxcbiAgRVNLSUw6IDFcbn07XG5cbi8vIHNyYy9lbnVtcy9XZWJHTEV4dGVuc2lvbi5qc1xudmFyIFdlYkdMRXh0ZW5zaW9uID0ge1xuICBERVJJVkFUSVZFUzogXCJkZXJpdmF0aXZlc1wiLFxuICBGUkFHX0RFUFRIOiBcImZyYWdEZXB0aFwiLFxuICBEUkFXX0JVRkZFUlM6IFwiZHJhd0J1ZmZlcnNcIixcbiAgU0hBREVSX1RFWFRVUkVfTE9EOiBcInNoYWRlclRleHR1cmVMT0RcIlxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9ub2lzZS5mcmFnXG52YXIgbm9pc2VfZGVmYXVsdCA9IGB2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMyBub2lzZT12ZWMzKHJhbmQodXYqKDEuMCt0aW1lKSkpO1xuI2lmZGVmIFBSRU1VTFRJUExZXG5vdXRwdXRDb2xvcj12ZWM0KG1pbihpbnB1dENvbG9yLnJnYipub2lzZSx2ZWMzKDEuMCkpLGlucHV0Q29sb3IuYSk7XG4jZWxzZVxub3V0cHV0Q29sb3I9dmVjNChub2lzZSxpbnB1dENvbG9yLmEpO1xuI2VuZGlmXG59YDtcblxuLy8gc3JjL2VmZmVjdHMvTm9pc2VFZmZlY3QuanNcbnZhciBOb2lzZUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbm9pc2UgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNDUkVFTl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucHJlbXVsdGlwbHk9ZmFsc2VdIC0gV2hldGhlciB0aGUgbm9pc2Ugc2hvdWxkIGJlIG11bHRpcGxpZWQgd2l0aCB0aGUgaW5wdXQgY29sb3JzIHByaW9yIHRvIGJsZW5kaW5nLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TQ1JFRU4sIHByZW11bHRpcGx5ID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJOb2lzZUVmZmVjdFwiLCBub2lzZV9kZWZhdWx0LCB7IGJsZW5kRnVuY3Rpb24gfSk7XG4gICAgdGhpcy5wcmVtdWx0aXBseSA9IHByZW11bHRpcGx5O1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBub2lzZSB3aWxsIGJlIG11bHRpcGxpZWQgd2l0aCB0aGUgaW5wdXQgY29sb3JzIHByaW9yIHRvIGJsZW5kaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBwcmVtdWx0aXBseSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLmhhcyhcIlBSRU1VTFRJUExZXCIpO1xuICB9XG4gIHNldCBwcmVtdWx0aXBseSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnByZW11bHRpcGx5ICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJQUkVNVUxUSVBMWVwiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiUFJFTVVMVElQTFlcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIG5vaXNlIHdpbGwgYmUgbXVsdGlwbGllZCB3aXRoIHRoZSBpbnB1dCBjb2xvcnMgcHJpb3IgdG8gYmxlbmRpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVtdWx0aXBseSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIG5vaXNlIGlzIHByZW11bHRpcGxpZWQuXG4gICAqL1xuICBpc1ByZW11bHRpcGxpZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlbXVsdGlwbHk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoZXRoZXIgbm9pc2Ugc2hvdWxkIGJlIG11bHRpcGxpZWQgd2l0aCB0aGUgaW5wdXQgY29sb3JzIHByaW9yIHRvIGJsZW5kaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlbXVsdGlwbHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgbm9pc2Ugc2hvdWxkIGJlIHByZW11bHRpcGxpZWQuXG4gICAqL1xuICBzZXRQcmVtdWx0aXBsaWVkKHZhbHVlKSB7XG4gICAgdGhpcy5wcmVtdWx0aXBseSA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9PdXRsaW5lRWZmZWN0LmpzXG5pbXBvcnQgeyBDb2xvciBhcyBDb2xvcjYsIFJlcGVhdFdyYXBwaW5nIGFzIFJlcGVhdFdyYXBwaW5nMywgVW5pZm9ybSBhcyBVbmlmb3JtMzAsIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTExLCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDEyIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhDb21wYXJpc29uTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzExLCBQZXJzcGVjdGl2ZUNhbWVyYSBhcyBQZXJzcGVjdGl2ZUNhbWVyYTMsIFJHQkFEZXB0aFBhY2tpbmcsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMTIsIFVuaWZvcm0gYXMgVW5pZm9ybTI4IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9kZXB0aC1jb21wYXJpc29uLmZyYWdcbnZhciBkZXB0aF9jb21wYXJpc29uX2RlZmF1bHQgPSBgI2luY2x1ZGUgPHBhY2tpbmc+XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZW5kaWZcbnVuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjt1bmlmb3JtIGZsb2F0IGNhbWVyYUZhcjtjZW50cm9pZCB2YXJ5aW5nIGZsb2F0IHZWaWV3WjtjZW50cm9pZCB2YXJ5aW5nIHZlYzQgdlByb2pUZXhDb29yZDt2b2lkIG1haW4oKXtcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XG52ZWMyIHByb2pUZXhDb29yZD0odlByb2pUZXhDb29yZC54eS92UHJvalRleENvb3JkLncpKjAuNSswLjU7cHJvalRleENvb3JkPWNsYW1wKHByb2pUZXhDb29yZCwwLjAwMiwwLjk5OCk7XG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXG5mbG9hdCBmcmFnQ29vcmRaPXVucGFja1JHQkFUb0RlcHRoKHRleHR1cmUyRChkZXB0aEJ1ZmZlcixwcm9qVGV4Q29vcmQpKTtcbiNlbHNlXG5mbG9hdCBmcmFnQ29vcmRaPXRleHR1cmUyRChkZXB0aEJ1ZmZlcixwcm9qVGV4Q29vcmQpLnI7XG4jZW5kaWZcbiNpZmRlZiBQRVJTUEVDVElWRV9DQU1FUkFcbmZsb2F0IHZpZXdaPXBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGZyYWdDb29yZFosY2FtZXJhTmVhcixjYW1lcmFGYXIpO1xuI2Vsc2VcbmZsb2F0IHZpZXdaPW9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WihmcmFnQ29vcmRaLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcbiNlbmRpZlxuZmxvYXQgZGVwdGhUZXN0PSgtdlZpZXdaPi12aWV3Wik/MS4wOjAuMDtnbF9GcmFnQ29sb3Iucmc9dmVjMigwLjAsZGVwdGhUZXN0KTt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2RlcHRoLWNvbXBhcmlzb24udmVydFxudmFyIGRlcHRoX2NvbXBhcmlzb25fZGVmYXVsdDIgPSBgI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XG52YXJ5aW5nIGZsb2F0IHZWaWV3Wjt2YXJ5aW5nIHZlYzQgdlByb2pUZXhDb29yZDt2b2lkIG1haW4oKXtcbiNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XG4jaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cbiNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XG4jaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XG52Vmlld1o9bXZQb3NpdGlvbi56O3ZQcm9qVGV4Q29vcmQ9Z2xfUG9zaXRpb247XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cbn1gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0RlcHRoQ29tcGFyaXNvbk1hdGVyaWFsLmpzXG52YXIgRGVwdGhDb21wYXJpc29uTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMTIge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBjb21wYXJpc29uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IFtkZXB0aFRleHR1cmU9bnVsbF0gLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7UGVyc3BlY3RpdmVDYW1lcmF9IFtjYW1lcmFdIC0gQSBjYW1lcmEuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkZXB0aFRleHR1cmUgPSBudWxsLCBjYW1lcmEpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkRlcHRoQ29tcGFyaXNvbk1hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIERFUFRIX1BBQ0tJTkc6IFwiMFwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMjgobnVsbCksXG4gICAgICAgIGNhbWVyYU5lYXI6IG5ldyBVbmlmb3JtMjgoMC4zKSxcbiAgICAgICAgY2FtZXJhRmFyOiBuZXcgVW5pZm9ybTI4KDFlMylcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzExLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhfY29tcGFyaXNvbl9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBkZXB0aF9jb21wYXJpc29uX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmRlcHRoUGFja2luZyA9IFJHQkFEZXB0aFBhY2tpbmc7XG4gICAgdGhpcy5jb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgZGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQnVmZmVyIGFuZCBkZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPVJHQkFEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IFJHQkFEZXB0aFBhY2tpbmcpIHtcbiAgICB0aGlzLmRlcHRoQnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3B5Q2FtZXJhU2V0dGluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYTMpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQSA9IFwiMVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkE7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvT3V0bGluZU1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcxMiwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxMywgVW5pZm9ybSBhcyBVbmlmb3JtMjksIFZlY3RvcjIgYXMgVmVjdG9yMjE1IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9vdXRsaW5lLmZyYWdcbnZhciBvdXRsaW5lX2RlZmF1bHQgPSBgdW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjt2YXJ5aW5nIHZlYzIgdlV2MDt2YXJ5aW5nIHZlYzIgdlV2MTt2YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdlV2Mzt2b2lkIG1haW4oKXt2ZWMyIGMwPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYwKS5yZzt2ZWMyIGMxPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYxKS5yZzt2ZWMyIGMyPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYyKS5yZzt2ZWMyIGMzPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYzKS5yZztmbG9hdCBkMD0oYzAueC1jMS54KSowLjU7ZmxvYXQgZDE9KGMyLngtYzMueCkqMC41O2Zsb2F0IGQ9bGVuZ3RoKHZlYzIoZDAsZDEpKTtmbG9hdCBhMD1taW4oYzAueSxjMS55KTtmbG9hdCBhMT1taW4oYzIueSxjMy55KTtmbG9hdCB2aXNpYmlsaXR5RmFjdG9yPW1pbihhMCxhMSk7Z2xfRnJhZ0NvbG9yLnJnPSgxLjAtdmlzaWJpbGl0eUZhY3Rvcj4wLjAwMSk/dmVjMihkLDAuMCk6dmVjMigwLjAsZCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9vdXRsaW5lLnZlcnRcbnZhciBvdXRsaW5lX2RlZmF1bHQyID0gYHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dm9pZCBtYWluKCl7dmVjMiB1dj1wb3NpdGlvbi54eSowLjUrMC41O3ZVdjA9dmVjMih1di54K3RleGVsU2l6ZS54LHV2LnkpO3ZVdjE9dmVjMih1di54LXRleGVsU2l6ZS54LHV2LnkpO3ZVdjI9dmVjMih1di54LHV2LnkrdGV4ZWxTaXplLnkpO3ZVdjM9dmVjMih1di54LHV2LnktdGV4ZWxTaXplLnkpO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvT3V0bGluZU1hdGVyaWFsLmpzXG52YXIgT3V0bGluZU1hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDEzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgb3V0bGluZSBtYXRlcmlhbC5cbiAgICpcbiAgICogVE9ETyBSZW1vdmUgdGV4ZWxTaXplIHBhcmFtLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFt0ZXhlbFNpemVdIC0gVGhlIHNjcmVlbiB0ZXhlbCBzaXplLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4ZWxTaXplID0gbmV3IFZlY3RvcjIxNSgpKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJPdXRsaW5lTWF0ZXJpYWxcIixcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTI5KG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtMjkobmV3IFZlY3RvcjIxNSgpKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMTIsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBvdXRsaW5lX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IG91dGxpbmVfZGVmYXVsdDJcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQodGV4ZWxTaXplLngsIHRleGVsU2l6ZS55KTtcbiAgICB0aGlzLnVuaWZvcm1zLm1hc2tUZXh0dXJlID0gdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlcjtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKi9cbiAgc2V0SW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleGVsIHNpemUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZXRTaXplKCkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgdGV4ZWwgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIHRleGVsIGhlaWdodC5cbiAgICovXG4gIHNldFRleGVsU2l6ZSh4LCB5KSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KHgsIHkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KDEgLyB3aWR0aCwgMSAvIGhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvRGVwdGhQYXNzLmpzXG5pbXBvcnQgeyBDb2xvciBhcyBDb2xvcjUsIE1lc2hEZXB0aE1hdGVyaWFsLCBOZWFyZXN0RmlsdGVyIGFzIE5lYXJlc3RGaWx0ZXIzLCBSR0JBRGVwdGhQYWNraW5nIGFzIFJHQkFEZXB0aFBhY2tpbmcyLCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDExIH0gZnJvbSBcInRocmVlXCI7XG52YXIgRGVwdGhQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgc2NlbmUgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYSB0byB1c2UgdG8gcmVuZGVyIHRoZSBzY2VuZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBbb3B0aW9ucy5yZW5kZXJUYXJnZXRdIC0gQSBjdXN0b20gcmVuZGVyIHRhcmdldC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0xLjBdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNjZW5lLCBjYW1lcmEsIHtcbiAgICByZW5kZXJUYXJnZXQsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMSxcbiAgICB3aWR0aCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIGhlaWdodCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25YID0gd2lkdGgsXG4gICAgcmVzb2x1dGlvblkgPSBoZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJEZXB0aFBhc3NcIik7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclBhc3MgPSBuZXcgUmVuZGVyUGFzcyhzY2VuZSwgY2FtZXJhLCBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoe1xuICAgICAgZGVwdGhQYWNraW5nOiBSR0JBRGVwdGhQYWNraW5nMlxuICAgIH0pKTtcbiAgICBjb25zdCByZW5kZXJQYXNzID0gdGhpcy5yZW5kZXJQYXNzO1xuICAgIHJlbmRlclBhc3Muc2tpcFNoYWRvd01hcFVwZGF0ZSA9IHRydWU7XG4gICAgcmVuZGVyUGFzcy5pZ25vcmVCYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICBjb25zdCBjbGVhclBhc3MgPSByZW5kZXJQYXNzLmNsZWFyUGFzcztcbiAgICBjbGVhclBhc3Mub3ZlcnJpZGVDbGVhckNvbG9yID0gbmV3IENvbG9yNSgxNjc3NzIxNSk7XG4gICAgY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJBbHBoYSA9IDE7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgaWYgKHRoaXMucmVuZGVyVGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTEoMSwgMSwge1xuICAgICAgICBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXIzLFxuICAgICAgICBtYWdGaWx0ZXI6IE5lYXJlc3RGaWx0ZXIzXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiRGVwdGhQYXNzLlRhcmdldFwiO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgfVxuICBzZXQgbWFpblNjZW5lKHZhbHVlKSB7XG4gICAgdGhpcy5yZW5kZXJQYXNzLm1haW5TY2VuZSA9IHZhbHVlO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5yZW5kZXJQYXNzLm1haW5DYW1lcmEgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7UmVzb2x1dGlvbn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICovXG4gIGdldFJlc29sdXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgbmV3IHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2NhbGUgPSBzY2FsZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc2NlbmUgZGVwdGguXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogdGhpcy5yZW5kZXJUYXJnZXQ7XG4gICAgdGhpcy5yZW5kZXJQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZShyZXNvbHV0aW9uLndpZHRoLCByZXNvbHV0aW9uLmhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvb3V0bGluZS5mcmFnXG52YXIgb3V0bGluZV9kZWZhdWx0MyA9IGB1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGVkZ2VUZXh0dXJlO3VuaWZvcm0gbG93cCBzYW1wbGVyMkQgbWFza1RleHR1cmU7dW5pZm9ybSB2ZWMzIHZpc2libGVFZGdlQ29sb3I7dW5pZm9ybSB2ZWMzIGhpZGRlbkVkZ2VDb2xvcjt1bmlmb3JtIGZsb2F0IHB1bHNlO3VuaWZvcm0gZmxvYXQgZWRnZVN0cmVuZ3RoO1xuI2lmZGVmIFVTRV9QQVRURVJOXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIHBhdHRlcm5UZXh0dXJlO3ZhcnlpbmcgdmVjMiB2VXZQYXR0ZXJuO1xuI2VuZGlmXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMiBlZGdlPXRleHR1cmUyRChlZGdlVGV4dHVyZSx1dikucmc7dmVjMiBtYXNrPXRleHR1cmUyRChtYXNrVGV4dHVyZSx1dikucmc7XG4jaWZuZGVmIFhfUkFZXG5lZGdlLnk9MC4wO1xuI2VuZGlmXG5lZGdlKj0oZWRnZVN0cmVuZ3RoKm1hc2sueCpwdWxzZSk7dmVjMyBjb2xvcj1lZGdlLngqdmlzaWJsZUVkZ2VDb2xvcitlZGdlLnkqaGlkZGVuRWRnZUNvbG9yO2Zsb2F0IHZpc2liaWxpdHlGYWN0b3I9MC4wO1xuI2lmZGVmIFVTRV9QQVRURVJOXG52ZWM0IHBhdHRlcm5Db2xvcj10ZXh0dXJlMkQocGF0dGVyblRleHR1cmUsdlV2UGF0dGVybik7XG4jaWZkZWYgWF9SQVlcbmZsb2F0IGhpZGRlbkZhY3Rvcj0wLjU7XG4jZWxzZVxuZmxvYXQgaGlkZGVuRmFjdG9yPTAuMDtcbiNlbmRpZlxudmlzaWJpbGl0eUZhY3Rvcj0oMS4wLW1hc2sueT4wLjApPzEuMDpoaWRkZW5GYWN0b3I7dmlzaWJpbGl0eUZhY3Rvcio9KDEuMC1tYXNrLngpKnBhdHRlcm5Db2xvci5hO2NvbG9yKz12aXNpYmlsaXR5RmFjdG9yKnBhdHRlcm5Db2xvci5yZ2I7XG4jZW5kaWZcbmZsb2F0IGFscGhhPW1heChtYXgoZWRnZS54LGVkZ2UueSksdmlzaWJpbGl0eUZhY3Rvcik7XG4jaWZkZWYgQUxQSEFcbm91dHB1dENvbG9yPXZlYzQoY29sb3IsYWxwaGEpO1xuI2Vsc2Vcbm91dHB1dENvbG9yPXZlYzQoY29sb3IsbWF4KGFscGhhLGlucHV0Q29sb3IuYSkpO1xuI2VuZGlmXG59YDtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9vdXRsaW5lLnZlcnRcbnZhciBvdXRsaW5lX2RlZmF1bHQ0ID0gYHVuaWZvcm0gZmxvYXQgcGF0dGVyblNjYWxlO3ZhcnlpbmcgdmVjMiB2VXZQYXR0ZXJuO3ZvaWQgbWFpblN1cHBvcnQoY29uc3QgaW4gdmVjMiB1dil7dlV2UGF0dGVybj11dip2ZWMyKGFzcGVjdCwxLjApKnBhdHRlcm5TY2FsZTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvT3V0bGluZUVmZmVjdC5qc1xudmFyIE91dGxpbmVFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG91dGxpbmUgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBtYWluIHNjZW5lLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNDUkVFTl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24uIFVzZSBgQmxlbmRGdW5jdGlvbi5BTFBIQWAgZm9yIGRhcmsgb3V0bGluZXMuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gW29wdGlvbnMucGF0dGVyblRleHR1cmU9bnVsbF0gLSBBIHBhdHRlcm4gdGV4dHVyZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBhdHRlcm5TY2FsZT0xLjBdIC0gVGhlIHBhdHRlcm4gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lZGdlU3RyZW5ndGg9MS4wXSAtIFRoZSBlZGdlIHN0cmVuZ3RoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHVsc2VTcGVlZD0wLjBdIC0gVGhlIHB1bHNlIHNwZWVkLiBBIHZhbHVlIG9mIHplcm8gZGlzYWJsZXMgdGhlIHB1bHNlIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpc2libGVFZGdlQ29sb3I9MHhmZmZmZmZdIC0gVGhlIGNvbG9yIG9mIHZpc2libGUgZWRnZXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oaWRkZW5FZGdlQ29sb3I9MHgyMjA5MGFdIC0gVGhlIGNvbG9yIG9mIGhpZGRlbiBlZGdlcy5cbiAgICogQHBhcmFtIHtLZXJuZWxTaXplfSBbb3B0aW9ucy5rZXJuZWxTaXplPUtlcm5lbFNpemUuVkVSWV9TTUFMTF0gLSBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ibHVyPWZhbHNlXSAtIFdoZXRoZXIgdGhlIG91dGxpbmUgc2hvdWxkIGJlIGJsdXJyZWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMueFJheT10cnVlXSAtIFdoZXRoZXIgb2NjbHVkZWQgcGFydHMgb2Ygc2VsZWN0ZWQgb2JqZWN0cyBzaG91bGQgYmUgdmlzaWJsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpc2FtcGxpbmc9MF0gLSBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgdXNlZCBmb3IgbXVsdGlzYW1wbGUgYW50aWFsaWFzaW5nLiBSZXF1aXJlcyBXZWJHTCAyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTAuNV0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWSBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSwge1xuICAgIGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLlNDUkVFTixcbiAgICBwYXR0ZXJuVGV4dHVyZSA9IG51bGwsXG4gICAgcGF0dGVyblNjYWxlID0gMSxcbiAgICBlZGdlU3RyZW5ndGggPSAxLFxuICAgIHB1bHNlU3BlZWQgPSAwLFxuICAgIHZpc2libGVFZGdlQ29sb3IgPSAxNjc3NzIxNSxcbiAgICBoaWRkZW5FZGdlQ29sb3IgPSAyMjMwNTM4LFxuICAgIGtlcm5lbFNpemUgPSBLZXJuZWxTaXplLlZFUllfU01BTEwsXG4gICAgYmx1ciA9IGZhbHNlLFxuICAgIHhSYXkgPSB0cnVlLFxuICAgIG11bHRpc2FtcGxpbmcgPSAwLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDAuNSxcbiAgICB3aWR0aCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIGhlaWdodCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25YID0gd2lkdGgsXG4gICAgcmVzb2x1dGlvblkgPSBoZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJPdXRsaW5lRWZmZWN0XCIsIG91dGxpbmVfZGVmYXVsdDMsIHtcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm1hc2tUZXh0dXJlXCIsIG5ldyBVbmlmb3JtMzAobnVsbCldLFxuICAgICAgICBbXCJlZGdlVGV4dHVyZVwiLCBuZXcgVW5pZm9ybTMwKG51bGwpXSxcbiAgICAgICAgW1wiZWRnZVN0cmVuZ3RoXCIsIG5ldyBVbmlmb3JtMzAoZWRnZVN0cmVuZ3RoKV0sXG4gICAgICAgIFtcInZpc2libGVFZGdlQ29sb3JcIiwgbmV3IFVuaWZvcm0zMChuZXcgQ29sb3I2KHZpc2libGVFZGdlQ29sb3IpKV0sXG4gICAgICAgIFtcImhpZGRlbkVkZ2VDb2xvclwiLCBuZXcgVW5pZm9ybTMwKG5ldyBDb2xvcjYoaGlkZGVuRWRnZUNvbG9yKSldLFxuICAgICAgICBbXCJwdWxzZVwiLCBuZXcgVW5pZm9ybTMwKDEpXSxcbiAgICAgICAgW1wicGF0dGVyblNjYWxlXCIsIG5ldyBVbmlmb3JtMzAocGF0dGVyblNjYWxlKV0sXG4gICAgICAgIFtcInBhdHRlcm5UZXh0dXJlXCIsIG5ldyBVbmlmb3JtMzAobnVsbCldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuYmxlbmRNb2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAodGhpcy5ibGVuZE1vZGUuYmxlbmRGdW5jdGlvbiA9PT0gQmxlbmRGdW5jdGlvbi5BTFBIQSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiQUxQSEFcIiwgXCIxXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIkFMUEhBXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfSk7XG4gICAgdGhpcy5ibGVuZE1vZGUuYmxlbmRGdW5jdGlvbiA9IGJsZW5kRnVuY3Rpb247XG4gICAgdGhpcy5wYXR0ZXJuVGV4dHVyZSA9IHBhdHRlcm5UZXh0dXJlO1xuICAgIHRoaXMueFJheSA9IHhSYXk7XG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFzayA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDEyKDEsIDEpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFzay5zYW1wbGVzID0gbXVsdGlzYW1wbGluZztcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2sudGV4dHVyZS5uYW1lID0gXCJPdXRsaW5lLk1hc2tcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIm1hc2tUZXh0dXJlXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRNYXNrLnRleHR1cmU7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRPdXRsaW5lID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTIoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRPdXRsaW5lLnRleHR1cmUubmFtZSA9IFwiT3V0bGluZS5FZGdlc1wiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZWRnZVRleHR1cmVcIikudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldE91dGxpbmUudGV4dHVyZTtcbiAgICB0aGlzLmNsZWFyUGFzcyA9IG5ldyBDbGVhclBhc3MoKTtcbiAgICB0aGlzLmNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQ29sb3IgPSBuZXcgQ29sb3I2KDApO1xuICAgIHRoaXMuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJBbHBoYSA9IDE7XG4gICAgdGhpcy5kZXB0aFBhc3MgPSBuZXcgRGVwdGhQYXNzKHNjZW5lLCBjYW1lcmEpO1xuICAgIHRoaXMubWFza1Bhc3MgPSBuZXcgUmVuZGVyUGFzcyhzY2VuZSwgY2FtZXJhLCBuZXcgRGVwdGhDb21wYXJpc29uTWF0ZXJpYWwodGhpcy5kZXB0aFBhc3MudGV4dHVyZSwgY2FtZXJhKSk7XG4gICAgY29uc3QgY2xlYXJQYXNzID0gdGhpcy5tYXNrUGFzcy5jbGVhclBhc3M7XG4gICAgY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjYoMTY3NzcyMTUpO1xuICAgIGNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQWxwaGEgPSAxO1xuICAgIHRoaXMuYmx1clBhc3MgPSBuZXcgS2F3YXNlQmx1clBhc3MoeyByZXNvbHV0aW9uU2NhbGUsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwga2VybmVsU2l6ZSB9KTtcbiAgICB0aGlzLmJsdXJQYXNzLmVuYWJsZWQgPSBibHVyO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmJsdXJQYXNzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICAgIHRoaXMub3V0bGluZVBhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgT3V0bGluZU1hdGVyaWFsKCkpO1xuICAgIGNvbnN0IG91dGxpbmVNYXRlcmlhbCA9IHRoaXMub3V0bGluZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICAgIG91dGxpbmVNYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0TWFzay50ZXh0dXJlO1xuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uKCk7XG4gICAgdGhpcy5wdWxzZVNwZWVkID0gcHVsc2VTcGVlZDtcbiAgfVxuICBzZXQgbWFpblNjZW5lKHZhbHVlKSB7XG4gICAgdGhpcy5zY2VuZSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwdGhQYXNzLm1haW5TY2VuZSA9IHZhbHVlO1xuICAgIHRoaXMubWFza1Bhc3MubWFpblNjZW5lID0gdmFsdWU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwdGhQYXNzLm1haW5DYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLm1hc2tQYXNzLm1haW5DYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLm1hc2tQYXNzLm92ZXJyaWRlTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJlc29sdXRpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEB0eXBlIHtSZXNvbHV0aW9ufVxuICAgKi9cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3MucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7UmVzaXplcn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLmdldFJlc29sdXRpb24oKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBNU0FBIHNhbXBsZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIFdlYkdMIDIuIFNldCB0byB6ZXJvIHRvIGRpc2FibGUgbXVsdGlzYW1wbGluZy5cbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbCBSZXF1aXJlcyB0aHJlZSA+PSByMTM4LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG11bHRpc2FtcGxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0TWFzay5zYW1wbGVzO1xuICB9XG4gIHNldCBtdWx0aXNhbXBsaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrLnNhbXBsZXMgPSB2YWx1ZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2suZGlzcG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcGF0dGVybiBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBwYXR0ZXJuU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwicGF0dGVyblNjYWxlXCIpLnZhbHVlO1xuICB9XG4gIHNldCBwYXR0ZXJuU2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInBhdHRlcm5TY2FsZVwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZWRnZSBzdHJlbmd0aC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBlZGdlU3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiZWRnZVN0cmVuZ3RoXCIpLnZhbHVlO1xuICB9XG4gIHNldCBlZGdlU3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImVkZ2VTdHJlbmd0aFwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdmlzaWJsZSBlZGdlIGNvbG9yLlxuICAgKlxuICAgKiBAdHlwZSB7Q29sb3J9XG4gICAqL1xuICBnZXQgdmlzaWJsZUVkZ2VDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJ2aXNpYmxlRWRnZUNvbG9yXCIpLnZhbHVlO1xuICB9XG4gIHNldCB2aXNpYmxlRWRnZUNvbG9yKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJ2aXNpYmxlRWRnZUNvbG9yXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBoaWRkZW4gZWRnZSBjb2xvci5cbiAgICpcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKi9cbiAgZ2V0IGhpZGRlbkVkZ2VDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJoaWRkZW5FZGdlQ29sb3JcIikudmFsdWU7XG4gIH1cbiAgc2V0IGhpZGRlbkVkZ2VDb2xvcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiaGlkZGVuRWRnZUNvbG9yXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsdXIgcGFzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJQYXNzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0thd2FzZUJsdXJQYXNzfSBUaGUgYmx1ciBwYXNzLlxuICAgKi9cbiAgZ2V0Qmx1clBhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3M7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNlbGVjdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNlbGVjdGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFRoZSBzZWxlY3Rpb24uXG4gICAqL1xuICBnZXRTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwdWxzZSBzcGVlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHB1bHNlU3BlZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3BlZWQuXG4gICAqL1xuICBnZXRQdWxzZVNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLnB1bHNlU3BlZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHB1bHNlIHNwZWVkLiBTZXQgdG8gemVybyB0byBkaXNhYmxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHVsc2VTcGVlZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc3BlZWQuXG4gICAqL1xuICBzZXRQdWxzZVNwZWVkKHZhbHVlKSB7XG4gICAgdGhpcy5wdWxzZVNwZWVkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24ud2lkdGggaW5zdGVhZC5cbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi5oZWlnaHQgaW5zdGVhZC5cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNlbGVjdGlvbiBsYXllci5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNlbGVjdGlvbi5sYXllciBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHNlbGVjdGlvbkxheWVyKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5sYXllcjtcbiAgfVxuICBzZXQgc2VsZWN0aW9uTGF5ZXIodmFsdWUpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5sYXllciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXRoZXJpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgZGl0aGVyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLmRpdGhlcmluZztcbiAgfVxuICBzZXQgZGl0aGVyaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5kaXRoZXJpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIga2VybmVsIHNpemUuXG4gICAqXG4gICAqIEB0eXBlIHtLZXJuZWxTaXplfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3Mua2VybmVsU2l6ZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGtlcm5lbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3Mua2VybmVsU2l6ZTtcbiAgfVxuICBzZXQga2VybmVsU2l6ZSh2YWx1ZSkge1xuICAgIHRoaXMuYmx1clBhc3Mua2VybmVsU2l6ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgb3V0bGluZXMgc2hvdWxkIGJlIGJsdXJyZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3MuZW5hYmxlZCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGJsdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3MuZW5hYmxlZDtcbiAgfVxuICBzZXQgYmx1cih2YWx1ZSkge1xuICAgIHRoaXMuYmx1clBhc3MuZW5hYmxlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBYLXJheSBtb2RlIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHhSYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJYX1JBWVwiKTtcbiAgfVxuICBzZXQgeFJheSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnhSYXkgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIlhfUkFZXCIsIFwiMVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJYX1JBWVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgWC1yYXkgbW9kZSBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgeFJheSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIFgtcmF5IG1vZGUgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzWFJheUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMueFJheTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBYLXJheSBvdXRsaW5lcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHhSYXkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgWC1yYXkgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRYUmF5RW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMueFJheSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcGF0dGVybiB0ZXh0dXJlLiBTZXQgdG8gYG51bGxgIHRvIGRpc2FibGUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHBhdHRlcm5UZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInBhdHRlcm5UZXh0dXJlXCIpLnZhbHVlO1xuICB9XG4gIHNldCBwYXR0ZXJuVGV4dHVyZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUud3JhcFMgPSB2YWx1ZS53cmFwVCA9IFJlcGVhdFdyYXBwaW5nMztcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJVU0VfUEFUVEVSTlwiLCBcIjFcIik7XG4gICAgICB0aGlzLnNldFZlcnRleFNoYWRlcihvdXRsaW5lX2RlZmF1bHQ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIlVTRV9QQVRURVJOXCIpO1xuICAgICAgdGhpcy5zZXRWZXJ0ZXhTaGFkZXIobnVsbCk7XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwicGF0dGVyblRleHR1cmVcIikudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcGF0dGVybiB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcGF0dGVyblRleHR1cmUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBuZXcgdGV4dHVyZS5cbiAgICovXG4gIHNldFBhdHRlcm5UZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy5wYXR0ZXJuVGV4dHVyZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5zY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gVGhlIG5ldyByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0UmVzb2x1dGlvblNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnNjYWxlID0gc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5kIHNlbGVjdHMgYSBsaXN0IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0M0RbXX0gb2JqZWN0cyAtIFRoZSBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIG91dGxpbmVkLiBUaGlzIGFycmF5IHdpbGwgYmUgY29waWVkLlxuICAgKiBAcmV0dXJuIHtPdXRsaW5lUGFzc30gVGhpcyBwYXNzLlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VsZWN0aW9uLnNldCgpIGluc3RlYWQuXG4gICAqL1xuICBzZXRTZWxlY3Rpb24ob2JqZWN0cykge1xuICAgIHRoaXMuc2VsZWN0aW9uLnNldChvYmplY3RzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBsaXN0IG9mIHNlbGVjdGVkIG9iamVjdHMuXG4gICAqXG4gICAqIEByZXR1cm4ge091dGxpbmVQYXNzfSBUaGlzIHBhc3MuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24uY2xlYXIoKSBpbnN0ZWFkLlxuICAgKi9cbiAgY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24uY2xlYXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2VsZWN0cyBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSBvYmplY3QgdGhhdCBzaG91bGQgYmUgb3V0bGluZWQuXG4gICAqIEByZXR1cm4ge091dGxpbmVQYXNzfSBUaGlzIHBhc3MuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24uYWRkKCkgaW5zdGVhZC5cbiAgICovXG4gIHNlbGVjdE9iamVjdChvYmplY3QpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5hZGQob2JqZWN0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVzZWxlY3RzIGFuIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0aGF0IHNob3VsZCBubyBsb25nZXIgYmUgb3V0bGluZWQuXG4gICAqIEByZXR1cm4ge091dGxpbmVQYXNzfSBUaGlzIHBhc3MuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24uZGVsZXRlKCkgaW5zdGVhZC5cbiAgICovXG4gIGRlc2VsZWN0T2JqZWN0KG9iamVjdCkge1xuICAgIHRoaXMuc2VsZWN0aW9uLmRlbGV0ZShvYmplY3QpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuc2NlbmU7XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGNvbnN0IHB1bHNlID0gdW5pZm9ybXMuZ2V0KFwicHVsc2VcIik7XG4gICAgY29uc3QgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XG4gICAgY29uc3QgbWFzayA9IGNhbWVyYS5sYXllcnMubWFzaztcbiAgICBpZiAodGhpcy5mb3JjZVVwZGF0ZSB8fCBzZWxlY3Rpb24uc2l6ZSA+IDApIHtcbiAgICAgIHNjZW5lLmJhY2tncm91bmQgPSBudWxsO1xuICAgICAgcHVsc2UudmFsdWUgPSAxO1xuICAgICAgaWYgKHRoaXMucHVsc2VTcGVlZCA+IDApIHtcbiAgICAgICAgcHVsc2UudmFsdWUgPSBNYXRoLmNvcyh0aGlzLnRpbWUgKiB0aGlzLnB1bHNlU3BlZWQgKiAxMCkgKiAwLjM3NSArIDAuNjI1O1xuICAgICAgfVxuICAgICAgdGhpcy50aW1lICs9IGRlbHRhVGltZTtcbiAgICAgIHNlbGVjdGlvbi5zZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgIHRoaXMuZGVwdGhQYXNzLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICBzZWxlY3Rpb24uc2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgIGNhbWVyYS5sYXllcnMuc2V0KHNlbGVjdGlvbi5sYXllcik7XG4gICAgICB0aGlzLm1hc2tQYXNzLnJlbmRlcihyZW5kZXJlciwgdGhpcy5yZW5kZXJUYXJnZXRNYXNrKTtcbiAgICAgIGNhbWVyYS5sYXllcnMubWFzayA9IG1hc2s7XG4gICAgICBzY2VuZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgICAgIHRoaXMub3V0bGluZVBhc3MucmVuZGVyKHJlbmRlcmVyLCBudWxsLCB0aGlzLnJlbmRlclRhcmdldE91dGxpbmUpO1xuICAgICAgaWYgKHRoaXMuYmx1clBhc3MuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLmJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgdGhpcy5yZW5kZXJUYXJnZXRPdXRsaW5lLCB0aGlzLnJlbmRlclRhcmdldE91dGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZvcmNlVXBkYXRlID0gc2VsZWN0aW9uLnNpemUgPiAwO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5ibHVyUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFzay5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB3ID0gcmVzb2x1dGlvbi53aWR0aCwgaCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgIHRoaXMuZGVwdGhQYXNzLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRPdXRsaW5lLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5vdXRsaW5lUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2V0U2l6ZSh3LCBoKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgVW5zaWduZWRCeXRlVHlwZTExKTtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuZGVwdGhQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgICAgdGhpcy5tYXNrUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICAgIHRoaXMub3V0bGluZVBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9QaXhlbGF0aW9uRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0zMSwgVmVjdG9yMiBhcyBWZWN0b3IyMTYsIFZlY3RvcjQgYXMgVmVjdG9yNDMgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9waXhlbGF0aW9uLmZyYWdcbnZhciBwaXhlbGF0aW9uX2RlZmF1bHQgPSBgdW5pZm9ybSBib29sIGFjdGl2ZTt1bmlmb3JtIHZlYzQgZDt2b2lkIG1haW5Vdihpbm91dCB2ZWMyIHV2KXtpZihhY3RpdmUpe3V2PWQueHkqKGZsb29yKHV2KmQuencpKzAuNSk7fX1gO1xuXG4vLyBzcmMvZWZmZWN0cy9QaXhlbGF0aW9uRWZmZWN0LmpzXG52YXIgUGl4ZWxhdGlvbkVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgcGl4ZWxhdGlvbiBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZ3JhbnVsYXJpdHk9MzAuMF0gLSBUaGUgcGl4ZWwgZ3JhbnVsYXJpdHkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihncmFudWxhcml0eSA9IDMwKSB7XG4gICAgc3VwZXIoXCJQaXhlbGF0aW9uRWZmZWN0XCIsIHBpeGVsYXRpb25fZGVmYXVsdCwge1xuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiYWN0aXZlXCIsIG5ldyBVbmlmb3JtMzEoZmFsc2UpXSxcbiAgICAgICAgW1wiZFwiLCBuZXcgVW5pZm9ybTMxKG5ldyBWZWN0b3I0MygpKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIxNigpO1xuICAgIHRoaXMuX2dyYW51bGFyaXR5ID0gMDtcbiAgICB0aGlzLmdyYW51bGFyaXR5ID0gZ3JhbnVsYXJpdHk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwaXhlbCBncmFudWxhcml0eS5cbiAgICpcbiAgICogQSBoaWdoZXIgdmFsdWUgeWllbGRzIGNvYXJzZXIgdmlzdWFscy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBncmFudWxhcml0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhbnVsYXJpdHk7XG4gIH1cbiAgc2V0IGdyYW51bGFyaXR5KHZhbHVlKSB7XG4gICAgbGV0IGQgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICBpZiAoZCAlIDIgPiAwKSB7XG4gICAgICBkICs9IDE7XG4gICAgfVxuICAgIHRoaXMuX2dyYW51bGFyaXR5ID0gZDtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImFjdGl2ZVwiKS52YWx1ZSA9IGQgPiAwO1xuICAgIHRoaXMuc2V0U2l6ZSh0aGlzLnJlc29sdXRpb24ud2lkdGgsIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaXhlbCBncmFudWxhcml0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGdyYW51bGFyaXR5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGdyYW51bGFyaXR5LlxuICAgKi9cbiAgZ2V0R3JhbnVsYXJpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JhbnVsYXJpdHk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBpeGVsIGdyYW51bGFyaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZ3JhbnVsYXJpdHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyBncmFudWxhcml0eS5cbiAgICovXG4gIHNldEdyYW51bGFyaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5ncmFudWxhcml0eSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBncmFudWxhcml0eS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgZCA9IHRoaXMuZ3JhbnVsYXJpdHk7XG4gICAgY29uc3QgeCA9IGQgLyByZXNvbHV0aW9uLng7XG4gICAgY29uc3QgeSA9IGQgLyByZXNvbHV0aW9uLnk7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJkXCIpLnZhbHVlLnNldCh4LCB5LCAxIC8geCwgMSAvIHkpO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9SZWFsaXN0aWNCb2tlaEVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtMzIsIFZlY3RvcjQgYXMgVmVjdG9yNDQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9yZWFsaXN0aWMtYm9rZWguZnJhZ1xudmFyIHJlYWxpc3RpY19ib2tlaF9kZWZhdWx0ID0gYHVuaWZvcm0gZmxvYXQgZm9jdXM7dW5pZm9ybSBmbG9hdCBmb2NhbExlbmd0aDt1bmlmb3JtIGZsb2F0IGZTdG9wO3VuaWZvcm0gZmxvYXQgbWF4Qmx1cjt1bmlmb3JtIGZsb2F0IGx1bWluYW5jZVRocmVzaG9sZDt1bmlmb3JtIGZsb2F0IGx1bWluYW5jZUdhaW47dW5pZm9ybSBmbG9hdCBiaWFzO3VuaWZvcm0gZmxvYXQgZnJpbmdlO1xuI2lmZGVmIE1BTlVBTF9ET0ZcbnVuaWZvcm0gdmVjNCBkb2Y7XG4jZW5kaWZcbiNpZmRlZiBQRU5UQUdPTlxuZmxvYXQgcGVudGFnb24oY29uc3QgaW4gdmVjMiBjb29yZHMpe2NvbnN0IHZlYzQgSFMwPXZlYzQoMS4wLDAuMCwwLjAsMS4wKTtjb25zdCB2ZWM0IEhTMT12ZWM0KDAuMzA5MDE2OTk0LDAuOTUxMDU2NTE2LDAuMCwxLjApO2NvbnN0IHZlYzQgSFMyPXZlYzQoLTAuODA5MDE2OTk0LDAuNTg3Nzg1MjUyLDAuMCwxLjApO2NvbnN0IHZlYzQgSFMzPXZlYzQoLTAuODA5MDE2OTk0LC0wLjU4Nzc4NTI1MiwwLjAsMS4wKTtjb25zdCB2ZWM0IEhTND12ZWM0KDAuMzA5MDE2OTk0LC0wLjk1MTA1NjUxNiwwLjAsMS4wKTtjb25zdCB2ZWM0IEhTNT12ZWM0KDAuMCwwLjAsMS4wLDEuMCk7Y29uc3QgdmVjNCBPTkU9dmVjNCgxLjApO2NvbnN0IGZsb2F0IFBfRkVBVEhFUj0wLjQ7Y29uc3QgZmxvYXQgTl9GRUFUSEVSPS1QX0ZFQVRIRVI7ZmxvYXQgaW5Pck91dD0tNC4wO3ZlYzQgUD12ZWM0KGNvb3Jkcyx2ZWMyKFJJTkdTX0ZMT0FULTEuMykpO3ZlYzQgZGlzdD12ZWM0KGRvdChQLEhTMCksZG90KFAsSFMxKSxkb3QoUCxIUzIpLGRvdChQLEhTMykpO2Rpc3Q9c21vb3Roc3RlcChOX0ZFQVRIRVIsUF9GRUFUSEVSLGRpc3QpO2luT3JPdXQrPWRvdChkaXN0LE9ORSk7ZGlzdC54PWRvdChQLEhTNCk7ZGlzdC55PUhTNS53LWFicyhQLnopO2Rpc3Q9c21vb3Roc3RlcChOX0ZFQVRIRVIsUF9GRUFUSEVSLGRpc3QpO2luT3JPdXQrPWRpc3QueDtyZXR1cm4gY2xhbXAoaW5Pck91dCwwLjAsMS4wKTt9XG4jZW5kaWZcbnZlYzMgcHJvY2Vzc1RleGVsKGNvbnN0IGluIHZlYzIgY29vcmRzLGNvbnN0IGluIGZsb2F0IGJsdXIpe3ZlYzIgc2NhbGU9dGV4ZWxTaXplKmZyaW5nZSpibHVyO3ZlYzMgYz12ZWMzKHRleHR1cmUyRChpbnB1dEJ1ZmZlcixjb29yZHMrdmVjMigwLjAsMS4wKSpzY2FsZSkucix0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmRzK3ZlYzIoLTAuODY2LC0wLjUpKnNjYWxlKS5nLHRleHR1cmUyRChpbnB1dEJ1ZmZlcixjb29yZHMrdmVjMigwLjg2NiwtMC41KSpzY2FsZSkuYik7ZmxvYXQgbHVtaW5hbmNlPWxpbmVhclRvUmVsYXRpdmVMdW1pbmFuY2UoYyk7ZmxvYXQgdGhyZXNob2xkPW1heCgobHVtaW5hbmNlLWx1bWluYW5jZVRocmVzaG9sZCkqbHVtaW5hbmNlR2FpbiwwLjApO3JldHVybiBjK21peCh2ZWMzKDAuMCksYyx0aHJlc2hvbGQqYmx1cik7fWZsb2F0IGdhdGhlcihjb25zdCBpbiBmbG9hdCBpLGNvbnN0IGluIGZsb2F0IGosY29uc3QgaW4gZmxvYXQgcmluZ1NhbXBsZXMsY29uc3QgaW4gdmVjMiB1dixjb25zdCBpbiB2ZWMyIGJsdXJGYWN0b3IsY29uc3QgaW4gZmxvYXQgYmx1cixpbm91dCB2ZWMzIGNvbG9yKXtmbG9hdCBzdGVwPVBJMi9yaW5nU2FtcGxlczt2ZWMyIHdoPXZlYzIoY29zKGoqc3RlcCkqaSxzaW4oaipzdGVwKSppKTtcbiNpZmRlZiBQRU5UQUdPTlxuZmxvYXQgcD1wZW50YWdvbih3aCk7XG4jZWxzZVxuZmxvYXQgcD0xLjA7XG4jZW5kaWZcbmNvbG9yKz1wcm9jZXNzVGV4ZWwod2gqYmx1ckZhY3Rvcit1dixibHVyKSptaXgoMS4wLGkvUklOR1NfRkxPQVQsYmlhcykqcDtyZXR1cm4gbWl4KDEuMCxpL1JJTkdTX0ZMT0FULGJpYXMpKnA7fXZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LGNvbnN0IGluIGZsb2F0IGRlcHRoLG91dCB2ZWM0IG91dHB1dENvbG9yKXtcbiNpZmRlZiBQRVJTUEVDVElWRV9DQU1FUkFcbmZsb2F0IHZpZXdaPXBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtmbG9hdCBsaW5lYXJEZXB0aD12aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgodmlld1osY2FtZXJhTmVhcixjYW1lcmFGYXIpO1xuI2Vsc2VcbmZsb2F0IGxpbmVhckRlcHRoPWRlcHRoO1xuI2VuZGlmXG4jaWZkZWYgTUFOVUFMX0RPRlxuZmxvYXQgZm9jYWxQbGFuZT1saW5lYXJEZXB0aC1mb2N1cztmbG9hdCBmYXJEb0Y9KGZvY2FsUGxhbmUtZG9mLnopL2RvZi53O2Zsb2F0IG5lYXJEb0Y9KC1mb2NhbFBsYW5lLWRvZi54KS9kb2YueTtmbG9hdCBibHVyPShmb2NhbFBsYW5lPjAuMCk/ZmFyRG9GOm5lYXJEb0Y7XG4jZWxzZVxuY29uc3QgZmxvYXQgQ0lSQ0xFX09GX0NPTkZVU0lPTj0wLjAzO2Zsb2F0IGZvY2FsUGxhbmVNTT1mb2N1cyoxMDAwLjA7ZmxvYXQgZGVwdGhNTT1saW5lYXJEZXB0aCoxMDAwLjA7ZmxvYXQgZm9jYWxQbGFuZT0oZGVwdGhNTSpmb2NhbExlbmd0aCkvKGRlcHRoTU0tZm9jYWxMZW5ndGgpO2Zsb2F0IGZhckRvRj0oZm9jYWxQbGFuZU1NKmZvY2FsTGVuZ3RoKS8oZm9jYWxQbGFuZU1NLWZvY2FsTGVuZ3RoKTtmbG9hdCBuZWFyRG9GPShmb2NhbFBsYW5lTU0tZm9jYWxMZW5ndGgpLyhmb2NhbFBsYW5lTU0qZlN0b3AqQ0lSQ0xFX09GX0NPTkZVU0lPTik7ZmxvYXQgYmx1cj1hYnMoZm9jYWxQbGFuZS1mYXJEb0YpKm5lYXJEb0Y7XG4jZW5kaWZcbmNvbnN0IGludCBNQVhfUklOR19TQU1QTEVTPVJJTkdTX0lOVCpTQU1QTEVTX0lOVDtibHVyPWNsYW1wKGJsdXIsMC4wLDEuMCk7dmVjMyBjb2xvcj1pbnB1dENvbG9yLnJnYjtpZihibHVyPj0wLjA1KXt2ZWMyIGJsdXJGYWN0b3I9Ymx1ciptYXhCbHVyKnRleGVsU2l6ZTtmbG9hdCBzPTEuMDtpbnQgcmluZ1NhbXBsZXM7Zm9yKGludCBpPTE7aTw9UklOR1NfSU5UO2krKyl7cmluZ1NhbXBsZXM9aSpTQU1QTEVTX0lOVDtmb3IoaW50IGo9MDtqPE1BWF9SSU5HX1NBTVBMRVM7aisrKXtpZihqPj1yaW5nU2FtcGxlcyl7YnJlYWs7fXMrPWdhdGhlcihmbG9hdChpKSxmbG9hdChqKSxmbG9hdChyaW5nU2FtcGxlcyksdXYsYmx1ckZhY3RvcixibHVyLGNvbG9yKTt9fWNvbG9yLz1zO31cbiNpZmRlZiBTSE9XX0ZPQ1VTXG5mbG9hdCBlZGdlPTAuMDAyKmxpbmVhckRlcHRoO2Zsb2F0IG09Y2xhbXAoc21vb3Roc3RlcCgwLjAsZWRnZSxibHVyKSwwLjAsMS4wKTtmbG9hdCBlPWNsYW1wKHNtb290aHN0ZXAoMS4wLWVkZ2UsMS4wLGJsdXIpLDAuMCwxLjApO2NvbG9yPW1peChjb2xvcix2ZWMzKDEuMCwwLjUsMC4wKSwoMS4wLW0pKjAuNik7Y29sb3I9bWl4KGNvbG9yLHZlYzMoMC4wLDAuNSwxLjApLCgoMS4wLWUpLSgxLjAtbSkpKjAuMik7XG4jZW5kaWZcbm91dHB1dENvbG9yPXZlYzQoY29sb3IsaW5wdXRDb2xvci5hKTt9YDtcblxuLy8gc3JjL2VmZmVjdHMvUmVhbGlzdGljQm9rZWhFZmZlY3QuanNcbnZhciBSZWFsaXN0aWNCb2tlaEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYm9rZWggZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mb2N1cz0xLjBdIC0gVGhlIGZvY3VzIGRpc3RhbmNlIGluIHdvcmxkIHVuaXRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jYWxMZW5ndGg9MjQuMF0gLSBUaGUgZm9jYWwgbGVuZ3RoIG9mIHRoZSBtYWluIGNhbWVyYS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZTdG9wPTAuOV0gLSBUaGUgcmF0aW8gb2YgdGhlIGxlbnMgZm9jYWwgbGVuZ3RoIHRvIHRoZSBkaWFtZXRlciBvZiB0aGUgZW50cmFuY2UgcHVwaWwgKGFwZXJ0dXJlKS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmx1bWluYW5jZVRocmVzaG9sZD0wLjVdIC0gQSBsdW1pbmFuY2UgdGhyZXNob2xkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubHVtaW5hbmNlR2Fpbj0yLjBdIC0gQSBsdW1pbmFuY2UgZ2FpbiBmYWN0b3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iaWFzPTAuNV0gLSBBIGJsdXIgYmlhcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZyaW5nZT0wLjddIC0gQSBibHVyIG9mZnNldC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEJsdXI9MS4wXSAtIFRoZSBtYXhpbXVtIGJsdXIgc3RyZW5ndGguXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmluZ3M9M10gLSBUaGUgbnVtYmVyIG9mIGJsdXIgaXRlcmF0aW9ucy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zYW1wbGVzPTJdIC0gVGhlIGFtb3VudCBvZiBzYW1wbGVzIHRha2VuIHBlciByaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNob3dGb2N1cz1mYWxzZV0gLSBXaGV0aGVyIHRoZSBmb2NhbCBwb2ludCBzaG91bGQgYmUgaGlnaGxpZ2h0ZWQuIFVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hbnVhbERvRj1mYWxzZV0gLSBFbmFibGVzIG1hbnVhbCBjb250cm9sIG92ZXIgdGhlIGRlcHRoIG9mIGZpZWxkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBlbnRhZ29uPWZhbHNlXSAtIEVuYWJsZXMgcGVudGFnb25hbCBibHVyIHNoYXBlcy4gUmVxdWlyZXMgYSBoaWdoIG51bWJlciBvZiByaW5ncyBhbmQgc2FtcGxlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBibGVuZEZ1bmN0aW9uLFxuICAgIGZvY3VzID0gMSxcbiAgICBmb2NhbExlbmd0aCA9IDI0LFxuICAgIGZTdG9wID0gMC45LFxuICAgIGx1bWluYW5jZVRocmVzaG9sZCA9IDAuNSxcbiAgICBsdW1pbmFuY2VHYWluID0gMixcbiAgICBiaWFzID0gMC41LFxuICAgIGZyaW5nZSA9IDAuNyxcbiAgICBtYXhCbHVyID0gMSxcbiAgICByaW5ncyA9IDMsXG4gICAgc2FtcGxlcyA9IDIsXG4gICAgc2hvd0ZvY3VzID0gZmFsc2UsXG4gICAgbWFudWFsRG9GID0gZmFsc2UsXG4gICAgcGVudGFnb24gPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIlJlYWxpc3RpY0Jva2VoRWZmZWN0XCIsIHJlYWxpc3RpY19ib2tlaF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgYXR0cmlidXRlczogRWZmZWN0QXR0cmlidXRlLkNPTlZPTFVUSU9OIHwgRWZmZWN0QXR0cmlidXRlLkRFUFRILFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiZm9jdXNcIiwgbmV3IFVuaWZvcm0zMihmb2N1cyldLFxuICAgICAgICBbXCJmb2NhbExlbmd0aFwiLCBuZXcgVW5pZm9ybTMyKGZvY2FsTGVuZ3RoKV0sXG4gICAgICAgIFtcImZTdG9wXCIsIG5ldyBVbmlmb3JtMzIoZlN0b3ApXSxcbiAgICAgICAgW1wibHVtaW5hbmNlVGhyZXNob2xkXCIsIG5ldyBVbmlmb3JtMzIobHVtaW5hbmNlVGhyZXNob2xkKV0sXG4gICAgICAgIFtcImx1bWluYW5jZUdhaW5cIiwgbmV3IFVuaWZvcm0zMihsdW1pbmFuY2VHYWluKV0sXG4gICAgICAgIFtcImJpYXNcIiwgbmV3IFVuaWZvcm0zMihiaWFzKV0sXG4gICAgICAgIFtcImZyaW5nZVwiLCBuZXcgVW5pZm9ybTMyKGZyaW5nZSldLFxuICAgICAgICBbXCJtYXhCbHVyXCIsIG5ldyBVbmlmb3JtMzIobWF4Qmx1cildLFxuICAgICAgICBbXCJkb2ZcIiwgbmV3IFVuaWZvcm0zMihudWxsKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yaW5ncyA9IHJpbmdzO1xuICAgIHRoaXMuc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgdGhpcy5zaG93Rm9jdXMgPSBzaG93Rm9jdXM7XG4gICAgdGhpcy5tYW51YWxEb0YgPSBtYW51YWxEb0Y7XG4gICAgdGhpcy5wZW50YWdvbiA9IHBlbnRhZ29uO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIGJsdXIgaXRlcmF0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByaW5ncygpIHtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHRoaXMuZGVmaW5lcy5nZXQoXCJSSU5HU19JTlRcIikpO1xuICB9XG4gIHNldCByaW5ncyh2YWx1ZSkge1xuICAgIGNvbnN0IHIgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiUklOR1NfSU5UXCIsIHIudG9GaXhlZCgwKSk7XG4gICAgdGhpcy5kZWZpbmVzLnNldChcIlJJTkdTX0ZMT0FUXCIsIHIudG9GaXhlZCgxKSk7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgYmx1ciBzYW1wbGVzIHBlciByaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNhbXBsZXMoKSB7XG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUludCh0aGlzLmRlZmluZXMuZ2V0KFwiU0FNUExFU19JTlRcIikpO1xuICB9XG4gIHNldCBzYW1wbGVzKHZhbHVlKSB7XG4gICAgY29uc3QgcyA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJTQU1QTEVTX0lOVFwiLCBzLnRvRml4ZWQoMCkpO1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJTQU1QTEVTX0ZMT0FUXCIsIHMudG9GaXhlZCgxKSk7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBmb2NhbCBwb2ludCB3aWxsIGJlIGhpZ2hsaWdodGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBzaG93Rm9jdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJTSE9XX0ZPQ1VTXCIpO1xuICB9XG4gIHNldCBzaG93Rm9jdXModmFsdWUpIHtcbiAgICBpZiAodGhpcy5zaG93Rm9jdXMgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIlNIT1dfRk9DVVNcIiwgXCIxXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIlNIT1dfRk9DVVNcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBEZXB0aCBvZiBGaWVsZCBzaG91bGQgYmUgY2FsY3VsYXRlZCBtYW51YWxseS5cbiAgICpcbiAgICogSWYgZW5hYmxlZCwgdGhlIERlcHRoIG9mIEZpZWxkIGNhbiBiZSBhZGp1c3RlZCB2aWEgdGhlIGBkb2ZgIHVuaWZvcm0uXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IG1hbnVhbERvRigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLmhhcyhcIk1BTlVBTF9ET0ZcIik7XG4gIH1cbiAgc2V0IG1hbnVhbERvRih2YWx1ZSkge1xuICAgIGlmICh0aGlzLm1hbnVhbERvRiAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiTUFOVUFMX0RPRlwiLCBcIjFcIik7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZG9mXCIpLnZhbHVlID0gbmV3IFZlY3RvcjQ0KDAuMiwgMSwgMC4yLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJNQU5VQUxfRE9GXCIpO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmdldChcImRvZlwiKS52YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBibHVyIHNoYXBlIHNob3VsZCBiZSBwZW50YWdvbmFsLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBwZW50YWdvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLmhhcyhcIlBFTlRBR09OXCIpO1xuICB9XG4gIHNldCBwZW50YWdvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLnBlbnRhZ29uICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJQRU5UQUdPTlwiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiUEVOVEFHT05cIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1NjYW5saW5lRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0zMywgVmVjdG9yMiBhcyBWZWN0b3IyMTcgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9zY2FubGluZXMuZnJhZ1xudmFyIHNjYW5saW5lc19kZWZhdWx0ID0gYHVuaWZvcm0gZmxvYXQgY291bnQ7XG4jaWZkZWYgU0NST0xMXG51bmlmb3JtIGZsb2F0IHNjcm9sbFNwZWVkO1xuI2VuZGlmXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7ZmxvYXQgeT11di55O1xuI2lmZGVmIFNDUk9MTFxueSs9dGltZSpzY3JvbGxTcGVlZDtcbiNlbmRpZlxudmVjMiBzbD12ZWMyKHNpbih5KmNvdW50KSxjb3MoeSpjb3VudCkpO291dHB1dENvbG9yPXZlYzQoc2wueHl4LGlucHV0Q29sb3IuYSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL1NjYW5saW5lRWZmZWN0LmpzXG52YXIgU2NhbmxpbmVFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHNjYW5saW5lIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5PVkVSTEFZXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlbnNpdHk9MS4yNV0gLSBUaGUgc2NhbmxpbmUgZGVuc2l0eS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNjcm9sbFNwZWVkPTAuMF0gLSBUaGUgc2NhbmxpbmUgc2Nyb2xsIHNwZWVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5PVkVSTEFZLCBkZW5zaXR5ID0gMS4yNSwgc2Nyb2xsU3BlZWQgPSAwIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiU2NhbmxpbmVFZmZlY3RcIiwgc2NhbmxpbmVzX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJjb3VudFwiLCBuZXcgVW5pZm9ybTMzKDApXSxcbiAgICAgICAgW1wic2Nyb2xsU3BlZWRcIiwgbmV3IFVuaWZvcm0zMygwKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIxNygpO1xuICAgIHRoaXMuZCA9IGRlbnNpdHk7XG4gICAgdGhpcy5zY3JvbGxTcGVlZCA9IHNjcm9sbFNwZWVkO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2NhbmxpbmUgZGVuc2l0eS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBkZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmQ7XG4gIH1cbiAgc2V0IGRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLmQgPSB2YWx1ZTtcbiAgICB0aGlzLnNldFNpemUodGhpcy5yZXNvbHV0aW9uLndpZHRoLCB0aGlzLnJlc29sdXRpb24uaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzY2FubGluZSBkZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzY2FubGluZSBkZW5zaXR5LlxuICAgKi9cbiAgZ2V0RGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZW5zaXR5O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzY2FubGluZSBkZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IHNjYW5saW5lIGRlbnNpdHkuXG4gICAqL1xuICBzZXREZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5kZW5zaXR5ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY2FubGluZSBzY3JvbGwgc3BlZWQuIERlZmF1bHQgaXMgMCAoZGlzYWJsZWQpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNjcm9sbFNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInNjcm9sbFNwZWVkXCIpLnZhbHVlO1xuICB9XG4gIHNldCBzY3JvbGxTcGVlZCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwic2Nyb2xsU3BlZWRcIikudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIGlmICh0aGlzLmRlZmluZXMuZGVsZXRlKFwiU0NST0xMXCIpKSB7XG4gICAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuZGVmaW5lcy5oYXMoXCJTQ1JPTExcIikpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJTQ1JPTExcIiwgXCIxXCIpO1xuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJjb3VudFwiKS52YWx1ZSA9IE1hdGgucm91bmQoaGVpZ2h0ICogdGhpcy5kZW5zaXR5KTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvU2hvY2tXYXZlRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0zNCwgVmVjdG9yMiBhcyBWZWN0b3IyMTgsIFZlY3RvcjMgYXMgVmVjdG9yMzUgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9zaG9jay13YXZlLmZyYWdcbnZhciBzaG9ja193YXZlX2RlZmF1bHQgPSBgdW5pZm9ybSBib29sIGFjdGl2ZTt1bmlmb3JtIHZlYzIgY2VudGVyO3VuaWZvcm0gZmxvYXQgd2F2ZVNpemU7dW5pZm9ybSBmbG9hdCByYWRpdXM7dW5pZm9ybSBmbG9hdCBtYXhSYWRpdXM7dW5pZm9ybSBmbG9hdCBhbXBsaXR1ZGU7dmFyeWluZyBmbG9hdCB2U2l6ZTt2b2lkIG1haW5Vdihpbm91dCB2ZWMyIHV2KXtpZihhY3RpdmUpe3ZlYzIgYXNwZWN0Q29ycmVjdGlvbj12ZWMyKGFzcGVjdCwxLjApO3ZlYzIgZGlmZmVyZW5jZT11diphc3BlY3RDb3JyZWN0aW9uLWNlbnRlciphc3BlY3RDb3JyZWN0aW9uO2Zsb2F0IGRpc3RhbmNlPXNxcnQoZG90KGRpZmZlcmVuY2UsZGlmZmVyZW5jZSkpKnZTaXplO2lmKGRpc3RhbmNlPnJhZGl1cyl7aWYoZGlzdGFuY2U8cmFkaXVzK3dhdmVTaXplKXtmbG9hdCBhbmdsZT0oZGlzdGFuY2UtcmFkaXVzKSpQSTIvd2F2ZVNpemU7ZmxvYXQgY29zU2luPSgxLjAtY29zKGFuZ2xlKSkqMC41O2Zsb2F0IGV4dGVudD1tYXhSYWRpdXMrd2F2ZVNpemU7ZmxvYXQgZGVjYXk9bWF4KGV4dGVudC1kaXN0YW5jZSpkaXN0YW5jZSwwLjApL2V4dGVudDt1di09KChjb3NTaW4qYW1wbGl0dWRlKmRpZmZlcmVuY2UpL2Rpc3RhbmNlKSpkZWNheTt9fX19YDtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9zaG9jay13YXZlLnZlcnRcbnZhciBzaG9ja193YXZlX2RlZmF1bHQyID0gYHVuaWZvcm0gZmxvYXQgc2l6ZTt1bmlmb3JtIGZsb2F0IGNhbWVyYURpc3RhbmNlO3ZhcnlpbmcgZmxvYXQgdlNpemU7dm9pZCBtYWluU3VwcG9ydCgpe3ZTaXplPSgwLjEqY2FtZXJhRGlzdGFuY2UpL3NpemU7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL1Nob2NrV2F2ZUVmZmVjdC5qc1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJICogMC41O1xudmFyIHYyID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzNSgpO1xudmFyIGFiID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzNSgpO1xudmFyIFNob2NrV2F2ZUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgc2hvY2sgd2F2ZSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgbWFpbiBjYW1lcmEuXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gW3Bvc2l0aW9uXSAtIFRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgc2hvY2sgd2F2ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3BlZWQ9Mi4wXSAtIFRoZSBhbmltYXRpb24gc3BlZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSYWRpdXM9MS4wXSAtIFRoZSBleHRlbnQgb2YgdGhlIHNob2NrIHdhdmUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53YXZlU2l6ZT0wLjJdIC0gVGhlIHdhdmUgc2l6ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFtcGxpdHVkZT0wLjA1XSAtIFRoZSBkaXN0b3J0aW9uIGFtcGxpdHVkZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbWVyYSwgcG9zaXRpb24gPSBuZXcgVmVjdG9yMzUoKSwge1xuICAgIHNwZWVkID0gMixcbiAgICBtYXhSYWRpdXMgPSAxLFxuICAgIHdhdmVTaXplID0gMC4yLFxuICAgIGFtcGxpdHVkZSA9IDAuMDVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJTaG9ja1dhdmVFZmZlY3RcIiwgc2hvY2tfd2F2ZV9kZWZhdWx0LCB7XG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHNob2NrX3dhdmVfZGVmYXVsdDIsXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJhY3RpdmVcIiwgbmV3IFVuaWZvcm0zNChmYWxzZSldLFxuICAgICAgICBbXCJjZW50ZXJcIiwgbmV3IFVuaWZvcm0zNChuZXcgVmVjdG9yMjE4KDAuNSwgMC41KSldLFxuICAgICAgICBbXCJjYW1lcmFEaXN0YW5jZVwiLCBuZXcgVW5pZm9ybTM0KDEpXSxcbiAgICAgICAgW1wic2l6ZVwiLCBuZXcgVW5pZm9ybTM0KDEpXSxcbiAgICAgICAgW1wicmFkaXVzXCIsIG5ldyBVbmlmb3JtMzQoLXdhdmVTaXplKV0sXG4gICAgICAgIFtcIm1heFJhZGl1c1wiLCBuZXcgVW5pZm9ybTM0KG1heFJhZGl1cyldLFxuICAgICAgICBbXCJ3YXZlU2l6ZVwiLCBuZXcgVW5pZm9ybTM0KHdhdmVTaXplKV0sXG4gICAgICAgIFtcImFtcGxpdHVkZVwiLCBuZXcgVW5pZm9ybTM0KGFtcGxpdHVkZSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5zY3JlZW5Qb3NpdGlvbiA9IHRoaXMudW5pZm9ybXMuZ2V0KFwiY2VudGVyXCIpLnZhbHVlO1xuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICAgIHRoaXMuY2FtZXJhID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbXBsaXR1ZGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYW1wbGl0dWRlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImFtcGxpdHVkZVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgYW1wbGl0dWRlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJhbXBsaXR1ZGVcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHdhdmUgc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3YXZlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJ3YXZlU2l6ZVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgd2F2ZVNpemUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIndhdmVTaXplXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHJhZGl1cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtYXhSYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwibWF4UmFkaXVzXCIpLnZhbHVlO1xuICB9XG4gIHNldCBtYXhSYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIm1heFJhZGl1c1wiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIHNob2NrIHdhdmUuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IzfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcG9zaXRpb24gaW5zdGVhZC5cbiAgICovXG4gIGdldCBlcGljZW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gIH1cbiAgc2V0IGVwaWNlbnRlcih2YWx1ZSkge1xuICAgIHRoaXMucG9zaXRpb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIHNob2NrIHdhdmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwb3NpdGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtWZWN0b3IzfSBUaGUgcG9zaXRpb24uXG4gICAqL1xuICBnZXRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHNob2NrIHdhdmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwb3NpdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZhbHVlIC0gVGhlIHBvc2l0aW9uLlxuICAgKi9cbiAgc2V0UG9zaXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnBvc2l0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNwZWVkIG9mIHRoZSBzaG9jayB3YXZlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3BlZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3BlZWQuXG4gICAqL1xuICBnZXRTcGVlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGVlZDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3BlZWQgb2YgdGhlIHNob2NrIHdhdmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzcGVlZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc3BlZWQuXG4gICAqL1xuICBzZXRTcGVlZCh2YWx1ZSkge1xuICAgIHRoaXMuc3BlZWQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogRW1pdHMgdGhlIHNob2NrIHdhdmUuXG4gICAqL1xuICBleHBsb2RlKCkge1xuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYWN0aXZlXCIpLnZhbHVlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YSkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gICAgY29uc3QgdUFjdGl2ZSA9IHVuaWZvcm1zLmdldChcImFjdGl2ZVwiKTtcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIGNvbnN0IHdhdmVTaXplID0gdW5pZm9ybXMuZ2V0KFwid2F2ZVNpemVcIikudmFsdWU7XG4gICAgICBjYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24odjIpO1xuICAgICAgYWIuY29weShjYW1lcmEucG9zaXRpb24pLnN1Yihwb3NpdGlvbik7XG4gICAgICB1QWN0aXZlLnZhbHVlID0gdjIuYW5nbGVUbyhhYikgPiBIQUxGX1BJO1xuICAgICAgaWYgKHVBY3RpdmUudmFsdWUpIHtcbiAgICAgICAgdW5pZm9ybXMuZ2V0KFwiY2FtZXJhRGlzdGFuY2VcIikudmFsdWUgPSBjYW1lcmEucG9zaXRpb24uZGlzdGFuY2VUbyhwb3NpdGlvbik7XG4gICAgICAgIHYyLmNvcHkocG9zaXRpb24pLnByb2plY3QoY2FtZXJhKTtcbiAgICAgICAgdGhpcy5zY3JlZW5Qb3NpdGlvbi5zZXQoKHYyLnggKyAxKSAqIDAuNSwgKHYyLnkgKyAxKSAqIDAuNSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpbWUgKz0gZGVsdGEgKiB0aGlzLnNwZWVkO1xuICAgICAgY29uc3QgcmFkaXVzID0gdGhpcy50aW1lIC0gd2F2ZVNpemU7XG4gICAgICB1bmlmb3Jtcy5nZXQoXCJyYWRpdXNcIikudmFsdWUgPSByYWRpdXM7XG4gICAgICBpZiAocmFkaXVzID49ICh1bmlmb3Jtcy5nZXQoXCJtYXhSYWRpdXNcIikudmFsdWUgKyB3YXZlU2l6ZSkgKiAyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHVBY3RpdmUudmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1NlbGVjdGl2ZUJsb29tRWZmZWN0LmpzXG5pbXBvcnQge1xuICBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzcsXG4gIENvbG9yIGFzIENvbG9yNyxcbiAgTm90RXF1YWxEZXB0aCBhcyBOb3RFcXVhbERlcHRoMixcbiAgRXF1YWxEZXB0aCBhcyBFcXVhbERlcHRoMixcbiAgUkdCQURlcHRoUGFja2luZyBhcyBSR0JBRGVwdGhQYWNraW5nMyxcbiAgU1JHQkNvbG9yU3BhY2UgYXMgU1JHQkNvbG9yU3BhY2UxMSxcbiAgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxM1xufSBmcm9tIFwidGhyZWVcIjtcbnZhciBTZWxlY3RpdmVCbG9vbUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgQmxvb21FZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBzZWxlY3RpdmUgYmxvb20gZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBtYWluIHNjZW5lLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuIFNlZSB7QGxpbmsgQmxvb21FZmZlY3R9IGZvciBkZXRhaWxzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSwgb3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlcyh0aGlzLmdldEF0dHJpYnV0ZXMoKSB8IEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCk7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5kZXB0aFBhc3MgPSBuZXcgRGVwdGhQYXNzKHNjZW5lLCBjYW1lcmEpO1xuICAgIHRoaXMuY2xlYXJQYXNzID0gbmV3IENsZWFyUGFzcyh0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjcoMCk7XG4gICAgdGhpcy5kZXB0aE1hc2tQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IERlcHRoTWFza01hdGVyaWFsKCkpO1xuICAgIGNvbnN0IGRlcHRoTWFza01hdGVyaWFsID0gdGhpcy5kZXB0aE1hc2tNYXRlcmlhbDtcbiAgICBkZXB0aE1hc2tNYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTtcbiAgICBkZXB0aE1hc2tNYXRlcmlhbC5kZXB0aEJ1ZmZlcjEgPSB0aGlzLmRlcHRoUGFzcy50ZXh0dXJlO1xuICAgIGRlcHRoTWFza01hdGVyaWFsLmRlcHRoUGFja2luZzEgPSBSR0JBRGVwdGhQYWNraW5nMztcbiAgICBkZXB0aE1hc2tNYXRlcmlhbC5kZXB0aE1vZGUgPSBFcXVhbERlcHRoMjtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2tlZCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDEzKDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnRleHR1cmUubmFtZSA9IFwiQmxvb20uTWFza2VkXCI7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uKCk7XG4gICAgdGhpcy5faW52ZXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pZ25vcmVCYWNrZ3JvdW5kID0gZmFsc2U7XG4gIH1cbiAgc2V0IG1haW5TY2VuZSh2YWx1ZSkge1xuICAgIHRoaXMuZGVwdGhQYXNzLm1haW5TY2VuZSA9IHZhbHVlO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5jYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoUGFzcy5tYWluQ2FtZXJhID0gdmFsdWU7XG4gICAgdGhpcy5kZXB0aE1hc2tNYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3ModmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBUaGUgc2VsZWN0aW9uLlxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIG1hc2sgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aE1hc2tNYXRlcmlhbH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBkZXB0aE1hc2tNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZXB0aE1hc2tQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgY29uc2lkZXJlZCBpbnZlcnRlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaW52ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludmVydGVkO1xuICB9XG4gIHNldCBpbnZlcnRlZCh2YWx1ZSkge1xuICAgIHRoaXMuX2ludmVydGVkID0gdmFsdWU7XG4gICAgdGhpcy5kZXB0aE1hc2tNYXRlcmlhbC5kZXB0aE1vZGUgPSB2YWx1ZSA/IE5vdEVxdWFsRGVwdGgyIDogRXF1YWxEZXB0aDI7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtYXNrIGlzIGludmVydGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW52ZXJ0ZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbWFzayBpcyBpbnZlcnRlZC5cbiAgICovXG4gIGlzSW52ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52ZXJ0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZSBtYXNrIGludmVyc2lvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludmVydGVkIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRoZSBtYXNrIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICovXG4gIHNldEludmVydGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pbnZlcnRlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYmFja2dyb3VuZCBjb2xvcnMgd2lsbCBiZSBpZ25vcmVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpZ25vcmVCYWNrZ3JvdW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9pZ25vcmVCYWNrZ3JvdW5kO1xuICB9XG4gIHNldCBpZ25vcmVCYWNrZ3JvdW5kKHZhbHVlKSB7XG4gICAgdGhpcy5faWdub3JlQmFja2dyb3VuZCA9IHZhbHVlO1xuICAgIHRoaXMuZGVwdGhNYXNrTWF0ZXJpYWwubWF4RGVwdGhTdHJhdGVneSA9IHZhbHVlID8gRGVwdGhUZXN0U3RyYXRlZ3kuRElTQ0FSRF9NQVhfREVQVEggOiBEZXB0aFRlc3RTdHJhdGVneS5LRUVQX01BWF9ERVBUSDtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJhY2tncm91bmQgaXMgZGlzYWJsZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpZ25vcmVCYWNrZ3JvdW5kIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGJhY2tncm91bmQgaXMgZGlzYWJsZWQuXG4gICAqL1xuICBpc0JhY2tncm91bmREaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pZ25vcmVCYWNrZ3JvdW5kO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBiYWNrZ3JvdW5kLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaWdub3JlQmFja2dyb3VuZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciB0aGUgYmFja2dyb3VuZCBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBzZXRCYWNrZ3JvdW5kRGlzYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmlnbm9yZUJhY2tncm91bmQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nNykge1xuICAgIHRoaXMuZGVwdGhNYXNrTWF0ZXJpYWwuZGVwdGhCdWZmZXIwID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuZGVwdGhNYXNrTWF0ZXJpYWwuZGVwdGhQYWNraW5nMCA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSB0aGlzLmludmVydGVkO1xuICAgIGxldCByZW5kZXJUYXJnZXQgPSBpbnB1dEJ1ZmZlcjtcbiAgICBpZiAodGhpcy5pZ25vcmVCYWNrZ3JvdW5kIHx8ICFpbnZlcnRlZCB8fCBzZWxlY3Rpb24uc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBjYW1lcmEubGF5ZXJzLm1hc2s7XG4gICAgICBjYW1lcmEubGF5ZXJzLnNldChzZWxlY3Rpb24ubGF5ZXIpO1xuICAgICAgdGhpcy5kZXB0aFBhc3MucmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgIGNhbWVyYS5sYXllcnMubWFzayA9IG1hc2s7XG4gICAgICByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldE1hc2tlZDtcbiAgICAgIHRoaXMuY2xlYXJQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0KTtcbiAgICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCByZW5kZXJUYXJnZXQpO1xuICAgIH1cbiAgICBzdXBlci51cGRhdGUocmVuZGVyZXIsIHJlbmRlclRhcmdldCwgZGVsdGFUaW1lKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHN1cGVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmRlcHRoUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHN1cGVyLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuY2xlYXJQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuZGVwdGhQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICBpZiAocmVuZGVyZXIgIT09IG51bGwgJiYgcmVuZGVyZXIuY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIpIHtcbiAgICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVmaW5lcy5MT0dfREVQVEggPSBcIjFcIjtcbiAgICB9XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldE1hc2tlZC50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICBpZiAocmVuZGVyZXIgIT09IG51bGwgJiYgcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UxMSkge1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldE1hc2tlZC50ZXh0dXJlLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTExO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvU2VwaWFFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTM1LCBWZWN0b3IzIGFzIFZlY3RvcjM2IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvc2VwaWEuZnJhZ1xudmFyIHNlcGlhX2RlZmF1bHQgPSBgdW5pZm9ybSB2ZWMzIHdlaWdodHNSO3VuaWZvcm0gdmVjMyB3ZWlnaHRzRzt1bmlmb3JtIHZlYzMgd2VpZ2h0c0I7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzMgY29sb3I9dmVjMyhkb3QoaW5wdXRDb2xvci5yZ2Isd2VpZ2h0c1IpLGRvdChpbnB1dENvbG9yLnJnYix3ZWlnaHRzRyksZG90KGlucHV0Q29sb3IucmdiLHdlaWdodHNCKSk7b3V0cHV0Q29sb3I9dmVjNChjb2xvcixpbnB1dENvbG9yLmEpO31gO1xuXG4vLyBzcmMvZWZmZWN0cy9TZXBpYUVmZmVjdC5qc1xudmFyIFNlcGlhRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBzZXBpYSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmludGVuc2l0eT0xLjBdIC0gVGhlIGludGVuc2l0eSBvZiB0aGUgZWZmZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uLCBpbnRlbnNpdHkgPSAxIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiU2VwaWFFZmZlY3RcIiwgc2VwaWFfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIndlaWdodHNSXCIsIG5ldyBVbmlmb3JtMzUobmV3IFZlY3RvcjM2KDAuMzkzLCAwLjc2OSwgMC4xODkpKV0sXG4gICAgICAgIFtcIndlaWdodHNHXCIsIG5ldyBVbmlmb3JtMzUobmV3IFZlY3RvcjM2KDAuMzQ5LCAwLjY4NiwgMC4xNjgpKV0sXG4gICAgICAgIFtcIndlaWdodHNCXCIsIG5ldyBVbmlmb3JtMzUobmV3IFZlY3RvcjM2KDAuMjcyLCAwLjUzNCwgMC4xMzEpKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibGVuZE1vZGUub3BhY2l0eSBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibGVuZE1vZGUub3BhY2l0eS52YWx1ZTtcbiAgfVxuICBzZXQgaW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5ibGVuZE1vZGUub3BhY2l0eS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNlcGlhIGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsZW5kTW9kZS5vcGFjaXR5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGludGVuc2l0eS5cbiAgICovXG4gIGdldEludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlbnNpdHk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlcGlhIGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsZW5kTW9kZS5vcGFjaXR5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBpbnRlbnNpdHkuXG4gICAqL1xuICBzZXRJbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLmludGVuc2l0eSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2VpZ2h0cyBmb3IgdGhlIHJlZCBjaGFubmVsLiBEZWZhdWx0IGlzIGAoMC4zOTMsIDAuNzY5LCAwLjE4OSlgLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yM31cbiAgICovXG4gIGdldCB3ZWlnaHRzUigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJ3ZWlnaHRzUlwiKS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHdlaWdodHMgZm9yIHRoZSBncmVlbiBjaGFubmVsLiBEZWZhdWx0IGlzIGAoMC4zNDksIDAuNjg2LCAwLjE2OClgLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yM31cbiAgICovXG4gIGdldCB3ZWlnaHRzRygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJ3ZWlnaHRzR1wiKS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHdlaWdodHMgZm9yIHRoZSBibHVlIGNoYW5uZWwuIERlZmF1bHQgaXMgYCgwLjI3MiwgMC41MzQsIDAuMTMxKWAuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IzfVxuICAgKi9cbiAgZ2V0IHdlaWdodHNCKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIndlaWdodHNCXCIpLnZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9TTUFBRWZmZWN0LmpzXG5pbXBvcnQge1xuICBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzksXG4gIENvbG9yIGFzIENvbG9yOCxcbiAgTGluZWFyRmlsdGVyIGFzIExpbmVhckZpbHRlcjUsXG4gIExvYWRpbmdNYW5hZ2VyLFxuICBOZWFyZXN0RmlsdGVyIGFzIE5lYXJlc3RGaWx0ZXI0LFxuICBUZXh0dXJlIGFzIFRleHR1cmUzLFxuICBVbmlmb3JtIGFzIFVuaWZvcm0zOCxcbiAgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxNFxufSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9FZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nOCwgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTMsIFJFVklTSU9OIGFzIFJFVklTSU9OMiwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxNCwgVW5pZm9ybSBhcyBVbmlmb3JtMzYsIFZlY3RvcjIgYXMgVmVjdG9yMjE5IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9lZGdlLWRldGVjdGlvbi5mcmFnXG52YXIgZWRnZV9kZXRlY3Rpb25fZGVmYXVsdCA9IGB2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO1xuI2lmIEVER0VfREVURUNUSU9OX01PREUgIT0gMFxudmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dmFyeWluZyB2ZWMyIHZVdjQ7dmFyeWluZyB2ZWMyIHZVdjU7XG4jZW5kaWZcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFID09IDFcbiNpbmNsdWRlIDxjb21tb24+XG4jZW5kaWZcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFID09IDAgfHwgUFJFRElDQVRJT05fTU9ERSA9PSAxXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZW5kaWZcbmZsb2F0IHJlYWREZXB0aChjb25zdCBpbiB2ZWMyIHV2KXtcbiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcbnJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpKTtcbiNlbHNlXG5yZXR1cm4gdGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KS5yO1xuI2VuZGlmXG59dmVjMyBnYXRoZXJOZWlnaGJvcnMoKXtmbG9hdCBwPXJlYWREZXB0aCh2VXYpO2Zsb2F0IHBMZWZ0PXJlYWREZXB0aCh2VXYwKTtmbG9hdCBwVG9wPXJlYWREZXB0aCh2VXYxKTtyZXR1cm4gdmVjMyhwLHBMZWZ0LHBUb3ApO31cbiNlbGlmIFBSRURJQ0FUSU9OX01PREUgPT0gMlxudW5pZm9ybSBzYW1wbGVyMkQgcHJlZGljYXRpb25CdWZmZXI7dmVjMyBnYXRoZXJOZWlnaGJvcnMoKXtmbG9hdCBwPXRleHR1cmUyRChwcmVkaWNhdGlvbkJ1ZmZlcix2VXYpLnI7ZmxvYXQgcExlZnQ9dGV4dHVyZTJEKHByZWRpY2F0aW9uQnVmZmVyLHZVdjApLnI7ZmxvYXQgcFRvcD10ZXh0dXJlMkQocHJlZGljYXRpb25CdWZmZXIsdlV2MSkucjtyZXR1cm4gdmVjMyhwLHBMZWZ0LHBUb3ApO31cbiNlbmRpZlxuI2lmIFBSRURJQ0FUSU9OX01PREUgIT0gMFxudmVjMiBjYWxjdWxhdGVQcmVkaWNhdGVkVGhyZXNob2xkKCl7dmVjMyBuZWlnaGJvdXJzPWdhdGhlck5laWdoYm9ycygpO3ZlYzIgZGVsdGE9YWJzKG5laWdoYm91cnMueHgtbmVpZ2hib3Vycy55eik7dmVjMiBlZGdlcz1zdGVwKFBSRURJQ0FUSU9OX1RIUkVTSE9MRCxkZWx0YSk7cmV0dXJuIFBSRURJQ0FUSU9OX1NDQUxFKkVER0VfVEhSRVNIT0xEKigxLjAtUFJFRElDQVRJT05fU1RSRU5HVEgqZWRnZXMpO31cbiNlbmRpZlxuI2lmIEVER0VfREVURUNUSU9OX01PREUgIT0gMFxudW5pZm9ybSBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZW5kaWZcbnZvaWQgbWFpbigpe1xuI2lmIEVER0VfREVURUNUSU9OX01PREUgPT0gMFxuY29uc3QgdmVjMiB0aHJlc2hvbGQ9dmVjMihERVBUSF9USFJFU0hPTEQpO1xuI2VsaWYgUFJFRElDQVRJT05fTU9ERSAhPSAwXG52ZWMyIHRocmVzaG9sZD1jYWxjdWxhdGVQcmVkaWNhdGVkVGhyZXNob2xkKCk7XG4jZWxzZVxuY29uc3QgdmVjMiB0aHJlc2hvbGQ9dmVjMihFREdFX1RIUkVTSE9MRCk7XG4jZW5kaWZcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFID09IDBcbnZlYzMgbmVpZ2hib3JzPWdhdGhlck5laWdoYm9ycygpO3ZlYzIgZGVsdGE9YWJzKG5laWdoYm9ycy54eC12ZWMyKG5laWdoYm9ycy55LG5laWdoYm9ycy56KSk7dmVjMiBlZGdlcz1zdGVwKHRocmVzaG9sZCxkZWx0YSk7aWYoZG90KGVkZ2VzLHZlYzIoMS4wKSk9PTAuMCl7ZGlzY2FyZDt9Z2xfRnJhZ0NvbG9yPXZlYzQoZWRnZXMsMC4wLDEuMCk7XG4jZWxpZiBFREdFX0RFVEVDVElPTl9NT0RFID09IDFcbmZsb2F0IGw9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpLnJnYik7ZmxvYXQgbExlZnQ9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYwKS5yZ2IpO2Zsb2F0IGxUb3A9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYxKS5yZ2IpO3ZlYzQgZGVsdGE7ZGVsdGEueHk9YWJzKGwtdmVjMihsTGVmdCxsVG9wKSk7dmVjMiBlZGdlcz1zdGVwKHRocmVzaG9sZCxkZWx0YS54eSk7aWYoZG90KGVkZ2VzLHZlYzIoMS4wKSk9PTAuMCl7ZGlzY2FyZDt9ZmxvYXQgbFJpZ2h0PWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MikucmdiKTtmbG9hdCBsQm90dG9tPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MykucmdiKTtkZWx0YS56dz1hYnMobC12ZWMyKGxSaWdodCxsQm90dG9tKSk7dmVjMiBtYXhEZWx0YT1tYXgoZGVsdGEueHksZGVsdGEuencpO2Zsb2F0IGxMZWZ0TGVmdD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjQpLnJnYik7ZmxvYXQgbFRvcFRvcD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjUpLnJnYik7ZGVsdGEuenc9YWJzKHZlYzIobExlZnQsbFRvcCktdmVjMihsTGVmdExlZnQsbFRvcFRvcCkpO21heERlbHRhPW1heChtYXhEZWx0YS54eSxkZWx0YS56dyk7ZmxvYXQgZmluYWxEZWx0YT1tYXgobWF4RGVsdGEueCxtYXhEZWx0YS55KTtlZGdlcy54eSo9c3RlcChmaW5hbERlbHRhLExPQ0FMX0NPTlRSQVNUX0FEQVBUQVRJT05fRkFDVE9SKmRlbHRhLnh5KTtnbF9GcmFnQ29sb3I9dmVjNChlZGdlcywwLjAsMS4wKTtcbiNlbGlmIEVER0VfREVURUNUSU9OX01PREUgPT0gMlxudmVjNCBkZWx0YTt2ZWMzIGM9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdikucmdiO3ZlYzMgY0xlZnQ9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjApLnJnYjt2ZWMzIHQ9YWJzKGMtY0xlZnQpO2RlbHRhLng9bWF4KG1heCh0LnIsdC5nKSx0LmIpO3ZlYzMgY1RvcD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MSkucmdiO3Q9YWJzKGMtY1RvcCk7ZGVsdGEueT1tYXgobWF4KHQucix0LmcpLHQuYik7dmVjMiBlZGdlcz1zdGVwKHRocmVzaG9sZCxkZWx0YS54eSk7aWYoZG90KGVkZ2VzLHZlYzIoMS4wKSk9PTAuMCl7ZGlzY2FyZDt9dmVjMyBjUmlnaHQ9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjIpLnJnYjt0PWFicyhjLWNSaWdodCk7ZGVsdGEuej1tYXgobWF4KHQucix0LmcpLHQuYik7dmVjMyBjQm90dG9tPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYzKS5yZ2I7dD1hYnMoYy1jQm90dG9tKTtkZWx0YS53PW1heChtYXgodC5yLHQuZyksdC5iKTt2ZWMyIG1heERlbHRhPW1heChkZWx0YS54eSxkZWx0YS56dyk7dmVjMyBjTGVmdExlZnQ9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjQpLnJnYjt0PWFicyhjLWNMZWZ0TGVmdCk7ZGVsdGEuej1tYXgobWF4KHQucix0LmcpLHQuYik7dmVjMyBjVG9wVG9wPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXY1KS5yZ2I7dD1hYnMoYy1jVG9wVG9wKTtkZWx0YS53PW1heChtYXgodC5yLHQuZyksdC5iKTttYXhEZWx0YT1tYXgobWF4RGVsdGEueHksZGVsdGEuencpO2Zsb2F0IGZpbmFsRGVsdGE9bWF4KG1heERlbHRhLngsbWF4RGVsdGEueSk7ZWRnZXMqPXN0ZXAoZmluYWxEZWx0YSxMT0NBTF9DT05UUkFTVF9BREFQVEFUSU9OX0ZBQ1RPUipkZWx0YS54eSk7Z2xfRnJhZ0NvbG9yPXZlYzQoZWRnZXMsMC4wLDEuMCk7XG4jZW5kaWZcbn1gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvZWRnZS1kZXRlY3Rpb24udmVydFxudmFyIGVkZ2VfZGV0ZWN0aW9uX2RlZmF1bHQyID0gYHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzIgdlV2MDt2YXJ5aW5nIHZlYzIgdlV2MTtcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFICE9IDBcbnZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO3ZhcnlpbmcgdmVjMiB2VXY0O3ZhcnlpbmcgdmVjMiB2VXY1O1xuI2VuZGlmXG52b2lkIG1haW4oKXt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTt2VXYwPXZVdit0ZXhlbFNpemUqdmVjMigtMS4wLDAuMCk7dlV2MT12VXYrdGV4ZWxTaXplKnZlYzIoMC4wLC0xLjApO1xuI2lmIEVER0VfREVURUNUSU9OX01PREUgIT0gMFxudlV2Mj12VXYrdGV4ZWxTaXplKnZlYzIoMS4wLDAuMCk7dlV2Mz12VXYrdGV4ZWxTaXplKnZlYzIoMC4wLDEuMCk7dlV2ND12VXYrdGV4ZWxTaXplKnZlYzIoLTIuMCwwLjApO3ZVdjU9dlV2K3RleGVsU2l6ZSp2ZWMyKDAuMCwtMi4wKTtcbiNlbmRpZlxuZ2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9FZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuanNcbnZhciBFZGdlRGV0ZWN0aW9uTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMTQge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBlZGdlIGRldGVjdGlvbiBtYXRlcmlhbC5cbiAgICpcbiAgICogVE9ETyBSZW1vdmUgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbdGV4ZWxTaXplXSAtIFRoZSBzY3JlZW4gdGV4ZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtFZGdlRGV0ZWN0aW9uTW9kZX0gW21vZGU9RWRnZURldGVjdGlvbk1vZGUuQ09MT1JdIC0gVGhlIGVkZ2UgZGV0ZWN0aW9uIG1vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXhlbFNpemUgPSBuZXcgVmVjdG9yMjE5KCksIG1vZGUgPSBFZGdlRGV0ZWN0aW9uTW9kZS5DT0xPUikge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiRWRnZURldGVjdGlvbk1hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIFRIUkVFX1JFVklTSU9OOiBSRVZJU0lPTjIucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSxcbiAgICAgICAgTE9DQUxfQ09OVFJBU1RfQURBUFRBVElPTl9GQUNUT1I6IFwiMi4wXCIsXG4gICAgICAgIEVER0VfVEhSRVNIT0xEOiBcIjAuMVwiLFxuICAgICAgICBERVBUSF9USFJFU0hPTEQ6IFwiMC4wMVwiLFxuICAgICAgICBQUkVESUNBVElPTl9NT0RFOiBcIjBcIixcbiAgICAgICAgUFJFRElDQVRJT05fVEhSRVNIT0xEOiBcIjAuMDFcIixcbiAgICAgICAgUFJFRElDQVRJT05fU0NBTEU6IFwiMi4wXCIsXG4gICAgICAgIFBSRURJQ0FUSU9OX1NUUkVOR1RIOiBcIjEuMFwiLFxuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTM2KG51bGwpLFxuICAgICAgICBkZXB0aEJ1ZmZlcjogbmV3IFVuaWZvcm0zNihudWxsKSxcbiAgICAgICAgcHJlZGljYXRpb25CdWZmZXI6IG5ldyBVbmlmb3JtMzYobnVsbCksXG4gICAgICAgIHRleGVsU2l6ZTogbmV3IFVuaWZvcm0zNih0ZXhlbFNpemUpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcxMyxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGVkZ2VfZGV0ZWN0aW9uX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGVkZ2VfZGV0ZWN0aW9uX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uTW9kZSA9IG1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGRlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICpcbiAgICogQHR5cGUge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9XG4gICAqL1xuICBzZXQgZGVwdGhQYWNraW5nKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1BBQ0tJTkcgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlciBhbmQgZGVwdGhQYWNraW5nIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gYnVmZmVyIC0gVGhlIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIHNldERlcHRoQnVmZmVyKGJ1ZmZlciwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc4KSB7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLmRlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogVGhlIGVkZ2UgZGV0ZWN0aW9uIG1vZGUuXG4gICAqXG4gICAqIEB0eXBlIHtFZGdlRGV0ZWN0aW9uTW9kZX1cbiAgICovXG4gIGdldCBlZGdlRGV0ZWN0aW9uTW9kZSgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5FREdFX0RFVEVDVElPTl9NT0RFKTtcbiAgfVxuICBzZXQgZWRnZURldGVjdGlvbk1vZGUodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuRURHRV9ERVRFQ1RJT05fTU9ERSA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkZ2UgZGV0ZWN0aW9uIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlZGdlRGV0ZWN0aW9uTW9kZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtFZGdlRGV0ZWN0aW9uTW9kZX0gVGhlIG1vZGUuXG4gICAqL1xuICBnZXRFZGdlRGV0ZWN0aW9uTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlRGV0ZWN0aW9uTW9kZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZWRnZSBkZXRlY3Rpb24gbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVkZ2VEZXRlY3Rpb25Nb2RlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RWRnZURldGVjdGlvbk1vZGV9IHZhbHVlIC0gVGhlIGVkZ2UgZGV0ZWN0aW9uIG1vZGUuXG4gICAqL1xuICBzZXRFZGdlRGV0ZWN0aW9uTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1vZGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGxvY2FsIGNvbnRyYXN0IGFkYXB0YXRpb24gZmFjdG9yLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBlZGdlIGRldGVjdGlvbiBtb2RlIGlzIHNldCB0byBERVBUSC4gRGVmYXVsdCBpcyAyLjAuXG4gICAqXG4gICAqIElmIGEgbmVpZ2hib3IgZWRnZSBoYXMgX2ZhY3Rvcl8gdGltZXMgYmlnZ2VyIGNvbnRyYXN0IHRoYW4gdGhlIGN1cnJlbnQgZWRnZSwgdGhlIGVkZ2Ugd2lsbCBiZSBkaXNjYXJkZWQuXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIHRvIGVsaW1pbmF0ZSBzcHVyaW91cyBjcm9zc2luZyBlZGdlcyBhbmQgaXMgYmFzZWQgb24gdGhlIGZhY3QgdGhhdCBpZiB0aGVyZSBpcyB0b28gbXVjaCBjb250cmFzdCBpbiBhXG4gICAqIGRpcmVjdGlvbiwgdGhlIHBlcmNlcHR1YWwgY29udHJhc3QgaW4gdGhlIG90aGVyIG5laWdoYm9ycyB3aWxsIGJlIGhpZGRlbi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBsb2NhbENvbnRyYXN0QWRhcHRhdGlvbkZhY3RvcigpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5MT0NBTF9DT05UUkFTVF9BREFQVEFUSU9OX0ZBQ1RPUik7XG4gIH1cbiAgc2V0IGxvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkxPQ0FMX0NPTlRSQVNUX0FEQVBUQVRJT05fRkFDVE9SID0gdmFsdWUudG9GaXhlZChcIjZcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxvY2FsIGNvbnRyYXN0IGFkYXB0YXRpb24gZmFjdG9yLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbG9jYWxDb250cmFzdEFkYXB0YXRpb25GYWN0b3IgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZmFjdG9yLlxuICAgKi9cbiAgZ2V0TG9jYWxDb250cmFzdEFkYXB0YXRpb25GYWN0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxDb250cmFzdEFkYXB0YXRpb25GYWN0b3I7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxvY2FsIGNvbnRyYXN0IGFkYXB0YXRpb24gZmFjdG9yLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBlZGdlIGRldGVjdGlvbiBtb2RlIGlzIHNldCB0byBERVBUSC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBsb2NhbCBjb250cmFzdCBhZGFwdGF0aW9uIGZhY3Rvci4gRGVmYXVsdCBpcyAyLjAuXG4gICAqL1xuICBzZXRMb2NhbENvbnRyYXN0QWRhcHRhdGlvbkZhY3Rvcih2YWx1ZSkge1xuICAgIHRoaXMubG9jYWxDb250cmFzdEFkYXB0YXRpb25GYWN0b3IgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZC4gUmFuZ2U6IFswLjAsIDAuNV0uXG4gICAqXG4gICAqIEEgbG93ZXIgdmFsdWUgcmVzdWx0cyBpbiBtb3JlIGVkZ2VzIGJlaW5nIGRldGVjdGVkIGF0IHRoZSBleHBlbnNlIG9mIHBlcmZvcm1hbmNlLlxuICAgKlxuICAgKiBGb3IgbHVtYS0gYW5kIGNocm9tYS1iYXNlZCBlZGdlIGRldGVjdGlvbiwgMC4xIGlzIGEgcmVhc29uYWJsZSB2YWx1ZSBhbmQgYWxsb3dzIHRvIGNhdGNoIG1vc3QgdmlzaWJsZSBlZGdlcy4gMC4wNVxuICAgKiBpcyBhIHJhdGhlciBvdmVya2lsbCB2YWx1ZSB0aGF0IGFsbG93cyB0byBjYXRjaCAnZW0gYWxsLiBEYXJrZXIgc2NlbmVzIG1heSByZXF1aXJlIGFuIGV2ZW4gbG93ZXIgdGhyZXNob2xkLlxuICAgKlxuICAgKiBJZiBkZXB0aC1iYXNlZCBlZGdlIGRldGVjdGlvbiBpcyB1c2VkLCB0aGUgdGhyZXNob2xkIHdpbGwgZGVwZW5kIG9uIHRoZSBzY2VuZSBkZXB0aC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBlZGdlRGV0ZWN0aW9uVGhyZXNob2xkKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkVER0VfVEhSRVNIT0xEKTtcbiAgfVxuICBzZXQgZWRnZURldGVjdGlvblRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5FREdFX1RIUkVTSE9MRCA9IHZhbHVlLnRvRml4ZWQoXCI2XCIpO1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9USFJFU0hPTEQgPSAodmFsdWUgKiAwLjEpLnRvRml4ZWQoXCI2XCIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGdlIGRldGVjdGlvbiB0aHJlc2hvbGQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlZGdlRGV0ZWN0aW9uVGhyZXNob2xkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHRocmVzaG9sZC5cbiAgICovXG4gIGdldEVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZURldGVjdGlvblRocmVzaG9sZDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZWRnZSBkZXRlY3Rpb24gdGhyZXNob2xkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZWRnZURldGVjdGlvblRocmVzaG9sZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgZWRnZSBkZXRlY3Rpb24gdGhyZXNob2xkLiBSYW5nZTogWzAuMCwgMC41XS5cbiAgICovXG4gIHNldEVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByZWRpY2F0aW9uIG1vZGUuXG4gICAqXG4gICAqIFByZWRpY2F0ZWQgdGhyZXNob2xkaW5nIGFsbG93cyB0byBiZXR0ZXIgcHJlc2VydmUgdGV4dHVyZSBkZXRhaWxzIGFuZCB0byBpbXByb3ZlIGVkZ2UgZGV0ZWN0aW9uIHVzaW5nIGFuIGFkZGl0aW9uYWxcbiAgICogYnVmZmVyIHN1Y2ggYXMgYSBsaWdodCBhY2N1bXVsYXRpb24gb3IgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7UHJlZGljYXRpb25Nb2RlfVxuICAgKi9cbiAgZ2V0IHByZWRpY2F0aW9uTW9kZSgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5QUkVESUNBVElPTl9NT0RFKTtcbiAgfVxuICBzZXQgcHJlZGljYXRpb25Nb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLlBSRURJQ0FUSU9OX01PREUgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmVkaWNhdGlvbiBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZGljYXRpb25Nb2RlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1ByZWRpY2F0aW9uTW9kZX0gVGhlIG1vZGUuXG4gICAqL1xuICBnZXRQcmVkaWNhdGlvbk1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZGljYXRpb25Nb2RlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmVkaWNhdGlvbiBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZGljYXRpb25Nb2RlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7UHJlZGljYXRpb25Nb2RlfSB2YWx1ZSAtIFRoZSBwcmVkaWNhdGlvbiBtb2RlLlxuICAgKi9cbiAgc2V0UHJlZGljYXRpb25Nb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5wcmVkaWNhdGlvbk1vZGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByZWRpY2F0aW9uIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgcHJlZGljYXRpb25CdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnByZWRpY2F0aW9uQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSBjdXN0b20gcHJlZGljYXRpb24gYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZGljYXRpb25CdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBwcmVkaWNhdGlvbiBidWZmZXIuXG4gICAqL1xuICBzZXRQcmVkaWNhdGlvbkJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMucHJlZGljYXRpb25CdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByZWRpY2F0aW9uIHRocmVzaG9sZC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBwcmVkaWNhdGlvblRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5QUkVESUNBVElPTl9USFJFU0hPTEQpO1xuICB9XG4gIHNldCBwcmVkaWNhdGlvblRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5QUkVESUNBVElPTl9USFJFU0hPTEQgPSB2YWx1ZS50b0ZpeGVkKFwiNlwiKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJlZGljYXRpb24gdGhyZXNob2xkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZGljYXRpb25UaHJlc2hvbGQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgdGhyZXNob2xkLlxuICAgKi9cbiAgZ2V0UHJlZGljYXRpb25UaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZGljYXRpb25UaHJlc2hvbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByZWRpY2F0aW9uIHRocmVzaG9sZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uVGhyZXNob2xkIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSB0aHJlc2hvbGQuXG4gICAqL1xuICBzZXRQcmVkaWNhdGlvblRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMucHJlZGljYXRpb25UaHJlc2hvbGQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByZWRpY2F0aW9uIHNjYWxlLiBSYW5nZTogWzEuMCwgNS4wXS5cbiAgICpcbiAgICogRGV0ZXJtaW5lcyBob3cgbXVjaCB0aGUgZWRnZSBkZXRlY3Rpb24gdGhyZXNob2xkIHNob3VsZCBiZSBzY2FsZWQgd2hlbiB1c2luZyBwcmVkaWNhdGlvbi5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW58VGV4dHVyZXxOdW1iZXJ9XG4gICAqL1xuICBnZXQgcHJlZGljYXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5QUkVESUNBVElPTl9TQ0FMRSk7XG4gIH1cbiAgc2V0IHByZWRpY2F0aW9uU2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fU0NBTEUgPSB2YWx1ZS50b0ZpeGVkKFwiNlwiKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJlZGljYXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVkaWNhdGlvblNjYWxlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNjYWxlLlxuICAgKi9cbiAgZ2V0UHJlZGljYXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGlvblNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmVkaWNhdGlvbiBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uU2NhbGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNjYWxlLiBSYW5nZTogWzEuMCwgNS4wXS5cbiAgICovXG4gIHNldFByZWRpY2F0aW9uU2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnByZWRpY2F0aW9uU2NhbGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByZWRpY2F0aW9uIHN0cmVuZ3RoLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogRGV0ZXJtaW5lcyBob3cgbXVjaCB0aGUgZWRnZSBkZXRlY3Rpb24gdGhyZXNob2xkIHNob3VsZCBiZSBkZWNyZWFzZWQgbG9jYWxseSB3aGVuIHVzaW5nIHByZWRpY2F0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHByZWRpY2F0aW9uU3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fU1RSRU5HVEgpO1xuICB9XG4gIHNldCBwcmVkaWNhdGlvblN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLlBSRURJQ0FUSU9OX1NUUkVOR1RIID0gdmFsdWUudG9GaXhlZChcIjZcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZWRpY2F0aW9uIHN0cmVuZ3RoLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZGljYXRpb25TdHJlbmd0aCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzdHJlbmd0aC5cbiAgICovXG4gIGdldFByZWRpY2F0aW9uU3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZGljYXRpb25TdHJlbmd0aDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZGljYXRpb24gc3RyZW5ndGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVkaWNhdGlvblN0cmVuZ3RoIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzdHJlbmd0aC4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqL1xuICBzZXRQcmVkaWNhdGlvblN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5wcmVkaWNhdGlvblN0cmVuZ3RoID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9TTUFBV2VpZ2h0c01hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcxNCwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxNSwgVW5pZm9ybSBhcyBVbmlmb3JtMzcsIFZlY3RvcjIgYXMgVmVjdG9yMjIwIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9zbWFhLXdlaWdodHMuZnJhZ1xudmFyIHNtYWFfd2VpZ2h0c19kZWZhdWx0ID0gYCNkZWZpbmUgc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KHQsIGNvb3JkLCBvZmZzZXQpIHRleHR1cmUyRCh0LCBjb29yZCArIG9mZnNldCAqIHRleGVsU2l6ZSlcbiNpZiBfX1ZFUlNJT05fXyA8IDMwMFxuI2RlZmluZSByb3VuZCh2KSBmbG9vcih2ICsgMC41KVxuI2VuZGlmXG4jaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbmRpZlxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBhcmVhVGV4dHVyZTt1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIHNlYXJjaFRleHR1cmU7dW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjNCB2T2Zmc2V0WzNdO3ZhcnlpbmcgdmVjMiB2UGl4Q29vcmQ7dm9pZCBtb3ZlYyhjb25zdCBpbiBidmVjMiBjLGlub3V0IHZlYzIgdmFyaWFibGUsY29uc3QgaW4gdmVjMiB2YWx1ZSl7aWYoYy54KXt2YXJpYWJsZS54PXZhbHVlLng7fWlmKGMueSl7dmFyaWFibGUueT12YWx1ZS55O319dm9pZCBtb3ZlYyhjb25zdCBpbiBidmVjNCBjLGlub3V0IHZlYzQgdmFyaWFibGUsY29uc3QgaW4gdmVjNCB2YWx1ZSl7bW92ZWMoYy54eSx2YXJpYWJsZS54eSx2YWx1ZS54eSk7bW92ZWMoYy56dyx2YXJpYWJsZS56dyx2YWx1ZS56dyk7fXZlYzIgZGVjb2RlRGlhZ0JpbGluZWFyQWNjZXNzKGluIHZlYzIgZSl7ZS5yPWUuciphYnMoNS4wKmUuci01LjAqMC43NSk7cmV0dXJuIHJvdW5kKGUpO312ZWM0IGRlY29kZURpYWdCaWxpbmVhckFjY2VzcyhpbiB2ZWM0IGUpe2UucmI9ZS5yYiphYnMoNS4wKmUucmItNS4wKjAuNzUpO3JldHVybiByb3VuZChlKTt9dmVjMiBzZWFyY2hEaWFnMShjb25zdCBpbiB2ZWMyIHRleENvb3JkLGNvbnN0IGluIHZlYzIgZGlyLG91dCB2ZWMyIGUpe3ZlYzQgY29vcmQ9dmVjNCh0ZXhDb29yZCwtMS4wLDEuMCk7dmVjMyB0PXZlYzModGV4ZWxTaXplLDEuMCk7Zm9yKGludCBpPTA7aTxNQVhfU0VBUkNIX1NURVBTX0lOVDsrK2kpe2lmKCEoY29vcmQuejxmbG9hdChNQVhfU0VBUkNIX1NURVBTX0RJQUdfSU5ULTEpJiZjb29yZC53PjAuOSkpe2JyZWFrO31jb29yZC54eXo9dCp2ZWMzKGRpciwxLjApK2Nvb3JkLnh5ejtlPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixjb29yZC54eSkucmc7Y29vcmQudz1kb3QoZSx2ZWMyKDAuNSkpO31yZXR1cm4gY29vcmQuenc7fXZlYzIgc2VhcmNoRGlhZzIoY29uc3QgaW4gdmVjMiB0ZXhDb29yZCxjb25zdCBpbiB2ZWMyIGRpcixvdXQgdmVjMiBlKXt2ZWM0IGNvb3JkPXZlYzQodGV4Q29vcmQsLTEuMCwxLjApO2Nvb3JkLngrPTAuMjUqdGV4ZWxTaXplLng7dmVjMyB0PXZlYzModGV4ZWxTaXplLDEuMCk7Zm9yKGludCBpPTA7aTxNQVhfU0VBUkNIX1NURVBTX0lOVDsrK2kpe2lmKCEoY29vcmQuejxmbG9hdChNQVhfU0VBUkNIX1NURVBTX0RJQUdfSU5ULTEpJiZjb29yZC53PjAuOSkpe2JyZWFrO31jb29yZC54eXo9dCp2ZWMzKGRpciwxLjApK2Nvb3JkLnh5ejtlPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixjb29yZC54eSkucmc7ZT1kZWNvZGVEaWFnQmlsaW5lYXJBY2Nlc3MoZSk7Y29vcmQudz1kb3QoZSx2ZWMyKDAuNSkpO31yZXR1cm4gY29vcmQuenc7fXZlYzIgYXJlYURpYWcoY29uc3QgaW4gdmVjMiBkaXN0LGNvbnN0IGluIHZlYzIgZSxjb25zdCBpbiBmbG9hdCBvZmZzZXQpe3ZlYzIgdGV4Q29vcmQ9dmVjMihBUkVBVEVYX01BWF9ESVNUQU5DRV9ESUFHLEFSRUFURVhfTUFYX0RJU1RBTkNFX0RJQUcpKmUrZGlzdDt0ZXhDb29yZD1BUkVBVEVYX1BJWEVMX1NJWkUqdGV4Q29vcmQrMC41KkFSRUFURVhfUElYRUxfU0laRTt0ZXhDb29yZC54Kz0wLjU7dGV4Q29vcmQueSs9QVJFQVRFWF9TVUJURVhfU0laRSpvZmZzZXQ7cmV0dXJuIHRleHR1cmUyRChhcmVhVGV4dHVyZSx0ZXhDb29yZCkucmc7fXZlYzIgY2FsY3VsYXRlRGlhZ1dlaWdodHMoY29uc3QgaW4gdmVjMiB0ZXhDb29yZCxjb25zdCBpbiB2ZWMyIGUsY29uc3QgaW4gdmVjNCBzdWJzYW1wbGVJbmRpY2VzKXt2ZWMyIHdlaWdodHM9dmVjMigwLjApO3ZlYzQgZDt2ZWMyIGVuZDtpZihlLnI+MC4wKXtkLnh6PXNlYXJjaERpYWcxKHRleENvb3JkLHZlYzIoLTEuMCwxLjApLGVuZCk7ZC54Kz1mbG9hdChlbmQueT4wLjkpO31lbHNle2QueHo9dmVjMigwLjApO31kLnl3PXNlYXJjaERpYWcxKHRleENvb3JkLHZlYzIoMS4wLC0xLjApLGVuZCk7aWYoZC54K2QueT4yLjApe3ZlYzQgY29vcmRzPXZlYzQoLWQueCswLjI1LGQueCxkLnksLWQueS0wLjI1KSp0ZXhlbFNpemUueHl4eSt0ZXhDb29yZC54eXh5O3ZlYzQgYztjLnh5PXNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcixjb29yZHMueHksdmVjMigtMSwwKSkucmc7Yy56dz1zYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsY29vcmRzLnp3LHZlYzIoMSwwKSkucmc7Yy55eHd6PWRlY29kZURpYWdCaWxpbmVhckFjY2VzcyhjLnh5encpO3ZlYzIgY2M9dmVjMigyLjApKmMueHorYy55dzttb3ZlYyhidmVjMihzdGVwKDAuOSxkLnp3KSksY2MsdmVjMigwLjApKTt3ZWlnaHRzKz1hcmVhRGlhZyhkLnh5LGNjLHN1YnNhbXBsZUluZGljZXMueik7fWQueHo9c2VhcmNoRGlhZzIodGV4Q29vcmQsdmVjMigtMS4wLC0xLjApLGVuZCk7aWYoc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLHRleENvb3JkLHZlYzIoMSwwKSkucj4wLjApe2QueXc9c2VhcmNoRGlhZzIodGV4Q29vcmQsdmVjMigxLjApLGVuZCk7ZC55Kz1mbG9hdChlbmQueT4wLjkpO31lbHNle2QueXc9dmVjMigwLjApO31pZihkLngrZC55PjIuMCl7dmVjNCBjb29yZHM9dmVjNCgtZC54LC1kLngsZC55LGQueSkqdGV4ZWxTaXplLnh5eHkrdGV4Q29vcmQueHl4eTt2ZWM0IGM7Yy54PXNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcixjb29yZHMueHksdmVjMigtMSwwKSkuZztjLnk9c2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLGNvb3Jkcy54eSx2ZWMyKDAsLTEpKS5yO2Muenc9c2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLGNvb3Jkcy56dyx2ZWMyKDEsMCkpLmdyO3ZlYzIgY2M9dmVjMigyLjApKmMueHorYy55dzttb3ZlYyhidmVjMihzdGVwKDAuOSxkLnp3KSksY2MsdmVjMigwLjApKTt3ZWlnaHRzKz1hcmVhRGlhZyhkLnh5LGNjLHN1YnNhbXBsZUluZGljZXMudykuZ3I7fXJldHVybiB3ZWlnaHRzO31mbG9hdCBzZWFyY2hMZW5ndGgoY29uc3QgaW4gdmVjMiBlLGNvbnN0IGluIGZsb2F0IG9mZnNldCl7dmVjMiBzY2FsZT1TRUFSQ0hURVhfU0laRSp2ZWMyKDAuNSwtMS4wKTt2ZWMyIGJpYXM9U0VBUkNIVEVYX1NJWkUqdmVjMihvZmZzZXQsMS4wKTtzY2FsZSs9dmVjMigtMS4wLDEuMCk7Ymlhcys9dmVjMigwLjUsLTAuNSk7c2NhbGUqPTEuMC9TRUFSQ0hURVhfUEFDS0VEX1NJWkU7Ymlhcyo9MS4wL1NFQVJDSFRFWF9QQUNLRURfU0laRTtyZXR1cm4gdGV4dHVyZTJEKHNlYXJjaFRleHR1cmUsc2NhbGUqZStiaWFzKS5yO31mbG9hdCBzZWFyY2hYTGVmdChpbiB2ZWMyIHRleENvb3JkLGNvbnN0IGluIGZsb2F0IGVuZCl7dmVjMiBlPXZlYzIoMC4wLDEuMCk7Zm9yKGludCBpPTA7aTxNQVhfU0VBUkNIX1NURVBTX0lOVDsrK2kpe2lmKCEodGV4Q29vcmQueD5lbmQmJmUuZz4wLjgyODEmJmUucj09MC4wKSl7YnJlYWs7fWU9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHRleENvb3JkKS5yZzt0ZXhDb29yZD12ZWMyKC0yLjAsMC4wKSp0ZXhlbFNpemUrdGV4Q29vcmQ7fWZsb2F0IG9mZnNldD0tKDI1NS4wLzEyNy4wKSpzZWFyY2hMZW5ndGgoZSwwLjApKzMuMjU7cmV0dXJuIHRleGVsU2l6ZS54Km9mZnNldCt0ZXhDb29yZC54O31mbG9hdCBzZWFyY2hYUmlnaHQodmVjMiB0ZXhDb29yZCxjb25zdCBpbiBmbG9hdCBlbmQpe3ZlYzIgZT12ZWMyKDAuMCwxLjApO2ZvcihpbnQgaT0wO2k8TUFYX1NFQVJDSF9TVEVQU19JTlQ7KytpKXtpZighKHRleENvb3JkLng8ZW5kJiZlLmc+MC44MjgxJiZlLnI9PTAuMCkpe2JyZWFrO31lPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix0ZXhDb29yZCkucmc7dGV4Q29vcmQ9dmVjMigyLjAsMC4wKSp0ZXhlbFNpemUueHkrdGV4Q29vcmQ7fWZsb2F0IG9mZnNldD0tKDI1NS4wLzEyNy4wKSpzZWFyY2hMZW5ndGgoZSwwLjUpKzMuMjU7cmV0dXJuLXRleGVsU2l6ZS54Km9mZnNldCt0ZXhDb29yZC54O31mbG9hdCBzZWFyY2hZVXAodmVjMiB0ZXhDb29yZCxjb25zdCBpbiBmbG9hdCBlbmQpe3ZlYzIgZT12ZWMyKDEuMCwwLjApO2ZvcihpbnQgaT0wO2k8TUFYX1NFQVJDSF9TVEVQU19JTlQ7KytpKXtpZighKHRleENvb3JkLnk+ZW5kJiZlLnI+MC44MjgxJiZlLmc9PTAuMCkpe2JyZWFrO31lPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix0ZXhDb29yZCkucmc7dGV4Q29vcmQ9LXZlYzIoMC4wLDIuMCkqdGV4ZWxTaXplLnh5K3RleENvb3JkO31mbG9hdCBvZmZzZXQ9LSgyNTUuMC8xMjcuMCkqc2VhcmNoTGVuZ3RoKGUuZ3IsMC4wKSszLjI1O3JldHVybiB0ZXhlbFNpemUueSpvZmZzZXQrdGV4Q29vcmQueTt9ZmxvYXQgc2VhcmNoWURvd24odmVjMiB0ZXhDb29yZCxjb25zdCBpbiBmbG9hdCBlbmQpe3ZlYzIgZT12ZWMyKDEuMCwwLjApO2ZvcihpbnQgaT0wO2k8TUFYX1NFQVJDSF9TVEVQU19JTlQ7aSsrKXtpZighKHRleENvb3JkLnk8ZW5kJiZlLnI+MC44MjgxJiZlLmc9PTAuMCkpe2JyZWFrO31lPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix0ZXhDb29yZCkucmc7dGV4Q29vcmQ9dmVjMigwLjAsMi4wKSp0ZXhlbFNpemUueHkrdGV4Q29vcmQ7fWZsb2F0IG9mZnNldD0tKDI1NS4wLzEyNy4wKSpzZWFyY2hMZW5ndGgoZS5nciwwLjUpKzMuMjU7cmV0dXJuLXRleGVsU2l6ZS55Km9mZnNldCt0ZXhDb29yZC55O312ZWMyIGFyZWEoY29uc3QgaW4gdmVjMiBkaXN0LGNvbnN0IGluIGZsb2F0IGUxLGNvbnN0IGluIGZsb2F0IGUyLGNvbnN0IGluIGZsb2F0IG9mZnNldCl7dmVjMiB0ZXhDb29yZD12ZWMyKEFSRUFURVhfTUFYX0RJU1RBTkNFKSpyb3VuZCg0LjAqdmVjMihlMSxlMikpK2Rpc3Q7dGV4Q29vcmQ9QVJFQVRFWF9QSVhFTF9TSVpFKnRleENvb3JkKzAuNSpBUkVBVEVYX1BJWEVMX1NJWkU7dGV4Q29vcmQueT1BUkVBVEVYX1NVQlRFWF9TSVpFKm9mZnNldCt0ZXhDb29yZC55O3JldHVybiB0ZXh0dXJlMkQoYXJlYVRleHR1cmUsdGV4Q29vcmQpLnJnO312b2lkIGRldGVjdEhvcml6b250YWxDb3JuZXJQYXR0ZXJuKGlub3V0IHZlYzIgd2VpZ2h0cyxjb25zdCBpbiB2ZWM0IHRleENvb3JkLGNvbnN0IGluIHZlYzIgZCl7XG4jaWYgIWRlZmluZWQoRElTQUJMRV9DT1JORVJfREVURUNUSU9OKVxudmVjMiBsZWZ0UmlnaHQ9c3RlcChkLnh5LGQueXgpO3ZlYzIgcm91bmRpbmc9KDEuMC1DT1JORVJfUk9VTkRJTkdfTk9STSkqbGVmdFJpZ2h0O3JvdW5kaW5nLz1sZWZ0UmlnaHQueCtsZWZ0UmlnaHQueTt2ZWMyIGZhY3Rvcj12ZWMyKDEuMCk7ZmFjdG9yLngtPXJvdW5kaW5nLngqc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLHRleENvb3JkLnh5LHZlYzIoMCwxKSkucjtmYWN0b3IueC09cm91bmRpbmcueSpzYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsdGV4Q29vcmQuencsdmVjMigxLDEpKS5yO2ZhY3Rvci55LT1yb3VuZGluZy54KnNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZC54eSx2ZWMyKDAsLTIpKS5yO2ZhY3Rvci55LT1yb3VuZGluZy55KnNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZC56dyx2ZWMyKDEsLTIpKS5yO3dlaWdodHMqPWNsYW1wKGZhY3RvciwwLjAsMS4wKTtcbiNlbmRpZlxufXZvaWQgZGV0ZWN0VmVydGljYWxDb3JuZXJQYXR0ZXJuKGlub3V0IHZlYzIgd2VpZ2h0cyxjb25zdCBpbiB2ZWM0IHRleENvb3JkLGNvbnN0IGluIHZlYzIgZCl7XG4jaWYgIWRlZmluZWQoRElTQUJMRV9DT1JORVJfREVURUNUSU9OKVxudmVjMiBsZWZ0UmlnaHQ9c3RlcChkLnh5LGQueXgpO3ZlYzIgcm91bmRpbmc9KDEuMC1DT1JORVJfUk9VTkRJTkdfTk9STSkqbGVmdFJpZ2h0O3JvdW5kaW5nLz1sZWZ0UmlnaHQueCtsZWZ0UmlnaHQueTt2ZWMyIGZhY3Rvcj12ZWMyKDEuMCk7ZmFjdG9yLngtPXJvdW5kaW5nLngqc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLHRleENvb3JkLnh5LHZlYzIoMSwwKSkuZztmYWN0b3IueC09cm91bmRpbmcueSpzYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsdGV4Q29vcmQuencsdmVjMigxLDEpKS5nO2ZhY3Rvci55LT1yb3VuZGluZy54KnNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZC54eSx2ZWMyKC0yLDApKS5nO2ZhY3Rvci55LT1yb3VuZGluZy55KnNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZC56dyx2ZWMyKC0yLDEpKS5nO3dlaWdodHMqPWNsYW1wKGZhY3RvciwwLjAsMS4wKTtcbiNlbmRpZlxufXZvaWQgbWFpbigpe3ZlYzQgd2VpZ2h0cz12ZWM0KDAuMCk7dmVjNCBzdWJzYW1wbGVJbmRpY2VzPXZlYzQoMC4wKTt2ZWMyIGU9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdikucmc7aWYoZS5nPjAuMCl7XG4jaWYgIWRlZmluZWQoRElTQUJMRV9ESUFHX0RFVEVDVElPTilcbndlaWdodHMucmc9Y2FsY3VsYXRlRGlhZ1dlaWdodHModlV2LGUsc3Vic2FtcGxlSW5kaWNlcyk7aWYod2VpZ2h0cy5yPT0td2VpZ2h0cy5nKXtcbiNlbmRpZlxudmVjMiBkO3ZlYzMgY29vcmRzO2Nvb3Jkcy54PXNlYXJjaFhMZWZ0KHZPZmZzZXRbMF0ueHksdk9mZnNldFsyXS54KTtjb29yZHMueT12T2Zmc2V0WzFdLnk7ZC54PWNvb3Jkcy54O2Zsb2F0IGUxPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixjb29yZHMueHkpLnI7Y29vcmRzLno9c2VhcmNoWFJpZ2h0KHZPZmZzZXRbMF0uencsdk9mZnNldFsyXS55KTtkLnk9Y29vcmRzLno7ZD1yb3VuZChyZXNvbHV0aW9uLnh4KmQrLXZQaXhDb29yZC54eCk7dmVjMiBzcXJ0RD1zcXJ0KGFicyhkKSk7ZmxvYXQgZTI9c2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLGNvb3Jkcy56eSx2ZWMyKDEsMCkpLnI7d2VpZ2h0cy5yZz1hcmVhKHNxcnRELGUxLGUyLHN1YnNhbXBsZUluZGljZXMueSk7Y29vcmRzLnk9dlV2Lnk7ZGV0ZWN0SG9yaXpvbnRhbENvcm5lclBhdHRlcm4od2VpZ2h0cy5yZyxjb29yZHMueHl6eSxkKTtcbiNpZiAhZGVmaW5lZChESVNBQkxFX0RJQUdfREVURUNUSU9OKVxufWVsc2V7ZS5yPTAuMDt9XG4jZW5kaWZcbn1pZihlLnI+MC4wKXt2ZWMyIGQ7dmVjMyBjb29yZHM7Y29vcmRzLnk9c2VhcmNoWVVwKHZPZmZzZXRbMV0ueHksdk9mZnNldFsyXS56KTtjb29yZHMueD12T2Zmc2V0WzBdLng7ZC54PWNvb3Jkcy55O2Zsb2F0IGUxPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixjb29yZHMueHkpLmc7Y29vcmRzLno9c2VhcmNoWURvd24odk9mZnNldFsxXS56dyx2T2Zmc2V0WzJdLncpO2QueT1jb29yZHMuejtkPXJvdW5kKHJlc29sdXRpb24ueXkqZC12UGl4Q29vcmQueXkpO3ZlYzIgc3FydEQ9c3FydChhYnMoZCkpO2Zsb2F0IGUyPXNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcixjb29yZHMueHosdmVjMigwLDEpKS5nO3dlaWdodHMuYmE9YXJlYShzcXJ0RCxlMSxlMixzdWJzYW1wbGVJbmRpY2VzLngpO2Nvb3Jkcy54PXZVdi54O2RldGVjdFZlcnRpY2FsQ29ybmVyUGF0dGVybih3ZWlnaHRzLmJhLGNvb3Jkcy54eXh6LGQpO31nbF9GcmFnQ29sb3I9d2VpZ2h0czt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL3NtYWEtd2VpZ2h0cy52ZXJ0XG52YXIgc21hYV93ZWlnaHRzX2RlZmF1bHQyID0gYHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dW5pZm9ybSB2ZWMyIHJlc29sdXRpb247dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzQgdk9mZnNldFszXTt2YXJ5aW5nIHZlYzIgdlBpeENvb3JkO3ZvaWQgbWFpbigpe3ZVdj1wb3NpdGlvbi54eSowLjUrMC41O3ZQaXhDb29yZD12VXYqcmVzb2x1dGlvbjt2T2Zmc2V0WzBdPXZVdi54eXh5K3RleGVsU2l6ZS54eXh5KnZlYzQoLTAuMjUsLTAuMTI1LDEuMjUsLTAuMTI1KTt2T2Zmc2V0WzFdPXZVdi54eXh5K3RleGVsU2l6ZS54eXh5KnZlYzQoLTAuMTI1LC0wLjI1LC0wLjEyNSwxLjI1KTt2T2Zmc2V0WzJdPXZlYzQodk9mZnNldFswXS54eix2T2Zmc2V0WzFdLnl3KSt2ZWM0KC0yLjAsMi4wLC0yLjAsMi4wKSp0ZXhlbFNpemUueHh5eSpNQVhfU0VBUkNIX1NURVBTX0ZMT0FUO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvU01BQVdlaWdodHNNYXRlcmlhbC5qc1xudmFyIFNNQUFXZWlnaHRzTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMTUge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBTTUFBIHdlaWdodHMgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gW3RleGVsU2l6ZV0gLSBUaGUgYWJzb2x1dGUgc2NyZWVuIHRleGVsIHNpemUuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gW3Jlc29sdXRpb25dIC0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXhlbFNpemUgPSBuZXcgVmVjdG9yMjIwKCksIHJlc29sdXRpb24gPSBuZXcgVmVjdG9yMjIwKCkpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIlNNQUFXZWlnaHRzTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgLy8gQ29uZmlndXJhYmxlIHNldHRpbmdzOlxuICAgICAgICBNQVhfU0VBUkNIX1NURVBTX0lOVDogXCIxNlwiLFxuICAgICAgICBNQVhfU0VBUkNIX1NURVBTX0ZMT0FUOiBcIjE2LjBcIixcbiAgICAgICAgTUFYX1NFQVJDSF9TVEVQU19ESUFHX0lOVDogXCI4XCIsXG4gICAgICAgIE1BWF9TRUFSQ0hfU1RFUFNfRElBR19GTE9BVDogXCI4LjBcIixcbiAgICAgICAgQ09STkVSX1JPVU5ESU5HOiBcIjI1XCIsXG4gICAgICAgIENPUk5FUl9ST1VORElOR19OT1JNOiBcIjAuMjVcIixcbiAgICAgICAgLy8gTm9uLWNvbmZpZ3VyYWJsZSBzZXR0aW5nczpcbiAgICAgICAgQVJFQVRFWF9NQVhfRElTVEFOQ0U6IFwiMTYuMFwiLFxuICAgICAgICBBUkVBVEVYX01BWF9ESVNUQU5DRV9ESUFHOiBcIjIwLjBcIixcbiAgICAgICAgQVJFQVRFWF9QSVhFTF9TSVpFOiBcIigxLjAgLyB2ZWMyKDE2MC4wLCA1NjAuMCkpXCIsXG4gICAgICAgIEFSRUFURVhfU1VCVEVYX1NJWkU6IFwiKDEuMCAvIDcuMClcIixcbiAgICAgICAgU0VBUkNIVEVYX1NJWkU6IFwidmVjMig2Ni4wLCAzMy4wKVwiLFxuICAgICAgICBTRUFSQ0hURVhfUEFDS0VEX1NJWkU6IFwidmVjMig2NC4wLCAxNi4wKVwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMzcobnVsbCksXG4gICAgICAgIHNlYXJjaFRleHR1cmU6IG5ldyBVbmlmb3JtMzcobnVsbCksXG4gICAgICAgIGFyZWFUZXh0dXJlOiBuZXcgVW5pZm9ybTM3KG51bGwpLFxuICAgICAgICByZXNvbHV0aW9uOiBuZXcgVW5pZm9ybTM3KHJlc29sdXRpb24pLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtMzcodGV4ZWxTaXplKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMTQsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBzbWFhX3dlaWdodHNfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogc21hYV93ZWlnaHRzX2RlZmF1bHQyXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGlucHV0IGJ1ZmZlci5cbiAgICovXG4gIHNldElucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2VhcmNoIGxvb2t1cCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCBzZWFyY2hUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNlYXJjaFRleHR1cmUudmFsdWU7XG4gIH1cbiAgc2V0IHNlYXJjaFRleHR1cmUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnNlYXJjaFRleHR1cmUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFyZWEgbG9va3VwIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IGFyZWFUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmFyZWFUZXh0dXJlLnZhbHVlO1xuICB9XG4gIHNldCBhcmVhVGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuYXJlYVRleHR1cmUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2VhcmNoIGFuZCBhcmVhIGxvb2t1cCB0ZXh0dXJlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNlYXJjaFRleHR1cmUgYW5kIGFyZWFUZXh0dXJlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gc2VhcmNoIC0gVGhlIHNlYXJjaCBsb29rdXAgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBhcmVhIC0gVGhlIGFyZWEgbG9va3VwIHRleHR1cmUuXG4gICAqL1xuICBzZXRMb29rdXBUZXh0dXJlcyhzZWFyY2gsIGFyZWEyKSB7XG4gICAgdGhpcy5zZWFyY2hUZXh0dXJlID0gc2VhcmNoO1xuICAgIHRoaXMuYXJlYVRleHR1cmUgPSBhcmVhMjtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIHN0ZXBzIHBlcmZvcm1lZCBpbiB0aGUgaG9yaXpvbnRhbC92ZXJ0aWNhbCBwYXR0ZXJuIHNlYXJjaGVzLCBhdCBlYWNoIHNpZGUgb2YgdGhlIHBpeGVsLlxuICAgKiBSYW5nZTogWzAsIDExMl0uXG4gICAqXG4gICAqIEluIG51bWJlciBvZiBwaXhlbHMsIGl0J3MgYWN0dWFsbHkgdGhlIGRvdWJsZS4gU28gdGhlIG1heGltdW0gbGluZSBsZW5ndGggcGVyZmVjdGx5IGhhbmRsZWQgYnksIGZvciBleGFtcGxlIDE2LCBpc1xuICAgKiA2NCAocGVyZmVjdGx5IG1lYW5zIHRoYXQgbG9uZ2VyIGxpbmVzIHdvbid0IGxvb2sgYXMgZ29vZCwgYnV0IGFyZSBzdGlsbCBhbnRpYWxpYXNlZCkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgb3J0aG9nb25hbFNlYXJjaFN0ZXBzKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLk1BWF9TRUFSQ0hfU1RFUFNfSU5UKTtcbiAgfVxuICBzZXQgb3J0aG9nb25hbFNlYXJjaFN0ZXBzKHZhbHVlKSB7XG4gICAgY29uc3QgcyA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAwKSwgMTEyKTtcbiAgICB0aGlzLmRlZmluZXMuTUFYX1NFQVJDSF9TVEVQU19JTlQgPSBzLnRvRml4ZWQoXCIwXCIpO1xuICAgIHRoaXMuZGVmaW5lcy5NQVhfU0VBUkNIX1NURVBTX0ZMT0FUID0gcy50b0ZpeGVkKFwiMVwiKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWF4aW11bSBhbW91bnQgb2Ygc3RlcHMgcGVyZm9ybWVkIGluIHRoZSBob3Jpem9udGFsL3ZlcnRpY2FsIHBhdHRlcm4gc2VhcmNoZXMsIGF0IGVhY2ggc2lkZSBvZiB0aGUgcGl4ZWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvcnRob2dvbmFsU2VhcmNoU3RlcHMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNlYXJjaCBzdGVwcy4gUmFuZ2U6IFswLCAxMTJdLlxuICAgKi9cbiAgc2V0T3J0aG9nb25hbFNlYXJjaFN0ZXBzKHZhbHVlKSB7XG4gICAgdGhpcy5vcnRob2dvbmFsU2VhcmNoU3RlcHMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gc3RlcHMgcGVyZm9ybWVkIGluIHRoZSBkaWFnb25hbCBwYXR0ZXJuIHNlYXJjaGVzLCBhdCBlYWNoIHNpZGUgb2YgdGhlIHBpeGVsLiBUaGlzIHNlYXJjaFxuICAgKiBqdW1wcyBvbmUgcGl4ZWwgYXQgYSB0aW1lLiBSYW5nZTogWzAsIDIwXS5cbiAgICpcbiAgICogT24gaGlnaC1lbmQgbWFjaGluZXMgdGhpcyBzZWFyY2ggaXMgY2hlYXAgKGJldHdlZW4gMC44eCBhbmQgMC45eCBzbG93ZXIgZm9yIDE2IHN0ZXBzKSwgYnV0IGl0IGNhbiBoYXZlIGFcbiAgICogc2lnbmlmaWNhbnQgaW1wYWN0IG9uIG9sZGVyIG1hY2hpbmVzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRpYWdvbmFsU2VhcmNoU3RlcHMoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuTUFYX1NFQVJDSF9TVEVQU19ESUFHX0lOVCk7XG4gIH1cbiAgc2V0IGRpYWdvbmFsU2VhcmNoU3RlcHModmFsdWUpIHtcbiAgICBjb25zdCBzID0gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIDApLCAyMCk7XG4gICAgdGhpcy5kZWZpbmVzLk1BWF9TRUFSQ0hfU1RFUFNfRElBR19JTlQgPSBzLnRvRml4ZWQoXCIwXCIpO1xuICAgIHRoaXMuZGVmaW5lcy5NQVhfU0VBUkNIX1NURVBTX0RJQUdfRkxPQVQgPSBzLnRvRml4ZWQoXCIxXCIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIG1heGltdW0gc3RlcHMgcGVyZm9ybWVkIGluIHRoZSBkaWFnb25hbCBwYXR0ZXJuIHNlYXJjaGVzLCBhdCBlYWNoIHNpZGUgb2YgdGhlIHBpeGVsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGlhZ29uYWxTZWFyY2hTdGVwcyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc2VhcmNoIHN0ZXBzLiBSYW5nZTogWzAsIDIwXS5cbiAgICovXG4gIHNldERpYWdvbmFsU2VhcmNoU3RlcHModmFsdWUpIHtcbiAgICB0aGlzLmRpYWdvbmFsU2VhcmNoU3RlcHMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGlhZ29uYWwgcGF0dGVybiBkZXRlY3Rpb24gaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGlhZ29uYWxEZXRlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5ESVNBQkxFX0RJQUdfREVURUNUSU9OID09PSB2b2lkIDA7XG4gIH1cbiAgc2V0IGRpYWdvbmFsRGV0ZWN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLkRJU0FCTEVfRElBR19ERVRFQ1RJT047XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5ESVNBQkxFX0RJQUdfREVURUNUSU9OID0gXCIxXCI7XG4gICAgfVxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaWFnb25hbCBwYXR0ZXJuIGRldGVjdGlvbiBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGlhZ29uYWxEZXRlY3Rpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBkaWFnb25hbCBwYXR0ZXJuIGRldGVjdGlvbiBpcyBlbmFibGVkLlxuICAgKi9cbiAgaXNEaWFnb25hbERldGVjdGlvbkVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlhZ29uYWxEZXRlY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgZGlhZ29uYWwgcGF0dGVybiBkZXRlY3Rpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkaWFnb25hbERldGVjdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciBkaWFnb25hbCBwYXR0ZXJuIGRldGVjdGlvbiBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldERpYWdvbmFsRGV0ZWN0aW9uRW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuZGlhZ29uYWxEZXRlY3Rpb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWVzIGhvdyBtdWNoIHNoYXJwIGNvcm5lcnMgd2lsbCBiZSByb3VuZGVkLiBSYW5nZTogWzAsIDEwMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29ybmVyUm91bmRpbmcoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuQ09STkVSX1JPVU5ESU5HKTtcbiAgfVxuICBzZXQgY29ybmVyUm91bmRpbmcodmFsdWUpIHtcbiAgICBjb25zdCByID0gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIDApLCAxMDApO1xuICAgIHRoaXMuZGVmaW5lcy5DT1JORVJfUk9VTkRJTkcgPSByLnRvRml4ZWQoXCI0XCIpO1xuICAgIHRoaXMuZGVmaW5lcy5DT1JORVJfUk9VTkRJTkdfTk9STSA9IChyIC8gMTAwKS50b0ZpeGVkKFwiNFwiKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWVzIGhvdyBtdWNoIHNoYXJwIGNvcm5lcnMgd2lsbCBiZSByb3VuZGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29ybmVyUm91bmRpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGNvcm5lciByb3VuZGluZyBhbW91bnQuIFJhbmdlOiBbMCwgMTAwXS5cbiAgICovXG4gIHNldENvcm5lclJvdW5kaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5jb3JuZXJSb3VuZGluZyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBjb3JuZXIgZGV0ZWN0aW9uIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29ybmVyRGV0ZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuRElTQUJMRV9DT1JORVJfREVURUNUSU9OID09PSB2b2lkIDA7XG4gIH1cbiAgc2V0IGNvcm5lckRldGVjdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5ESVNBQkxFX0NPUk5FUl9ERVRFQ1RJT047XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5ESVNBQkxFX0NPUk5FUl9ERVRFQ1RJT04gPSBcIjFcIjtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGNvcm5lciByb3VuZGluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29ybmVyRGV0ZWN0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgY29ybmVyIHJvdW5kaW5nIGlzIGVuYWJsZWQuXG4gICAqL1xuICBpc0Nvcm5lclJvdW5kaW5nRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb3JuZXJEZXRlY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgY29ybmVyIHJvdW5kaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29ybmVyRGV0ZWN0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIGNvcm5lciByb3VuZGluZyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldENvcm5lclJvdW5kaW5nRW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuY29ybmVyRGV0ZWN0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gICAgdW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICAgIHVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUuc2V0KHdpZHRoLCBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvdGV4dHVyZXMvc21hYS9zZWFyY2hJbWFnZURhdGFVUkwuanNcbnZhciBzZWFyY2hJbWFnZURhdGFVUkxfZGVmYXVsdCA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUFRQ0FZQUFBQ201M2twQUFBQWVFbEVRVlJZUisyWFN3cUFNQXhFSjE2OGVQRXF3UlNLaElJaXVIakpxaVUwZ1dFKzFDUWRBcGNWQU1VQXVBUmFNR0NYMU1JTC9PdzEzKys5bFcyczNtVzlNV3ZzbldjLzJmdkd5Z3dQQU40RThRekFBNENYQUI2QUhqRzRKVEhZSTFleTNwY3g2RkhuRWZoTERPSUJLQW1VQks2L0FOVURUbFJPWEFIZDlFQzFBQUFBQUVsRlRrU3VRbUNDXCI7XG5cbi8vIHNyYy90ZXh0dXJlcy9zbWFhL2FyZWFJbWFnZURhdGFVUkwuanNcbnZhciBhcmVhSW1hZ2VEYXRhVVJMX2RlZmF1bHQgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBS0FBQUFJd0NBWUFBQUFCTm1CSEFBQWdBRWxFUVZSNFh1eTlDYmhsVjFrdE92YnBxMDlEa2lJa1VCSTZreEFTSUgwRGxBUWlJSzF3UmZTSlR4K2k0Slg3dktJaWdzOEhYcFh2cVZjdnJjQzlhZ1E3SURUU1NXZ3FDUVFsaURSQkpLa2toRFNrcVZQTnFWT25QKzhiLy9ySDNQK2VaKzE5OXRsem5WVGx2VnJmdDcrMVQ3T2F1ZVpZNDIvbTM3UUFMS05rMndIZzFwSVRsQjE3bUMrUHAxMVczWC9MSHlUMzJ2aGc0OC81U092K1Bud3BzSEE3MEpvR2x1ZUIxaUtBcGVxenZPem40NEdhdFRCNzZYemhkN3N1QlI3K1dXQURnREVBd3dDRy9MNTRiL3BvRExySHV2dm03MFoyQXZoc2MrUFZjeHNjQlU4RjhDOEFEZzUraXBJakQvUGxHd2ZnanU4QjkyNEU1c2VBUlVmTHNpTm1xUVcwSWpMOCs3TDJOWUQvN0NPQnpmY0NtK2FCOFNWZ2RBa1lJUkNYS3lEYXg0RWRBYW5MNVB1TlBsbE52WERsQUh3RmdQOEFjQzJBaFJJb0RYYnNZYjQ4ZGw1V2tWRlRFM0xHRGNDOW00Q1pDV0J1RkZnZUFaYUdBWUpRUUNScURIVCtNY0pyVmI4endBVFVYSDAyTUhZZk1IRUlHRnNBeGdqQXBRcUFDWVFPUmp0ZC9CN0F4dC96NzlzQzArY01QZ2pqbHdQd1Z3SGNBK0RmQUh6VHhjVmdXQnJvcU1OOCtjWUJlTTcxd0gwVHdLRXhZSFlVV0NJQUhZUkxUbGtDWWdjSUJjQWdVL24zcXk4R1J1NEhSZ25BT1dCa0VSaGRkUEFKaEdKREJ4a3Z3N2NxaW1yK3pGTS9aTG5aRjY0Y2dMOEJZRCtBV3dCOHgvZGxXdVdhZ0hpWUw5ODRBSi8wUldCeTFBRTRBaXp5TTF5eFlBY1RpZ1c1NXhNYkFreEVpd0Vka0ovWkNReFBBaU9IZ0JFQ2NLRUM0VEJaY0trU3YrbVRpZU5jTlBOQzI2bUxOc2o0NVFEOExRRFRBTzRHY0p0LzdpdzJiZm9HNFdHK3ZBR3dtOUV4aUVnNjl6cGcvd2d3UFFMTWpnQUx6bjRFNGFJem9KalE5ZzQwMjR1eWdraitweXVBb1gwVkFJZm5nT0g1TmdDSE1oQW04U3YyeTNYRFplQmhOSXA4T3pKRThPc0J6QUtZQkhBWGdEdDgvNE8rTVZUMGo0ZjU4bzBEOFB4cmdmM0R3TXdJTUVQUUVZUmtOd2Znc3V1RFpMc2tpcDBObzBnV01ELzlIR0RvQURBa0FDNEF3L3dzQWdaQWdzMlowQUJJMEdVNklWbUt2K2YyOEtEbkh4a0EvRzBBOHk2RzczTjlrT0NqWG5oL0ViYjZPdmd3WDc1eEFGNXdMVEExVklIUEFEZ01MRGo0eUlBNUFBbTZhQ1VudjRvejQ2ZWVEd3hOQVVNendKQXo0QkFCU05ERlR3U2ZnN0RES0hFMjNNRzVQcUlZOEExdS9kSU5zOWRCZHk4QWduR1BNMk5mVUJyc253N3o1UnNINElYWEFBY0p2aUZnbHVBYnlnQklOblNMV09Bakd4SjRwZ09LRFYwdi9PU0xLcDhpR1hCb3ZoTEJCT0NRTTJBQ29UT2huWXJBZEl0WWJDaWo1SkZ6UnlJQXFSY2NBbkRBUVVqZzZVTlE3aHNNWFAwY1JRQWV4c3MzRHNDTENFQ0NMd0NRek1jUHdVaTJNd0FTY0FLYmZuWS9ZUkxGUThESFgrSUFKQU1TZkRrQUYxM2tMdmxlSWpoalFRSHhVVlMzampnR3BLZWVOellWUUVqZ1VTOGsrUGdoT05kaEl3QVA0K1hYQllDSEtJSmJ3SnlEVGdhSUFkQ0JKeDNRMk04dFlBSFA5bTRkZi95bFFPc1EwSnF0UkxDeDMwSzF3dExCZ2dTY1FPZ3NLQkdjV0hBSmVPd1JDMEJTTTFtUUlLUmJoaCtCajk4SlFQNnQ0VTBBUEV5WFh4Y0FFbnhrUUFGd29WVXhJRDlrdlFnK2MxQzd2aWRSYklEa2MyNEIvL2hUUUd1bURjQ1dBNURnTXhBU2ROSUZCVUk1cENNTDh2OEFQSTV6ZkVReDRCdWRncWljenZpU25KaFF3Q1A0Qk1DR2wrd084K1U3QUppL1c0TzRZUzYrcG1LLzJjaUFEc0FPQmhUSUlpQUpuUEI3QXZOalArMEFuQU5hWWtBSFgySkJBYyt0WWFKWE9xQlp2MjRWYzM4NlhXNWR0a0hHVys0SEZBSm9ucE9lK1lZUVpBU2hnS2p2M1BOdlBRYXhWb0k4ekpkZkZ3QVNmUHpNVXdTM0t0MXYwVUZJbG9zNm9ERmRBR0ZjbGlNQVAvcnlBRUFHTndRUm5ET2dMYmRsSUV3cklzNkFaL1Fna01NSFFGNlpBS1FjSkFzU1lQd0llQUlrOXdKZ29QSzFnaTcrUHdGNEdDL2ZPQUF2SVFQU3MwVVJUUEJKL1BwM0dTRUdSSGZCQ0lRMHhvd0J0VWJjQWo3eXM1WDRKZnUxSElBR1FySWdRUlhFc0FGUUlPUkRGaGlEWS9yTUhtclU0UVVnUjA4QWtnVWpDQVc2Q0Q2Q2t3QnNBSVFDNEdHNmZQTUEzT1hpTnpDZzJJOWdOQ01rc21BQW9lbUR6b2ltRndMNDhNODVBS2tpdVFWTUFBcDhDWVJSREF0OEdRaUo2N042R0pPREFYQUhsc0dndXNjQTJBSmcxSVBHWW14T3BCeEZXa1JOOUxzQVRnSXdYbk5zL3YvNXovOVhDZjhCTzNZQXR4YmMvNDYvS0R0KzUrZWExWWt1MlZVeEh6L3owdjI0RndNR0sxZ1dzSzJPVVV4SEhkQ0JlUlVCNk94SEFCcjRaSUNJQmQwUVdTRitYUmRNVEFqZ0NkVHJHOWNCTndFNEY4Q3BEa0lDeVlMR3N1aEZ0NnpzK2dJU3dVZW44ekVBamdNdzRjZngySDZPLzkweUFGbzg0Q2JnNElEMy85VGZMVHQrNStlYm5SQUJrT0RqeDBTd1BpNWVjL0ZyWXBtcVNBeE04RG42MENzcUFGSTZHZmhxQU1pREUvZ29rbXZFcjBDNFBnRGtCUW00MHdFOHpNRkVVREtFVm94SU1MbC9LUzczbUU3SDlkK3ZjS0hRUWNqd1cwWXU5blA4bThzQW1PSUJ1V1k2d1AyLzRzMGV6ampnOFR1dmFSNkFCSjcwdnhVQXBHcm03RWJHRStpNDcyQkFCK1dIZnFIUy9lb0FhRXdZMkU5K3dMU1hUcWhJN0NYZ25CNkxDb09KNEJpU1QraFRuRzBIY0N3QWdsQ3gzQVJvWkVWRlhuQlBwL08vQS9oWEFDYzdDUHM5L2kxbEFPeUlCK1JEWCtQOS8rcGJRampqQU1mdi9QTDZBRkRzMXdGQWdzLzlmZ0tmZ2RFL1pFcHVpUWxid0FkZTZRQU1CZ2lSbXNTd0E5QlkwSmZqb3ZHUkRCTUg0VGxjWEdoY0JPYzZIa0YwZ2pQaFpnY2h4VExaTUFjaS8wNFcvQjZBYjN0MDlFUFhjUHlmbGdGd1JUd2dKMk1OOS84YmY1cUZNNjd4K0IvYVc0WFF6NDJGZUwwWXJSeWlrenRVRncwNzA0bWY5a1hneGhPQXFjM0FBc1B5Unh4UUNzL1BkWE9GWTBXMUtIeTNRSVVHdHgrNnZkbngxdnNCK2RzVG5jbTJBb2dnbEZnVkVBbFVXck9NQjJSeUVtTUNHUS9ZNy9IdktuczZ0ZkdBbkpRK3IvOWI3Nm9KWjF6RDhXZHlRallCaDhhQmhWRUhqRUxvdVE4dWtRN1ZSU0NKQUFMd2tyK3NBTGhuR3pERDNKQUpZSkhnOXVob2k0Yng4eXRrV1V0dkhULzcrWmM0ZHcxdVozNjEyZkgyZGtRZjd5eElFRW9ja3drSlFuNElRb3E4dW5oQWhtUFJLS0Z4MHV2NEs4dWVUczk0d0Q3dS8vVlg5Z2huN09QNGMrNEc3aDhIcHNlQitkRjJBS2xGTHd1QUlaOGpENk5Qck9oQWZmbWZBOS9aQnV6WkNreVJXU2VxQkNXeW9ZR1E1eVFyQnBEYnVtL01FMUhvUG8wWEVrU0QyemxmYm5hOHE2K0VVSmNUQ3hLRXRITDVFUWpQNkJFUHlJZ1lBWkJ2WXQzeEh5eDdPcXZHQTY1eS83Lzl3VlhDR1ZjNS9zbDdxeEQ2NmRFcWlZZ1J6QXFoTjFBNENCTkFBbER5QUZJK2laOS9OM0RMSnVDK2pjRFVCbUNXeVVuT3JtVFlDTUlPa05jbExnMEI4L1JzTkxnOStVdk5qbmQxQVBMbW1RcEZIeUVCUk91V0FDUVQ4bk4rSC9HQXZZNy9WTm5UNlNzZXNNZjEzL0NwYWhHblp6aGpqK1BQbXdYMk1ZZERJZlFleFd5QkF3RVVPUURyUkROLzk4cDNBN2R2QU82ZkFBNXNxSEpEQkVBeW9VVkdrd0VkNkhSMTJYVTRrd3pmbDZmQ1hUWnpqeTU3dnZuUjUxM1g3SGo3QXlEdmdnQVVpOUV5RmdpWnFOeFBRRjYzNDVuT1diRDFIUS9ZNWZwdnVMYS8yKzgyL3ZOSGdBUERGUURuaG9GNWoyQzJxQldDSThidzFlUnc1Q0w1bDk0TDNERU9USTREQjhZOU9XbXNFdS96QkozcmdzYXlicUJvYi83QTRDN2p0V2Nvb1JyY3pyK3UyZkgyRDBBT1FnQVVDeEtFUDdhR2dMeTY0K202S2RqV0ZBOVljLzAzL09zYTRnbHJqcitBdXBxSHoxc0VzMGN4RzBCQzlISWVQTG9pdDllTmtWZjlMK0R1VVdCeURKZ2FxNHliR1lMUEFXZ2lYbUxlZFVFN2R3QzdzYUw3Q3FmUEtYaTROWWRheWtDRDQxMGJBSGxERXNOaXdaOXdBUFlia0pjZno2VDJnbTNOOFlEWjlkL3dIeFVBKzczOWZQd1hQclNLWUdiK0J1UDNqQUZERWxGSDlISVd3YnpDSUdrQnIvb3I0SjRSWU84b01PVzZaVmNBdXZpMUNnb2hhMDRCQ3dUNWdmTUtIbTdOb1JkZTIreDQxdzVBM2hRWmtBRGs1K2NHaUFlTXgzKy83QUVORkE4WXJ2L0c3MWNBWEZNNFl6aitvdE9BYVFMUUEwZ1p4YUlJWnRNREZUaWdLSlY4SDlJcTZhWjU5WlhBdlNQQXZwRUtnQlR0Qk9EY1NDV0NaZVJZdHB6cm1MeWVHTkNBeUZsMXYrSGVpOHFlYjM3MFJkYzJPOTdCQU1pN0VnQi8yUUc0MW5oQUhVOUx1V0FiT0I3UXIvL0dQUlVBMTNyN0d2OUZad0lNb1ZjRXN3RXdmRG9pbUVQMHNoS0t0SXBoYVpRQVh2MStZTSt3QTNERWRjdlJLa0dKQURRUUVzUXVoaTFUanQ5NXZCc2g1bngySU81OVNzSERyVG1VT1N0TmpuZHdBQXFFcnkwSXlDTUlDa095aXVJQk53QnZQRlFRVDdnQnVQamM5b1JZQUlIeU9FTDR2SUZFWVZOYU9vdTV2Q0dFL3RWL0Ewd09WY25wekk0N05PcmkzUUZJQnBTZWFTRFVkWUxPU1d2WUltU0dnZnRwSkRhNE1XSmJBR3hpdkdVQTVNQU9jMEJlNmVWTGo3LzRNaytoekNPWVBZcFpEQmlOa0xoK0cvTTN5Rnl2L2x0Z0wzVzNZUWZnY0ZVaGdSWTJQd1krWjcvRWhBUjFTRnlYQ09iNTdyMjhRZlFCc0pRQk1uNUQ0eTBIWUxQamU5Q2Q3UklDMFBNM0VpTW9mRjRnVkNCcDFQODQwaXgvZ3l6NTZyK3ZBTWprOUdsMzc1aUI0K0N6dmV1WmRMa2tFUEo4WkVmWC82Ujczdk9qelQ1U2k5aHVjTHhIQVZnNFB3SmdSd2g5Q0tPWEs4WUE0WkVxS1pYU1FXaDVQKzVBZnRYZkEvdUdLdllqQ0tuNzJjY3RiRnJaTkVDa2E1TDVDUHdJUHRNSDNUVnoxN01MQjVnZExnQTJOZDZqQUN5Y0h3TFF4RkVVU1I1QVN2QVJEQjBoOUFRYjliWElnQ0drNmxVZkFQWVRnRVBBSVRLZ2cxQk9iazU4c3JUSmdHNThXTWtXTWFBYlFRVDFuYzhySEdBTkFKc2M3MUVBRnM0UEFhZ1Flc3RnQzFsc0JKNEJNQ1NPSzZkRFVjd3FxYUZpUXIvMFFlQUFBZGp5K2pCaVFRZWVNU0JaVDNuQ1BVRElhOXorL01JQjFnQ3d5ZkVlQldEaC9CQ0FlUVN6Z2tqRmZHTEJCRDVueFE0RHhOMHd2M2hWeFg1VEJHRHdMNW9ieHZWQTVZcVlMNUJlTUxkNjZZWXhKcFJCMGdLKzk2TENBZFlBc01ueEhnVmc0ZndJZ01yaFVQS1EyQytCejBQbUJUcUJNUWVoQWJEbElqajRGODBLSmd1U1ZaMEZ1WHBqb0NPZ1hhd0xqQUxoYlQ5ZU9NQXVBR3hxdkVjQldEZy9sMUlFMDVFZDB5Z1pueUhkejBWd0NxRVBJZk55eDBRUXZ2TERGUUNwKzhuZlprNXVuZDh0WHdJZ1djSFNOWDBOMkNKbW5BbDN2NlJ3Z05uaGwxN1Q3SGlQQXJCd2ZnaEFTN21WL2hleTJKUzlGdk0zQkxwVVVpMVl3RFJNWHZrUllKb0FsQWgybDBkY1owNHM2SlVURElqeUJjcmw0eURjL2RMQ0FkWUFzTW54SGdWZzRmeHdLVndKZ0dFSk5tV3R4cFFNcFg5b24yZVJoVkErTzU2QWpNZm5QK2UzWHZmM053RzR4SVBUbGVpWTU1YnBHaDZVYmFmTlUwbDB6MHArNUpoNUhxWUo2YjUxblA2WFA4Y3gxMlhOSFFWZ0lRQi9iRlBWZzJPQzdRK1dnVkZXbmcvRnZ0V0xJMDZ1V2g1b2d1S0VjWFZTLzlzRUFGLy9WR0Q3dDRFVERnSmJGNENOaThDR1pXQnMyZlBML0g2VndwMktFdFZrNGZKK3YvRUlZUE45d0thNXF1K0luY2ZQd1hIVlplL2FPTDNFYndTN3h2OEExclF2bk8wajhQQXJUZ1RHWjRCeEZ2OW1JeGhPQ0dzdiswT1BZRFJnaGNMZmtXa0V1cTArRzAweDRPdGZER3orZDJEYkhtRExqTDhzaThBWVAvN0NHSUFpRUVNVEc5MnpYcVNiSCtkOVIyYUEwWG52TytKanRoaUlyT1ZESEhQT2tCcnpVUUFXQVBzWnAzb1BEcGEvWGFnNkVWa0xCSys1ckFuSkMzL25Zay9BUEQ3MDRXaUVBVjhPVEh3WDJMUUgyRGdGYkpnRk5yQmhqZDhyNzlkZUdvRXdzbGxnTkJPenk4Q2Rqd2VHOXdCajA4QUlBY2kyRDZIYWZteUFrNC9aN1NKNzJoR1lSd0ZZQU1ETFR3T0dwNEZSRmdEM0hoenFSR1FpeWV1cnFPZEc2cjBSbThJRVpqelJsa2lxQ1dvRWdLOEF4bTRCSnU0SEpoeUFiRmhEeG1iREduWk80ajBTZ0xHRGtwaWJnRXE2NlRKdy8xbkEwRjVnZExwcSt6RHFGZmQ1TE1lV3F1NUhOU1QwdUpPSWxsZytxZ01XZ0krSFB2MHh3TEEzZ1dIcFcyc0M0NDFnQ0VDYm1LemlhR3JuVWRNTzRhSGVoNk14QVA0U01ISTdNTDRIR0Q4QWpIdkhKR05BZ3BEZ1kvY2szc3RpcFJlbXZWaGMrdUFTTVBVRVlHaC85ZElSZ0d4OFkrTU5iUi8wMHVWdEgwd0V4OTRqL3Ywb0F4YUE4RWQrR0JpZUFZWlpnNWtBREMwUVdHT0Z6R0psY0dQemwxQnhOTFhEOHNrNHhmdHdOQWJBL3d3TTN3R01VbXhPT1FCbkhYemV0SVl2aWJvbm1TaXVZVE5qcmlWZzdnbEFpd0JrMGZOWkg2K1BtWDlQNmtmTm1DWEdwZnRKN1RnS3dCSUFubG4xNEJBQVl4TVltNUM2UmpDeUNvT3lyMHFrRC9jK0hJMEI4RFhBOE4zQXlDUXdlc0QxVlFLSDdFY0FTbTFRK3k0Q2tOOXBVS2lWRjVuTHZ5K2ZCYlRVZDhRQmFIMUh2TkJST2ladmZzTm5yRjRrY3ZQd3Bkc0JMQmVVMThOZjdBQjIzRHA0ZWNIQzhvQmdVbEpKZWNMUys3K1dPcEUzZ2JFK0hLdyt5b2V2Q1lrTUdLcVBKcmRFS0FSdXRhRllSczFmaUVaMHdQOENETjhMRE84RlJxWXEzVzEwcGdLZ2ZZTGFZQ3pvb3RnQTZLWGFUQTkweTM3NFRLQjFzQm96eTc3eEhGWjUzNnV0UmdBbUVhdzZnNWtVU0Zad1NYbkEzMzBxc09sZmdITVBEbFplc0xBOElPam9MeXBQV0hqLzExRW5DaVZ3a3o3a0FFeHRzR3JhWVVXZFNEWDVUbXNhZ0w4S0RCR0E3QmQzMEpzVzBvV2l2bkVPUU5QN3lHVFNCUjEwMUFsWlNVdEd5ZmdaRGtDV1kxSG5KZGNCVmU2MzI1aFR2ZWxnMkNRalpORHlnRy8yQW4wajF3S25MNnk5dkdCaGVVQzhwclE4WWVIOVgzOU9WUVNjN01jNmZDYUt2QWVIZENJVmY0eU1ZQ3luVHBYK25iOTdOSm1sU1FiOHI4RFFIbTlZT0ZVWlRLT3pvWEdoczZBeEYwSElleGNMQnZXQnVpSE44czJuZTk4UjNxYzZMNFZ5YjJvQlZqZm05TUlGSGJqRENoNmtQT0JiUW9HK29XOENPNWJXVmw2d3NEd2dmcjIwUEdIaC9YLzFpYUVJdURjQ1RJVy8xUTRyRnY4T25ZaVczYytXMmlLd1VqS2J5alFOd0wxdXVSNnNBRWdEZ3ExYnJYT21WODFQeGhOQjZEVURCU1l6UUp3RnR6NjIzWGNrdFgxUTFWV0thVEYvelpoVmF6QlZZQTF0WDVNYXpzR3ZvYndlL2pRcjBOZTZCVGg1dWYveWdvWGxBZkc2MHZLRWhmZi9yU2UxaTREblRXRFVBQ1kxZ3VGVERxTFlkQ0J2ZjZESllTTVlBVEJmT3gxa0xmajF2MWF4SDEwblEzU2QwR1VrQm5UZnBlbXRCSmdzZUlLUUFITFFjVnhhMlRudU1XMEFxdWk1ZXM4eEJJZWdWZFZWRThWaHpIbkxoNjVXTUI5QW4rWDE4SzZhQW4ydE80RVRsNnZxYkt1VkZ5d3NEd2hldnFnOFllSDkzL1JrNzBKRTkwbm93eFpiSUpqdlMzV1lOU0dVd0dISlRwUHh3d2NiQnVCcmdSWUJlS0FDbjdWdHBkVXUvYzBOSnhPOUJJeGNLdTRUVE9EemJrb25QTG9hTDB2eVVRUmIyeThIc0wxY2tmV3pNZXVGaTQwUWV6cWkreWlQaHl0N0ZPanI2L2dDRndnUDdYYjV2c3NURnQ3L25RUmc2TUdSV21EUm9leVRscGd3NjhHUlR3Z1pnbzFnR21YQVg2LzhkdGF5bFNLWS9rb3lJRDlCaHpNTDNxMWdBb3MyQWNPclpZU29xL3BKcDFWdE9EUm05WjNMUy83V2pWa3ZYT3pFdE9wS3lHcmxBVCs0U29HK1ZZOHZCR0N2eS9kVm5yRHcvdmVlNjVOQkppQWpCSVZjQUpRak9tK0RrQ1pFZWlHQU13NnNBd0Rac0pyQWRoRk05clBHaGQ0OTA0Q281b1Z1Q1pQVjZrRDQwRWM2KzlXOGRCVEJzZmRjM25rcHZuQjgyZnAyUlBjczc5ZEhnYjUxTEE5b2ZzRFY2dnV0NS8zUG54Y0FtTFZCaURxZ2V2RGFKTGtZcnB1UXh6Y053TjhBV2dJZ1JiQjhsb0VCelhEd2w0Y0dpREdmdDU4U0NPV0dlZGdqdk9KK2JQdmdSa2l1QStaanpoblFRT2lGTlZibG9hN2wvZm9zMExkTzVRRU5nRVhsQ2ZzOFFiZjdIeU1BM1FWallpaFloTEVOZ2pYOXkvcXd4UW1SVS9hc2ZkMFpjTFUyQ0hWR3l1c0pRTEtmVmk5OENTMTJUNWY3aUVDa0hwc01rQWhDRjgrbnNoV0gySS9qWHNPWU8xNDRHVi85QXBBSXJTM3Z0NFlDZmV0UUh0QUEyRysvNFBXNC8yUFBiek1nbVVNaTJOb2VTQ1J4SXQyL0Z2dXhXVVJJV0NYZzM1N2dmVGpFRE5JSG5UUlhSQ3BINXVnS3dHbDNIcE1CWFFjMHY2V0xZVm0vNWxpbWowNHJHNzYySzJ1WVk5akJrcjkrckkwM05MNVpiY3pTL2RKK0xReW9nYTRvNzdmR0FuME5sd2RNQU95M3ZsL1Q5MzhLQWNqMTIxejhCbitZOWVXUUpSejhZNmtOYWdEaDJleTVFdnhqeFFEOFRXZEF1bmVDQ080QW4xdnc1dmR6UU1tZGt0d3E3cExaUVIrZE0zNCtadW1BeHZZMVkwNHVxT0FKNkZzRXh6ZXRvN3pmQUFYNkdpd1BhTFdSMWxyZnI4bjdmL1JsM1FHem1zaXMrL3VPNzFWOU9GZ1AyZ3BQaGdyN1RHUnFSVVQ2ZHl2cjRhSXMvcG0vMnpWVU5iQlN2Nkc4ZTVwRXYwQ3ZlYzdQbzcrYlR0amxCUmxrdkFNQmtEZVF5dnNOV0tDdm9mS0FDWUJycmUvWDFQMC9vV0VBbm5GRDFZZGpodFh4UjczbVgxMEZmQ0hIRTlwVldjR0FJL1MwZ0tzZkEyeSt0d3JGWnc2SHhmL0YwUGs4Umkva3BHU25NdUR4NVQwaUFDZ1FIaW9vME5kQWVjQlVIVzZRZHNWMi9jTDd2L0N5cXI1Z25jNDJDQ09jZlgxVklaL1Y4V2U5SURtVHpWWHdQREppWHVLWFB4dERCbWE4K2x6UDRXQWdLa1B4Q1VBUEU0djVHekV1TVgwUFlKUExoQjZGSnNjN01BTW1rVnhhWUMvSzlnRytGMSsrOEFRN0d3YmdrNzhJN0dGcFhnSXdGaVJYT3dhSlpQVWJpUjB5Q1VEUmsrY0hmK1lwd01qOUhnZkk4Q2xHUHl2c1NpSDBXU0tSdVlsaXRMYi96SE0vSk9TczVDL1lJQzljTVFEWnIvZHd4Z09XOWd0R1lVQmkwd0E4bDMwNHZEUXZBY2hpbEZicElCUWhaN0VqcTZaUTAvWWhpbDh5NGo4OUF4aWU5REFzRDZGWDlIT0szUXRST1RGa3ZpTjgza0c0ZmVsSVk4RENlTHJTZU1EU2ZzRW92QUVDVUZzVGpIRCt0Y0IrdGtGZ2NYS3ZCUmlyN3F0Rmw5b3dtTzRYeS8xRzNiQUZmUHJaSG9yRk5XQkZ3SGpRQUZjdElnaGoya0JhcncwNklmLytNTTlacVRONkRnc0RvakNlcmpRZXNMUmZNQXB2b0drQVdoOE9iL3RnQVBTS1dDcDhuZ05RdGFkam1UZGx0dk52bjNwZUZZaGdRUWdoK2lVbUVhVUFVb1hNMXlSTG1XdUZMYUU5WitYSUFXQmhQRjFwUEdCcHYyQVUza0RUQUx6d21xbzZxdFZoOWtKRXJBdWRBQmlhMzhUQzV3SmdTMnhJaEF3Qm4zeWhCeUw0RWh6WGZSWHhZc0RUSjRJdnJOTjJKRk14WmNCelZvNGNBQmJHMDVYR0E1YjJDMGJoRFRRTlFMWkJZSDFBVnNRU0FBVStpbUkxb2JIeWJsbmpHL2tKazNVOEJIejh4VlVRQWhuUUlsNUN5TmdLQUdwNUxLU1NDb0F5U2g1Smo3OXZUYWdjeFVhSUJlUk5lNzlnOWdxK0RYaWc0d0d6eStQT05mVDdSV0ZBNG5vQWtHWFpWQWhjQmNrSlFnTmdyTGlhTmIzcGFJRG8xdkhIWCtvQTlMUUJpNER4SmNPVVBKVW5UZ1UyTkpVeVJPczhpckdBUnhRQUMrUHBDdHNGZDQwSC9BRWYwZ01Ra0xnZUFDVDQxUGlHb0xPS3F5ckpxM0svWWE5bU55cjVGdXNOL3VQTFBJZURhOEJjK3czcnR5bDRWRkhhTVpjM2k5UldCTTlqanpnQUZzYlRGYllMUm1tL1lCVGVRTk1BdEQ0Y0JLRFhCVFFHZEFCMk1HQm84U0NMbUV1UzFBRlZBSjNBL05oUHQwUG9DY0E4YlNERzc2WEk3YXlTZzZKWXVHZkt3SkhGZ0gwRTVCM3VlTUNlL1k0TCt4VkhBT1orOUVIY0VnUWd3YmVpRVl4Nmp3VGR6NHFmdTdFaEVKcXhHcXJ1Zi9SbkhJQUVueGd3Qk0wYUM4YVVBWVdOQlJDbW9JbGw0SFRxTzEyMlFjWmJyZ01XeHRNVnRndnVPeDZ3YTcvandodG9Hb0RXaDRNQkoxNldONGxmcjhBcUkwVFZWMU8xZmE5QmJRem92a0F5NEVkK05nQ1FVU3haQ0ZXdkNPYU9GUkVYeVV3Wk9QSUEyR2RBM3VHT0I2d1BhT3orUVB2NVMrTUEzT1hpTjlhY2xnaFcrZDNJZ3VwQkYycFBxeGN4R2VuRFB4ZlNSaDJBU2lLS2lWUDJQYVpTY3ZBS29BMFZEYzZjT2xJQjJHZEEzdUdPQjF6Ujc3aXdYL0Y2QUZCOU9OU09RVzBmckE1MHNJTFZjY2tXSnlJRFNnd1BBVmNKZ0ZiWXVaM0ZKdkFsRUhiSjNJc2dKTEdlZGVCSUErQUFBWG1IT3g2d285OXhZYi9pOVFLZzJpQUlmREpFSkhxajRTRXhiRXR5MGdrZGhCLzZQOW9aYkJaSUdpS1lWYjlHS2FONTBsUkhCTE92aER4aC81RUt3RFVHNUIzdWVNQjJRR00vZ3JiNy82d0hBUE5HTUFZK0dTR1VqQzUyVlgyZjJDRDQrSE8wZ3FrWmZlZ1hLZ0JhSGtjV3RTMEFXaWk5eEcxSW1yTGxONVhSOEw4Zm1RRDA1QlZybUVFTm1wWVNQOVFYK0tIaXFqMi84MitIcXFEV3duYkJSZkdBVGR6QWVnR3dydTJEcFJxN016cTJmcEFmME5xMFJsMndCWHpnbFo0eVVBUEFtRFNWV0RCUEhRakxjZ1RxT1o2elV2ZEtIaDRydURDZXJveC9EbnU3WXF3WEFDMU5JL1FjRVF1SzZXSy9rZGdDVEdDMFBZQVAvS0lETUJnZ2xxK2hJa3JPZnNhQ3ZpTFNvZmNKZ0o1QWRNN2trU2FDai9IcVFLVklHdkQ0c3dGOGJjQmptempzYVEySDVELzZhY0JkOXdBTEI0REZXV0I1QVZoZXJNcDRHS0lZRU9wNysyNlVGMGFTZlQveFl1REc3d0RqcklwQUVSeXRYZjJ2YWpqN3VlcnlRWFNGbDEwSy9PTjNnSVdEd0NMdmpmR0I4WjU0TytFZTR2ZTY1MTN1QjJSMXl6c3FDK3R3YkM4SGNOVmhmQWVhQnVEUC9Udnd0UzNBL2VQQUlmWUZWbFBxMkhIVHV5dWxaQ1RsaGJqaEVURjV5eFRRR2dQR2hvSGhJV0M0VlNYR0QzbjB0TGtNSFhIeHUrWXlCK01sUHdEdVpzNUs2RmxzYkN6ZFZPOUR1S2ZrSE04QUVrUDdCOGZPa3dEY0QrQjducDQyK0prR092S2RBTDRFNEs4UDB6dlFkRVQwYjE0RDNEZ0IzRDBCN0I4SFprYTlXenJEODhONnNGbStZY1Vqcm43RTFaRHZNdEY5REJnZUFZYUhnU0dCMFBOSENENEJMd0xSc0J5QXlYL2lqMC9kRFV4dXFsSUc1aGl4N2VGaHZMY09WVUF0eVBTeWRBRm1PUU5lNkVZR1YvOVpFU2lLZ0lFZ3RiYUQvZ0hBTFFDNG92WTVyNUt3dGpPVS9YZlRBSHp6THVDbUllRHVNV0R2S0hCd3BNb04wV1F6TnRBYVlTczBLNFpsT1NBakdHOWtQakNCUndaMEFCS0VCSmV4WUFaRUFVM0E3T2kxQmVEeW00RURualExVHdDR1dNVzhNWGNLa3MwWU95Wk5sUU9RamNnWUlVSGxsRXpZUTBrdG0rcjZvejhHNEY0QVh3WHdSZDgva085QTB3Qjh5NjVLbVB4Z0dKZ2NxWUpUS1lwVHYyQ0N6eWRkUUpSRE9qS2l2bitEZWg4QkY4Qm53QnRhQ1VBK1lZRXlBVThoK2M2QXo5Z05ISFJtcmdPZ21EQTNqSFEraVd1cENlVUF2TlNyQTlITndxeCttdWs5bkpWTmcvQ1Rmcm1iQVB3YmdLOEQrUGNIa0lpYmpvYjVvMTNBM1h5cFdzQWtHMWNQQTlQREZRRFpNMWlkMGkxS3hzV2ZPcktuQUZYbGlmQ0ZGTU1SY0FTaWdPY3MyTUdBSWZFOWlXWHBsUzZPbjdVYm1QYVVVVFhRcmdzVk16Y1JqNUZvbGcyVjVheVVBNUJXWUt3T3hLVWFmbm9zV2pjSndrKzdXNUYyRUt2bEUzeGNYYU5ZZmlDWXNHa0Evc211cXVnNmhjbGVBbkFJbVBiTzZZd1JwTWdqQ0FWQW0veVFtS1R2NWhOc0FmL2k3U3lOQlNsMmE4UXYvNC9NMXlGK0JaU1lsTlFDbm5WcnBiQyttVG9BQUNBQVNVUkJWSmNhSTdzT1NFWTJOcGFEWExxcFIrdkUvT1Zrc0RnSW1nR2dnaEhvWUpiVFdjN29KdEZXYzY1L2NnMkFZdmgyQUxzQjNBemdWdjk1blMvZjRRZHNJa1Q5VDNjQnJHdElUV1pmQzVocXRRSEluc0VHUW4zVUREdkVERVkvSUNmN1N4TU9yQWc4VCtjMDBKR2t2SEdkMkRBQlVZWklBT056Q1VEcHBDRmhTdWtDQnNMUXJGdFplL0lpeFlRcFN5RW9Kb3FudVBXclZSQXViUWg4M0hObFpCMjN6N2oxeXdtajZDSUlxVVB4dzJYZXU5YngyangxMHd6NFo3c3FUWVphREQ4RUlEdW9FM2hNVkVwaFdnNjZKSXA5MGswc0J4QmN5K2lQSUlhVDFSdEVzSFMveUlBcXcrVlNOUFdRZmU1dGxWRWs4YXVYZ1ZhNUJVc0VKdVQ1dW9saUFiRTVBR290bUlBakNQblI5eERHM1RRZXJuWUFVdXBUZEJHRUZNZjgzT2tBcEhHK1hsdlRBUHdmdXlyZ1NaT2hhczN1NmN3VHNVQlZuMmdUd3lGTWk4d2pIWkFBMU05ZllHSERVTEpEMW04Q3BhOGZSeERhZCtsK1lrZi8zWE52ZDExVStxaUwzOVN4WGV2U3NzaGRERnZnYkkxTzJBd0F0UlpNWnpUQlJ1REZqeGUxWGc4UUVJQjh5eWo1eVlJVXhmUUlrZmtJUm5tSENNNzEySm9HNEZzZGdISHAzQUNvTUgyRzZqTTRsV3pvUWFyU3Z3UTZNU0IvdnBvclZhRmtoK21DTGxwVlI4WitkcURaTG9ET3BIU2lRZUFGRGtCalBybGdDSGdDVWFGaWZnNjdILzl1WWpuNEFpMXZwVEVSVEFBU0Jhb1FKQkFLZU5xSGxMNm13UERaWUFPUk9hZy9FWVJrUFgzNE13SEl2elc5clFjQStUTHBJMjJHN0VjUUtsSkdzWUlKaEM2Q2xVTWlYZkJUYkZVUUFlajZuUFMvT3VBbDlwT09xSWMyQkx6ZysrM1ZtV2dJRVV6ODJjUnVDQXRMSUhRUW0wZ081MnVPQWIyMnNDM0pFV2dSZlBwWmYyc1FCUUlnTHlkUEVJRkd3UEVqOE1sRjJiU2JzdWxnaExmdHFzQ1hxOUhHZ0h5c3puckdnaTVxelRVVEZIOEZMaEFVbjNoSUp3Q04wSExuY3czN3FhRjJ6b1l2dUtOaXZtUUl1VU5jN0d2V3Q2c0hOczI2dHdBNnZoeXE4TkVNQUhseW50RnJEQ2NRZWh5YVBUbCtGd0FiWERjbUFLTVJUaGFrRWs4UThrUGc4U1BMMHF6TEJsK0E5UUNnUjZ1WkdzM3ZmSHo4VHRCWnZrZ0dRckVQQlZBVWcyU2lqNTBRQU9qaVZLSTNzYUFESlJtN2RTTFlXZlNGRGtDZW0vZGhaZU15OXBQWTVRdlNEWVF5VUpvRElLOHFNZXpoM3dZNmZTTDQ5UGNHZ0NBQThwU2NKTElnQVVZUUVtejhSUEExN1N0dkdvQnYzOVcyNGVSRWlCb05RU2dXTkkxSEJrZGd4SlN3MUFJK2RGSWJnT1lta2ppbVExcjZYWEMzckFiQ0h5Y0FneXRvaGY4dnNCL3IyS1JhUnE3enBaK0QzN0hNWDBzM0REY0NVR0xZYXc1M01KNFlVT0R6dXNxbEdDUUFPUUNlanV4QThVVUxVa3hJd0FtTUFwOFdhM3FrTi9SOVcrc0J3T2hJRVBqazVTTHI4SGVLRmJUUWZiNzdjc1BJTUhHbC80TVBiUmVzbFBoTmU0K01pVHBpOUFGR1Y0bkk3TWZ2YWdOUUxoL3BmclluREFTOGFKUTQyQTJ3NGVtMmNBeVdRVXVKVlFUR1dMczF1TDdERzlKMVJqaEEranZZazR0M0tYZU1xaWpwenJ1ZDRBdDl6M1h0UDE2eUdmaktabUNHb29ZaDF0Wnp2djh4WFBGbDRQb0pZQzk3azlGbHdaV0QrQXppL2RlTVpXZVAxM2VRQ0dFeW9FUnVkQ2hJamJiM21KWXdIN1YwUUlLdUN3ai9nZk1qMGFzbjJJMEZYUlNIWGZML2lSa05nTHllVmo4Y2NNWS8vSjFmeXh6VEFYVDIreG9RVmlLWUQvMWhEcUx4UGlZeFRnU3ZRcnBocGhHOTd0ejRTbHFhZm5qN3VrMWtJUURacnZXVHc4QjNqd0VXK1JMeFBnU2lDRVJkUHdQUjcrd0NQZy9ndWxGZ2ZydURrT01Ra0ZjNXg4NGU3MDhKQU1tQ3VSTkJYaTRUSWc1Q0dSekdpQkdFL0Q0RS9DMnIydmNBWUpvaWZ5NjJpMGFKU01oQisySUhvTnd1MGZrY2pRODVwdTNhY2s1bklCUkVxbmVZRnlXTGtBWElKSEVTZTAwQ3l4NVF5ZUw2Ri90eUVjRGNyT1cybjdmWDhkZjBtTUUrL3ZRL1BRamhveTNnem8zQUlTWWY4ME1RYVF4MXBlSDl3Yjd2Mm1ydG1DQmtJTU1lanAzaklKRDFNc2F4YU1aOHY1Ti82N0lOQXNCM0JBWVU0Skw0RFNvMUoxNUFGUEFFd3VRSFpKemtLZlVBdE9ITEpTT1FSV25kQllRdkNRQTAxY2ZuTm9wZnNhQ0phRDJiYUJuNzlRalNUaU9FUDFFY2F3SXBrcTJrZWdCVE5nSFdFcE9LRjhVd3EyTlJGUE00QXFDZjQ2L3JBMlU5L3VWRHZ1ckIwMXp2QUpwaWl3T2wzZkVlY2lDR0YrSWoxMWYrUWtiU2ZNUGZJenF3NTdtRUZaOURsM1BzNUhYV0FZQnlISkFKS1Y3TitzMGNDUVFod1NsZm00bEdaMEtCOEMvckFCZ1pVUzZaSElUQlNFaENvd1VZQUFrc0Y3Y1N0V1JFeXhSd3R1UHBPbGd3KzVzOXNxNk9hSUpJSWxVZ0VoQTFlZG9UZ0h4YTlIVnc1amliWk5GK2ovOXlHUUEvN3BidWpaNGJ3djIrY1dCNnRGbzBOellua3hGQStjdkVBbzQzVkJvRW8yZSs0OEVNWEVPbUQ5RjZ4aENFOFJ3WkVKODBWYmxLdkRsbXp3aWNmcXk5My9vKzhLOFR3QjJqVlNnVzEzOEZySlFUWEJObG5KZ21yalp3YW5vdzlDQlAvckw5d0YwandBR1dEdEZ5b045UEh1dG5JSFQwNW1QWHo5M2RNR1FBUG5pSnNqaUJYaVRieERaRk1GOU5MVVBReEtSNXFlenoxWTYvWVpESDBENkdrZEFrWUpJdlJhbEFkSEFNbVBab1loYjZOaERXdkV5Zi9tYTczN0NYTjdSMVpDN2hVYlBnY0ZncXQvWlpqQURuTTF4cUVWaFlCcGI0Q1VrNVVzTDdqUXZqLy8vNWJ1RHJMZUNPRWVEK1lRY2hZd0c5VklmeWcxTmFac3pGaUNINkRrUkdMemU1L2RnazhJTVdjTUNqZENpQ3pSOG9kMUI4T1R3dkpNOEpFU2hGdXQxZnpNaGkrZVJKcjZMSTdoWVAyTS94Vkx3S05vWmpVVHdSTUFRUW1ZeWhXR1F4c1NBRE9mbFo0a3VrajdQaFo3NWJFVGpCcGtBR2FoTWtjckdnd2hzWGVDeUJIQmoxd21PQlF3dkF3cUt6b0ZlUlY4WmFlcmpLWUF1aXJtUFkvbzlYN3E1Q3lyN2ZBdllNQWZ0Q1BHQUVvWWxCaVZ0RndManRwMlU0aXJqN3lPQU5iaStjckh5cmZDYlRxdUpWNDRPMEYxRnJ3UUdJTVpGcWRRRHlQL2dHU1o4VEMwWlJSc09sVnp6Z2FzZC91K3pwTUJ5TGVoQWZDZ01RQ0R5R1pKSEZDQ2dMWjJmOG1nSTVxYXVFY1Z4OWU1dkFDVGdDVHdFTVdyNVRkSXBXS0piNU12cm5vb2NEc3d2QVBBRzRWTEdnNlVLZXFtaTRpdUR6NGVyMzBvWDBGUDd1NW1vTXZJZjdXOEIrandsVU5BekZubFpDSWh2R0ZSQ2VXenJnWFNTSUJyZVhURlpTZ1ZMSEFwNFVIT0Z1b2NpRUVzbjJQSndsL1hFazBkemZTb2plZXJGZzFJT281QktBdmVJQmV4MVA2N2xnVXpnV1FhSndMQUtSSDA0aTE0SXRnREtFdEdzUm5XeDQ5YjJWa2s5d1VlZlRHcktDRjdSMEp4Wk1xeE44Y21QQXhXY0FjeEdBQktFQUtQQTV1OWxFYUFiQ21LTUkrc0ROMVgzeitybzI0d0VaRmMwVkVFNjRBQmdUMTgwUEY5WmRCY0RiNkpwcWNQdFBrKzFBQ2JtS2pKbmxsd3l1SUx1bkVBV2paSGtCc3JzUlVuZkQwcUVpQzVJSmZ5aXNnTWh6V2hjUDJPMTRSbzRXYkFTZ0FNUUo0OFNKd2NobUJDREZhOHFweUJiU1A3T3ZVNFBRMHAyVzcrTFNuU0pVRk9ySTRWN3c1SW9CVFFRVGZKNm9UU1lrMm1RY3BHUnlIMnN5R2pJRjZFTTNWL2ZNKytDMUNmd1VFeGhDc216Q2FRVDQzbFpDM2UxaEJwRUhoMzZYRXFyQjdTY21xNWRWMFhaeG1WOFd1REZ6QUY5aXdob3c5c2VBR29CY0d0S2pxQWMrMWw5ckxiLzFpZ2VzTzU1eXNtQ3JDOGVpNkl4Uk1BS1RXTkJpNlh3OTh4TlRGVWkwakVjbXBZZ1JBUGhkZHBWaTlPSUVQUDVjWUQ0Q2NMa0Nvb0hQd2FXOWtWK2l3V3JRSFQ4dUExZmQzRjdERnZnVUhVUDJrOGpUaW9nQXFMb3hGcERnYk1qOWpYU3VON2k5ZExJZGF4ekJwNVhWQk1JTWdGRW5GQVBLVDlxUGQ2QTlCSUdJN01mUG1mNFUrNDBIekk4bldncTJQQnhMNEZFa2pLSml4R1JSRnlRUVB6emQxaUFVekNBUWFzMVlPbUFFb0Zqd2tlY0RDL1BBd2hLdzZDeElrQ1h3T2RWSkx4VG9iTWpCZHlJZ2Z2aW1Odk5KN0V2ZjRqV3RkblJZRDFZTkdWdUc5M1ZXdVdzNEpmK21sWkNDWnh3UC9jbko2bVhWS2syK3RLOGxRUVZIUlRHYzY0U0RBWkIzRXkzSmN4eUFDa1RvSng0d0hsK1l3cWxvR0RJQ21ZbVRGZ01RRkJFVDh5eVl6eUFHL0FmV1g4bUNHUWcwQlRSb0h3dDlLVmFQRS9IUTg5MEFJZmdXSytDUkFhTVJZblZkeEhiaGRZOFdzbHcxVjkzVURzbVBJajlHeGdpQWlvUlJNSUpOdm90aStTVy9Ja2QwZ3dBVTgrWHhKY2JHSVRKUER2STZYZENGUkVGU2tuVEI4M3hrYTQwSDFQR0Y5ZG55Y0N4Rnd5Z2tLMGJBU0pRU1ZBYkFZZUQ5OHhVQWU1VTNqS0l3Qm9zU2dOc3VBQllvZ2wzL0l3Z0ZQck9JZzFYYzRacnBBc1NydnJ1eWtsMnVjeWthcGtNTWg0Q0V4RDVEd0pmV0FZQXh3azRNS1BBSmdPSWpHU0VHd3VDYWtSaGVtdzZZdjBVVXdSZjdMMDBMOXBuc054NlF4NGZlWTRPOHBERWNpeE9qc29US0twTVlqU0ZZWWpPQzhFcTNXbm5yMFlZUyswVG1pMkh5c3JQR0xxd0FTTll6Qm5UMk16MlFEOTFsYXhMQjBnczEyR0FoODFjZi9vL09jSHlKK3FqMFMvenhuaFVaYlN5WVdhTDgrUnEyUzI5d293aVdrSlBhbjRNdmdyRERHQWxSZTdLSXl3RElnUjNtZUVEV2c5SGJKZ0FwTlRrWG84bzBpN29WZ3huRWdGcjhGN2pFZG5VNUd2cWZKUUtRS3lFT1Bsc05JUXZ5dnVwQUdIUy9Pa3Y0cXY5b2grUEh4TUxrOGdnQkNSeHZBbUVOK0FpRXp6MmlRZlFCZU5ta2g0SzUyaEpCS09hTmUvRlNMb2JMUlhDejQzclFudTJ5aTlvTVNNRHhzMmpvODMwM0VSejF3c0NHWkVDRjRrZDNEd0VZWXdKamhvTmxRcmdJamxZb2RiQlByd01BWmZFbXl6Y0l2MjdnczZYRHpDL0lSMURPZ0E5YTZEUno0d1pBc1orTFlYdlFZc0hvRDR6aU9Ga2xuYTZZRDMrbm5VNmRaN2JHREFjQlVJbUlBbUVVdy96YkoxaS9zY0dOREppTFhtbGUzUmhRK2wvYXE1N2dVUUNXend3QktQZUxzWi9MRnJHZy9TaFJYQWU2NEFqa3YzMGtBTEFqRjhSMTFEeTNLN0tSd0pjc1VUYXFXU2NBUm91M3cvSU5WbkNIK0EzNm44UnZNM25CNVhQNG9ENkRBVEJZd0diNWFqbE9MT2g2WDhKYUJLUkc3Nys3eWdHWXAxYm4rVjI1LzAxQXpCbndRMXlwYW5EN0tXZkExUURZQzN6SklqN0tnT1V6YzluRmJldFgvcitPNWJpd05oeVg1dVNFRHI1bzB4c0p3THA4L200QTdHYUpVdi9qMy81K0hRRllKM29GUFBraG8vaE5lcUJjTWtjQjJCQUE2WHJ4bU1Ca2ZGQWNpL20wSnB3elh3MFRYdlh0enJ6K1BLYy9NbC91Z3pNOU1EcUNBYnova2VWampHY1FBL1lMdmpvZ3VvMW1Sc2xSSTZSd2ZzaUE1bnFoTDVENm5zY0Y4Z2ZUZGZ4cFMrL2hMenZXZnpNUUNvQjFGcS84YjNWV2FQSURacXNSVjY0REFMc1pIVkhzMWdFdnNxRkFlQlNBcFFDOHBISzkwT3FsNFVFQXl2Q3dOZUdjQlhOTE9QTUxmdGdac0k3NW91VXI5b3VzcDJURXlJSi9zVTRBekMxZStXSUZzaHlBSFBaUkVWd0l0cnJEM3dHQWhpYlRZQmh4VnBlL3hlUHlyTkJ1V2FvTnAzRGdGd0M4MU8rUkFlcEsvYTVMZmU1MWp4cjdKd0E4M25QWFlncTFhc2wweVg1TjQ4K2Y0VkVHTEFUbEsxdkFvNVlCMWdCU1Jtc00rTkZFNTdsY2ZQRDVwUEZXQ0pJbXR5dkdnR2ZPQWFjQllPNTl6RmdsZ0hnUGVmWnNYVjYvZ1BYQlllQzBSVmd5Sk5PR1l1SmpQa2E5ZUhXZ2pMOWJXemhXazAvbi93UG4razhiZ0ZObWdZY3NWZmxabkJSbUlTaHRKTS9tN0pHaWJHQm9PSUllejl3S1BQNEFjTnB5bGZiTmxHZmRJKzlOakJqejhKVnpwcGNrWnVKK2RCdzRhUTQ0ZHJrNmoxTElZOUprUEQ3UDRzMmx3VkVHTEh3Sm5uY3NjTkloNE5oNVlNc1NzSG01bmRPdTFCR0ZUaEo4L0s2SnJadG9zbFNUMitYSEE2ZnRCMDVaQUU1Y3JnQXVwczVUZmFMNkVGK1V5SWlmM2dBY093dHNYZXA4MmVJWVk5SmtYcE1nTXAvQWVaUUJDMmI4T2R1Qll3OEMyK2FBTFF2QVJnSndHWmhZN3N3RXpiTmE4OElSdkFWTzFxa0Y5MUozNkROT0JFN2VEMnlmQjQ1ZnFwaExuZXZ6ZEdlQktCZkw4VVg1L0NaZ3l5eXdlUkhZc0Z3eFlIelJOSzZvZXRTQk1ETGpVUUFXVFBxUG5ncHNuUUsyemdLYkNNQWxZTU1TTUU0QUxyY25SNkpZUUl3c29VbmpwRFJzdE9MeTdjQkpCNENIVUd3dUF0dVcyblVEVkgxRUZVaHljU3dXakdENjRtWmcweHl3Y2FFQ29JMHo1UDNYNVA2bldsSGRnSGdVZ0FVQWZPWU9ZTXRCWU5Nc3NIRWUyTGdJVEJDQURrSXpTSlpYcENPbklnMjV1UHJoZ251cE8vVHlod0xISHdTT213VzJMVlNpazJwQ3JEc1Fza3pOSUJHSXBCZEdJK1ZmTmdNYjVvRU5DeFg0eVBSalBqNHhhSjArV0dlRUhSWEJEVXoyTXg0RmJEb0liSnlwQURpeFVBRnd6QUZJOEtVSkNoTVYyU1VhQUdjMWNFL3hGSmVmM0ZZUnRpNjRua3FXRHJxcUVoYnJzbTV6dlpDZFBDZDhuSHpKT0xadUFCUno5aFRIWndQTDdMbkxub05NSVkyVnlhS2NqdFpMSE9BYk5nTlBuZ0tlNEJhY2ZHRjFwbnlkRCtocGhRLzhYVjVVaUV1ZUxHbkROMXRXWGovMy80Y1R3QVV6d0dQY1JjRkppRHBQdDNGTG1mNXZqd0UySEFRMnpQckV6RHY3T1FnNU9TTStTY1lReTVYYm84NDY1dS9aZkxUSjdmS0hBZHVtS3hWaDh3S3dlYWxTRTZpbkVvU3kyTVdDZGJVSElnaHYzQXFNendIamk5VkxadUR6RDhjWHh4V1pzNWM3YXBtVzBmTUJuSUhLbjVYN2Q2STVucHZSejk0TzdMZ1h1R0lSZUpTYitYbDF0enFmbHlid1J3cWY5aTk3QlFSV29tV0pRN29aVkZ0Sm9xRFgvYi9vR09Ec3ZjQlRBVEI5Z3NmR3FtemRqdFZ6K0crUEF5YW1nWW1aQ29EakZFMmFuQ1ZnMUNlSndPTW5UUkIvRG1VSU5Wa2tnaWEzeTA4QnRrd0RXK1lxQUZKRk1EMVZBQXc2WEc2MVIzMU85L2ZkcmNEWVBERG1ZMHpqYzFVaml2QnVBTXgxUWRNQitXQVlYVThkaEVVMTZkT1NrcHBiY0hGU3JuZzhNSHduc0dNUGNONXlwVVJIcDJ4TUlhN3pEejJ6OEduL2tWZTBZb21PMHdFd0JZS3VqTDd2L3pIQTZDM0F4Zk9WaDU4ZzVBc1p4eDRmWk03c2YzaDZCY0R4V1dlR0JaK2NNRUZpd0dFSEhSbkR6dW43T05Icy9kamtSZ0J1bnFsMFZET1NISURVM2N4U0Q0YUVhamhGWFM0SDRTMWJnVkdOMFY4d2U3RTBGaDlqVkRHNk9icjFMSk1Sd24ra09DYVRFWVQwZHNmcVpIWGwvcDdQckxpOXdJWTdnTzBIMnlBZ0NBV0NXQ293S3JZRThuTUxuL2E3UFFuOVg3eklKUFBrQ2NLKzc1OHk3eDdndU5zQjZsOThnWmpMTFlldDNBeTVuMHN2NFIrZkNZeFBBMk1Pd0xFQVFMSURQeVA4dUJnMmNSWW16RndlQVlpbEtrbitPQzgvRmRoMENOaEVBNG5HQTQwa2Q2RkVTMTNXTE84djFxSEtBZmg5QitEb1lqVTJBay9qcy84TkFJd2c3T1ViN0xDQytXQWZCNENwQkpvSWlUUk5SbVMxbDEza3FXaDNBZHYyQThjZHFxcDFNQithSU9TeFd2NnBxNUQya2tJQXZ0OHJGN0JMSmtzTi9qTXFmYTd2KzcvQWs0QjNBNmNlcXBhc0tNcTVha0FtbExXWTM3dDhaVzk3UERCMnFBTGcyQnhnQUZ3QU5FR2NuSTVKY3JEWlJQbGthWEw0dTFLSlVBZkFqYlRRNTl4NmRTdmRMUFhBZ0dZc2haV1I2SklSYVhCL053Rkk4QzFXd0xNWHpNZVN3TGZjWHVLckEyRyt3ckxDRGNOL0lJZzRFUlJuMHF2eXlTQVFYNm1HMVh1QTRmdUFiVE9Wd2t0UlJyMk1MQ29ReXZFWi9VWS9Xd2pBajNqdEZKWmtVNzlnMWdoa2dFQmY5OCswVW1iLzNBMk0zbGtCbC9mT2NkTW9rMkVqa1p5djg3NzNMQWZnSERES2p3Tnd4RVV3OXlhaWxwd2R4QkFFWWhCYkF1R3pHM2FLa1FFSndBa0NrT0NqbGI3WTZTWXlmMlV3bEFTK3ZLWW5BWGpmTm1ERVg3REVmQTVDalVjc256dmJ1MW5EdFVNbUNEa1JaRUV5R2RsQWs2RzZsUVRTYTZtME1QNkh1WTczQXhOVGxjSkxaNldPSllDNS9DTnhMcEhNZ2RLSUtObDY5UXZ1Ni83NUFqSE9pVFU4N2dLT09WaUpiNzQ4QktDV3JuSy9tYVRBKzU4QWpNMEFvN1BBNkx4L3hCQXVwb1lEQzlva0JSQW1QZEJaNDdsTkEvRGh3TVJzeFg3bVBnbCtTcm1LNUVhUk5Sc2xYRlE5Q0tCOURrQURuNzljWnRrSEZreXNKMTAzZUJicWxoOTdEcG1UUVRZZ2s5Vk54dSt4WWJYS1UzbGhGb0pQT2dkRkdZK2xQa2dReG9ra2dGOVhnajRBdmZvRnM4NGVYNEtlOXg5ZklDK3RSZkR4dnZuaWlmMzU4c1NpcjJMQ2o1d05qQktBYzhDSWkyQXh4TEN6SUFHWTlMN0FoR0lLZ3BBVHc0bDh3VG9CMEpqUHJmVGtwK1NMUWJIck9xbTVqTnlhalM2VkNNSXBBcERBV3dRNExyR2dYcXpJZm5xNWN2MHZOMFpYSFRJbk1FNUdCTkxiMURHZE9ZUXNJN0FmR0tGamxncXZlOHdKd0c0VCtmdUZBRnl0WHpDTGIrVmdXbkgvZklHWWZjNDZIczdpSEM4WmtQY2RYeDRWZlZYSnc4K2NBNHdJZ002QUhTTEtXWkNURVNmTGZnN1dzSXlSRjNja2lSUStIQUNYa3dIcHR5UDRLSHJwSnZLVkduT2hSRjllQkY5d0UwbVVFb2d6MndDK1dHSS92VnhpUVFJeEFzOStybUhBNkUxWUZZQjhESndRTVpsME9yTForK2k3c2ZUOHpyb1lITFM5ZGY0UkFDV0t4U1p2TFh6Ry9mUUxacWsyZ3FuMi92VUNVUTlVWmFNOXdEYVBlU1ByQzRBNUMxS1YrTklUS3dDUy9TaUNSL2pSQkRsTG1QN25IeW5zeG5vMUlQd0pTeVJwYmlNQURYenVQRFlmWmZCVEVvQW1jdVZRZGlhVzB6d1h3UXNDWURZbU1hREExd0c4VEJTdmFvUjBHNzdFY0dTRVQ2aGpPdlZBcGZSUEFVTjB6anI0NUp6VmNTcWlUeEQrVmVHelhrdS80TnI3SndESk9reEZJd3Q2ajYrUnFVcmxrTzRiWHpwMWdDQUF2MDRBemdMRERzQmhLdWdMRlV2UVVoVHdDRUtibktDdzE0SHdKOWNEZ0dROVdlZ1JnREk4WEVjVkVEdkFsN2xWbGdsQWdpK0k0Q1IrWmYxbUxHZ01tREZoQkdGZkRDaWNSSkZFUnZpU0FCakxTN0ZDME1GS01VKzA3d09QRTBrR3Zhb1FnR3Z0Rjl6MS9pT0Rrd24zVldvRVh4cmVzNWliOXh4MXdadWZCQXdMZ0FRZXhiQUQwSmlRd0pPdUpCQTY4L0gzWmhrNiszQ2lmcXF3V05NS044d2pLZ2JrNmdXSmdDK0ZNYUJiNXZKVm1zVWJWMnZDcW8zY1JXWmNDSUFDb2F4NTMrdWxrcU5kN2lxT2NVMVdjQzljeEVtNWtRQlVkWitzVG5TTC9qRXRUV25naTIxamhKTkpCaXZaQnVrWHZPTCt5WUJrY09xeEtqSjRBR2d4ek1yQlZ3ZEFNbUhyWk9BWUYybDZ5L213VjZ4RDE3em1XbzZNYlJ5ZVd0T0h3eEo5MUlJaHI2cnFaUzcwRFBQTFhEVlVyZkJ3ekhLcjFFVXA2L2gwVC82TC9HY0Nxc2x0NElob1Rjd2RBcURTczdJNjBXUUg2UjMyOXBIdUZ5dVhESm1FanVPU2JkQit3U3Z1UDViR1VqbXNBNVhvVXZjdkJYS0tBUW5BcFVkWHdhaDBiOGpYUjJZekpUc0MwWkhCMzNGTCsyeWlYM2gvMVllRDFmRlpHVDgxZy9INnlxa1ZhOVlFcHFNaFRBRGxlOGVySEE2dDdNaDZqNFpCWGRCR2pGeU80Q1NJbTl3R0JpQnZncXh3SUFKUWxYSXlFSkx5SS9pMFNrQUcvRmJoYUVyNkJYZmN2KzVkTEtoQ2c0ejFDMUhFQko4K0JPRFFHWlhmay9xdUFaQzZrZXRBWkVRQ1RXQVU4UElKdDBmZ3dIelp2VldOYUtxaTdKTE9tdERXRnk0MmcxRnhIL1hmcUdrSUkwQythMHRuRGtmc0d4UWpuM1ZQc2s3dFhtdXkrWHAwSmh0b0pvc0FhRmNVQUpVWUtpWUp4Y3FIcUtBSDlyUGxHMmNNcm1DVWJNWDlndU1McEdUY0NNS0RsWkdoTUs4SVBuUEluMVg1UEEyQXdlZ3dFRVltREdCTWpPSTV3aEdRUDNOUEJUN1ZKbFJOYUt2RjR0MklXSGJERXJ0RGxTazFwNGxKNy96ZDI0NnRnbEdacnlJZnJGaFE3cFU4V0NBWDBaRU5HKzU3VTE0WjRZckNlTHJTeFhkZXY2VGZMd3JieFQ3em5NcmZLUVhmSExRQ255dm1SSXYwUTM0MzBlek1tTDk4UDM5M0czd3F6NmFtMU5ZenpvR24rc3ZxUm1UQVUyY2l0Y3RxQVgvMkVJOEY5QUNFbUxIWExaR29GeHRTbDJ4eUsyYkFZd3JqNlhyMTIrMW5vTC9qVVRDRDl2dkZybjZ1MHYxL252R2thb1ZCQVFpMGV1bW1NQXVYUUhNV0pBQTdnQ2l4RzhVMGdGZmNYZGxCS2s0WjZ6RUxnQUpmWkVLcnhwQzF4T0lsLytTazdqa2NkWWxTY285MHk5K2dLNnZKclJpQUREMHBpYWQ3UnVGbzN1ZE5DZ2Z0OTR2Q2RyR1huK3R1amdWM1FBY0hMY0Zucm9lbGl2SGtjaEVMOHVlMHVRNzRTM2V1YkFJVFMzSVFoS2tNUmpCTW9rZ1dHM0wvLzJ6M1ZTblA0VkRnUVd4VUVFVXhBWkZITDBlUjNIRGZtM0lSYkRIa0JmRjB6eTRFSUtOaFN2cjlnb0dFQmR2VHovTUlZUUxRZFZzVHdSVEZEajVqUW1kQXJSRFlKUU5EU3M5NjFSM3RQaHg1TlhvVmdveGxlSG5hcmpvaGdMZWMzRDJISTQ5MnlRTnZJd3ZxTzlmSm05ektHYkF3bnU2RmhhUDVwRnVNZy9iN3RUYnBCZHZUejY4Y3ovekk4YXpWajhpQUhUcWdtRkhYRFVCODlSMmR0YUM3dFVHdzRrRE9nRmIwUjJ3WVJER1o4ZzlPOGFVNFh3UE9jemhpd0dsTWpxcUxXaUZZR3U1NzB3QURGc2JUdmF4Zzhua293N0U4bk0vYXRmS3psbjYvMW1TNFlIdjZCUTQrWjBCYnFIY2QwTnd3WWJWRDMrMXlXaFhKeFBCcmJxOEFxRS9YQXBTcUF4aUJWMk1aLzU0RE1PWndLRTAwcm5EVVdjUjVLaVYvYnJqdFNBTUFMSXluKy9tQ3llZWhqSVlwNmZkcnZWRUx0aDhSQUNseUhYeG1oUGk2cjFtOEZNMHVjZ2s4K3k0UkhDMWtBSy81WGdXKzJoWllvZmFmV2NQcTFCNUFxRHFFWXNRM25lcFIyZ3FoVjJ5aW9sMUNPa0QwQythT2FvR3g0YUw3RFFDd01KN3VWd29tbjRmbTdWclgydS9YQWxFTHRoKzVzSFB0TitsL0FwNnNYMmRDc1ovcGhaa0lKZ3Y5bCsrMXdiY3ErMldGdjJOWElqTktBUHp1dzdNVUFWOERUdXluRklFc1F5ODNSZ1RBaGl2K05nQkFCYVFPR0UvM213V1RMd0FxSG5hUWZyOUdud1ViQVJnRE5CVWxrcHpRYm95WUN5WURZZElMZGYwbDROZHVXOWtHb2E0Z2VOZGF6TEVsS29BM1ByeDdEb2ZpRVR0QzZYdkU3aEdFekpscGNpczNRZ3JqNmQ1VU9Kb1lEY01nbHJYMit5ME5QdGw1VVpVamtmeC9IcWJlY29lME9aemRGMWdIUXJsbjlCaGVlNHMzZjNaeG00TXZBazlWU0ZkVUl3MGkrUTJQYUJ0SVNpQlNTRmdDWU1qTVcwME1QN3B3dnZMRG13RmdRVHpkSHhjT1NHdkJnL2I3WlJaQnlXWUFsT0VSbHVLTTNSYTlDS1djMHE3M2RUQmhNRlQ0WndJdzlsNUxycGVzK0hqZUJpR0NVT0tYZXVCdlBjS1RpRUlPUjBmK1JoREJNWWkwTGhlYTRHVGFhNU5iT1FBVkR6aGdQQjFMYTVSc3NWM3JJUDErN3l5NU9BQURvQWNoRUhCa0ZiS2ZHUnBpd2VBUHRNczVJRk5va3lPR2svN3JBWUM5T2hCRndOWFZZMWF0NXRmdENCSGFXVlMyQUpkRWNFaW5yRE5DK0x1bWl5YzFCOEFCNCttdUxBUkFYVERDV3ZyOTNsUjQvWjBYdDZPREZRa2o4V3R1bUV3SFRLRExRZWpBZk4zdWRzL2Rmam9RZGF0R0x4YjhqUUJBWXo2L2JveGlGZ0FWdWR6TkljMi9zM3hMazFzekFPUm9CNHluKzJEaGFBVEFHSkN0YnBrQ1lxOSt2NFYrYUJnQVE0aTY2WHRhQzg1WWtEb2cvemRadnpVZ2ZOMU43YTYzM1hxdjZmZTltc0RJSGZOYUI2QXkySlJFMUFIQUVESWZJNW56WkNMZU40TmJtOXlhQStDQThYU3N1bDZ5cVYwckoyV1FmcitzcGxDeUNZQlIvSEp5S1g0cGhzMFBLQlowbHFPWVRwdm5pQWlVQW1BZCtIS2pvMWN2RGpIZ3IrM3dQSlFzVkN5bVVaclBNdVJzUkJERzRBUUNzdW55SnRGR0h3QUFJQUJKUkVGVWNjMEJVSmx4UW9INjJxOFNUOGNnZ3BLTkFGUkd3Q0Q5Zmt1dmJ3QWt5R2dKRTNDK056MVAxcTkvVDNGMUVaQnh2Wmg1MHM2QUVZQzV5eVVIWHQ1L1E4ekk1L0tyQW1BSWtraXBreUdQWXdYejFhUlQ4djVaTzZqSnJSeUF2S092TlhsTGF6c1hzOWJvL3p0YzI5UG9oZ290cDVKNDlSY2ovcHpmSXdHUy8vM09NNENOZDFkcG50UXBGVW1qRUg0TFlJZ255bi9PTGpMOEZlREdod0piTmdGakk4RElFREE4QkF5MVBGSzdGU0tmNDNjTktydkh4KzhDL3ZteHdNZ21ZSGdFYUEzNUowU3RwdnZ6TC9uUDhSYkxBZmh5VDIwN1RDaGdEUml1L1pMOURzZldOQUJ2WXpiaENEQktvQkFrL3BFb2JHV1RxcDgxOWh6UTEvMGswUG9hTURFSmJKanhWWkZnRGFkMFNhVU81TGtzV1ZqK1hTY0RtdzVVRVVESjZVNGQwblZiQzkxUzNvdmZWSHA1YWw2NGNnQytrN21aQVA3NjhLQ0EwV0QzQS9pZUx6MDkwQ0RjZVZtbEF1aEJsakxncmZjQXc2UEF5REF3UEZ3QmtDQWJJdE00YS9GaU50RVJqQmw3Nlc5ZmZEMkFid0pEZHdGais2c3lJbVJYcmQ1WTJGaklZY256V1BMRXFuc2ZDMHpzcjZxQk1RbWZJRFIvcHlKNnhNaEt5TXJTRGlLRDJ4amE2VEFEVHQwL0FHQXMxS2NBVUNGck9MRjZ0YnRpUlZGYXZUL3d1TUNhN01mVlRsSDA5OFlCZUJjd05BSU1FWUFVbFM0dUJVTE9tSzNMQ253T1BBTmxFSU9Tb0Y5K0M0RHZWb1dYaHZkV1pWT1lxV2dpM3ZPWERVUWhnaWVCMEVFbFZpTVlKMDhIeHFlcW5HOEQ0SUlEa0F6bzUxREtRUUp2QktVbUtBQ3piTTQrNWhVaXZ3cmdpd0M0THp2am1nQ2g2bkJjZ2lNVGN2OUFibzBEOEU2ZzVlQ2pmcFVBNkF4b1FJemdpOEFMbVd3QzR6Ly9EeGNQUHdCYWs4RFFGREI4eUpQcFBaSGVHQ3lDMEtONURGQ0J5Zmg5LytPQXNla0tnRXpDVHdEMDQ3WDBTQ1BNMUlZUWpDdjJFL01Kb0dWd1VVUW9QYm9xME1kcWtXVm43UnRERE1haEI0ZytQNnFoWEZwalZ0a0R0UkdBMm5Lam9zN0l5T3lIRlViSXJYZTBGWHNUdXpJWWZOYjRPMk0zQVRHSVlRT21QbjZoRzZnaTNlVWtRUUFlQUlZT0FVT3pBTE1WaDJwQWxFU3FHRkJBWEFZT01RVmp4bGwwM2lPL3lZS1JBVDBGUVhrd1pranAxcHo1MUxPMlhBVDNLdEQzQUlBd2o0V2cwNWtmaXVVSFlsc1hBSkxWblAwSU5MTTBPWUZ4NzhBemNSeVNlVHN3MkFKdWVJK0RqMkZuZTRFV0t6NU1BME16RGtDQ2tBQnlVV3FzSnphckVhbnpqMnpYd2pFR0ZIdUdZK3BZc01vanpaTDFHOUVCZXhYb3UzMzlJUkJyQzNsSkdtTkR1U0hYK3c3V0M0Q202d1d4bThEbmdMVEltZ0M4cEJjR0J1VFhmLzFmWG55VHVnbkZ3eFRRT2dpMENFQ3lJRmxzdnZKZkVuaDBtaHNZSS9zNXV4RllpMXhab2Y3b09xU0Fhd3dZalJHQnpZR1hidFdYYUNJcmx2SFVhZ1g2U1AvcnVNVllDRWJFcUVDWEFNamZyZWUySGdBMEVTdXIxLzB2dG5Od0dTc0cwUnNaTUUyMC8rL1hXSDZNdWdrL3luZ1BBR3k1R0RZQUxqaUlISWdSVUlyc1pqTTdBeCtCU3gxUzRwZmZmUVZJZXA4ZEw3ZE1Ec1RHakpCK0N2UXhUSG1kdHJ3NGwwQ292RnJ1QzJOT2U5NzVlZ0RRc0NYUksvZUs2MzRKaEJLOTBxMkM3STFpK0d0MGp4RjQwazFjUEpBQjdVUDJtM01HSkFBRlFyR2VpOWlVVEg5eUJVRFRIZlUzQjUrQk9JS1E0M0JXdE50UGNXSU96RVpFOEZvSzlLMERDR054TGkzRnFhS0E5Z1RnZW9Gd1BRQW9JME91bFdUMTFvRXdpRno3Y3diRXJ6TnhXdEVZQkIrVlk3NlZoNERXckg4SU9vR1E3T2NnMUNxTVJMUGx0bXh2czEvU0hhUDRkY0FKZVBZeXlVQ1JJenJUQjh0RThGb0w5RFVNd2w2MWtRUTg3Um15MlBTMnJnQjBhMWNpMThSdWRFSkg1N09zWTAyeS8rODMvc1pkQktyNEZYUVRBcEJ2cHJHZ1FDZzlVRUFNK2g5RjZ1Z0pEa0MzZ0pQQkV2UkdyWW9ZQ0JYOUl4RWNTNUs0aTZjWkFISXc4b1hRNG1MQmIzNVlINWQ3T2VrYWR0VFYxVVpTamFFSVBING5RellOd2dqQUhOd0R1V0dZcFpjN2x6UGZYMWNRdXI1b0JvcmZ6RGYremkweVZUdVNrdXhCSTJRK1BoUURJVUVuTUxvMVRCQ1pMdWZHdy9peGJRYTBLQjhDVE9EalBvaGRZNzhJUW1mRGptVzdZby9kb0FYNkdxSWlBdERIYVlzd1NtZU11YlY4MWtwMTFMNmh5MlBkQWNnYmxmc2xPS0MxSWlLUm15UnhaZ1YvOCsrRFM4QkZyeFhpNUhkL1U2TWVTS2RxRXNFS2hwQlJzZ1JNYkF0dUc0S1UvKzlyeTVicnpQL2xQVk12MUVQT1FlZ2hhcnJWY2daVWhWSEZ4TlBjcDlWRnRsT1drTDQzN0MwV0FCV3lwRlJHc1Ywc2I1SG4yellCd3ZVR29LbDEwdjFrbkRnbzB5N1hBOFBmdjBVQUNuamFLMzNDbzlnSlFBT2U2NEZrTnZ0WkFIUWRqejl2Mk56MkdTYTNqWWVqMlczS0d1WjlpeEdkSVZTb0tUMTNCMnM1QUhrR2hlU1Q2cW4wZXJIdjVBSWdBQVUrTFZmdy93cTNDRUFWN2NsQktEREdaRzkvNW9WWHgvb3lZQVJjemNxSDVHeUg4ZUZwbFRhd0Z2QXRydFhMR3BOclFER2JlanVwQjNvbWxJSFFHYy9FcnpPY0dTUnM4enJoQWJidUwxVGNvL0pmYkxsTndIT21pMmtJY3Mzb3diZHdOcFl0eW5EUWhzRmNndnVHOS9ZYXBHRnZZWDIyelpjQVUwL0d3QTJMSi80QW1HRjltd0ViQnU5OFkzY01GK3VBR1FDajJIVnAzQmJQdW8zSWxxeEF5NXdIQXE0T2ZBUm1FQlhHZk5JQmEwQklzRzBlY3dDNjdtZXJIZ1JwWkx3b2NyV2FvdnVUeGV3L1YwdHhKUTJEV2VhZTNXQUdiZGhiMkRCNCt3Unc3dzVnOFFwdjg4bGl5R3RvV0h6TWk0QzlmQUVIYkJpOGt3VUt1MnhOQWRCeGFHQkxiSmRadXgxTHdBR0VDWUFFbTZ3eWZwZWxKckVnRm5SRHhFU3dneVV4SVVzVk13alZ5NUFZTzBiRzg5QXV1MS81QkYzOEtxakJIbFVBWVhzdGVOQ0d3VGVXTnV3dGs0Sk1rcmx6R05pekExaG02OWcxTml4K3pET0JXMGFCZVJaWkdxQmg4TTRlbWZXTkFERFQrenFNalF5RVNkUUZIZkRiWkVDQ0xSZ2RIZUNUZThDQmFLSlkxckRuQlJDSUF1R1c0VFlBWmVGRzhadU1rR2lRMUlFd0dDSnRIWkJteTFvYkJzdlZNbkREM2pJQWVydGkzTEVCT01qR2NPcGEzV2ZENGljOXQ2b3ZlRHRMZnc3UU1Iam5INndQQXliVzZ5YUc0KzhENEhJUWZ2dERJVnRMZWpwQkZzVnZVSTdOSUJIdzNEVWpSekwzckRWdHNZUE9rQVNjdVgzY29ORHluVDJWWUpDa24rUGpxdlVEOGhWYlM4TmdqcGhHeGNBTmU4c0FHTm9WWS84MjRCQ0J0SWFHeFJlOHBMS1pkcE1rVHZYaUoydG9HSHpTTkhEUFNjQXlxM2VyNHFQeUdhTmM3SkNSWFdMVDJUandHbUNPZVFhc2hxNitxU3BabXA4dm9qUXBoZUY1OG5jZFpWakxualdQSHI0VldLVEt4ckhHVXFxOTdxWHUzanAwd1B5K2VFQy9EWU5ac1pBTzZJRWI5cFk5bE5DdUdQY05WODMwWm1rTTlkbXcrT0tmYmRjWHZKTVBkWTBOZzAvN0duRFhLY0RNY2NCUzdNd2RLejhLQ0FLUUlnWTBNV0dDdHI0VE9IQWFzTXdPa1RxZjZ1bnl1THlrZmQyNTRua2I3cXN3L2lWZzdqaGdtU1gzMVZwZDl5UkhlTHgrelJoakVHUmJCNndEWVQ4TmR5bXl1YnpEekNDR2ZwTUpXZlNSWWZyOUhQL2FNZ0JtN1lveE5RSE1iUUhtK0lENmFGaDh5UzkzdEF2R1FiN2RhMmdZZlBvWGdidFBBcWFQQSthM0FFdWJnR1UxUk02QjA2MGZna1JvQ3pqK1RjRCswNENGRTRCbGRaZFJjNC9ZeGx4Z2pKTWV3U2l3TjF6V2ZzT25nZGxqcTNFbVkwOHZtNWkvN2o1eUlNcXB2dXBLeUdvTmc5bG5nWW9zbDl3WS8wZFpkck16WWw4TmU4c0FXTk91Mk1BM3p3L0YyQ29OaXk5OVhidmZ0cmNMcml6NlBoc0duM1U5Y005eE1PRE9iUVlXQ01BTndQSjQ5VWxpdVc2U2FxcUJuL2dHWVA4cHdQeUp3Tkl4d0RLNzZhaERlTjZ1WFlDdVl5QUJrRXphNExicFk1V0VXZFNMeGpGMjYvZFFCMFNKNnI0QnlBTjZOUXhta1djcXJuUTAweDFERURKRmpSOENjTldHdldWUHA2WmRNUTZPVk9DYjN3QXNjUEo2TkN5KzdQZXJrUDVRM3RCWTFQclQ5dEV3K0p3YmdQdTJBbE5iZ1ZrQ2NDT3d0QUZZY2dBdWl3V2xNL1hxRGpNRWJQOXQ0TUIyWU81NFlKRk1vLzVnSEljQUxWMVRSWjE3RlhPaFB0dmd0dmtxZjlINGt2SERseUtLNGw2Vnp2VlNCRjIydXdqT2I3cGJ3K0NmY3dCU2t5ZUZFSEFVeC95dzlKVHlFYm8yN0MxN09sM2FGV051QWxnSW45UXhPMnRZZk5sYks2TXZheGVNUllxdXZMOXJUY1BnSjMwVHVIOExjSEF6TU91Z1gzUUFMbzIxV1hCWkxFSHdSRjFPZ0hTMmVPZ2JnSVBIQTdQSEFlek51N1FGV0ZaN0puWEo1cm5xeEhFdWx2bHp3eVZOTjMrd2VybjVZb3ZsN1NYTEd3dm40cmlMV080ZmdNUkpYY1BkLytwbU95bUVMRWhSekJ4SkFvOWdWTDRrd1ZuYnNMY2NnSEVwV2kzZXBvY0NBTWVCUlU1ZVRjUGl5LzZxdGwwd3B2aEErMmdZZk83TndPUW00T0JHWUdhRHMrNUV4WURHZ3FQK2NjQWtJTmFWcEI4R1R2NGQ0T0J4d053MllHRnJ4WUNtVjBZeExOWWhlQ1hhdTdFaFYzZ2EzTGI4ZzQrUjQ1dW9HTEFEZ0hXcWhzQlhBOEsxQVpBRHlSdnV2dGtCU0FyaCtpOURzUWhDT3RmMFVVZ1cvN2FpWVcvWjArblJyaGl6b3hYd0ZoeUFpNXk0ckdIeFU2NnFBRmhUM3JEU0lWZHBHSHplbmNEZWpjREJEY0RzQkRCUDF1WDFDTUpSd0ZpUUlCenhpZUwzS0lZMVlXNU1QT3hOd0xSYjhnczBhZ2hBc3MxR1oxTytTRkhzZFJQdDBpL1BMSHUrK2RGYi94NG1YZmhjYld4aGZDdFlNRnIvdVd2S3hmRGFBY2c3aXBQQ3ZGT1ZwdW8zSHJDallXL1pBK3JScnRpNlRTNk1WUStMNE5QSDJueDY5OEduWEYwQnNLYThJYWI0ZEZacEdIeitKTEJ2QXBpZXFBQTRKOENQT1F1T0JCQU9WMENVWWJJc2tSa0FlY3J2QWROYlhjL2FEQ3hTcHlUNENFSXlUZ1JnbmVpTElwM25QNmZzK2E0QTROOEI4LzQ4Q1VDK1pHSkEyOWZwdUxteEpXKzVoNWtORmcyamlXSFNpMHIwVXY0cENvWnN4dzhEVWZuaGQ0VmswWEdkR3ZhV1BhQlYyaFZqZGpnQTBCbHBrUS9LOWJtbi9IT1ZxdENsdktFQnFsZkQ0QXRtZ1AzakRzQnhCNkRBN3RkYmN2WXpKdlFKa2lpMm40Tk9lTXBiZ0prdGJZUEdBQ2lGM3dGb0V4MVpNTmUvNGpuUExYdStLd0Q0dC81U08vaU1CY1h1ZXNIeWx5QUNNQlBEZ3pHZzdvcE04bUVISUdkd3JmR0ExckMzN0FIMTBhNjRZcjRBUHZ2T1Nkd0VQT1ZiS3h1K0sycGRLUlRtZEkzZHFrUFBWZ2JTVEJHQVk4QXNBVGpXbmlCZHgwUXhKeWxPRkNjcjZIQml3MVAvQ0RnVTNFZ0VJTVc1Mk04WWtMb2xRUmRkSU4xQXlLV2lCcmV0ZjlNSlFONkhzYUNQeGU0cnZnRGRIT2NPeERJQWNtREZEWHZMbms0ZjdZcXQ2M2dFSUIvWW9qKzRwOXhhQWJCSGVVUE04cUYyYVJoODRRUXdOUVljR2dkbXg0QzUwV3FDRm5nTnNnU3ZRK0R4dTRNdWlhd2h3SUFYVmsxTytlL0E3Q1pnVGhZMWRjbm8xbkhMMm9ESXlaVUxwQnNBRlRCWjlwalQwUVFnbjJWNnVmUmljUzhRUmdiczVaWXBFc0VORGVqQmZwb0xyd0FPamdJelpNQlJaMEFIb1VDK1NPQTU2eEp3TmxFeVRGdzVGeEJQZVd2bHpwbmJBTkNkUTFlU0dUUnliTXV5ZGdNZ2dWQnNLbXRZb0M2TXQ4em5aeHNaTUx6QXhvQU92c2greWREcXRYeDRGSURsOEwvb21RN0EwUXFBODJTL0VSZFRJMjJtTmZhVHVCSUl4UjRCaEtlK3k2MXB1blFDK015dEkvWnovYzlFdXZ5QmVldExBZkdaNVdPTVo5ajIvZ3FBQkIxZk1Mc0hBVkJxaGZUY3lINWQ5TUJ5RWR6cytCNTBaN3ZvR1pYK056TlNzZDhjd1VjRzVBU1JLWWJkSFJOWXdoaERJSFJnR21PMGdGUCtISmgxNWpPWGpueUtibFZUNUNiZm9xK3lKT3N6RjhQOCtWbk5QbElDa01BemRzL1lMeGxZem5ySndJcE82ZWdUUE1xQTVaTkRBQjZpQ0NZQXlZQmNCcVRSUTBlNDYzMFN4WnlRSlFJdk1KOG1TZUxyWWUrcC9HekdmblRwRUlCeTZVUy9vdXQrSzF3ZyticnM4OHJIbURPZ0FWQ01uckVmeHhNdGUxTXQ2ajd1OXp6S2dJWHpjekVCT0pJQjBCbkNKb3FnSWZERWhNNThTV3pKRVBHSmU5aGZWSDQydW4vTWZ4bDliZ1NpQnlTSUJXbkFKQkRHRURBQjhRV0ZBOHdPMy9hK3dINCtyZzRSTFBZTHVsOHRDSThDc0ptSk1RQU91d0ZDOXFNSTlnOVowQ3hoWno2NUswd2ZGQlBxdTdQRXlWZFdBT1RIVmxUY3B4aFhIWkx6MXcwWkE2RURMaGtDc2tSZjBzdzRkUllDMFBRL3ZWU1JBWVBvN1FDZGo3R3FWT1NNZUJTQXpVek14WmNETXdMZ2NLWC96YnY0NVNRbEhYRElnYWdKYytialpCcUFXaFVvSC9ZK0IyRDBKN3JGYTZMWURSbXpvbXNBYU9lS3F4RXZiV2FjSFFCMDhKa1JJdGVTWGlTQkxZSk9MQitYNHhyekF6WTd2Z2ZkMlM0UkFLa0REZ1B6TkVBSXhNQVNTV0YzOFdzZ2t1WEx5WFRSU1JDZS9EZHVTWk1CTXdlNk9iVGQ4SkJqMjRBb3QwN3VET2JQUDlYc0l6VUdGUHM1K0pKL002b1Q0YnV4SHY5WDdCZVk4S2dPV0RnL1o1OEdUQzlYcTVGeFRYT3c5YzNDbTZrNWZQY2pnYkhiZ0FsdlZHMnRIMVQzT2F2b3E2QmxuaVorMTJuNXUvMnNEYk92YXNxb0ZnOHgyTG5iY2QxR2RoU0FoWE4rN3FNckFDNHNBOHNPUko2eUh3RDI4eitGdDRmZHY4VXlxVURyRG1DRUJjcFozOWtMUzZhcTlsNEQyckxiL0tZc0ZUUFdkZmJ2aDg2dlF1MnMxSy9LK3pJalRzWElWUTlhNTlFZ3M0WTZzWmZJQS9FY1NwL2pFWHY4QldjQWh4YUErU1ZnU1FBa0dBTUlDY3dWbE5MbHFUYzlHYnYvSEFBN01yTDQrZjFWbFh3clVxN1N2Q295R2NycldwR2h1dXIyZk5HWXdNOFlUNjdoVDNzMUxhWnZxbjVNTE0wYnptSE1tSUZTZ2RGTmovbUlCY3Q2M05oRlp3RXpEc0JGZ3BEUGVhbk5nQVRmQ3RHc1g5VElLd05yZzl0dVZraGxuZzdUSS9ZQXJYMVZrWEtyRWUxbDJTeW5OMVJDc0ZKc3FuUXYzVUlNeGh3SVJqVTVBR045UVV0ZVZ6M0JVQXZhaHVOZ2pDM0h4TEFORDduQnAvY2dPTlhGNXdDejh4VURHZ0NqS1BidmV2bHpjS1VISDJhZzZjbll6ZXBZQkI5WmkyRnhESmRqb1hKdjFXREZpTEo2TUtxS1pVem9RRlRmajJIbXdUS2NUcFZXdmN4SEttNmtLZ29PUkFFdlZjbFBENk5kekxYcE1UOElZTlBjTFY3eUpHQjJBVmhZckFDNFNOQTVBeEtNOXJ5RFBFNWZzNmVlVktXR1oyTTNTM01RZkV5SlVLVjhMMVpwSlhwVko5cExpbG1sQXhXa1ZKSEt3SWhqakQ5VHRWWFZtMUhkT3kvcEppYU1GUldNK2JvMHJXbDR5TTFON29QaFRKZWNDOHdSZ0F0dEJqUVdkQkJHRVN3Z1NpVjBQYjlEUmd1MFRZMTlOK00xbVJLaDhuaXFGeDNyUkRzTHFqZ2w5eWFHWFQ4MHZjTDF3bkUyNTJQQVpDekFIUUNvaXFvVzN5WVdGSXQ2NjRmVXBLYVJFcjFOUGFrSDZYa3VPUStZRHd5NEZNU3dnVThHU1JTejBVSngzVngvNXZGTmJycy9FaUxSWSt2NEFDSVR3dzZpSkVvZFFLd0JJeUJSdjl2d2hLelVXNno2NlRVR0V3aERTM2V6cXVzQXlOeG5Kbjh4YTFLUlBTRnRzOVlmRkIvUURaY0FtNzhDbkRCVDVVOHJDcWpmYzN5aDhHbi9oR2QvTXNLZjErUXpZSjQ4OTFKeWUxM2l5MWNBRTljREorNkZwWXJFa2lkeEROM090WFIrRndCR01lem9NbXhKTE91bUF1RDRKNHJ4SnJmZEgvWENvTEdGVktpVWJ3K0xBUFFxV1dhTU1McmQ2LytKeWNTSW04NXc5bE9wdDFqMU13QXdGVGlxQVdFVXhlWUg1RU5uL2pJblVWSGVNWFEvZi9qUmVQdkNhNERoVHdMSGZCYzRmckdxcWFOSnpMUHc2aVp4VitIVHBsRkd2WnJYWlQ0NU4zOStIVzNUdWpsWnY4RDZmcDhIUnE4RHRzOVhJT1I1WXRha2dCZ2RycnJ0NVFzcThTc2QwQmhRNEhNd21WaXRBV0hBWS9MYkxEUU5RRGFUVko4UTZXNHFWQjUxT09xRFpEUFZCM1RMT0JlcFc1am1xYUxiZWMzakdnQkdNU3h2dmVtRFlrUTlHb0tGMVNoVUNTS0NxQmVRcnZtZlZaUEMxa2VCalhjQ213OTExdFRKOHE1WGdPTGFRZ0EreC9PZFdBMkVHWjk4Z2JqbGVUSGRRSFFOKzJpd2xzM25LMy9aaGozVmVRaG92WXpkeG1BclN3UWdEUkEzUWlTQ0pVclRuamZsNEtvelJDU0NDZVltdDkwRW9KSmJWQ2svMStGaUN3Rlp4TGs0ZFJmTEZpYTZ4OExiWWtEOXY5Y1h0TEc2K080QVlRUmZyZ1B5Z1ZJY3F5aFRYY1dGT0pIOGZoM3J6N0VLd25VQXJxOG1jR3dLMk1DQzFpN1dZN1plbmg1NmZlSFQvakUzeWxpRTRUWm5jZDYzNmdQRkNLV2F2R2hjUngySitjdnM5TWxTdzBUeTNjQ20rYzduMEcwTUV4ZFc0Qk1JYlRYRTlVQ3ludnlDQ1grT3ZtNGdiQnlBL3hpc1ZnSlBwWHJ6TGo0RW9SSmpKSVpyV0hBclM5aXBySytLY2VmZ2l5QjBYVktHak9tQ21XOXhoUlZNVVN5UkZuTmVGR0VkSTJxKy9IRlhjbGtwOVdzQWJnVEc5d0dqMDhDSTY0V3hSay9PVERjVUF2QkhYU0xReGNWQ0RNUVNXYnp2KzFlN1dWYnorazV3MnRKdHNiY0NZVjZXSlk3aG1Bc0RBN3IxU3ozT2dPZ29NK0tUT0piY2pTSTV5R0lhTkUxdXV3bEFBVS9NRit0RjUvMHNJZ2hWTGRWZE0yUzBiU3pIeDJNaStGVHhYZjhYOTI1TkM0QnljSzhRd2ZtZ1ZYMUxsY0ZpeWtFTWNMMkJuZEpKN2FRZmlqS2Z4TEdEd0FoQnlNN2FDNVU0cXdQek53dWZObk51T0g0VlphQ1BsUG8yQWFocUZxb1BWRmMxNGdhMm0rV0VFTDBjQXo5a2RQck9tTXU4cjFvL3JUc1h6N2Y5b3N3RnMrak82TEFxa3ZDM0dnZzVGZzZtd1cwM0NVSTZYMTJoOGx5ZmN6M1FIcXIzRElsNjREYnFhUUtjOW1JODdRWEFDRDZ2cEpxWTBFVnh6MkNFeUNJNWVNU0dYMmU3VnRJNUo0eVRSeVpoc2NydnQxblF1aXZPQWFOTGxZRVN3Y3lTZ2lWYnIzN0JmZDAvdTMxeUVnZzJGVmFpUENlVk9ndXFBZkdvdjBpUjBSOUpBQkowYm53azluTXh3K2ZPaDU1RWJnUmh6b3pyQlVBMXBvbE45Q0x3b2s1SEVFVVFCakZNUUI3RCtqNjU2UFcrSXJKOE8vYkJDbzRzR0ZkR2VqcWl5WUN4M21LZTkvSnRUaUJ2bUk1T0ZpVGlzZzlMdEpGRjdnWkdEclViSEtzNzkraHl1NWhTYVV2aDFmb0ZyM3IvNnZaSkNpWGdDRHdWVkZKN01WbVJMc3JHbHR1RkNjNjh5RmRBQ01EQWZsd1I0UU0zSFBvS2dJRXh0NGd6NDJTdWFRYjhoQk9FMm9abWx1K0tGbEtSM1FTc3NNSnhEUFdiYmpwZkxvSnJ4RzhDWVQ4TUtHWlNWVEN4WUZUSWI4NG5rQ3hDSVBMRGlieTMwZ1hGZ2hhRjRjMlJlUjQ2NlV1MmZ2b0ZyM3IvZktBRUZ4dnBxTWNkOXlvbklya3VLNUxMVjdNVkNNKy91REpDeUlDMko4YTB6MWl3cXlFU2dNbDE1U2EzM1FLZ210UEVCbnAxMW13dVhnTzcwVWQ0REhXemZnRFlDM3pCRU9rN0hsQTZYS3lIUXpiOEhnR29DU1FMcXN4b3JJeTFCeGllN1d4MHJGYWYrd3I5WHYzMkMrNTYvN0hiSjVWSHRSWVQrR0pyc2VoSGN5YTU3UHlLQVFrNit2QmtCWlBwalBFRXhsd1U1OWF3ZzNDMjRXNktCc0M2dHFIUitNaWR5VkczaTNyZEFuQXNIMlQwOTNYVCt6THIxOTdNVEE4MGgzU2ZzWlAyVXFwQ3JQUTQ2b0YzMTdWcnBlaUtYVEo5TWhNTGtnR2RDYWNLRy9tdXBWOXcxL3Zud3lHZ0NEQ0tXekplM2xxc3l6TFdaV2U2L2tjL29LemdLSDRqQzdvb2xoZEM0aml1ek0wV1BvK2NQUTJBc1gxb2JGQ1RPNUp6bjU2NlB3YlJlaXduZlRXakk0S3ZEb2gxanVoK2FUK1dLU1lEM2k4QXFsMnJKaytWc1ZRbHk1a2tkZHYyRnZIVDYxaWNxTzdGcjcxL0lrTE5YT2kwRlFqVjAwNDZvQnk2d1o5MjJROTVJQ3FERWFMNFhXdzNDT2NmOU13NzNERkI5QXFFNndaQUFTOFh1ekdRSURLZitvVmtxeHQwMHR0QWMrWVQwUEo5cVJGU0I4eG95ZTVYdTFaVmVDU2dDTGJZTFZOc3dvbmNIeG9lTHdDekJHakJOa2kvNEJYM3o5bFhnVUN5SUlHbWhvdmE4M2NSZ081VGU5eUxnUDNNZm1zQlM4eHM4L1U2N2VQUU9xeTl1bUJVcnVEY2hxbzhzSFNkM1BNZlQ1aWZvK2FjazhlRkhJNlFFY25UNUd2ZE9uVmRYb2YrcHRKK0JWUFdjZWlhUkhBOFVzL25rQUNvOG16cWxxbVdyYkZEcHBUNUE1VUlabTdDUEEyVmdtM1Fmc0VkOTA5a0tJcUIxcUpBS0NCRzhac3RaejN4SE9BQWl3bXBESWRuZzFtYVpRQWtaenNIWjUzN1lmUXJ3Tnl4b1ErSGFrcm5TMGgxbVVBMUM5NlRkSlRtT1J5aEMzb2VxZHdST2krR0Roa0ZJNmJZTnJjTkRFRGVBa1h3UWl6UFJwbW5JczNPZHFaUFNhUkZVY2JjaEhsZ2llNmFncTJrWDdEZC8rZDhsVUpWWHVVems4RVJtUysydmZkNHV2TjJWT1Y1clN3YjB5M0poZ0loOXdKZU4zWU1RQ0lnUjc4UStuREVWWUJZWlVyVXBiWEZuTTdDT1NkZjdONElQdnREblQyQlkvaDhDaGgxME1YUWVZR1MrN0dHamFRaUFCcHVOSUZpRUNuemRXSk1JVUhjYXpMcHRDN1lpdnNGOC83RmdMRk1xcGlRTDVUdU5iS2ZBL0RDNDZycXFBYkF3SUtXSyt0aW1SVUJFaU5Hc09Rc3lRbStHcGpkNG4wNDZoYlQ4NEtQdVlqT21ISHlwOTJnY2dEUzJPb0l1VkllaC94eVVrYVZ3eUVXZExyZXdIRTN1QlVEY0tJd25xNDBIcERYTCtuM0N6YmFLZGd1ZWw1Vm5GSmwyYXdhZ2hMUUJUenRlWjBjakxxMkEybjBNNkVQaDJwQzU3V2c0MXBvTHpac0FaTnNvMEh3NmVWUi9KOGJGOVlqV0dtVkNwR0t3UUxCUkNjcmJpU3hOTGdWQXhDRjhYU2w4WURISEZQVzd4ZUZCUnd2L3JHcU9LVUJrT0R6cWdkV1BZQU01M3ZUQVNNUXU0Qng5Sis2OU9ISUYrTjcxRjFPMWdVQitBc0JmRnFLQys0V2k0QldYK0NZZ09UQVUzNndkTVZOVktrYTNNb0JXQmhQeHlpdWtvM3hrU1g5ZnZHTWtxc0RsenpIQzFONlNRNERvSU5PZTdLZWxXV1RoZXppT2JlS0NkQVJBcEQxQWRWblJIMDQ4Z0tVQW1BRVlpNk9oNERKVjRWb0dEV3FqcTRYTGJPNW8xakJvaW1FUGhQSm13dTlGdm5UTGdkZ1lUd2Qyd3lYYk15UktlbjNpMmVYWEIyNDVGbFZZVXBWeFVwR2lMdG1HQmxyVEVoVlV3VjhkRWtWS0FxM01ISjF1elJiUngrT09nRFdGWDZNc1hKVS8zNmxKb0VvQTJBS3Z3OCt1d1RFRElCYlN0ZE9zOGRkRHNEQ2VEb203WmRzekJJczZmY0w5cm9yMkM3NVVTOUl4SkpzRXNIZEdGQmlsNHlZdVV3a25vZkpnRjRYY0VVZmpyeitYN2ZLbzRFSkovL1BrTU9STzZGclZqUU1lTDVrSmhaTU1Yekx3TlpDdDFuekRGZ1lUOGNRd3BMdDRoRE9OMGkvWDd5czVPckFKVmUwUy9JU2dGWTdqOVp2blE3STMrbHlxcFlhTDk4Q1dwL04rbkRrWmRoaTZiVzhBbjFrUDNmUlRMS1ZXbHdGNlJaQ0gyTDR6RERSMGsxSXFlVE5iMk9RU1lOYk9RTVd4dE14ZXF0a1k2SStueTlWRXo2YnRmYjd4YytYWEIyNDlBb1h2ODUrdElCVmdKSjZuNGxmNm9WK21mamRESk5NSDB3QVZGWDkwR01rMWY1VHhsUzNGZ2doOTJEeU4wSU9SeTU2NjVLSWZDa3RzbCtLM1ZzR3RwVk9XT01pdURDZXJsU25qUTJyQituM0MrcElCZHVsejh3cW9uck5QTEtnd0thQzVCM3M1M3FoWFZxNm9ETmc2c09ocXZxaEVyM1YyVk5MQmptblNTTmRyT0xKMXprQXU2VlBSakZjRno0ZlhESjhpNDVoRzk0R3QzSUdqT0ZZQThUVGxRWi9xR0gxb1AxKzhadGxUMU1BdEhLOG1RZzI1ek9aVVNDTElsaVdjYnc4d2ZXNUxuMDRzc3FuSFgwNGV1aUNrNi8zZGU2Nk1QcHVBUVZaQUVGa3cyTUtGdzZhMXdFTDQrbFNCdm1BT01oRDh2a09rRlg3N2ZlTE53MTRZVC9zc21jNEE2b09kSEJFa3dYbGdqSDJrNE5hbDZ3QjRmSXVYOUx6WmpBbW9yTmVITW81VGMwT2V3SHdEVFVoOUhYeGZHSnNZa0FiQUFBZ0FFbEVRVlMvdXZDcG9BY2V3NnpCQnJkeUJsUXd3b0R4ZExaV1hMREZrSHlGOHhHRS9mYjd4UjhYWEJ5QUFWQzFvQjE4SFFZSVQrOHVHZlA3NVNDVXMxbzY0aGU4djRqNmNJUStJcWtQaHhyQkNIamRqQkg2QWJsUWtBZVkxb25kdWtTaUVMbXNVUHBqYnlwN1h1dkRnQVh4ZE5aVnZXQ0xJZm1LZzZCYmhyanVwOTh2M2xWd2NRTHc4Z3FBNXY5ekM5akVydXRsdGc4Z014RFdXTUJhTVZrbUFOV0Z5RVY2UjB1SDJJMUl6Vzd5cGJrUU9UUDVmMmNoOUtzRmt3cDBrUWxEQU9teHpIcHNjR3VHQVF2aTZWRDRSZ21BZy9iN3haVmxUNU1BVE5Yd3FRYzZLR3dmMlUydUdWMnV6ZzNENHVhN2ZEblB3WmNLZ0lkcTlHYUlCUFpiMFlkRDdoZ3lJRldNWGlIMGVRNXZYUzVIY01rYysrOWx6MnQ5R0xBZ25zN0t4eFpzQ2tnZHROOHZXRCt2WURNQVVwY2phN2xPUjllTFZjSVA0dGN1b2IvM0FPSENkVzAyVlRYNjJBcEI0TXYxdjI0Z25QeTlIaUgwM2ZKMzY2S1lIWVRIc2dCQmcxczVBeGJHMCtITFphT3A2NWkrbG42L1lNNUV3ZFlCd0dqMWNtVWtFNys4VEhMTmRBSGh3clVPWHRjck8vcHdoRjRjY3Qyb042OEJNRENmbXNKTS9uNlBFUG9ZUHA4Ykgza0NrYnRqamkydEpKQTk2MllBV0JCUFowV0JDcmJZc0ZvT2Y5cERBaUVOazE3OWZrdXZmOW5UWGV3S2NCU2pzbjdsZG9uV2JnUXB4KzI2b3RhTEl3QWxmaTJRUVNKWTNZank1aTlkbXNGTS9vRURNTS9aN1VmMFJpWVVBN0orVG9OYk9RQzNlMFdCQm05cUxhZDZISUNHMVpLMVhCNVBveG51T09JY3hTWGUvT2Y4eEhWL1ArRnB3TjQ3Z0tVcFlIbXVTdmUwcEtaZ0NLU3E1d3FuaVdFMVdaei94b3VCbTc0S1RNd0JJMTdsVkJYd3RXU3MrOC92TDQ1RmYzdmhwY0FudndvczhkNDhEWlgzTTJoeDlYSUFudTBJSU8wY2h1MzVBT2dMTDB5dUcvak9td2JnMDI4Ry9tTnoxWVdkRVRibTRJNUJyRmxvditFdEQyd0lvN2wrQXRnOEQyeFk3aXczVjVkaUVxTzU0bW5qNlhkTUFZY1UrNmdvbjdBM05TTzJxRmpseVpZRGtBWDZ1RDVJYW00NFlhVWZWTkROeGFKY0xJUFhjR0dwZmk2UG5aZFZEMXdQc3BRQlgvd2w0T2FOd042SnFnK3h3cnhzbGNWRnVZSmJsZWhrY1lZWkdQUzNMMjBCeHVlQmNTOG53ZzVINWtaa3g2VFFTYlhGWmNDUUthZHg1Q3o1bVB1ckFGeHJSYWExN3BBUjJQRkMrRWxTSEtRLzBRalFjZ0N5R3lNOXYzU25zREJSSmdMNm1zV0NmNklmV2VVSmFjOFVGbHBZODUwMERjQ2Z2Z2I0M2hpd1p3eVlWaGQyRC9WU3JLR0FtSURuQmtpYWZFY045Y3BySGdLTXpnTmpTMVY3clJqUmxjZXlycWlmNktBa01nWElNKzZ0QW5EbCt6U0wzNk85K1U4cDlqR0hRbzI4NS8yWEEvQW5YZU5uS0FvckRYSC9BSUx3YlN2TEV6NlFsMitjQWYvM1hjQ2R3OERrS0hCd3BPcEZiRTJ3YWR6SWR5aDNqak5RaXJZV0V3WXErL3pKd01oOHBmK3hLTlN3TTZEWk1tek5SUmJNMksrMklpNlRsRnJBV2ZkNVYzaS9GN0lnVDJMQkY1TGJJZGtxeExQV3Z0emxBR1EzUnBVM1k3QWlpeE14TE9VQjJ0N3BLUThNMHFDVG5wOEhrb2pKZ05xYU1FSmVzUXY0QVIzSXc4REI0UXFBcys2U1dSaXFnSmdZMEhWREFkQkE0QmE0eE43bmRsU0ZBQWpBWVg0SVBPNWRCRE1BZFMyaStKeDdYVGYxZUVkVERmZ0FRblIzNHAvd1FrUm1qTkFvQnlEVC91Z0ZwaFhBbWpBRW44cWFQUUFnWkNzMGxTY2tDTm1WaWdFYkZNc1BCQkUzRGNCWDdnTHVhd0g3aG9BRDdFTThETXc0OEFoQVRyanRRd2lYb3FrVEV3V2Q3TE9uZVhOQ2J6NlRpcS9USW5iMk04WnpJRnJUUWJHaXk5Mm9HejdwWGwvN2p2ZEFKbmIyNDcwSWJCM1Q3N1NhaStoeUFQNXZvVHFXNnNLd0ZBYy9UQWRjNSszZHZjc1RydlBWWVNLNFNRYjh4VjMrNklhQXFTSGcwRkRWaDNpT0lGVElGeHRpdDlvckw1Wi9MRDFRNHMrQjhPbkhWdVh3aGhkZDVEb0xHc2dDQ0owNHE2NlgvSnUvdlNhZUF4RFB2YmR0bWR0S0RWOTBnVkVQSWwveHlTa3ZpT2htQUVqcmx6U2t3ajQwU2xRWllaMzlJKzhKQk14OG1acnloT3NLd3FZQitLcGRWU0RGdmhZd1BWUjlCRDd1eVg0U3dSUzU5bk5JK2JSY2svRHpKMDV2MTJNMG5ZOGZBazhpV0w1QkI1cUFTUEdSQ2k4RVZqenYzbXFwa0M5QUNycndoS3VrQjY3R2hwcVJSb3dRTXFDaVliajhvT29IZVVXcGRZSUJBVWo4YzhXanJqeWhOSUoxdW56akRQanFYZFVqSkFBUDhUTUV6TFlxOXVPSElDUUFMZS9Fd1dlK1FnZGRBcUN6ekQ4K3ZnSWdnMHFwKzVuWWphRHpDZ2ptbkNZb25lMGtscVA0SlNndnZLKzZMb0ZQb0ZNbGtQR2grMHJQV3RhNFJIVE5KSlF6NE04RUFHb05UUFZVOG9wUzY0Q0M5em9BV1RGQ2hjcTdsQ2RjaDZzM0w0Si8yUUZJRUJLQTFQOW1ISUJtaFBoM0FpMzU0UnlBQW1Xc1IvUFJzNnZPUjhaOEZNUFM5N3l4dElsWWdWQi9JN2pDMHJJS1NmTFhGMUVFQitCRkZqUTNqQ0xBNDlPV3NSVFRFUHp2elFFd3J5N1ZyWjVLd3pBUUFQc3NUOWp3MWRjSGdDck9SUUNTL2JnbisxSHNDWVFTdmVhSGt6dkd2MXNjZ1UvNlI1NVkxWUl4aHZPbTFFWmVrUVdsOHdWRHhKZ3djODhRaUpjNkFLWC9tZUhEYXdYOXoxNk0vRW03Yk84UTA4R0JQL2pFa0FFVmpNQm9BRldYVWpSQTNLdE53T0JYVzNFa0FaaHJBTGt0cEM2bEt0VFY0T1U3UkhCKzNrSFdndi96cm5ZWmwya0NrRjR1RjhNR1FHYytNcUVZVUNBMG4xdGt3eGJ3NFNjSEFIcjcxUTdXNCsrYzhjendjQkFtSFZCL2M3QmNlazliM0Z1d2JkRC9rakdXZ3pKalEzdGhHbVZBM2poZk95VStSeEI2RmFtT0ZwOE5yaHNUZ0x5OENwem01UWxWcHRBVSs2Q2lOZ1hDYUlRMEJjRFlWOGIwUDRwaTMwdmZJeEQ1K3c3MkM5YWxpZWdXOE1IenFybWgvbWV1RmhZaTBwS2JzNkQ5ZnNoL24xWEZNcllNYlBnVUJ5Q1p6NkordUVrbkRBOUFvcm5XRlJiMDFXWkVzQUNvSGhPcXlDN3dkZXRUMFFBSzJLcU9iNU1DVXZQeWhMRTBvUXh6cWFZTlhMNXhCdnlWWGUxMnZCeUxBRGpYQXZneEJ2U1BHRkdNSWpDbUpiRVc4SGZudHh0UW14VDBjbXhwOVVQQWRLQVoxdXBBNkVCN3FnRG82b0NVeFhSdFBWU3BBd0pwblVodXhBcVdDQ1lLMU1CRXhabGpZNVM4U1lyK3B4QUZBdUJheWhORzI2anc4dXNDUUxYMFNBQWt3d2NBRW5neVFpemFYb3ppSWxpK09lNy85a0p2TmsxTG1CTWU5RUNPM1hSQjdhUGVGMEVZSE5WUGRUOGdqMDE2WUJjV3RCZkJWWUp1ejdtRjdWZ0dZL3BPOGY1V2RRMS83VTY3bklLTlM3ajB3SWJEUEZac3lOSEhZN29kL3hkbEVIajhDY0MzVGdDV0hnR0FQU3hpU2R0NDMxMnUvOFNQQWw4L0RsaDRwRGVaVzJQRDRKMWM5K3V5RGFJRGtnRUpRS25UZkcvTjhuVUFtdTVIVW5NVzVBUmJQZkV1SUh5L0FDalJLN0ZMNXBPUjRSYXhnVEhvZktsOHIvUzFaV0JuQUdES2VmYm4zQUZJUFJQWEI3c0ZpVlFpbUtWZ0dkbDVvb053TFExLzFVK0RRR1NYUTlyNUV2eTFxOXJaYlAxbEdRRFpzUHB6SThBUEhnWGdvZDdxVXgxMVl0QmJGekMrL0MrQkw3U0FXd2hnZG9Ma09OU0xxeTVvTG9nWWZ0M1pJMUY3RUFDK3Boc0FuZWtva2hQNEhJem1sL1B2dGhRV21QQjlMSjdqeGtjU3IxNGpXajQvMHdGbGdKRDVlb0R3NmZlNER6QVlQSG9rV2hISlozVEZTa240aDdZT1NPQndFdGlNVHYxYVkwdWt0RllUbUkyLzQzRU1RbUN1QUptVUUwZ21WRDhFRmRQcGRueGhWaHF6RHI4RjROTXRZTTlKZmc5OEVWVGVOdTlRMk9GWkJYN3ZyOXZ0Z20vbGNlemN6WjYxWk5OOERDdmlsWUNkUFhxTkRRcEFsZkdUS20wTTZBQTBQVEF5b01TeDY0Y1JmUFFIWHNuaU9USStmRVdERkdwK1FiOUJleVNSQlYya3BsMFF4eEdBbEhEbWtJNTZYNnorRVA3VURZU2RSZ2gvSW91d0laMzZsSGFiQkUwR0owcjEwUmdiL3hBL3R0L2ovNmFNQWYrN1I0Q3h6dUJYV1JHVUx3QmZJclk2VU5mcHZMYWU3bjBJK0xPL3Jlb0xNcWlWTWJXMzhvVWhrTmtRSXpaTzd0SXdlR2VQY21XbEFGVGpBWUhQVkd3WHhXb0xZYmxFRGtMdVRUOE1EUGhYTEo0akFMcGFKQitnZ1U2eGZnSmtuVDdJS1hJUVhoNFkwRlpDb2crd3hpVVR3U2tYVWJTTVYxckIvQTMxT1hXdUZwUFVkYS9tUkhLaTFlNlUraEE3WnE3bCtBK1VBZkR0SGcvTHJwdGtRcFo3MjdjUldPTDk1NDJQYTNyT3Z1T3FhZ1VsdGd0bUpNMDhqNC9QSUxiSURLejZ3NVBBSHNicmFUbk1HZFpXSXdJenhJZmVLMHJuNTc4SjNMQVZ1SDhDT0RSYWhWL0ZGUS8xSXVtSXZYUDFRdWROZnlOVDhvVnFjSHZpUGNCZDQ4QTBnMlJEdW9EcUhkYjJTYWxaQWRHOWRuZkRrQUUwZ1huSDVpaldDRGJLQ3E1L01SaVYwUUQ4SGdIUTYzakcwaGRzTEd4QTN4OUJ3MUFzbGk3aE8zQndBcGduZy9HanZxMDFJSHJYSjdxM0N6N0UrK1l6aUYycnMxWkxaKzhIOWpKc1NvRUNXWGo2aWdtUjg3YUxnZmJHcTRHdmJnTHUyZ2pzSHdkbUNFSVBTSTFoK1NrQ1JqcGZVQzNpTldjcG9ScmNucllidUdzVU9NQm83UUJDeFNURy9pZ3hWY0JJVkdQV00xaDFKWVFQbnlLTkV4R1pNRElKOWI2NmVFQkd4UERZMVk1bnYrR0NqZkdBeEQrRERwaWF3cGhBQldaUGp3TnpOTEFFSUg0WENIME03LzVjOTNiQmZJOFlrMmNnVkFkdmRUMTBpZkRrQldDL3I5bEdINTFOaElzbnNXSE9mUG1FVUtUOTRXZUFHOGVBTzhhQWZXUEF3VkVISVNOUWxLUVVnbEpqSkV4cUMrSDZOcTkza09wVWc5c3pid0x1SGE2NlF6RldrYUZpZVh4aTZoZ1ZIT01DWUdSdUorNVY0allKSURLSTlLbHNBdkZEcThRRHJuYjhOV1ZQaDlFd2RGa1E3OVRsU01Jc04wTWk1czlNb09Hbm80VTZmM1lBdmVmTDdZN3J2ZG9GTHhPQU5TQThmN3hTZ1dtZDBrQ1FibVo2bVRMRW5KMFVxV0xoVWt4bHJCbjZuM3dXdUdrWXVHdWtDc3VmR3EyaW9qblJGcGFmc1U3TUR4RXJKdVpoWUNzSm9zSHRXVGNCZTFvZXEraHhpZ0pnWEJyTW1UQlBuSktMcnIrVkVENTRpYkhZdlpvczhzTytETmNySHJEWDhZVlZ5Z2xBS3VkMEx0TWpGUHROTXo2UUxEWTdWb21MSmQ2NzFBRUg0WHUrM2c3bldxMjhJU3ZYNTgvaGd1T0JnOHZ0RlF2Vi9oRXp4ZnFPZXZ1VGZwanJpOHZBV3o4TDNOWUNmakJjNlpZSG1CY2l0bkZkMDZweHliOFc0Z1BsZ29uQnFmZlR0ZFRnOXB5YnFpVk5Cc3N5VXNkVUQ3ZUdPOWFtbmYzc1h0eFFpcGw3V2cvc0Q0QThBd0hJeVpNWWt5NTBUcC94Z04yT0w4eTA1MXF3MmhYendSQ0VkVDJubWNrMVJ4SEcrdzVqZU85TkZRQnBSNmxkTUlNWGxGV2dWbmRxRjJkVkZzSnp1T2dSd01FbEI2RGNJNnJ6bmVtRDBSbmJ3UWlTUlMzZzdaK3RWSWw3UEM5a2FoaVlabTZJaXp1TGlnbGlUL1ZvVW9nK3A4UDlsM3dKN3FHRWFuQjc3azNWY3pyb1VUb1dMQ3NBQnVkNHlwYUxDVW94ZjlpLzl3OUFEaUlDVUxyUVJXdUlCNnc3bnVacndhWndMQkd3Q2xTcVN5ejNBaEhiYVJHRUZHT21DNDRENzJVVmdqVzJDMlo0bElGNEFyam9kT0RRY3FVR3FBeGZjcEc0bUpWdVZxY0w1dGJzMnovdmVWMHRZSy9uaFRBcWVzWU5IZE81UENKWm9zK1d1enhISklWaXVYRnlKeHVwTkxnOTc2WksybGl6VUtvZGlsR1VnenlHaG9rRjh5dzVNZitxUmtqZGpmdUR0d2trbTdEVGtOYUJhUTJveDFxM2VNRDgrQjZPM0g2ZW04S3gxQ2N4OXB0V2w5aVlJVUFBV3JJM0kzbkhnUGRPdHNPNWVPdXhYWEJkajBWMXZPTC9zbzNDeGVmNjB0bFNwWXd2ZUtmMHBBdTZvaGZkSjhrNENVcWd2cjVqVjZWR1RCS0FMZUNBaCtWYlpMVG5oNWd1NkQ0NEE2SDhjVmxrTks5NU8xV2tCcmZuMzFSNUhTeStKQ3dQcGxBeFJlZ0UvMlQrQWxvR25jTm1iUXlvZ1VReC9Ld0I0Z0hqOFlXTlR3UkFPVzBGSUlJbmRvcU5rVEF4ei9iZDA5WERHTEJkTU02L3BMS2k1d2hBWDYwZ0NLMnVqeHpFQXFHTDJwUTFKaXM1QUpFQUZIdlR1allBS2pSZitTRXVnbTFkMkNPUUxVL0RBd1E0NGNhRXc4QXRaelNJUGdBdnVLa2RyV01NNk03eENNQm9pQm40WXBDRTJOQ2Z4V0FBNU1FdXd2Q0NFSUN3bG5oQUhWK1lPUmZEc1dKR2dQcE1Ld2cxYjlRcEZuekhiRDJCSzJKR3VsOXM4S2tZVzE3dkxBTFFSVENCcHpYWnBTNGd0Q1hYTUFrZHV1QXk4RTdQaWpQV3ByWEo1Q1IzOHlndzFmSkRvaGgyQmxSQWdxMk9lTjd1VFdjMUQwQUZOdG1MNTRFU0JzQ2FKY0xrRGFqeGo1WlhSaUNJR0Ewd2FEd2dqeThzazUrSFkrWDlwcFViSlNDcDZUbkZDTVh3bnkxV0FGUThyVUFjMndVclJMNm1YVEFlZlduRmZuejNGcGJhZ1FLTEFxQXpvWmpBS2trcFhrTk81R0NFdk9NTEZYT25uQzR4SUtPam5RR05kV1NNK0dxSFFHZDdKU3N4VWYrSnpRTHdoVGRWNGplMW5RdnIxTWtQR3RsZjl5UDJEeStnQXFaNnJReXRmdmRIU0R4Z0x3QkY4QW1BWWpIV2x1RURpS0dNaXFPVnZ0ZWpYVEJPdVJTWUp3REpBQVJnWkFHV0w5TmsrSU0zU3pnVHlkRTRlZWMxblpIYnREYU5BZjFEcGQvU014MkVORDZrRDBvWHRGaEJYbWNZK09ZNkFGQ2huS256bDdOZmRNUjNxQ0FhZTJCK1ZWTVlYQVN2RHMzL1gvekhKWmNCODR2dWlxQUJFbzBRUG5obndxUUx5UlVSbVpCUHl0bndIZGUwTTF2TjJsUjZwaWNvS1VMYXhIRElFZEhrVzJpV2c0LzdiNXpiN0RTUUFWZDAvZ3JpVjJKWW9qZnB3UkdFWXNHQnJPQm14L09nUDVzQUtBTmtjYkZ6TldUUm5YL0dTR0ltTVlIL0xZbGsrZ0d2ZFQrYlcrU1dIK0lnMUdxTDVRZVR0UjJFWWo1TFZIZmp3L1pEd0w4eUo2VEI3VVUzVlZvVGpUWXhZREsrSXZ2N2R6TkFaSXhwWlNpVThqaktnSVdUY3lrWmtCYXdEQkJuUWRNcjVRZVRLSTVpV0NCMDlBbUViNyt1Y25PUS9hVFBXbjZ3dXp5UzR1K1IwT2I2Q1VHcUpwSURBOTdBZHFJTmJnUmdCSjY5Q0c0SnA2cS9ja2pYcUIvUktsYTRXcGtPMk9EZ0hveW5pZ0EwSmlMd2FOaUV0OTVZUUtKNEZSQys3YnJLelJIOWpaYk42aUpZdVNIbTlJNWlPQU9oSE5KZlpraCtneHNCS1BiTHUzK0pnYVdEZG9qaE1PNWtrRFdTbE5UZzRCNk1weUlBamYzSWdnSmdNRDRNQ0FSakZNVTlRQ2dBeWtoU0tuVUNZSEI5SkIwd3k1YVRSVXhtdXA0aCtRMXVBbURzK2hwWGdGTG5CNlVMT05PbjV4QUNOSnF4Z2hzYzNJUHhWQkdBaVFHOWFMZWlsV1VKVzFGdlZYRU4wVEtwMUM2QXQxOVRNU0NCcHoxZEh0VC9KSDdOOXlheHA2UWtGNzNLQnhZSXIxMG5BTXByb0I0NHFRR1RqNnNqVXJ0T0ZQdExlRlFITEVTOUFkREZycTFFNk0xM01heFZDVE5BWE5GVGhJeWxMY29yNDB6eHRnREFQS3VWd0RNck9LdytTQlRidFIyTU5EN3Nad0M3UXZtNHdxSGE0VC91SXJoYis3bjBFZ2JRZFRpam95ZythZ1dYVDhsbERzQUZXci9COHFQMUs3YlQwcHZ0VndIaFc2K3QyQy9tOHN2dlpsYXdpMkNLZTM3bmhGdGFwa0RuSUxScUJRQSt2MDRBak15bjc5RUlrWE8vRG56eUNCd1Z3ZVg0d3hzOUI0clJaZ3lQVkZxeWtnRGQrNUpTcEJVNXIwdkh5SHoranNjM3ViMEtBQnNaTUN5UWdlRXhLeUZQVkl6M2xtY002T2ZQQUdDQURZUEU2N0pmczZoN0cwbyt4dmk3b3lLNGNMWmZPZ3BzWHdDMkxxOU13dXVWRVJvbktuNG5TSnJjWG5RS2NNN2R3TU1YZ1ljc1Z4a1NlYkpnek9XUHFkQjFhZDJmM2dwc253SzJMWFdlUjltM2RhblVJVjFsQlNDUEFyQnd0cCs3RFRodUJ0aTZVRFdEbVdBL0R2WGs4TFJwdGZQdE5VbGloWVpUT1BDaTA0R0gzd0ZzbndHT1c2aUFzNW4zR2VKSitLTG9FKzlWRENsUThSNnZPUUhZZWdEWXd1WTNTNkgvaUo4amIxMWNrMHE5UWhvYzlRTVdnUEJaSndGYnBvRk44OERHUldCaXFRSWdXeUpZM2xQb3phR0oxS1RFUGgzNnpwVGtKcmNYUFJFNDRTN2crQ25nMkRsZ3l5S3dhY2xmRm9Jd3ZDd3g5Wm4zUTFEbUlQeC8yL3NTYU11dXNzenZqZlhxMVpSVUVsSmtLc0JFR1F5WWhKQ0JTa1VxQVcxdHNCZHB1eEVWYUJ6b3dYWnFlMWc5MEcyTG90alFkbU1qS3F0QnhRRVJkQVdVQWtVbFpOQkdrUVJOeUlBRU1Ba3hwRktwcWpmVUczdDkvL20vYy8rNzM3bmpQcTl1VmVxY3RlNjZiN2pubm4zMi9zNi8vLzN2Ly8rK1R6MGRtRDBLekM0RE02dkFGcGQvMEwzR2g2eVREZ252THdLekFXREdpSC9UaGNDMk9XRHJFckIxcFJnUWlzSVFoQWErQUVEK0hFRVk2dU5MeXJSblpMU2w2dFNicmdMT2VCUTQ0eWl3OHppd2ZhVjRVR2JkZWdtQTVRTVRMRmxxc2ZuN1hlY0RXK2VBbWVQQWx0WGlYbmt1WlNCa1JjbTRVR1h0VTJ1bzN4c0FaZ3o2eTU0SnpNd0RXemtnQk9BcU1NVkJDU0FVT2JoOFF1Ti9DaVRnY1dBdXlXaEwxYW12dkJiWStWZ3hiVzQ3N3BhYTdnSUJxQ25VcmJVQmlRdWhBS0RVb3QxM0liQmxEdGl5QkV5dnRPNVZEeHZ2VmZ4Vy9Ka1dORnJDZUs4TkFHc1k3QnN2S1FDNGhRQ2tKTmFLeTJMUklzZzZTSjNJUVNlMW9uS0tDMkNzT1lNZU4rMER0ajBPYkRzR2JGc0VabVdwNVM3NGcySXIydUEyMkJTY0FKR0ErZEpGd1BROE1MMEVUQVVBa2dEVFBxOXpkSy8rc01XcFBGMTlOeFl3QTRnM1B0c0h4QUU0U1FDNkZkU2dtR1dSUklKTFpKbGw4RUdLakhpWDFqd2FOMTBIekQ0QmJEMEd6QzRXcnNLTVcycE5vYlpvQ3U2Q0xDRGZDVHF6Z2c2c3Ird0ZwaGFBS1FmZ1pIS3ZwUlNZZzdITjVYQ0wyQWJBWndQclpHYWo2aXBwWGhnbjBrcW1VMXdveG5IZWRnNUFBVHVXSGlnMkZFMXVWUndveG9YK1djYmc4OVMzQXFDS1BPTmNDaThvUHRWUCs5KytHM2orb1NLMnhSQkZERWxVeGJUUyszbnZjNEZwRHNqeGxsWFFvSmc4RmdkQ1FvR0pKVFRpY0xjUTZ2UEw2d2JnOWNETTRjSnYyN29BekZBNWt5OS9VT1N2bWc4b1A4Nm4wZElDQm4yNUp3akFSV0RTQVVnQkhONnZmZGJ2MTBBYkFSaDhYOTF2RE0yc3MrTnZBRUNLUFZMQ3NIb3lVZ1JxcmxiblJ3QjkzM09CYys0RFhySUMwSUVtaUxuRTc1ZGk4SHN5QWNqeldVVkdVaTZ1SUNNcFZ3d0pWTVhkZU9rM1hBeGMrSG5nK3ZWMmVzQVl3K3NXb1AzMXIzZUxjTHdRQmVRVXJFSGg0Sm8yaDR2RG1KUHVBeU1MR0FlRW43dXFiZ0IrSTdEbFNXQkdDd2UzMUdiOWFMMjBrR0RiL0VHUnhZNldUejhmMnd0TThsNHBnTDFTZ004ZXNIQ3ZzdXlsTUU0bm45Y2ZRTHRsZGc2VFowa1VLb3JBZmlqMjN2QVBDbXFwM2ZjQ2w2MFhGSU5pZDFQbFpyZjQxL2RuQXBCNndTUWp1dFVmSURKUjhDR0lRT3dXRUg3RHl3cEtyV2M4Q0Z6cVJMSGtWWXJCMmpTMkZRSDV2a3VCeWNYQ0FsSVVVQUFrQ00yaVJCQTYrQVJDZTdEalltUWR1TFlUbGVpUS9YVFRTNERwSSs2bkxoWlcybnpWQ0VCYU1MZCtzb0lHcWpEMWFtcGR1Z2lZV0NwZUJLQTliQkpDOUFjdEFrOExFUzI2U3FzZnRJbkxaNDRkUWlmNElnZGh5bTVXTHJQRHl1WUgvN0hUQ053RG5Qa284TFhyQmNjalFhaW9lNkJpS2FkMytRWS9NR1RINnJTM09CdkNuUUR1QUl5cWhpRGtROVJYKzI5eUUzb244SXdqeFFQSTh6a1RpQXBHVTNvVmtELzRmR0RpZUF1QWRNdzVNRlFqRWdnMURZc1VrdSthM3VJMFRHQmZWN1BvdHdId2FPRW1iSEVBVHZ1REl1dG5pNlVBUW9GUklGUlloZmUvZGhFdzd0YmU5T2YwU2kxZzhIa3J3UmNldkRhanowN2dJSjduMDVyWXlXSXBiNHlhLzd2djhQUmRGcGovTFhEbWtRTEFuQTRqQ0NPbFRCUk4vckZNQUpLZ2trVkhwR1VqeVNTQlNGZWc3L2F6cWs4RWdiU0VxOFVEUkFDTEtEWFN5YVE3QnIvL0RjQTRMU0N0d25LaFRFa1FjbUFJUWh0TStVYWFqbDB1UzlOYXRJVFhXenB6ZmNkTkI0RHBZKzZuQmdEYUN0YW5ZTE42ZkNqNHUxYXkwUUlxdE1ML0VZQzYxd1NBOXRBSmVQNmVXc0FvRHlzRnBnMWVCMEhJUVJDSUlrVmVDcVFmLzA1UDNXQ0IrVVBBK0NQQXp2bUNhRldES0V1WWNsMXlNTitZMmRja3FHVGVIUEV2dldEU05oT0FmYmVmWDBBNnJTOENVdzhYOTA2NmJGSWZkcU1ISklEKytESmdMQUNRdW15YzNneUFFWVJSS0ZDTEQxZXU1T0RMRjZRdlhlZHgwdzNBMUJ3d3hkQUpMVFhqZDhzZVFuR3JaOWJQRnhMeUE3V0lLT042M3RZdENRQk4vc3Y5UVBtNkJrTHAwdmw5dC9tNmlldFI2ZmJ5QkE0Z25YdE9Sd1JScE5uVHRQcFc2Z1dMSDgzbEtxY09GVEVuRGlLdG9Id3k4Uk5GaHJlZnllenRibnJCZmJXZmd0dHNQK2tJeU8zMkVMRDFjSEh2SW5ybHZXczZUc25CN3FBVWxnL3N1RnRBV2tFNTV6WVEwUXBxY0FMb05DWFRFdDdBM0tvYUR3R1FmcW9BT0VVQmE3ZlViS2N0bHR3Q2FqVmJ4dlNpeXZvYXNNMEJhQkt3d2RLYjlmTjdOZmNxQldHaVNXeWtXWEVSMHVtZWFjVUVvblFnQ0tSZklnREZqeWE1eXE4V2ZzZnM4ZFlnaXVNeGdwQWcvdm5NenU2bUYwejZaajVBUGR2UFFlYzBURW9zbnZRb3NHT2hhTHVJWXZud0VZU2l0aEU1MkYxWEZBQTBwNXlpZ0Q0b3RDcXlnRktucEhVcExZUDBPY0tVUll2Nk1qNE1OUjQzM1FoTTBnTDZRb25nYXdPZys2cmw5Q3N3S29Ta0VJeFB5VHN1QVBpZ0NZQm1BWFZmWWNWZituMFNSWXc2ZFAxWXdOZ0hzZ1NhamlKUDQyOVJycFdPTTZjeERpSkI2TklOTTR3N0xiVUdNUVV3Qi9NOW1aM2RTeStZVkcwRW9CaURCU1Q1ZGRaK1BrQ3NBaUlsUVpEYTNMVmF0SjBXWEcyUGJMOThBQis0b21CM29QL0hnVFVobUdnQmZScVdmMlRUclVTakV4RFNQL3FXelFEZ2ZBRkFXeXpSOHJrRnREQUtYNzVqbzZuVWd1WnhaOE5CeUhidnZxQlEzNlQxc3djc0JhQkFHR1JnNDBJcitydDlXVURoUTVaQVU3RXMyZTlMTHpnbHFIUnhOa2JldVcrb1FSUmxzNWphTWpuSzBhOWVjTmYyUjRMQXdPODI5a1FCM0xUdEVZUVBVd3pRQVdnVzBBR284QVFIMGxqcC9WMTdwbTBLUmNFaWZHdU5Pbm9jTzFyQUNRYktQWGhzOFR0TndWcjV1aCtuNlpmM3dEZ3UyOWcyRmRNdE9jOEI2UGRwRmowOFpGcnBsdytaQTVGVHZBUVEwL0JUMzZGUERrUnFCVDlKYWc3eFlsUUl0WTBmODhqNzhzWnpDY0tQWmxyQVFmU0NLOXV2QjRoNTc3U0NvdFVpRUo4b3BxOElRRmwvUFVCUEVvQkx4YlJFNjJMU3FHNGRGQjhyNWJIY090aU9RU3FUNVQ3Ukt6WURnSngrQlVDQ1R4WlFDd2hhUWM5b0tjRW5FQktrbmo1RnNKMUxBUG85eG9XV1BXRHkrNklJb3FiZWFPMFZBK3pIQjB6eElRREtrbjFHZ3RYaVJ4TUlBeDBWbjBEYitsa3VGakxSQ3Q1V0V3RDcxUXZ1Mkg1T2Zla0Q1RmFjaVFheS9HSWJGZ0JYcml3QXlHbUpBRFIxY2szRHdURTNUUTRCMExldHpCSkVyVFlBcjJCQlNJM0hUUzh0TEtCWlBvL2ZXUURacDE5N1ozc2NqR2I1QkRwL0wzK25qTXdlQjZCODNHajl3ajNhdE9zUFdpbjlXZ1hDRmxWTy8zY3RmNGlEOFhrQmtINVVTbEFabE5QWkFRcUFScjV2eHUxeWptSDBnaXZiWDBVUUtJNjNvMFd1bi94SHVSOEU0Vm5QSzVKUUxkNFZOdHRUQnZLMnVvaUtPVWYvZitHandNTkJoME5NVjZKMGMwTnBjUnY3bXJZdjNraDgvdUh4WXArYlZwd0xwM1I3c3RzMll6b3VTcTNLR2ErcTcreDdDbzRuYXpBZXJSS3NWbFYxUWl0RjU5ZHl5RlphWVkwSE11OW1XTDNndHZaWE1ieW1CSUZNWjFvdjJoMEIrTFRMaXN4Z1crRXE1dVU5MmlaNzJ1ZDl2dlIrNEpGcDROamtSaDJPTmkwT0IxL1VCQ2t2RVlSaGZ1TnM0T21oaGlQS25GUWx4NmFBak1uU1hKVUFBQ0FBU1VSQlZQam16MXc0MW5ud080Y0NJQnZCd1pnVEFPVUhScTNneURFeEQ0elJHVllFbnBtNUxxbVFjME01ZXNGdDdhY0ZsMFNsSGlCeHVUa1l4eGRhaWhVQzRRVlhGdTVGQ1VENVF0Smw4NXNqR0EwemlReHFldS9mZW0raHcwRjJmTExRR3hGbFlNUnZvN3YxV21JVnRwdDFERmtYdk9SN0x3SjJIU2t5b1ptRXlwb1ZWZThwN2I2cUVNbmlkR0cvVmwvTDJhUE9Jd3VBMXBBSVFFM0RBbUZhNGo5ZjdDUGFGcENIS3VqcjV4elplc0dkSHFBcUt6NVgrRkxSQWw1OGxlK2p1aStrVEJBTE1jZ1o3M0NEQmtwTjIvNytiZmNXT2h3VXlDRUFqUVRjQVZoS2Rqa1BjMlJhamV3S3l1L24xLy9xSmNBMnVoQk1SR1hRT2NuOVU2SklPalhIUXFTWU9zVm9RcDFITmdBdno4eW55ODBINVBWejlINlJxVmQ4NDlXdFhRL3pBME93MmF5R0xKNDc0TDBHNzl2dmJ1bHdrSmk4QkdDZzRTMDFTS3FvZm9OdlNJQys1emtoRlV1cFY4clVUcEpOMDZLcGFCa0ZRbTVNMUhsa0EzQXlNNS91OVpsMzh6cms2ZjBpVTYvNGhtc2NnSzVJU1V0Q1Rvd3lEcWI3VXh3c3FGSlczZm8vdmJ1SUJKRVoxWVJneUh3UUtOaTBLRWwxT0tUQ1pKZHh0UERuLy92OG9vYURhVmdxRnlpVEQySUtmY2paUzRGbys3ZytIWE9Qdjg0akc0REl6S2ZMelFmOEtWZkkvRk5LclE2aDk0dGZ6K3ZPQTljR0FBYnJweWxZMlNEbFZUVHQrdUNuVjMvVjNhN0RRUUF5c0pBd29iWkpnVVhpNzhRYXloZDgxMldlaU9BWnpFeVVpQWtITWV1NUJGNUZ3WlFBV0xQd2tua0xReTlDclBNeTgrbElIWkZ6dk4zVCtZYlYrOFg3YzY0T0hIaXg3NFY2ekl4QitSSjB3UStVVTk5MnRZb0Z5M2ZjWGNURHhRa29Qc0NVaEZJY3pLVkNlZ1NnNUI4QS9QSUxOOVp3eEJTeHRpS2lVQU9pN0pXMGRMVHVzdEY4QUdibTAvMW8zdmpqblNHZGorbFlsR3dkUk84WE4rYzF3QUJJb0hrNms2MXl1U0NKSVRxM2pEWTlWeDBCcUsrK3V3QWZYNkprSS9oTUUwU0MxRUdndWlRK2lzcWNRUkxyRjYvMGpPMncrNkZNblpoeVpZc1ExVzUwcU9IZ1BYMU5YbmR0T0RzZmdNd0h6TWluKzArWk4wUzlZT2xsTXpXZkx3S1FTUzM5NlAzaVkza05PTERQTTF5MDY1SDRnT1czcDR1VERrQjh6V2RiN0ZnYmREaEVnSmtDVURSdm9nVG1kL3ZQdjNCVkFVQnV2eWxOekFBWWk0aGlzVlFuRUhvSXFXYmxyeHFtNE14OHVqZmxqVCtZanNXQllnSU9jMG9KUHNxMXNsQ3BINzFmS3liSk9Fb0F1dVZUUlNDbllsbVU2UC9aNGlTSkVjYkx2K1l1OS8xRUFoN0pLRVhES3hxNENoVWlLeW1SYndqZ0hkY1VXVEFSZ0xZWEhTcjJMT1UrQlY3TVZ3enh3T2ZrT1d5YllBR1pENWlSVDBlZGpweEQ2VmhjT1E2ajk0dFA1MXdkT0hCZE1lWGE5T3FXUmNtV1hBMVhMVUlVSDZ6eUN3bEFzM3orWUJrZnMxdStWSWVqSkVGM2NrcmpJOVQweS9hTUEyKy90Z0FnMDhWVVJLVDh2YktNVWdBTUlHenpBY09pNUhrbkhRQXo4K2wrTVcvODI5S3hodEg3dFR6K2pJTUFKUENZTVVMQVdkNmZ2aStFWTlvdW9aQk0vS3gvNExVQmdGTGdOQzVvMTZGckU4SkpWSmdraUZoYVFRQnYzK2RWYk1yV1ZzQzhVeEZSa2pqYVZzVzJEdFJkT0ovdkF5b2hWWUs3QStiVHZUZGo4SGxxVE1jYVJ1L1h4SGt6amdOa0lPV3VEcjhqbllZREtEdXRncFVocmEwdUFsQXlDQ1VBSzhCWGNqQlhnTENrL2gwRC9oY0J5RHhGQWRBem9GVXFVQllSSlRVY01XZFBQN09OTDZpNWJMUWVBTEpSUStiVC9XN0c0QXVBT1hxL2xzR2RjUmdBWStnbExrWWNsSlZUc2E2cHRDWDN1UWpBS0lOUXN0RnJBWktJd1d4UUloSUp1b3ZCL054K3IyTHpGQ3dsajhZMGV2bC9NWWswa2llVnRjdnJ3R1VuSFFDVmpqVmtQbDNtSXRRc0lQdUVseDlHNzlkT3pEZ01nR2tBV2xOeUJKbjh4S3ByQlJDK3pnRW80TFdSZ2NkVmNPQ2pqbE52bXg4NERyek5BYWhhRlpXTHlnS1d4VU5pYkloVGNQRDlCTUxMYTY1YnpyZUFNU0dWb1h2Si9DZ2gxV1VmTytYVFpTNUNEWURzOUdIMWZuT3JJRGNBa0FCVFREQ0NMWUswQ3dpLzU4NldjS0pVaUVwQzhDQ0JZRHNpaVNwbHFVSVVtT2pmK28ydElpS1ZVSmJnVTV1U1dsNERXd1g0K1BjWG5yUUFUQk5TKzh5bnkxeUVvcGRjYXkrOTMweTVZaGdBZys5bjJPb1VlSTVUZFFlciszMmZkaG1Hb09CWmFuQm8rZzF5RUtVNGRZZ0ZTdnFCLy92WkJJQnQ5UnNoa1RiVzhaWloyaFVndkRMM2lVM3V1eDRMU0JNMFpEN2RQUm5USDA4VkFJZlYrMlhBT3VjUUFNdVZjS2ZGU0QvK0lBQUJzRW9Hd1lBb0haSUtFRVl4UklId0xTOHBVdWhqRlZzNi9aWmhJVld5eFZLQkJJUlhuYlFBVEJOUys4eW5JNHRCemtFQUN2K2NobFVWSUtFLzVjUkdzV21sS2ZJenVkYzNBUExRU2xnM0UyT0N5VlJjMWtwVTNEZ0JtS29Rc1d0bEJjc3dqUHUrbmZUWXRCTCtHUWRnT2YxNkdDWlc2cFhsQkNxV1NncUp5cG9PQUZmWFhEaWZid0ZKTHZpNUhBamxuVXNpSWU2QWpPcDRpUU5RSFJsVDJQbGdKQ1ViYmMycyt2L2hGd0ZiL3E3Z202SGxZcEJibVRWMnNzY1F5eS9xRkJqMnYwL2NBZHovSEdEN05EQTFBVXlPT1UrMUN3V09ld05qS2o2L08wM0YxL1d1dWdXNC9YSmdmQm9ZbXdER2RIN0l4QjVrTFBJQitJOEFmTndaZ2dhNWNrMmZKYkVtOFY5ek5XUGZyYXNiZ011UEFjdXNlSjhFeHNiOUZkQmhBKzdnYVFOS0I2VGZjZ0NZdWcrWUpUK2c4OWFvQkRNbUlNU2NQMTJ1VEtqMTN1RHY4enNLaWcvdUoxdVFPc25vam0zcUI1UDVBQ1JCSDNPaFB1enpSTjlEVjg4SHFRTEVXUEpudlR5NW5tL3QvMXM0QmN1U3BSWnRHQXU0Zmkrd3RCVllFeWNjcll3bjZoRjgvRmtKcDliS3hBS1ZGc24vZDh1cmdiSFBBOU5QT0VPV2w0KzJjZm9GSGhmVnJKVFpQS0hTajVkYU90dXA2SnlDcFB4OHJIV1JWUTdXT2xyWUNNeDhBSEl6bHhrQUxQRDljMFZCK3gvQTNFLytFMmZVWUhYZEY3S1RHd2R2VGQwQUhQOXI0UGdXWUcwS1dCZGZzQmRzTVBmUHJLS3NvTDlYQVZMQXZPMmZGeWxDRTRjS2xpeXJEVlpOY0dTMUNxRVloV0ZpQVpWK1hudGFVUmRUTG1wQ0VicGNoVFlMcWk2TnJrTUN6THp0NVhjNEh3eUptbWtKK1o3M2pRT2g0TldlRFVaaUsxSzA4ZjBFWHQ3Q01IVmF3SWs3Z2FWcFlKVUE5TEkxQW84YnpLWDFjeXRvRnRGZnBkQ0lXejdyZ3pIZ3RoOHUwb1BHRHdFVGM4Q0VNeVNVekZhaWtndGxwVzFUYThKcU5iYTdsVmxqU1JnVytRNlpQLzU3V1F2ajZmeWRCalhmQWpLYmdFdk1Md1dDdmhOb2lwZ05wblFzaGxTNElHRld6SWs2eWxXd0F6OTNFVEx4R1dCNUNsaWRMQUJvSU9TN3BtR2ZHKzMzWUFHNW1ORDBHOEY0Njc4dmtpUEpjek5PQUM0VXlRbTJOOHc5NGtpckZsZklBbDdpNDAyZDZkYlBXV0F0cnNqT0ZpdUN2QUpaT1FFMHBIVEZzY2tIWURlQ3ZoTmdpcFFOeG9BejgvOElQcjVuYnZIMmpkKzZBVGhKQUU0QXF3VGRaS0VCTERvRGdVNCtZVmtQSElCb1B3YXJlT3QvQmtEZXhzTUZBRm5iek5KWW0wSURuVndidDR1eXVyMWt3TDdUcCtpWk0vMDhXVDlSYzdESFVtdVlUci94KzZvNG92dnU5ZmpCYmdSOUp5QStvbXd3eHZaSTVVTGc2Wlc3eTlGUGY5UU53S20vQ2dDY0tBQm92aDhCeVZ5L1VDdEpxMmYrWDF5WUpQR1UyN2xJWkxidUVXRHNXQkhlc1plRHo0aVVSTFVXYTFURTQ3THFLMTJmWm1kM09YaWRGY3RxbTkyS2F0VnMxakFFc052NnNkeW1hYTJnOCt4VUw0SStQbjJiZUNnYkxHV0hJL2g4RzNvVHI0NWlLODZQT2xiQlU5eUtJL0FjZkxSK291UXdIOUJmbW1iTGxUSGJvT25aL1Q5KzV2YWY4RlVhQVRoWHNGT1E0NW1VY2daQ1dUQXhlMFVRK3VyWU1PMS8zN0d0eFFtb0xDQnRSU3AzMExyRHAyU0ZkellNZ2svUitWTnd2d1I5bXdRRHNhc3BHU2ZKZ1lEWU5UYnA4cHNDUUZKeEVJQmtRakRyeHQ4ZFhDVUlZK0NPSDVNVkZQaThTT24ybi9RWUxaOUdwMGN4QU5JUDVJdkFrelZ6eGl2UnlkbktOekJhOGZkZE04NGI2QUZ5QXJpTUYycGFqazlrWUllb0NsWG1BM0FRZ3I1TlFFSE1CcU1WRk1OYUlPYXlOUkwvdmhsSDNSWndtaGJRUVVjQWFzclZWR3o0RXRqQ3UvM2RmYi9JRDNQYlQ3dUtBWi9NaGNJQzB2cVJUbzRXMElCSUVBbUV0RndDWXFqVzAzYmNtZHdCWWVvV2dldFViclI4c25ybG9pUjJkcnBBQ2YrckQ0RDlFdlRWaklKdTdIQlYrNzgxWDc1MkN6ajlsd1Vaa1RFZ2NQb05QcDVOdjRvQlJoQ0c2ZGQrMURrTXoxSkloUjFCQUhKN3p3cU8zZklSUk01dG1ESzVDb1FLc1NnT2VCWUJLRlpVTFRxY0I5cjZOaTVLWW1kM1dLRFVBMEJsaE5MTThFYlQxUUJYQlU3MmFJNVpqVWNWT3h6N1dMa1E4ZDM3dnNhcnQvdUE2UmNQc3hOU0F0QVhIRFlOQzFBRXBmOXMwMWtLd3VCd0dVN0hnVnQvMWp0RDFlNjBmZ1FpZ1NlL2o1YlFwK0tZcEdCK0g2MmpUN1A4L1p5cEJJQzhEaGN4OGVZOXdGMDE1YWJobW5vQXlKNVdTcktlTmdLTzlTSHhuVC9MU2FzSkJpbTVsUmpXQkVJVmVST0luS0wxcXVueWJSYXdMZ0FTZEV5NzRxamFOTnpKQ2dxRUVZekJHdkswMjk3bUFGU0hFSUI2ZWJLRGdjOEoxa3NtVjh0MjlmMWVuNkw1djZjeElLNWlLNlhuZS81akNUaUZjVHFWbi9yL3RXRFBXd1huRVBUVmdJS1VIVTdsakFTYXdLZWZJd0RwTWRSeFJCK3dGZ0QrUlJFREpBQnB3U3p6MmMwTGZ4Y3pWamtWS3dhWWd0QkJlenUzU3ZYMDhkMzlQNXVPM1FLYWhYTVFjaW91clpSQUdLWldhci9ZWjF4WFJQZTh3UXIyQVVLN1R2Yk9WVFpCWHg0TUJFQ1JuQ29uVUJTRkVYVDZtZi9USysvcW16QUYvMFVCT1BxQlpZRjUySHJURkN3MkxINUc4VUN6SkVrbzVuWnFtUm5QaC91Q1htcG5WcERUc0lQUHdLQXBPYVNBMlFMRExTSGY5N2lQeDB0cElTTGZ6N2JsNGlGZnNVc25qK0haV0VlT1lEQ0RuRG1DdlprRWdlZGNDanhHc2VJaEJZdDN2eDA0OUh3TUxSaDhnQTlnaDJNb0g5QUJxS0p6eGYwTWNPN1hsU0FVNEh6aFlZRnErNUQ3aHdCdS85OE9RTGxJQkNLblczOVNsWE5ZK25xZWlxMmRrUWcrZ25HUGI5L1pwVDBscTZNVjVEOTZnTEN3Z0RtQ3diZG5DdlptQ2dZL2R4eTQ3eHhnNVNXdVVqaWdZUEhGYndBK2Z5R3dmcjJyWHJNdlBCK3ZwM0wzR0hDZ2k5Sk9IUUNrUlZQcHBlVUJpZ1hMRnlteWVqWVRCNFlzZ2ZBMjBvZlJBbFlCMEZmQWx2UXFQMC9Uc1g1UExPQjVETnU0NzFjbUl3aUJhUnd3L0YwMUorbXoycHFDaHhVTVp2cEpsbUJ2M2lUb2NzVzRkemV3ZmhrR0ZpeCsyZmViWERBZUpPL1lFSUxCQjdwVTFnOExRRm85OFFBU1ZHWU5RNkRaZkVHM2ZuRXFyZ0xoYmYvSFYxNWFuYmtGTkN2b2hXU2w5WFBRMlhUTS8yczNJNER3UElad0JFRGZnaXRIMEVrNk42eCt1L2lEN1Q0Zy9ZZEJCWVBwV0hFYUhscXdOdytBUWE0WWo1NEpySk8rYVFEQjRwdCtvQ0F5WXZPUEVJUURDZ1lmZUYvOVUzQWJBTVg3SXRBbFZ0QXNwS1pkejVTT2x2QTJwc3R4akVTM3dKKzkyTmdBR0syZ3dpNzhRb1ZmRWhCZVFBQ3FOTlAxUmRvQTE4a0tkZ0RoeGtVSS96S0lZRENucXl6QjNqd0FKbkxGT0VJVzdRRUVpMS8xWTIxeXdWZ2xDQWNRREQ1L0VmajdNNENWclo1QUtsa2h4ZVFVYXhCSTRudkZ6eGY4SWZDVkM0SFY3Y0M2WkVYNW5lbjNWWDF2QUdMWnE4eXNydkhZK1FCd2JHZkkyRTZKcEx2ZFgra3N0aHBVdlFybVgvc1ZER1pWVUpaZ2IxN3ZKSExGZUdRY21DZFZiNStDeGQvNXhqWjZRenpNTE9RQkJJT2ZUVjJQczRIRkhRN0NMUVVRbVVyVjByZ0tKTXNDanN4R0FxVG4vaHp3MEVYQTR0bkF5ZzVnYlRZQm9yS2tVeUxua0I5WVZoVHh1K2tUMTNpY2N3dHdkQmV3UEF1cytiMmFyOXhKQWFmcWZnTVFPNGRoK0o5K0JIZTVncVpaWnpZb2sxSkpVY3BhUjZicDkzUCtXL042cDBLdUdJZW1nRVdLZ1BRaFdQeGRQN05CTGhpSEtZSFVwMkR3cFo4ckxPRDh0bUpRVnBsT0x4QXFtYlJLQzZFRFlDNy9DZUNSUGNDeDNjRFNyc0lTcnMwNENQbTlBclprNTVVdktBc3BZTHFQYVBkUjQvSDBnOERSSGNEeVZyL1g2VmFiTEhrMlBoanBQVlpZN2Q1eHdGNkN3Uzl5LzRMYmJWeVFzRUtJdWZHaUtlMHAySnZYT3gza2luRjBHamhPUVkrb05SdGxqamk5VFFQZi9mT1Y5SVpZNEdxNEQ4SGd5LzRXK09vMllHNWJVVXkwNHZVY0xDcVNKVlJXc3pKYk5neFNtTWF1K3EvQW8yY0JSODhFanRPcWJnTldXYVRrSUZ6M1lpV3JGNG5BanROMG5CWnJKblUrLzhQQTNDeHdmTVlCNkxVcmEzb2dsTDB0cHM2d2xWaGE1ckxpcWQ5QWREZkI0SmU2VTBzLzBCWFREWWg4MFNyMkZPek5BMkFYdVdJc3pBQkwxSmFLV3ExUitud0dlTTE3T3NvRlk1WFRWdy9CNEN2K0RqZzBDOHh2TFlxSkNFQ3pnc3htWmxxOVQ4ZTBYR1V5YVVpemF2UHR4b0ZyL3p2dzJCbkEwWjNBOGUyRlZWM3g2YzRzcXdPYmNrZXloaVhBb3dVU0FEaEQxWGhjZURNd3gzN2x2VTRYeFZOMm4zckpJb2N5Z2tyL1ZiczdmZStFZEJMY2ZhWFhRM0lQV0lycEJCNlhsbndwUjc2allHOWU3L1NRS3phcnhNN3FKRmo4bWc4VWFyTVY5SVo0Z3ZOREQ4SGdLeDhIRHM4QTh6TUZBRm5QWVFQRGwwQ28yZzRmcERaTHFLQ3hUMC83ZmhKNGZDZHdiRnZoUml3UmdKcnVDT3dVZ0NwZUN2VWpabUVGeGhmazlXOTY5a1cvQjh4dktRcW5WZ2crQjZDQjBNc0k3UDcwQUhnbWQybjFOUTBydjdGdkFMSWxWWUs3M01uUUNETFRoU0dab0RwdVA3dUNldVg1bjh6cm9CNXl4VGhHblEwQ2d5Qk14WTYzQXEvNWFCSEc2RUJ2aURsT0xWMEVnMSswQUJ5WkxnYmwrSFJ4blpYSm9xcXR0QTRPRG92bEpaVnVTalRRRnRxK053TlBiSE1BenJhbWRWcFZzNndFb1B0ZE5nMzd3SmZ2c1lpSlA5TkZxdkhZKzd2QXdqU3d4QWVOeFZPOFQ2YU5WUlJSbFQ2aEhySjBPdmF3MFdESkNLbmc3Zzg2QVB2TkI5d2cySnZYTzMzSUZXT0JnbjhFSWYyblJMRDR0YmUxK0FVN3lBV2JaZXNrR0h3VmRkMm1nQVVDY05LbkpnTFFyWi9WOS9Kbm41SlVZbW5BRTNoQ212Myt0OEFXUWZTenlQSy9QT09nSmdEZHNncUE1bmZKQXZMZExWK2J6MGtLNFJxUFozd1FXSnh5QVBxRFZoWlF5UXI3Z3lhWEk5YXhXQ0ZWQUdMdlJVaFY0NlBnTG5VV0JzMEhiQlBzemV1ZFB1V0tzVFJaQUpEVG84bDh1aS80Mmp1TDV2ZVFDN1pwc0VvdytPclpRbHFWVnVINEZMQThXVnlEQU9UQW1IVVFDQVdRa09sc1FBd0R0LzkvQUU4U2dQUXBOYTA3K0FoQUE2SExYYmI1WHI0SWFBTWZ2L2VHdlA1Tnp5WUE3VUdqQldUV2poNDB2OWZTeXNjSEx0YXhoSld4RlZzTk5BWEgxa2h3OTgzK0RZUG1BNWFDdlhrZE5JQmNjZW1mY2Vvb0FmaEFBY0ErNkEyeEx1QUd1Y3hyemdLT01leERmVjlPd2JTMkJCL0JFb3FMU3JCb1lHZ0ozRThxTGNJRXNQL25nQ1B1VXk3UzEzTDN3YjZQVTU2L20vWGo0UHMwVEtDWFFBNkFYdU5lWlkzSE16NVFBTkFlTkQxa3djS1hsajZ3T1pRK2I3UitQaTBQRDBEZUZBZms1OTBDS2c4cW5jZm9GeklSVldWcWZGZkJoZ24yNXZYT0FITEZXQ0RidlBzdEJzSlo0TFVQdCtqZGVzZ0ZnK3FWcHRXcTExYmcyZ3RnZnVMaVJBQWdRZWcrb0Vtc091anNYYjVTc0FvQ0lOLzN2eDA0T2xOTTZZdjB0ZHgxTUt2SzcvVEZqVm1lQ0Q0SFFRUWhmMTU5ZVY3L3BtYy9rd0NjS0FCb2VZdlIwb2VwdDdTRW9aUTBUcjFsUHVQUUZsQXRPMG55QWNXaHB6dy9GU2pGekdqTHgrUkd2eHpvU2VDMWh3c0E5a2x2YUZONUZBeSs5bUpnbmhhUTBxcWFnZ2xBRG80YzlBaENEcEpQbDVab21tUTg3MzhIY0d3NkFKQlcxVmVjWnYwY2VQd09ZMC93bDFsQUQvV1VDeDBtTWxETHI4YmptYitEd3AzeDRua0RZYkQwdGhJTzVhTnRmbURpL3hHRWVSYXd4aHM3VmIvcTJodUFCUUp3QWxoeXkyY0MweG9nZ2pBQVVDV1dBa2tzT2lJWTk3OFRtT09xZXFxd3FBeDNXR2hISzA2bjdURHdPY0FWL2lpcFBBS2p3Z3JabTJvOG5rVUEwZ0ttQUhUcnArbzlNVHJFWXZxNDRvOXBaSU90Z211OG1hZkNWNzJZQUtUL1J3QXk1T1BPdVZsQUFrOU91bGU2eFFSVFdVS2xXdGtVL0l2QUhBSHRpNW9Jd0RLODQxWlBGdENtZHIwVThQYUM5aFZ1bHRkNENJQzhQMlp0dC9tNS9xQzExVEpYbEpER0dwZkdBbVlPRGdGb0N4QUNrTHB1V2gzS0NncUU4Z05WWks0S3R4Z2pKQUIvMlgxS3JhbzFyZk43Q1daZjNMU0JUNHVBRUl5V0JWcGlwTDdHZ3dBMEFXMjVHYkdFTkJUUngzcm0xTTJ3MzltbXJGVndqVGQxS24rVkFaQUxFRTVMdElEeU1XVUJ2YkxOTEdIZ2Q1SC9WMDdCRHA3cjN1VStKYWRnbjNwdHhla0E1TUJyaTAvV3A0d3pCakRiQ25rTVdNcVZwRThHSndMUXF2ZmMwcHFia1ZqNWFOazdnYkN4Z0pubzMwY0FqbnRvd3RYTmFaMXN1dlNLTmhzWVRjVkttdzlGNXhHRSs5NGRmRW9QK0pZaEQvOE9DOGVJUFVzVUhva1ZWS0I3OFhzemJ6QUY0UHZkLy9QQ0tWR0lwT0FyNzhtbjREWk9tOFlDMWpjbyt3NkVGVEREUEpxZUNFQlpCYTVHZmZWYmhtUThEdFpXNVRZT3ZQaFhpcDBHVHV1MjJsVE1MU3crYUFWbDlRaEVXanVySS9hUWlMSmtUTUxzWDlSM3IveW1aNzNmcDErMzdPVTlodW5YU2tkbDdUM1FyaEtDdGxDTTU5azJpNUNNTVNJQUdkcXhFSXdybXB0elRzQ0V1dDV5aWxLb0pMQWN4Q3EzZmU4dExDREJGd08rdEtqeXV4U0NNZFlFWG9lRHJIY0h2dTB0VHdMem13SEE0Ti9HaDZ6TkNxcWVPU3hDMmxiOHRRU2lNd2J1cVhJcUFjakZoMkpqQktHSnlTaFFHNnlnVmJmSmVnVUxXQlljTVIzcnZiNm9DUmFRd0ZQZ2wxTTVyUjcvSnRCWk9JWld4LzArczRRZVk1ei8xL1gydEZuQXhQcEZFTGFWa2RMTjhNV0dWcjRwQ0JzZk1ITjhibVRLZkNqWjBOY3A0NTYveDU4ekx6Znc2UWYzQUJkOHBVZ0VZbXFrNWJHeWVrMDZJUWwxYmtYU2NubE4vdThMMjRHZHgxcVZxOTFLUXZycGd3YUFBdzlwK3duWFB3MVlqeVdNR3REbzJBU09GR01VN1NJRVV6ZFlEMzR2TVBtWHdMYkhnZGtGWUF0bEdpaW02RHB4SnR2cTlMdGxWci9hV0tFQjhwVVhBT09QQUZQendCVFo5cjA0dmRROVRzNHBBWjNjZCt5SHhnZk1BT0grdmNBNjkvOVV4aWptei9BZXJZcGRhcjFsTlNNWXpWK3ZXWS8zNEk4RFk1OEdwaDhCcG84QTA0dkFGRUZJa25JSG9oR1ZSNjJRaEZSU1lqUUU2cUZyaTJ6M2lhUEFoSE5ObHhLd0FySTBRMUlBeHdmUmVhY2JDNWdCUHA2Ni81SUNnTEtDdHFuc3JLS2xyRlpVRlBLT3I3b3NNVHRkc3h6cVFSWjkzUTFNUEFSTVBsbG9oVXhScWtFSzZnU2hPUDBTK2RZMmhsUnY5OXkrb3ZSaTdJaVRuVHZMcW1nNnhEUFlwcUFVZ1Jnc29SN014Z0ptZ0hEL2M0RTFGWHU3RlJSYnZFZ2Q3ZXZYV2xiUHBwOUVnVWppSnB3ZTZ6d09NbHZwQVdDTVZ1c0pZUElZTU9sU0RaUnBvR2lOeEt6YmRJUWxYT05NV0piR3R3NHN2ZGd6M0VsNDduelRSdlBycktwdEFKVDZacnpmaW50dkFKZ3g0dnN2ZFF2SVhLNVZZRjNzVVp4bUpVdmdBMUZPdndGOHNwS3lCdE0xeTZFZXBJNExxVk1lZGJFYVRwMEVJS2RQS2g1RnFZWXFTeGdvMmpnRnIxM2o2WFhIbk9pU1pPZUJWU3Z5QzhxQzJyMDVGVnZWdzljQU1BT0ExNzhBV1BNcDJMSmFhZWtpQ1BYRXh3SHc2NjBuMW9CL25pR1FhendPa2tTZXBiSi83MkkxeDRDSitjSjZsWUkxcmljY3JWaWNVdVZTbUlXODJwa3duSEhWT0tiRnNPb3pRR2tGa3dld25CRVMzN0FCWU1hQVgzOVpBVUNDYjgybklsbys0MHAyZ05udnNvS3VueEgxeEd3QS9MT3pkUU9RSlBJdUh6VjJHQmc3Q293N0FJMGwzM1hmak9zdjZvVm9kZXM2SVNiQnNBWk1YK2tKeFU1NktZN3BrbUZWaE9jaXV2VHpTdDA1djArcnl1VC85Z0RyWk5lNHdQTXNJN1ZKUDNHY1A3Z1VPT2R2Z0wxclJZSjBaSTVJVjNoVjQvd3JHWVBQVTMvQWlSaFl1c3kySzdtVTk5OVArejkwT2JEN0x1QlpLMFhka2VxOU5TWDIrbzRITHdmV2xvcEZDQzBmZ2NpQk10QUZDOENHcllYVm9Wam5VMkc3clRYcnpoNGtmUnpMWTFreUd3Qm9laUdjUGlYYjVlQXpkWFduYXpQQ1NTY2I0ajN4Zm1hdjhDeDJwNTBsQU1XMFZYSU5pdENvZ2wycjlIMmRjY3RXd1F4UXNuNlpUQmJNTnRjZ2RLSWJpWmo1MVZjQmszOENYUHhvUWNmQ1VnOHBqY1lnWlNjdy9tb21BQ25YeXI0bGVCaHM1UWFCVEhwZjdYOGRNUFlKWU84WGdBdjllOFFKbEFaWnE4RDR4U3VBTllLUEpRbjBBUjJBSEt5MU1BQ0tlOW5mRkk2SUVxZHVFV29ISUo5d2xzVktMZWtvTUNhOUVBZWdTVFlRZU00VFhjbzJTRU1rQUhFYkJab2o0YmJZdGR5Q1ZyRnFHWGdUU3hnWFlUWmVITGk5QU1qRVFSQ1ZVWFAvbjRLVWFhVDh2VlRpK1J0ZzdHUEF1WWNBV2xNQ2dVVmtRZkoyUTEyeUJ2UFhNd0hJbWhEV3dmODFpbXNUaUxTRXZIWmtyK2pZL3A5Q1FSRDRwOERPQnd0ZUl0YWkwNXFuMzFGRmRmTGxGeFlXZ0NEVUlrUmtqL1R4YkNFaS84OWpmUFozWDJWcVlTSlFibVVOUVkzSFFUN2hidjJzTG9lclZ3S1FITkVFb0NzbThSNE1oUFJqWFVHelZFSUtJb1k3eWFFWXVZNGRnR2I1UlhydW9TZ3RTQ0xMYXJrSUNROWY2UU55a0dqRmRqc0lCYUk0a0dsdDhXK1JnNWcwSEo4cUFwNDduaWhBekZwdVd0UElNQlpKbEFTSUx2UjZmUTBEQ1ZiSkNrSk9KQ3FuazRwR3BiOTl0WjhNb3B5aUtEWDdXV0Rpd1lLWGlFUU9laENyZ0toK2VKUStFUUhvMUxieS96Umx5ZjhUSWJmOVhTNWZ0SWI4STkyWXVnSDRheTJwTHVzb3JsN2RBb29uV3RNd1FTVGRPRnVRU0xUR0h5SUM4a3hTSVF1QTRod1UyV1VBb080L2dyQmNEYnNmV0VsU3pnK0pDb1lEb0VHTTFpeFNrSHpnRi93Rzd5OHNJYTNKN0pQQUdXdUZKU1FJYVUwMWlKSFVpWVA0ZTMzQnJQT0htRy9KTWFPZlRaVllSaHdHYXY4N3ZXS1BKOS9yU0g0SU9HTzVzSVRxZy9nZ3hYczRUT2FCQUVDYmVvT3NnZmwrRHJRU2hGcWNFSWh5eXQwTWJNdXNFa3g3NmlBWlhLTThCdlhpWkFHbEYrS2FJYmFhZFlwZW00YURncEpaUXo2WUpBQlY1VmNIQUpaMHY0RnhYNktHNVVwWXMwS25xamhSdWFnRVZnUGdsWUFsOWNpSGY4bWRVckpoMFF4OXZrREJ6Qnl3ZmJrWVFJR3dhaEEva2dsQVRzSHNEektBMEJBVGlQeVo0TkVEd0llb2EvdUZZS0tYTDJmMjRuUW9JZ2Q5UjN5UUNNVEZxd0lBZmRCV0k3K3lCNVpMRUNZTEVUZDg1WUpsKzJZQVVOb3NMSWVsL3hZbHU0SnNsNmJoTmhENml0NFdKQ3ZBMlpjNEd4bzczUmNnSmVPcUZtR1I2cmNDaExZQUN5R29qbUVZZGo1OUtuWit0SVFSaEg5SXZXQTJoaVJFakRlUkk5Q2x5N2ZNRjNFdFdSRmF3aFFJZjVJSndFNTZ3ZFRJWWR0N3RwOXlzMUs4Sm5vSnZvZDlXbjY4MlBOa1A0aFV5MW5kV2dzdEF0QkRNTFlONS82UEFjNURHTm9GNFNyWmZOKzQrSWhUOGpxd2cyQ3A4VGhJSjV2ZlNXQlhBVkNyV045U014REsrc2thT3Zob0FjOG1lNjU0cG1VQjNmMHd5dCtFOEZ5UkFHbVBsT0VvaVNEMnFndm1BS29PbTUyZkF1aVRESFN5SVJ4eCtsSTBReHhBRHViZkY1dmZmTW1TYWpyV2xQN25tWjNkU3krNHIvWnpBVUVIblE4UjcwSHNYbEsrUGdKc1c2OEc0WFlHWmowRVkyRVlBVENBVDZ0QWhtRTBEWGNDNGZhYXBjd01nQUlmTGIwa3V6VDlRbXc1dXdBQUlBQkpSRUZVU2krRWZlQUxrU3JwQm92YnJRRG5rbTh3QW84L0UzaStDQ3NaOThOQ3BBcDhjVWVrWnlCYXZJNEVUL1RuYUFrL1JRQ3lBWHk2dU5TUEEwaSt3TWVCNmVQQTVIRmdacTJ3cE5HSzNGVURBSG12M2ZTQ2U3YWZYOENCNFVORUVPb2xWaS8zb2Jhc3ROd0o5Y081Qk9CS0VRTXNBY2lmSFd6UkFpZ1dXQWxDbjVLMmJRWUFPZTFLTWpUSVIya1JVaEtWUzdJckxpYTB2KzN4d0hNWk1DYllOUDBLZkc3OXpBcUs1RHhPdnlFdVd1NlZENUtTSHkyWUFFUUFmcGFSZGw1VWt1VWN0SXBCbkNJSWw0cHNEMDNGdElJUDFBREFsQnVKTTQ3RXFxVVgzTFg5a1NCUWN1dXlmdEs3OHhVa0h5UStSTHFIWjNGdjFLY2dMajVrQVExczBRbzZJQTFuSGhOTFF6QThaeHZCWHVOeDhEY1M1VVlwTm5vWXhzQ25VSXF2Wm8wRjN3UFRNYTdIdjUzSE9KVmJTL2wrNWJ1bVg3ZCs1V0xFNDRoeElSSkIyTk1DcWo5aXh3dUU5MHN2V0NhSUE2YkFwOTU5RUtlV0NoQXlBMFBUT1YydW5HTVF2ZUNPN2JmcUhiY1M0ckpSN0V3cW53NUFXaEx1SW1nMnVGUUFYQVZzOFJHbW50VzQrZzJoQjNQNzlML0VKOXpHdnFyeE9QaWJpVmloQU9ncldRT2YvRUJmQmNzUE5CQnFXOUh2Nnp6R3FGem1vWHozQjlBZVBnWGlxNmJnaXY0WU9COVFIUzhBZnBrQUZNTWpyV0FjUUEwaU85WEppUXlBbm9zMnZWN0VTSE9PUWZXQ083WmY3RjQwbVpGUVNjUktBWUJhU1U2dkFWY1RnTjd4WEhpVUZwRFRNSzJkRmg1NjkxMkJUaURjdnBrQVRJWHpDTDRnM1dYVFo0anBHZmpvRi9vaWhMK2Z4KzB5V1VBQkx3SXd0WUtLSWFiZ0N6SFF2aTJnZ0JLbjBNY0VRRGFLVDVjR2tJT282U3V5WXpFZmpRQjBFTTVuWmdBUG94ZThvZjNzZ1NxQ1FNM2prZEZMdnBSdlIxMys3VVZSdWhVRlNhdk5PNm90d3A4OFpaMyt0NE02SEx0Y2g2T1Q5QUcvcTljbXRmLy9nVjFKRFljblEyelk2L1lha2ZTclUrUGcxTTQ1TnFQdDNJRXRvTTdXRkhva3lyV0trb29nbENNV0xZamlVWE10SzNnOFV6ZDFXTDNnRGUzdlJSQ29VRVlDd0d0WUZ4eHFnQTJFL2pJMjBGNWhobVFvZDk4QkhObmx4T1RpZzFhR2lEYW5PMjF5VjREeWdXdUI4WWVCNmZuQzlXRXRpS1ZWS2VFMFpHaVhXY3plSm9XTUlpZzVhOVY1REExQU5vS0RlRHlsWjlOU1h4eUFzaUthd3JRcW1DdjJIVmY1ZThhUm94ZmMxbjd4cytraEl0QVV2b2p2eVdyeXhWY1dKWmtzVlN5Wm9RUkEzZGNBb0h6YXg0R2oyd3R1NkZWS003Z01ndGkwMmpiVjQ3Nm9VSkpzMWovQWJBMW1RM1BtOGVUUnNvWkR0Uit4WktDaUVLbU1YVEllWEhQR2RoWUFyWDhGd0c0REdNRW5BSElLNHl2VDU4bldDMmI3M2NleGFaZ1dXYUVLZ1UxZ2pOYlBQN1B2T1lHc1VTQmt2M2hCdG1SV056eGpUazlSV2t0dnhwNlBPajB2QVJqWTlzV2tGZWw4Uld4ZWdqSUY0Ump3QU9uWldNUEJUR2pxdkhtc3p4Sk9CVUQzeHl6bkwyYnFST3ZvUDNOM3E4NGpHNEM3TS9QcGN2TUJlZjBjdlY5azZoWHYrMllubzVRZkdBclJiYUNDMG1XdjJZdEYzZWNlck5EaGtOWklJc1hRUnY1ZGxUdEdBREpTejJnRUUxRUpRTS8vMDI2SGRJRVpMQzhCNkEwdGswZzFKYThEdXpKZHBoUzgyUUJFWmo1ZGJqN2d4Wk41ZXIvSVpJKzY3cHNjZ0U3UWFET1VNeUMwV2I4K2dYanVSNEY1SjZZc2FYbkZoQm9BR0VWdlVoYjYwaklTZ0NRbm9oL09MQmd2SXJMOHY3RGRGa0VZTTVkdE5nOTd0dno1ekpxemRmSUJtSmxQbDVzUCtESlA1eHRXN3hmZm56ZWg3SCtaKzMrUnBreVdUMVl4dVVSSllWdHg2VDBmQ1RvY291UVY4NVZrSFJJR2VnRXVFdi9ZS3BrQS9KY2VWbUw4a3Y2dDUvOXB1NjJ0ZmlQV2NGUVZFYTBEWjlXY0xKRVB3TXg4dXZmbmpUOUlnWnlqOTR0L2xkZUEvUzl0TWFHYTlTTmRtc0l4YnZWc2NWSjFHU2NvTXQ0VVB3aEFzbU1aMGFYelFCc3ZkR1JCalF6MEZVcEVKUkFKUU9xNEtBbkJkeitzZmlQSjNiT1luOGZzeWt5VldNZmlOM0JPemNrUytRRE16S2U3T1cvODhhcVF6c2ZFNWtIMWZ2R2plUTB3QURvZG1WR3dPZWlNc1VxSHJHT25TNFVGeTlQL3dBRW9qa0VuSStJcU9JSlFOTGdwQ1hoY21MQXREL0Qra2dRRTIzNUw5M3RqK1lCcWdUWDlCaUNlVy9OZWRUNEFtUStZa1UvM3NienhCeW1RdVpobThnMVQrUWJWK3dXRmRqS08vVGUybUVGTmxDYjZnUEY3MDhWSjFUWEhnS2Q5MUduWnBEZmkxay9nTTJ2cVUzRFVuQ3VCbU5RZTNQOXZ3NnBlMjI5S092QjBLMWsrWlMrcm5yZk0yQWxBM0pNWnRhaC9FWktaVDNkcnh1RHoxTy95eEF3dTlKZ0p4cjNsUWZSKzhhYThCdXkvd2RXUVpBVmwrWnpDckczcTljL1lya21IeTNJUllyeUFBcUFrRUJJbG9wSnhOTlViRVIrZkEvSCsvK0FBZFA5UG1TOWRhemljSnlibTdtbEI4blIyZEkxSHZnVmtPbFpHUHQybk0yOUdDYW1jR1pqQXdsUSt2dnJWKzhYL3pHc0FBVWlMVlBwL3dkK3phVE1GV3crL2tBQTBHUVFucEN3NW1Ec0FNSXJjUkI1bUMvK01BZmZUd2dmd0tZMktmbUNaNlpJa1VTaHJ4WHhCWDR5WWFWOEh6bWNuMTNqVUE4Q01mRHFXWWVRY1NraFZPbDhVNnV4SDd4ZWtyc2c0OWg4b2lDRU5nQzVUVUc1dkt4eFQ4ZjJhUnRPdGNBS1Exczhzb1B1T1ZVSXdwY2hObEVFSU95TlNJcnJ2djNod25ja1dJWlBac25iY0R5elRwdmczbFU4bXBaUXFvenlmSzc0YWozd0FLaDFMZ3JzRDV0TXhpei9ua0dEMXNIcS9ZTkZPeGtFQWN1VzdvcW1YbGlzdVFPVDdWVjJqd2kva1RnajFSa29aaEJqZThaODNTQ0FFRUpaVzBDM2dmZjh0QURDdDRWQVNhV0lCSzBISTlxOEJGNXlVQU16SXA4dE54NUpnOWJCNnYvamREUFNSbnMwQldJWmVVaXRJbzlJaEhtaFhUdnpDUFFkZGNjblo3NlUxVi9JdkM0U0JDRnlnMjZERk5nN2MrK01oaGI2cWlDaWtUN1dWVW1yNmxZbjJuUkt5cmRaNTFHTUJsWkljMDdHVUJkTWpueTZYQ2lVbXBBNmo5NHZNWmJnQk1GbzU1MnB1MjdQWEFxWFR5QVVRY2l0T1FqQW05eFgwTjlwSXdJUG1TQ21INVF1UHFFUjBMNGtEWWdwOXpPVUw2Zll4a2JaY0ZjZXlBcmVBRjNHbFYrTlJEd0F6OHVrc25UM2ppSUxWU21wV05saE16ZStrOTR2TVpmZ0dBUEplSERqcENyZ00wMVRkcnk5T3p2bVlBekFxTFZXSXdFU2h3emJSd3dTRW4rTXFQNmJRSzV0WmxXeWhqQ0NDc0MxOVh2N2dPbkJSYmdwN2N1LzVBT3lWanFWTW1BNzVkSlo5bkhGMHlvaFdObGhNeEtuUyswWG1NdHdBbUZxNGltbllickVxTkpQYys5a2ZkNjJSS2gwT244cVY5aFhaOWFza0VQZ0FmSTU2emlvY1VnVmJ6R1QyOGxFdFJNb0t0ZzdsQkh0em5mWk5BK0NRK1hRV004azR1Z2xXSy9OTFlLelMrOFU5R1JlWEQwZy9UeXZoNE5lMTdZYjRaYnI2ZzZ5Ny9hTldjb1BwaktSVHNKSWFnczVJSndrRUF2NmVuMDVTNkdVQmZSV3NVRXhaeVZaVlFDUXdyZ043V2ZkZDQxR1BCY3pJcDhPRGVYZlRTYkJhNllZeGxZOC9wM3EvdWRjM0MralRidHZxdDJvYWRuQjJtNG9OZ01uMFcwcCtoWVdIV2J3Zzl5VS8wS2I5RUl5KzV5MmhpQ2l0NFVnS3lUZUFrTjhWYWxrNExlL2xkbE9OUno0QVdXQlJNNmZkSVBmSHN0dy9HK1NFNXJNblZRL2tBNUFrTEhTMGFrN1Y3cmVYZmhnQUNhQnFEdEQzZS9ubWM1azlrQS9BODBKUmVxK1UzOHpHVnAzT2JKby9CdkFPRDNkdHdpV2FyOXpFSHNnSElHbEZ1YnFTeDcrSmphMzZhbkxMY0R2dmd3QStORHBEZklMditxbHp1WHdBWHVTanJrS2VtbE8yZTNVMXVXVVluTDhkd0IvNWUyYXBjYTlMTnYrdnNRZnlBVWhlWDRWZ3VCK216SXNhRzludHF4aEY0WGJlM1FEK243L3VITEFXOXdRMXRibE1SUS9VQTBDYUhDN3BsWEVoK3E0VDBPV2NmaGxlWVRTSEJLMEVIL21pK2ZjUnVLUW40STZmV3Blb0I0QWV2Q3ozSE9PbTl5YjNGNW1CbFpCTmNsWUNqMWFSZnlmcmJnUENUUjZBeksrdkQ0Q3lnbFg3anBtTjdIWTY2ZDFFMGN0ZElyRUVFNHdFSU1sYW0rUGs3WUY2QU1qN0V3QVZiVTgydlRlckN3aEFYb3BKTjl6VkkrQVlyT2VVTExaZ0VyWTJ4OG5aQS9rQUpHV3IwbmFVV2RGcHkyY1Qrb0NXanBkakxGeEU1VXpZSUJCcEVVWDVuTG5sdkFrdGI3NlNQVkFmQU9VSHBpQU1tOTZic1Z0Q0FNYUtBTElDTXl4RHE2Y1hmeWNBK2IvbU9MbDZvRjRBaXFCUklFekJwNy9YMkFmMCtmaTFYSWlvTUlsQUkrQUlQSUdQbWVST1dWM2oxWnV2eXUyQitnSG9GZlppRFMybEMwTGlZNTJXVUFEa1FvVFRNSDFCRlNZUmRIb1JmS1N1NXY5cXJpek1IWVBUK3Z4NkFSaFN1RGNBenptRG81WkdIVDFQQUtZTXdReE1FMmppU28vZ0V3QnJycSt1NDFaT3krK29ENEJhQ2NzWFRQaVNJM2V5OHM0S0dvRzhRd0NNRk0rMGdnUWhMUjBCRjE5U1h1RC9heWFrejd1UjAvVHNNY3hnM1NqZnFXTkEwaHNyZ2Evb2phcS84V1BjQytZSWs0S2U0Q01TdUIyWFZodDFPajh6SWZYbFU4QnRVOERobVlSWFdkZnJkRjFmZ3IzK1M4QXQ0OENEMDREVmpYUVNETzcwUFRVbmFKNXVPQ3dzSUlGSFNTRnkxcEtQV0NEc1p4Q3B3OFVWZ0tTUHhMWE05MzdPenh4QWxqemNQQWJjc3dVNFFoNFYzVU44bUtvZUttL2J1NzhJZktKUWE4VkQ0OEN5bEhRaUwzTzMvcWc1UmYzMEJLQUNNdEpYalhLUWNmQlNLOERmcWMzS1ZDd3VOMlZGR1JubS95S1p0cTRSZTVpZnlRUWdNMkErQmVCM0dIYVpCbzVNQUl1ZTBsN0t0M2NDNHhodys1ZUw3VHVDa0prMWpCdHllcmJVZllHNUV4alovcHFyeEU1ZkFPck9xNVNtb3dWSXJScDFJeVQyUjYrZmcwYmdWWUc0Q3N5WmUyVXNhaU9HS1hyNFNmcDlrOEN4Q1lBRlNLeXZYZVkxbzFCeFF1eDkxeU10ZnNIUHV0Z25ueVV1VXZoYzBac2dVWGliK25Wa3E2K1pLYUFCSUhzZ1ZabnV3RDlzVm82NnJyUjRJbWRoTEdTUTh6UEwvSmdCUXhlVTFvdVdrTzlQVGdEemJnbVh4cnpNa2F0bDNrZWl2Zkc1eDRyNElSY3o1QmZrTzV2RVowa2dwSWZCWjh5S2psTDE3c3l5MHRNTmNPbjlkbDRGeTZkTEZhYmoxTXB2b3c5SWZ5K0k0TmxvOVh0K1pxVTlWZEpwcVpoNFFERHl4VXlZT1lKd0hEZytEaGdJL1dVVlpsN2FTRXQ5MytHTzlJYTJpdVpLT2ZBN2xocDlKcHZBVnk2MXcybU93TzVobUNnTUhDMUg5TzI0Z3U2VUQ5alArWm1idExSYVNzZWk5U0w0WERQYkFFaC9rR1EvcFNVY2MwbGJBcEZXYjY3bFFVaHBWbkxCc29LcXFaY2xGTW1VdHJ4UGN3eGwzWDd2T0NBdFlMU0NjdWdGUW1xaGRzc0g3SFUrUnpuamlPbFlYQTh3cWtPZmtJdFRBb20rb0t5Z2NhNEVTOGpZK04zejdmU0c0aGZVdHAzaWhVSHJ1VlNzRnkxaVJ2TlArMU43QTVCZEpBQ21WcEFnWlBoR095Q2lnRWpsUEx1ZG43a3ZGdE94dUI0ZzZPakQ4VVdMUmtDWkZSd3JMQ0VYSlFRaHAySyszN2xRZUJDUlgxQTdLUFF0bzFwckZFbVNZbjJtQjlFQXNPK2tZZms4S1FoWkY4eWpWejVncC9NenR5T1VqaVc5YkNVaEVCaEtSQ0NnU2lzNDV1US9QaFgveGZGV01nT25XdTJneEIwVEYvbzBrRVova0NETTFUcyszUkhZbndWVUw2WGhERnJBc3dmSUI2dzZQMU1yVHVsWTBzdW0xVklDZ2xLd0NFQUNxdlFGQ1VLM2dIY3NGUUNNL0lMYXlxUDFrOUpzaFZxcm5jTWFsT1lZdmdjR0F5Q3ZJd3VvZDhZQkpRbVpwbUdKZXlSd2tHdzRuOGpKT0pRTnczaWRMRmhNUk5CMFNnQVNUSnlLb3kvNGllWENlRmZKQlVlVjJTb0FjbEZ5UjBiYm0xT0hUVWlOMC9EVEF3RDd6UWVNNTJkcWo4VnNHRWtWRTJqS2V0RzdBRWhRMGZySkF2NlJDMHRyQzFza2wrSVdsTmluR0xiU2FaZzdNYzB4ZkE4TWJnRjFMUVYxejA4QTJHOCtvTTdQVkY5TXMyR1VFMGdReXArTHd1MnlhZ0xnUjlaYVlwa1N5cFE2YTZRMkRDcXpwa3ZpZXRYSUZkb1pmdWllR21jT0QwRGVQMEhFYkJoTndZUG1BL0w4ekpRc0FUQUtuZ3VFcVMrWFRxa0U0WWZXV3dDVUZaVGtzWUFZd1pmSUJlTjlUdzBjak93dThnRElacXNvU1N2aEVlUURpaUdZRm95V2lTRFJ5cFdnaTY5VVA1c2M1ZkljcXVTQ05lWHFlMlg5WkFIZk03S2hlMnBjT0IrQVQ0MSthTzVpUkQzUUFIQkVIZDljdHVpQkJvQU5Fa2JhQXcwQVI5cjl6Y1ViQURZWUdHa1BOQUFjYWZjM0YyOEEyR0JncEQzUUFIQ2szZDljdkFGZ2c0R1I5a0FEd0pGMmYzUHhCb0FOQmtiYUF3MEFSOXI5emNVYkFEWVlHR2tQTkFBY2FmYzNGMjhBMkdCZ3BEM1FBSENrM2Q5Y2ZPeHFZSjJhdTlSZFB0ZHAva2hvRU9sZ2xEWVQzOVYxUHpRRlhMc01YQWxndDlQQ3hKS1BidWZ5ZjgvS0hJUGZCUEFaQUJmNzlYYzVYUTBaUTFRNzM2ME5ieG9IcmxzRHZzNVpSc2dvMHVuZTA2Ynk2WDFtWnZ0UDk5UE5BcDRGNExzQlhBNWdqdzhFR1RlcWFHRjRRaHpRRjgwQ1g3Y0F2R0lkZURZQWZoZFoyc1RLVWNWcnBFN25kMzFONWdqOGUyZElvMm9zazdOWnBNZEswWjE5dHYrYko0RjlLOEQxQUNqOHlmTlNpa0hlZys1Wjk2OW01N1kvOC9aUCtkUExLWmhQL3JjQStBWUFGN2cxb1JVaEVNVXpGTXQ2ZVNKZlg3OGIyRGtQZk0waThHSUFYK3VXbEFNcHByZVVVRXJuOHAyZ3pUbCsyZmxnL3NEYlRrdklPaWsrQ1AyMC8vbXp3QVh6d0RjQ3VOVFBKZUZYcEVwTTZRRWpJSG0velRGOEQ3VDVnQVRZTlFDZTY5YUFsb1JUR3VsZkJFU0JTWU55eFI1Zy9CaHc3aEt3WndsNHZrOUxuTTVKbXNCelV5REdBWDNCOEcyM016L2c5QnVVYS8wSWl1dGZNa2o3endLbW5nQXVYU3ZPcFV2QVdZQnRGNEJUbnNwSWovTzh6UGFmN3FkdldJVHc2ZVpBMEpMUUVoS0VHZ3haaFVqL2R6M056U0t3YlI0NGV4bll2VktjeSttTTVLbTBKaHhJblV0ckdrbXpDUGljZzNXNUxNR2tRaVpaVG05eFM5WjMrNG0ybzhDNWM0WDE1cFRLVzJMYitmQ3g3V0x0all4enFpcWwyOUljdy9kQTVTcVlmNlJUVGlsZytsWUNJWG1JQ0tRNElLOXd4ZlNKWThBWks4Q3VGV0RuYW5FdWE5WlRBTXNhQ29nM0R0OTJPL012blJHQnRHd2txS1JtTUVrcUNhYSsyayswTFFEVGg0clA4OFVIajc0a0YxV2FBVG85UUhRN21tUDRIdWdZaHRFS2o0UEI2WlErRlMwaFFhaHBsZFB5YTFrWFRPcU5ZOERzY2dHK0hhdkF0dFVDdkJ4SW5pdHJrZ0w0bGNPMzNjN3NwQmRNM2tBdVNucTJueDlnUWZBaDRKeVZ3dnJ4d2VsMnozcDRhTWx6SDZETTJ6L2xUKzhhQitRL09UNEVFcWNrV1FTQmtHRDZFUUtRbkRDTHdCU25ZZ2NmMzJmWGlvR1VGYXdDNGVzeXU3Q1hYbkRQOXRPQ3N5RDRLTEIxcm1ndlg3emZidTJXRy9KdG1lMC8zVS92S3hCTkFNb2kwS2Nqa0FUQ04zSE9FcjNVQWpEcndPUDcxclhpeFlFa2VLTUZsU1g4b2N3UjZLVVhUSjdBYU5FMnRGOFdmQTRZZTdLdzFtd3ZYL3labitlS252Y3JmekM2SUsvT2JQL3BmbnBmQUdRbnlTb0lTQnFVWHlBQVNTMUFLMEpmYWdXWWNSRE9yQUY2NlR4WlFVN2pCT0ViTTBlZ0g3MWdjZ1hTRlpBVjU0TlF0ajlZY05JcGJPTkN5aDhZZ2k4Q1Zvc3BBcER1QjYzZzkyVzIvM1Evdlc4QXNxTTRnTElLQkJJSDhiY0p3TUNOTVg2OEJUcUJiOHM2c0dXdHNJQTZqd0RrNjYyWkk5Q3ZYakE1QTZOVmEydC9JQWljbkMvYUdWKzhUNzRJUVBtL0FtR3VCYys4L1ZQKzlJRUF5THNsQUtNVi9MZ0F5SVVJbmZuandQUXFNT09nSS9Ec3RRNU1yN1VBcU1GOFYyWVhEcW9YWE5sK0VRUTZOOXYyOWFLZGVzVXBXSlpiQVB5UG1lMC8zVThmR0lEc3NEaWQvcFVBU0N2Q2FYZ0ptRmd1QUVmZ0VYVDI3Z0RrdXdhVWcvbmJtU013akY3d2h2YkxoU0RMNVR3d3ZkUnFvOW9xSHpBQ2tDQjhVMmI3VC9mVGh3SWdPMDFUMUlNQ29BWnhHUmhiS29BWFFVY1FUamtJK2E0QjVlNUZ6akdzWHZDRzlnZHFyTEdGWXJwVkcvVXVIekJPdzIvTGFYeHpiaDQzREtlb0p3bEFIcUxuZFNzNHVkb0NvSUJIUUU0NUVQazNEdWl0bVlPUW94ZGN0cDgrckZ3SVdzR0ZZaUZGb0xHTmNoY0VRQzZlK09KQzVKMlo3VC9kVHgvYUFwWWRKMzdBeUpLL0RJd3ZGeFl2V3IwSXdFbi9IMU9wY281c3ZlRFVoU0FBRjRISnBRSmtXaXhwNmsybjRJWWZNR2YwYW1ESGV2Mkk4K2w0L1Vidk53OEVvenc3MndKZVBPSjh1bmQ3RWtLajl6dEtHQTEvN1d3QVRvNDRuNDVwV0kzZTcvQUFHUFdaMlFCa1lIQ1UrWFRNZkdHUW1ZSXhqZDd2cU9FMCtQWHpBVGppZkRyS3RUWjZ2NE1QL01seVJqNEFSNXhQRitWYXFaTEpGMVV6S2RQVjZQMmVMRERyM0k1OEFJNDRuMDdaTUFSYm8vZDc4Z011YldFK0FFZWNUOGU5WU9uMlVoZXUwZnM5dFVDWUQ4QVI1OU1wRzZiUit6MjFnS2ZXMWdOQXo0Z2VSVDVkVEVabzlINVBQUkRtQXpCbVJNOEJKenFmTGlZalNLS3IwZnM5ZFlCWUR3QkhtRTlYdFJmTXNJejA0YVFaMStqOW5weWdyQStBa3FzOHdmbDBCQ0NUV1JxOTM1TVRZTDFhVlE4QW8xemxBbkFpOCtrRVFHWlROWHEvdlliNzVQdC9mUUFjVVQ1ZEJHQ2o5M3Z5QWF4WGkrb0RvRkx5VDNBKzNSY2F2ZDllWTN4Uy96OGZnQ1FYL0xQUjNTT3prb241NWpnMWV5QWZnRDhNNE5jQVBENmFEbUJ0QjFlNE5NRE5jZXIxUUQ0QWJ3Ynd4d0RlNFV2UkU5d0haRzFnTlNYRExsd0xOY2VwMVFQNUFQeHp6d2o5SUlBUG5YaFQ1T1JjNUVZQ0E5SE5jV3IxUUQ0QW1SSDZGUUJNVFNaWkg5OFptRDVCaDVnMUZvcGlObnMxeDZuVEEva0F2QWZBRXdEdWRuSStFdlF4UGZrRXpZZmFDWFJTQmx1UU1CN1lIS2RHRCtRRHNCTkJILzkrQWtBb2JxVEFER0s3SW53MXg4bmZBL2tBN0VYUXQ4a2dyR0FHTWZCeFo1Q3Y1amk1ZXlBZmdMMEkrcjY4dVIwUW1VRm9CUVU4dmZOdnpYSHk5a0E5QU9Sb013N0NkR1FDam9VWkR3TDRrdi8rOE9aMWdKaEJJakdEZ01oM3ZUYXZCYzAzNS9SQVBnRDdKZWdqT0RmaGlNd2dvcWVKd05QUFRhQjZFenEvaHErc0I0QWNYZVhFUCtaaEdWbzl2UmltSVFENXY1b1BBWkN1cGdESTl3ZzgvcXovMVh6NTV1c3lleUFmZ01NUTlHVTJPcDRlQWNocE9JSlFRRXovVnVQbG02L0s3SUg2QU1qZ0d6ZGw2UXR5WDVqV2pwUUZldkYzbHEzeGY2eWhyT2xJQVVnUUNvalI4Z21FK2w5TmwyKytKck1INmdFZ1I1VUE1S1lzYytBWm1DYlFDRGkrSXZnRVFNb2IxWEJFQUhJYWpnQk1MViswa0Nkd3M2YUd1M3pxZmtWOUFHVHdqZnRnM0pSVlZSQXRIUUVYWC93YkFjb1hQNWQ1Q0lEOEdvSkt2cURBbG9LT29Jei95N3g4YzNwbUQ0emhhcXdqUnpDWXlRZzVncjJaZ3NGVEx3ZVdyOFhRZ3NYamJ3TFdybk50TWxLZ05vTEJtWkFhN1BUQ0F1WUlCbE12bFdRc3d3cjJVbFV3NDVqZERTeDhIYkQrQ3RkK0hWQ3dlUEtiZ0pWOWFBU0RNOFlnNTlUV0ZEeXNZUEJ0bVlLOTFJYk5PSGFQQS9NN2dVWEtYQTRoV0R6NzljQTgrVzBhd2VDTVVSaisxSFlmY0JqQllPNTRNTVkzdEdEdjhJM25tV1NIT3pZT0xKMExMUEdYQVFXTHozb0I4TVFVc0VhMTZrWXdPRzh3aGpoNzR5SmtVTUZnYnNObENmWU8wZXB3aXNzVlkzNGJzSHcyc0VJUmtBRUVpL2RjVTBTUDVxaEYxZ2dHNXczR0VHZFhyNEw1MTM0Rmc0a0FqdURRZ3IxRHREcWNVbVpFVHdBclp3QXJ1NEJWcXN2MEtWaDgvbzNGNHYwUVhaQkdNRGh2TUlZNHUzTVlodjk1WmgrQ3UxeEJjeHVPVS9IZmVESXE1Y3Y3RnV3ZG90WGhsQ0JYak9YWkFueXJPNEJWNmluMElWaDh3U3RMdVdDc1VBeXZFUXpPRzVBQnorNGVCK1IvZXdudS9rT1AvM0cvbDRrSlRFUmxsalF0SW90MmU1My9Jd08yT1BsNEZMdGNuQ3FBcDljYWhUNTZDQlpmK0xwU0xoaHoxTjVxQklQekJtVEFzL3NMUkhjVERLYmlOSGRCR0d5bU9DLzNoZ2xFdmdqQW5vSzlBN1k0K1hnaVY0elZXWURBcy9ldHhhdWJZUEZGUDFRa0x0Q0lQOG5lYUFTRDh3Wmt3TFA3QXlDL3RKTmc4TC94TE5CdStZQmRCWHNIYkhFRkFJTmNNVmFtZ2RXWkFvUnJmUGRYbThLaXRMZG1nWXZlV0FxKzJ5N2lNcWZ1UmpBNGIxQUdPTHQvQVBKTHF3U0QzK3k1VDF5STBBb1NiQXhNTXpHVjFvOC9NeTJybzJEdkFLMnQrR2dpVjR6ajQrM0FJd0RYdHdCclZKZXVFQ3plKzlhVzREdXQ0UHhrSWhZc2RldEdNRGh2b0RxY1BSZ0ErU1dwNE80dmVRNVV2L21BR3dSNzgrNnJRcTRZcTlQQU9pMmZBNC92QmtLdWRLVlU3Vlp3Nzd1S3ZXRnVaYnRjTU5iNXYwWXdPRzlnK2p4N2NBRHlpNlBnN2djY2dJeGxjQTVUS2hhRDAxeVlLQm1WRnBCWk1meC9tMkJ2bnkzdDhMR3FvcVRsaVpiVkkrZ01nSHduTUFuQ0lGaTg5N2NMQUFaNlF5ekZ6elNDd1hrRDFPUHM0UURJTDVYZ0xtazVKSGsvU0Q1Z0tkaWJkMzhWY3NWWUdtdUJUYUF6RUhMSGd5Q2Nhb2tCNy8xSWtVRVQ1SUt4d0Y1cEJJUHpCcWJQczRjSElDL0FhZXF2UEw5cG1IeEFFK3p0czZWZExDRC9sY2dWWTNVeVdEMEJqMVp3cWdDZ2dYQTdzUGZXQW9BSnZhRXRaQnJCNEx5eDZlZnNQQUR5Q3RtQ3ZmMDBzL05uT3NnVlkzbThCVFJaUFp1R0JVQUNkQXJZKzVsV0RxR21ZYklyTEhFeDBnZ0c1dzFPSDJmbkE3Q1BpelFmYVhxZ1V3ODBBR3l3TWRJZWFBQTQwdTV2THQ0QXNNSEFTSHVnQWVCSXU3KzVlQVBBQmdNajdZRUdnQ1B0L3ViaURRQWJESXkwQnhvQWpyVDdtNHMzQUd3d01OSWVhQUE0MHU1dkx0NEFzTUhBU0h1Z0FlQkl1Nys1ZUFQQUJnTWo3WUVHZ0NQdC91YmlEUUFiREl5MEI4WllOTWJrWCtaZWtwdUlpT1FyUGFyK3hzODg5SEpnNmpaZzVqQXd2Vlo4QitsbDlQbE81L0ZjL28rRUNqbkhmaTh6WWZrdk01dWxtcDRxSlhWcXg1ZGVENHpmQWt3L0NHeGRBWmdvSGZ1aDEzMVFrYUk1aHU4QnM0RHM4QjBBV0xuSVJHQ0JzRmZuODdKZmZETXdkak93NVI1ZzhnaXdaYTM0am5RUVV3RG85OXdCZko0VE03Q09pTmRsYWoyckEvamVWL3ZmRGVBVEFQNFVHSDhJMkxyYzZnYytTSHFZNG9NWjc0VlNLTTB4ZkErVVV6Qi9vQlVVQ0tNbDZ6U1EvUHNYcVpENUtRQy9BMHcvREV3Y0FjWVhnWW5Wd3Bwd0FEdUJrZWZuQ2ltOTBGbUJXWHduSzg3VWVuNTNCSThzYnV3cWF6OXA1VWduUWhCUytaTjF6RThBazB1dHZpQ3dxOERJOC9ueDVoaStCemI0Z0p6S1pFMVNFRlpaZ1M5LzJwV1IvZ1RBSjRISlE4REVNV0I4QVJoZkJzYVdDd0RxdXdRS3Z2TmdIWHZPY1lWYlBGSlBrdytkRHhDL1cxWTR0V0Rwdy9SbGdvNGxvMVQ0L0t4VGloRE5wSndqMy9VaU1MWGVtcHJqZmZDN2VXcHpETjhEbFlzUURpS3RWeHpFcW9Ia3lYOUhSaXpXK25JZ2FRbnZBaWFlQkNibUMwczR0Z1NNdTJyTWVQQVI5WDI1MmpYa2xhVEZVMTA4SzBNSGF2L252SjZaeFZWazlPSTdHUjJJWm9HUU5jL0hnYkhnSXdxSUxJVnVqdUY3b09NcVdGYXdDb1J4a2ZFSUI1Q1dna1JFQkNOZjl3TVRjOEE0UWNpQld5b0d6MTZyd05nYU1MNWVXS3BjdFlaTDNOK1RXTFgwZ3Z0dVAwSEhrMm4xNkpEeXhYbVZoZlUwcXl3YkpicjVHU3VYS3hBL3NWNVk5VVlXZG5qd3lTM3FLS2dhcldBNjlXZzZmalFPSUswSGFkbklqUFZGQitBaU1FNEF1aVVrQ0ZuRVN5Q1NrbUF1VTdDam0xNXdYKzJYMmlmQlJuOUE4bUtjVzJVRmpVTFZRY2dWRGw4MHU0MFNZaDc2M0ZmdnF1aExDeGl0b0JZVXNvSmZqWEt0dEJ5TXE5Q0tjSG40c1B1Q2JnWE5Kd3lXa0VDY3o1UTM3NlVYM0xObmNaeVFBQUFERWtsRVFWVDlmRmdJSnM2bEJCd3RuM1R0NkZwSXo0UldudVF4UGgyWElHem00Q3dROWhXSUZnQlRLMGdRSGlJQUpkZEtxMEVMUWgrS0wxcVVSNE12U0Vzb0VOSUtyZ0FMSE5pTW94Kzk0Szd0bDlxbm5NaW84TVNmNlNOd0dwWVZqQ0RrL0p1N2lzcTQ5NmZDcVgwQmtEZXFsV3dLd2ljMWdBUVNwekdSRW5GZ1JFejAxZUFMTHZ2cTJLZmk0NW02Y2YzcUJYZHNmeFJiSk1obzhkaW1xT2hFSzhjWFFScjlRVnB2UG9ETk1YUVA5QTNBQ0VMRnhQaCtqQUNrUDBmTElLRkNDUlJxS3VQVWRxamxDOW8wN0pad0tWTkhlQkM5NERRY1pPMFhBQWttZ290QWs5UVlyUjlmL0J2QnlZZk1TQVREVk16d1RYTU0zUU1EQVZBZ1ZIQ1o3L01hUUs0UVpVSGlOQ2JCUWxxVXc3NFlDYjdnY21Za2VsQzlZRmx3dlZ2N1JSQW9yVHVCa0VDVTlhc0NJRDkveDlCOTM1ell6eUtrcXBmaU5IeGNBMGdMUWd2QkFhUFZrQ3FtM2gyQXRDNW0vUnlFcXp3LzR4aEdMM2hEKytNbXNsZ3FDYmdVZkxLQWNScm1UbEJ6RE4wREExdEFYVWxXY0RtMUlPSUlKQWpsVC9GZDA1bGJGUUZ3amR0Z0djZXdlc0Z0N1JjL0d4OGlXalVDakdDVDFZdldUMU13Z1VxcmYzTkc0NXRUYmN1MGF4aW1XeDl4RU5jRVFIR2JjWUFFd3RTWFNxWTBnbkNkZ2V1TUkwY3Z1R3gvRlVHZ0Zod0VZclI4MFFja1dOK1gwZmptMUR3QVd2OFJnSkZpbEpaQnpuejBwUWcrQVpBQWxWV2gxR3ZHa2EwWHpCMGNDUWkzMGFTR1ZhOUFGNjJmTE9CN01ocmZuSm9Qd1BFUjU5UHgrbzNlNzZtTDVLd3AyRzU3eFBsMGt4YzNlcituTHZ5S3RMbWhmVUM3OFJIbjA4MU9ObnEvcHpjQVI1eFBSOW1SUnUvMzFJVmd2Z1VjY1Q0ZE5hb2J2ZC9UR1lBanpxZWp1bXFqOTNzNkEzREUrWFJVZzJWU0NqZGFHcjNmVXcrSStWUHdpUFBwcUpqTzhKMU53NDNlN3ltSHdIb0FLTUZkN1FFckFlRUU1Tk5KTWIzUit6M2xzR2NOemdmZ2lQUHBvbUo2by9kNzZvR3dQZ0NPS0o4dUtxWTNlcituS3dCSG1FK25vcVJHNy9mVUExOTlVL0FJOCtrRXdFYnY5M1FIb0VoWlRuQStuWXFTR3IzZkJvQXRhaXFCVUltZG01aFBKd0EyZXIrbkt3QkhuRStYMWdVelNiblIrejExd1BqL0FlQ3BQREQzdDdydkFBQUFBRWxGVGtTdVFtQ0NcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9zbWFhLmZyYWdcbnZhciBzbWFhX2RlZmF1bHQgPSBgdW5pZm9ybSBzYW1wbGVyMkQgd2VpZ2h0TWFwO3ZhcnlpbmcgdmVjMiB2T2Zmc2V0MDt2YXJ5aW5nIHZlYzIgdk9mZnNldDE7dm9pZCBtb3ZlYyhjb25zdCBpbiBidmVjMiBjLGlub3V0IHZlYzIgdmFyaWFibGUsY29uc3QgaW4gdmVjMiB2YWx1ZSl7aWYoYy54KXt2YXJpYWJsZS54PXZhbHVlLng7fWlmKGMueSl7dmFyaWFibGUueT12YWx1ZS55O319dm9pZCBtb3ZlYyhjb25zdCBpbiBidmVjNCBjLGlub3V0IHZlYzQgdmFyaWFibGUsY29uc3QgaW4gdmVjNCB2YWx1ZSl7bW92ZWMoYy54eSx2YXJpYWJsZS54eSx2YWx1ZS54eSk7bW92ZWMoYy56dyx2YXJpYWJsZS56dyx2YWx1ZS56dyk7fXZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWM0IGE7YS54PXRleHR1cmUyRCh3ZWlnaHRNYXAsdk9mZnNldDApLmE7YS55PXRleHR1cmUyRCh3ZWlnaHRNYXAsdk9mZnNldDEpLmc7YS53ej10ZXh0dXJlMkQod2VpZ2h0TWFwLHV2KS5yYjt2ZWM0IGNvbG9yPWlucHV0Q29sb3I7aWYoZG90KGEsdmVjNCgxLjApKT49MWUtNSl7Ym9vbCBoPW1heChhLngsYS56KT5tYXgoYS55LGEudyk7dmVjNCBibGVuZGluZ09mZnNldD12ZWM0KDAuMCxhLnksMC4wLGEudyk7dmVjMiBibGVuZGluZ1dlaWdodD1hLnl3O21vdmVjKGJ2ZWM0KGgpLGJsZW5kaW5nT2Zmc2V0LHZlYzQoYS54LDAuMCxhLnosMC4wKSk7bW92ZWMoYnZlYzIoaCksYmxlbmRpbmdXZWlnaHQsYS54eik7YmxlbmRpbmdXZWlnaHQvPWRvdChibGVuZGluZ1dlaWdodCx2ZWMyKDEuMCkpO3ZlYzQgYmxlbmRpbmdDb29yZD1ibGVuZGluZ09mZnNldCp2ZWM0KHRleGVsU2l6ZSwtdGV4ZWxTaXplKSt1di54eXh5O2NvbG9yPWJsZW5kaW5nV2VpZ2h0LngqdGV4dHVyZTJEKGlucHV0QnVmZmVyLGJsZW5kaW5nQ29vcmQueHkpO2NvbG9yKz1ibGVuZGluZ1dlaWdodC55KnRleHR1cmUyRChpbnB1dEJ1ZmZlcixibGVuZGluZ0Nvb3JkLnp3KTt9b3V0cHV0Q29sb3I9Y29sb3I7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvc21hYS52ZXJ0XG52YXIgc21hYV9kZWZhdWx0MiA9IGB2YXJ5aW5nIHZlYzIgdk9mZnNldDA7dmFyeWluZyB2ZWMyIHZPZmZzZXQxO3ZvaWQgbWFpblN1cHBvcnQoY29uc3QgaW4gdmVjMiB1dil7dk9mZnNldDA9dXYrdGV4ZWxTaXplKnZlYzIoMS4wLDAuMCk7dk9mZnNldDE9dXYrdGV4ZWxTaXplKnZlYzIoMC4wLDEuMCk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL1NNQUFFZmZlY3QuanNcbnZhciBTTUFBRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBTTUFBIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TUkNdIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge1NNQUFQcmVzZXR9IFtvcHRpb25zLnByZXNldD1TTUFBUHJlc2V0Lk1FRElVTV0gLSBUaGUgcXVhbGl0eSBwcmVzZXQuXG4gICAqIEBwYXJhbSB7RWRnZURldGVjdGlvbk1vZGV9IFtvcHRpb25zLmVkZ2VEZXRlY3Rpb25Nb2RlPUVkZ2VEZXRlY3Rpb25Nb2RlLkNPTE9SXSAtIFRoZSBlZGdlIGRldGVjdGlvbiBtb2RlLlxuICAgKiBAcGFyYW0ge1ByZWRpY2F0aW9uTW9kZX0gW29wdGlvbnMucHJlZGljYXRpb25Nb2RlPVByZWRpY2F0aW9uTW9kZS5ESVNBQkxFRF0gLSBUaGUgcHJlZGljYXRpb24gbW9kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsXG4gICAgcHJlc2V0ID0gU01BQVByZXNldC5NRURJVU0sXG4gICAgZWRnZURldGVjdGlvbk1vZGUgPSBFZGdlRGV0ZWN0aW9uTW9kZS5DT0xPUixcbiAgICBwcmVkaWNhdGlvbk1vZGUgPSBQcmVkaWNhdGlvbk1vZGUuRElTQUJMRURcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJTTUFBRWZmZWN0XCIsIHNtYWFfZGVmYXVsdCwge1xuICAgICAgdmVydGV4U2hhZGVyOiBzbWFhX2RlZmF1bHQyLFxuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIGF0dHJpYnV0ZXM6IEVmZmVjdEF0dHJpYnV0ZS5DT05WT0xVVElPTiB8IEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIndlaWdodE1hcFwiLCBuZXcgVW5pZm9ybTM4KG51bGwpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICBsZXQgc2VhcmNoSW1hZ2UsIGFyZWFJbWFnZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNlYXJjaEltYWdlID0gYXJndW1lbnRzWzBdO1xuICAgICAgYXJlYUltYWdlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHByZXNldCA9IGFyZ3VtZW50c1syXTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykge1xuICAgICAgICBlZGdlRGV0ZWN0aW9uTW9kZSA9IGFyZ3VtZW50c1szXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRFZGdlcyA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDE0KDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMudGV4dHVyZS5uYW1lID0gXCJTTUFBLkVkZ2VzXCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRXZWlnaHRzID0gdGhpcy5yZW5kZXJUYXJnZXRFZGdlcy5jbG9uZSgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cy50ZXh0dXJlLm5hbWUgPSBcIlNNQUEuV2VpZ2h0c1wiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwid2VpZ2h0TWFwXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRXZWlnaHRzLnRleHR1cmU7XG4gICAgdGhpcy5jbGVhclBhc3MgPSBuZXcgQ2xlYXJQYXNzKHRydWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgdGhpcy5jbGVhclBhc3Mub3ZlcnJpZGVDbGVhckNvbG9yID0gbmV3IENvbG9yOCgwKTtcbiAgICB0aGlzLmNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQWxwaGEgPSAxO1xuICAgIHRoaXMuZWRnZURldGVjdGlvblBhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgRWRnZURldGVjdGlvbk1hdGVyaWFsKCkpO1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsLmVkZ2VEZXRlY3Rpb25Nb2RlID0gZWRnZURldGVjdGlvbk1vZGU7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWwucHJlZGljYXRpb25Nb2RlID0gcHJlZGljYXRpb25Nb2RlO1xuICAgIHRoaXMud2VpZ2h0c1Bhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgU01BQVdlaWdodHNNYXRlcmlhbCgpKTtcbiAgICBjb25zdCBsb2FkaW5nTWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcigpO1xuICAgIGxvYWRpbmdNYW5hZ2VyLm9uTG9hZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHNlYXJjaFRleHR1cmUgPSBuZXcgVGV4dHVyZTMoc2VhcmNoSW1hZ2UpO1xuICAgICAgc2VhcmNoVGV4dHVyZS5uYW1lID0gXCJTTUFBLlNlYXJjaFwiO1xuICAgICAgc2VhcmNoVGV4dHVyZS5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyNDtcbiAgICAgIHNlYXJjaFRleHR1cmUubWluRmlsdGVyID0gTmVhcmVzdEZpbHRlcjQ7XG4gICAgICBzZWFyY2hUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgICAgc2VhcmNoVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICBzZWFyY2hUZXh0dXJlLmZsaXBZID0gdHJ1ZTtcbiAgICAgIHRoaXMud2VpZ2h0c01hdGVyaWFsLnNlYXJjaFRleHR1cmUgPSBzZWFyY2hUZXh0dXJlO1xuICAgICAgY29uc3QgYXJlYVRleHR1cmUgPSBuZXcgVGV4dHVyZTMoYXJlYUltYWdlKTtcbiAgICAgIGFyZWFUZXh0dXJlLm5hbWUgPSBcIlNNQUEuQXJlYVwiO1xuICAgICAgYXJlYVRleHR1cmUubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyNTtcbiAgICAgIGFyZWFUZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjU7XG4gICAgICBhcmVhVGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgIGFyZWFUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIGFyZWFUZXh0dXJlLmZsaXBZID0gZmFsc2U7XG4gICAgICB0aGlzLndlaWdodHNNYXRlcmlhbC5hcmVhVGV4dHVyZSA9IGFyZWFUZXh0dXJlO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJsb2FkXCIgfSk7XG4gICAgfTtcbiAgICBsb2FkaW5nTWFuYWdlci5pdGVtU3RhcnQoXCJzZWFyY2hcIik7XG4gICAgbG9hZGluZ01hbmFnZXIuaXRlbVN0YXJ0KFwiYXJlYVwiKTtcbiAgICBpZiAoc2VhcmNoSW1hZ2UgIT09IHZvaWQgMCAmJiBhcmVhSW1hZ2UgIT09IHZvaWQgMCkge1xuICAgICAgbG9hZGluZ01hbmFnZXIuaXRlbUVuZChcInNlYXJjaFwiKTtcbiAgICAgIGxvYWRpbmdNYW5hZ2VyLml0ZW1FbmQoXCJhcmVhXCIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEltYWdlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBzZWFyY2hJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgYXJlYUltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBzZWFyY2hJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBsb2FkaW5nTWFuYWdlci5pdGVtRW5kKFwic2VhcmNoXCIpKTtcbiAgICAgIGFyZWFJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBsb2FkaW5nTWFuYWdlci5pdGVtRW5kKFwiYXJlYVwiKSk7XG4gICAgICBzZWFyY2hJbWFnZS5zcmMgPSBzZWFyY2hJbWFnZURhdGFVUkxfZGVmYXVsdDtcbiAgICAgIGFyZWFJbWFnZS5zcmMgPSBhcmVhSW1hZ2VEYXRhVVJMX2RlZmF1bHQ7XG4gICAgfVxuICAgIHRoaXMuYXBwbHlQcmVzZXQocHJlc2V0KTtcbiAgfVxuICAvKipcbiAgICogVGhlIGVkZ2VzIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IGVkZ2VzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXRFZGdlcy50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGdlcyB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZWRnZXNUZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0RWRnZXNUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VzVGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGVkZ2Ugd2VpZ2h0cyB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB3ZWlnaHRzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXRXZWlnaHRzLnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkZ2Ugd2VpZ2h0cyB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugd2VpZ2h0c1RleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRXZWlnaHRzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy53ZWlnaHRzVGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGVkZ2UgZGV0ZWN0aW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7RWRnZURldGVjdGlvbk1hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IGVkZ2VEZXRlY3Rpb25NYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlRGV0ZWN0aW9uUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIGRldGVjdGlvbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge0VkZ2VEZXRlY3Rpb25NYXRlcmlhbH1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVkZ2VEZXRlY3Rpb25NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGNvbG9yRWRnZXNNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkZ2UgZGV0ZWN0aW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZWRnZURldGVjdGlvbk1hdGVyaWFsIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0VkZ2VEZXRlY3Rpb25NYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0RWRnZURldGVjdGlvbk1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VEZXRlY3Rpb25NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGVkZ2Ugd2VpZ2h0cyBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge1NNQUFXZWlnaHRzTWF0ZXJpYWx9XG4gICAqL1xuICBnZXQgd2VpZ2h0c01hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLndlaWdodHNQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRnZSB3ZWlnaHRzIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugd2VpZ2h0c01hdGVyaWFsIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1NNQUFXZWlnaHRzTWF0ZXJpYWx9IFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIGdldFdlaWdodHNNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy53ZWlnaHRzTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGVkZ2UgZGV0ZWN0aW9uIHNlbnNpdGl2aXR5LlxuICAgKlxuICAgKiBTZWUge0BsaW5rIEVkZ2VEZXRlY3Rpb25NYXRlcmlhbCNzZXRFZGdlRGV0ZWN0aW9uVGhyZXNob2xkfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZWRnZURldGVjdGlvbk1hdGVyaWFsIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGQgLSBUaGUgZWRnZSBkZXRlY3Rpb24gc2Vuc2l0aXZpdHkuIFJhbmdlOiBbMC4wNSwgMC41XS5cbiAgICovXG4gIHNldEVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQodGhyZXNob2xkKSB7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuZWRnZURldGVjdGlvblRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWF4aW11bSBhbW91bnQgb2YgaG9yaXpvbnRhbC92ZXJ0aWNhbCBzZWFyY2ggc3RlcHMuXG4gICAqXG4gICAqIFNlZSB7QGxpbmsgU01BQVdlaWdodHNNYXRlcmlhbCNzZXRPcnRob2dvbmFsU2VhcmNoU3RlcHN9IGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB3ZWlnaHRzTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBzIC0gVGhlIHNlYXJjaCBzdGVwcy4gUmFuZ2U6IFswLCAxMTJdLlxuICAgKi9cbiAgc2V0T3J0aG9nb25hbFNlYXJjaFN0ZXBzKHN0ZXBzKSB7XG4gICAgdGhpcy53ZWlnaHRzTWF0ZXJpYWwub3J0aG9nb25hbFNlYXJjaFN0ZXBzID0gc3RlcHM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGdpdmVuIHF1YWxpdHkgcHJlc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1NNQUFQcmVzZXR9IHByZXNldCAtIFRoZSBwcmVzZXQuXG4gICAqL1xuICBhcHBseVByZXNldChwcmVzZXQpIHtcbiAgICBjb25zdCBlZGdlRGV0ZWN0aW9uTWF0ZXJpYWwgPSB0aGlzLmVkZ2VEZXRlY3Rpb25NYXRlcmlhbDtcbiAgICBjb25zdCB3ZWlnaHRzTWF0ZXJpYWwgPSB0aGlzLndlaWdodHNNYXRlcmlhbDtcbiAgICBzd2l0Y2ggKHByZXNldCkge1xuICAgICAgY2FzZSBTTUFBUHJlc2V0LkxPVzpcbiAgICAgICAgZWRnZURldGVjdGlvbk1hdGVyaWFsLmVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQgPSAwLjE1O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwub3J0aG9nb25hbFNlYXJjaFN0ZXBzID0gNDtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmRpYWdvbmFsRGV0ZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5jb3JuZXJEZXRlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNNQUFQcmVzZXQuTUVESVVNOlxuICAgICAgICBlZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuZWRnZURldGVjdGlvblRocmVzaG9sZCA9IDAuMTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLm9ydGhvZ29uYWxTZWFyY2hTdGVwcyA9IDg7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5kaWFnb25hbERldGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuY29ybmVyRGV0ZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTTUFBUHJlc2V0LkhJR0g6XG4gICAgICAgIGVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5lZGdlRGV0ZWN0aW9uVGhyZXNob2xkID0gMC4xO1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwub3J0aG9nb25hbFNlYXJjaFN0ZXBzID0gMTY7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5kaWFnb25hbFNlYXJjaFN0ZXBzID0gODtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmNvcm5lclJvdW5kaW5nID0gMjU7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5kaWFnb25hbERldGVjdGlvbiA9IHRydWU7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5jb3JuZXJEZXRlY3Rpb24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU01BQVByZXNldC5VTFRSQTpcbiAgICAgICAgZWRnZURldGVjdGlvbk1hdGVyaWFsLmVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQgPSAwLjA1O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwub3J0aG9nb25hbFNlYXJjaFN0ZXBzID0gMzI7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5kaWFnb25hbFNlYXJjaFN0ZXBzID0gMTY7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5jb3JuZXJSb3VuZGluZyA9IDI1O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuZGlhZ29uYWxEZXRlY3Rpb24gPSB0cnVlO1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuY29ybmVyRGV0ZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc5KSB7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuZGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICB0aGlzLmNsZWFyUGFzcy5yZW5kZXIocmVuZGVyZXIsIHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMpO1xuICAgIHRoaXMuZWRnZURldGVjdGlvblBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgdGhpcy5yZW5kZXJUYXJnZXRFZGdlcyk7XG4gICAgdGhpcy53ZWlnaHRzUGFzcy5yZW5kZXIocmVuZGVyZXIsIHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMsIHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cyk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMud2VpZ2h0c01hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRFZGdlcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGludGVybmFsIHJlbmRlciB0YXJnZXRzIGFuZCB0ZXh0dXJlcy5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3QgeyBzZWFyY2hUZXh0dXJlLCBhcmVhVGV4dHVyZSB9ID0gdGhpcy53ZWlnaHRzTWF0ZXJpYWw7XG4gICAgaWYgKHNlYXJjaFRleHR1cmUgIT09IG51bGwgJiYgYXJlYVRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgIHNlYXJjaFRleHR1cmUuZGlzcG9zZSgpO1xuICAgICAgYXJlYVRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBTTUFBIHNlYXJjaCBpbWFnZSwgZW5jb2RlZCBhcyBhIGJhc2U2NCBkYXRhIFVSTC5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHN0YXRpYyBnZXQgc2VhcmNoSW1hZ2VEYXRhVVJMKCkge1xuICAgIHJldHVybiBzZWFyY2hJbWFnZURhdGFVUkxfZGVmYXVsdDtcbiAgfVxuICAvKipcbiAgICogVGhlIFNNQUEgYXJlYSBpbWFnZSwgZW5jb2RlZCBhcyBhIGJhc2U2NCBkYXRhIFVSTC5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHN0YXRpYyBnZXQgYXJlYUltYWdlRGF0YVVSTCgpIHtcbiAgICByZXR1cm4gYXJlYUltYWdlRGF0YVVSTF9kZWZhdWx0O1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9TU0FPRWZmZWN0LmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzEzLCBDb2xvciBhcyBDb2xvcjksIFJlcGVhdFdyYXBwaW5nIGFzIFJlcGVhdFdyYXBwaW5nNCwgUkdCQUZvcm1hdCBhcyBSR0JBRm9ybWF0NCwgVW5pZm9ybSBhcyBVbmlmb3JtNDEsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTYgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9TU0FPTWF0ZXJpYWwuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTAsIE1hdHJpeDQgYXMgTWF0cml4NDIsIE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzE1LCBQZXJzcGVjdGl2ZUNhbWVyYSBhcyBQZXJzcGVjdGl2ZUNhbWVyYTQsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMTYsIFVuaWZvcm0gYXMgVW5pZm9ybTM5LCBWZWN0b3IyIGFzIFZlY3RvcjIyMSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvc3Nhby5mcmFnXG52YXIgc3Nhb19kZWZhdWx0ID0gYCNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8cGFja2luZz5cbiNpZmRlZiBOT1JNQUxfREVQVEhcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgbm9ybWFsRGVwdGhCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcbiNlbmRpZlxuZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe3JldHVybiB0ZXh0dXJlMkQobm9ybWFsRGVwdGhCdWZmZXIsdXYpLmE7fVxuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbm9ybWFsQnVmZmVyO1xuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbGlmIGRlZmluZWQoR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gpXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xuI2VuZGlmXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXG5yZXR1cm4gdW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KSk7XG4jZWxzZVxucmV0dXJuIHRleHR1cmUyRChkZXB0aEJ1ZmZlcix1dikucjtcbiNlbmRpZlxufVxuI2VuZGlmXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIG5vaXNlVGV4dHVyZTt1bmlmb3JtIG1hdDQgaW52ZXJzZVByb2plY3Rpb25NYXRyaXg7dW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7dW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt1bmlmb3JtIHZlYzIgY2FtZXJhTmVhckZhcjt1bmlmb3JtIGZsb2F0IGludGVuc2l0eTt1bmlmb3JtIGZsb2F0IG1pblJhZGl1c1NjYWxlO3VuaWZvcm0gZmxvYXQgZmFkZTt1bmlmb3JtIGZsb2F0IGJpYXM7dW5pZm9ybSB2ZWMyIGRpc3RhbmNlQ3V0b2ZmO3VuaWZvcm0gdmVjMiBwcm94aW1pdHlDdXRvZmY7dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzIgdlV2MjtmbG9hdCBnZXRWaWV3Wihjb25zdCBpbiBmbG9hdCBkZXB0aCl7XG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXG5yZXR1cm4gcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7XG4jZWxzZVxucmV0dXJuIG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyRmFyLngsY2FtZXJhTmVhckZhci55KTtcbiNlbmRpZlxufXZlYzMgZ2V0Vmlld1Bvc2l0aW9uKGNvbnN0IGluIHZlYzIgc2NyZWVuUG9zaXRpb24sY29uc3QgaW4gZmxvYXQgZGVwdGgsY29uc3QgaW4gZmxvYXQgdmlld1ope3ZlYzQgY2xpcFBvc2l0aW9uPXZlYzQodmVjMyhzY3JlZW5Qb3NpdGlvbixkZXB0aCkqMi4wLTEuMCwxLjApO2Zsb2F0IGNsaXBXPXByb2plY3Rpb25NYXRyaXhbMl1bM10qdmlld1orcHJvamVjdGlvbk1hdHJpeFszXVszXTtjbGlwUG9zaXRpb24qPWNsaXBXO3JldHVybihpbnZlcnNlUHJvamVjdGlvbk1hdHJpeCpjbGlwUG9zaXRpb24pLnh5ejt9ZmxvYXQgZ2V0QW1iaWVudE9jY2x1c2lvbihjb25zdCBpbiB2ZWMzIHAsY29uc3QgaW4gdmVjMyBuLGNvbnN0IGluIGZsb2F0IGRlcHRoLGNvbnN0IGluIHZlYzIgdXYpe2Zsb2F0IHJhZGl1c1NjYWxlPTEuMC1zbW9vdGhzdGVwKDAuMCxkaXN0YW5jZUN1dG9mZi55LGRlcHRoKTtyYWRpdXNTY2FsZT1yYWRpdXNTY2FsZSooMS4wLW1pblJhZGl1c1NjYWxlKSttaW5SYWRpdXNTY2FsZTtmbG9hdCByYWRpdXM9UkFESVVTKnJhZGl1c1NjYWxlO2Zsb2F0IG5vaXNlPXRleHR1cmUyRChub2lzZVRleHR1cmUsdlV2MikucjtmbG9hdCBiYXNlQW5nbGU9bm9pc2UqUEkyO2Zsb2F0IHJpbmdzPVNQSVJBTF9UVVJOUypQSTI7ZmxvYXQgb2NjbHVzaW9uPTAuMDtpbnQgdGFwcz0wO2ZvcihpbnQgaT0wO2k8U0FNUExFU19JTlQ7KytpKXtmbG9hdCBhbHBoYT0oZmxvYXQoaSkrMC41KSpJTlZfU0FNUExFU19GTE9BVDtmbG9hdCBhbmdsZT1hbHBoYSpyaW5ncytiYXNlQW5nbGU7dmVjMiByb3RhdGlvbj12ZWMyKGNvcyhhbmdsZSksc2luKGFuZ2xlKSk7dmVjMiBjb29yZHM9YWxwaGEqcmFkaXVzKnJvdGF0aW9uKnRleGVsU2l6ZSt1djtpZihjb29yZHMuczwwLjB8fGNvb3Jkcy5zPjEuMHx8Y29vcmRzLnQ8MC4wfHxjb29yZHMudD4xLjApe2NvbnRpbnVlO31mbG9hdCBzYW1wbGVEZXB0aD1yZWFkRGVwdGgoY29vcmRzKTtmbG9hdCB2aWV3Wj1nZXRWaWV3WihzYW1wbGVEZXB0aCk7XG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXG5mbG9hdCBsaW5lYXJTYW1wbGVEZXB0aD12aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgodmlld1osY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7XG4jZWxzZVxuZmxvYXQgbGluZWFyU2FtcGxlRGVwdGg9c2FtcGxlRGVwdGg7XG4jZW5kaWZcbmZsb2F0IHByb3hpbWl0eT1hYnMoZGVwdGgtbGluZWFyU2FtcGxlRGVwdGgpO2lmKHByb3hpbWl0eTxwcm94aW1pdHlDdXRvZmYueSl7ZmxvYXQgZmFsbG9mZj0xLjAtc21vb3Roc3RlcChwcm94aW1pdHlDdXRvZmYueCxwcm94aW1pdHlDdXRvZmYueSxwcm94aW1pdHkpO3ZlYzMgUT1nZXRWaWV3UG9zaXRpb24oY29vcmRzLHNhbXBsZURlcHRoLHZpZXdaKTt2ZWMzIHY9US1wO2Zsb2F0IHZ2PWRvdCh2LHYpO2Zsb2F0IHZuPWRvdCh2LG4pLWJpYXM7ZmxvYXQgZj1tYXgoUkFESVVTX1NRLXZ2LDAuMCkvUkFESVVTX1NRO29jY2x1c2lvbis9KGYqZipmKm1heCh2bi8oZmFkZSt2diksMC4wKSkqZmFsbG9mZjt9Kyt0YXBzO31yZXR1cm4gb2NjbHVzaW9uLyg0LjAqbWF4KGZsb2F0KHRhcHMpLDEuMCkpO312b2lkIG1haW4oKXtcbiNpZmRlZiBOT1JNQUxfREVQVEhcbnZlYzQgbm9ybWFsRGVwdGg9dGV4dHVyZTJEKG5vcm1hbERlcHRoQnVmZmVyLHZVdik7XG4jZWxzZVxudmVjNCBub3JtYWxEZXB0aD12ZWM0KHRleHR1cmUyRChub3JtYWxCdWZmZXIsdlV2KS54eXoscmVhZERlcHRoKHZVdikpO1xuI2VuZGlmXG5mbG9hdCBhbz0wLjA7ZmxvYXQgZGVwdGg9bm9ybWFsRGVwdGguYTtmbG9hdCB2aWV3Wj1nZXRWaWV3WihkZXB0aCk7XG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXG5mbG9hdCBsaW5lYXJEZXB0aD12aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgodmlld1osY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7XG4jZWxzZVxuZmxvYXQgbGluZWFyRGVwdGg9ZGVwdGg7XG4jZW5kaWZcbmlmKGxpbmVhckRlcHRoPGRpc3RhbmNlQ3V0b2ZmLnkpe3ZlYzMgdmlld1Bvc2l0aW9uPWdldFZpZXdQb3NpdGlvbih2VXYsZGVwdGgsdmlld1opO3ZlYzMgdmlld05vcm1hbD11bnBhY2tSR0JUb05vcm1hbChub3JtYWxEZXB0aC5yZ2IpO2FvKz1nZXRBbWJpZW50T2NjbHVzaW9uKHZpZXdQb3NpdGlvbix2aWV3Tm9ybWFsLGxpbmVhckRlcHRoLHZVdik7ZmxvYXQgZD1zbW9vdGhzdGVwKGRpc3RhbmNlQ3V0b2ZmLngsZGlzdGFuY2VDdXRvZmYueSxsaW5lYXJEZXB0aCk7YW89bWl4KGFvLDAuMCxkKTtcbiNpZmRlZiBMRUdBQ1lfSU5URU5TSVRZXG5hbz1jbGFtcCgxLjAtcG93KDEuMC1hbyxhYnMoaW50ZW5zaXR5KSksMC4wLDEuMCk7XG4jZW5kaWZcbn1nbF9GcmFnQ29sb3Iucj1hbzt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL3NzYW8udmVydFxudmFyIHNzYW9fZGVmYXVsdDIgPSBgdW5pZm9ybSB2ZWMyIG5vaXNlU2NhbGU7dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzIgdlV2Mjt2b2lkIG1haW4oKXt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTt2VXYyPXZVdipub2lzZVNjYWxlO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvU1NBT01hdGVyaWFsLmpzXG52YXIgU1NBT01hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDE2IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgU1NBTyBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FtZXJhKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJTU0FPTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgU0FNUExFU19JTlQ6IFwiMFwiLFxuICAgICAgICBJTlZfU0FNUExFU19GTE9BVDogXCIwLjBcIixcbiAgICAgICAgU1BJUkFMX1RVUk5TOiBcIjAuMFwiLFxuICAgICAgICBSQURJVVM6IFwiMS4wXCIsXG4gICAgICAgIFJBRElVU19TUTogXCIxLjBcIixcbiAgICAgICAgRElTVEFOQ0VfU0NBTElORzogXCIxXCIsXG4gICAgICAgIERFUFRIX1BBQ0tJTkc6IFwiMFwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMzkobnVsbCksXG4gICAgICAgIG5vcm1hbEJ1ZmZlcjogbmV3IFVuaWZvcm0zOShudWxsKSxcbiAgICAgICAgbm9ybWFsRGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMzkobnVsbCksXG4gICAgICAgIG5vaXNlVGV4dHVyZTogbmV3IFVuaWZvcm0zOShudWxsKSxcbiAgICAgICAgaW52ZXJzZVByb2plY3Rpb25NYXRyaXg6IG5ldyBVbmlmb3JtMzkobmV3IE1hdHJpeDQyKCkpLFxuICAgICAgICBwcm9qZWN0aW9uTWF0cml4OiBuZXcgVW5pZm9ybTM5KG5ldyBNYXRyaXg0MigpKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTM5KG5ldyBWZWN0b3IyMjEoKSksXG4gICAgICAgIGNhbWVyYU5lYXJGYXI6IG5ldyBVbmlmb3JtMzkobmV3IFZlY3RvcjIyMSgpKSxcbiAgICAgICAgZGlzdGFuY2VDdXRvZmY6IG5ldyBVbmlmb3JtMzkobmV3IFZlY3RvcjIyMSgpKSxcbiAgICAgICAgcHJveGltaXR5Q3V0b2ZmOiBuZXcgVW5pZm9ybTM5KG5ldyBWZWN0b3IyMjEoKSksXG4gICAgICAgIG5vaXNlU2NhbGU6IG5ldyBVbmlmb3JtMzkobmV3IFZlY3RvcjIyMSgpKSxcbiAgICAgICAgbWluUmFkaXVzU2NhbGU6IG5ldyBVbmlmb3JtMzkoMC4zMyksXG4gICAgICAgIGludGVuc2l0eTogbmV3IFVuaWZvcm0zOSgxKSxcbiAgICAgICAgZmFkZTogbmV3IFVuaWZvcm0zOSgwLjAxKSxcbiAgICAgICAgYmlhczogbmV3IFVuaWZvcm0zOSgwKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMTUsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBzc2FvX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHNzYW9fZGVmYXVsdDJcbiAgICB9KTtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IG5ldyBWZWN0b3IyMjEoKTtcbiAgICB0aGlzLnIgPSAxO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBuZWFyIHBsYW5lIHNldHRpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgbmVhcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyRmFyLnZhbHVlLng7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGZhciBwbGFuZSBzZXR0aW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IGZhcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyRmFyLnZhbHVlLnk7XG4gIH1cbiAgLyoqXG4gICAqIEEgY29tYmluZWQgbm9ybWFsLWRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgbm9ybWFsRGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm5vcm1hbERlcHRoQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmRlZmluZXMuTk9STUFMX0RFUFRIID0gXCIxXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuTk9STUFMX0RFUFRIO1xuICAgIH1cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY29tYmluZWQgbm9ybWFsLWRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG5vcm1hbERlcHRoQnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBidWZmZXIuXG4gICAqL1xuICBzZXROb3JtYWxEZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMubm9ybWFsRGVwdGhCdWZmZXIgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG5vcm1hbCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IG5vcm1hbEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubm9ybWFsQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vcm1hbCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBub3JtYWxCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGJ1ZmZlci5cbiAgICovXG4gIHNldE5vcm1hbEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubm9ybWFsQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGRlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICpcbiAgICogQHR5cGUge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9XG4gICAqL1xuICBzZXQgZGVwdGhQYWNraW5nKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1BBQ0tJTkcgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlciBhbmQgZGVwdGhQYWNraW5nIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gYnVmZmVyIC0gVGhlIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIHNldERlcHRoQnVmZmVyKGJ1ZmZlciwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxMCkge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBub2lzZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBub2lzZVRleHR1cmUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm5vaXNlVGV4dHVyZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub2lzZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugbm9pc2VUZXh0dXJlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgc2V0Tm9pc2VUZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5ub2lzZVRleHR1cmUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNhbXBsZSBjb3VudC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzYW1wbGVzKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLlNBTVBMRVNfSU5UKTtcbiAgfVxuICBzZXQgc2FtcGxlcyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5TQU1QTEVTX0lOVCA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5kZWZpbmVzLklOVl9TQU1QTEVTX0ZMT0FUID0gKDEgLyB2YWx1ZSkudG9GaXhlZCg5KTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIG9jY2x1c2lvbiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNhbXBsZXMgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2FtcGxlIGNvdW50LlxuICAgKi9cbiAgZ2V0U2FtcGxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhbW91bnQgb2Ygb2NjbHVzaW9uIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2FtcGxlcyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc2FtcGxlIGNvdW50LlxuICAgKi9cbiAgc2V0U2FtcGxlcyh2YWx1ZSkge1xuICAgIHRoaXMuc2FtcGxlcyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2FtcGxpbmcgc3BpcmFsIHJpbmcgY291bnQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmluZ3MoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuU1BJUkFMX1RVUk5TKTtcbiAgfVxuICBzZXQgcmluZ3ModmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuU1BJUkFMX1RVUk5TID0gdmFsdWUudG9GaXhlZCgxKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIHNwaXJhbCB0dXJucyBpbiB0aGUgb2NjbHVzaW9uIHNhbXBsaW5nIHBhdHRlcm4uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByaW5ncyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByYWRpdXMuXG4gICAqL1xuICBnZXRSaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5yaW5ncztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYW1vdW50IG9mIHNwaXJhbCB0dXJucyBpbiB0aGUgb2NjbHVzaW9uIHNhbXBsaW5nIHBhdHRlcm4uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByaW5ncyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgcmFkaXVzLlxuICAgKi9cbiAgc2V0UmluZ3ModmFsdWUpIHtcbiAgICB0aGlzLnJpbmdzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBTU0FPRWZmZWN0LmludGVuc2l0eSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5pbnRlbnNpdHkudmFsdWU7XG4gIH1cbiAgc2V0IGludGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW50ZW5zaXR5LnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuZGVmaW5lcy5MRUdBQ1lfSU5URU5TSVRZID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5MRUdBQ1lfSU5URU5TSVRZID0gXCIxXCI7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIFNTQU9FZmZlY3QuaW50ZW5zaXR5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGludGVuc2l0eS5cbiAgICovXG4gIGdldEludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5pbnRlbnNpdHkudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIFNTQU9FZmZlY3QuaW50ZW5zaXR5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBpbnRlbnNpdHkuXG4gICAqL1xuICBzZXRJbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmludGVuc2l0eS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggZmFkZSBmYWN0b3IuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZmFkZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5mYWRlLnZhbHVlO1xuICB9XG4gIHNldCBmYWRlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5mYWRlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlcHRoIGZhZGUgZmFjdG9yLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZmFkZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmYWRlIGZhY3Rvci5cbiAgICovXG4gIGdldEZhZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZmFkZS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggZmFkZSBmYWN0b3IuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBmYWRlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBmYWRlIGZhY3Rvci5cbiAgICovXG4gIHNldEZhZGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmZhZGUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGJpYXMuIFJhbmdlOiBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJpYXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuYmlhcy52YWx1ZTtcbiAgfVxuICBzZXQgYmlhcyh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuYmlhcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXB0aCBiaWFzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmlhcyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBiaWFzLlxuICAgKi9cbiAgZ2V0QmlhcygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5iaWFzLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBiaWFzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmlhcyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgYmlhcy5cbiAgICovXG4gIHNldEJpYXModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmJpYXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1pbmltdW0gcmFkaXVzIHNjYWxlIGZvciBkaXN0YW5jZSBzY2FsaW5nLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtaW5SYWRpdXNTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5taW5SYWRpdXNTY2FsZS52YWx1ZTtcbiAgfVxuICBzZXQgbWluUmFkaXVzU2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm1pblJhZGl1c1NjYWxlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1pbmltdW0gcmFkaXVzIHNjYWxlIGZvciBkaXN0YW5jZSBzY2FsaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWluUmFkaXVzU2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWluaW11bSByYWRpdXMgc2NhbGUuXG4gICAqL1xuICBnZXRNaW5SYWRpdXNTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5taW5SYWRpdXNTY2FsZS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWluaW11bSByYWRpdXMgc2NhbGUgZm9yIGRpc3RhbmNlIHNjYWxpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtaW5SYWRpdXNTY2FsZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWluaW11bSByYWRpdXMgc2NhbGUuXG4gICAqL1xuICBzZXRNaW5SYWRpdXNTY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubWluUmFkaXVzU2NhbGUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYWJzb2x1dGUgcmFkaXVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlUmFkaXVzKCkge1xuICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMuciAqIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgdGhpcy5kZWZpbmVzLlJBRElVUyA9IHJhZGl1cy50b0ZpeGVkKDExKTtcbiAgICB0aGlzLmRlZmluZXMuUkFESVVTX1NRID0gKHJhZGl1cyAqIHJhZGl1cykudG9GaXhlZCgxMSk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gc2FtcGxpbmcgcmFkaXVzLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucjtcbiAgfVxuICBzZXQgcmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy5yID0gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIDFlLTYpLCAxKTtcbiAgICB0aGlzLnVwZGF0ZVJhZGl1cygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvY2NsdXNpb24gc2FtcGxpbmcgcmFkaXVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmFkaXVzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJhZGl1cy5cbiAgICovXG4gIGdldFJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5yYWRpdXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9jY2x1c2lvbiBzYW1wbGluZyByYWRpdXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByYWRpdXMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHJhZGl1cy4gUmFuZ2UgWzFlLTYsIDEuMF0uXG4gICAqL1xuICBzZXRSYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnJhZGl1cyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXN0YW5jZS1iYXNlZCByYWRpdXMgc2NhbGluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBkaXN0YW5jZVNjYWxpbmcoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2V0IGRpc3RhbmNlU2NhbGluZyh2YWx1ZSkge1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXN0YW5jZS1iYXNlZCByYWRpdXMgc2NhbGluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGRpc3RhbmNlIHNjYWxpbmcgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzRGlzdGFuY2VTY2FsaW5nRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVNjYWxpbmc7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgZGlzdGFuY2UtYmFzZWQgcmFkaXVzIHNjYWxpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIGRpc3RhbmNlIHNjYWxpbmcgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXREaXN0YW5jZVNjYWxpbmdFbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5kaXN0YW5jZVNjYWxpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBkaXN0YW5jZSB0aHJlc2hvbGQuIFJhbmdlOiBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRpc3RhbmNlVGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRpc3RhbmNlQ3V0b2ZmLnZhbHVlLng7XG4gIH1cbiAgc2V0IGRpc3RhbmNlVGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kaXN0YW5jZUN1dG9mZi52YWx1ZS5zZXQoXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIDEpLFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgodmFsdWUgKyB0aGlzLmRpc3RhbmNlRmFsbG9mZiwgMCksIDEpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBkaXN0YW5jZSB0aHJlc2hvbGQgaW4gd29ybGQgdW5pdHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd29ybGREaXN0YW5jZVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gLW9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3Wih0aGlzLmRpc3RhbmNlVGhyZXNob2xkLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGREaXN0YW5jZVRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMuZGlzdGFuY2VUaHJlc2hvbGQgPSB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoLXZhbHVlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBkaXN0YW5jZSBmYWxsb2ZmLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBkaXN0YW5jZUZhbGxvZmYoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGlzdGFuY2VDdXRvZmYudmFsdWUueSAtIHRoaXMuZGlzdGFuY2VUaHJlc2hvbGQ7XG4gIH1cbiAgc2V0IGRpc3RhbmNlRmFsbG9mZih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGlzdGFuY2VDdXRvZmYudmFsdWUueSA9IE1hdGgubWluKE1hdGgubWF4KHRoaXMuZGlzdGFuY2VUaHJlc2hvbGQgKyB2YWx1ZSwgMCksIDEpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb2NjbHVzaW9uIGRpc3RhbmNlIGZhbGxvZmYgaW4gd29ybGQgdW5pdHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd29ybGREaXN0YW5jZUZhbGxvZmYoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5kaXN0YW5jZUZhbGxvZmYsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuICB9XG4gIHNldCB3b3JsZERpc3RhbmNlRmFsbG9mZih2YWx1ZSkge1xuICAgIHRoaXMuZGlzdGFuY2VGYWxsb2ZmID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9jY2x1c2lvbiBkaXN0YW5jZSBjdXRvZmYuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkaXN0YW5jZVRocmVzaG9sZCBhbmQgZGlzdGFuY2VGYWxsb2ZmIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGQgLSBUaGUgZGlzdGFuY2UgdGhyZXNob2xkLiBSYW5nZSBbMC4wLCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZmFsbG9mZiAtIFRoZSBmYWxsb2ZmLiBSYW5nZSBbMC4wLCAxLjBdLlxuICAgKi9cbiAgc2V0RGlzdGFuY2VDdXRvZmYodGhyZXNob2xkLCBmYWxsb2ZmKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kaXN0YW5jZUN1dG9mZi52YWx1ZS5zZXQoXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCh0aHJlc2hvbGQsIDApLCAxKSxcbiAgICAgIE1hdGgubWluKE1hdGgubWF4KHRocmVzaG9sZCArIGZhbGxvZmYsIDApLCAxKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gcHJveGltaXR5IHRocmVzaG9sZC4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcHJveGltaXR5VGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnByb3hpbWl0eUN1dG9mZi52YWx1ZS54O1xuICB9XG4gIHNldCBwcm94aW1pdHlUaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnByb3hpbWl0eUN1dG9mZi52YWx1ZS5zZXQoXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIDEpLFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgodmFsdWUgKyB0aGlzLnByb3hpbWl0eUZhbGxvZmYsIDApLCAxKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gcHJveGltaXR5IHRocmVzaG9sZCBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZFByb3hpbWl0eVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gLW9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3Wih0aGlzLnByb3hpbWl0eVRocmVzaG9sZCwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgc2V0IHdvcmxkUHJveGltaXR5VGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy5wcm94aW1pdHlUaHJlc2hvbGQgPSB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoLXZhbHVlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBwcm94aW1pdHkgZmFsbG9mZi4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcHJveGltaXR5RmFsbG9mZigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5wcm94aW1pdHlDdXRvZmYudmFsdWUueSAtIHRoaXMucHJveGltaXR5VGhyZXNob2xkO1xuICB9XG4gIHNldCBwcm94aW1pdHlGYWxsb2ZmKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5wcm94aW1pdHlDdXRvZmYudmFsdWUueSA9IE1hdGgubWluKE1hdGgubWF4KHRoaXMucHJveGltaXR5VGhyZXNob2xkICsgdmFsdWUsIDApLCAxKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBwcm94aW1pdHkgZmFsbG9mZiBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZFByb3hpbWl0eUZhbGxvZmYoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5wcm94aW1pdHlGYWxsb2ZmLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGRQcm94aW1pdHlGYWxsb2ZmKHZhbHVlKSB7XG4gICAgdGhpcy5wcm94aW1pdHlGYWxsb2ZmID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9jY2x1c2lvbiBwcm94aW1pdHkgY3V0b2ZmLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJveGltaXR5VGhyZXNob2xkIGFuZCBwcm94aW1pdHlGYWxsb2ZmIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGQgLSBUaGUgcmFuZ2UgdGhyZXNob2xkLiBSYW5nZSBbMC4wLCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZmFsbG9mZiAtIFRoZSBmYWxsb2ZmLiBSYW5nZSBbMC4wLCAxLjBdLlxuICAgKi9cbiAgc2V0UHJveGltaXR5Q3V0b2ZmKHRocmVzaG9sZCwgZmFsbG9mZikge1xuICAgIHRoaXMudW5pZm9ybXMucHJveGltaXR5Q3V0b2ZmLnZhbHVlLnNldChcbiAgICAgIE1hdGgubWluKE1hdGgubWF4KHRocmVzaG9sZCwgMCksIDEpLFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgodGhyZXNob2xkICsgZmFsbG9mZiwgMCksIDEpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNpemUoKSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxuICAgKi9cbiAgc2V0VGV4ZWxTaXplKHgsIHkpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcHlDYW1lcmFTZXR0aW5ncyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSBjYW1lcmEuXG4gICAqL1xuICBhZG9wdENhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIHRoaXMuY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIGlmIChjYW1lcmEpIHtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhckZhci52YWx1ZS5zZXQoY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIpO1xuICAgICAgdGhpcy51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LnZhbHVlLmNvcHkoY2FtZXJhLnByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgdGhpcy51bmlmb3Jtcy5pbnZlcnNlUHJvamVjdGlvbk1hdHJpeC52YWx1ZS5jb3B5KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KS5pbnZlcnQoKTtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYTQpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQSA9IFwiMVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkE7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gICAgY29uc3Qgbm9pc2VUZXh0dXJlID0gdW5pZm9ybXMubm9pc2VUZXh0dXJlLnZhbHVlO1xuICAgIGlmIChub2lzZVRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgIHVuaWZvcm1zLm5vaXNlU2NhbGUudmFsdWUuc2V0KFxuICAgICAgICB3aWR0aCAvIG5vaXNlVGV4dHVyZS5pbWFnZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0IC8gbm9pc2VUZXh0dXJlLmltYWdlLmhlaWdodFxuICAgICAgKTtcbiAgICB9XG4gICAgdW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICAgIHRoaXMucmVzb2x1dGlvbi5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy51cGRhdGVSYWRpdXMoKTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9EZXB0aERvd25zYW1wbGluZ1Bhc3MuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTIsIEZsb2F0VHlwZSBhcyBGbG9hdFR5cGU0LCBOZWFyZXN0RmlsdGVyIGFzIE5lYXJlc3RGaWx0ZXI1LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDE1IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhEb3duc2FtcGxpbmdNYXRlcmlhbC5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmcxMSwgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTYsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMTcsIFVuaWZvcm0gYXMgVW5pZm9ybTQwLCBWZWN0b3IyIGFzIFZlY3RvcjIyMiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvZGVwdGgtZG93bnNhbXBsaW5nLmZyYWdcbnZhciBkZXB0aF9kb3duc2FtcGxpbmdfZGVmYXVsdCA9IGAjaW5jbHVkZSA8cGFja2luZz5cbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbmRpZlxuI2lmZGVmIERPV05TQU1QTEVfTk9STUFMU1xudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBub3JtYWxCdWZmZXI7XG4jZW5kaWZcbnZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO2Zsb2F0IHJlYWREZXB0aChjb25zdCBpbiB2ZWMyIHV2KXtcbiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcbnJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpKTtcbiNlbHNlXG5yZXR1cm4gdGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KS5yO1xuI2VuZGlmXG59aW50IGZpbmRCZXN0RGVwdGgoY29uc3QgaW4gZmxvYXQgc2FtcGxlc1s0XSl7ZmxvYXQgYz0oc2FtcGxlc1swXStzYW1wbGVzWzFdK3NhbXBsZXNbMl0rc2FtcGxlc1szXSkqMC4yNTtmbG9hdCBkaXN0YW5jZXNbNF07ZGlzdGFuY2VzWzBdPWFicyhjLXNhbXBsZXNbMF0pO2Rpc3RhbmNlc1sxXT1hYnMoYy1zYW1wbGVzWzFdKTtkaXN0YW5jZXNbMl09YWJzKGMtc2FtcGxlc1syXSk7ZGlzdGFuY2VzWzNdPWFicyhjLXNhbXBsZXNbM10pO2Zsb2F0IG1heERpc3RhbmNlPW1heChtYXgoZGlzdGFuY2VzWzBdLGRpc3RhbmNlc1sxXSksbWF4KGRpc3RhbmNlc1syXSxkaXN0YW5jZXNbM10pKTtpbnQgcmVtYWluaW5nWzNdO2ludCByZWplY3RlZFszXTtpbnQgaSxqLGs7Zm9yKGk9MCxqPTAsaz0wO2k8NDsrK2kpe2lmKGRpc3RhbmNlc1tpXTxtYXhEaXN0YW5jZSl7cmVtYWluaW5nW2orK109aTt9ZWxzZXtyZWplY3RlZFtrKytdPWk7fX1mb3IoO2o8MzsrK2ope3JlbWFpbmluZ1tqXT1yZWplY3RlZFstLWtdO312ZWMzIHM9dmVjMyhzYW1wbGVzW3JlbWFpbmluZ1swXV0sc2FtcGxlc1tyZW1haW5pbmdbMV1dLHNhbXBsZXNbcmVtYWluaW5nWzJdXSk7Yz0ocy54K3MueStzLnopLzMuMDtkaXN0YW5jZXNbMF09YWJzKGMtcy54KTtkaXN0YW5jZXNbMV09YWJzKGMtcy55KTtkaXN0YW5jZXNbMl09YWJzKGMtcy56KTtmbG9hdCBtaW5EaXN0YW5jZT1taW4oZGlzdGFuY2VzWzBdLG1pbihkaXN0YW5jZXNbMV0sZGlzdGFuY2VzWzJdKSk7Zm9yKGk9MDtpPDM7KytpKXtpZihkaXN0YW5jZXNbaV09PW1pbkRpc3RhbmNlKXticmVhazt9fXJldHVybiByZW1haW5pbmdbaV07fXZvaWQgbWFpbigpe2Zsb2F0IGRbNF07ZFswXT1yZWFkRGVwdGgodlV2MCk7ZFsxXT1yZWFkRGVwdGgodlV2MSk7ZFsyXT1yZWFkRGVwdGgodlV2Mik7ZFszXT1yZWFkRGVwdGgodlV2Myk7aW50IGluZGV4PWZpbmRCZXN0RGVwdGgoZCk7XG4jaWZkZWYgRE9XTlNBTVBMRV9OT1JNQUxTXG52ZWMzIG5bNF07blswXT10ZXh0dXJlMkQobm9ybWFsQnVmZmVyLHZVdjApLnJnYjtuWzFdPXRleHR1cmUyRChub3JtYWxCdWZmZXIsdlV2MSkucmdiO25bMl09dGV4dHVyZTJEKG5vcm1hbEJ1ZmZlcix2VXYyKS5yZ2I7blszXT10ZXh0dXJlMkQobm9ybWFsQnVmZmVyLHZVdjMpLnJnYjtcbiNlbHNlXG52ZWMzIG5bNF07blswXT12ZWMzKDAuMCk7blsxXT12ZWMzKDAuMCk7blsyXT12ZWMzKDAuMCk7blszXT12ZWMzKDAuMCk7XG4jZW5kaWZcbmdsX0ZyYWdDb2xvcj12ZWM0KG5baW5kZXhdLGRbaW5kZXhdKTt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2RlcHRoLWRvd25zYW1wbGluZy52ZXJ0XG52YXIgZGVwdGhfZG93bnNhbXBsaW5nX2RlZmF1bHQyID0gYHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dm9pZCBtYWluKCl7dmVjMiB1dj1wb3NpdGlvbi54eSowLjUrMC41O3ZVdjA9dXY7dlV2MT12ZWMyKHV2LngsdXYueSt0ZXhlbFNpemUueSk7dlV2Mj12ZWMyKHV2LngrdGV4ZWxTaXplLngsdXYueSk7dlV2Mz11dit0ZXhlbFNpemU7Z2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9EZXB0aERvd25zYW1wbGluZ01hdGVyaWFsLmpzXG52YXIgRGVwdGhEb3duc2FtcGxpbmdNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxNyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRlcHRoIGRvd25zYW1wbGluZyBtYXRlcmlhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiRGVwdGhEb3duc2FtcGxpbmdNYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGRlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTQwKG51bGwpLFxuICAgICAgICBub3JtYWxCdWZmZXI6IG5ldyBVbmlmb3JtNDAobnVsbCksXG4gICAgICAgIHRleGVsU2l6ZTogbmV3IFVuaWZvcm00MChuZXcgVmVjdG9yMjIyKCkpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcxNixcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGRlcHRoX2Rvd25zYW1wbGluZ19kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBkZXB0aF9kb3duc2FtcGxpbmdfZGVmYXVsdDJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgZGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQnVmZmVyIGFuZCBkZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIoYnVmZmVyLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzExKSB7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLmRlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogVGhlIG5vcm1hbCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IG5vcm1hbEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubm9ybWFsQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmRlZmluZXMuRE9XTlNBTVBMRV9OT1JNQUxTID0gXCIxXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuRE9XTlNBTVBMRV9OT1JNQUxTO1xuICAgIH1cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbm9ybWFsIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG5vcm1hbEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIG5vcm1hbCBidWZmZXIuXG4gICAqL1xuICBzZXROb3JtYWxCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLm5vcm1hbEJ1ZmZlciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXhlbCBzaXplLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0U2l6ZSgpIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gVGhlIHRleGVsIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB0ZXhlbCBoZWlnaHQuXG4gICAqL1xuICBzZXRUZXhlbFNpemUoeCwgeSkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCh4LCB5KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0RlcHRoRG93bnNhbXBsaW5nUGFzcy5qc1xudmFyIERlcHRoRG93bnNhbXBsaW5nUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRlcHRoIGRvd25zYW1wbGluZyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gW29wdGlvbnMubm9ybWFsQnVmZmVyPW51bGxdIC0gQSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdmlldyBzcGFjZSBub3JtYWxzLiBTZWUge0BsaW5rIE5vcm1hbFBhc3N9LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTAuNV0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWSBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5vcm1hbEJ1ZmZlciA9IG51bGwsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMC41LFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkRlcHRoRG93bnNhbXBsaW5nUGFzc1wiKTtcbiAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBEZXB0aERvd25zYW1wbGluZ01hdGVyaWFsKCk7XG4gICAgbWF0ZXJpYWwubm9ybWFsQnVmZmVyID0gbm9ybWFsQnVmZmVyO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgdGhpcy5uZWVkc0RlcHRoVGV4dHVyZSA9IHRydWU7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDE1KDEsIDEsIHtcbiAgICAgIG1pbkZpbHRlcjogTmVhcmVzdEZpbHRlcjUsXG4gICAgICBtYWdGaWx0ZXI6IE5lYXJlc3RGaWx0ZXI1LFxuICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlLFxuICAgICAgdHlwZTogRmxvYXRUeXBlNFxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiRGVwdGhEb3duc2FtcGxpbmdQYXNzLlRhcmdldFwiO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbiA9IG5ldyBSZXNvbHV0aW9uKHRoaXMsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwgcmVzb2x1dGlvblNjYWxlKTtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBub3JtYWwoUkdCKSArIGRlcHRoKEEpIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5vcm1hbChSR0IpICsgZGVwdGgoQSkgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtSZXNvbHV0aW9ufSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTIpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIERvd25zYW1wbGVzIGRlcHRoIGFuZCBzY2VuZSBub3JtYWxzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB0aGlzLnJlbmRlclRhcmdldCk7XG4gICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZShyZXNvbHV0aW9uLndpZHRoLCByZXNvbHV0aW9uLmhlaWdodCk7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG4gICAgY29uc3QgcmVuZGVyYWJsZSA9IGdsLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIikgfHwgZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpO1xuICAgIGlmICghcmVuZGVyYWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVuZGVyaW5nIHRvIGZsb2F0IHRleHR1cmUgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3NzYW8uZnJhZ1xudmFyIHNzYW9fZGVmYXVsdDMgPSBgdW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBhb0J1ZmZlcjt1bmlmb3JtIGZsb2F0IGx1bWluYW5jZUluZmx1ZW5jZTt1bmlmb3JtIGZsb2F0IGludGVuc2l0eTtcbiNpZiBkZWZpbmVkKERFUFRIX0FXQVJFX1VQU0FNUExJTkcpICYmIGRlZmluZWQoTk9STUFMX0RFUFRIKVxuI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIG5vcm1hbERlcHRoQnVmZmVyO1xuI2VuZGlmXG4jZW5kaWZcbiNpZmRlZiBDT0xPUklaRVxudW5pZm9ybSB2ZWMzIGNvbG9yO1xuI2VuZGlmXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixjb25zdCBpbiBmbG9hdCBkZXB0aCxvdXQgdmVjNCBvdXRwdXRDb2xvcil7ZmxvYXQgYW9MaW5lYXI9dGV4dHVyZTJEKGFvQnVmZmVyLHV2KS5yO1xuI2lmIGRlZmluZWQoREVQVEhfQVdBUkVfVVBTQU1QTElORykgJiYgZGVmaW5lZChOT1JNQUxfREVQVEgpICYmIF9fVkVSU0lPTl9fID09IDMwMFxudmVjNCBub3JtYWxEZXB0aFs0XTtub3JtYWxEZXB0aFswXT10ZXh0dXJlT2Zmc2V0KG5vcm1hbERlcHRoQnVmZmVyLHV2LGl2ZWMyKDAsMCkpO25vcm1hbERlcHRoWzFdPXRleHR1cmVPZmZzZXQobm9ybWFsRGVwdGhCdWZmZXIsdXYsaXZlYzIoMCwxKSk7bm9ybWFsRGVwdGhbMl09dGV4dHVyZU9mZnNldChub3JtYWxEZXB0aEJ1ZmZlcix1dixpdmVjMigxLDApKTtub3JtYWxEZXB0aFszXT10ZXh0dXJlT2Zmc2V0KG5vcm1hbERlcHRoQnVmZmVyLHV2LGl2ZWMyKDEsMSkpO2Zsb2F0IGRvdDAxPWRvdChub3JtYWxEZXB0aFswXS5yZ2Isbm9ybWFsRGVwdGhbMV0ucmdiKTtmbG9hdCBkb3QwMj1kb3Qobm9ybWFsRGVwdGhbMF0ucmdiLG5vcm1hbERlcHRoWzJdLnJnYik7ZmxvYXQgZG90MDM9ZG90KG5vcm1hbERlcHRoWzBdLnJnYixub3JtYWxEZXB0aFszXS5yZ2IpO2Zsb2F0IG1pbkRvdD1taW4oZG90MDEsbWluKGRvdDAyLGRvdDAzKSk7ZmxvYXQgcz1zdGVwKFRIUkVTSE9MRCxtaW5Eb3QpO2Zsb2F0IHNtYWxsZXN0RGlzdGFuY2U9MS4wO2ludCBpbmRleDtmb3IoaW50IGk9MDtpPDQ7KytpKXtmbG9hdCBkaXN0YW5jZT1hYnMoZGVwdGgtbm9ybWFsRGVwdGhbaV0uYSk7aWYoZGlzdGFuY2U8c21hbGxlc3REaXN0YW5jZSl7c21hbGxlc3REaXN0YW5jZT1kaXN0YW5jZTtpbmRleD1pO319aXZlYzIgb2Zmc2V0c1s0XTtvZmZzZXRzWzBdPWl2ZWMyKDAsMCk7b2Zmc2V0c1sxXT1pdmVjMigwLDEpO29mZnNldHNbMl09aXZlYzIoMSwwKTtvZmZzZXRzWzNdPWl2ZWMyKDEsMSk7aXZlYzIgY29vcmQ9aXZlYzIodXYqdmVjMih0ZXh0dXJlU2l6ZShhb0J1ZmZlciwwKSkpK29mZnNldHNbaW5kZXhdO2Zsb2F0IGFvTmVhcmVzdD10ZXhlbEZldGNoKGFvQnVmZmVyLGNvb3JkLDApLnI7ZmxvYXQgYW89bWl4KGFvTmVhcmVzdCxhb0xpbmVhcixzKTtcbiNlbHNlXG5mbG9hdCBhbz1hb0xpbmVhcjtcbiNlbmRpZlxuZmxvYXQgbD1sdW1pbmFuY2UoaW5wdXRDb2xvci5yZ2IpO2FvPW1peChhbywwLjAsbCpsdW1pbmFuY2VJbmZsdWVuY2UpO2FvPWNsYW1wKGFvKmludGVuc2l0eSwwLjAsMS4wKTtcbiNpZmRlZiBDT0xPUklaRVxub3V0cHV0Q29sb3I9dmVjNCgxLjAtYW8qKDEuMC1jb2xvciksaW5wdXRDb2xvci5hKTtcbiNlbHNlXG5vdXRwdXRDb2xvcj12ZWM0KHZlYzMoMS4wLWFvKSxpbnB1dENvbG9yLmEpO1xuI2VuZGlmXG59YDtcblxuLy8gc3JjL2VmZmVjdHMvU1NBT0VmZmVjdC5qc1xudmFyIE5PSVNFX1RFWFRVUkVfU0laRSA9IDY0O1xudmFyIFNTQU9FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNTQU8gZWZmZWN0LlxuICAgKlxuICAgKiBAdG9kbyBNb3ZlIG5vcm1hbEJ1ZmZlciB0byBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gW2NhbWVyYV0gLSBUaGUgbWFpbiBjYW1lcmEuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gW25vcm1hbEJ1ZmZlcl0gLSBBIHRleHR1cmUgdGhhdCBjb250YWlucyB0aGUgc2NlbmUgbm9ybWFscy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5NVUxUSVBMWV0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGlzdGFuY2VTY2FsaW5nPXRydWVdIC0gRGVwcmVjYXRlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kZXB0aEF3YXJlVXBzYW1wbGluZz10cnVlXSAtIEVuYWJsZXMgb3IgZGlzYWJsZXMgZGVwdGgtYXdhcmUgdXBzYW1wbGluZy4gSGFzIG5vIGVmZmVjdCBpZiBXZWJHTCAyIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gW29wdGlvbnMubm9ybWFsRGVwdGhCdWZmZXI9bnVsbF0gLSBEZXByZWNhdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2FtcGxlcz05XSAtIFRoZSBhbW91bnQgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwuIFNob3VsZCBub3QgYmUgYSBtdWx0aXBsZSBvZiB0aGUgcmluZyBjb3VudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJpbmdzPTddIC0gVGhlIGFtb3VudCBvZiBzcGlyYWwgdHVybnMgaW4gdGhlIG9jY2x1c2lvbiBzYW1wbGluZyBwYXR0ZXJuLiBTaG91bGQgYmUgYSBwcmltZSBudW1iZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53b3JsZERpc3RhbmNlVGhyZXNob2xkXSAtIFRoZSB3b3JsZCBkaXN0YW5jZSB0aHJlc2hvbGQgYXQgd2hpY2ggdGhlIG9jY2x1c2lvbiBlZmZlY3Qgc3RhcnRzIHRvIGZhZGUgb3V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud29ybGREaXN0YW5jZUZhbGxvZmZdIC0gVGhlIHdvcmxkIGRpc3RhbmNlIGZhbGxvZmYuIEluZmx1ZW5jZXMgdGhlIHNtb290aG5lc3Mgb2YgdGhlIG9jY2x1c2lvbiBjdXRvZmYuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53b3JsZFByb3hpbWl0eVRocmVzaG9sZF0gLSBUaGUgd29ybGQgcHJveGltaXR5IHRocmVzaG9sZCBhdCB3aGljaCB0aGUgb2NjbHVzaW9uIHN0YXJ0cyB0byBmYWRlIG91dC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndvcmxkUHJveGltaXR5RmFsbG9mZl0gLSBUaGUgd29ybGQgcHJveGltaXR5IGZhbGxvZmYuIEluZmx1ZW5jZXMgdGhlIHNtb290aG5lc3Mgb2YgdGhlIHByb3hpbWl0eSBjdXRvZmYuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZVRocmVzaG9sZD0wLjk3XSAtIERlcHJlY2F0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZUZhbGxvZmY9MC4wM10gLSBEZXByZWNhdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmFuZ2VUaHJlc2hvbGQ9MC4wMDA1XSAtIERlcHJlY2F0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYW5nZUZhbGxvZmY9MC4wMDFdIC0gRGVwcmVjYXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblJhZGl1c1NjYWxlPTAuMV0gLSBUaGUgbWluaW11bSByYWRpdXMgc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sdW1pbmFuY2VJbmZsdWVuY2U9MC43XSAtIERldGVybWluZXMgaG93IG11Y2ggdGhlIGx1bWluYW5jZSBvZiB0aGUgc2NlbmUgaW5mbHVlbmNlcyB0aGUgYW1iaWVudCBvY2NsdXNpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MC4xODI1XSAtIFRoZSBvY2NsdXNpb24gc2FtcGxpbmcgcmFkaXVzLCBleHByZXNzZWQgYXMgYSBzY2FsZSByZWxhdGl2ZSB0byB0aGUgcmVzb2x1dGlvbi4gUmFuZ2UgWzFlLTYsIDEuMF0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pbnRlbnNpdHk9MS4wXSAtIFRoZSBpbnRlbnNpdHkgb2YgdGhlIGFtYmllbnQgb2NjbHVzaW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmlhcz0wLjAyNV0gLSBBbiBvY2NsdXNpb24gYmlhcy4gRWxpbWluYXRlcyBhcnRpZmFjdHMgY2F1c2VkIGJ5IGRlcHRoIGRpc2NvbnRpbnVpdGllcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZhZGU9MC4wMV0gLSBJbmZsdWVuY2VzIHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBzaGFkb3dzLiBBIGxvd2VyIHZhbHVlIHJlc3VsdHMgaW4gaGlnaGVyIGNvbnRyYXN0LlxuICAgKiBAcGFyYW0ge0NvbG9yfSBbb3B0aW9ucy5jb2xvcj1udWxsXSAtIFRoZSBjb2xvciBvZiB0aGUgYW1iaWVudCBvY2NsdXNpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MS4wXSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25YIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25ZIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYW1lcmEsIG5vcm1hbEJ1ZmZlciwge1xuICAgIGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLk1VTFRJUExZLFxuICAgIHNhbXBsZXMgPSA5LFxuICAgIHJpbmdzID0gNyxcbiAgICBub3JtYWxEZXB0aEJ1ZmZlciA9IG51bGwsXG4gICAgZGVwdGhBd2FyZVVwc2FtcGxpbmcgPSB0cnVlLFxuICAgIHdvcmxkRGlzdGFuY2VUaHJlc2hvbGQsXG4gICAgd29ybGREaXN0YW5jZUZhbGxvZmYsXG4gICAgd29ybGRQcm94aW1pdHlUaHJlc2hvbGQsXG4gICAgd29ybGRQcm94aW1pdHlGYWxsb2ZmLFxuICAgIGRpc3RhbmNlVGhyZXNob2xkID0gMC45NyxcbiAgICBkaXN0YW5jZUZhbGxvZmYgPSAwLjAzLFxuICAgIHJhbmdlVGhyZXNob2xkID0gNWUtNCxcbiAgICByYW5nZUZhbGxvZmYgPSAxZS0zLFxuICAgIG1pblJhZGl1c1NjYWxlID0gMC4xLFxuICAgIGx1bWluYW5jZUluZmx1ZW5jZSA9IDAuNyxcbiAgICByYWRpdXMgPSAwLjE4MjUsXG4gICAgaW50ZW5zaXR5ID0gMSxcbiAgICBiaWFzID0gMC4wMjUsXG4gICAgZmFkZSA9IDAuMDEsXG4gICAgY29sb3I6IGNvbG9yMiA9IG51bGwsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMSxcbiAgICB3aWR0aCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIGhlaWdodCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25YID0gd2lkdGgsXG4gICAgcmVzb2x1dGlvblkgPSBoZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJTU0FPRWZmZWN0XCIsIHNzYW9fZGVmYXVsdDMsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBhdHRyaWJ1dGVzOiBFZmZlY3RBdHRyaWJ1dGUuREVQVEgsXG4gICAgICBkZWZpbmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIlRIUkVTSE9MRFwiLCBcIjAuOTk3XCJdXG4gICAgICBdKSxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImFvQnVmZmVyXCIsIG5ldyBVbmlmb3JtNDEobnVsbCldLFxuICAgICAgICBbXCJub3JtYWxEZXB0aEJ1ZmZlclwiLCBuZXcgVW5pZm9ybTQxKG5vcm1hbERlcHRoQnVmZmVyKV0sXG4gICAgICAgIFtcImx1bWluYW5jZUluZmx1ZW5jZVwiLCBuZXcgVW5pZm9ybTQxKGx1bWluYW5jZUluZmx1ZW5jZSldLFxuICAgICAgICBbXCJjb2xvclwiLCBuZXcgVW5pZm9ybTQxKG51bGwpXSxcbiAgICAgICAgW1wiaW50ZW5zaXR5XCIsIG5ldyBVbmlmb3JtNDEoaW50ZW5zaXR5KV0sXG4gICAgICAgIFtcInNjYWxlXCIsIG5ldyBVbmlmb3JtNDEoMCldXG4gICAgICAgIC8vIFVudXNlZC5cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxNigxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkFPLlRhcmdldFwiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYW9CdWZmZXJcIikudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzID0gbmV3IERlcHRoRG93bnNhbXBsaW5nUGFzcyh7IG5vcm1hbEJ1ZmZlciwgcmVzb2x1dGlvblNjYWxlIH0pO1xuICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLmVuYWJsZWQgPSBub3JtYWxEZXB0aEJ1ZmZlciA9PT0gbnVsbDtcbiAgICB0aGlzLnNzYW9QYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IFNTQU9NYXRlcmlhbChjYW1lcmEpKTtcbiAgICBjb25zdCBub2lzZVRleHR1cmUgPSBuZXcgTm9pc2VUZXh0dXJlKE5PSVNFX1RFWFRVUkVfU0laRSwgTk9JU0VfVEVYVFVSRV9TSVpFLCBSR0JBRm9ybWF0NCk7XG4gICAgbm9pc2VUZXh0dXJlLndyYXBTID0gbm9pc2VUZXh0dXJlLndyYXBUID0gUmVwZWF0V3JhcHBpbmc0O1xuICAgIGNvbnN0IHNzYW9NYXRlcmlhbCA9IHRoaXMuc3Nhb01hdGVyaWFsO1xuICAgIHNzYW9NYXRlcmlhbC5ub3JtYWxCdWZmZXIgPSBub3JtYWxCdWZmZXI7XG4gICAgc3Nhb01hdGVyaWFsLm5vaXNlVGV4dHVyZSA9IG5vaXNlVGV4dHVyZTtcbiAgICBzc2FvTWF0ZXJpYWwubWluUmFkaXVzU2NhbGUgPSBtaW5SYWRpdXNTY2FsZTtcbiAgICBzc2FvTWF0ZXJpYWwuc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgc3Nhb01hdGVyaWFsLnJhZGl1cyA9IHJhZGl1cztcbiAgICBzc2FvTWF0ZXJpYWwucmluZ3MgPSByaW5ncztcbiAgICBzc2FvTWF0ZXJpYWwuZmFkZSA9IGZhZGU7XG4gICAgc3Nhb01hdGVyaWFsLmJpYXMgPSBiaWFzO1xuICAgIHNzYW9NYXRlcmlhbC5kaXN0YW5jZVRocmVzaG9sZCA9IGRpc3RhbmNlVGhyZXNob2xkO1xuICAgIHNzYW9NYXRlcmlhbC5kaXN0YW5jZUZhbGxvZmYgPSBkaXN0YW5jZUZhbGxvZmY7XG4gICAgc3Nhb01hdGVyaWFsLnByb3hpbWl0eVRocmVzaG9sZCA9IHJhbmdlVGhyZXNob2xkO1xuICAgIHNzYW9NYXRlcmlhbC5wcm94aW1pdHlGYWxsb2ZmID0gcmFuZ2VGYWxsb2ZmO1xuICAgIGlmICh3b3JsZERpc3RhbmNlVGhyZXNob2xkICE9PSB2b2lkIDApIHtcbiAgICAgIHNzYW9NYXRlcmlhbC53b3JsZERpc3RhbmNlVGhyZXNob2xkID0gd29ybGREaXN0YW5jZVRocmVzaG9sZDtcbiAgICB9XG4gICAgaWYgKHdvcmxkRGlzdGFuY2VGYWxsb2ZmICE9PSB2b2lkIDApIHtcbiAgICAgIHNzYW9NYXRlcmlhbC53b3JsZERpc3RhbmNlRmFsbG9mZiA9IHdvcmxkRGlzdGFuY2VGYWxsb2ZmO1xuICAgIH1cbiAgICBpZiAod29ybGRQcm94aW1pdHlUaHJlc2hvbGQgIT09IHZvaWQgMCkge1xuICAgICAgc3Nhb01hdGVyaWFsLndvcmxkUHJveGltaXR5VGhyZXNob2xkID0gd29ybGRQcm94aW1pdHlUaHJlc2hvbGQ7XG4gICAgfVxuICAgIGlmICh3b3JsZFByb3hpbWl0eUZhbGxvZmYgIT09IHZvaWQgMCkge1xuICAgICAgc3Nhb01hdGVyaWFsLndvcmxkUHJveGltaXR5RmFsbG9mZiA9IHdvcmxkUHJveGltaXR5RmFsbG9mZjtcbiAgICB9XG4gICAgaWYgKG5vcm1hbERlcHRoQnVmZmVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnNzYW9NYXRlcmlhbC5ub3JtYWxEZXB0aEJ1ZmZlciA9IG5vcm1hbERlcHRoQnVmZmVyO1xuICAgICAgdGhpcy5kZWZpbmVzLnNldChcIk5PUk1BTF9ERVBUSFwiLCBcIjFcIik7XG4gICAgfVxuICAgIHRoaXMuZGVwdGhBd2FyZVVwc2FtcGxpbmcgPSBkZXB0aEF3YXJlVXBzYW1wbGluZztcbiAgICB0aGlzLmNvbG9yID0gY29sb3IyO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5jYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3ModmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub3JtYWwgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCBub3JtYWxCdWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Nhb01hdGVyaWFsLm5vcm1hbEJ1ZmZlcjtcbiAgfVxuICBzZXQgbm9ybWFsQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwubm9ybWFsQnVmZmVyID0gdmFsdWU7XG4gICAgdGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLm5vcm1hbEJ1ZmZlciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtSZXNvbHV0aW9ufSBUaGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIFNTQU8gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtTU0FPTWF0ZXJpYWx9XG4gICAqL1xuICBnZXQgc3Nhb01hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLnNzYW9QYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgU1NBTyBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNzYW9NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtTU0FPTWF0ZXJpYWx9IFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIGdldFNTQU9NYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zc2FvTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2Ygb2NjbHVzaW9uIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3Nhb01hdGVyaWFsLnNhbXBsZXMgaW5zdGVhZC5cbiAgICovXG4gIGdldCBzYW1wbGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNzYW9NYXRlcmlhbC5zYW1wbGVzO1xuICB9XG4gIHNldCBzYW1wbGVzKHZhbHVlKSB7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwuc2FtcGxlcyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIHNwaXJhbCB0dXJucyBpbiB0aGUgb2NjbHVzaW9uIHNhbXBsaW5nIHBhdHRlcm4uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBzc2FvTWF0ZXJpYWwucmluZ3MgaW5zdGVhZC5cbiAgICovXG4gIGdldCByaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5zc2FvTWF0ZXJpYWwucmluZ3M7XG4gIH1cbiAgc2V0IHJpbmdzKHZhbHVlKSB7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwucmluZ3MgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBzYW1wbGluZyByYWRpdXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBzc2FvTWF0ZXJpYWwucmFkaXVzIGluc3RlYWQuXG4gICAqL1xuICBnZXQgcmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLnNzYW9NYXRlcmlhbC5yYWRpdXM7XG4gIH1cbiAgc2V0IHJhZGl1cyh2YWx1ZSkge1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLnJhZGl1cyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkZXB0aC1hd2FyZSB1cHNhbXBsaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGRlcHRoQXdhcmVVcHNhbXBsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiREVQVEhfQVdBUkVfVVBTQU1QTElOR1wiKTtcbiAgfVxuICBzZXQgZGVwdGhBd2FyZVVwc2FtcGxpbmcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5kZXB0aEF3YXJlVXBzYW1wbGluZyAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiREVQVEhfQVdBUkVfVVBTQU1QTElOR1wiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiREVQVEhfQVdBUkVfVVBTQU1QTElOR1wiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGVwdGgtYXdhcmUgdXBzYW1wbGluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhBd2FyZVVwc2FtcGxpbmcgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBkZXB0aC1hd2FyZSB1cHNhbXBsaW5nIGlzIGVuYWJsZWQuXG4gICAqL1xuICBpc0RlcHRoQXdhcmVVcHNhbXBsaW5nRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZXB0aEF3YXJlVXBzYW1wbGluZztcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBkZXB0aC1hd2FyZSB1cHNhbXBsaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhBd2FyZVVwc2FtcGxpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgZGVwdGgtYXdhcmUgdXBzYW1wbGluZyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldERlcHRoQXdhcmVVcHNhbXBsaW5nRW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuZGVwdGhBd2FyZVVwc2FtcGxpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGlzdGFuY2UtYmFzZWQgcmFkaXVzIHNjYWxpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgZGlzdGFuY2VTY2FsaW5nKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldCBkaXN0YW5jZVNjYWxpbmcodmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBhbWJpZW50IG9jY2x1c2lvbi4gU2V0IHRvIGBudWxsYCB0byBkaXNhYmxlLlxuICAgKlxuICAgKiBAdHlwZSB7Q29sb3J9XG4gICAqL1xuICBnZXQgY29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiY29sb3JcIikudmFsdWU7XG4gIH1cbiAgc2V0IGNvbG9yKHZhbHVlKSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGNvbnN0IGRlZmluZXMgPSB0aGlzLmRlZmluZXM7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBpZiAoZGVmaW5lcy5oYXMoXCJDT0xPUklaRVwiKSkge1xuICAgICAgICB1bmlmb3Jtcy5nZXQoXCJjb2xvclwiKS52YWx1ZS5zZXQodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lcy5zZXQoXCJDT0xPUklaRVwiLCBcIjFcIik7XG4gICAgICAgIHVuaWZvcm1zLmdldChcImNvbG9yXCIpLnZhbHVlID0gbmV3IENvbG9yOSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGVmaW5lcy5oYXMoXCJDT0xPUklaRVwiKSkge1xuICAgICAgZGVmaW5lcy5kZWxldGUoXCJDT0xPUklaRVwiKTtcbiAgICAgIHVuaWZvcm1zLmdldChcImNvbG9yXCIpLnZhbHVlID0gbnVsbDtcbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSBpbmZsdWVuY2UgZmFjdG9yLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgbHVtaW5hbmNlSW5mbHVlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImx1bWluYW5jZUluZmx1ZW5jZVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgbHVtaW5hbmNlSW5mbHVlbmNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJsdW1pbmFuY2VJbmZsdWVuY2VcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGludGVuc2l0eS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBpbnRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiaW50ZW5zaXR5XCIpLnZhbHVlO1xuICB9XG4gIHNldCBpbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImludGVuc2l0eVwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb2xvciBvZiB0aGUgYW1iaWVudCBvY2NsdXNpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb2xvciBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtDb2xvcn0gVGhlIGNvbG9yLlxuICAgKi9cbiAgZ2V0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3I7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbG9yIG9mIHRoZSBhbWJpZW50IG9jY2x1c2lvbi4gU2V0IHRvIGBudWxsYCB0byBkaXNhYmxlIGNvbG9yaXphdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvbG9yIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Q29sb3J9IHZhbHVlIC0gVGhlIGNvbG9yLlxuICAgKi9cbiAgc2V0Q29sb3IodmFsdWUpIHtcbiAgICB0aGlzLmNvbG9yID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9jY2x1c2lvbiBkaXN0YW5jZSBjdXRvZmYuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzc2FvTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRocmVzaG9sZCAtIFRoZSBkaXN0YW5jZSB0aHJlc2hvbGQuIFJhbmdlIFswLjAsIDEuMF0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmYWxsb2ZmIC0gVGhlIGZhbGxvZmYuIFJhbmdlIFswLjAsIDEuMF0uXG4gICAqL1xuICBzZXREaXN0YW5jZUN1dG9mZih0aHJlc2hvbGQsIGZhbGxvZmYpIHtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5kaXN0YW5jZVRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5kaXN0YW5jZUZhbGxvZmYgPSBmYWxsb2ZmO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvY2NsdXNpb24gcHJveGltaXR5IGN1dG9mZi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNzYW9NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkIC0gVGhlIHByb3hpbWl0eSB0aHJlc2hvbGQuIFJhbmdlIFswLjAsIDEuMF0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmYWxsb2ZmIC0gVGhlIGZhbGxvZmYuIFJhbmdlIFswLjAsIDEuMF0uXG4gICAqL1xuICBzZXRQcm94aW1pdHlDdXRvZmYodGhyZXNob2xkLCBmYWxsb2ZmKSB7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwucHJveGltaXR5VGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLnByb3hpbWl0eUZhbGxvZmYgPSBmYWxsb2ZmO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxMykge1xuICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLnNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyk7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwuZGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcbiAgICBpZiAodGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3MuZW5hYmxlZCkge1xuICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3MucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gICAgdGhpcy5zc2FvUGFzcy5yZW5kZXIocmVuZGVyZXIsIG51bGwsIHJlbmRlclRhcmdldCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3ModGhpcy5jYW1lcmEpO1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy5yZXNvbHV0aW9uLnNjYWxlID0gcmVzb2x1dGlvbi5zY2FsZTtcbiAgICB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IG5vcm1hbERlcHRoQnVmZmVyID0gdGhpcy51bmlmb3Jtcy5nZXQoXCJub3JtYWxEZXB0aEJ1ZmZlclwiKS52YWx1ZTtcbiAgICAgIGlmIChub3JtYWxEZXB0aEJ1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICAgICAgbm9ybWFsRGVwdGhCdWZmZXIgPSB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy50ZXh0dXJlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmdldChcIm5vcm1hbERlcHRoQnVmZmVyXCIpLnZhbHVlID0gbm9ybWFsRGVwdGhCdWZmZXI7XG4gICAgICAgIHRoaXMuc3Nhb01hdGVyaWFsLm5vcm1hbERlcHRoQnVmZmVyID0gbm9ybWFsRGVwdGhCdWZmZXI7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJOT1JNQUxfREVQVEhcIiwgXCIxXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1RleHR1cmVFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTQyLCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUxMiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3RleHR1cmUuZnJhZ1xudmFyIHRleHR1cmVfZGVmYXVsdCA9IGAjaWZkZWYgVEVYVFVSRV9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBtYXA7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBtYXA7XG4jZW5kaWZcbnZhcnlpbmcgdmVjMiB2VXYyO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtcbiNpZmRlZiBVVl9UUkFOU0ZPUk1cbnZlYzQgdGV4ZWw9dGV4dHVyZTJEKG1hcCx2VXYyKTtcbiNlbHNlXG52ZWM0IHRleGVsPXRleHR1cmUyRChtYXAsdXYpO1xuI2VuZGlmXG5vdXRwdXRDb2xvcj1URVhFTDtvdXRwdXRDb2xvci5hPW1heChpbnB1dENvbG9yLmEsb3V0cHV0Q29sb3IuYSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvdGV4dHVyZS52ZXJ0XG52YXIgdGV4dHVyZV9kZWZhdWx0MiA9IGAjaWZkZWYgQVNQRUNUX0NPUlJFQ1RJT05cbnVuaWZvcm0gZmxvYXQgc2NhbGU7XG4jZWxzZVxudW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xuI2VuZGlmXG52YXJ5aW5nIHZlYzIgdlV2Mjt2b2lkIG1haW5TdXBwb3J0KGNvbnN0IGluIHZlYzIgdXYpe1xuI2lmZGVmIEFTUEVDVF9DT1JSRUNUSU9OXG52VXYyPXV2KnZlYzIoYXNwZWN0LDEuMCkqc2NhbGU7XG4jZWxzZVxudlV2Mj0odXZUcmFuc2Zvcm0qdmVjMyh1diwxLjApKS54eTtcbiNlbmRpZlxufWA7XG5cbi8vIHNyYy9lZmZlY3RzL1RleHR1cmVFZmZlY3QuanNcbnZhciBUZXh0dXJlRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyB0ZXh0dXJlIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb25dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IFtvcHRpb25zLnRleHR1cmVdIC0gQSB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFzcGVjdENvcnJlY3Rpb249ZmFsc2VdIC0gRGVwcmVjYXRlZC4gQWRqdXN0IHRoZSB0ZXh0dXJlJ3Mgb2Zmc2V0LCByZXBlYXQgYW5kIGNlbnRlciBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uLCB0ZXh0dXJlID0gbnVsbCwgYXNwZWN0Q29ycmVjdGlvbiA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiVGV4dHVyZUVmZmVjdFwiLCB0ZXh0dXJlX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBkZWZpbmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIlRFWEVMXCIsIFwidGV4ZWxcIl1cbiAgICAgIF0pLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wibWFwXCIsIG5ldyBVbmlmb3JtNDIobnVsbCldLFxuICAgICAgICBbXCJzY2FsZVwiLCBuZXcgVW5pZm9ybTQyKDEpXSxcbiAgICAgICAgW1widXZUcmFuc2Zvcm1cIiwgbmV3IFVuaWZvcm00MihudWxsKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLmFzcGVjdENvcnJlY3Rpb24gPSBhc3BlY3RDb3JyZWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXBcIikudmFsdWU7XG4gIH1cbiAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICBjb25zdCBwcmV2VGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gICAgY29uc3QgZGVmaW5lcyA9IHRoaXMuZGVmaW5lcztcbiAgICBpZiAocHJldlRleHR1cmUgIT09IHZhbHVlKSB7XG4gICAgICB1bmlmb3Jtcy5nZXQoXCJtYXBcIikudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHVuaWZvcm1zLmdldChcInV2VHJhbnNmb3JtXCIpLnZhbHVlID0gdmFsdWUubWF0cml4O1xuICAgICAgZGVmaW5lcy5kZWxldGUoXCJURVhUVVJFX1BSRUNJU0lPTl9ISUdIXCIpO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh2YWx1ZS5tYXRyaXhBdXRvVXBkYXRlKSB7XG4gICAgICAgICAgZGVmaW5lcy5zZXQoXCJVVl9UUkFOU0ZPUk1cIiwgXCIxXCIpO1xuICAgICAgICAgIHRoaXMuc2V0VmVydGV4U2hhZGVyKHRleHR1cmVfZGVmYXVsdDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmluZXMuZGVsZXRlKFwiVVZfVFJBTlNGT1JNXCIpO1xuICAgICAgICAgIHRoaXMuc2V0VmVydGV4U2hhZGVyKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlMTIpIHtcbiAgICAgICAgICBkZWZpbmVzLnNldChcIlRFWFRVUkVfUFJFQ0lTSU9OX0hJR0hcIiwgXCIxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2VGV4dHVyZSA9PT0gbnVsbCB8fCBwcmV2VGV4dHVyZS50eXBlICE9PSB2YWx1ZS50eXBlIHx8IHByZXZUZXh0dXJlLmVuY29kaW5nICE9PSB2YWx1ZS5lbmNvZGluZykge1xuICAgICAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgc2V0VGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMudGV4dHVyZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhc3BlY3QgY29ycmVjdGlvbiBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBBZGp1c3QgdGhlIHRleHR1cmUncyBvZmZzZXQsIHJlcGVhdCwgcm90YXRpb24gYW5kIGNlbnRlciBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGFzcGVjdENvcnJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJBU1BFQ1RfQ09SUkVDVElPTlwiKTtcbiAgfVxuICBzZXQgYXNwZWN0Q29ycmVjdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLmFzcGVjdENvcnJlY3Rpb24gIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIkFTUEVDVF9DT1JSRUNUSU9OXCIsIFwiMVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJBU1BFQ1RfQ09SUkVDVElPTlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRleHR1cmUgVVYgY29vcmRpbmF0ZXMgd2lsbCBiZSB0cmFuc2Zvcm1lZCB1c2luZyB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUubWF0cml4QXV0b1VwZGF0ZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHV2VHJhbnNmb3JtKCkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgcmV0dXJuIHRleHR1cmUgIT09IG51bGwgJiYgdGV4dHVyZS5tYXRyaXhBdXRvVXBkYXRlO1xuICB9XG4gIHNldCB1dlRyYW5zZm9ybSh2YWx1ZSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgaWYgKHRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgIHRleHR1cmUubWF0cml4QXV0b1VwZGF0ZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3dpenpsZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudHMgb2YgYSB0ZXhlbCBiZWZvcmUgaXQgaXMgd3JpdHRlbiB0byB0aGUgb3V0cHV0IGNvbG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbG9yQ2hhbm5lbH0gciAtIFRoZSBzd2l6emxlIGZvciB0aGUgYHJgIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtDb2xvckNoYW5uZWx9IFtnPXJdIC0gVGhlIHN3aXp6bGUgZm9yIHRoZSBgZ2AgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0NvbG9yQ2hhbm5lbH0gW2I9cl0gLSBUaGUgc3dpenpsZSBmb3IgdGhlIGBiYCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7Q29sb3JDaGFubmVsfSBbYT1yXSAtIFRoZSBzd2l6emxlIGZvciB0aGUgYGFgIGNvbXBvbmVudC5cbiAgICovXG4gIHNldFRleHR1cmVTd2l6emxlUkdCQShyLCBnID0gciwgYiA9IHIsIGEgPSByKSB7XG4gICAgY29uc3QgcmdiYSA9IFwicmdiYVwiO1xuICAgIGxldCBzd2l6emxlID0gXCJcIjtcbiAgICBpZiAociAhPT0gQ29sb3JDaGFubmVsLlJFRCB8fCBnICE9PSBDb2xvckNoYW5uZWwuR1JFRU4gfHwgYiAhPT0gQ29sb3JDaGFubmVsLkJMVUUgfHwgYSAhPT0gQ29sb3JDaGFubmVsLkFMUEhBKSB7XG4gICAgICBzd2l6emxlID0gW1wiLlwiLCByZ2JhW3JdLCByZ2JhW2ddLCByZ2JhW2JdLCByZ2JhW2FdXS5qb2luKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiVEVYRUxcIiwgXCJ0ZXhlbFwiICsgc3dpenpsZSk7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICAgIGlmICh0aGlzLnRleHR1cmUubWF0cml4QXV0b1VwZGF0ZSkge1xuICAgICAgdGhpcy50ZXh0dXJlLnVwZGF0ZU1hdHJpeCgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvVGlsdFNoaWZ0RWZmZWN0LmpzXG5pbXBvcnQgeyBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTEyLCBVbmlmb3JtIGFzIFVuaWZvcm00NCwgVmVjdG9yMiBhcyBWZWN0b3IyMjQsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTcgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9UaWx0U2hpZnRCbHVyTWF0ZXJpYWwuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTQzLCBWZWN0b3IyIGFzIFZlY3RvcjIyMywgVmVjdG9yNCBhcyBWZWN0b3I0NSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24udGlsdC1zaGlmdC5mcmFnXG52YXIgY29udm9sdXRpb25fdGlsdF9zaGlmdF9kZWZhdWx0ID0gYCNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2VuZGlmXG51bmlmb3JtIHZlYzQgbWFza1BhcmFtczt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2T2Zmc2V0O2Zsb2F0IGxpbmVhckdyYWRpZW50TWFzayhjb25zdCBpbiBmbG9hdCB4KXtyZXR1cm4gc21vb3Roc3RlcChtYXNrUGFyYW1zLngsbWFza1BhcmFtcy55LHgpLXNtb290aHN0ZXAobWFza1BhcmFtcy53LG1hc2tQYXJhbXMueix4KTt9dm9pZCBtYWluKCl7dmVjMiBkVXY9dk9mZnNldCooMS4wLWxpbmVhckdyYWRpZW50TWFzayh2VXYyLnkpKTt2ZWM0IHN1bT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdmVjMih2VXYueC1kVXYueCx2VXYueStkVXYueSkpO3N1bSs9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZlYzIodlV2LngrZFV2LngsdlV2LnkrZFV2LnkpKTtzdW0rPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2ZWMyKHZVdi54K2RVdi54LHZVdi55LWRVdi55KSk7c3VtKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdmVjMih2VXYueC1kVXYueCx2VXYueS1kVXYueSkpO2dsX0ZyYWdDb2xvcj1zdW0qMC4yNTtcbiNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxufWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi50aWx0LXNoaWZ0LnZlcnRcbnZhciBjb252b2x1dGlvbl90aWx0X3NoaWZ0X2RlZmF1bHQyID0gYHVuaWZvcm0gdmVjNCB0ZXhlbFNpemU7dW5pZm9ybSBmbG9hdCBrZXJuZWw7dW5pZm9ybSBmbG9hdCBzY2FsZTt1bmlmb3JtIGZsb2F0IGFzcGVjdDt1bmlmb3JtIHZlYzIgcm90YXRpb247dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdk9mZnNldDt2b2lkIG1haW4oKXt2ZWMyIHV2PXBvc2l0aW9uLnh5KjAuNSswLjU7dlV2PXV2O3ZVdjI9KHV2LTAuNSkqMi4wKnZlYzIoYXNwZWN0LDEuMCk7dlV2Mj12ZWMyKGRvdChyb3RhdGlvbix2VXYyKSxkb3Qocm90YXRpb24sdmVjMih2VXYyLnksLXZVdjIueCkpKTt2T2Zmc2V0PSh0ZXhlbFNpemUueHkqdmVjMihrZXJuZWwpK3RleGVsU2l6ZS56dykqc2NhbGU7Z2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9UaWx0U2hpZnRCbHVyTWF0ZXJpYWwuanNcbnZhciBUaWx0U2hpZnRCbHVyTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIEthd2FzZUJsdXJNYXRlcmlhbCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHRpbHQgc2hpZnQgYmx1ciBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0PTAuMF0gLSBUaGUgcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm90YXRpb249MC4wXSAtIFRoZSByb3RhdGlvbiBvZiB0aGUgZm9jdXMgYXJlYSBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXNBcmVhPTAuNF0gLSBUaGUgcmVsYXRpdmUgc2l6ZSBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZlYXRoZXI9MC4zXSAtIFRoZSBzb2Z0bmVzcyBvZiB0aGUgZm9jdXMgYXJlYSBlZGdlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBrZXJuZWxTaXplID0gS2VybmVsU2l6ZS5NRURJVU0sXG4gICAgb2Zmc2V0ID0gMCxcbiAgICByb3RhdGlvbiA9IDAsXG4gICAgZm9jdXNBcmVhID0gMC40LFxuICAgIGZlYXRoZXIgPSAwLjNcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gY29udm9sdXRpb25fdGlsdF9zaGlmdF9kZWZhdWx0O1xuICAgIHRoaXMudmVydGV4U2hhZGVyID0gY29udm9sdXRpb25fdGlsdF9zaGlmdF9kZWZhdWx0MjtcbiAgICB0aGlzLmtlcm5lbFNpemUgPSBrZXJuZWxTaXplO1xuICAgIHRoaXMudW5pZm9ybXMuYXNwZWN0ID0gbmV3IFVuaWZvcm00MygxKTtcbiAgICB0aGlzLnVuaWZvcm1zLnJvdGF0aW9uID0gbmV3IFVuaWZvcm00MyhuZXcgVmVjdG9yMjIzKCkpO1xuICAgIHRoaXMudW5pZm9ybXMubWFza1BhcmFtcyA9IG5ldyBVbmlmb3JtNDMobmV3IFZlY3RvcjQ1KCkpO1xuICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLl9mb2N1c0FyZWEgPSBmb2N1c0FyZWE7XG4gICAgdGhpcy5fZmVhdGhlciA9IGZlYXRoZXI7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMudXBkYXRlUGFyYW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZWxhdGl2ZSBvZmZzZXQgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVQYXJhbXMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy51bmlmb3Jtcy5tYXNrUGFyYW1zLnZhbHVlO1xuICAgIGNvbnN0IGEgPSBNYXRoLm1heCh0aGlzLmZvY3VzQXJlYSwgMCk7XG4gICAgY29uc3QgYiA9IE1hdGgubWF4KGEgLSB0aGlzLmZlYXRoZXIsIDApO1xuICAgIHBhcmFtcy5zZXQoXG4gICAgICB0aGlzLm9mZnNldCAtIGEsXG4gICAgICB0aGlzLm9mZnNldCAtIGIsXG4gICAgICB0aGlzLm9mZnNldCArIGEsXG4gICAgICB0aGlzLm9mZnNldCArIGJcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIGZvY3VzIGFyZWEgaW4gcmFkaWFucy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByb3RhdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5hY29zKHRoaXMudW5pZm9ybXMucm90YXRpb24udmFsdWUueCk7XG4gIH1cbiAgc2V0IHJvdGF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvbi52YWx1ZS5zZXQoTWF0aC5jb3ModmFsdWUpLCBNYXRoLnNpbih2YWx1ZSkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICB9XG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLl9vZmZzZXQgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVBhcmFtcygpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVsYXRpdmUgc2l6ZSBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBmb2N1c0FyZWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzQXJlYTtcbiAgfVxuICBzZXQgZm9jdXNBcmVhKHZhbHVlKSB7XG4gICAgdGhpcy5fZm9jdXNBcmVhID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYXJhbXMoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNvZnRuZXNzIG9mIHRoZSBmb2N1cyBhcmVhIGVkZ2VzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZlYXRoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZlYXRoZXI7XG4gIH1cbiAgc2V0IGZlYXRoZXIodmFsdWUpIHtcbiAgICB0aGlzLl9mZWF0aGVyID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYXJhbXMoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHN1cGVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy5hc3BlY3QudmFsdWUgPSB3aWR0aCAvIGhlaWdodDtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9UaWx0U2hpZnRCbHVyUGFzcy5qc1xudmFyIFRpbHRTaGlmdEJsdXJQYXNzID0gY2xhc3MgZXh0ZW5kcyBLYXdhc2VCbHVyUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEthd2FzZSBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldD0wLjBdIC0gVGhlIHJlbGF0aXZlIG9mZnNldCBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJvdGF0aW9uPTAuMF0gLSBUaGUgcm90YXRpb24gb2YgdGhlIGZvY3VzIGFyZWEgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvY3VzQXJlYT0wLjRdIC0gVGhlIHJlbGF0aXZlIHNpemUgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mZWF0aGVyPTAuM10gLSBUaGUgc29mdG5lc3Mgb2YgdGhlIGZvY3VzIGFyZWEgZWRnZXMuXG4gICAqIEBwYXJhbSB7S2VybmVsU2l6ZX0gW29wdGlvbnMua2VybmVsU2l6ZT1LZXJuZWxTaXplLk1FRElVTV0gLSBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb2Zmc2V0ID0gMCxcbiAgICByb3RhdGlvbiA9IDAsXG4gICAgZm9jdXNBcmVhID0gMC40LFxuICAgIGZlYXRoZXIgPSAwLjMsXG4gICAga2VybmVsU2l6ZSA9IEtlcm5lbFNpemUuTUVESVVNLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDAuNSxcbiAgICByZXNvbHV0aW9uWCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25ZID0gUmVzb2x1dGlvbi5BVVRPX1NJWkVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBrZXJuZWxTaXplLCByZXNvbHV0aW9uU2NhbGUsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSB9KTtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbCA9IG5ldyBUaWx0U2hpZnRCbHVyTWF0ZXJpYWwoeyBrZXJuZWxTaXplLCBvZmZzZXQsIHJvdGF0aW9uLCBmb2N1c0FyZWEsIGZlYXRoZXIgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvdGlsdC1zaGlmdC5mcmFnXG52YXIgdGlsdF9zaGlmdF9kZWZhdWx0ID0gYCNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBtYXA7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBtYXA7XG4jZW5kaWZcbnVuaWZvcm0gdmVjMiBtYXNrUGFyYW1zO3ZhcnlpbmcgdmVjMiB2VXYyO2Zsb2F0IGxpbmVhckdyYWRpZW50TWFzayhjb25zdCBpbiBmbG9hdCB4KXtyZXR1cm4gc3RlcChtYXNrUGFyYW1zLngseCktc3RlcChtYXNrUGFyYW1zLnkseCk7fXZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtmbG9hdCBtYXNrPWxpbmVhckdyYWRpZW50TWFzayh2VXYyLnkpO3ZlYzQgdGV4ZWw9dGV4dHVyZTJEKG1hcCx1dik7b3V0cHV0Q29sb3I9bWl4KHRleGVsLGlucHV0Q29sb3IsbWFzayk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvdGlsdC1zaGlmdC52ZXJ0XG52YXIgdGlsdF9zaGlmdF9kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzIgcm90YXRpb247dmFyeWluZyB2ZWMyIHZVdjI7dm9pZCBtYWluU3VwcG9ydChjb25zdCBpbiB2ZWMyIHV2KXt2VXYyPSh1di0wLjUpKjIuMCp2ZWMyKGFzcGVjdCwxLjApO3ZVdjI9dmVjMihkb3Qocm90YXRpb24sdlV2MiksZG90KHJvdGF0aW9uLHZlYzIodlV2Mi55LC12VXYyLngpKSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL1RpbHRTaGlmdEVmZmVjdC5qc1xudmFyIFRpbHRTaGlmdEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgdGlsdCBzaGlmdCBFZmZlY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb25dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0PTAuMF0gLSBUaGUgcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm90YXRpb249MC4wXSAtIFRoZSByb3RhdGlvbiBvZiB0aGUgZm9jdXMgYXJlYSBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXNBcmVhPTAuNF0gLSBUaGUgcmVsYXRpdmUgc2l6ZSBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZlYXRoZXI9MC4zXSAtIFRoZSBzb2Z0bmVzcyBvZiB0aGUgZm9jdXMgYXJlYSBlZGdlcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJpYXM9MC4wNl0gLSBEZXByZWNhdGVkLlxuICAgKiBAcGFyYW0ge0tlcm5lbFNpemV9IFtvcHRpb25zLmtlcm5lbFNpemU9S2VybmVsU2l6ZS5NRURJVU1dIC0gVGhlIGJsdXIga2VybmVsIHNpemUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MC41XSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgb2Zmc2V0ID0gMCxcbiAgICByb3RhdGlvbiA9IDAsXG4gICAgZm9jdXNBcmVhID0gMC40LFxuICAgIGZlYXRoZXIgPSAwLjMsXG4gICAga2VybmVsU2l6ZSA9IEtlcm5lbFNpemUuTUVESVVNLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDAuNSxcbiAgICByZXNvbHV0aW9uWCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25ZID0gUmVzb2x1dGlvbi5BVVRPX1NJWkVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJUaWx0U2hpZnRFZmZlY3RcIiwgdGlsdF9zaGlmdF9kZWZhdWx0LCB7XG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHRpbHRfc2hpZnRfZGVmYXVsdDIsXG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wicm90YXRpb25cIiwgbmV3IFVuaWZvcm00NChuZXcgVmVjdG9yMjI0KCkpXSxcbiAgICAgICAgW1wibWFza1BhcmFtc1wiLCBuZXcgVW5pZm9ybTQ0KG5ldyBWZWN0b3IyMjQoKSldLFxuICAgICAgICBbXCJtYXBcIiwgbmV3IFVuaWZvcm00NChudWxsKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMuX2ZvY3VzQXJlYSA9IGZvY3VzQXJlYTtcbiAgICB0aGlzLl9mZWF0aGVyID0gZmVhdGhlcjtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDE3KDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiVGlsdFNoaWZ0LlRhcmdldFwiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibWFwXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICB0aGlzLmJsdXJQYXNzID0gbmV3IFRpbHRTaGlmdEJsdXJQYXNzKHtcbiAgICAgIGtlcm5lbFNpemUsXG4gICAgICByZXNvbHV0aW9uU2NhbGUsXG4gICAgICByZXNvbHV0aW9uWCxcbiAgICAgIHJlc29sdXRpb25ZLFxuICAgICAgb2Zmc2V0LFxuICAgICAgcm90YXRpb24sXG4gICAgICBmb2N1c0FyZWEsXG4gICAgICBmZWF0aGVyXG4gICAgfSk7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbiA9IG5ldyBSZXNvbHV0aW9uKHRoaXMsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwgcmVzb2x1dGlvblNjYWxlKTtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMudXBkYXRlUGFyYW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIG1hc2sgcGFyYW1zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlUGFyYW1zKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMudW5pZm9ybXMuZ2V0KFwibWFza1BhcmFtc1wiKS52YWx1ZTtcbiAgICBjb25zdCB4ID0gTWF0aC5tYXgodGhpcy5mb2N1c0FyZWEgLSB0aGlzLmZlYXRoZXIsIDApO1xuICAgIHBhcmFtcy5zZXQodGhpcy5vZmZzZXQgLSB4LCB0aGlzLm9mZnNldCArIHgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIGZvY3VzIGFyZWEgaW4gcmFkaWFucy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByb3RhdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5hY29zKHRoaXMudW5pZm9ybXMuZ2V0KFwicm90YXRpb25cIikudmFsdWUueCk7XG4gIH1cbiAgc2V0IHJvdGF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJyb3RhdGlvblwiKS52YWx1ZS5zZXQoTWF0aC5jb3ModmFsdWUpLCBNYXRoLnNpbih2YWx1ZSkpO1xuICAgIHRoaXMuYmx1clBhc3MuYmx1ck1hdGVyaWFsLnJvdGF0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZWxhdGl2ZSBvZmZzZXQgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gIH1cbiAgc2V0IG9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMuX29mZnNldCA9IHZhbHVlO1xuICAgIHRoaXMuYmx1clBhc3MuYmx1ck1hdGVyaWFsLm9mZnNldCA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlUGFyYW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZWxhdGl2ZSBzaXplIG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZvY3VzQXJlYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9jdXNBcmVhO1xuICB9XG4gIHNldCBmb2N1c0FyZWEodmFsdWUpIHtcbiAgICB0aGlzLl9mb2N1c0FyZWEgPSB2YWx1ZTtcbiAgICB0aGlzLmJsdXJQYXNzLmJsdXJNYXRlcmlhbC5mb2N1c0FyZWEgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVBhcmFtcygpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc29mdG5lc3Mgb2YgdGhlIGZvY3VzIGFyZWEgZWRnZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZmVhdGhlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmVhdGhlcjtcbiAgfVxuICBzZXQgZmVhdGhlcih2YWx1ZSkge1xuICAgIHRoaXMuX2ZlYXRoZXIgPSB2YWx1ZTtcbiAgICB0aGlzLmJsdXJQYXNzLmJsdXJNYXRlcmlhbC5mZWF0aGVyID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYXJhbXMoKTtcbiAgfVxuICAvKipcbiAgICogQSBibGVuZCBiaWFzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGJpYXMoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgc2V0IGJpYXModmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCB0aGlzLnJlbmRlclRhcmdldCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZShyZXNvbHV0aW9uLndpZHRoLCByZXNvbHV0aW9uLmhlaWdodCk7XG4gICAgdGhpcy5ibHVyUGFzcy5yZXNvbHV0aW9uLmNvcHkocmVzb2x1dGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRoaXMuYmx1clBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICBpZiAocmVuZGVyZXIgIT09IG51bGwgJiYgcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UxMikge1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTEyO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvVG9uZU1hcHBpbmdFZmZlY3QuanNcbmltcG9ydCB7IExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgUkVWSVNJT04gYXMgUkVWSVNJT04zLCBVbmlmb3JtIGFzIFVuaWZvcm00NiwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxOSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvcGFzc2VzL0FkYXB0aXZlTHVtaW5hbmNlUGFzcy5qc1xuaW1wb3J0IHsgTmVhcmVzdEZpbHRlciBhcyBOZWFyZXN0RmlsdGVyNiwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxOCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0FkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzE3LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDE4LCBVbmlmb3JtIGFzIFVuaWZvcm00NSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvYWRhcHRpdmUtbHVtaW5hbmNlLmZyYWdcbnZhciBhZGFwdGl2ZV9sdW1pbmFuY2VfZGVmYXVsdCA9IGAjaW5jbHVkZSA8cGFja2luZz5cbiNkZWZpbmUgcGFja0Zsb2F0VG9SR0JBKHYpIHBhY2tEZXB0aFRvUkdCQSh2KVxuI2RlZmluZSB1bnBhY2tSR0JBVG9GbG9hdCh2KSB1bnBhY2tSR0JBVG9EZXB0aCh2KVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBsdW1pbmFuY2VCdWZmZXIwO3VuaWZvcm0gbG93cCBzYW1wbGVyMkQgbHVtaW5hbmNlQnVmZmVyMTt1bmlmb3JtIGZsb2F0IG1pbkx1bWluYW5jZTt1bmlmb3JtIGZsb2F0IGRlbHRhVGltZTt1bmlmb3JtIGZsb2F0IHRhdTt2YXJ5aW5nIHZlYzIgdlV2O3ZvaWQgbWFpbigpe2Zsb2F0IGwwPXVucGFja1JHQkFUb0Zsb2F0KHRleHR1cmUyRChsdW1pbmFuY2VCdWZmZXIwLHZVdikpO1xuI2lmIF9fVkVSU0lPTl9fIDwgMzAwXG5mbG9hdCBsMT10ZXh0dXJlMkRMb2RFWFQobHVtaW5hbmNlQnVmZmVyMSx2VXYsTUlQX0xFVkVMXzFYMSkucjtcbiNlbHNlXG5mbG9hdCBsMT10ZXh0dXJlTG9kKGx1bWluYW5jZUJ1ZmZlcjEsdlV2LE1JUF9MRVZFTF8xWDEpLnI7XG4jZW5kaWZcbmwwPW1heChtaW5MdW1pbmFuY2UsbDApO2wxPW1heChtaW5MdW1pbmFuY2UsbDEpO2Zsb2F0IGFkYXB0ZWRMdW09bDArKGwxLWwwKSooMS4wLWV4cCgtZGVsdGFUaW1lKnRhdSkpO2dsX0ZyYWdDb2xvcj0oYWRhcHRlZEx1bT09MS4wKT92ZWM0KDEuMCk6cGFja0Zsb2F0VG9SR0JBKGFkYXB0ZWRMdW0pO31gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0FkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwuanNcbnZhciBBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDE4IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYWRhcHRpdmUgbHVtaW5hbmNlIG1hdGVyaWFsLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIE1JUF9MRVZFTF8xWDE6IFwiMC4wXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBsdW1pbmFuY2VCdWZmZXIwOiBuZXcgVW5pZm9ybTQ1KG51bGwpLFxuICAgICAgICBsdW1pbmFuY2VCdWZmZXIxOiBuZXcgVW5pZm9ybTQ1KG51bGwpLFxuICAgICAgICBtaW5MdW1pbmFuY2U6IG5ldyBVbmlmb3JtNDUoMC4wMSksXG4gICAgICAgIGRlbHRhVGltZTogbmV3IFVuaWZvcm00NSgwKSxcbiAgICAgICAgdGF1OiBuZXcgVW5pZm9ybTQ1KDEpXG4gICAgICB9LFxuICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICBzaGFkZXJUZXh0dXJlTE9EOiB0cnVlXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcxNyxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGFkYXB0aXZlX2x1bWluYW5jZV9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb21tb25fZGVmYXVsdFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcHJpbWFyeSBsdW1pbmFuY2UgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIGRvd25zYW1wbGVkIGF2ZXJhZ2UgbHVtaW5hbmNlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBsdW1pbmFuY2VCdWZmZXIwKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5sdW1pbmFuY2VCdWZmZXIwLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByaW1hcnkgbHVtaW5hbmNlIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSBkb3duc2FtcGxlZCBhdmVyYWdlIGx1bWluYW5jZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGx1bWluYW5jZUJ1ZmZlcjAgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBidWZmZXIuXG4gICAqL1xuICBzZXRMdW1pbmFuY2VCdWZmZXIwKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5sdW1pbmFuY2VCdWZmZXIwLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzZWNvbmRhcnkgbHVtaW5hbmNlIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgbHVtaW5hbmNlQnVmZmVyMSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubHVtaW5hbmNlQnVmZmVyMS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWNvbmRhcnkgbHVtaW5hbmNlIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGx1bWluYW5jZUJ1ZmZlcjEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBidWZmZXIuXG4gICAqL1xuICBzZXRMdW1pbmFuY2VCdWZmZXIxKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5sdW1pbmFuY2VCdWZmZXIxLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSAxeDEgbWlwbWFwIGxldmVsLlxuICAgKlxuICAgKiBUaGlzIGxldmVsIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHNtYWxsZXN0IG1pcG1hcCBvZiB0aGUgcHJpbWFyeSBsdW1pbmFuY2UgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IG1pcExldmVsMXgxKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLk1JUF9MRVZFTF8xWDEgPSB2YWx1ZS50b0ZpeGVkKDEpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSAxeDEgbWlwbWFwIGxldmVsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWlwTGV2ZWwxeDEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGxldmVsLlxuICAgKi9cbiAgc2V0TWlwTGV2ZWwxeDEodmFsdWUpIHtcbiAgICB0aGlzLm1pcExldmVsMXgxID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZWx0YSB0aW1lLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IGRlbHRhVGltZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVsdGFUaW1lLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlbHRhIHRpbWUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZWx0YVRpbWUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGRlbHRhIHRpbWUuXG4gICAqL1xuICBzZXREZWx0YVRpbWUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlbHRhVGltZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbG93ZXN0IHBvc3NpYmxlIGx1bWluYW5jZSB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtaW5MdW1pbmFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWluTHVtaW5hbmNlLnZhbHVlO1xuICB9XG4gIHNldCBtaW5MdW1pbmFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm1pbkx1bWluYW5jZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsb3dlc3QgcG9zc2libGUgbHVtaW5hbmNlIHZhbHVlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWluTHVtaW5hbmNlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1pbmltdW0gbHVtaW5hbmNlLlxuICAgKi9cbiAgZ2V0TWluTHVtaW5hbmNlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1pbkx1bWluYW5jZS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWluaW11bSBsdW1pbmFuY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtaW5MdW1pbmFuY2UgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG1pbmltdW0gbHVtaW5hbmNlLlxuICAgKi9cbiAgc2V0TWluTHVtaW5hbmNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5taW5MdW1pbmFuY2UudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSBhZGFwdGF0aW9uIHJhdGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYWRhcHRhdGlvblJhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudGF1LnZhbHVlO1xuICB9XG4gIHNldCBhZGFwdGF0aW9uUmF0ZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudGF1LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGx1bWluYW5jZSBhZGFwdGF0aW9uIHJhdGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBhZGFwdGF0aW9uUmF0ZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhZGFwdGF0aW9uIHJhdGUuXG4gICAqL1xuICBnZXRBZGFwdGF0aW9uUmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy50YXUudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGx1bWluYW5jZSBhZGFwdGF0aW9uIHJhdGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBhZGFwdGF0aW9uUmF0ZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgYWRhcHRhdGlvbiByYXRlLlxuICAgKi9cbiAgc2V0QWRhcHRhdGlvblJhdGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRhdS52YWx1ZSA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0FkYXB0aXZlTHVtaW5hbmNlUGFzcy5qc1xudmFyIEFkYXB0aXZlTHVtaW5hbmNlUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGFkYXB0aXZlIGx1bWluYW5jZSBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGx1bWluYW5jZUJ1ZmZlciAtIEEgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIGN1cnJlbnQgc2NlbmUgbHVtaW5hbmNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5MdW1pbmFuY2U9MC4wMV0gLSBUaGUgbWluaW11bSBsdW1pbmFuY2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hZGFwdGF0aW9uUmF0ZT0xLjBdIC0gVGhlIGx1bWluYW5jZSBhZGFwdGF0aW9uIHJhdGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsdW1pbmFuY2VCdWZmZXIsIHsgbWluTHVtaW5hbmNlID0gMC4wMSwgYWRhcHRhdGlvblJhdGUgPSAxIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiQWRhcHRpdmVMdW1pbmFuY2VQYXNzXCIpO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gbmV3IEFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwoKTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0UHJldmlvdXMgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxOCgxLCAxLCB7XG4gICAgICBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXI2LFxuICAgICAgbWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyNixcbiAgICAgIGRlcHRoQnVmZmVyOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0UHJldmlvdXMudGV4dHVyZS5uYW1lID0gXCJMdW1pbmFuY2UuUHJldmlvdXNcIjtcbiAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICAgIG1hdGVyaWFsLmx1bWluYW5jZUJ1ZmZlcjAgPSB0aGlzLnJlbmRlclRhcmdldFByZXZpb3VzLnRleHR1cmU7XG4gICAgbWF0ZXJpYWwubHVtaW5hbmNlQnVmZmVyMSA9IGx1bWluYW5jZUJ1ZmZlcjtcbiAgICBtYXRlcmlhbC5taW5MdW1pbmFuY2UgPSBtaW5MdW1pbmFuY2U7XG4gICAgbWF0ZXJpYWwuYWRhcHRhdGlvblJhdGUgPSBhZGFwdGF0aW9uUmF0ZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEFkYXB0ZWQgPSB0aGlzLnJlbmRlclRhcmdldFByZXZpb3VzLmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkLnRleHR1cmUubmFtZSA9IFwiTHVtaW5hbmNlLkFkYXB0ZWRcIjtcbiAgICB0aGlzLmNvcHlQYXNzID0gbmV3IENvcHlQYXNzKHRoaXMucmVuZGVyVGFyZ2V0UHJldmlvdXMsIGZhbHNlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFkYXB0aXZlIGx1bWluYW5jZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldEFkYXB0ZWQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWRhcHRpdmUgMXgxIGx1bWluYW5jZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSAxeDEgbWlwbWFwIGxldmVsLlxuICAgKlxuICAgKiBUaGlzIGxldmVsIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHNtYWxsZXN0IG1pcG1hcCBvZiB0aGUgbWFpbiBsdW1pbmFuY2UgdGV4dHVyZSB3aGljaCBjb250YWlucyB0aGUgZG93bnNhbXBsZWRcbiAgICogYXZlcmFnZSBzY2VuZSBsdW1pbmFuY2UuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBmdWxsc2NyZWVuTWF0ZXJpYWwubWlwTGV2ZWwxeDEgaW5zdGVhZC5cbiAgICovXG4gIHNldCBtaXBMZXZlbDF4MSh2YWx1ZSkge1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLm1pcExldmVsMXgxID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsdW1pbmFuY2UgYWRhcHRhdGlvbiByYXRlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZnVsbHNjcmVlbk1hdGVyaWFsLmFkYXB0YXRpb25SYXRlIGluc3RlYWQuXG4gICAqL1xuICBnZXQgYWRhcHRhdGlvblJhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmFkYXB0YXRpb25SYXRlO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZnVsbHNjcmVlbk1hdGVyaWFsLmFkYXB0YXRpb25SYXRlIGluc3RlYWQuXG4gICAqL1xuICBzZXQgYWRhcHRhdGlvblJhdGUodmFsdWUpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5hZGFwdGF0aW9uUmF0ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBzY2VuZSBub3JtYWxzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZWx0YVRpbWUgPSBkZWx0YVRpbWU7XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogdGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkKTtcbiAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgIHRoaXMuY29weVBhc3MucmVuZGVyKHJlbmRlcmVyLCB0aGlzLnJlbmRlclRhcmdldEFkYXB0ZWQpO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3RvbmUtbWFwcGluZy5mcmFnXG52YXIgdG9uZV9tYXBwaW5nX2RlZmF1bHQgPSBgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ+XG51bmlmb3JtIGZsb2F0IHdoaXRlUG9pbnQ7XG4jaWYgVE9ORV9NQVBQSU5HX01PREUgPT0gMiB8fCBUT05FX01BUFBJTkdfTU9ERSA9PSAzXG51bmlmb3JtIGZsb2F0IG1pZGRsZUdyZXk7XG4jaWYgVE9ORV9NQVBQSU5HX01PREUgPT0gM1xudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBsdW1pbmFuY2VCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBmbG9hdCBhdmVyYWdlTHVtaW5hbmNlO1xuI2VuZGlmXG52ZWMzIFJlaW5oYXJkMlRvbmVNYXBwaW5nKHZlYzMgY29sb3Ipe2NvbG9yKj10b25lTWFwcGluZ0V4cG9zdXJlO2Zsb2F0IGw9bHVtaW5hbmNlKGNvbG9yKTtcbiNpZiBUT05FX01BUFBJTkdfTU9ERSA9PSAzXG5mbG9hdCBsdW1Bdmc9dW5wYWNrUkdCQVRvRmxvYXQodGV4dHVyZTJEKGx1bWluYW5jZUJ1ZmZlcix2ZWMyKDAuNSkpKTtcbiNlbHNlXG5mbG9hdCBsdW1Bdmc9YXZlcmFnZUx1bWluYW5jZTtcbiNlbmRpZlxuZmxvYXQgbHVtU2NhbGVkPShsKm1pZGRsZUdyZXkpL21heChsdW1BdmcsMWUtNik7ZmxvYXQgbHVtQ29tcHJlc3NlZD1sdW1TY2FsZWQqKDEuMCtsdW1TY2FsZWQvKHdoaXRlUG9pbnQqd2hpdGVQb2ludCkpO2x1bUNvbXByZXNzZWQvPSgxLjArbHVtU2NhbGVkKTtyZXR1cm4gY2xhbXAobHVtQ29tcHJlc3NlZCpjb2xvciwwLjAsMS4wKTt9XG4jZWxpZiBUT05FX01BUFBJTkdfTU9ERSA9PSA0XG4jZGVmaW5lIEEgMC4xNVxuI2RlZmluZSBCIDAuNTBcbiNkZWZpbmUgQyAwLjEwXG4jZGVmaW5lIEQgMC4yMFxuI2RlZmluZSBFIDAuMDJcbiNkZWZpbmUgRiAwLjMwXG52ZWMzIFVuY2hhcnRlZDJIZWxwZXIoY29uc3QgaW4gdmVjMyB4KXtyZXR1cm4oKHgqKEEqeCtDKkIpK0QqRSkvKHgqKEEqeCtCKStEKkYpKS1FL0Y7fXZlYzMgVW5jaGFydGVkMlRvbmVNYXBwaW5nKHZlYzMgY29sb3Ipe2NvbG9yKj10b25lTWFwcGluZ0V4cG9zdXJlO3JldHVybiBjbGFtcChVbmNoYXJ0ZWQySGVscGVyKGNvbG9yKS9VbmNoYXJ0ZWQySGVscGVyKHZlYzMod2hpdGVQb2ludCkpLDAuMCwxLjApO31cbiNlbmRpZlxudm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe1xuI2lmIFRPTkVfTUFQUElOR19NT0RFID09IDIgfHwgVE9ORV9NQVBQSU5HX01PREUgPT0gM1xub3V0cHV0Q29sb3I9dmVjNChSZWluaGFyZDJUb25lTWFwcGluZyhpbnB1dENvbG9yLnJnYiksaW5wdXRDb2xvci5hKTtcbiNlbGlmIFRPTkVfTUFQUElOR19NT0RFID09IDRcbm91dHB1dENvbG9yPXZlYzQoVW5jaGFydGVkMlRvbmVNYXBwaW5nKGlucHV0Q29sb3IucmdiKSxpbnB1dENvbG9yLmEpO1xuI2Vsc2Vcbm91dHB1dENvbG9yPXZlYzQodG9uZU1hcHBpbmcoaW5wdXRDb2xvci5yZ2IpLGlucHV0Q29sb3IuYSk7XG4jZW5kaWZcbn1gO1xuXG4vLyBzcmMvZWZmZWN0cy9Ub25lTWFwcGluZ0VmZmVjdC5qc1xudmFyIFRvbmVNYXBwaW5nRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyB0b25lIG1hcHBpbmcgZWZmZWN0LlxuICAgKlxuICAgKiBUaGUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIG9ubHkgYWZmZWN0IHRoZSBSZWluaGFyZDIgb3BlcmF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hZGFwdGl2ZT1mYWxzZV0gLSBEZXByZWNhdGVkLiBVc2UgbW9kZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RvbmVNYXBwaW5nTW9kZX0gW29wdGlvbnMubW9kZT1Ub25lTWFwcGluZ01vZGUuQUdYXSAtIFRoZSB0b25lIG1hcHBpbmcgbW9kZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249MjU2XSAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSBsdW1pbmFuY2UgdGV4dHVyZS4gTXVzdCBiZSBhIHBvd2VyIG9mIHR3by5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEx1bWluYW5jZT00LjBdIC0gRGVwcmVjYXRlZC4gU2FtZSBhcyB3aGl0ZVBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2hpdGVQb2ludD00LjBdIC0gVGhlIHdoaXRlIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWlkZGxlR3JleT0wLjZdIC0gVGhlIG1pZGRsZSBncmV5IGZhY3Rvci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pbkx1bWluYW5jZT0wLjAxXSAtIFRoZSBtaW5pbXVtIGx1bWluYW5jZS4gUHJldmVudHMgdmVyeSBoaWdoIGV4cG9zdXJlIGluIGRhcmsgc2NlbmVzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXZlcmFnZUx1bWluYW5jZT0xLjBdIC0gVGhlIGF2ZXJhZ2UgbHVtaW5hbmNlLiBVc2VkIGZvciB0aGUgbm9uLWFkYXB0aXZlIFJlaW5oYXJkIG9wZXJhdG9yLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYWRhcHRhdGlvblJhdGU9MS4wXSAtIFRoZSBsdW1pbmFuY2UgYWRhcHRhdGlvbiByYXRlLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLlNSQyxcbiAgICBhZGFwdGl2ZSA9IGZhbHNlLFxuICAgIG1vZGUgPSBhZGFwdGl2ZSA/IFRvbmVNYXBwaW5nTW9kZS5SRUlOSEFSRDJfQURBUFRJVkUgOiBUb25lTWFwcGluZ01vZGUuQUdYLFxuICAgIHJlc29sdXRpb24gPSAyNTYsXG4gICAgbWF4THVtaW5hbmNlID0gNCxcbiAgICB3aGl0ZVBvaW50ID0gbWF4THVtaW5hbmNlLFxuICAgIG1pZGRsZUdyZXkgPSAwLjYsXG4gICAgbWluTHVtaW5hbmNlID0gMC4wMSxcbiAgICBhdmVyYWdlTHVtaW5hbmNlID0gMSxcbiAgICBhZGFwdGF0aW9uUmF0ZSA9IDFcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJUb25lTWFwcGluZ0VmZmVjdFwiLCB0b25lX21hcHBpbmdfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImx1bWluYW5jZUJ1ZmZlclwiLCBuZXcgVW5pZm9ybTQ2KG51bGwpXSxcbiAgICAgICAgW1wibWF4THVtaW5hbmNlXCIsIG5ldyBVbmlmb3JtNDYobWF4THVtaW5hbmNlKV0sXG4gICAgICAgIC8vIFVudXNlZFxuICAgICAgICBbXCJ3aGl0ZVBvaW50XCIsIG5ldyBVbmlmb3JtNDYod2hpdGVQb2ludCldLFxuICAgICAgICBbXCJtaWRkbGVHcmV5XCIsIG5ldyBVbmlmb3JtNDYobWlkZGxlR3JleSldLFxuICAgICAgICBbXCJhdmVyYWdlTHVtaW5hbmNlXCIsIG5ldyBVbmlmb3JtNDYoYXZlcmFnZUx1bWluYW5jZSldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0THVtaW5hbmNlID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTkoMSwgMSwge1xuICAgICAgbWluRmlsdGVyOiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsXG4gICAgICBkZXB0aEJ1ZmZlcjogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEx1bWluYW5jZS50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRMdW1pbmFuY2UudGV4dHVyZS5uYW1lID0gXCJMdW1pbmFuY2VcIjtcbiAgICB0aGlzLmx1bWluYW5jZVBhc3MgPSBuZXcgTHVtaW5hbmNlUGFzcyh7XG4gICAgICByZW5kZXJUYXJnZXQ6IHRoaXMucmVuZGVyVGFyZ2V0THVtaW5hbmNlXG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGl2ZUx1bWluYW5jZVBhc3MgPSBuZXcgQWRhcHRpdmVMdW1pbmFuY2VQYXNzKHRoaXMubHVtaW5hbmNlUGFzcy50ZXh0dXJlLCB7XG4gICAgICBtaW5MdW1pbmFuY2UsXG4gICAgICBhZGFwdGF0aW9uUmF0ZVxuICAgIH0pO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibHVtaW5hbmNlQnVmZmVyXCIpLnZhbHVlID0gdGhpcy5hZGFwdGl2ZUx1bWluYW5jZVBhc3MudGV4dHVyZTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0b25lIG1hcHBpbmcgbW9kZS5cbiAgICpcbiAgICogQHR5cGUge1RvbmVNYXBwaW5nTW9kZX1cbiAgICovXG4gIGdldCBtb2RlKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLmdldChcIlRPTkVfTUFQUElOR19NT0RFXCIpKTtcbiAgfVxuICBzZXQgbW9kZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJldmlzaW9uID0gUkVWSVNJT04zLnJlcGxhY2UoL1xcRCsvZywgXCJcIik7XG4gICAgY29uc3QgY2luZW9uVG9uZU1hcHBpbmcgPSByZXZpc2lvbiA+PSAxNjggPyBcIkNpbmVvblRvbmVNYXBwaW5nKHRleGVsKVwiIDogXCJPcHRpbWl6ZWRDaW5lb25Ub25lTWFwcGluZyh0ZXhlbClcIjtcbiAgICB0aGlzLmRlZmluZXMuY2xlYXIoKTtcbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiVE9ORV9NQVBQSU5HX01PREVcIiwgdmFsdWUudG9GaXhlZCgwKSk7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBUb25lTWFwcGluZ01vZGUuTElORUFSOlxuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwidG9uZU1hcHBpbmcodGV4ZWwpXCIsIFwiTGluZWFyVG9uZU1hcHBpbmcodGV4ZWwpXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9uZU1hcHBpbmdNb2RlLlJFSU5IQVJEOlxuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwidG9uZU1hcHBpbmcodGV4ZWwpXCIsIFwiUmVpbmhhcmRUb25lTWFwcGluZyh0ZXhlbClcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb25lTWFwcGluZ01vZGUuQ0lORU9OOlxuICAgICAgY2FzZSBUb25lTWFwcGluZ01vZGUuT1BUSU1JWkVEX0NJTkVPTjpcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcInRvbmVNYXBwaW5nKHRleGVsKVwiLCBjaW5lb25Ub25lTWFwcGluZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb25lTWFwcGluZ01vZGUuQUNFU19GSUxNSUM6XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJ0b25lTWFwcGluZyh0ZXhlbClcIiwgXCJBQ0VTRmlsbWljVG9uZU1hcHBpbmcodGV4ZWwpXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9uZU1hcHBpbmdNb2RlLkFHWDpcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcInRvbmVNYXBwaW5nKHRleGVsKVwiLCBcIkFnWFRvbmVNYXBwaW5nKHRleGVsKVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRvbmVNYXBwaW5nTW9kZS5ORVVUUkFMOlxuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwidG9uZU1hcHBpbmcodGV4ZWwpXCIsIFwiTmV1dHJhbFRvbmVNYXBwaW5nKHRleGVsKVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwidG9uZU1hcHBpbmcodGV4ZWwpXCIsIFwidGV4ZWxcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmFkYXB0aXZlTHVtaW5hbmNlUGFzcy5lbmFibGVkID0gdmFsdWUgPT09IFRvbmVNYXBwaW5nTW9kZS5SRUlOSEFSRDJfQURBUFRJVkU7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdG9uZSBtYXBwaW5nIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtb2RlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RvbmVNYXBwaW5nTW9kZX0gVGhlIHRvbmUgbWFwcGluZyBtb2RlLlxuICAgKi9cbiAgZ2V0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0b25lIG1hcHBpbmcgbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1vZGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUb25lTWFwcGluZ01vZGV9IHZhbHVlIC0gVGhlIHRvbmUgbWFwcGluZyBtb2RlLlxuICAgKi9cbiAgc2V0TW9kZSh2YWx1ZSkge1xuICAgIHRoaXMubW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2hpdGUgcG9pbnQuIERlZmF1bHQgaXMgYDQuMGAuXG4gICAqXG4gICAqIE9ubHkgYXBwbGllcyB0byBSZWluaGFyZDIgKE1vZGlmaWVkICYgQWRhcHRpdmUpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdoaXRlUG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwid2hpdGVQb2ludFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgd2hpdGVQb2ludCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwid2hpdGVQb2ludFwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWlkZGxlIGdyZXkgZmFjdG9yLiBEZWZhdWx0IGlzIGAwLjZgLlxuICAgKlxuICAgKiBPbmx5IGFwcGxpZXMgdG8gUmVpbmhhcmQyIChNb2RpZmllZCAmIEFkYXB0aXZlKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtaWRkbGVHcmV5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIm1pZGRsZUdyZXlcIikudmFsdWU7XG4gIH1cbiAgc2V0IG1pZGRsZUdyZXkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIm1pZGRsZUdyZXlcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGF2ZXJhZ2UgbHVtaW5hbmNlLlxuICAgKlxuICAgKiBPbmx5IGFwcGxpZXMgdG8gUmVpbmhhcmQyIChNb2RpZmllZCkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYXZlcmFnZUx1bWluYW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJhdmVyYWdlTHVtaW5hbmNlXCIpLnZhbHVlO1xuICB9XG4gIHNldCBhdmVyYWdlTHVtaW5hbmNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJhdmVyYWdlTHVtaW5hbmNlXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhZGFwdGl2ZSBsdW1pbmFuY2UgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IGFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWRhcHRpdmUgbHVtaW5hbmNlIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsfSBUaGUgbWF0ZXJpYWwuXG4gICAqL1xuICBnZXRBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZXNvbHV0aW9uIG9mIHRoZSBsdW1pbmFuY2UgdGV4dHVyZS4gTXVzdCBiZSBhIHBvd2VyIG9mIHR3by5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmx1bWluYW5jZVBhc3MucmVzb2x1dGlvbi53aWR0aDtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IGV4cG9uZW50ID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKE1hdGgubG9nMih2YWx1ZSkpKTtcbiAgICBjb25zdCBzaXplID0gTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuICAgIHRoaXMubHVtaW5hbmNlUGFzcy5yZXNvbHV0aW9uLnNldFByZWZlcnJlZFNpemUoc2l6ZSwgc2l6ZSk7XG4gICAgdGhpcy5hZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsLm1pcExldmVsMXgxID0gZXhwb25lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24gb2YgdGhlIGx1bWluYW5jZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBsdW1pbmFuY2UgdGV4dHVyZS4gTXVzdCBiZSBhIHBvd2VyIG9mIHR3by5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgcGFzcyB1c2VzIGFkYXB0aXZlIGx1bWluYW5jZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSBtb2RlIGluc3RlYWQuXG4gICAqL1xuICBnZXQgYWRhcHRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gVG9uZU1hcHBpbmdNb2RlLlJFSU5IQVJEMl9BREFQVElWRTtcbiAgfVxuICBzZXQgYWRhcHRpdmUodmFsdWUpIHtcbiAgICB0aGlzLm1vZGUgPSB2YWx1ZSA/IFRvbmVNYXBwaW5nTW9kZS5SRUlOSEFSRDJfQURBUFRJVkUgOiBUb25lTWFwcGluZ01vZGUuUkVJTkhBUkQyO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbHVtaW5hbmNlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwuYWRhcHRhdGlvblJhdGUgaW5zdGVhZC5cbiAgICovXG4gIGdldCBhZGFwdGF0aW9uUmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsLmFkYXB0YXRpb25SYXRlO1xuICB9XG4gIHNldCBhZGFwdGF0aW9uUmF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbC5hZGFwdGF0aW9uUmF0ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGRpc3RpbmN0aW9uKCkge1xuICAgIGNvbnNvbGUud2Fybih0aGlzLm5hbWUsIFwiZGlzdGluY3Rpb24gd2FzIHJlbW92ZWQuXCIpO1xuICAgIHJldHVybiAxO1xuICB9XG4gIHNldCBkaXN0aW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnNvbGUud2Fybih0aGlzLm5hbWUsIFwiZGlzdGluY3Rpb24gd2FzIHJlbW92ZWQuXCIpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBpZiAodGhpcy5hZGFwdGl2ZUx1bWluYW5jZVBhc3MuZW5hYmxlZCkge1xuICAgICAgdGhpcy5sdW1pbmFuY2VQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIpO1xuICAgICAgdGhpcy5hZGFwdGl2ZUx1bWluYW5jZVBhc3MucmVuZGVyKHJlbmRlcmVyLCBudWxsLCBudWxsLCBkZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgdGhpcy5hZGFwdGl2ZUx1bWluYW5jZVBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1ZpZ25ldHRlRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm00NyB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3ZpZ25ldHRlLmZyYWdcbnZhciB2aWduZXR0ZV9kZWZhdWx0ID0gYHVuaWZvcm0gZmxvYXQgb2Zmc2V0O3VuaWZvcm0gZmxvYXQgZGFya25lc3M7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe2NvbnN0IHZlYzIgY2VudGVyPXZlYzIoMC41KTt2ZWMzIGNvbG9yPWlucHV0Q29sb3IucmdiO1xuI2lmIFZJR05FVFRFX1RFQ0hOSVFVRSA9PSAwXG5mbG9hdCBkPWRpc3RhbmNlKHV2LGNlbnRlcik7Y29sb3IqPXNtb290aHN0ZXAoMC44LG9mZnNldCowLjc5OSxkKihkYXJrbmVzcytvZmZzZXQpKTtcbiNlbHNlXG52ZWMyIGNvb3JkPSh1di1jZW50ZXIpKnZlYzIob2Zmc2V0KTtjb2xvcj1taXgoY29sb3IsdmVjMygxLjAtZGFya25lc3MpLGRvdChjb29yZCxjb29yZCkpO1xuI2VuZGlmXG5vdXRwdXRDb2xvcj12ZWM0KGNvbG9yLGlucHV0Q29sb3IuYSk7fWA7XG5cbi8vIHNyYy9lZmZlY3RzL1ZpZ25ldHRlRWZmZWN0LmpzXG52YXIgVmlnbmV0dGVFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFZpZ25ldHRlIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb25dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge1ZpZ25ldHRlVGVjaG5pcXVlfSBbb3B0aW9ucy50ZWNobmlxdWU9VmlnbmV0dGVUZWNobmlxdWUuREVGQVVMVF0gLSBUaGUgVmlnbmV0dGUgdGVjaG5pcXVlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVza2lsPWZhbHNlXSAtIERlcHJlY2F0ZWQuIFVzZSB0ZWNobmlxdWUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldD0wLjVdIC0gVGhlIFZpZ25ldHRlIG9mZnNldC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRhcmtuZXNzPTAuNV0gLSBUaGUgVmlnbmV0dGUgZGFya25lc3MuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmxlbmRGdW5jdGlvbixcbiAgICBlc2tpbCA9IGZhbHNlLFxuICAgIHRlY2huaXF1ZSA9IGVza2lsID8gVmlnbmV0dGVUZWNobmlxdWUuRVNLSUwgOiBWaWduZXR0ZVRlY2huaXF1ZS5ERUZBVUxULFxuICAgIG9mZnNldCA9IDAuNSxcbiAgICBkYXJrbmVzcyA9IDAuNVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIlZpZ25ldHRlRWZmZWN0XCIsIHZpZ25ldHRlX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBkZWZpbmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIlZJR05FVFRFX1RFQ0hOSVFVRVwiLCB0ZWNobmlxdWUudG9GaXhlZCgwKV1cbiAgICAgIF0pLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wib2Zmc2V0XCIsIG5ldyBVbmlmb3JtNDcob2Zmc2V0KV0sXG4gICAgICAgIFtcImRhcmtuZXNzXCIsIG5ldyBVbmlmb3JtNDcoZGFya25lc3MpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIFZpZ25ldHRlIHRlY2huaXF1ZS5cbiAgICpcbiAgICogQHR5cGUge1ZpZ25ldHRlVGVjaG5pcXVlfVxuICAgKi9cbiAgZ2V0IHRlY2huaXF1ZSgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5nZXQoXCJWSUdORVRURV9URUNITklRVUVcIikpO1xuICB9XG4gIHNldCB0ZWNobmlxdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy50ZWNobmlxdWUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiVklHTkVUVEVfVEVDSE5JUVVFXCIsIHZhbHVlLnRvRml4ZWQoMCkpO1xuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBFc2tpbCdzIFZpZ25ldHRlIHRlY2huaXF1ZSBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRlY2huaXF1ZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGVza2lsKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2huaXF1ZSA9PT0gVmlnbmV0dGVUZWNobmlxdWUuRVNLSUw7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIEVza2lsJ3MgVmlnbmV0dGUgdGVjaG5pcXVlIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGVjaG5pcXVlIGluc3RlYWQuXG4gICAqL1xuICBzZXQgZXNraWwodmFsdWUpIHtcbiAgICB0aGlzLnRlY2huaXF1ZSA9IHZhbHVlID8gVmlnbmV0dGVUZWNobmlxdWUuRVNLSUwgOiBWaWduZXR0ZVRlY2huaXF1ZS5ERUZBVUxUO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBWaWduZXR0ZSB0ZWNobmlxdWUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZWNobmlxdWUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmlnbmV0dGVUZWNobmlxdWV9IFRoZSB0ZWNobmlxdWUuXG4gICAqL1xuICBnZXRUZWNobmlxdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaG5pcXVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBWaWduZXR0ZSB0ZWNobmlxdWUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZWNobmlxdWUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtWaWduZXR0ZVRlY2huaXF1ZX0gdmFsdWUgLSBUaGUgdGVjaG5pcXVlLlxuICAgKi9cbiAgc2V0VGVjaG5pcXVlKHZhbHVlKSB7XG4gICAgdGhpcy50ZWNobmlxdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIFZpZ25ldHRlIG9mZnNldC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwib2Zmc2V0XCIpLnZhbHVlO1xuICB9XG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIm9mZnNldFwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBWaWduZXR0ZSBvZmZzZXQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvZmZzZXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgb2Zmc2V0LlxuICAgKi9cbiAgZ2V0T2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgVmlnbmV0dGUgb2Zmc2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb2Zmc2V0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBvZmZzZXQuXG4gICAqL1xuICBzZXRPZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLm9mZnNldCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgVmlnbmV0dGUgZGFya25lc3MuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZGFya25lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiZGFya25lc3NcIikudmFsdWU7XG4gIH1cbiAgc2V0IGRhcmtuZXNzKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJkYXJrbmVzc1wiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBWaWduZXR0ZSBkYXJrbmVzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRhcmtuZXNzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGRhcmtuZXNzLlxuICAgKi9cbiAgZ2V0RGFya25lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGFya25lc3M7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIFZpZ25ldHRlIGRhcmtuZXNzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGFya25lc3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGRhcmtuZXNzLlxuICAgKi9cbiAgc2V0RGFya25lc3ModmFsdWUpIHtcbiAgICB0aGlzLmRhcmtuZXNzID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9sb2FkZXJzL0xVVDNkbExvYWRlci5qc1xuaW1wb3J0IHsgRmlsZUxvYWRlciwgTG9hZGVyLCBMb2FkaW5nTWFuYWdlciBhcyBMb2FkaW5nTWFuYWdlcjIgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBMVVQzZGxMb2FkZXIgPSBjbGFzcyBleHRlbmRzIExvYWRlciB7XG4gIC8qKlxuICAgKiBMb2FkcyBhIExVVC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIDNkbC1maWxlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Mb2FkXSAtIEEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgbG9hZGVkIGxvb2t1cCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Qcm9ncmVzc10gLSBBIHByb2dyZXNzIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIFhNTEh0dHBSZXF1ZXN0IGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gLSBBbiBlcnJvciBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBVUkwgb2YgdGhlIGZpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxMb29rdXBUZXh0dXJlPn0gQSBwcm9taXNlIHRoYXQgcmV0dXJucyB0aGUgbG9va3VwIHRleHR1cmUuXG4gICAqL1xuICBsb2FkKHVybCwgb25Mb2FkID0gKCkgPT4ge1xuICB9LCBvblByb2dyZXNzID0gKCkgPT4ge1xuICB9LCBvbkVycm9yID0gbnVsbCkge1xuICAgIGNvbnN0IGV4dGVybmFsTWFuYWdlciA9IHRoaXMubWFuYWdlcjtcbiAgICBjb25zdCBpbnRlcm5hbE1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIyKCk7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoaW50ZXJuYWxNYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJ0ZXh0XCIpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpbnRlcm5hbE1hbmFnZXIub25FcnJvciA9ICh1cmwyKSA9PiB7XG4gICAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtRXJyb3IodXJsMik7XG4gICAgICAgIGlmIChvbkVycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgb25FcnJvcihgRmFpbGVkIHRvIGxvYWQgJHt1cmwyfWApO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoYEZhaWxlZCB0byBsb2FkICR7dXJsMn1gKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtU3RhcnQodXJsKTtcbiAgICAgIGxvYWRlci5sb2FkKHVybCwgKGRhdGEpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBhcnNlKGRhdGEpO1xuICAgICAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICAgICAgb25Mb2FkKHJlc3VsdCk7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICBpbnRlcm5hbE1hbmFnZXIub25FcnJvcih1cmwpO1xuICAgICAgICB9XG4gICAgICB9LCBvblByb2dyZXNzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgLSBUaGUgTFVUIGRhdGEuXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoZSBsb29rdXAgdGV4dHVyZS5cbiAgICogQHRocm93cyB7RXJyb3J9IEZhaWxzIGlmIHRoZSBkYXRhIGlzIGludmFsaWQuXG4gICAqL1xuICBwYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHJlZ0V4cEdyaWRJbmZvID0gL15bXFxkIF0rJC9tO1xuICAgIGNvbnN0IHJlZ0V4cERhdGFQb2ludHMgPSAvXihbXFxkLmUrLV0rKSArKFtcXGQuZSstXSspICsoW1xcZC5lKy1dKykgKiQvZ207XG4gICAgbGV0IHJlc3VsdCA9IHJlZ0V4cEdyaWRJbmZvLmV4ZWMoaW5wdXQpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZ3JpZCBpbmZvcm1hdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3QgZ3JpZExpbmVzID0gcmVzdWx0WzBdLnRyaW0oKS5zcGxpdCgvXFxzKy9nKS5tYXAoKG4pID0+IE51bWJlcihuKSk7XG4gICAgY29uc3QgZ3JpZFN0ZXAgPSBncmlkTGluZXNbMV0gLSBncmlkTGluZXNbMF07XG4gICAgY29uc3Qgc2l6ZSA9IGdyaWRMaW5lcy5sZW5ndGg7XG4gICAgY29uc3Qgc2l6ZVNxID0gc2l6ZSAqKiAyO1xuICAgIGZvciAobGV0IGkgPSAxLCBsID0gZ3JpZExpbmVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgaWYgKGdyaWRTdGVwICE9PSBncmlkTGluZXNbaV0gLSBncmlkTGluZXNbaSAtIDFdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29uc2lzdGVudCBncmlkIHNpemVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiogMyAqIDQpO1xuICAgIGxldCBtYXhWYWx1ZSA9IDA7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZ0V4cERhdGFQb2ludHMuZXhlYyhpbnB1dCkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCByID0gTnVtYmVyKHJlc3VsdFsxXSk7XG4gICAgICBjb25zdCBnID0gTnVtYmVyKHJlc3VsdFsyXSk7XG4gICAgICBjb25zdCBiID0gTnVtYmVyKHJlc3VsdFszXSk7XG4gICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KG1heFZhbHVlLCByLCBnLCBiKTtcbiAgICAgIGNvbnN0IGJMYXllciA9IGluZGV4ICUgc2l6ZTtcbiAgICAgIGNvbnN0IGdMYXllciA9IE1hdGguZmxvb3IoaW5kZXggLyBzaXplKSAlIHNpemU7XG4gICAgICBjb25zdCByTGF5ZXIgPSBNYXRoLmZsb29yKGluZGV4IC8gc2l6ZVNxKSAlIHNpemU7XG4gICAgICBjb25zdCBkNCA9IChiTGF5ZXIgKiBzaXplU3EgKyBnTGF5ZXIgKiBzaXplICsgckxheWVyKSAqIDQ7XG4gICAgICBkYXRhW2Q0ICsgMF0gPSByO1xuICAgICAgZGF0YVtkNCArIDFdID0gZztcbiAgICAgIGRhdGFbZDQgKyAyXSA9IGI7XG4gICAgICBkYXRhW2Q0ICsgM10gPSAxO1xuICAgICAgKytpbmRleDtcbiAgICB9XG4gICAgY29uc3QgYml0cyA9IE1hdGguY2VpbChNYXRoLmxvZzIobWF4VmFsdWUpKTtcbiAgICBjb25zdCBtYXhCaXRWYWx1ZSA9IE1hdGgucG93KDIsIGJpdHMpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgIGRhdGFbaSArIDBdIC89IG1heEJpdFZhbHVlO1xuICAgICAgZGF0YVtpICsgMV0gLz0gbWF4Qml0VmFsdWU7XG4gICAgICBkYXRhW2kgKyAyXSAvPSBtYXhCaXRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb29rdXBUZXh0dXJlKGRhdGEsIHNpemUpO1xuICB9XG59O1xuXG4vLyBzcmMvbG9hZGVycy9MVVRDdWJlTG9hZGVyLmpzXG5pbXBvcnQgeyBGaWxlTG9hZGVyIGFzIEZpbGVMb2FkZXIyLCBMb2FkZXIgYXMgTG9hZGVyMiwgTG9hZGluZ01hbmFnZXIgYXMgTG9hZGluZ01hbmFnZXIzLCBWZWN0b3IzIGFzIFZlY3RvcjM3IH0gZnJvbSBcInRocmVlXCI7XG52YXIgTFVUQ3ViZUxvYWRlciA9IGNsYXNzIGV4dGVuZHMgTG9hZGVyMiB7XG4gIC8qKlxuICAgKiBMb2FkcyBhIExVVC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIENVQkUtZmlsZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uTG9hZF0gLSBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGxvYWRlZCBsb29rdXAgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIC0gQSBwcm9ncmVzcyBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBYTUxIdHRwUmVxdWVzdCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIC0gQW4gZXJyb3IgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgVVJMIG9mIHRoZSBmaWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TG9va3VwVGV4dHVyZT59IEEgcHJvbWlzZSB0aGF0IHJldHVybnMgdGhlIGxvb2t1cCB0ZXh0dXJlLlxuICAgKi9cbiAgbG9hZCh1cmwsIG9uTG9hZCA9ICgpID0+IHtcbiAgfSwgb25Qcm9ncmVzcyA9ICgpID0+IHtcbiAgfSwgb25FcnJvciA9IG51bGwpIHtcbiAgICBjb25zdCBleHRlcm5hbE1hbmFnZXIgPSB0aGlzLm1hbmFnZXI7XG4gICAgY29uc3QgaW50ZXJuYWxNYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyMygpO1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyMihpbnRlcm5hbE1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShcInRleHRcIik7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGludGVybmFsTWFuYWdlci5vbkVycm9yID0gKHVybDIpID0+IHtcbiAgICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1FcnJvcih1cmwyKTtcbiAgICAgICAgaWYgKG9uRXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICBvbkVycm9yKGBGYWlsZWQgdG8gbG9hZCAke3VybDJ9YCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGxvYWQgJHt1cmwyfWApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuICAgICAgbG9hZGVyLmxvYWQodXJsLCAoZGF0YSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICAgICAgICBvbkxvYWQocmVzdWx0KTtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgIGludGVybmFsTWFuYWdlci5vbkVycm9yKHVybCk7XG4gICAgICAgIH1cbiAgICAgIH0sIG9uUHJvZ3Jlc3MpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCAtIFRoZSBMVVQgZGF0YS5cbiAgICogQHJldHVybiB7TG9va3VwVGV4dHVyZX0gVGhlIGxvb2t1cCB0ZXh0dXJlLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gRmFpbHMgaWYgdGhlIGRhdGEgaXMgaW52YWxpZC5cbiAgICovXG4gIHBhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcmVnRXhwVGl0bGUgPSAvVElUTEUgK1wiKFteXCJdKilcIi87XG4gICAgY29uc3QgcmVnRXhwU2l6ZSA9IC9MVVRfM0RfU0laRSArKFxcZCspLztcbiAgICBjb25zdCByZWdFeHBEb21haW5NaW4gPSAvRE9NQUlOX01JTiArKFtcXGQuXSspICsoW1xcZC5dKykgKyhbXFxkLl0rKS87XG4gICAgY29uc3QgcmVnRXhwRG9tYWluTWF4ID0gL0RPTUFJTl9NQVggKyhbXFxkLl0rKSArKFtcXGQuXSspICsoW1xcZC5dKykvO1xuICAgIGNvbnN0IHJlZ0V4cERhdGFQb2ludHMgPSAvXihbXFxkLmUrLV0rKSArKFtcXGQuZSstXSspICsoW1xcZC5lKy1dKykgKiQvZ207XG4gICAgbGV0IHJlc3VsdCA9IHJlZ0V4cFRpdGxlLmV4ZWMoaW5wdXQpO1xuICAgIGNvbnN0IHRpdGxlID0gcmVzdWx0ICE9PSBudWxsID8gcmVzdWx0WzFdIDogbnVsbDtcbiAgICByZXN1bHQgPSByZWdFeHBTaXplLmV4ZWMoaW5wdXQpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgTFVUXzNEX1NJWkUgaW5mb3JtYXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSBOdW1iZXIocmVzdWx0WzFdKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShzaXplICoqIDMgKiA0KTtcbiAgICBjb25zdCBkb21haW5NaW4gPSBuZXcgVmVjdG9yMzcoMCwgMCwgMCk7XG4gICAgY29uc3QgZG9tYWluTWF4ID0gbmV3IFZlY3RvcjM3KDEsIDEsIDEpO1xuICAgIHJlc3VsdCA9IHJlZ0V4cERvbWFpbk1pbi5leGVjKGlucHV0KTtcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICBkb21haW5NaW4uc2V0KE51bWJlcihyZXN1bHRbMV0pLCBOdW1iZXIocmVzdWx0WzJdKSwgTnVtYmVyKHJlc3VsdFszXSkpO1xuICAgIH1cbiAgICByZXN1bHQgPSByZWdFeHBEb21haW5NYXguZXhlYyhpbnB1dCk7XG4gICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgZG9tYWluTWF4LnNldChOdW1iZXIocmVzdWx0WzFdKSwgTnVtYmVyKHJlc3VsdFsyXSksIE51bWJlcihyZXN1bHRbM10pKTtcbiAgICB9XG4gICAgaWYgKGRvbWFpbk1pbi54ID4gZG9tYWluTWF4LnggfHwgZG9tYWluTWluLnkgPiBkb21haW5NYXgueSB8fCBkb21haW5NaW4ueiA+IGRvbWFpbk1heC56KSB7XG4gICAgICBkb21haW5NaW4uc2V0KDAsIDAsIDApO1xuICAgICAgZG9tYWluTWF4LnNldCgxLCAxLCAxKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgZG9tYWluXCIpO1xuICAgIH1cbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKChyZXN1bHQgPSByZWdFeHBEYXRhUG9pbnRzLmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgZGF0YVtpKytdID0gTnVtYmVyKHJlc3VsdFsxXSk7XG4gICAgICBkYXRhW2krK10gPSBOdW1iZXIocmVzdWx0WzJdKTtcbiAgICAgIGRhdGFbaSsrXSA9IE51bWJlcihyZXN1bHRbM10pO1xuICAgICAgZGF0YVtpKytdID0gMTtcbiAgICB9XG4gICAgY29uc3QgbHV0ID0gbmV3IExvb2t1cFRleHR1cmUoZGF0YSwgc2l6ZSk7XG4gICAgbHV0LmRvbWFpbk1pbi5jb3B5KGRvbWFpbk1pbik7XG4gICAgbHV0LmRvbWFpbk1heC5jb3B5KGRvbWFpbk1heCk7XG4gICAgaWYgKHRpdGxlICE9PSBudWxsKSB7XG4gICAgICBsdXQubmFtZSA9IHRpdGxlO1xuICAgIH1cbiAgICByZXR1cm4gbHV0O1xuICB9XG59O1xuXG4vLyBzcmMvbG9hZGVycy9TTUFBSW1hZ2VMb2FkZXIuanNcbmltcG9ydCB7IExvYWRlciBhcyBMb2FkZXIzLCBMb2FkaW5nTWFuYWdlciBhcyBMb2FkaW5nTWFuYWdlcjQgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBTTUFBSW1hZ2VMb2FkZXIgPSBjbGFzcyBleHRlbmRzIExvYWRlcjMge1xuICAvKipcbiAgICogTG9hZHMgdGhlIFNNQUEgZGF0YSBpbWFnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkxvYWRdIC0gQSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBzZWFyY2ggaW1hZ2UgYW5kIGFyZWEgaW1hZ2UgYXMgYSBwYWlyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gLSBBbiBlcnJvciBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBVUkwgb2YgdGhlIGltYWdlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8SW1hZ2VbXT59IEEgcHJvbWlzZSB0aGF0IHJldHVybnMgdGhlIHNlYXJjaCBpbWFnZSBhbmQgYXJlYSBpbWFnZSBhcyBhIHBhaXIuXG4gICAqL1xuICBsb2FkKG9uTG9hZCA9ICgpID0+IHtcbiAgfSwgb25FcnJvciA9IG51bGwpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgb25Mb2FkID0gYXJndW1lbnRzWzFdO1xuICAgICAgb25FcnJvciA9IGFyZ3VtZW50c1szXTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgfHwgdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvbkxvYWQgPSBhcmd1bWVudHNbMV07XG4gICAgICBvbkVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXh0ZXJuYWxNYW5hZ2VyID0gdGhpcy5tYW5hZ2VyO1xuICAgIGNvbnN0IGludGVybmFsTWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcjQoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgc2VhcmNoSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGNvbnN0IGFyZWFJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW50ZXJuYWxNYW5hZ2VyLm9uRXJyb3IgPSAodXJsKSA9PiB7XG4gICAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgICAgaWYgKG9uRXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICBvbkVycm9yKGBGYWlsZWQgdG8gbG9hZCAke3VybH1gKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KGBGYWlsZWQgdG8gbG9hZCAke3VybH1gKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGludGVybmFsTWFuYWdlci5vbkxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtzZWFyY2hJbWFnZSwgYXJlYUltYWdlXTtcbiAgICAgICAgb25Mb2FkKHJlc3VsdCk7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH07XG4gICAgICBzZWFyY2hJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGUpID0+IHtcbiAgICAgICAgaW50ZXJuYWxNYW5hZ2VyLml0ZW1FcnJvcihcInNtYWEtc2VhcmNoXCIpO1xuICAgICAgfSk7XG4gICAgICBhcmVhSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlKSA9PiB7XG4gICAgICAgIGludGVybmFsTWFuYWdlci5pdGVtRXJyb3IoXCJzbWFhLWFyZWFcIik7XG4gICAgICB9KTtcbiAgICAgIHNlYXJjaEltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1FbmQoXCJzbWFhLXNlYXJjaFwiKTtcbiAgICAgICAgaW50ZXJuYWxNYW5hZ2VyLml0ZW1FbmQoXCJzbWFhLXNlYXJjaFwiKTtcbiAgICAgIH0pO1xuICAgICAgYXJlYUltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1FbmQoXCJzbWFhLWFyZWFcIik7XG4gICAgICAgIGludGVybmFsTWFuYWdlci5pdGVtRW5kKFwic21hYS1hcmVhXCIpO1xuICAgICAgfSk7XG4gICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbVN0YXJ0KFwic21hYS1zZWFyY2hcIik7XG4gICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbVN0YXJ0KFwic21hYS1hcmVhXCIpO1xuICAgICAgaW50ZXJuYWxNYW5hZ2VyLml0ZW1TdGFydChcInNtYWEtc2VhcmNoXCIpO1xuICAgICAgaW50ZXJuYWxNYW5hZ2VyLml0ZW1TdGFydChcInNtYWEtYXJlYVwiKTtcbiAgICAgIHNlYXJjaEltYWdlLnNyYyA9IHNlYXJjaEltYWdlRGF0YVVSTF9kZWZhdWx0O1xuICAgICAgYXJlYUltYWdlLnNyYyA9IGFyZWFJbWFnZURhdGFVUkxfZGVmYXVsdDtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9Cb3hCbHVyTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzE4LCBQZXJzcGVjdGl2ZUNhbWVyYSBhcyBQZXJzcGVjdGl2ZUNhbWVyYTUsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMTksIFVuaWZvcm0gYXMgVW5pZm9ybTQ4LCBWZWN0b3IyIGFzIFZlY3RvcjIyNSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uYm94LmZyYWdcbnZhciBjb252b2x1dGlvbl9ib3hfZGVmYXVsdCA9IGAjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbmRpZlxuI2lmZGVmIEJJTEFURVJBTFxuI2luY2x1ZGUgPHBhY2tpbmc+XG51bmlmb3JtIHZlYzIgY2FtZXJhTmVhckZhcjtcbiNpZmRlZiBOT1JNQUxfREVQVEhcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgbm9ybWFsRGVwdGhCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcbiNlbmRpZlxuZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe3JldHVybiB0ZXh0dXJlMkQobm9ybWFsRGVwdGhCdWZmZXIsdXYpLmE7fVxuI2Vsc2VcbiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZWxpZiBkZWZpbmVkKEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIKVxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbmRpZlxuZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe1xuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxucmV0dXJuIHVucGFja1JHQkFUb0RlcHRoKHRleHR1cmUyRChkZXB0aEJ1ZmZlcix1dikpO1xuI2Vsc2VcbnJldHVybiB0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XG4jZW5kaWZcbn1cbiNlbmRpZlxuZmxvYXQgZ2V0Vmlld1ooY29uc3QgaW4gZmxvYXQgZGVwdGgpe1xuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxucmV0dXJuIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xuI2Vsc2VcbnJldHVybiBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7XG4jZW5kaWZcbn1cbiNpZmRlZiBQRVJTUEVDVElWRV9DQU1FUkFcbiNkZWZpbmUgbGluZWFyRGVwdGgodikgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKGdldFZpZXdaKHJlYWREZXB0aCh2KSksIGNhbWVyYU5lYXJGYXIueCwgY2FtZXJhTmVhckZhci55KVxuI2Vsc2VcbiNkZWZpbmUgbGluZWFyRGVwdGgodikgcmVhZERlcHRoKHYpXG4jZW5kaWZcbiNlbmRpZlxuI2RlZmluZSBnZXRUZXhlbCh2KSB0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsIHYpXG4jaWYgS0VSTkVMX1NJWkUgPT0gM1xudmFyeWluZyB2ZWMyIHZVdjAwLHZVdjAxLHZVdjAyO3ZhcnlpbmcgdmVjMiB2VXYwMyx2VXYwNCx2VXYwNTt2YXJ5aW5nIHZlYzIgdlV2MDYsdlV2MDcsdlV2MDg7XG4jZWxpZiBLRVJORUxfU0laRSA9PSA1ICYmIE1BWF9WQVJZSU5HX1ZFQ1RPUlMgPj0gMTNcbnZhcnlpbmcgdmVjMiB2VXYwMCx2VXYwMSx2VXYwMix2VXYwMyx2VXYwNDt2YXJ5aW5nIHZlYzIgdlV2MDUsdlV2MDYsdlV2MDcsdlV2MDgsdlV2MDk7dmFyeWluZyB2ZWMyIHZVdjEwLHZVdjExLHZVdjEyLHZVdjEzLHZVdjE0O3ZhcnlpbmcgdmVjMiB2VXYxNSx2VXYxNix2VXYxNyx2VXYxOCx2VXYxOTt2YXJ5aW5nIHZlYzIgdlV2MjAsdlV2MjEsdlV2MjIsdlV2MjMsdlV2MjQ7XG4jZWxzZVxudW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt1bmlmb3JtIGZsb2F0IHNjYWxlO3ZhcnlpbmcgdmVjMiB2VXY7XG4jZW5kaWZcbnZvaWQgbWFpbigpe1xuI2lmIEtFUk5FTF9TSVpFID09IDNcbnZlYzQgY1tdPXZlYzRbS0VSTkVMX1NJWkVfU1FdKGdldFRleGVsKHZVdjAwKSxnZXRUZXhlbCh2VXYwMSksZ2V0VGV4ZWwodlV2MDIpLGdldFRleGVsKHZVdjAzKSxnZXRUZXhlbCh2VXYwNCksZ2V0VGV4ZWwodlV2MDUpLGdldFRleGVsKHZVdjA2KSxnZXRUZXhlbCh2VXYwNyksZ2V0VGV4ZWwodlV2MDgpKTtcbiNpZmRlZiBCSUxBVEVSQUxcbmZsb2F0IHpbXT1mbG9hdFtLRVJORUxfU0laRV9TUV0obGluZWFyRGVwdGgodlV2MDApLGxpbmVhckRlcHRoKHZVdjAxKSxsaW5lYXJEZXB0aCh2VXYwMiksbGluZWFyRGVwdGgodlV2MDMpLGxpbmVhckRlcHRoKHZVdjA0KSxsaW5lYXJEZXB0aCh2VXYwNSksbGluZWFyRGVwdGgodlV2MDYpLGxpbmVhckRlcHRoKHZVdjA3KSxsaW5lYXJEZXB0aCh2VXYwOCkpO1xuI2VuZGlmXG4jZWxpZiBLRVJORUxfU0laRSA9PSA1ICYmIE1BWF9WQVJZSU5HX1ZFQ1RPUlMgPj0gMTNcbnZlYzQgY1tdPXZlYzRbS0VSTkVMX1NJWkVfU1FdKGdldFRleGVsKHZVdjAwKSxnZXRUZXhlbCh2VXYwMSksZ2V0VGV4ZWwodlV2MDIpLGdldFRleGVsKHZVdjAzKSxnZXRUZXhlbCh2VXYwNCksZ2V0VGV4ZWwodlV2MDUpLGdldFRleGVsKHZVdjA2KSxnZXRUZXhlbCh2VXYwNyksZ2V0VGV4ZWwodlV2MDgpLGdldFRleGVsKHZVdjA5KSxnZXRUZXhlbCh2VXYxMCksZ2V0VGV4ZWwodlV2MTEpLGdldFRleGVsKHZVdjEyKSxnZXRUZXhlbCh2VXYxMyksZ2V0VGV4ZWwodlV2MTQpLGdldFRleGVsKHZVdjE1KSxnZXRUZXhlbCh2VXYxNiksZ2V0VGV4ZWwodlV2MTcpLGdldFRleGVsKHZVdjE4KSxnZXRUZXhlbCh2VXYxOSksZ2V0VGV4ZWwodlV2MjApLGdldFRleGVsKHZVdjIxKSxnZXRUZXhlbCh2VXYyMiksZ2V0VGV4ZWwodlV2MjMpLGdldFRleGVsKHZVdjI0KSk7XG4jaWZkZWYgQklMQVRFUkFMXG5mbG9hdCB6W109ZmxvYXRbS0VSTkVMX1NJWkVfU1FdKGxpbmVhckRlcHRoKHZVdjAwKSxsaW5lYXJEZXB0aCh2VXYwMSksbGluZWFyRGVwdGgodlV2MDIpLGxpbmVhckRlcHRoKHZVdjAzKSxsaW5lYXJEZXB0aCh2VXYwNCksbGluZWFyRGVwdGgodlV2MDUpLGxpbmVhckRlcHRoKHZVdjA2KSxsaW5lYXJEZXB0aCh2VXYwNyksbGluZWFyRGVwdGgodlV2MDgpLGxpbmVhckRlcHRoKHZVdjA5KSxsaW5lYXJEZXB0aCh2VXYxMCksbGluZWFyRGVwdGgodlV2MTEpLGxpbmVhckRlcHRoKHZVdjEyKSxsaW5lYXJEZXB0aCh2VXYxMyksbGluZWFyRGVwdGgodlV2MTQpLGxpbmVhckRlcHRoKHZVdjE1KSxsaW5lYXJEZXB0aCh2VXYxNiksbGluZWFyRGVwdGgodlV2MTcpLGxpbmVhckRlcHRoKHZVdjE4KSxsaW5lYXJEZXB0aCh2VXYxOSksbGluZWFyRGVwdGgodlV2MjApLGxpbmVhckRlcHRoKHZVdjIxKSxsaW5lYXJEZXB0aCh2VXYyMiksbGluZWFyRGVwdGgodlV2MjMpLGxpbmVhckRlcHRoKHZVdjI0KSk7XG4jZW5kaWZcbiNlbmRpZlxudmVjNCByZXN1bHQ9dmVjNCgwLjApO1xuI2lmZGVmIEJJTEFURVJBTFxuZmxvYXQgdz0wLjA7XG4jaWYgS0VSTkVMX1NJWkUgPT0gMyB8fCAoS0VSTkVMX1NJWkUgPT0gNSAmJiBNQVhfVkFSWUlOR19WRUNUT1JTID49IDEzKVxuZmxvYXQgY2VudGVyRGVwdGg9eltLRVJORUxfU0laRV9TUV9IQUxGXTtmb3IoaW50IGk9MDtpPEtFUk5FTF9TSVpFX1NROysraSl7ZmxvYXQgZD1zdGVwKGFicyh6W2ldLWNlbnRlckRlcHRoKSxESVNUQU5DRV9USFJFU0hPTEQpO3Jlc3VsdCs9Y1tpXSpkO3crPWQ7fVxuI2Vsc2VcbmZsb2F0IGNlbnRlckRlcHRoPWxpbmVhckRlcHRoKHZVdik7dmVjMiBzPXRleGVsU2l6ZSpzY2FsZTtmb3IoaW50IHg9LUtFUk5FTF9TSVpFX0hBTEY7eDw9S0VSTkVMX1NJWkVfSEFMRjsrK3gpe2ZvcihpbnQgeT0tS0VSTkVMX1NJWkVfSEFMRjt5PD1LRVJORUxfU0laRV9IQUxGOysreSl7dmVjMiBjb29yZHM9dlV2K3ZlYzIoeCx5KSpzO3ZlYzQgYz1nZXRUZXhlbChjb29yZHMpO2Zsb2F0IHo9KHg9PTAmJnk9PTApP2NlbnRlckRlcHRoOmxpbmVhckRlcHRoKGNvb3Jkcyk7ZmxvYXQgZD1zdGVwKGFicyh6LWNlbnRlckRlcHRoKSxESVNUQU5DRV9USFJFU0hPTEQpO3Jlc3VsdCs9YypkO3crPWQ7fX1cbiNlbmRpZlxuZ2xfRnJhZ0NvbG9yPXJlc3VsdC9tYXgodywxLjApO1xuI2Vsc2VcbiNpZiBLRVJORUxfU0laRSA9PSAzIHx8IChLRVJORUxfU0laRSA9PSA1ICYmIE1BWF9WQVJZSU5HX1ZFQ1RPUlMgPj0gMTMpXG5mb3IoaW50IGk9MDtpPEtFUk5FTF9TSVpFX1NROysraSl7cmVzdWx0Kz1jW2ldO31cbiNlbHNlXG52ZWMyIHM9dGV4ZWxTaXplKnNjYWxlO2ZvcihpbnQgeD0tS0VSTkVMX1NJWkVfSEFMRjt4PD1LRVJORUxfU0laRV9IQUxGOysreCl7Zm9yKGludCB5PS1LRVJORUxfU0laRV9IQUxGO3k8PUtFUk5FTF9TSVpFX0hBTEY7Kyt5KXtyZXN1bHQrPWdldFRleGVsKHV2K3ZlYzIoeCx5KSpzKTt9fVxuI2VuZGlmXG5nbF9GcmFnQ29sb3I9cmVzdWx0KklOVl9LRVJORUxfU0laRV9TUTtcbiNlbmRpZlxufWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5ib3gudmVydFxudmFyIGNvbnZvbHV0aW9uX2JveF9kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQgc2NhbGU7XG4jaWYgS0VSTkVMX1NJWkUgPT0gM1xudmFyeWluZyB2ZWMyIHZVdjAwLHZVdjAxLHZVdjAyO3ZhcnlpbmcgdmVjMiB2VXYwMyx2VXYwNCx2VXYwNTt2YXJ5aW5nIHZlYzIgdlV2MDYsdlV2MDcsdlV2MDg7XG4jZWxpZiBLRVJORUxfU0laRSA9PSA1ICYmIE1BWF9WQVJZSU5HX1ZFQ1RPUlMgPj0gMTNcbnZhcnlpbmcgdmVjMiB2VXYwMCx2VXYwMSx2VXYwMix2VXYwMyx2VXYwNDt2YXJ5aW5nIHZlYzIgdlV2MDUsdlV2MDYsdlV2MDcsdlV2MDgsdlV2MDk7dmFyeWluZyB2ZWMyIHZVdjEwLHZVdjExLHZVdjEyLHZVdjEzLHZVdjE0O3ZhcnlpbmcgdmVjMiB2VXYxNSx2VXYxNix2VXYxNyx2VXYxOCx2VXYxOTt2YXJ5aW5nIHZlYzIgdlV2MjAsdlV2MjEsdlV2MjIsdlV2MjMsdlV2MjQ7XG4jZWxzZVxudmFyeWluZyB2ZWMyIHZVdjtcbiNlbmRpZlxudm9pZCBtYWluKCl7dmVjMiB1dj1wb3NpdGlvbi54eSowLjUrMC41O1xuI2lmIEtFUk5FTF9TSVpFID09IDNcbnZlYzIgcz10ZXhlbFNpemUqc2NhbGU7dlV2MDA9dXYrcyp2ZWMyKC0xLjAsLTEuMCk7dlV2MDE9dXYrcyp2ZWMyKDAuMCwtMS4wKTt2VXYwMj11ditzKnZlYzIoMS4wLC0xLjApO3ZVdjAzPXV2K3MqdmVjMigtMS4wLDAuMCk7dlV2MDQ9dXY7dlV2MDU9dXYrcyp2ZWMyKDEuMCwwLjApO3ZVdjA2PXV2K3MqdmVjMigtMS4wLDEuMCk7dlV2MDc9dXYrcyp2ZWMyKDAuMCwxLjApO3ZVdjA4PXV2K3MqdmVjMigxLjAsMS4wKTtcbiNlbGlmIEtFUk5FTF9TSVpFID09IDVcbnZlYzIgcz10ZXhlbFNpemUqc2NhbGU7dlV2MDA9dXYrcyp2ZWMyKC0yLjAsLTIuMCk7dlV2MDE9dXYrcyp2ZWMyKC0xLjAsLTIuMCk7dlV2MDI9dXYrcyp2ZWMyKDAuMCwtMi4wKTt2VXYwMz11ditzKnZlYzIoMS4wLC0yLjApO3ZVdjA0PXV2K3MqdmVjMigyLjAsLTIuMCk7dlV2MDU9dXYrcyp2ZWMyKC0yLjAsLTEuMCk7dlV2MDY9dXYrcyp2ZWMyKC0xLjAsLTEuMCk7dlV2MDc9dXYrcyp2ZWMyKDAuMCwtMS4wKTt2VXYwOD11ditzKnZlYzIoMS4wLC0xLjApO3ZVdjA5PXV2K3MqdmVjMigyLjAsLTEuMCk7dlV2MTA9dXYrcyp2ZWMyKC0yLjAsMC4wKTt2VXYxMT11ditzKnZlYzIoLTEuMCwwLjApO3ZVdjEyPXV2O3ZVdjEzPXV2K3MqdmVjMigxLjAsMC4wKTt2VXYxND11ditzKnZlYzIoMi4wLDAuMCk7dlV2MTU9dXYrcyp2ZWMyKC0yLjAsMS4wKTt2VXYxNj11ditzKnZlYzIoLTEuMCwxLjApO3ZVdjE3PXV2K3MqdmVjMigwLjAsMS4wKTt2VXYxOD11ditzKnZlYzIoMS4wLDEuMCk7dlV2MTk9dXYrcyp2ZWMyKDIuMCwxLjApO3ZVdjIwPXV2K3MqdmVjMigtMi4wLDIuMCk7dlV2MjE9dXYrcyp2ZWMyKC0xLjAsMi4wKTt2VXYyMj11ditzKnZlYzIoMC4wLDIuMCk7dlV2MjM9dXYrcyp2ZWMyKDEuMCwyLjApO3ZVdjI0PXV2K3MqdmVjMigyLjAsMi4wKTtcbiNlbHNlXG52VXY9dXY7XG4jZW5kaWZcbmdsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fWA7XG5cbi8vIHNyYy9tYXRlcmlhbHMvQm94Qmx1ck1hdGVyaWFsLmpzXG52YXIgQm94Qmx1ck1hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDE5IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYm94IGJsdXIgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJpbGF0ZXJhbD1mYWxzZV0gLSBFbmFibGVzIG9yIGRpc2FibGVzIGJpbGF0ZXJhbCBibHVycmluZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmtlcm5lbFNpemU9NV0gLSBUaGUga2VybmVsIHNpemUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJpbGF0ZXJhbCA9IGZhbHNlLCBrZXJuZWxTaXplID0gNSB9ID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkJveEJsdXJNYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIixcbiAgICAgICAgRElTVEFOQ0VfVEhSRVNIT0xEOiBcIjAuMVwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtNDgobnVsbCksXG4gICAgICAgIGRlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTQ4KG51bGwpLFxuICAgICAgICBub3JtYWxEZXB0aEJ1ZmZlcjogbmV3IFVuaWZvcm00OChudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTQ4KG5ldyBWZWN0b3IyMjUoKSksXG4gICAgICAgIGNhbWVyYU5lYXJGYXI6IG5ldyBVbmlmb3JtNDgobmV3IFZlY3RvcjIyNSgpKSxcbiAgICAgICAgc2NhbGU6IG5ldyBVbmlmb3JtNDgoMSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzE4LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fYm94X2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbnZvbHV0aW9uX2JveF9kZWZhdWx0MlxuICAgIH0pO1xuICAgIHRoaXMuYmlsYXRlcmFsID0gYmlsYXRlcmFsO1xuICAgIHRoaXMua2VybmVsU2l6ZSA9IGtlcm5lbFNpemU7XG4gICAgdGhpcy5tYXhWYXJ5aW5nVmVjdG9ycyA9IDg7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB2YXJ5aW5nIHZlY3RvcnMuXG4gICAqXG4gICAqIFNob3VsZCBiZSBzeW5jZWQgd2l0aCBgcmVuZGVyZXIuY2FwYWJpbGl0aWVzLm1heFZhcnlpbmdzYC4gRGVmYXVsdCBpcyA4LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IG1heFZhcnlpbmdWZWN0b3JzKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLk1BWF9WQVJZSU5HX1ZFQ1RPUlMgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUga2VybmVsIHNpemUuXG4gICAqXG4gICAqIC0gTXVzdCBiZSBhbiBvZGQgbnVtYmVyXG4gICAqIC0gS2VybmVsIHNpemUgMyBhbmQgNSB1c2Ugb3B0aW1pemVkIGNvZGUgcGF0aHNcbiAgICogLSBEZWZhdWx0IGlzIDVcbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBrZXJuZWxTaXplKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLktFUk5FTF9TSVpFKTtcbiAgfVxuICBzZXQga2VybmVsU2l6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAlIDIgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBrZXJuZWwgc2l6ZSBtdXN0IGJlIGFuIG9kZCBudW1iZXJcIik7XG4gICAgfVxuICAgIHRoaXMuZGVmaW5lcy5LRVJORUxfU0laRSA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5kZWZpbmVzLktFUk5FTF9TSVpFX0hBTEYgPSBNYXRoLmZsb29yKHZhbHVlIC8gMikudG9GaXhlZCgwKTtcbiAgICB0aGlzLmRlZmluZXMuS0VSTkVMX1NJWkVfU1EgPSAodmFsdWUgKiogMikudG9GaXhlZCgwKTtcbiAgICB0aGlzLmRlZmluZXMuS0VSTkVMX1NJWkVfU1FfSEFMRiA9IE1hdGguZmxvb3IodmFsdWUgKiogMiAvIDIpLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5kZWZpbmVzLklOVl9LRVJORUxfU0laRV9TUSA9ICgxIC8gdmFsdWUgKiogMikudG9GaXhlZCg2KTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBuZWFyIHBsYW5lIHNldHRpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgbmVhcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyRmFyLnZhbHVlLng7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGZhciBwbGFuZSBzZXR0aW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IGZhcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyRmFyLnZhbHVlLnk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQSBjb21iaW5lZCBub3JtYWwtZGVwdGggYnVmZmVyLiBPdmVycmlkZXMge0BsaW5rIGRlcHRoQnVmZmVyfSBpZiBzZXQuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IG5vcm1hbERlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5ub3JtYWxEZXB0aEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLk5PUk1BTF9ERVBUSCA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLk5PUk1BTF9ERVBUSDtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGJpbGF0ZXJhbCBmaWx0ZXJpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgYmlsYXRlcmFsKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuQklMQVRFUkFMICE9PSB2b2lkIDA7XG4gIH1cbiAgc2V0IGJpbGF0ZXJhbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLkJJTEFURVJBTCA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLkJJTEFURVJBTDtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiaWxhdGVyYWwgZmlsdGVyIGRpc3RhbmNlIHRocmVzaG9sZCBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZERpc3RhbmNlVGhyZXNob2xkKCkge1xuICAgIHJldHVybiAtb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKE51bWJlcih0aGlzLmRlZmluZXMuRElTVEFOQ0VfVEhSRVNIT0xEKSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgc2V0IHdvcmxkRGlzdGFuY2VUaHJlc2hvbGQodmFsdWUpIHtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoLXZhbHVlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgICB0aGlzLmRlZmluZXMuRElTVEFOQ0VfVEhSRVNIT0xEID0gdGhyZXNob2xkLnRvRml4ZWQoMTIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXJGYXIudmFsdWUuc2V0KGNhbWVyYS5uZWFyLCBjYW1lcmEuZmFyKTtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYTUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQSA9IFwiMVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkE7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9EZXB0aENvcHlNYXRlcmlhbC5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmcxNCwgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTksIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMjAsIFVuaWZvcm0gYXMgVW5pZm9ybTQ5LCBWZWN0b3IyIGFzIFZlY3RvcjIyNiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvZGVwdGgtY29weS5mcmFnXG52YXIgZGVwdGhfY29weV9kZWZhdWx0ID0gYCNpbmNsdWRlIDxwYWNraW5nPlxudmFyeWluZyB2ZWMyIHZVdjtcbiNpZmRlZiBOT1JNQUxfREVQVEhcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgbm9ybWFsRGVwdGhCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcbiNlbmRpZlxuZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe3JldHVybiB0ZXh0dXJlMkQobm9ybWFsRGVwdGhCdWZmZXIsdXYpLmE7fVxuI2Vsc2VcbiNpZiBJTlBVVF9ERVBUSF9QQUNLSU5HID09IDMyMDFcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZWxpZiBkZWZpbmVkKEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIKVxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbmRpZlxuZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe1xuI2lmIElOUFVUX0RFUFRIX1BBQ0tJTkcgPT0gMzIwMVxucmV0dXJuIHVucGFja1JHQkFUb0RlcHRoKHRleHR1cmUyRChkZXB0aEJ1ZmZlcix1dikpO1xuI2Vsc2VcbnJldHVybiB0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XG4jZW5kaWZcbn1cbiNlbmRpZlxudm9pZCBtYWluKCl7XG4jaWYgSU5QVVRfREVQVEhfUEFDS0lORyA9PSBPVVRQVVRfREVQVEhfUEFDS0lOR1xuZ2xfRnJhZ0NvbG9yPXRleHR1cmUyRChkZXB0aEJ1ZmZlcix2VXYpO1xuI2Vsc2VcbmZsb2F0IGRlcHRoPXJlYWREZXB0aCh2VXYpO1xuI2lmIE9VVFBVVF9ERVBUSF9QQUNLSU5HID09IDMyMDFcbmdsX0ZyYWdDb2xvcj0oZGVwdGg9PTEuMCk/dmVjNCgxLjApOnBhY2tEZXB0aFRvUkdCQShkZXB0aCk7XG4jZWxzZVxuZ2xfRnJhZ0NvbG9yPXZlYzQodmVjMyhkZXB0aCksMS4wKTtcbiNlbmRpZlxuI2VuZGlmXG59YDtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2RlcHRoLWNvcHkudmVydFxudmFyIGRlcHRoX2NvcHlfZGVmYXVsdDIgPSBgdmFyeWluZyB2ZWMyIHZVdjtcbiNpZiBERVBUSF9DT1BZX01PREUgPT0gMVxudW5pZm9ybSB2ZWMyIHRleGVsUG9zaXRpb247XG4jZW5kaWZcbnZvaWQgbWFpbigpe1xuI2lmIERFUFRIX0NPUFlfTU9ERSA9PSAxXG52VXY9dGV4ZWxQb3NpdGlvbjtcbiNlbHNlXG52VXY9cG9zaXRpb24ueHkqMC41KzAuNTtcbiNlbmRpZlxuZ2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9YDtcblxuLy8gc3JjL21hdGVyaWFscy9EZXB0aENvcHlNYXRlcmlhbC5qc1xudmFyIERlcHRoQ29weU1hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDIwIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggY29weSBtYXRlcmlhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiRGVwdGhDb3B5TWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgSU5QVVRfREVQVEhfUEFDS0lORzogXCIwXCIsXG4gICAgICAgIE9VVFBVVF9ERVBUSF9QQUNLSU5HOiBcIjBcIixcbiAgICAgICAgREVQVEhfQ09QWV9NT0RFOiBcIjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGRlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTQ5KG51bGwpLFxuICAgICAgICB0ZXhlbFBvc2l0aW9uOiBuZXcgVW5pZm9ybTQ5KG5ldyBWZWN0b3IyMjYoKSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzE5LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhfY29weV9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBkZXB0aF9jb3B5X2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5kZXB0aENvcHlNb2RlID0gRGVwdGhDb3B5TW9kZS5GVUxMO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCBkZXB0aEJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlci52YWx1ZTtcbiAgfVxuICBzZXQgZGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBpbnB1dERlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5JTlBVVF9ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG91dHB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIGdldCBvdXRwdXREZXB0aFBhY2tpbmcoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuT1VUUFVUX0RFUFRIX1BBQ0tJTkcpO1xuICB9XG4gIHNldCBvdXRwdXREZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuT1VUUFVUX0RFUFRIX1BBQ0tJTkcgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlciBhbmQgaW5wdXREZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIoYnVmZmVyLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzE0KSB7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLmlucHV0RGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGlucHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEByZXR1cm4ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFRoZSBpbnB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgZ2V0SW5wdXREZXB0aFBhY2tpbmcoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuSU5QVVRfREVQVEhfUEFDS0lORyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dERlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IHZhbHVlIC0gVGhlIG5ldyBpbnB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0SW5wdXREZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuSU5QVVRfREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgb3V0cHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvdXRwdXREZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHJldHVybiB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gVGhlIG91dHB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgZ2V0T3V0cHV0RGVwdGhQYWNraW5nKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLk9VVFBVVF9ERVBUSF9QQUNLSU5HKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgb3V0cHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvdXRwdXREZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSB2YWx1ZSAtIFRoZSBuZXcgb3V0cHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXRPdXRwdXREZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuT1VUUFVUX0RFUFRIX1BBQ0tJTkcgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2NyZWVuIHNwYWNlIHBvc2l0aW9uIHVzZWQgZm9yIHNpbmdsZS10ZXhlbCBjb3B5IG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0IHRleGVsUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudGV4ZWxQb3NpdGlvbi52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2NyZWVuIHNwYWNlIHBvc2l0aW9uIHVzZWQgZm9yIHNpbmdsZS10ZXhlbCBjb3B5IG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXhlbFBvc2l0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9IFRoZSBwb3NpdGlvbi5cbiAgICovXG4gIGdldFRleGVsUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudGV4ZWxQb3NpdGlvbi52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2NyZWVuIHNwYWNlIHBvc2l0aW9uIHVzZWQgZm9yIHNpbmdsZS10ZXhlbCBjb3B5IG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdmFsdWUgLSBUaGUgcG9zaXRpb24uXG4gICAqL1xuICBzZXRUZXhlbFBvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFBvc2l0aW9uLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBjb3B5IG1vZGUuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aENvcHlNb2RlfVxuICAgKi9cbiAgZ2V0IG1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwdGhDb3B5TW9kZTtcbiAgfVxuICBzZXQgbW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuZGVwdGhDb3B5TW9kZSA9IHZhbHVlO1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9DT1BZX01PREUgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXB0aCBjb3B5IG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtb2RlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0RlcHRoQ29weU1vZGV9IFRoZSBkZXB0aCBjb3B5IG1vZGUuXG4gICAqL1xuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGNvcHkgbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1vZGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtEZXB0aENvcHlNb2RlfSB2YWx1ZSAtIFRoZSBuZXcgbW9kZS5cbiAgICovXG4gIHNldE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLm1vZGUgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9FZmZlY3RNYXRlcmlhbC5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmcxNSwgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMjAsIFBlcnNwZWN0aXZlQ2FtZXJhIGFzIFBlcnNwZWN0aXZlQ2FtZXJhNiwgUkVWSVNJT04gYXMgUkVWSVNJT040LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDIxLCBVbmlmb3JtIGFzIFVuaWZvcm01MCwgVmVjdG9yMiBhcyBWZWN0b3IyMjcgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2VmZmVjdC5mcmFnXG52YXIgZWZmZWN0X2RlZmF1bHQgPSBgI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDxwYWNraW5nPlxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxuI2RlZmluZSBwYWNrRmxvYXRUb1JHQkEodikgcGFja0RlcHRoVG9SR0JBKHYpXG4jZGVmaW5lIHVucGFja1JHQkFUb0Zsb2F0KHYpIHVucGFja1JHQkFUb0RlcHRoKHYpXG4jaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZWxzZVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcbiNlbmRpZlxuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbGlmIGRlZmluZWQoR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gpXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcbiNlbHNlXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xuI2VuZGlmXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjt1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjt1bmlmb3JtIGZsb2F0IGNhbWVyYUZhcjt1bmlmb3JtIGZsb2F0IGFzcGVjdDt1bmlmb3JtIGZsb2F0IHRpbWU7dmFyeWluZyB2ZWMyIHZVdjt2ZWM0IHNSR0JUb0xpbmVhcihjb25zdCBpbiB2ZWM0IHZhbHVlKXtyZXR1cm4gdmVjNChtaXgocG93KHZhbHVlLnJnYiowLjk0Nzg2NzI5ODYrdmVjMygwLjA1MjEzMjcwMTQpLHZlYzMoMi40KSksdmFsdWUucmdiKjAuMDc3Mzk5MzgwOCx2ZWMzKGxlc3NUaGFuRXF1YWwodmFsdWUucmdiLHZlYzMoMC4wNDA0NSkpKSksdmFsdWUuYSk7fWZsb2F0IHJlYWREZXB0aChjb25zdCBpbiB2ZWMyIHV2KXtcbiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcbnJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpKTtcbiNlbHNlXG5yZXR1cm4gdGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KS5yO1xuI2VuZGlmXG59ZmxvYXQgZ2V0Vmlld1ooY29uc3QgaW4gZmxvYXQgZGVwdGgpe1xuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxucmV0dXJuIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcbiNlbHNlXG5yZXR1cm4gb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcbiNlbmRpZlxufXZlYzMgUkdCVG9IQ1YoY29uc3QgaW4gdmVjMyBSR0Ipe3ZlYzQgUD1taXgodmVjNChSR0IuYmcsLTEuMCwyLjAvMy4wKSx2ZWM0KFJHQi5nYiwwLjAsLTEuMC8zLjApLHN0ZXAoUkdCLmIsUkdCLmcpKTt2ZWM0IFE9bWl4KHZlYzQoUC54eXcsUkdCLnIpLHZlYzQoUkdCLnIsUC55engpLHN0ZXAoUC54LFJHQi5yKSk7ZmxvYXQgQz1RLngtbWluKFEudyxRLnkpO2Zsb2F0IEg9YWJzKChRLnctUS55KS8oNi4wKkMrRVBTSUxPTikrUS56KTtyZXR1cm4gdmVjMyhILEMsUS54KTt9dmVjMyBSR0JUb0hTTChjb25zdCBpbiB2ZWMzIFJHQil7dmVjMyBIQ1Y9UkdCVG9IQ1YoUkdCKTtmbG9hdCBMPUhDVi56LUhDVi55KjAuNTtmbG9hdCBTPUhDVi55LygxLjAtYWJzKEwqMi4wLTEuMCkrRVBTSUxPTik7cmV0dXJuIHZlYzMoSENWLngsUyxMKTt9dmVjMyBIdWVUb1JHQihjb25zdCBpbiBmbG9hdCBIKXtmbG9hdCBSPWFicyhIKjYuMC0zLjApLTEuMDtmbG9hdCBHPTIuMC1hYnMoSCo2LjAtMi4wKTtmbG9hdCBCPTIuMC1hYnMoSCo2LjAtNC4wKTtyZXR1cm4gY2xhbXAodmVjMyhSLEcsQiksMC4wLDEuMCk7fXZlYzMgSFNMVG9SR0IoY29uc3QgaW4gdmVjMyBIU0wpe3ZlYzMgUkdCPUh1ZVRvUkdCKEhTTC54KTtmbG9hdCBDPSgxLjAtYWJzKDIuMCpIU0wuei0xLjApKSpIU0wueTtyZXR1cm4oUkdCLTAuNSkqQytIU0wuejt9RlJBR01FTlRfSEVBRCB2b2lkIG1haW4oKXtGUkFHTUVOVF9NQUlOX1VWIHZlYzQgY29sb3IwPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixVVik7dmVjNCBjb2xvcjE9dmVjNCgwLjApO0ZSQUdNRU5UX01BSU5fSU1BR0UgY29sb3IwLmE9Y2xhbXAoY29sb3IwLmEsMC4wLDEuMCk7Z2xfRnJhZ0NvbG9yPWNvbG9yMDtcbiNpZmRlZiBFTkNPREVfT1VUUFVUXG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cbiNlbmRpZlxuI2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cbn1gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvZWZmZWN0LnZlcnRcbnZhciBlZmZlY3RfZGVmYXVsdDIgPSBgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247dW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt1bmlmb3JtIGZsb2F0IGNhbWVyYU5lYXI7dW5pZm9ybSBmbG9hdCBjYW1lcmFGYXI7dW5pZm9ybSBmbG9hdCBhc3BlY3Q7dW5pZm9ybSBmbG9hdCB0aW1lO3ZhcnlpbmcgdmVjMiB2VXY7VkVSVEVYX0hFQUQgdm9pZCBtYWluKCl7dlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7VkVSVEVYX01BSU5fU1VQUE9SVCBnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0VmZmVjdE1hdGVyaWFsLmpzXG52YXIgRWZmZWN0TWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMjEge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBlZmZlY3QgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7TWFwPFN0cmluZywgU3RyaW5nPn0gW3NoYWRlclBhcnRzXSAtIERlcHJlY2F0ZWQuIFVzZSBzZXRTaGFkZXJEYXRhIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TWFwPFN0cmluZywgU3RyaW5nPn0gW2RlZmluZXNdIC0gRGVwcmVjYXRlZC4gVXNlIHNldFNoYWRlckRhdGEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtNYXA8U3RyaW5nLCBVbmlmb3JtPn0gW3VuaWZvcm1zXSAtIERlcHJlY2F0ZWQuIFVzZSBzZXRTaGFkZXJEYXRhIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBbY2FtZXJhXSAtIEEgY2FtZXJhLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkaXRoZXJpbmc9ZmFsc2VdIC0gRGVwcmVjYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNoYWRlclBhcnRzLCBkZWZpbmVzLCB1bmlmb3JtcywgY2FtZXJhLCBkaXRoZXJpbmcgPSBmYWxzZSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiRWZmZWN0TWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgVEhSRUVfUkVWSVNJT046IFJFVklTSU9ONC5yZXBsYWNlKC9cXEQrL2csIFwiXCIpLFxuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIixcbiAgICAgICAgRU5DT0RFX09VVFBVVDogXCIxXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm01MChudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtNTAobnVsbCksXG4gICAgICAgIHJlc29sdXRpb246IG5ldyBVbmlmb3JtNTAobmV3IFZlY3RvcjIyNygpKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTUwKG5ldyBWZWN0b3IyMjcoKSksXG4gICAgICAgIGNhbWVyYU5lYXI6IG5ldyBVbmlmb3JtNTAoMC4zKSxcbiAgICAgICAgY2FtZXJhRmFyOiBuZXcgVW5pZm9ybTUwKDFlMyksXG4gICAgICAgIGFzcGVjdDogbmV3IFVuaWZvcm01MCgxKSxcbiAgICAgICAgdGltZTogbmV3IFVuaWZvcm01MCgwKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMjAsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGRpdGhlcmluZ1xuICAgIH0pO1xuICAgIGlmIChzaGFkZXJQYXJ0cykge1xuICAgICAgdGhpcy5zZXRTaGFkZXJQYXJ0cyhzaGFkZXJQYXJ0cyk7XG4gICAgfVxuICAgIGlmIChkZWZpbmVzKSB7XG4gICAgICB0aGlzLnNldERlZmluZXMoZGVmaW5lcyk7XG4gICAgfVxuICAgIGlmICh1bmlmb3Jtcykge1xuICAgICAgdGhpcy5zZXRVbmlmb3Jtcyh1bmlmb3Jtcyk7XG4gICAgfVxuICAgIHRoaXMuY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGlucHV0IGJ1ZmZlci5cbiAgICovXG4gIHNldElucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCBkZXB0aEJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlci52YWx1ZTtcbiAgfVxuICBzZXQgZGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIGdldCBkZXB0aFBhY2tpbmcoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyk7XG4gIH1cbiAgc2V0IGRlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhCdWZmZXIgYW5kIGRlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTUpIHtcbiAgICB0aGlzLmRlcHRoQnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaGFkZXIgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtFZmZlY3RTaGFkZXJEYXRhfSBkYXRhIC0gVGhlIHNoYWRlciBkYXRhLlxuICAgKiBAcmV0dXJuIHtFZmZlY3RNYXRlcmlhbH0gVGhpcyBtYXRlcmlhbC5cbiAgICovXG4gIHNldFNoYWRlckRhdGEoZGF0YSkge1xuICAgIHRoaXMuc2V0U2hhZGVyUGFydHMoZGF0YS5zaGFkZXJQYXJ0cyk7XG4gICAgdGhpcy5zZXREZWZpbmVzKGRhdGEuZGVmaW5lcyk7XG4gICAgdGhpcy5zZXRVbmlmb3JtcyhkYXRhLnVuaWZvcm1zKTtcbiAgICB0aGlzLnNldEV4dGVuc2lvbnMoZGF0YS5leHRlbnNpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2hhZGVyIHBhcnRzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0U2hhZGVyRGF0YSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge01hcDxTdHJpbmcsIFN0cmluZz59IHNoYWRlclBhcnRzIC0gQSBjb2xsZWN0aW9uIG9mIHNoYWRlciBzbmlwcGV0cy4gU2VlIHtAbGluayBFZmZlY3RTaGFkZXJTZWN0aW9ufS5cbiAgICogQHJldHVybiB7RWZmZWN0TWF0ZXJpYWx9IFRoaXMgbWF0ZXJpYWwuXG4gICAqL1xuICBzZXRTaGFkZXJQYXJ0cyhzaGFkZXJQYXJ0cykge1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBlZmZlY3RfZGVmYXVsdC5yZXBsYWNlKEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCwgc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCkgfHwgXCJcIikucmVwbGFjZShFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fVVYsIHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fVVYpIHx8IFwiXCIpLnJlcGxhY2UoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX0lNQUdFLCBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX0lNQUdFKSB8fCBcIlwiKTtcbiAgICB0aGlzLnZlcnRleFNoYWRlciA9IGVmZmVjdF9kZWZhdWx0Mi5yZXBsYWNlKEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX0hFQUQsIHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLlZFUlRFWF9IRUFEKSB8fCBcIlwiKS5yZXBsYWNlKEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX01BSU5fU1VQUE9SVCwgc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX01BSU5fU1VQUE9SVCkgfHwgXCJcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNoYWRlciBtYWNyb3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZXRTaGFkZXJEYXRhIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TWFwPFN0cmluZywgU3RyaW5nPn0gZGVmaW5lcyAtIEEgY29sbGVjdGlvbiBvZiBwcmVwcm9jZXNzb3IgbWFjcm8gZGVmaW5pdGlvbnMuXG4gICAqIEByZXR1cm4ge0VmZmVjdE1hdGVyaWFsfSBUaGlzIG1hdGVyaWFsLlxuICAgKi9cbiAgc2V0RGVmaW5lcyhkZWZpbmVzKSB7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBkZWZpbmVzLmVudHJpZXMoKSkge1xuICAgICAgdGhpcy5kZWZpbmVzW2VudHJ5WzBdXSA9IGVudHJ5WzFdO1xuICAgIH1cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2hhZGVyIHVuaWZvcm1zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0U2hhZGVyRGF0YSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge01hcDxTdHJpbmcsIFVuaWZvcm0+fSB1bmlmb3JtcyAtIEEgY29sbGVjdGlvbiBvZiB1bmlmb3Jtcy5cbiAgICogQHJldHVybiB7RWZmZWN0TWF0ZXJpYWx9IFRoaXMgbWF0ZXJpYWwuXG4gICAqL1xuICBzZXRVbmlmb3Jtcyh1bmlmb3Jtcykge1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdW5pZm9ybXMuZW50cmllcygpKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zW2VudHJ5WzBdXSA9IGVudHJ5WzFdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVxdWlyZWQgc2hhZGVyIGV4dGVuc2lvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZXRTaGFkZXJEYXRhIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7U2V0PFdlYkdMRXh0ZW5zaW9uPn0gZXh0ZW5zaW9ucyAtIEEgY29sbGVjdGlvbiBvZiBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJuIHtFZmZlY3RNYXRlcmlhbH0gVGhpcyBtYXRlcmlhbC5cbiAgICovXG4gIHNldEV4dGVuc2lvbnMoZXh0ZW5zaW9ucykge1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuICAgIGZvciAoY29uc3QgZXh0ZW5zaW9uIG9mIGV4dGVuc2lvbnMpIHtcbiAgICAgIHRoaXMuZXh0ZW5zaW9uc1tleHRlbnNpb25dID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIG91dHB1dCBlbmNvZGluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBlbmNvZGVPdXRwdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5FTkNPREVfT1VUUFVUICE9PSB2b2lkIDA7XG4gIH1cbiAgc2V0IGVuY29kZU91dHB1dCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmVuY29kZU91dHB1dCAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuRU5DT0RFX09VVFBVVCA9IFwiMVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5FTkNPREVfT1VUUFVUO1xuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvdXRwdXQgZW5jb2RpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVuY29kZU91dHB1dCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIG91dHB1dCBlbmNvZGluZyBpcyBlbmFibGVkLlxuICAgKi9cbiAgaXNPdXRwdXRFbmNvZGluZ0VuYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGVPdXRwdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgb3V0cHV0IGVuY29kaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZW5jb2RlT3V0cHV0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIG91dHB1dCBlbmNvZGluZyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldE91dHB1dEVuY29kaW5nRW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuZW5jb2RlT3V0cHV0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0aW1lIGluIHNlY29uZHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgdGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy50aW1lLnZhbHVlO1xuICB9XG4gIHNldCB0aW1lKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy50aW1lLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlbHRhIHRpbWUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aW1lIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBkZWx0YSB0aW1lIGluIHNlY29uZHMuXG4gICAqL1xuICBzZXREZWx0YVRpbWUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRpbWUudmFsdWUgKz0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcHlDYW1lcmFTZXR0aW5ncyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSBjYW1lcmEuXG4gICAqL1xuICBhZG9wdENhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIHRoaXMuY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIGlmIChjYW1lcmEpIHtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhci52YWx1ZSA9IGNhbWVyYS5uZWFyO1xuICAgICAgdGhpcy51bmlmb3Jtcy5jYW1lcmFGYXIudmFsdWUgPSBjYW1lcmEuZmFyO1xuICAgICAgaWYgKGNhbWVyYSBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhNikge1xuICAgICAgICB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBID0gXCIxXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVzb2x1dGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHVuaWZvcm1zID0gdGhpcy51bmlmb3JtcztcbiAgICB1bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLnNldCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB1bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KDEgLyB3aWR0aCwgMSAvIGhlaWdodCk7XG4gICAgdW5pZm9ybXMuYXNwZWN0LnZhbHVlID0gd2lkdGggLyBoZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIEFuIGVudW1lcmF0aW9uIG9mIHNoYWRlciBjb2RlIHBsYWNlaG9sZGVycy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIEVmZmVjdFNoYWRlclNlY3Rpb24gaW5zdGVhZC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgU2VjdGlvbigpIHtcbiAgICByZXR1cm4gRWZmZWN0U2hhZGVyU2VjdGlvbjtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9HYXVzc2lhbkJsdXJNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMjEsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMjIsIFVuaWZvcm0gYXMgVW5pZm9ybTUxLCBWZWN0b3IyIGFzIFZlY3RvcjIyOCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uZ2F1c3NpYW4uZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2dhdXNzaWFuX2RlZmF1bHQgPSBgI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xuI2Vsc2VcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XG4jZW5kaWZcbnVuaWZvcm0gdmVjMiBrZXJuZWxbU1RFUFNdO3ZhcnlpbmcgdmVjMiB2T2Zmc2V0O3ZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7dmVjNCByZXN1bHQ9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdikqa2VybmVsWzBdLnk7Zm9yKGludCBpPTE7aTxTVEVQUzsrK2kpe3ZlYzIgb2Zmc2V0PWtlcm5lbFtpXS54KnZPZmZzZXQ7dmVjNCBjMD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2K29mZnNldCk7dmVjNCBjMT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2LW9mZnNldCk7cmVzdWx0Kz0oYzArYzEpKmtlcm5lbFtpXS55O31nbF9GcmFnQ29sb3I9cmVzdWx0O1xuI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XG59YDtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLmdhdXNzaWFuLnZlcnRcbnZhciBjb252b2x1dGlvbl9nYXVzc2lhbl9kZWZhdWx0MiA9IGB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gdmVjMiBkaXJlY3Rpb247dW5pZm9ybSBmbG9hdCBzY2FsZTt2YXJ5aW5nIHZlYzIgdk9mZnNldDt2YXJ5aW5nIHZlYzIgdlV2O3ZvaWQgbWFpbigpe3ZPZmZzZXQ9ZGlyZWN0aW9uKnRleGVsU2l6ZSpzY2FsZTt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31gO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0dhdXNzaWFuQmx1ck1hdGVyaWFsLmpzXG52YXIgR2F1c3NpYW5CbHVyTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMjIge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBjb252b2x1dGlvbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMua2VybmVsU2l6ZT0zNV0gLSBUaGUga2VybmVsIHNpemUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGtlcm5lbFNpemUgPSAzNSB9ID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkdhdXNzaWFuQmx1ck1hdGVyaWFsXCIsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm01MShudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTUxKG5ldyBWZWN0b3IyMjgoKSksXG4gICAgICAgIGRpcmVjdGlvbjogbmV3IFVuaWZvcm01MShuZXcgVmVjdG9yMjI4KCkpLFxuICAgICAgICBrZXJuZWw6IG5ldyBVbmlmb3JtNTEobnVsbCksXG4gICAgICAgIHNjYWxlOiBuZXcgVW5pZm9ybTUxKDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcyMSxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGNvbnZvbHV0aW9uX2dhdXNzaWFuX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbnZvbHV0aW9uX2dhdXNzaWFuX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5fa2VybmVsU2l6ZSA9IDA7XG4gICAgdGhpcy5rZXJuZWxTaXplID0ga2VybmVsU2l6ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBrZXJuZWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9rZXJuZWxTaXplO1xuICB9XG4gIHNldCBrZXJuZWxTaXplKHZhbHVlKSB7XG4gICAgdGhpcy5fa2VybmVsU2l6ZSA9IHZhbHVlO1xuICAgIHRoaXMuZ2VuZXJhdGVLZXJuZWwodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBkaXJlY3Rpb24uXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kaXJlY3Rpb24udmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIGtlcm5lbCBzY2FsZS4gVmFsdWVzIGdyZWF0ZXIgdGhhbiAxLjAgbWF5IGludHJvZHVjZSBhcnRpZmFjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIEdhdXNzIGtlcm5lbC5cbiAgICpcbiAgICogQHBhcmFtIHtLZXJuZWxTaXplfSBrZXJuZWxTaXplIC0gVGhlIGtlcm5lbCBzaXplLiBTaG91bGQgYmUgYW4gb2RkIG51bWJlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdlbmVyYXRlS2VybmVsKGtlcm5lbFNpemUpIHtcbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgR2F1c3NLZXJuZWwoa2VybmVsU2l6ZSk7XG4gICAgY29uc3Qgc3RlcHMgPSBrZXJuZWwubGluZWFyU3RlcHM7XG4gICAgY29uc3Qga2VybmVsRGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkoc3RlcHMgKiAyKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBzdGVwczsgKytpKSB7XG4gICAgICBrZXJuZWxEYXRhW2orK10gPSBrZXJuZWwubGluZWFyT2Zmc2V0c1tpXTtcbiAgICAgIGtlcm5lbERhdGFbaisrXSA9IGtlcm5lbC5saW5lYXJXZWlnaHRzW2ldO1xuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLmtlcm5lbC52YWx1ZSA9IGtlcm5lbERhdGE7XG4gICAgdGhpcy5kZWZpbmVzLlNURVBTID0gc3RlcHMudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0JveEJsdXJQYXNzLmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzE2LCBTUkdCQ29sb3JTcGFjZSBhcyBTUkdCQ29sb3JTcGFjZTEzLCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUxMywgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQyMCB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIEJveEJsdXJQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYm94IGJsdXIgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMua2VybmVsU2l6ZT01XSAtIE11c3QgYmUgYW4gb2RkIG51bWJlci4gVGhlIHNpemVzIDMgYW5kIDUgdXNlIG9wdGltaXplZCBjb2RlIHBhdGhzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaXRlcmF0aW9ucz0xXSAtIFRoZSBhbW91bnQgb2YgdGltZXMgdGhlIGJsdXIgc2hvdWxkIGJlIGFwcGxpZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iaWxhdGVyYWw9ZmFsc2VdIC0gRW5hYmxlcyBvciBkaXNhYmxlcyBiaWxhdGVyYWwgYmx1cnJpbmcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MS4wXSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGtlcm5lbFNpemUgPSA1LFxuICAgIGl0ZXJhdGlvbnMgPSAxLFxuICAgIGJpbGF0ZXJhbCA9IGZhbHNlLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDEsXG4gICAgcmVzb2x1dGlvblggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWSA9IFJlc29sdXRpb24uQVVUT19TSVpFXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiQm94Qmx1clBhc3NcIik7XG4gICAgdGhpcy5uZWVkc0RlcHRoVGV4dHVyZSA9IGJpbGF0ZXJhbDtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQyMCgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5uYW1lID0gXCJCbHVyLlRhcmdldC5BXCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MjAoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUubmFtZSA9IFwiQmx1ci5UYXJnZXQuQlwiO1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsID0gbmV3IEJveEJsdXJNYXRlcmlhbCh7IGJpbGF0ZXJhbCwga2VybmVsU2l6ZSB9KTtcbiAgICB0aGlzLmNvcHlNYXRlcmlhbCA9IG5ldyBDb3B5TWF0ZXJpYWwoKTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgICB0aGlzLml0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTYpIHtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5kZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGJsdXIuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZTtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRBID0gdGhpcy5yZW5kZXJUYXJnZXRBO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldEIgPSB0aGlzLnJlbmRlclRhcmdldEI7XG4gICAgY29uc3QgYmx1ck1hdGVyaWFsID0gdGhpcy5ibHVyTWF0ZXJpYWw7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBibHVyTWF0ZXJpYWw7XG4gICAgbGV0IHByZXZpb3VzQnVmZmVyID0gaW5wdXRCdWZmZXI7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBNYXRoLm1heCh0aGlzLml0ZXJhdGlvbnMsIDEpOyBpIDwgbDsgKytpKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSAoaSAmIDEpID09PSAwID8gcmVuZGVyVGFyZ2V0QSA6IHJlbmRlclRhcmdldEI7XG4gICAgICBibHVyTWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSBwcmV2aW91c0J1ZmZlci50ZXh0dXJlO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGJ1ZmZlcik7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICBwcmV2aW91c0J1ZmZlciA9IGJ1ZmZlcjtcbiAgICB9XG4gICAgdGhpcy5jb3B5TWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSBwcmV2aW91c0J1ZmZlci50ZXh0dXJlO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gdGhpcy5jb3B5TWF0ZXJpYWw7XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogb3V0cHV0QnVmZmVyKTtcbiAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHcgPSByZXNvbHV0aW9uLndpZHRoLCBoID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgaWYgKHJlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmJsdXJNYXRlcmlhbC5tYXhWYXJ5aW5nVmVjdG9ycyA9IHJlbmRlcmVyLmNhcGFiaWxpdGllcy5tYXhWYXJ5aW5ncztcbiAgICB9XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUxMykge1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlbmRlcmVyICE9PSBudWxsICYmIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlMTMpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlMTM7XG4gICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTEzO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9EZXB0aFBpY2tpbmdQYXNzLmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzE4LCBGbG9hdFR5cGUgYXMgRmxvYXRUeXBlNiwgUkVWSVNJT04gYXMgUkVWSVNJT041LCBSR0JBRGVwdGhQYWNraW5nIGFzIFJHQkFEZXB0aFBhY2tpbmc1IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9wYXNzZXMvRGVwdGhDb3B5UGFzcy5qc1xuaW1wb3J0IHtcbiAgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmcxNyxcbiAgRmxvYXRUeXBlIGFzIEZsb2F0VHlwZTUsXG4gIE5lYXJlc3RGaWx0ZXIgYXMgTmVhcmVzdEZpbHRlcjcsXG4gIFJHQkFEZXB0aFBhY2tpbmcgYXMgUkdCQURlcHRoUGFja2luZzQsXG4gIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTE0LFxuICBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDIxXG59IGZyb20gXCJ0aHJlZVwiO1xudmFyIERlcHRoQ29weVBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBzYXZlIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbb3B0aW9ucy5kZXB0aFBhY2tpbmc9UkdCQURlcHRoUGFja2luZ10gLSBUaGUgb3V0cHV0IGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRlcHRoUGFja2luZyA9IFJHQkFEZXB0aFBhY2tpbmc0IH0gPSB7fSkge1xuICAgIHN1cGVyKFwiRGVwdGhDb3B5UGFzc1wiKTtcbiAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBEZXB0aENvcHlNYXRlcmlhbCgpO1xuICAgIG1hdGVyaWFsLm91dHB1dERlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgIHRoaXMubmVlZHNEZXB0aFRleHR1cmUgPSB0cnVlO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQyMSgxLCAxLCB7XG4gICAgICB0eXBlOiBkZXB0aFBhY2tpbmcgPT09IFJHQkFEZXB0aFBhY2tpbmc0ID8gVW5zaWduZWRCeXRlVHlwZTE0IDogRmxvYXRUeXBlNSxcbiAgICAgIG1pbkZpbHRlcjogTmVhcmVzdEZpbHRlcjcsXG4gICAgICBtYWdGaWx0ZXI6IE5lYXJlc3RGaWx0ZXI3LFxuICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJEZXB0aENvcHlQYXNzLlRhcmdldFwiO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb3V0cHV0IGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG91dHB1dCBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvdXRwdXQgZGVwdGggcGFja2luZy5cbiAgICpcbiAgICogQHR5cGUge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9XG4gICAqL1xuICBnZXQgZGVwdGhQYWNraW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5vdXRwdXREZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG91dHB1dCBkZXB0aCBwYWNraW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhQYWNraW5nIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgZ2V0RGVwdGhQYWNraW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5vdXRwdXREZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBzZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzE3KSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuaW5wdXREZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBkZXB0aCBmcm9tIGEgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogdGhpcy5yZW5kZXJUYXJnZXQpO1xuICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9EZXB0aFBpY2tpbmdQYXNzLmpzXG52YXIgdGhyZWVSZXZpc2lvbiA9IE51bWJlcihSRVZJU0lPTjUucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSk7XG52YXIgdW5wYWNrRG93bnNjYWxlID0gMjU1IC8gMjU2O1xudmFyIHVucGFja0ZhY3RvcnNMZWdhY3kgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgdW5wYWNrRG93bnNjYWxlIC8gMjU2ICoqIDMsXG4gIHVucGFja0Rvd25zY2FsZSAvIDI1NiAqKiAyLFxuICB1bnBhY2tEb3duc2NhbGUgLyAyNTYsXG4gIHVucGFja0Rvd25zY2FsZVxuXSk7XG52YXIgdW5wYWNrRmFjdG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICB1bnBhY2tEb3duc2NhbGUsXG4gIHVucGFja0Rvd25zY2FsZSAvIDI1NixcbiAgdW5wYWNrRG93bnNjYWxlIC8gMjU2ICoqIDIsXG4gIDEgLyAyNTYgKiogM1xuXSk7XG5mdW5jdGlvbiB1bnBhY2tSR0JBVG9EZXB0aChwYWNrZWREZXB0aCkge1xuICBjb25zdCBmID0gdGhyZWVSZXZpc2lvbiA+PSAxNjcgPyB1bnBhY2tGYWN0b3JzIDogdW5wYWNrRmFjdG9yc0xlZ2FjeTtcbiAgcmV0dXJuIChwYWNrZWREZXB0aFswXSAqIGZbMF0gKyBwYWNrZWREZXB0aFsxXSAqIGZbMV0gKyBwYWNrZWREZXB0aFsyXSAqIGZbMl0gKyBwYWNrZWREZXB0aFszXSAqIGZbM10pIC8gMjU1O1xufVxudmFyIERlcHRoUGlja2luZ1Bhc3MgPSBjbGFzcyBleHRlbmRzIERlcHRoQ29weVBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBwaWNraW5nIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbb3B0aW9ucy5kZXB0aFBhY2tpbmc9UkdCQURlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1vZGU9RGVwdGhDb3B5TW9kZS5TSU5HTEVdIC0gVGhlIGRlcHRoIGNvcHkgbW9kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGVwdGhQYWNraW5nID0gUkdCQURlcHRoUGFja2luZzUsIG1vZGUgPSBEZXB0aENvcHlNb2RlLlNJTkdMRSB9ID0ge30pIHtcbiAgICBpZiAoZGVwdGhQYWNraW5nICE9PSBSR0JBRGVwdGhQYWNraW5nNSAmJiBkZXB0aFBhY2tpbmcgIT09IEJhc2ljRGVwdGhQYWNraW5nMTgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVwdGggcGFja2luZzogJHtkZXB0aFBhY2tpbmd9YCk7XG4gICAgfVxuICAgIHN1cGVyKHsgZGVwdGhQYWNraW5nIH0pO1xuICAgIHRoaXMubmFtZSA9IFwiRGVwdGhQaWNraW5nUGFzc1wiO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMucGl4ZWxCdWZmZXIgPSBkZXB0aFBhY2tpbmcgPT09IFJHQkFEZXB0aFBhY2tpbmc1ID8gbmV3IFVpbnQ4QXJyYXkoNCkgOiBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkcyBkZXB0aCBhdCBhIHNwZWNpZmljIHNjcmVlbiBwb3NpdGlvbi5cbiAgICpcbiAgICogT25seSBvbmUgZGVwdGggdmFsdWUgY2FuIGJlIHBpY2tlZCBwZXIgZnJhbWUuIENhbGxpbmcgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgcGVyIGZyYW1lIHdpbGwgb3ZlcndyaXRlIHRoZVxuICAgKiBwaWNraW5nIGNvb3JkaW5hdGVzLiBVbnJlc29sdmVkIHByb21pc2VzIHdpbGwgYmUgYWJhbmRvbmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBuZGMgPSBuZXcgVmVjdG9yMygpO1xuICAgKiBjb25zdCBjbGllbnRSZWN0ID0gbXlWaWV3cG9ydC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICogY29uc3QgY2xpZW50WCA9IHBvaW50ZXJFdmVudC5jbGllbnRYIC0gY2xpZW50UmVjdC5sZWZ0O1xuICAgKiBjb25zdCBjbGllbnRZID0gcG9pbnRlckV2ZW50LmNsaWVudFkgLSBjbGllbnRSZWN0LnRvcDtcbiAgICogbmRjLnggPSAoY2xpZW50WCAvIG15Vmlld3BvcnQuY2xpZW50V2lkdGgpICogMi4wIC0gMS4wO1xuICAgKiBuZGMueSA9IC0oY2xpZW50WSAvIG15Vmlld3BvcnQuY2xpZW50SGVpZ2h0KSAqIDIuMCArIDEuMDtcbiAgICogY29uc3QgZGVwdGggPSBhd2FpdCBkZXB0aFBpY2tpbmdQYXNzLnJlYWREZXB0aChuZGMpO1xuICAgKiBuZGMueiA9IGRlcHRoICogMi4wIC0gMS4wO1xuICAgKlxuICAgKiBjb25zdCB3b3JsZFBvc2l0aW9uID0gbmRjLnVucHJvamVjdChjYW1lcmEpO1xuICAgKlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ8VmVjdG9yM30gbmRjIC0gTm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMuIE9ubHkgWCBhbmQgWSBhcmUgcmVsZXZhbnQuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TnVtYmVyPn0gQSBwcm9taXNlIHRoYXQgcmV0dXJucyB0aGUgZGVwdGggb24gdGhlIG5leHQgZnJhbWUuXG4gICAqL1xuICByZWFkRGVwdGgobmRjKSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwudGV4ZWxQb3NpdGlvbi5zZXQobmRjLnggKiAwLjUgKyAwLjUsIG5kYy55ICogMC41ICsgMC41KTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSByZXNvbHZlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgZGVwdGggYW5kIHJlc29sdmVzIGRlcHRoIHBpY2tpbmcgcHJvbWlzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gICAgY29uc3QgbW9kZSA9IG1hdGVyaWFsLm1vZGU7XG4gICAgaWYgKG1vZGUgPT09IERlcHRoQ29weU1vZGUuRlVMTCkge1xuICAgICAgc3VwZXIucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgICAgY29uc3QgcGl4ZWxCdWZmZXIgPSB0aGlzLnBpeGVsQnVmZmVyO1xuICAgICAgY29uc3QgcGFja2VkID0gcmVuZGVyVGFyZ2V0LnRleHR1cmUudHlwZSAhPT0gRmxvYXRUeXBlNjtcbiAgICAgIGxldCB4ID0gMCwgeSA9IDA7XG4gICAgICBpZiAobW9kZSA9PT0gRGVwdGhDb3B5TW9kZS5TSU5HTEUpIHtcbiAgICAgICAgc3VwZXIucmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRleGVsUG9zaXRpb24gPSBtYXRlcmlhbC50ZXhlbFBvc2l0aW9uO1xuICAgICAgICB4ID0gTWF0aC5yb3VuZCh0ZXhlbFBvc2l0aW9uLnggKiByZW5kZXJUYXJnZXQud2lkdGgpO1xuICAgICAgICB5ID0gTWF0aC5yb3VuZCh0ZXhlbFBvc2l0aW9uLnkgKiByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMocmVuZGVyVGFyZ2V0LCB4LCB5LCAxLCAxLCBwaXhlbEJ1ZmZlcik7XG4gICAgICB0aGlzLmNhbGxiYWNrKHBhY2tlZCA/IHVucGFja1JHQkFUb0RlcHRoKHBpeGVsQnVmZmVyKSA6IHBpeGVsQnVmZmVyWzBdKTtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwubW9kZSA9PT0gRGVwdGhDb3B5TW9kZS5GVUxMKSB7XG4gICAgICBzdXBlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9FZmZlY3RQYXNzLmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzE5LCBOb0NvbG9yU3BhY2UgYXMgTm9Db2xvclNwYWNlMiwgU1JHQkNvbG9yU3BhY2UgYXMgU1JHQkNvbG9yU3BhY2UxNCwgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlMTUgfSBmcm9tIFwidGhyZWVcIjtcbmZ1bmN0aW9uIHByZWZpeFN1YnN0cmluZ3MocHJlZml4LCBzdWJzdHJpbmdzLCBzdHJpbmdzKSB7XG4gIGZvciAoY29uc3Qgc3Vic3RyaW5nIG9mIHN1YnN0cmluZ3MpIHtcbiAgICBjb25zdCBwcmVmaXhlZCA9IFwiJDFcIiArIHByZWZpeCArIHN1YnN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN1YnN0cmluZy5zbGljZSgxKTtcbiAgICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKFwiKFteXFxcXC5dKShcXFxcYlwiICsgc3Vic3RyaW5nICsgXCJcXFxcYilcIiwgXCJnXCIpO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2Ygc3RyaW5ncy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChlbnRyeVsxXSAhPT0gbnVsbCkge1xuICAgICAgICBzdHJpbmdzLnNldChlbnRyeVswXSwgZW50cnlbMV0ucmVwbGFjZShyZWdFeHAsIHByZWZpeGVkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbnRlZ3JhdGVFZmZlY3QocHJlZml4LCBlZmZlY3QsIGRhdGEpIHtcbiAgbGV0IGZyYWdtZW50U2hhZGVyID0gZWZmZWN0LmdldEZyYWdtZW50U2hhZGVyKCk7XG4gIGxldCB2ZXJ0ZXhTaGFkZXIgPSBlZmZlY3QuZ2V0VmVydGV4U2hhZGVyKCk7XG4gIGNvbnN0IG1haW5JbWFnZUV4aXN0cyA9IGZyYWdtZW50U2hhZGVyICE9PSB2b2lkIDAgJiYgL21haW5JbWFnZS8udGVzdChmcmFnbWVudFNoYWRlcik7XG4gIGNvbnN0IG1haW5VdkV4aXN0cyA9IGZyYWdtZW50U2hhZGVyICE9PSB2b2lkIDAgJiYgL21haW5Vdi8udGVzdChmcmFnbWVudFNoYWRlcik7XG4gIGRhdGEuYXR0cmlidXRlcyB8PSBlZmZlY3QuZ2V0QXR0cmlidXRlcygpO1xuICBpZiAoZnJhZ21lbnRTaGFkZXIgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBmcmFnbWVudCBzaGFkZXIgKCR7ZWZmZWN0Lm5hbWV9KWApO1xuICB9IGVsc2UgaWYgKG1haW5VdkV4aXN0cyAmJiAoZGF0YS5hdHRyaWJ1dGVzICYgRWZmZWN0QXR0cmlidXRlLkNPTlZPTFVUSU9OKSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRWZmZWN0cyB0aGF0IHRyYW5zZm9ybSBVVnMgYXJlIGluY29tcGF0aWJsZSB3aXRoIGNvbnZvbHV0aW9uIGVmZmVjdHMgKCR7ZWZmZWN0Lm5hbWV9KWApO1xuICB9IGVsc2UgaWYgKCFtYWluSW1hZ2VFeGlzdHMgJiYgIW1haW5VdkV4aXN0cykge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgbWFpbkltYWdlIG9yIG1haW5VdiBmdW5jdGlvbiAoJHtlZmZlY3QubmFtZX0pYCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZnVuY3Rpb25SZWdFeHAgPSAvXFx3K1xccysoXFx3KylcXChbXFx3XFxzLF0qXFwpXFxzKnsvZztcbiAgICBjb25zdCBzaGFkZXJQYXJ0cyA9IGRhdGEuc2hhZGVyUGFydHM7XG4gICAgbGV0IGZyYWdtZW50SGVhZCA9IHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX0hFQUQpIHx8IFwiXCI7XG4gICAgbGV0IGZyYWdtZW50TWFpblV2ID0gc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9VVikgfHwgXCJcIjtcbiAgICBsZXQgZnJhZ21lbnRNYWluSW1hZ2UgPSBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX0lNQUdFKSB8fCBcIlwiO1xuICAgIGxldCB2ZXJ0ZXhIZWFkID0gc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX0hFQUQpIHx8IFwiXCI7XG4gICAgbGV0IHZlcnRleE1haW5TdXBwb3J0ID0gc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX01BSU5fU1VQUE9SVCkgfHwgXCJcIjtcbiAgICBjb25zdCB2YXJ5aW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgbmFtZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGlmIChtYWluVXZFeGlzdHMpIHtcbiAgICAgIGZyYWdtZW50TWFpblV2ICs9IGBcdCR7cHJlZml4fU1haW5VdihVVik7XG5gO1xuICAgICAgZGF0YS51dlRyYW5zZm9ybWF0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZlcnRleFNoYWRlciAhPT0gbnVsbCAmJiAvbWFpblN1cHBvcnQvLnRlc3QodmVydGV4U2hhZGVyKSkge1xuICAgICAgY29uc3QgbmVlZHNVdiA9IC9tYWluU3VwcG9ydCAqXFwoW1xcd1xcc10qP3V2XFxzKj9cXCkvLnRlc3QodmVydGV4U2hhZGVyKTtcbiAgICAgIHZlcnRleE1haW5TdXBwb3J0ICs9IGBcdCR7cHJlZml4fU1haW5TdXBwb3J0KGA7XG4gICAgICB2ZXJ0ZXhNYWluU3VwcG9ydCArPSBuZWVkc1V2ID8gXCJ2VXYpO1xcblwiIDogXCIpO1xcblwiO1xuICAgICAgZm9yIChjb25zdCBtMiBvZiB2ZXJ0ZXhTaGFkZXIubWF0Y2hBbGwoLyg/OnZhcnlpbmdcXHMrXFx3K1xccysoW1xcU1xcc10qPyk7KS9nKSkge1xuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgbTJbMV0uc3BsaXQoL1xccyosXFxzKi8pKSB7XG4gICAgICAgICAgZGF0YS52YXJ5aW5ncy5hZGQobik7XG4gICAgICAgICAgdmFyeWluZ3MuYWRkKG4pO1xuICAgICAgICAgIG5hbWVzLmFkZChuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBtMiBvZiB2ZXJ0ZXhTaGFkZXIubWF0Y2hBbGwoZnVuY3Rpb25SZWdFeHApKSB7XG4gICAgICAgIG5hbWVzLmFkZChtMlsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgbTIgb2YgZnJhZ21lbnRTaGFkZXIubWF0Y2hBbGwoZnVuY3Rpb25SZWdFeHApKSB7XG4gICAgICBuYW1lcy5hZGQobTJbMV0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGQgb2YgZWZmZWN0LmRlZmluZXMua2V5cygpKSB7XG4gICAgICBuYW1lcy5hZGQoZC5yZXBsYWNlKC9cXChbXFx3XFxzLF0qXFwpL2csIFwiXCIpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB1IG9mIGVmZmVjdC51bmlmb3Jtcy5rZXlzKCkpIHtcbiAgICAgIG5hbWVzLmFkZCh1KTtcbiAgICB9XG4gICAgbmFtZXMuZGVsZXRlKFwid2hpbGVcIik7XG4gICAgbmFtZXMuZGVsZXRlKFwiZm9yXCIpO1xuICAgIG5hbWVzLmRlbGV0ZShcImlmXCIpO1xuICAgIGVmZmVjdC51bmlmb3Jtcy5mb3JFYWNoKCh2YWwsIGtleSkgPT4gZGF0YS51bmlmb3Jtcy5zZXQocHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpLCB2YWwpKTtcbiAgICBlZmZlY3QuZGVmaW5lcy5mb3JFYWNoKCh2YWwsIGtleSkgPT4gZGF0YS5kZWZpbmVzLnNldChwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSksIHZhbCkpO1xuICAgIGNvbnN0IHNoYWRlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW1wiZnJhZ21lbnRcIiwgZnJhZ21lbnRTaGFkZXJdLCBbXCJ2ZXJ0ZXhcIiwgdmVydGV4U2hhZGVyXV0pO1xuICAgIHByZWZpeFN1YnN0cmluZ3MocHJlZml4LCBuYW1lcywgZGF0YS5kZWZpbmVzKTtcbiAgICBwcmVmaXhTdWJzdHJpbmdzKHByZWZpeCwgbmFtZXMsIHNoYWRlcnMpO1xuICAgIGZyYWdtZW50U2hhZGVyID0gc2hhZGVycy5nZXQoXCJmcmFnbWVudFwiKTtcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBzaGFkZXJzLmdldChcInZlcnRleFwiKTtcbiAgICBjb25zdCBibGVuZE1vZGUgPSBlZmZlY3QuYmxlbmRNb2RlO1xuICAgIGRhdGEuYmxlbmRNb2Rlcy5zZXQoYmxlbmRNb2RlLmJsZW5kRnVuY3Rpb24sIGJsZW5kTW9kZSk7XG4gICAgaWYgKG1haW5JbWFnZUV4aXN0cykge1xuICAgICAgaWYgKGVmZmVjdC5pbnB1dENvbG9yU3BhY2UgIT09IG51bGwgJiYgZWZmZWN0LmlucHV0Q29sb3JTcGFjZSAhPT0gZGF0YS5jb2xvclNwYWNlKSB7XG4gICAgICAgIGZyYWdtZW50TWFpbkltYWdlICs9IGVmZmVjdC5pbnB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlMTQgPyBcImNvbG9yMCA9IHNSR0JUcmFuc2Zlck9FVEYoY29sb3IwKTtcXG5cdFwiIDogXCJjb2xvcjAgPSBzUkdCVG9MaW5lYXIoY29sb3IwKTtcXG5cdFwiO1xuICAgICAgfVxuICAgICAgaWYgKGVmZmVjdC5vdXRwdXRDb2xvclNwYWNlICE9PSBOb0NvbG9yU3BhY2UyKSB7XG4gICAgICAgIGRhdGEuY29sb3JTcGFjZSA9IGVmZmVjdC5vdXRwdXRDb2xvclNwYWNlO1xuICAgICAgfSBlbHNlIGlmIChlZmZlY3QuaW5wdXRDb2xvclNwYWNlICE9PSBudWxsKSB7XG4gICAgICAgIGRhdGEuY29sb3JTcGFjZSA9IGVmZmVjdC5pbnB1dENvbG9yU3BhY2U7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXB0aFBhcmFtUmVnRXhwID0gL01haW5JbWFnZSAqXFwoW1xcd1xccyxdKj9kZXB0aFtcXHdcXHMsXSo/XFwpLztcbiAgICAgIGZyYWdtZW50TWFpbkltYWdlICs9IGAke3ByZWZpeH1NYWluSW1hZ2UoY29sb3IwLCBVViwgYDtcbiAgICAgIGlmICgoZGF0YS5hdHRyaWJ1dGVzICYgRWZmZWN0QXR0cmlidXRlLkRFUFRIKSAhPT0gMCAmJiBkZXB0aFBhcmFtUmVnRXhwLnRlc3QoZnJhZ21lbnRTaGFkZXIpKSB7XG4gICAgICAgIGZyYWdtZW50TWFpbkltYWdlICs9IFwiZGVwdGgsIFwiO1xuICAgICAgICBkYXRhLnJlYWREZXB0aCA9IHRydWU7XG4gICAgICB9XG4gICAgICBmcmFnbWVudE1haW5JbWFnZSArPSBcImNvbG9yMSk7XFxuXHRcIjtcbiAgICAgIGNvbnN0IGJsZW5kT3BhY2l0eSA9IHByZWZpeCArIFwiQmxlbmRPcGFjaXR5XCI7XG4gICAgICBkYXRhLnVuaWZvcm1zLnNldChibGVuZE9wYWNpdHksIGJsZW5kTW9kZS5vcGFjaXR5KTtcbiAgICAgIGZyYWdtZW50TWFpbkltYWdlICs9IGBjb2xvcjAgPSBibGVuZCR7YmxlbmRNb2RlLmJsZW5kRnVuY3Rpb259KGNvbG9yMCwgY29sb3IxLCAke2JsZW5kT3BhY2l0eX0pO1xuXG5cdGA7XG4gICAgICBmcmFnbWVudEhlYWQgKz0gYHVuaWZvcm0gZmxvYXQgJHtibGVuZE9wYWNpdHl9O1xuXG5gO1xuICAgIH1cbiAgICBmcmFnbWVudEhlYWQgKz0gZnJhZ21lbnRTaGFkZXIgKyBcIlxcblwiO1xuICAgIGlmICh2ZXJ0ZXhTaGFkZXIgIT09IG51bGwpIHtcbiAgICAgIHZlcnRleEhlYWQgKz0gdmVydGV4U2hhZGVyICsgXCJcXG5cIjtcbiAgICB9XG4gICAgc2hhZGVyUGFydHMuc2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCwgZnJhZ21lbnRIZWFkKTtcbiAgICBzaGFkZXJQYXJ0cy5zZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX1VWLCBmcmFnbWVudE1haW5Vdik7XG4gICAgc2hhZGVyUGFydHMuc2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9JTUFHRSwgZnJhZ21lbnRNYWluSW1hZ2UpO1xuICAgIHNoYWRlclBhcnRzLnNldChFZmZlY3RTaGFkZXJTZWN0aW9uLlZFUlRFWF9IRUFELCB2ZXJ0ZXhIZWFkKTtcbiAgICBzaGFkZXJQYXJ0cy5zZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfTUFJTl9TVVBQT1JULCB2ZXJ0ZXhNYWluU3VwcG9ydCk7XG4gICAgaWYgKGVmZmVjdC5leHRlbnNpb25zICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbiBvZiBlZmZlY3QuZXh0ZW5zaW9ucykge1xuICAgICAgICBkYXRhLmV4dGVuc2lvbnMuYWRkKGV4dGVuc2lvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG52YXIgRWZmZWN0UGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGVmZmVjdCBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0gey4uLkVmZmVjdH0gZWZmZWN0cyAtIFRoZSBlZmZlY3RzIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBieSB0aGlzIHBhc3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYW1lcmEsIC4uLmVmZmVjdHMpIHtcbiAgICBzdXBlcihcIkVmZmVjdFBhc3NcIik7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBuZXcgRWZmZWN0TWF0ZXJpYWwobnVsbCwgbnVsbCwgbnVsbCwgY2FtZXJhKTtcbiAgICB0aGlzLmxpc3RlbmVyID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICB0aGlzLnNldEVmZmVjdHMoZWZmZWN0cyk7XG4gICAgdGhpcy5za2lwUmVuZGVyaW5nID0gZmFsc2U7XG4gICAgdGhpcy5taW5UaW1lID0gMTtcbiAgICB0aGlzLm1heFRpbWUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy50aW1lU2NhbGUgPSAxO1xuICB9XG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdC5tYWluU2NlbmUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3ModmFsdWUpO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0Lm1haW5DYW1lcmEgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgcGFzcyBlbmNvZGVzIGl0cyBvdXRwdXQgd2hlbiByZW5kZXJpbmcgdG8gc2NyZWVuLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZ1bGxzY3JlZW5NYXRlcmlhbC5lbmNvZGVPdXRwdXQgaW5zdGVhZC5cbiAgICovXG4gIGdldCBlbmNvZGVPdXRwdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmVuY29kZU91dHB1dDtcbiAgfVxuICBzZXQgZW5jb2RlT3V0cHV0KHZhbHVlKSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZW5jb2RlT3V0cHV0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRpdGhlcmluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBkaXRoZXJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRpdGhlcmluZztcbiAgfVxuICBzZXQgZGl0aGVyaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgICBtYXRlcmlhbC5kaXRoZXJpbmcgPSB2YWx1ZTtcbiAgICBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGVmZmVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RWZmZWN0W119IGVmZmVjdHMgLSBUaGUgZWZmZWN0cy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2V0RWZmZWN0cyhlZmZlY3RzKSB7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBlZmZlY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG4gICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cy5zb3J0KChhLCBiKSA9PiBiLmF0dHJpYnV0ZXMgLSBhLmF0dHJpYnV0ZXMpO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5saXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb21wb3VuZCBzaGFkZXIgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHVwZGF0ZU1hdGVyaWFsKCkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgRWZmZWN0U2hhZGVyRGF0YSgpO1xuICAgIGxldCBpZCA9IDA7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBpZiAoZWZmZWN0LmJsZW5kTW9kZS5ibGVuZEZ1bmN0aW9uID09PSBCbGVuZEZ1bmN0aW9uLkRTVCkge1xuICAgICAgICBkYXRhLmF0dHJpYnV0ZXMgfD0gZWZmZWN0LmdldEF0dHJpYnV0ZXMoKSAmIEVmZmVjdEF0dHJpYnV0ZS5ERVBUSDtcbiAgICAgIH0gZWxzZSBpZiAoKGRhdGEuYXR0cmlidXRlcyAmIGVmZmVjdC5nZXRBdHRyaWJ1dGVzKCkgJiBFZmZlY3RBdHRyaWJ1dGUuQ09OVk9MVVRJT04pICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udm9sdXRpb24gZWZmZWN0cyBjYW5ub3QgYmUgbWVyZ2VkICgke2VmZmVjdC5uYW1lfSlgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVncmF0ZUVmZmVjdChcImVcIiArIGlkKyssIGVmZmVjdCwgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBmcmFnbWVudEhlYWQgPSBkYXRhLnNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX0hFQUQpO1xuICAgIGxldCBmcmFnbWVudE1haW5JbWFnZSA9IGRhdGEuc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9JTUFHRSk7XG4gICAgbGV0IGZyYWdtZW50TWFpblV2ID0gZGF0YS5zaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX1VWKTtcbiAgICBjb25zdCBibGVuZFJlZ0V4cCA9IC9cXGJibGVuZFxcYi9nO1xuICAgIGZvciAoY29uc3QgYmxlbmRNb2RlIG9mIGRhdGEuYmxlbmRNb2Rlcy52YWx1ZXMoKSkge1xuICAgICAgZnJhZ21lbnRIZWFkICs9IGJsZW5kTW9kZS5nZXRTaGFkZXJDb2RlKCkucmVwbGFjZShibGVuZFJlZ0V4cCwgYGJsZW5kJHtibGVuZE1vZGUuYmxlbmRGdW5jdGlvbn1gKSArIFwiXFxuXCI7XG4gICAgfVxuICAgIGlmICgoZGF0YS5hdHRyaWJ1dGVzICYgRWZmZWN0QXR0cmlidXRlLkRFUFRIKSAhPT0gMCkge1xuICAgICAgaWYgKGRhdGEucmVhZERlcHRoKSB7XG4gICAgICAgIGZyYWdtZW50TWFpbkltYWdlID0gXCJmbG9hdCBkZXB0aCA9IHJlYWREZXB0aChVVik7XFxuXFxuXHRcIiArIGZyYWdtZW50TWFpbkltYWdlO1xuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc0RlcHRoVGV4dHVyZSA9IHRoaXMuZ2V0RGVwdGhUZXh0dXJlKCkgPT09IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmVlZHNEZXB0aFRleHR1cmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UxNCkge1xuICAgICAgZnJhZ21lbnRNYWluSW1hZ2UgKz0gXCJjb2xvcjAgPSBzUkdCVG9MaW5lYXIoY29sb3IwKTtcXG5cdFwiO1xuICAgIH1cbiAgICBpZiAoZGF0YS51dlRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICBmcmFnbWVudE1haW5VdiA9IFwidmVjMiB0cmFuc2Zvcm1lZFV2ID0gdlV2O1xcblwiICsgZnJhZ21lbnRNYWluVXY7XG4gICAgICBkYXRhLmRlZmluZXMuc2V0KFwiVVZcIiwgXCJ0cmFuc2Zvcm1lZFV2XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLmRlZmluZXMuc2V0KFwiVVZcIiwgXCJ2VXZcIik7XG4gICAgfVxuICAgIGRhdGEuc2hhZGVyUGFydHMuc2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCwgZnJhZ21lbnRIZWFkKTtcbiAgICBkYXRhLnNoYWRlclBhcnRzLnNldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fSU1BR0UsIGZyYWdtZW50TWFpbkltYWdlKTtcbiAgICBkYXRhLnNoYWRlclBhcnRzLnNldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fVVYsIGZyYWdtZW50TWFpblV2KTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBkYXRhLnNoYWRlclBhcnRzKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgZGF0YS5zaGFkZXJQYXJ0cy5zZXQoa2V5LCB2YWx1ZS50cmltKCkucmVwbGFjZSgvXiMvLCBcIlxcbiNcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNraXBSZW5kZXJpbmcgPSBpZCA9PT0gMDtcbiAgICB0aGlzLm5lZWRzU3dhcCA9ICF0aGlzLnNraXBSZW5kZXJpbmc7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2V0U2hhZGVyRGF0YShkYXRhKTtcbiAgfVxuICAvKipcbiAgICogUmVidWlsZHMgdGhlIHNoYWRlciBtYXRlcmlhbC5cbiAgICovXG4gIHJlY29tcGlsZSgpIHtcbiAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIGN1cnJlbnQgZGVwdGggdGV4dHVyZSwgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lLlxuICAgKi9cbiAgZ2V0RGVwdGhUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZXB0aEJ1ZmZlcjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTkpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBlZmZlY3Quc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBlZmZlY3QudXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNraXBSZW5kZXJpbmcgfHwgdGhpcy5yZW5kZXJUb1NjcmVlbikge1xuICAgICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgICAgIG1hdGVyaWFsLmlucHV0QnVmZmVyID0gaW5wdXRCdWZmZXIudGV4dHVyZTtcbiAgICAgIG1hdGVyaWFsLnRpbWUgKz0gZGVsdGFUaW1lICogdGhpcy50aW1lU2NhbGU7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiBvdXRwdXRCdWZmZXIpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0LmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsKCk7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwICYmIGZyYW1lQnVmZmVyVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTE1KSB7XG4gICAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGRpc3Bvc2FibGUgb2JqZWN0cy5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5saXN0ZW5lcik7XG4gICAgICBlZmZlY3QuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gQW4gZXZlbnQuXG4gICAqL1xuICBoYW5kbGVFdmVudChldmVudCkge1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSBcImNoYW5nZVwiOlxuICAgICAgICB0aGlzLnJlY29tcGlsZSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvR2F1c3NpYW5CbHVyUGFzcy5qc1xuaW1wb3J0IHsgU1JHQkNvbG9yU3BhY2UgYXMgU1JHQkNvbG9yU3BhY2UxNSwgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlMTYsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MjIgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBHYXVzc2lhbkJsdXJQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgR2F1c3NpYW4gYmx1ciBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5rZXJuZWxTaXplPTM1XSAtIFRoZSBrZXJuZWwgc2l6ZS4gU2hvdWxkIGJlIGFuIG9kZCBudW1iZXIgaW4gdGhlIHJhbmdlIFszLCAxMDIwXS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLml0ZXJhdGlvbnM9MV0gLSBUaGUgYW1vdW50IG9mIHRpbWVzIHRoZSBibHVyIHNob3VsZCBiZSBhcHBsaWVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTEuMF0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBrZXJuZWxTaXplID0gMzUsXG4gICAgaXRlcmF0aW9ucyA9IDEsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMSxcbiAgICByZXNvbHV0aW9uWCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25ZID0gUmVzb2x1dGlvbi5BVVRPX1NJWkVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJHYXVzc2lhbkJsdXJQYXNzXCIpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QSA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDIyKDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QS50ZXh0dXJlLm5hbWUgPSBcIkJsdXIuVGFyZ2V0LkFcIjtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIgPSB0aGlzLnJlbmRlclRhcmdldEEuY2xvbmUoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS5uYW1lID0gXCJCbHVyLlRhcmdldC5CXCI7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwgPSBuZXcgR2F1c3NpYW5CbHVyTWF0ZXJpYWwoeyBrZXJuZWxTaXplIH0pO1xuICAgIHRoaXMuY29weU1hdGVyaWFsID0gbmV3IENvcHlNYXRlcmlhbCgpO1xuICAgIHRoaXMuY29weU1hdGVyaWFsLmlucHV0QnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmU7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbiA9IG5ldyBSZXNvbHV0aW9uKHRoaXMsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwgcmVzb2x1dGlvblNjYWxlKTtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gICAgdGhpcy5pdGVyYXRpb25zID0gaXRlcmF0aW9ucztcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYmx1ci5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldEEgPSB0aGlzLnJlbmRlclRhcmdldEE7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0QiA9IHRoaXMucmVuZGVyVGFyZ2V0QjtcbiAgICBjb25zdCBibHVyTWF0ZXJpYWwgPSB0aGlzLmJsdXJNYXRlcmlhbDtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IGJsdXJNYXRlcmlhbDtcbiAgICBsZXQgcHJldmlvdXNCdWZmZXIgPSBpbnB1dEJ1ZmZlcjtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IE1hdGgubWF4KHRoaXMuaXRlcmF0aW9ucywgMSk7IGkgPCBsOyArK2kpIHtcbiAgICAgIGJsdXJNYXRlcmlhbC5kaXJlY3Rpb24uc2V0KDEsIDApO1xuICAgICAgYmx1ck1hdGVyaWFsLmlucHV0QnVmZmVyID0gcHJldmlvdXNCdWZmZXIudGV4dHVyZTtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXRBKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIGJsdXJNYXRlcmlhbC5kaXJlY3Rpb24uc2V0KDAsIDEpO1xuICAgICAgYmx1ck1hdGVyaWFsLmlucHV0QnVmZmVyID0gcmVuZGVyVGFyZ2V0QS50ZXh0dXJlO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldEIpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgaWYgKGkgPT09IDAgJiYgbCA+IDEpIHtcbiAgICAgICAgcHJldmlvdXNCdWZmZXIgPSByZW5kZXJUYXJnZXRCO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IHRoaXMuY29weU1hdGVyaWFsO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IG91dHB1dEJ1ZmZlcik7XG4gICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB3ID0gcmVzb2x1dGlvbi53aWR0aCwgaCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QS5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Qi5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlMTYpIHtcbiAgICAgICAgdGhpcy5ibHVyTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgICAgICB0aGlzLmNvcHlNYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlbmRlcmVyICE9PSBudWxsICYmIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlMTUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlMTU7XG4gICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTE1O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9MYW1iZGFQYXNzLmpzXG52YXIgTGFtYmRhUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGxhbWJkYSBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIC0gQSBmdW5jdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGYpIHtcbiAgICBzdXBlcihcIkxhbWJkYVBhc3NcIiwgbnVsbCwgbnVsbCk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLmYgPSBmO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIHRoaXMuZigpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL05vcm1hbFBhc3MuanNcbmltcG9ydCB7IENvbG9yIGFzIENvbG9yMTAsIE1lc2hOb3JtYWxNYXRlcmlhbCwgTmVhcmVzdEZpbHRlciBhcyBOZWFyZXN0RmlsdGVyOCwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQyMyB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIE5vcm1hbFBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBub3JtYWwgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgc2NlbmUgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYSB0byB1c2UgdG8gcmVuZGVyIHRoZSBzY2VuZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBbb3B0aW9ucy5yZW5kZXJUYXJnZXRdIC0gQSBjdXN0b20gcmVuZGVyIHRhcmdldC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0xLjBdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNjZW5lLCBjYW1lcmEsIHtcbiAgICByZW5kZXJUYXJnZXQsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMSxcbiAgICB3aWR0aCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIGhlaWdodCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25YID0gd2lkdGgsXG4gICAgcmVzb2x1dGlvblkgPSBoZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJOb3JtYWxQYXNzXCIpO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3Moc2NlbmUsIGNhbWVyYSwgbmV3IE1lc2hOb3JtYWxNYXRlcmlhbCgpKTtcbiAgICBjb25zdCByZW5kZXJQYXNzID0gdGhpcy5yZW5kZXJQYXNzO1xuICAgIHJlbmRlclBhc3MuaWdub3JlQmFja2dyb3VuZCA9IHRydWU7XG4gICAgcmVuZGVyUGFzcy5za2lwU2hhZG93TWFwVXBkYXRlID0gdHJ1ZTtcbiAgICBjb25zdCBjbGVhclBhc3MgPSByZW5kZXJQYXNzLmdldENsZWFyUGFzcygpO1xuICAgIGNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQ29sb3IgPSBuZXcgQ29sb3IxMCg3ODI5NTAzKTtcbiAgICBjbGVhclBhc3Mub3ZlcnJpZGVDbGVhckFscGhhID0gMTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcbiAgICBpZiAodGhpcy5yZW5kZXJUYXJnZXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQyMygxLCAxLCB7XG4gICAgICAgIG1pbkZpbHRlcjogTmVhcmVzdEZpbHRlcjgsXG4gICAgICAgIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlcjhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJOb3JtYWxQYXNzLlRhcmdldFwiO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgfVxuICBzZXQgbWFpblNjZW5lKHZhbHVlKSB7XG4gICAgdGhpcy5yZW5kZXJQYXNzLm1haW5TY2VuZSA9IHZhbHVlO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5yZW5kZXJQYXNzLm1haW5DYW1lcmEgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG5vcm1hbCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbm9ybWFsIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7UmVzb2x1dGlvbn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24ucHJlZmVycmVkV2lkdGggb3IgcmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgaW5zdGVhZC5cbiAgICovXG4gIGdldFJlc29sdXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgbmV3IHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uLnByZWZlcnJlZFdpZHRoIG9yIHJlc29sdXRpb24ucHJlZmVycmVkSGVpZ2h0IGluc3RlYWQuXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2NhbGUgPSBzY2FsZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc2NlbmUgbm9ybWFscy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB0aGlzLnJlbmRlclRhcmdldDtcbiAgICB0aGlzLnJlbmRlclBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXQsIHJlbmRlclRhcmdldCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUocmVzb2x1dGlvbi53aWR0aCwgcmVzb2x1dGlvbi5oZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvdGV4dHVyZXMvbHV0L1RldHJhaGVkcmFsVXBzY2FsZXIuanNcbnZhciBQID0gW1xuICBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICBuZXcgRmxvYXQzMkFycmF5KDMpXG5dO1xudmFyIEMgPSBbXG4gIG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gIG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gIG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gIG5ldyBGbG9hdDMyQXJyYXkoMylcbl07XG52YXIgVCA9IFtcbiAgW1xuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDFdKVxuICBdLFxuICBbXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAxXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMV0pXG4gIF0sXG4gIFtcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMV0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDFdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxXSlcbiAgXSxcbiAgW1xuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDFdKVxuICBdLFxuICBbXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAxXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMV0pXG4gIF0sXG4gIFtcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMV0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDFdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxXSlcbiAgXVxuXTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVRldHJhaGVkcm9uVm9sdW1lKGEsIGIsIGMyLCBkKSB7XG4gIGNvbnN0IGJjWCA9IGMyWzBdIC0gYlswXTtcbiAgY29uc3QgYmNZID0gYzJbMV0gLSBiWzFdO1xuICBjb25zdCBiY1ogPSBjMlsyXSAtIGJbMl07XG4gIGNvbnN0IGJhWCA9IGFbMF0gLSBiWzBdO1xuICBjb25zdCBiYVkgPSBhWzFdIC0gYlsxXTtcbiAgY29uc3QgYmFaID0gYVsyXSAtIGJbMl07XG4gIGNvbnN0IGNyb3NzWCA9IGJjWSAqIGJhWiAtIGJjWiAqIGJhWTtcbiAgY29uc3QgY3Jvc3NZID0gYmNaICogYmFYIC0gYmNYICogYmFaO1xuICBjb25zdCBjcm9zc1ogPSBiY1ggKiBiYVkgLSBiY1kgKiBiYVg7XG4gIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydChjcm9zc1ggKiBjcm9zc1ggKyBjcm9zc1kgKiBjcm9zc1kgKyBjcm9zc1ogKiBjcm9zc1opO1xuICBjb25zdCB0cmlhbmdsZUFyZWEgPSBsZW5ndGggKiAwLjU7XG4gIGNvbnN0IG5vcm1hbFggPSBjcm9zc1ggLyBsZW5ndGg7XG4gIGNvbnN0IG5vcm1hbFkgPSBjcm9zc1kgLyBsZW5ndGg7XG4gIGNvbnN0IG5vcm1hbFogPSBjcm9zc1ogLyBsZW5ndGg7XG4gIGNvbnN0IGNvbnN0YW50ID0gLShhWzBdICogbm9ybWFsWCArIGFbMV0gKiBub3JtYWxZICsgYVsyXSAqIG5vcm1hbFopO1xuICBjb25zdCBkb3QgPSBkWzBdICogbm9ybWFsWCArIGRbMV0gKiBub3JtYWxZICsgZFsyXSAqIG5vcm1hbFo7XG4gIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKGRvdCArIGNvbnN0YW50KTtcbiAgcmV0dXJuIGhlaWdodCAqIHRyaWFuZ2xlQXJlYSAvIDM7XG59XG5mdW5jdGlvbiBzYW1wbGUoZGF0YSwgc2l6ZSwgeCwgeSwgeiwgY29sb3IyKSB7XG4gIGNvbnN0IGk0ID0gKHggKyB5ICogc2l6ZSArIHogKiBzaXplICogc2l6ZSkgKiA0O1xuICBjb2xvcjJbMF0gPSBkYXRhW2k0ICsgMF07XG4gIGNvbG9yMlsxXSA9IGRhdGFbaTQgKyAxXTtcbiAgY29sb3IyWzJdID0gZGF0YVtpNCArIDJdO1xufVxuZnVuY3Rpb24gdGV0cmFoZWRyYWxTYW1wbGUoZGF0YSwgc2l6ZSwgdSwgdjMsIHcsIGNvbG9yMikge1xuICBjb25zdCBweCA9IHUgKiAoc2l6ZSAtIDEpO1xuICBjb25zdCBweSA9IHYzICogKHNpemUgLSAxKTtcbiAgY29uc3QgcHogPSB3ICogKHNpemUgLSAxKTtcbiAgY29uc3QgbWluWCA9IE1hdGguZmxvb3IocHgpO1xuICBjb25zdCBtaW5ZID0gTWF0aC5mbG9vcihweSk7XG4gIGNvbnN0IG1pblogPSBNYXRoLmZsb29yKHB6KTtcbiAgY29uc3QgbWF4WCA9IE1hdGguY2VpbChweCk7XG4gIGNvbnN0IG1heFkgPSBNYXRoLmNlaWwocHkpO1xuICBjb25zdCBtYXhaID0gTWF0aC5jZWlsKHB6KTtcbiAgY29uc3Qgc3UgPSBweCAtIG1pblg7XG4gIGNvbnN0IHN2ID0gcHkgLSBtaW5ZO1xuICBjb25zdCBzdyA9IHB6IC0gbWluWjtcbiAgaWYgKG1pblggPT09IHB4ICYmIG1pblkgPT09IHB5ICYmIG1pblogPT09IHB6KSB7XG4gICAgc2FtcGxlKGRhdGEsIHNpemUsIHB4LCBweSwgcHosIGNvbG9yMik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHZlcnRpY2VzO1xuICAgIGlmIChzdSA+PSBzdiAmJiBzdiA+PSBzdykge1xuICAgICAgdmVydGljZXMgPSBUWzBdO1xuICAgIH0gZWxzZSBpZiAoc3UgPj0gc3cgJiYgc3cgPj0gc3YpIHtcbiAgICAgIHZlcnRpY2VzID0gVFsxXTtcbiAgICB9IGVsc2UgaWYgKHN3ID49IHN1ICYmIHN1ID49IHN2KSB7XG4gICAgICB2ZXJ0aWNlcyA9IFRbMl07XG4gICAgfSBlbHNlIGlmIChzdiA+PSBzdSAmJiBzdSA+PSBzdykge1xuICAgICAgdmVydGljZXMgPSBUWzNdO1xuICAgIH0gZWxzZSBpZiAoc3YgPj0gc3cgJiYgc3cgPj0gc3UpIHtcbiAgICAgIHZlcnRpY2VzID0gVFs0XTtcbiAgICB9IGVsc2UgaWYgKHN3ID49IHN2ICYmIHN2ID49IHN1KSB7XG4gICAgICB2ZXJ0aWNlcyA9IFRbNV07XG4gICAgfVxuICAgIGNvbnN0IFtQMCwgUDEsIFAyLCBQM10gPSB2ZXJ0aWNlcztcbiAgICBjb25zdCBjb29yZHMgPSBQWzBdO1xuICAgIGNvb3Jkc1swXSA9IHN1O1xuICAgIGNvb3Jkc1sxXSA9IHN2O1xuICAgIGNvb3Jkc1syXSA9IHN3O1xuICAgIGNvbnN0IHRtcCA9IFBbMV07XG4gICAgY29uc3QgZGlmZlggPSBtYXhYIC0gbWluWDtcbiAgICBjb25zdCBkaWZmWSA9IG1heFkgLSBtaW5ZO1xuICAgIGNvbnN0IGRpZmZaID0gbWF4WiAtIG1pblo7XG4gICAgdG1wWzBdID0gZGlmZlggKiBQMFswXSArIG1pblg7XG4gICAgdG1wWzFdID0gZGlmZlkgKiBQMFsxXSArIG1pblk7XG4gICAgdG1wWzJdID0gZGlmZlogKiBQMFsyXSArIG1pblo7XG4gICAgc2FtcGxlKGRhdGEsIHNpemUsIHRtcFswXSwgdG1wWzFdLCB0bXBbMl0sIENbMF0pO1xuICAgIHRtcFswXSA9IGRpZmZYICogUDFbMF0gKyBtaW5YO1xuICAgIHRtcFsxXSA9IGRpZmZZICogUDFbMV0gKyBtaW5ZO1xuICAgIHRtcFsyXSA9IGRpZmZaICogUDFbMl0gKyBtaW5aO1xuICAgIHNhbXBsZShkYXRhLCBzaXplLCB0bXBbMF0sIHRtcFsxXSwgdG1wWzJdLCBDWzFdKTtcbiAgICB0bXBbMF0gPSBkaWZmWCAqIFAyWzBdICsgbWluWDtcbiAgICB0bXBbMV0gPSBkaWZmWSAqIFAyWzFdICsgbWluWTtcbiAgICB0bXBbMl0gPSBkaWZmWiAqIFAyWzJdICsgbWluWjtcbiAgICBzYW1wbGUoZGF0YSwgc2l6ZSwgdG1wWzBdLCB0bXBbMV0sIHRtcFsyXSwgQ1syXSk7XG4gICAgdG1wWzBdID0gZGlmZlggKiBQM1swXSArIG1pblg7XG4gICAgdG1wWzFdID0gZGlmZlkgKiBQM1sxXSArIG1pblk7XG4gICAgdG1wWzJdID0gZGlmZlogKiBQM1syXSArIG1pblo7XG4gICAgc2FtcGxlKGRhdGEsIHNpemUsIHRtcFswXSwgdG1wWzFdLCB0bXBbMl0sIENbM10pO1xuICAgIGNvbnN0IFYwID0gY2FsY3VsYXRlVGV0cmFoZWRyb25Wb2x1bWUoUDEsIFAyLCBQMywgY29vcmRzKSAqIDY7XG4gICAgY29uc3QgVjEgPSBjYWxjdWxhdGVUZXRyYWhlZHJvblZvbHVtZShQMCwgUDIsIFAzLCBjb29yZHMpICogNjtcbiAgICBjb25zdCBWMiA9IGNhbGN1bGF0ZVRldHJhaGVkcm9uVm9sdW1lKFAwLCBQMSwgUDMsIGNvb3JkcykgKiA2O1xuICAgIGNvbnN0IFYzID0gY2FsY3VsYXRlVGV0cmFoZWRyb25Wb2x1bWUoUDAsIFAxLCBQMiwgY29vcmRzKSAqIDY7XG4gICAgQ1swXVswXSAqPSBWMDtcbiAgICBDWzBdWzFdICo9IFYwO1xuICAgIENbMF1bMl0gKj0gVjA7XG4gICAgQ1sxXVswXSAqPSBWMTtcbiAgICBDWzFdWzFdICo9IFYxO1xuICAgIENbMV1bMl0gKj0gVjE7XG4gICAgQ1syXVswXSAqPSBWMjtcbiAgICBDWzJdWzFdICo9IFYyO1xuICAgIENbMl1bMl0gKj0gVjI7XG4gICAgQ1szXVswXSAqPSBWMztcbiAgICBDWzNdWzFdICo9IFYzO1xuICAgIENbM11bMl0gKj0gVjM7XG4gICAgY29sb3IyWzBdID0gQ1swXVswXSArIENbMV1bMF0gKyBDWzJdWzBdICsgQ1szXVswXTtcbiAgICBjb2xvcjJbMV0gPSBDWzBdWzFdICsgQ1sxXVsxXSArIENbMl1bMV0gKyBDWzNdWzFdO1xuICAgIGNvbG9yMlsyXSA9IENbMF1bMl0gKyBDWzFdWzJdICsgQ1syXVsyXSArIENbM11bMl07XG4gIH1cbn1cbnZhciBUZXRyYWhlZHJhbFVwc2NhbGVyID0gY2xhc3Mge1xuICAvKipcbiAgICogRXhwYW5kcyB0aGUgZ2l2ZW4gZGF0YSB0byB0aGUgdGFyZ2V0IHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSB7VHlwZWRBcnJheX0gZGF0YSAtIFRoZSBpbnB1dCBSR0JBIGRhdGEuIEFzc3VtZWQgdG8gYmUgY3ViaWMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIC0gVGhlIHRhcmdldCBzaXplLlxuICAgKiBAcmV0dXJuIHtUeXBlZEFycmF5fSBUaGUgbmV3IGRhdGEuXG4gICAqL1xuICBzdGF0aWMgZXhwYW5kKGRhdGEsIHNpemUpIHtcbiAgICBjb25zdCBvcmlnaW5hbFNpemUgPSBNYXRoLmNicnQoZGF0YS5sZW5ndGggLyA0KTtcbiAgICBjb25zdCByZ2IgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IGRhdGEuY29uc3RydWN0b3Ioc2l6ZSAqKiAzICogNCk7XG4gICAgY29uc3QgbWF4VmFsdWUgPSBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSA/IDI1NSA6IDE7XG4gICAgY29uc3Qgc2l6ZVNxID0gc2l6ZSAqKiAyO1xuICAgIGNvbnN0IHMgPSAxIC8gKHNpemUgLSAxKTtcbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IHNpemU7ICsreikge1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplOyArK3kpIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplOyArK3gpIHtcbiAgICAgICAgICBjb25zdCB1ID0geCAqIHM7XG4gICAgICAgICAgY29uc3QgdjMgPSB5ICogcztcbiAgICAgICAgICBjb25zdCB3ID0geiAqIHM7XG4gICAgICAgICAgY29uc3QgaTQgPSBNYXRoLnJvdW5kKHggKyB5ICogc2l6ZSArIHogKiBzaXplU3EpICogNDtcbiAgICAgICAgICB0ZXRyYWhlZHJhbFNhbXBsZShkYXRhLCBvcmlnaW5hbFNpemUsIHUsIHYzLCB3LCByZ2IpO1xuICAgICAgICAgIGFycmF5W2k0ICsgMF0gPSByZ2JbMF07XG4gICAgICAgICAgYXJyYXlbaTQgKyAxXSA9IHJnYlsxXTtcbiAgICAgICAgICBhcnJheVtpNCArIDJdID0gcmdiWzJdO1xuICAgICAgICAgIGFycmF5W2k0ICsgM10gPSBtYXhWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn07XG5cbi8vIHNyYy90ZXh0dXJlcy9zbWFhL1NNQUFBcmVhSW1hZ2VEYXRhLmpzXG52YXIgYXJlYSA9IFtcbiAgbmV3IEZsb2F0MzJBcnJheSgyKSxcbiAgbmV3IEZsb2F0MzJBcnJheSgyKVxuXTtcbnZhciBPUlRIT0dPTkFMX1NJWkUgPSAxNjtcbnZhciBESUFHT05BTF9TSVpFID0gMjA7XG52YXIgRElBR09OQUxfU0FNUExFUyA9IDMwO1xudmFyIFNNT09USF9NQVhfRElTVEFOQ0UgPSAzMjtcbnZhciBvcnRob2dvbmFsU3Vic2FtcGxpbmdPZmZzZXRzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gIDAsXG4gIC0wLjI1LFxuICAwLjI1LFxuICAtMC4xMjUsXG4gIDAuMTI1LFxuICAtMC4zNzUsXG4gIDAuMzc1XG5dKTtcbnZhciBkaWFnb25hbFN1YnNhbXBsaW5nT2Zmc2V0cyA9IFtcbiAgbmV3IEZsb2F0MzJBcnJheShbMCwgMF0pLFxuICBuZXcgRmxvYXQzMkFycmF5KFswLjI1LCAtMC4yNV0pLFxuICBuZXcgRmxvYXQzMkFycmF5KFstMC4yNSwgMC4yNV0pLFxuICBuZXcgRmxvYXQzMkFycmF5KFswLjEyNSwgLTAuMTI1XSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWy0wLjEyNSwgMC4xMjVdKVxuXTtcbnZhciBvcnRob2dvbmFsRWRnZXMgPSBbXG4gIG5ldyBVaW50OEFycmF5KFswLCAwXSksXG4gIG5ldyBVaW50OEFycmF5KFszLCAwXSksXG4gIG5ldyBVaW50OEFycmF5KFswLCAzXSksXG4gIG5ldyBVaW50OEFycmF5KFszLCAzXSksXG4gIG5ldyBVaW50OEFycmF5KFsxLCAwXSksXG4gIG5ldyBVaW50OEFycmF5KFs0LCAwXSksXG4gIG5ldyBVaW50OEFycmF5KFsxLCAzXSksXG4gIG5ldyBVaW50OEFycmF5KFs0LCAzXSksXG4gIG5ldyBVaW50OEFycmF5KFswLCAxXSksXG4gIG5ldyBVaW50OEFycmF5KFszLCAxXSksXG4gIG5ldyBVaW50OEFycmF5KFswLCA0XSksXG4gIG5ldyBVaW50OEFycmF5KFszLCA0XSksXG4gIG5ldyBVaW50OEFycmF5KFsxLCAxXSksXG4gIG5ldyBVaW50OEFycmF5KFs0LCAxXSksXG4gIG5ldyBVaW50OEFycmF5KFsxLCA0XSksXG4gIG5ldyBVaW50OEFycmF5KFs0LCA0XSlcbl07XG52YXIgZGlhZ29uYWxFZGdlcyA9IFtcbiAgbmV3IFVpbnQ4QXJyYXkoWzAsIDBdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzEsIDBdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzAsIDJdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzEsIDJdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzIsIDBdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzMsIDBdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzIsIDJdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzMsIDJdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzAsIDFdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzEsIDFdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzAsIDNdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzEsIDNdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzIsIDFdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzMsIDFdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzIsIDNdKSxcbiAgbmV3IFVpbnQ4QXJyYXkoWzMsIDNdKVxuXTtcbmZ1bmN0aW9uIGxlcnAoYSwgYiwgcCkge1xuICByZXR1cm4gYSArIChiIC0gYSkgKiBwO1xufVxuZnVuY3Rpb24gc2F0dXJhdGUoYSkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoYSwgMCksIDEpO1xufVxuZnVuY3Rpb24gc21vb3RoQXJlYShkKSB7XG4gIGNvbnN0IGExID0gYXJlYVswXTtcbiAgY29uc3QgYTIgPSBhcmVhWzFdO1xuICBjb25zdCBiMVggPSBNYXRoLnNxcnQoYTFbMF0gKiAyKSAqIDAuNTtcbiAgY29uc3QgYjFZID0gTWF0aC5zcXJ0KGExWzFdICogMikgKiAwLjU7XG4gIGNvbnN0IGIyWCA9IE1hdGguc3FydChhMlswXSAqIDIpICogMC41O1xuICBjb25zdCBiMlkgPSBNYXRoLnNxcnQoYTJbMV0gKiAyKSAqIDAuNTtcbiAgY29uc3QgcCA9IHNhdHVyYXRlKGQgLyBTTU9PVEhfTUFYX0RJU1RBTkNFKTtcbiAgYTFbMF0gPSBsZXJwKGIxWCwgYTFbMF0sIHApO1xuICBhMVsxXSA9IGxlcnAoYjFZLCBhMVsxXSwgcCk7XG4gIGEyWzBdID0gbGVycChiMlgsIGEyWzBdLCBwKTtcbiAgYTJbMV0gPSBsZXJwKGIyWSwgYTJbMV0sIHApO1xufVxuZnVuY3Rpb24gZ2V0T3J0aEFyZWEocDFYLCBwMVksIHAyWCwgcDJZLCB4LCByZXN1bHQpIHtcbiAgY29uc3QgZFggPSBwMlggLSBwMVg7XG4gIGNvbnN0IGRZID0gcDJZIC0gcDFZO1xuICBjb25zdCB4MSA9IHg7XG4gIGNvbnN0IHgyID0geCArIDE7XG4gIGNvbnN0IHkxID0gcDFZICsgZFkgKiAoeDEgLSBwMVgpIC8gZFg7XG4gIGNvbnN0IHkyID0gcDFZICsgZFkgKiAoeDIgLSBwMVgpIC8gZFg7XG4gIGlmICh4MSA+PSBwMVggJiYgeDEgPCBwMlggfHwgeDIgPiBwMVggJiYgeDIgPD0gcDJYKSB7XG4gICAgaWYgKE1hdGguc2lnbih5MSkgPT09IE1hdGguc2lnbih5MikgfHwgTWF0aC5hYnMoeTEpIDwgMWUtNCB8fCBNYXRoLmFicyh5MikgPCAxZS00KSB7XG4gICAgICBjb25zdCBhID0gKHkxICsgeTIpIC8gMjtcbiAgICAgIGlmIChhIDwgMCkge1xuICAgICAgICByZXN1bHRbMF0gPSBNYXRoLmFicyhhKTtcbiAgICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICAgIHJlc3VsdFsxXSA9IE1hdGguYWJzKGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0ID0gLXAxWSAqIGRYIC8gZFkgKyBwMVg7XG4gICAgICBjb25zdCB0SW50ID0gTWF0aC50cnVuYyh0KTtcbiAgICAgIGNvbnN0IGExID0gdCA+IHAxWCA/IHkxICogKHQgLSB0SW50KSAvIDIgOiAwO1xuICAgICAgY29uc3QgYTIgPSB0IDwgcDJYID8geTIgKiAoMSAtICh0IC0gdEludCkpIC8gMiA6IDA7XG4gICAgICBjb25zdCBhID0gTWF0aC5hYnMoYTEpID4gTWF0aC5hYnMoYTIpID8gYTEgOiAtYTI7XG4gICAgICBpZiAoYSA8IDApIHtcbiAgICAgICAgcmVzdWx0WzBdID0gTWF0aC5hYnMoYTEpO1xuICAgICAgICByZXN1bHRbMV0gPSBNYXRoLmFicyhhMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbMF0gPSBNYXRoLmFicyhhMik7XG4gICAgICAgIHJlc3VsdFsxXSA9IE1hdGguYWJzKGExKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0WzBdID0gMDtcbiAgICByZXN1bHRbMV0gPSAwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRPcnRoQXJlYUZvclBhdHRlcm4ocGF0dGVybiwgbGVmdCwgcmlnaHQsIG9mZnNldCwgcmVzdWx0KSB7XG4gIGNvbnN0IGExID0gYXJlYVswXTtcbiAgY29uc3QgYTIgPSBhcmVhWzFdO1xuICBjb25zdCBvMSA9IDAuNSArIG9mZnNldDtcbiAgY29uc3QgbzIgPSAwLjUgKyBvZmZzZXQgLSAxO1xuICBjb25zdCBkID0gbGVmdCArIHJpZ2h0ICsgMTtcbiAgc3dpdGNoIChwYXR0ZXJuKSB7XG4gICAgY2FzZSAwOiB7XG4gICAgICByZXN1bHRbMF0gPSAwO1xuICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDE6IHtcbiAgICAgIGlmIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgICAgIGdldE9ydGhBcmVhKDAsIG8yLCBkIC8gMiwgMCwgbGVmdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICAgIHJlc3VsdFsxXSA9IDA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAyOiB7XG4gICAgICBpZiAobGVmdCA+PSByaWdodCkge1xuICAgICAgICBnZXRPcnRoQXJlYShkIC8gMiwgMCwgZCwgbzIsIGxlZnQsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbMF0gPSAwO1xuICAgICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMzoge1xuICAgICAgZ2V0T3J0aEFyZWEoMCwgbzIsIGQgLyAyLCAwLCBsZWZ0LCBhMSk7XG4gICAgICBnZXRPcnRoQXJlYShkIC8gMiwgMCwgZCwgbzIsIGxlZnQsIGEyKTtcbiAgICAgIHNtb290aEFyZWEoZCwgYXJlYSk7XG4gICAgICByZXN1bHRbMF0gPSBhMVswXSArIGEyWzBdO1xuICAgICAgcmVzdWx0WzFdID0gYTFbMV0gKyBhMlsxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDQ6IHtcbiAgICAgIGlmIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgICAgIGdldE9ydGhBcmVhKDAsIG8xLCBkIC8gMiwgMCwgbGVmdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICAgIHJlc3VsdFsxXSA9IDA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA1OiB7XG4gICAgICByZXN1bHRbMF0gPSAwO1xuICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDY6IHtcbiAgICAgIGlmIChNYXRoLmFicyhvZmZzZXQpID4gMCkge1xuICAgICAgICBnZXRPcnRoQXJlYSgwLCBvMSwgZCwgbzIsIGxlZnQsIGExKTtcbiAgICAgICAgZ2V0T3J0aEFyZWEoMCwgbzEsIGQgLyAyLCAwLCBsZWZ0LCBhMik7XG4gICAgICAgIGdldE9ydGhBcmVhKGQgLyAyLCAwLCBkLCBvMiwgbGVmdCwgcmVzdWx0KTtcbiAgICAgICAgYTJbMF0gPSBhMlswXSArIHJlc3VsdFswXTtcbiAgICAgICAgYTJbMV0gPSBhMlsxXSArIHJlc3VsdFsxXTtcbiAgICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldE9ydGhBcmVhKDAsIG8xLCBkLCBvMiwgbGVmdCwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDc6IHtcbiAgICAgIGdldE9ydGhBcmVhKDAsIG8xLCBkLCBvMiwgbGVmdCwgcmVzdWx0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDg6IHtcbiAgICAgIGlmIChsZWZ0ID49IHJpZ2h0KSB7XG4gICAgICAgIGdldE9ydGhBcmVhKGQgLyAyLCAwLCBkLCBvMSwgbGVmdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICAgIHJlc3VsdFsxXSA9IDA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA5OiB7XG4gICAgICBpZiAoTWF0aC5hYnMob2Zmc2V0KSA+IDApIHtcbiAgICAgICAgZ2V0T3J0aEFyZWEoMCwgbzIsIGQsIG8xLCBsZWZ0LCBhMSk7XG4gICAgICAgIGdldE9ydGhBcmVhKDAsIG8yLCBkIC8gMiwgMCwgbGVmdCwgYTIpO1xuICAgICAgICBnZXRPcnRoQXJlYShkIC8gMiwgMCwgZCwgbzEsIGxlZnQsIHJlc3VsdCk7XG4gICAgICAgIGEyWzBdID0gYTJbMF0gKyByZXN1bHRbMF07XG4gICAgICAgIGEyWzFdID0gYTJbMV0gKyByZXN1bHRbMV07XG4gICAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRPcnRoQXJlYSgwLCBvMiwgZCwgbzEsIGxlZnQsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxMDoge1xuICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgIHJlc3VsdFsxXSA9IDA7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxMToge1xuICAgICAgZ2V0T3J0aEFyZWEoMCwgbzIsIGQsIG8xLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTI6IHtcbiAgICAgIGdldE9ydGhBcmVhKDAsIG8xLCBkIC8gMiwgMCwgbGVmdCwgYTEpO1xuICAgICAgZ2V0T3J0aEFyZWEoZCAvIDIsIDAsIGQsIG8xLCBsZWZ0LCBhMik7XG4gICAgICBzbW9vdGhBcmVhKGQsIGFyZWEpO1xuICAgICAgcmVzdWx0WzBdID0gYTFbMF0gKyBhMlswXTtcbiAgICAgIHJlc3VsdFsxXSA9IGExWzFdICsgYTJbMV07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxMzoge1xuICAgICAgZ2V0T3J0aEFyZWEoMCwgbzIsIGQsIG8xLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTQ6IHtcbiAgICAgIGdldE9ydGhBcmVhKDAsIG8xLCBkLCBvMiwgbGVmdCwgcmVzdWx0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDE1OiB7XG4gICAgICByZXN1bHRbMF0gPSAwO1xuICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNJbnNpZGVBcmVhKGExWCwgYTFZLCBhMlgsIGEyWSwgeCwgeSkge1xuICBsZXQgcmVzdWx0ID0gYTFYID09PSBhMlggJiYgYTFZID09PSBhMlk7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgY29uc3QgeG0gPSAoYTFYICsgYTJYKSAvIDI7XG4gICAgY29uc3QgeW0gPSAoYTFZICsgYTJZKSAvIDI7XG4gICAgY29uc3QgYSA9IGEyWSAtIGExWTtcbiAgICBjb25zdCBiID0gYTFYIC0gYTJYO1xuICAgIGNvbnN0IGMyID0gYSAqICh4IC0geG0pICsgYiAqICh5IC0geW0pO1xuICAgIHJlc3VsdCA9IGMyID4gMDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0RGlhZ0FyZWFGb3JQaXhlbChhMVgsIGExWSwgYTJYLCBhMlksIHBYLCBwWSkge1xuICBsZXQgbiA9IDA7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgRElBR09OQUxfU0FNUExFUzsgKyt5KSB7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBESUFHT05BTF9TQU1QTEVTOyArK3gpIHtcbiAgICAgIGNvbnN0IG9mZnNldFggPSB4IC8gKERJQUdPTkFMX1NBTVBMRVMgLSAxKTtcbiAgICAgIGNvbnN0IG9mZnNldFkgPSB5IC8gKERJQUdPTkFMX1NBTVBMRVMgLSAxKTtcbiAgICAgIGlmIChpc0luc2lkZUFyZWEoYTFYLCBhMVksIGEyWCwgYTJZLCBwWCArIG9mZnNldFgsIHBZICsgb2Zmc2V0WSkpIHtcbiAgICAgICAgKytuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbiAvIChESUFHT05BTF9TQU1QTEVTICogRElBR09OQUxfU0FNUExFUyk7XG59XG5mdW5jdGlvbiBnZXREaWFnQXJlYShwYXR0ZXJuLCBhMVgsIGExWSwgYTJYLCBhMlksIGxlZnQsIG9mZnNldCwgcmVzdWx0KSB7XG4gIGNvbnN0IGUgPSBkaWFnb25hbEVkZ2VzW3BhdHRlcm5dO1xuICBjb25zdCBlMSA9IGVbMF07XG4gIGNvbnN0IGUyID0gZVsxXTtcbiAgaWYgKGUxID4gMCkge1xuICAgIGExWCArPSBvZmZzZXRbMF07XG4gICAgYTFZICs9IG9mZnNldFsxXTtcbiAgfVxuICBpZiAoZTIgPiAwKSB7XG4gICAgYTJYICs9IG9mZnNldFswXTtcbiAgICBhMlkgKz0gb2Zmc2V0WzFdO1xuICB9XG4gIHJlc3VsdFswXSA9IDEgLSBnZXREaWFnQXJlYUZvclBpeGVsKGExWCwgYTFZLCBhMlgsIGEyWSwgMSArIGxlZnQsIDAgKyBsZWZ0KTtcbiAgcmVzdWx0WzFdID0gZ2V0RGlhZ0FyZWFGb3JQaXhlbChhMVgsIGExWSwgYTJYLCBhMlksIDEgKyBsZWZ0LCAxICsgbGVmdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXREaWFnQXJlYUZvclBhdHRlcm4ocGF0dGVybiwgbGVmdCwgcmlnaHQsIG9mZnNldCwgcmVzdWx0KSB7XG4gIGNvbnN0IGExID0gYXJlYVswXTtcbiAgY29uc3QgYTIgPSBhcmVhWzFdO1xuICBjb25zdCBkID0gbGVmdCArIHJpZ2h0ICsgMTtcbiAgc3dpdGNoIChwYXR0ZXJuKSB7XG4gICAgY2FzZSAwOiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMToge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMCArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDI6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDAsIDAsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAzOiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgcmVzdWx0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDQ6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDAgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA1OiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAwICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgNjoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA3OiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgODoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMCwgMCwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDk6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCByZXN1bHQpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxMDoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMCwgMCwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDExOiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTI6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCByZXN1bHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTM6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxNDoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDE1OiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVBhdHRlcm5zKHBhdHRlcm5zLCBvZmZzZXQsIG9ydGhvZ29uYWwpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwYXR0ZXJucy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gcGF0dGVybnNbaV07XG4gICAgY29uc3QgZGF0YSA9IHBhdHRlcm4uZGF0YTtcbiAgICBjb25zdCBzaXplID0gcGF0dGVybi53aWR0aDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemU7ICsreSkge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplOyArK3gpIHtcbiAgICAgICAgaWYgKG9ydGhvZ29uYWwpIHtcbiAgICAgICAgICBnZXRPcnRoQXJlYUZvclBhdHRlcm4oaSwgeCwgeSwgb2Zmc2V0LCByZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdldERpYWdBcmVhRm9yUGF0dGVybihpLCB4LCB5LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYzIgPSAoeSAqIHNpemUgKyB4KSAqIDI7XG4gICAgICAgIGRhdGFbYzJdID0gcmVzdWx0WzBdICogMjU1O1xuICAgICAgICBkYXRhW2MyICsgMV0gPSByZXN1bHRbMV0gKiAyNTU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhc3NlbWJsZShiYXNlWCwgYmFzZVksIHBhdHRlcm5zLCBlZGdlczIsIHNpemUsIG9ydGhvZ29uYWwsIHRhcmdldCkge1xuICBjb25zdCBkc3REYXRhID0gdGFyZ2V0LmRhdGE7XG4gIGNvbnN0IGRzdFdpZHRoID0gdGFyZ2V0LndpZHRoO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBhdHRlcm5zLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGNvbnN0IGVkZ2UgPSBlZGdlczJbaV07XG4gICAgY29uc3QgcGF0dGVybiA9IHBhdHRlcm5zW2ldO1xuICAgIGNvbnN0IHNyY0RhdGEgPSBwYXR0ZXJuLmRhdGE7XG4gICAgY29uc3Qgc3JjV2lkdGggPSBwYXR0ZXJuLndpZHRoO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZTsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemU7ICsreCkge1xuICAgICAgICBjb25zdCBwWCA9IGVkZ2VbMF0gKiBzaXplICsgYmFzZVggKyB4O1xuICAgICAgICBjb25zdCBwWSA9IGVkZ2VbMV0gKiBzaXplICsgYmFzZVkgKyB5O1xuICAgICAgICBjb25zdCBjMiA9IChwWSAqIGRzdFdpZHRoICsgcFgpICogNDtcbiAgICAgICAgY29uc3QgZCA9IG9ydGhvZ29uYWwgPyAoeSAqIHkgKiBzcmNXaWR0aCArIHggKiB4KSAqIDIgOiAoeSAqIHNyY1dpZHRoICsgeCkgKiAyO1xuICAgICAgICBkc3REYXRhW2MyXSA9IHNyY0RhdGFbZF07XG4gICAgICAgIGRzdERhdGFbYzIgKyAxXSA9IHNyY0RhdGFbZCArIDFdO1xuICAgICAgICBkc3REYXRhW2MyICsgMl0gPSAwO1xuICAgICAgICBkc3REYXRhW2MyICsgM10gPSAyNTU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG52YXIgU01BQUFyZWFJbWFnZURhdGEgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGFyZWEgaW1hZ2UuXG4gICAqXG4gICAqIEByZXR1cm4ge1Jhd0ltYWdlRGF0YX0gVGhlIGdlbmVyYXRlZCBpbWFnZSBkYXRhLlxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlKCkge1xuICAgIGNvbnN0IHdpZHRoID0gMiAqIDUgKiBPUlRIT0dPTkFMX1NJWkU7XG4gICAgY29uc3QgaGVpZ2h0ID0gb3J0aG9nb25hbFN1YnNhbXBsaW5nT2Zmc2V0cy5sZW5ndGggKiA1ICogT1JUSE9HT05BTF9TSVpFO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgUmF3SW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQsIGRhdGEpO1xuICAgIGNvbnN0IG9ydGhQYXR0ZXJuU2l6ZSA9IE1hdGgucG93KE9SVEhPR09OQUxfU0laRSAtIDEsIDIpICsgMTtcbiAgICBjb25zdCBkaWFnUGF0dGVyblNpemUgPSBESUFHT05BTF9TSVpFO1xuICAgIGNvbnN0IG9ydGhvZ29uYWxQYXR0ZXJucyA9IFtdO1xuICAgIGNvbnN0IGRpYWdvbmFsUGF0dGVybnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMywgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICBkYXRhW2ldID0gMjU1O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIG9ydGhvZ29uYWxQYXR0ZXJucy5wdXNoKG5ldyBSYXdJbWFnZURhdGEoXG4gICAgICAgIG9ydGhQYXR0ZXJuU2l6ZSxcbiAgICAgICAgb3J0aFBhdHRlcm5TaXplLFxuICAgICAgICBuZXcgVWludDhDbGFtcGVkQXJyYXkob3J0aFBhdHRlcm5TaXplICogb3J0aFBhdHRlcm5TaXplICogMiksXG4gICAgICAgIDJcbiAgICAgICkpO1xuICAgICAgZGlhZ29uYWxQYXR0ZXJucy5wdXNoKG5ldyBSYXdJbWFnZURhdGEoXG4gICAgICAgIGRpYWdQYXR0ZXJuU2l6ZSxcbiAgICAgICAgZGlhZ1BhdHRlcm5TaXplLFxuICAgICAgICBuZXcgVWludDhDbGFtcGVkQXJyYXkoZGlhZ1BhdHRlcm5TaXplICogZGlhZ1BhdHRlcm5TaXplICogMiksXG4gICAgICAgIDJcbiAgICAgICkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IG9ydGhvZ29uYWxTdWJzYW1wbGluZ09mZnNldHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICBnZW5lcmF0ZVBhdHRlcm5zKG9ydGhvZ29uYWxQYXR0ZXJucywgb3J0aG9nb25hbFN1YnNhbXBsaW5nT2Zmc2V0c1tpXSwgdHJ1ZSk7XG4gICAgICBhc3NlbWJsZShcbiAgICAgICAgMCxcbiAgICAgICAgNSAqIE9SVEhPR09OQUxfU0laRSAqIGksXG4gICAgICAgIG9ydGhvZ29uYWxQYXR0ZXJucyxcbiAgICAgICAgb3J0aG9nb25hbEVkZ2VzLFxuICAgICAgICBPUlRIT0dPTkFMX1NJWkUsXG4gICAgICAgIHRydWUsXG4gICAgICAgIHJlc3VsdFxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBkaWFnb25hbFN1YnNhbXBsaW5nT2Zmc2V0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGdlbmVyYXRlUGF0dGVybnMoZGlhZ29uYWxQYXR0ZXJucywgZGlhZ29uYWxTdWJzYW1wbGluZ09mZnNldHNbaV0sIGZhbHNlKTtcbiAgICAgIGFzc2VtYmxlKFxuICAgICAgICA1ICogT1JUSE9HT05BTF9TSVpFLFxuICAgICAgICA0ICogRElBR09OQUxfU0laRSAqIGksXG4gICAgICAgIGRpYWdvbmFsUGF0dGVybnMsXG4gICAgICAgIGRpYWdvbmFsRWRnZXMsXG4gICAgICAgIERJQUdPTkFMX1NJWkUsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICByZXN1bHRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHNyYy90ZXh0dXJlcy9zbWFhL1NNQUFJbWFnZUdlbmVyYXRvci5qc1xuaW1wb3J0IHsgTG9hZGluZ01hbmFnZXIgYXMgTG9hZGluZ01hbmFnZXI1IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHRlbXAvc21hYS93b3JrZXIudHh0XG52YXIgd29ya2VyX2RlZmF1bHQyID0gJ1widXNlIHN0cmljdFwiOygoKT0+e2Z1bmN0aW9uIHEodCxhLHMpe2xldCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksbj1lLmdldENvbnRleHQoXCIyZFwiKTtpZihlLndpZHRoPXQsZS5oZWlnaHQ9YSxzIGluc3RhbmNlb2YgSW1hZ2Upbi5kcmF3SW1hZ2UocywwLDApO2Vsc2V7bGV0IHI9bi5jcmVhdGVJbWFnZURhdGEodCxhKTtyLmRhdGEuc2V0KHMpLG4ucHV0SW1hZ2VEYXRhKHIsMCwwKX1yZXR1cm4gZX12YXIgRj1jbGFzcyB0e2NvbnN0cnVjdG9yKGE9MCxzPTAsZT1udWxsKXt0aGlzLndpZHRoPWEsdGhpcy5oZWlnaHQ9cyx0aGlzLmRhdGE9ZX10b0NhbnZhcygpe3JldHVybiB0eXBlb2YgZG9jdW1lbnQ9PVwidW5kZWZpbmVkXCI/bnVsbDpxKHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsdGhpcy5kYXRhKX1zdGF0aWMgZnJvbShhKXtsZXR7d2lkdGg6cyxoZWlnaHQ6ZX09YSxuO2lmKGEgaW5zdGFuY2VvZiBJbWFnZSl7bGV0IHI9cShzLGUsYSk7ciE9PW51bGwmJihuPXIuZ2V0Q29udGV4dChcIjJkXCIpLmdldEltYWdlRGF0YSgwLDAscyxlKS5kYXRhKX1lbHNlIG49YS5kYXRhO3JldHVybiBuZXcgdChzLGUsbil9fTt2YXIgTT1bbmV3IEZsb2F0MzJBcnJheSgyKSxuZXcgRmxvYXQzMkFycmF5KDIpXSxEPTE2LFc9MjAsST0zMCxqPTMyLHY9bmV3IEZsb2F0MzJBcnJheShbMCwtLjI1LC4yNSwtLjEyNSwuMTI1LC0uMzc1LC4zNzVdKSxOPVtuZXcgRmxvYXQzMkFycmF5KFswLDBdKSxuZXcgRmxvYXQzMkFycmF5KFsuMjUsLS4yNV0pLG5ldyBGbG9hdDMyQXJyYXkoWy0uMjUsLjI1XSksbmV3IEZsb2F0MzJBcnJheShbLjEyNSwtLjEyNV0pLG5ldyBGbG9hdDMyQXJyYXkoWy0uMTI1LC4xMjVdKV0sej1bbmV3IFVpbnQ4QXJyYXkoWzAsMF0pLG5ldyBVaW50OEFycmF5KFszLDBdKSxuZXcgVWludDhBcnJheShbMCwzXSksbmV3IFVpbnQ4QXJyYXkoWzMsM10pLG5ldyBVaW50OEFycmF5KFsxLDBdKSxuZXcgVWludDhBcnJheShbNCwwXSksbmV3IFVpbnQ4QXJyYXkoWzEsM10pLG5ldyBVaW50OEFycmF5KFs0LDNdKSxuZXcgVWludDhBcnJheShbMCwxXSksbmV3IFVpbnQ4QXJyYXkoWzMsMV0pLG5ldyBVaW50OEFycmF5KFswLDRdKSxuZXcgVWludDhBcnJheShbMyw0XSksbmV3IFVpbnQ4QXJyYXkoWzEsMV0pLG5ldyBVaW50OEFycmF5KFs0LDFdKSxuZXcgVWludDhBcnJheShbMSw0XSksbmV3IFVpbnQ4QXJyYXkoWzQsNF0pXSxwPVtuZXcgVWludDhBcnJheShbMCwwXSksbmV3IFVpbnQ4QXJyYXkoWzEsMF0pLG5ldyBVaW50OEFycmF5KFswLDJdKSxuZXcgVWludDhBcnJheShbMSwyXSksbmV3IFVpbnQ4QXJyYXkoWzIsMF0pLG5ldyBVaW50OEFycmF5KFszLDBdKSxuZXcgVWludDhBcnJheShbMiwyXSksbmV3IFVpbnQ4QXJyYXkoWzMsMl0pLG5ldyBVaW50OEFycmF5KFswLDFdKSxuZXcgVWludDhBcnJheShbMSwxXSksbmV3IFVpbnQ4QXJyYXkoWzAsM10pLG5ldyBVaW50OEFycmF5KFsxLDNdKSxuZXcgVWludDhBcnJheShbMiwxXSksbmV3IFVpbnQ4QXJyYXkoWzMsMV0pLG5ldyBVaW50OEFycmF5KFsyLDNdKSxuZXcgVWludDhBcnJheShbMywzXSldO2Z1bmN0aW9uIEModCxhLHMpe3JldHVybiB0KyhhLXQpKnN9ZnVuY3Rpb24gQih0KXtyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodCwwKSwxKX1mdW5jdGlvbiBfKHQpe2xldCBhPU1bMF0scz1NWzFdLGU9TWF0aC5zcXJ0KGFbMF0qMikqLjUsbj1NYXRoLnNxcnQoYVsxXSoyKSouNSxyPU1hdGguc3FydChzWzBdKjIpKi41LG89TWF0aC5zcXJ0KHNbMV0qMikqLjUsYz1CKHQvaik7YVswXT1DKGUsYVswXSxjKSxhWzFdPUMobixhWzFdLGMpLHNbMF09QyhyLHNbMF0sYyksc1sxXT1DKG8sc1sxXSxjKX1mdW5jdGlvbiBkKHQsYSxzLGUsbixyKXtsZXQgbz1zLXQsYz1lLWEsaD1uLGk9bisxLHc9YStjKihoLXQpL28sYj1hK2MqKGktdCkvbztpZihoPj10JiZoPHN8fGk+dCYmaTw9cylpZihNYXRoLnNpZ24odyk9PT1NYXRoLnNpZ24oYil8fE1hdGguYWJzKHcpPDFlLTR8fE1hdGguYWJzKGIpPDFlLTQpe2xldCBnPSh3K2IpLzI7ZzwwPyhyWzBdPU1hdGguYWJzKGcpLHJbMV09MCk6KHJbMF09MCxyWzFdPU1hdGguYWJzKGcpKX1lbHNle2xldCBnPS1hKm8vYyt0LGs9TWF0aC50cnVuYyhnKSxtPWc+dD93KihnLWspLzI6MCxVPWc8cz9iKigxLShnLWspKS8yOjA7KE1hdGguYWJzKG0pPk1hdGguYWJzKFUpP206LVUpPDA/KHJbMF09TWF0aC5hYnMobSksclsxXT1NYXRoLmFicyhVKSk6KHJbMF09TWF0aC5hYnMoVSksclsxXT1NYXRoLmFicyhtKSl9ZWxzZSByWzBdPTAsclsxXT0wO3JldHVybiByfWZ1bmN0aW9uIEoodCxhLHMsZSxuKXtsZXQgcj1NWzBdLG89TVsxXSxjPS41K2UsaD0uNStlLTEsaT1hK3MrMTtzd2l0Y2godCl7Y2FzZSAwOntuWzBdPTAsblsxXT0wO2JyZWFrfWNhc2UgMTp7YTw9cz9kKDAsaCxpLzIsMCxhLG4pOihuWzBdPTAsblsxXT0wKTticmVha31jYXNlIDI6e2E+PXM/ZChpLzIsMCxpLGgsYSxuKTooblswXT0wLG5bMV09MCk7YnJlYWt9Y2FzZSAzOntkKDAsaCxpLzIsMCxhLHIpLGQoaS8yLDAsaSxoLGEsbyksXyhpLE0pLG5bMF09clswXStvWzBdLG5bMV09clsxXStvWzFdO2JyZWFrfWNhc2UgNDp7YTw9cz9kKDAsYyxpLzIsMCxhLG4pOihuWzBdPTAsblsxXT0wKTticmVha31jYXNlIDU6e25bMF09MCxuWzFdPTA7YnJlYWt9Y2FzZSA2OntNYXRoLmFicyhlKT4wPyhkKDAsYyxpLGgsYSxyKSxkKDAsYyxpLzIsMCxhLG8pLGQoaS8yLDAsaSxoLGEsbiksb1swXT1vWzBdK25bMF0sb1sxXT1vWzFdK25bMV0sblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMik6ZCgwLGMsaSxoLGEsbik7YnJlYWt9Y2FzZSA3OntkKDAsYyxpLGgsYSxuKTticmVha31jYXNlIDg6e2E+PXM/ZChpLzIsMCxpLGMsYSxuKTooblswXT0wLG5bMV09MCk7YnJlYWt9Y2FzZSA5OntNYXRoLmFicyhlKT4wPyhkKDAsaCxpLGMsYSxyKSxkKDAsaCxpLzIsMCxhLG8pLGQoaS8yLDAsaSxjLGEsbiksb1swXT1vWzBdK25bMF0sb1sxXT1vWzFdK25bMV0sblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMik6ZCgwLGgsaSxjLGEsbik7YnJlYWt9Y2FzZSAxMDp7blswXT0wLG5bMV09MDticmVha31jYXNlIDExOntkKDAsaCxpLGMsYSxuKTticmVha31jYXNlIDEyOntkKDAsYyxpLzIsMCxhLHIpLGQoaS8yLDAsaSxjLGEsbyksXyhpLE0pLG5bMF09clswXStvWzBdLG5bMV09clsxXStvWzFdO2JyZWFrfWNhc2UgMTM6e2QoMCxoLGksYyxhLG4pO2JyZWFrfWNhc2UgMTQ6e2QoMCxjLGksaCxhLG4pO2JyZWFrfWNhc2UgMTU6e25bMF09MCxuWzFdPTA7YnJlYWt9fXJldHVybiBufWZ1bmN0aW9uIEsodCxhLHMsZSxuLHIpe2xldCBvPXQ9PT1zJiZhPT09ZTtpZighbyl7bGV0IGM9KHQrcykvMixoPShhK2UpLzIsaT1lLWEsdz10LXM7bz1pKihuLWMpK3cqKHItaCk+MH1yZXR1cm4gb31mdW5jdGlvbiBHKHQsYSxzLGUsbixyKXtsZXQgbz0wO2ZvcihsZXQgYz0wO2M8STsrK2MpZm9yKGxldCBoPTA7aDxJOysraCl7bGV0IGk9aC8oSS0xKSx3PWMvKEktMSk7Syh0LGEscyxlLG4raSxyK3cpJiYrK299cmV0dXJuIG8vKEkqSSl9ZnVuY3Rpb24gQSh0LGEscyxlLG4scixvLGMpe2xldCBoPXBbdF0saT1oWzBdLHc9aFsxXTtyZXR1cm4gaT4wJiYoYSs9b1swXSxzKz1vWzFdKSx3PjAmJihlKz1vWzBdLG4rPW9bMV0pLGNbMF09MS1HKGEscyxlLG4sMStyLDArciksY1sxXT1HKGEscyxlLG4sMStyLDErciksY31mdW5jdGlvbiBRKHQsYSxzLGUsbil7bGV0IHI9TVswXSxvPU1bMV0sYz1hK3MrMTtzd2l0Y2godCl7Y2FzZSAwOntBKHQsMSwxLDErYywxK2MsYSxlLHIpLEEodCwxLDAsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDE6e0EodCwxLDAsMCtjLDArYyxhLGUsciksQSh0LDEsMCwxK2MsMCtjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgMjp7QSh0LDAsMCwxK2MsMCtjLGEsZSxyKSxBKHQsMSwwLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSAzOntBKHQsMSwwLDErYywwK2MsYSxlLG4pO2JyZWFrfWNhc2UgNDp7QSh0LDEsMSwwK2MsMCtjLGEsZSxyKSxBKHQsMSwxLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSA1OntBKHQsMSwxLDArYywwK2MsYSxlLHIpLEEodCwxLDAsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDY6e0EodCwxLDEsMStjLDArYyxhLGUsbik7YnJlYWt9Y2FzZSA3OntBKHQsMSwxLDErYywwK2MsYSxlLHIpLEEodCwxLDAsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDg6e0EodCwwLDAsMStjLDErYyxhLGUsciksQSh0LDEsMCwxK2MsMStjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgOTp7QSh0LDEsMCwxK2MsMStjLGEsZSxuKSxBKHQsMSwwLDErYywxK2MsYSxlLG4pO2JyZWFrfWNhc2UgMTA6e0EodCwwLDAsMStjLDErYyxhLGUsciksQSh0LDEsMCwxK2MsMCtjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgMTE6e0EodCwxLDAsMStjLDErYyxhLGUsciksQSh0LDEsMCwxK2MsMCtjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgMTI6e0EodCwxLDEsMStjLDErYyxhLGUsbik7YnJlYWt9Y2FzZSAxMzp7QSh0LDEsMSwxK2MsMStjLGEsZSxyKSxBKHQsMSwwLDErYywxK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSAxNDp7QSh0LDEsMSwxK2MsMStjLGEsZSxyKSxBKHQsMSwxLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSAxNTp7QSh0LDEsMSwxK2MsMStjLGEsZSxyKSxBKHQsMSwwLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9fXJldHVybiBufWZ1bmN0aW9uIFIodCxhLHMpe2xldCBlPW5ldyBGbG9hdDMyQXJyYXkoMik7Zm9yKGxldCBuPTAscj10Lmxlbmd0aDtuPHI7KytuKXtsZXQgbz10W25dLGM9by5kYXRhLGg9by53aWR0aDtmb3IobGV0IGk9MDtpPGg7KytpKWZvcihsZXQgdz0wO3c8aDsrK3cpe3M/SihuLHcsaSxhLGUpOlEobix3LGksYSxlKTtsZXQgYj0oaSpoK3cpKjI7Y1tiXT1lWzBdKjI1NSxjW2IrMV09ZVsxXSoyNTV9fX1mdW5jdGlvbiBUKHQsYSxzLGUsbixyLG8pe2xldCBjPW8uZGF0YSxoPW8ud2lkdGg7Zm9yKGxldCBpPTAsdz1zLmxlbmd0aDtpPHc7KytpKXtsZXQgYj1lW2ldLGc9c1tpXSxrPWcuZGF0YSxtPWcud2lkdGg7Zm9yKGxldCBVPTA7VTxuOysrVSlmb3IobGV0IHg9MDt4PG47Kyt4KXtsZXQgWj1iWzBdKm4rdCt4LE89KChiWzFdKm4rYStVKSpoK1opKjQsTD1yPyhVKlUqbSt4KngpKjI6KFUqbSt4KSoyO2NbT109a1tMXSxjW08rMV09a1tMKzFdLGNbTysyXT0wLGNbTyszXT0yNTV9fX12YXIgUz1jbGFzc3tzdGF0aWMgZ2VuZXJhdGUoKXtsZXQgYT0xMCpELHM9di5sZW5ndGgqNSpELGU9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGEqcyo0KSxuPW5ldyBGKGEscyxlKSxyPU1hdGgucG93KEQtMSwyKSsxLG89VyxjPVtdLGg9W107Zm9yKGxldCBpPTMsdz1lLmxlbmd0aDtpPHc7aSs9NCllW2ldPTI1NTtmb3IobGV0IGk9MDtpPDE2OysraSljLnB1c2gobmV3IEYocixyLG5ldyBVaW50OENsYW1wZWRBcnJheShyKnIqMiksMikpLGgucHVzaChuZXcgRihvLG8sbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG8qbyoyKSwyKSk7Zm9yKGxldCBpPTAsdz12Lmxlbmd0aDtpPHc7KytpKVIoYyx2W2ldLCEwKSxUKDAsNSpEKmksYyx6LEQsITAsbik7Zm9yKGxldCBpPTAsdz1OLmxlbmd0aDtpPHc7KytpKVIoaCxOW2ldLCExKSxUKDUqRCw0KlcqaSxoLHAsVywhMSxuKTtyZXR1cm4gbn19O3ZhciBQPW5ldyBNYXAoW1t5KDAsMCwwLDApLG5ldyBGbG9hdDMyQXJyYXkoWzAsMCwwLDBdKV0sW3koMCwwLDAsMSksbmV3IEZsb2F0MzJBcnJheShbMCwwLDAsMV0pXSxbeSgwLDAsMSwwKSxuZXcgRmxvYXQzMkFycmF5KFswLDAsMSwwXSldLFt5KDAsMCwxLDEpLG5ldyBGbG9hdDMyQXJyYXkoWzAsMCwxLDFdKV0sW3koMCwxLDAsMCksbmV3IEZsb2F0MzJBcnJheShbMCwxLDAsMF0pXSxbeSgwLDEsMCwxKSxuZXcgRmxvYXQzMkFycmF5KFswLDEsMCwxXSldLFt5KDAsMSwxLDApLG5ldyBGbG9hdDMyQXJyYXkoWzAsMSwxLDBdKV0sW3koMCwxLDEsMSksbmV3IEZsb2F0MzJBcnJheShbMCwxLDEsMV0pXSxbeSgxLDAsMCwwKSxuZXcgRmxvYXQzMkFycmF5KFsxLDAsMCwwXSldLFt5KDEsMCwwLDEpLG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwwLDFdKV0sW3koMSwwLDEsMCksbmV3IEZsb2F0MzJBcnJheShbMSwwLDEsMF0pXSxbeSgxLDAsMSwxKSxuZXcgRmxvYXQzMkFycmF5KFsxLDAsMSwxXSldLFt5KDEsMSwwLDApLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwwLDBdKV0sW3koMSwxLDAsMSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDAsMV0pXSxbeSgxLDEsMSwwKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMSwwXSldLFt5KDEsMSwxLDEpLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxLDFdKV1dKTtmdW5jdGlvbiBIKHQsYSxzKXtyZXR1cm4gdCsoYS10KSpzfWZ1bmN0aW9uIHkodCxhLHMsZSl7bGV0IG49SCh0LGEsLjc1KSxyPUgocyxlLDEtLjI1KTtyZXR1cm4gSChuLHIsMS0uMTI1KX1mdW5jdGlvbiBWKHQsYSl7bGV0IHM9MDtyZXR1cm4gYVszXT09PTEmJihzKz0xKSxzPT09MSYmYVsyXT09PTEmJnRbMV0hPT0xJiZ0WzNdIT09MSYmKHMrPTEpLHN9ZnVuY3Rpb24gJCh0LGEpe2xldCBzPTA7cmV0dXJuIGFbM109PT0xJiZ0WzFdIT09MSYmdFszXSE9PTEmJihzKz0xKSxzPT09MSYmYVsyXT09PTEmJnRbMF0hPT0xJiZ0WzJdIT09MSYmKHMrPTEpLHN9dmFyIEU9Y2xhc3N7c3RhdGljIGdlbmVyYXRlKCl7bGV0IG89bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDIxNzgpLGM9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDY0KjE2KjQpO2ZvcihsZXQgaD0wO2g8MzM7KytoKWZvcihsZXQgaT0wO2k8NjY7KytpKXtsZXQgdz0uMDMxMjUqaSxiPS4wMzEyNSpoO2lmKFAuaGFzKHcpJiZQLmhhcyhiKSl7bGV0IGc9UC5nZXQodyksaz1QLmdldChiKSxtPWgqNjYraTtvW21dPTEyNypWKGcsayksb1ttKzMzXT0xMjcqJChnLGspfX1mb3IobGV0IGg9MCxpPTE3O2k8MzM7KytpKWZvcihsZXQgdz0wO3c8NjQ7Kyt3LGgrPTQpY1toXT1vW2kqNjYrd10sY1toKzNdPTI1NTtyZXR1cm4gbmV3IEYoNjQsMTYsYyl9fTtzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdD0+e2xldCBhPVMuZ2VuZXJhdGUoKSxzPUUuZ2VuZXJhdGUoKTtwb3N0TWVzc2FnZSh7YXJlYUltYWdlRGF0YTphLHNlYXJjaEltYWdlRGF0YTpzfSxbYS5kYXRhLmJ1ZmZlcixzLmRhdGEuYnVmZmVyXSksY2xvc2UoKX0pO30pKCk7XFxuJztcblxuLy8gc3JjL3RleHR1cmVzL3NtYWEvU01BQUltYWdlR2VuZXJhdG9yLmpzXG5mdW5jdGlvbiBnZW5lcmF0ZSh1c2VDYWNoZSA9IHRydWUpIHtcbiAgY29uc3Qgd29ya2VyVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd29ya2VyX2RlZmF1bHQyXSwge1xuICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgfSkpO1xuICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVSTCk7XG4gIFVSTC5yZXZva2VPYmplY3RVUkwod29ya2VyVVJMKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChldmVudCkgPT4gcmVqZWN0KGV2ZW50LmVycm9yKSk7XG4gICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgY29uc3Qgc2VhcmNoSW1hZ2VEYXRhID0gUmF3SW1hZ2VEYXRhLmZyb20oZXZlbnQuZGF0YS5zZWFyY2hJbWFnZURhdGEpO1xuICAgICAgY29uc3QgYXJlYUltYWdlRGF0YSA9IFJhd0ltYWdlRGF0YS5mcm9tKGV2ZW50LmRhdGEuYXJlYUltYWdlRGF0YSk7XG4gICAgICBjb25zdCB1cmxzID0gW1xuICAgICAgICBzZWFyY2hJbWFnZURhdGEudG9DYW52YXMoKS50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIiwgMSksXG4gICAgICAgIGFyZWFJbWFnZURhdGEudG9DYW52YXMoKS50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIiwgMSlcbiAgICAgIF07XG4gICAgICBpZiAodXNlQ2FjaGUpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzbWFhLXNlYXJjaFwiLCB1cmxzWzBdKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzbWFhLWFyZWFcIiwgdXJsc1sxXSk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHVybHMpO1xuICAgIH0pO1xuICAgIHdvcmtlci5wb3N0TWVzc2FnZShudWxsKTtcbiAgfSk7XG59XG52YXIgU01BQUltYWdlR2VuZXJhdG9yID0gY2xhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBTTUFBIGltYWdlIGdlbmVyYXRvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGlzYWJsZUNhY2hlID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgY2FjaGluZyB2aWEgbG9jYWxTdG9yYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciB0aGUgY2FjaGUgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRDYWNoZUVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmRpc2FibGVDYWNoZSA9ICF2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBTTUFBIGRhdGEgaW1hZ2VzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBTTUFBSW1hZ2VHZW5lcmF0b3IuZ2VuZXJhdGUoKS50aGVuKChbc2VhcmNoLCBhcmVhXSkgPT4ge1xuICAgKiAgIGNvbnN0IHNtYWFFZmZlY3QgPSBuZXcgU01BQUVmZmVjdChzZWFyY2gsIGFyZWEpO1xuICAgKiB9KTtcbiAgICogQHJldHVybiB7UHJvbWlzZTxJbWFnZVtdPn0gQSBwcm9taXNlIHRoYXQgcmV0dXJucyB0aGUgc2VhcmNoIGltYWdlIGFuZCBhcmVhIGltYWdlIGFzIGEgcGFpci5cbiAgICovXG4gIGdlbmVyYXRlKCkge1xuICAgIGNvbnN0IHVzZUNhY2hlID0gIXRoaXMuZGlzYWJsZUNhY2hlICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UgIT09IHZvaWQgMDtcbiAgICBjb25zdCBjYWNoZWRVUkxzID0gdXNlQ2FjaGUgPyBbXG4gICAgICBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNtYWEtc2VhcmNoXCIpLFxuICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzbWFhLWFyZWFcIilcbiAgICBdIDogW251bGwsIG51bGxdO1xuICAgIGNvbnN0IHByb21pc2UgPSBjYWNoZWRVUkxzWzBdICE9PSBudWxsICYmIGNhY2hlZFVSTHNbMV0gIT09IG51bGwgPyBQcm9taXNlLnJlc29sdmUoY2FjaGVkVVJMcykgOiBnZW5lcmF0ZSh1c2VDYWNoZSk7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbigodXJscykgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgc2VhcmNoSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgYXJlYUltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXI1KCk7XG4gICAgICAgIG1hbmFnZXIub25Mb2FkID0gKCkgPT4gcmVzb2x2ZShbc2VhcmNoSW1hZ2UsIGFyZWFJbWFnZV0pO1xuICAgICAgICBtYW5hZ2VyLm9uRXJyb3IgPSByZWplY3Q7XG4gICAgICAgIHNlYXJjaEltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZSkgPT4gbWFuYWdlci5pdGVtRXJyb3IoXCJzbWFhLXNlYXJjaFwiKSk7XG4gICAgICAgIGFyZWFJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGUpID0+IG1hbmFnZXIuaXRlbUVycm9yKFwic21hYS1hcmVhXCIpKTtcbiAgICAgICAgc2VhcmNoSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4gbWFuYWdlci5pdGVtRW5kKFwic21hYS1zZWFyY2hcIikpO1xuICAgICAgICBhcmVhSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4gbWFuYWdlci5pdGVtRW5kKFwic21hYS1hcmVhXCIpKTtcbiAgICAgICAgbWFuYWdlci5pdGVtU3RhcnQoXCJzbWFhLXNlYXJjaFwiKTtcbiAgICAgICAgbWFuYWdlci5pdGVtU3RhcnQoXCJzbWFhLWFyZWFcIik7XG4gICAgICAgIHNlYXJjaEltYWdlLnNyYyA9IHVybHNbMF07XG4gICAgICAgIGFyZWFJbWFnZS5zcmMgPSB1cmxzWzFdO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy90ZXh0dXJlcy9zbWFhL1NNQUFTZWFyY2hJbWFnZURhdGEuanNcbnZhciBlZGdlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW2JpbGluZWFyKDAsIDAsIDAsIDApLCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAwXSldLFxuICBbYmlsaW5lYXIoMCwgMCwgMCwgMSksIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDFdKV0sXG4gIFtiaWxpbmVhcigwLCAwLCAxLCAwKSwgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMF0pXSxcbiAgW2JpbGluZWFyKDAsIDAsIDEsIDEpLCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAxXSldLFxuICBbYmlsaW5lYXIoMCwgMSwgMCwgMCksIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDAsIDBdKV0sXG4gIFtiaWxpbmVhcigwLCAxLCAwLCAxKSwgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMCwgMV0pXSxcbiAgW2JpbGluZWFyKDAsIDEsIDEsIDApLCBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAxLCAwXSldLFxuICBbYmlsaW5lYXIoMCwgMSwgMSwgMSksIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDEsIDFdKV0sXG4gIFtiaWxpbmVhcigxLCAwLCAwLCAwKSwgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMF0pXSxcbiAgW2JpbGluZWFyKDEsIDAsIDAsIDEpLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAxXSldLFxuICBbYmlsaW5lYXIoMSwgMCwgMSwgMCksIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDEsIDBdKV0sXG4gIFtiaWxpbmVhcigxLCAwLCAxLCAxKSwgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMSwgMV0pXSxcbiAgW2JpbGluZWFyKDEsIDEsIDAsIDApLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAwLCAwXSldLFxuICBbYmlsaW5lYXIoMSwgMSwgMCwgMSksIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDAsIDFdKV0sXG4gIFtiaWxpbmVhcigxLCAxLCAxLCAwKSwgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMF0pXSxcbiAgW2JpbGluZWFyKDEsIDEsIDEsIDEpLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSldXG5dKTtcbmZ1bmN0aW9uIGxlcnAyKGEsIGIsIHApIHtcbiAgcmV0dXJuIGEgKyAoYiAtIGEpICogcDtcbn1cbmZ1bmN0aW9uIGJpbGluZWFyKGUwLCBlMSwgZTIsIGUzKSB7XG4gIGNvbnN0IGEgPSBsZXJwMihlMCwgZTEsIDEgLSAwLjI1KTtcbiAgY29uc3QgYiA9IGxlcnAyKGUyLCBlMywgMSAtIDAuMjUpO1xuICByZXR1cm4gbGVycDIoYSwgYiwgMSAtIDAuMTI1KTtcbn1cbmZ1bmN0aW9uIGRlbHRhTGVmdChsZWZ0LCB0b3ApIHtcbiAgbGV0IGQgPSAwO1xuICBpZiAodG9wWzNdID09PSAxKSB7XG4gICAgZCArPSAxO1xuICB9XG4gIGlmIChkID09PSAxICYmIHRvcFsyXSA9PT0gMSAmJiBsZWZ0WzFdICE9PSAxICYmIGxlZnRbM10gIT09IDEpIHtcbiAgICBkICs9IDE7XG4gIH1cbiAgcmV0dXJuIGQ7XG59XG5mdW5jdGlvbiBkZWx0YVJpZ2h0KGxlZnQsIHRvcCkge1xuICBsZXQgZCA9IDA7XG4gIGlmICh0b3BbM10gPT09IDEgJiYgbGVmdFsxXSAhPT0gMSAmJiBsZWZ0WzNdICE9PSAxKSB7XG4gICAgZCArPSAxO1xuICB9XG4gIGlmIChkID09PSAxICYmIHRvcFsyXSA9PT0gMSAmJiBsZWZ0WzBdICE9PSAxICYmIGxlZnRbMl0gIT09IDEpIHtcbiAgICBkICs9IDE7XG4gIH1cbiAgcmV0dXJuIGQ7XG59XG52YXIgU01BQVNlYXJjaEltYWdlRGF0YSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc2VhcmNoIGltYWdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSYXdJbWFnZURhdGF9IFRoZSBnZW5lcmF0ZWQgaW1hZ2UgZGF0YS5cbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZSgpIHtcbiAgICBjb25zdCB3aWR0aCA9IDY2O1xuICAgIGNvbnN0IGhlaWdodCA9IDMzO1xuICAgIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICBjb25zdCBjcm9wcGVkV2lkdGggPSA2NDtcbiAgICBjb25zdCBjcm9wcGVkSGVpZ2h0ID0gMTY7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCk7XG4gICAgY29uc3QgY3JvcHBlZERhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoY3JvcHBlZFdpZHRoICogY3JvcHBlZEhlaWdodCAqIDQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgICBjb25zdCBzID0gMC4wMzEyNSAqIHg7XG4gICAgICAgIGNvbnN0IHQgPSAwLjAzMTI1ICogeTtcbiAgICAgICAgaWYgKGVkZ2VzLmhhcyhzKSAmJiBlZGdlcy5oYXModCkpIHtcbiAgICAgICAgICBjb25zdCBlMSA9IGVkZ2VzLmdldChzKTtcbiAgICAgICAgICBjb25zdCBlMiA9IGVkZ2VzLmdldCh0KTtcbiAgICAgICAgICBjb25zdCBpID0geSAqIHdpZHRoICsgeDtcbiAgICAgICAgICBkYXRhW2ldID0gMTI3ICogZGVsdGFMZWZ0KGUxLCBlMik7XG4gICAgICAgICAgZGF0YVtpICsgaGFsZldpZHRoXSA9IDEyNyAqIGRlbHRhUmlnaHQoZTEsIGUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgeSA9IGhlaWdodCAtIGNyb3BwZWRIZWlnaHQ7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBjcm9wcGVkV2lkdGg7ICsreCwgaSArPSA0KSB7XG4gICAgICAgIGNyb3BwZWREYXRhW2ldID0gZGF0YVt5ICogd2lkdGggKyB4XTtcbiAgICAgICAgY3JvcHBlZERhdGFbaSArIDNdID0gMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJhd0ltYWdlRGF0YShjcm9wcGVkV2lkdGgsIGNyb3BwZWRIZWlnaHQsIGNyb3BwZWREYXRhKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEFTQ0lJRWZmZWN0LFxuICBBU0NJSVRleHR1cmUsXG4gIEFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwsXG4gIEFkYXB0aXZlTHVtaW5hbmNlUGFzcyxcbiAgQmxlbmRGdW5jdGlvbixcbiAgQmxlbmRNb2RlLFxuICBCbG9vbUVmZmVjdCxcbiAgS2F3YXNlQmx1clBhc3MgYXMgQmx1clBhc3MsXG4gIEJva2VoRWZmZWN0LFxuICBCb2tlaE1hdGVyaWFsLFxuICBCb3hCbHVyTWF0ZXJpYWwsXG4gIEJveEJsdXJQYXNzLFxuICBCcmlnaHRuZXNzQ29udHJhc3RFZmZlY3QsXG4gIENocm9tYXRpY0FiZXJyYXRpb25FZmZlY3QsXG4gIENpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwsXG4gIENsZWFyTWFza1Bhc3MsXG4gIENsZWFyUGFzcyxcbiAgQ29sb3JBdmVyYWdlRWZmZWN0LFxuICBDb2xvckNoYW5uZWwsXG4gIENvbG9yRGVwdGhFZmZlY3QsXG4gIEVkZ2VEZXRlY3Rpb25NYXRlcmlhbCBhcyBDb2xvckVkZ2VzTWF0ZXJpYWwsXG4gIEthd2FzZUJsdXJNYXRlcmlhbCBhcyBDb252b2x1dGlvbk1hdGVyaWFsLFxuICBDb3B5TWF0ZXJpYWwsXG4gIENvcHlQYXNzLFxuICBEZXB0aENvbXBhcmlzb25NYXRlcmlhbCxcbiAgRGVwdGhDb3B5TWF0ZXJpYWwsXG4gIERlcHRoQ29weU1vZGUsXG4gIERlcHRoQ29weVBhc3MsXG4gIERlcHRoRG93bnNhbXBsaW5nTWF0ZXJpYWwsXG4gIERlcHRoRG93bnNhbXBsaW5nUGFzcyxcbiAgRGVwdGhFZmZlY3QsXG4gIERlcHRoTWFza01hdGVyaWFsLFxuICBEZXB0aE9mRmllbGRFZmZlY3QsXG4gIERlcHRoUGFzcyxcbiAgRGVwdGhQaWNraW5nUGFzcyxcbiAgRGVwdGhDb3B5UGFzcyBhcyBEZXB0aFNhdmVQYXNzLFxuICBEZXB0aFRlc3RTdHJhdGVneSxcbiAgRGlzcG9zYWJsZSxcbiAgRG90U2NyZWVuRWZmZWN0LFxuICBEb3duc2FtcGxpbmdNYXRlcmlhbCxcbiAgRWRnZURldGVjdGlvbk1hdGVyaWFsLFxuICBFZGdlRGV0ZWN0aW9uTW9kZSxcbiAgRWZmZWN0LFxuICBFZmZlY3RBdHRyaWJ1dGUsXG4gIEVmZmVjdENvbXBvc2VyLFxuICBFZmZlY3RNYXRlcmlhbCxcbiAgRWZmZWN0UGFzcyxcbiAgRWZmZWN0U2hhZGVyRGF0YSxcbiAgRWZmZWN0U2hhZGVyU2VjdGlvbixcbiAgRlhBQUVmZmVjdCxcbiAgR2FtbWFDb3JyZWN0aW9uRWZmZWN0LFxuICBHYXVzc0tlcm5lbCxcbiAgR2F1c3NpYW5CbHVyTWF0ZXJpYWwsXG4gIEdhdXNzaWFuQmx1clBhc3MsXG4gIEdsaXRjaEVmZmVjdCxcbiAgR2xpdGNoTW9kZSxcbiAgR29kUmF5c0VmZmVjdCxcbiAgR29kUmF5c01hdGVyaWFsLFxuICBHcmlkRWZmZWN0LFxuICBIdWVTYXR1cmF0aW9uRWZmZWN0LFxuICBJbW11dGFibGVUaW1lcixcbiAgSW5pdGlhbGl6YWJsZSxcbiAgS2F3YXNlQmx1ck1hdGVyaWFsLFxuICBLYXdhc2VCbHVyUGFzcyxcbiAgS2VybmVsU2l6ZSxcbiAgTFVUMURFZmZlY3QsXG4gIExVVDNERWZmZWN0LFxuICBMVVQzZGxMb2FkZXIsXG4gIExVVEN1YmVMb2FkZXIsXG4gIExVVDNERWZmZWN0IGFzIExVVEVmZmVjdCxcbiAgTFVUT3BlcmF0aW9uLFxuICBMYW1iZGFQYXNzLFxuICBMZW5zRGlzdG9ydGlvbkVmZmVjdCxcbiAgTG9va3VwVGV4dHVyZSxcbiAgTG9va3VwVGV4dHVyZSBhcyBMb29rdXBUZXh0dXJlM0QsXG4gIEx1bWluYW5jZU1hdGVyaWFsLFxuICBMdW1pbmFuY2VQYXNzLFxuICBNYXNrRnVuY3Rpb24sXG4gIE1hc2tNYXRlcmlhbCxcbiAgTWFza1Bhc3MsXG4gIE1pcG1hcEJsdXJQYXNzLFxuICBOb2lzZUVmZmVjdCxcbiAgTm9pc2VUZXh0dXJlLFxuICBOb3JtYWxQYXNzLFxuICBPdXRsaW5lTWF0ZXJpYWwgYXMgT3V0bGluZUVkZ2VzTWF0ZXJpYWwsXG4gIE91dGxpbmVFZmZlY3QsXG4gIE91dGxpbmVNYXRlcmlhbCxcbiAgT3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIsXG4gIFBhc3MsXG4gIFBpeGVsYXRpb25FZmZlY3QsXG4gIFByZWRpY2F0aW9uTW9kZSxcbiAgUmF3SW1hZ2VEYXRhLFxuICBSZWFsaXN0aWNCb2tlaEVmZmVjdCxcbiAgUmVuZGVyUGFzcyxcbiAgUmVzaXphYmxlLFxuICBSZXNvbHV0aW9uIGFzIFJlc2l6ZXIsXG4gIFJlc29sdXRpb24sXG4gIFNNQUFBcmVhSW1hZ2VEYXRhLFxuICBTTUFBRWZmZWN0LFxuICBTTUFBSW1hZ2VHZW5lcmF0b3IsXG4gIFNNQUFJbWFnZUxvYWRlcixcbiAgU01BQVByZXNldCxcbiAgU01BQVNlYXJjaEltYWdlRGF0YSxcbiAgU01BQVdlaWdodHNNYXRlcmlhbCxcbiAgU1NBT0VmZmVjdCxcbiAgU1NBT01hdGVyaWFsLFxuICBDb3B5UGFzcyBhcyBTYXZlUGFzcyxcbiAgU2NhbmxpbmVFZmZlY3QsXG4gIEVmZmVjdFNoYWRlclNlY3Rpb24gYXMgU2VjdGlvbixcbiAgU2VsZWN0aW9uLFxuICBTZWxlY3RpdmVCbG9vbUVmZmVjdCxcbiAgU2VwaWFFZmZlY3QsXG4gIFNoYWRlclBhc3MsXG4gIFNob2NrV2F2ZUVmZmVjdCxcbiAgVGV0cmFoZWRyYWxVcHNjYWxlcixcbiAgVGV4dHVyZUVmZmVjdCxcbiAgVGlsdFNoaWZ0Qmx1ck1hdGVyaWFsLFxuICBUaWx0U2hpZnRCbHVyUGFzcyxcbiAgVGlsdFNoaWZ0RWZmZWN0LFxuICBUaW1lcixcbiAgVG9uZU1hcHBpbmdFZmZlY3QsXG4gIFRvbmVNYXBwaW5nTW9kZSxcbiAgVXBzYW1wbGluZ01hdGVyaWFsLFxuICBWaWduZXR0ZUVmZmVjdCxcbiAgVmlnbmV0dGVUZWNobmlxdWUsXG4gIFdlYkdMRXh0ZW5zaW9uLFxuICB2ZXJzaW9uXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/postprocessing/build/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three/examples/jsm/postprocessing/Pass.js":
/*!****************************************************************!*\
  !*** ./node_modules/three/examples/jsm/postprocessing/Pass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FullScreenQuad: () => (/* binding */ FullScreenQuad),\n/* harmony export */   Pass: () => (/* binding */ Pass)\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_BufferGeometry_Float32BufferAttribute_Mesh_OrthographicCamera_three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=BufferGeometry,Float32BufferAttribute,Mesh,OrthographicCamera!=!three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\nclass Pass {\n    setSize() {}\n    render() {\n        console.error('THREE.Pass: .render() must be implemented in derived pass.');\n    }\n    dispose() {}\n    constructor(){\n        this.isPass = true;\n        // if set to true, the pass is processed by the composer\n        this.enabled = true;\n        // if set to true, the pass indicates to swap read and write buffer after rendering\n        this.needsSwap = true;\n        // if set to true, the pass clears its buffer before rendering\n        this.clear = false;\n        // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n        this.renderToScreen = false;\n    }\n}\n// Helper for passes that need to fill the viewport with a single quad.\nconst _camera = new _barrel_optimize_names_BufferGeometry_Float32BufferAttribute_Mesh_OrthographicCamera_three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n// https://github.com/mrdoob/three.js/pull/21358\nclass FullscreenTriangleGeometry extends _barrel_optimize_names_BufferGeometry_Float32BufferAttribute_Mesh_OrthographicCamera_three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry {\n    constructor(){\n        super();\n        this.setAttribute('position', new _barrel_optimize_names_BufferGeometry_Float32BufferAttribute_Mesh_OrthographicCamera_three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute([\n            -1,\n            3,\n            0,\n            -1,\n            -1,\n            0,\n            3,\n            -1,\n            0\n        ], 3));\n        this.setAttribute('uv', new _barrel_optimize_names_BufferGeometry_Float32BufferAttribute_Mesh_OrthographicCamera_three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute([\n            0,\n            2,\n            0,\n            0,\n            2,\n            0\n        ], 2));\n    }\n}\nconst _geometry = new FullscreenTriangleGeometry();\nclass FullScreenQuad {\n    dispose() {\n        this._mesh.geometry.dispose();\n    }\n    render(renderer) {\n        renderer.render(this._mesh, _camera);\n    }\n    get material() {\n        return this._mesh.material;\n    }\n    set material(value) {\n        this._mesh.material = value;\n    }\n    constructor(material){\n        this._mesh = new _barrel_optimize_names_BufferGeometry_Float32BufferAttribute_Mesh_OrthographicCamera_three__WEBPACK_IMPORTED_MODULE_0__.Mesh(_geometry, material);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvUGFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFLZTtBQUVmLE1BQU1JO0lBb0JMQyxVQUErQixDQUFDO0lBRWhDQyxTQUF5RTtRQUV4RUMsUUFBUUMsS0FBSyxDQUFFO0lBRWhCO0lBRUFDLFVBQVUsQ0FBQztJQTFCWCxhQUFjO1FBRWIsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFFZCx3REFBd0Q7UUFDeEQsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFFZixtRkFBbUY7UUFDbkYsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFFakIsOERBQThEO1FBQzlELElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBRWIsNkdBQTZHO1FBQzdHLElBQUksQ0FBQ0MsY0FBYyxHQUFHO0lBRXZCO0FBWUQ7QUFFQSx1RUFBdUU7QUFFdkUsTUFBTUMsVUFBVSxJQUFJYiwwSUFBa0JBLENBQUUsQ0FBRSxHQUFHLEdBQUcsR0FBRyxDQUFFLEdBQUcsR0FBRztBQUUzRCxnREFBZ0Q7QUFFaEQsTUFBTWMsbUNBQW1DaEIsc0lBQWNBO0lBRXRELGFBQWM7UUFFYixLQUFLO1FBRUwsSUFBSSxDQUFDaUIsWUFBWSxDQUFFLFlBQVksSUFBSWhCLDhJQUFzQkEsQ0FBRTtZQUFFLENBQUU7WUFBRztZQUFHO1lBQUcsQ0FBRTtZQUFHLENBQUU7WUFBRztZQUFHO1lBQUcsQ0FBRTtZQUFHO1NBQUcsRUFBRTtRQUNsRyxJQUFJLENBQUNnQixZQUFZLENBQUUsTUFBTSxJQUFJaEIsOElBQXNCQSxDQUFFO1lBQUU7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUcsRUFBRTtJQUU1RTtBQUVEO0FBRUEsTUFBTWlCLFlBQVksSUFBSUY7QUFFdEIsTUFBTUc7SUFRTFYsVUFBVTtRQUVULElBQUksQ0FBQ1csS0FBSyxDQUFDQyxRQUFRLENBQUNaLE9BQU87SUFFNUI7SUFFQUgsT0FBUWdCLFFBQVEsRUFBRztRQUVsQkEsU0FBU2hCLE1BQU0sQ0FBRSxJQUFJLENBQUNjLEtBQUssRUFBRUw7SUFFOUI7SUFFQSxJQUFJUSxXQUFXO1FBRWQsT0FBTyxJQUFJLENBQUNILEtBQUssQ0FBQ0csUUFBUTtJQUUzQjtJQUVBLElBQUlBLFNBQVVDLEtBQUssRUFBRztRQUVyQixJQUFJLENBQUNKLEtBQUssQ0FBQ0csUUFBUSxHQUFHQztJQUV2QjtJQTVCQSxZQUFhRCxRQUFRLENBQUc7UUFFdkIsSUFBSSxDQUFDSCxLQUFLLEdBQUcsSUFBSWpCLDRIQUFJQSxDQUFFZSxXQUFXSztJQUVuQztBQTBCRDtBQUVnQyIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9QYXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEJ1ZmZlckdlb21ldHJ5LFxuXHRGbG9hdDMyQnVmZmVyQXR0cmlidXRlLFxuXHRPcnRob2dyYXBoaWNDYW1lcmEsXG5cdE1lc2hcbn0gZnJvbSAndGhyZWUnO1xuXG5jbGFzcyBQYXNzIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMuaXNQYXNzID0gdHJ1ZTtcblxuXHRcdC8vIGlmIHNldCB0byB0cnVlLCB0aGUgcGFzcyBpcyBwcm9jZXNzZWQgYnkgdGhlIGNvbXBvc2VyXG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuXHRcdC8vIGlmIHNldCB0byB0cnVlLCB0aGUgcGFzcyBpbmRpY2F0ZXMgdG8gc3dhcCByZWFkIGFuZCB3cml0ZSBidWZmZXIgYWZ0ZXIgcmVuZGVyaW5nXG5cdFx0dGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xuXG5cdFx0Ly8gaWYgc2V0IHRvIHRydWUsIHRoZSBwYXNzIGNsZWFycyBpdHMgYnVmZmVyIGJlZm9yZSByZW5kZXJpbmdcblx0XHR0aGlzLmNsZWFyID0gZmFsc2U7XG5cblx0XHQvLyBpZiBzZXQgdG8gdHJ1ZSwgdGhlIHJlc3VsdCBvZiB0aGUgcGFzcyBpcyByZW5kZXJlZCB0byBzY3JlZW4uIFRoaXMgaXMgc2V0IGF1dG9tYXRpY2FsbHkgYnkgRWZmZWN0Q29tcG9zZXIuXG5cdFx0dGhpcy5yZW5kZXJUb1NjcmVlbiA9IGZhbHNlO1xuXG5cdH1cblxuXHRzZXRTaXplKCAvKiB3aWR0aCwgaGVpZ2h0ICovICkge31cblxuXHRyZW5kZXIoIC8qIHJlbmRlcmVyLCB3cml0ZUJ1ZmZlciwgcmVhZEJ1ZmZlciwgZGVsdGFUaW1lLCBtYXNrQWN0aXZlICovICkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlBhc3M6IC5yZW5kZXIoKSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGRlcml2ZWQgcGFzcy4nICk7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7fVxuXG59XG5cbi8vIEhlbHBlciBmb3IgcGFzc2VzIHRoYXQgbmVlZCB0byBmaWxsIHRoZSB2aWV3cG9ydCB3aXRoIGEgc2luZ2xlIHF1YWQuXG5cbmNvbnN0IF9jYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCAtIDEsIDEsIDEsIC0gMSwgMCwgMSApO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjEzNThcblxuY2xhc3MgRnVsbHNjcmVlblRyaWFuZ2xlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBbIC0gMSwgMywgMCwgLSAxLCAtIDEsIDAsIDMsIC0gMSwgMCBdLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFsgMCwgMiwgMCwgMCwgMiwgMCBdLCAyICkgKTtcblxuXHR9XG5cbn1cblxuY29uc3QgX2dlb21ldHJ5ID0gbmV3IEZ1bGxzY3JlZW5UcmlhbmdsZUdlb21ldHJ5KCk7XG5cbmNsYXNzIEZ1bGxTY3JlZW5RdWFkIHtcblxuXHRjb25zdHJ1Y3RvciggbWF0ZXJpYWwgKSB7XG5cblx0XHR0aGlzLl9tZXNoID0gbmV3IE1lc2goIF9nZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMuX21lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXG5cdH1cblxuXHRyZW5kZXIoIHJlbmRlcmVyICkge1xuXG5cdFx0cmVuZGVyZXIucmVuZGVyKCB0aGlzLl9tZXNoLCBfY2FtZXJhICk7XG5cblx0fVxuXG5cdGdldCBtYXRlcmlhbCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9tZXNoLm1hdGVyaWFsO1xuXG5cdH1cblxuXHRzZXQgbWF0ZXJpYWwoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5fbWVzaC5tYXRlcmlhbCA9IHZhbHVlO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBQYXNzLCBGdWxsU2NyZWVuUXVhZCB9O1xuIl0sIm5hbWVzIjpbIkJ1ZmZlckdlb21ldHJ5IiwiRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIk1lc2giLCJQYXNzIiwic2V0U2l6ZSIsInJlbmRlciIsImNvbnNvbGUiLCJlcnJvciIsImRpc3Bvc2UiLCJpc1Bhc3MiLCJlbmFibGVkIiwibmVlZHNTd2FwIiwiY2xlYXIiLCJyZW5kZXJUb1NjcmVlbiIsIl9jYW1lcmEiLCJGdWxsc2NyZWVuVHJpYW5nbGVHZW9tZXRyeSIsInNldEF0dHJpYnV0ZSIsIl9nZW9tZXRyeSIsIkZ1bGxTY3JlZW5RdWFkIiwiX21lc2giLCJnZW9tZXRyeSIsInJlbmRlcmVyIiwibWF0ZXJpYWwiLCJ2YWx1ZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three/examples/jsm/postprocessing/Pass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/generators/fps-renderer-3d.tsx":
/*!*******************************************************!*\
  !*** ./src/components/generators/fps-renderer-3d.tsx ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FPSRenderer3D: () => (/* binding */ FPSRenderer3D)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/web/Html.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/Sky.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/Stars.js\");\n/* harmony import */ var _react_three_postprocessing__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @react-three/postprocessing */ \"(app-pages-browser)/./node_modules/@react-three/postprocessing/dist/index.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var simplex_noise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! simplex-noise */ \"(app-pages-browser)/./node_modules/simplex-noise/dist/esm/simplex-noise.js\");\n/* harmony import */ var _hooks_useGamepadController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/hooks/useGamepadController */ \"(app-pages-browser)/./src/hooks/useGamepadController.ts\");\n/**\n * @file fps-renderer-3d.tsx\n * @description Professional AAA-Quality FPS Renderer \n * @version 4.0.0 - High-End Gaming Quality\n * @author Galactic Clans Development Team\n * \n * @features\n * - Advanced multi-octave terrain generation\n * - Professional lighting with high-quality shadows\n * - Instanced foliage system for performance\n * - Realistic water simulation\n * - Enhanced FPS controls with smooth movement\n * - Professional visual effects\n */ /* __next_internal_client_entry_do_not_use__ FPSRenderer3D auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$();\n\n\n\n\n\n\n\n// Advanced terrain generation engine\nclass ProfessionalTerrainEngine {\n    // Multi-octave terrain height with geological realism\n    getTerrainHeight(x, z) {\n        const scale = 0.01;\n        const amplitude = 20;\n        // Base terrain with multiple octaves for detail\n        let height = 0;\n        let currentAmplitude = amplitude;\n        let currentScale = scale;\n        // 8 octaves for highly detailed terrain\n        for(let i = 0; i < 8; i++){\n            height += this.noise2D(x * currentScale, z * currentScale) * currentAmplitude;\n            currentAmplitude *= 0.5;\n            currentScale *= 2.1;\n        }\n        // Ridge features for mountain ranges\n        const ridges = Math.abs(this.ridgeNoise(x * 0.003, z * 0.003)) * 12;\n        height += ridges;\n        // Erosion effects for realistic valleys\n        const erosion = this.erosionNoise(x * 0.015, z * 0.015) * 3;\n        height = Math.max(height - Math.abs(erosion), -1.5);\n        return height;\n    }\n    // Determine biome for realistic coloring\n    getBiome(x, z) {\n        const height = this.getTerrainHeight(x, z);\n        const moisture = this.noise2D(x * 0.002, z * 0.002);\n        const temperature = this.noise2D(x * 0.001, z * 0.001);\n        if (height < 0) return 'water';\n        if (height < 3) return moisture > 0.2 ? 'swamp' : 'beach';\n        if (height < 8) {\n            if (temperature > 0.3) return moisture > 0 ? 'forest' : 'grassland';\n            return 'tundra';\n        }\n        if (height < 18) return temperature > 0 ? 'mountain' : 'snow';\n        return 'snow';\n    }\n    constructor(){\n        this.noise2D = (0,simplex_noise__WEBPACK_IMPORTED_MODULE_2__.createNoise2D)();\n        this.noise3D = (0,simplex_noise__WEBPACK_IMPORTED_MODULE_2__.createNoise3D)();\n        this.ridgeNoise = (0,simplex_noise__WEBPACK_IMPORTED_MODULE_2__.createNoise2D)();\n        this.erosionNoise = (0,simplex_noise__WEBPACK_IMPORTED_MODULE_2__.createNoise2D)();\n    }\n}\n// Professional water simulation with realistic waves\nfunction ProfessionalWaterSystem() {\n    _s();\n    const waterRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D)({\n        \"ProfessionalWaterSystem.useFrame\": (state)=>{\n            if (!waterRef.current) return;\n            const time = state.clock.elapsedTime;\n            const geometry = waterRef.current.geometry;\n            const positions = geometry.attributes.position.array;\n            // Create realistic wave motion\n            for(let i = 0; i < positions.length; i += 3){\n                const x = positions[i];\n                const z = positions[i + 2];\n                positions[i + 1] = Math.sin(time * 0.8 + x * 0.02) * 0.15 + Math.cos(time * 1.2 + z * 0.025) * 0.1 + Math.sin(time * 0.5 + (x + z) * 0.01) * 0.05;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            geometry.computeVertexNormals();\n        }\n    }[\"ProfessionalWaterSystem.useFrame\"]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n        ref: waterRef,\n        position: [\n            0,\n            -0.8,\n            0\n        ],\n        rotation: [\n            -Math.PI / 2,\n            0,\n            0\n        ],\n        receiveShadow: true,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                args: [\n                    800,\n                    800,\n                    128,\n                    128\n                ]\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 128,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshStandardMaterial\", {\n                color: \"#1e40af\",\n                transparent: true,\n                opacity: 0.7,\n                roughness: 0.05,\n                metalness: 0.1,\n                envMapIntensity: 2\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 129,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n        lineNumber: 127,\n        columnNumber: 3\n    }, this);\n}\n_s(ProfessionalWaterSystem, \"gk7H3b1Z+0pThM8KOrriM4ByL2U=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D\n    ];\n});\n_c = ProfessionalWaterSystem;\n// Advanced terrain system with LOD and biome coloring\nfunction ProfessionalTerrainSystem(param) {\n    let { terrainEngine } = param;\n    _s1();\n    const { camera } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C)();\n    const [chunks, setChunks] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Map());\n    // Professional terrain material\n    const terrainMaterial = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ProfessionalTerrainSystem.useMemo[terrainMaterial]\": ()=>{\n            return new three__WEBPACK_IMPORTED_MODULE_5__.MeshStandardMaterial({\n                vertexColors: true,\n                roughness: 0.85,\n                metalness: 0.05\n            });\n        }\n    }[\"ProfessionalTerrainSystem.useMemo[terrainMaterial]\"], []);\n    // Generate highly detailed terrain chunk\n    const generateTerrainChunk = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ProfessionalTerrainSystem.useCallback[generateTerrainChunk]\": function(chunkX, chunkZ) {\n            let detail = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 96;\n            const size = 40;\n            const geometry = new three__WEBPACK_IMPORTED_MODULE_5__.PlaneGeometry(size, size, detail, detail);\n            const positions = geometry.attributes.position.array;\n            const colors = new Float32Array(positions.length);\n            // Generate heightmap with biome-based coloring\n            for(let i = 0; i < positions.length; i += 3){\n                const localX = positions[i];\n                const localZ = positions[i + 2];\n                const worldX = chunkX * size + localX;\n                const worldZ = chunkZ * size + localZ;\n                // Set realistic height\n                positions[i + 1] = terrainEngine.getTerrainHeight(worldX, worldZ);\n                // Professional biome coloring\n                const biome = terrainEngine.getBiome(worldX, worldZ);\n                let r = 0.4, g = 0.6, b = 0.3; // Default grassland\n                switch(biome){\n                    case 'water':\n                        r = 0.1;\n                        g = 0.2;\n                        b = 0.8;\n                        break;\n                    case 'beach':\n                        r = 0.9;\n                        g = 0.8;\n                        b = 0.6;\n                        break;\n                    case 'swamp':\n                        r = 0.2;\n                        g = 0.4;\n                        b = 0.2;\n                        break;\n                    case 'forest':\n                        r = 0.15;\n                        g = 0.5;\n                        b = 0.15;\n                        break;\n                    case 'mountain':\n                        r = 0.5;\n                        g = 0.4;\n                        b = 0.3;\n                        break;\n                    case 'tundra':\n                        r = 0.6;\n                        g = 0.6;\n                        b = 0.5;\n                        break;\n                    case 'snow':\n                        r = 0.95;\n                        g = 0.95;\n                        b = 0.95;\n                        break;\n                }\n                // Add height-based variation\n                const heightFactor = Math.max(0, positions[i + 1]) * 0.02;\n                colors[i] = Math.min(1, r + heightFactor);\n                colors[i + 1] = Math.min(1, g + heightFactor);\n                colors[i + 2] = Math.min(1, b + heightFactor);\n            }\n            geometry.setAttribute('color', new three__WEBPACK_IMPORTED_MODULE_5__.BufferAttribute(colors, 3));\n            geometry.computeVertexNormals();\n            geometry.rotateX(-Math.PI / 2);\n            return geometry;\n        }\n    }[\"ProfessionalTerrainSystem.useCallback[generateTerrainChunk]\"], [\n        terrainEngine\n    ]);\n    // Intelligent LOD management\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D)({\n        \"ProfessionalTerrainSystem.useFrame\": ()=>{\n            const cameraPos = camera.position;\n            const renderDistance = 6;\n            const newChunks = new Map();\n            for(let x = -renderDistance; x <= renderDistance; x++){\n                for(let z = -renderDistance; z <= renderDistance; z++){\n                    const chunkX = Math.floor(cameraPos.x / 40) + x;\n                    const chunkZ = Math.floor(cameraPos.z / 40) + z;\n                    const key = \"\".concat(chunkX, \",\").concat(chunkZ);\n                    if (!chunks.has(key)) {\n                        const distance = Math.sqrt(x * x + z * z);\n                        const detail = distance < 2 ? 96 : distance < 4 ? 64 : 32;\n                        const geometry = generateTerrainChunk(chunkX, chunkZ, detail);\n                        newChunks.set(key, geometry);\n                    } else {\n                        newChunks.set(key, chunks.get(key));\n                    }\n                }\n            }\n            // Clean up distant chunks\n            chunks.forEach({\n                \"ProfessionalTerrainSystem.useFrame\": (geometry, key)=>{\n                    if (!newChunks.has(key)) {\n                        geometry.dispose();\n                    }\n                }\n            }[\"ProfessionalTerrainSystem.useFrame\"]);\n            setChunks(newChunks);\n        }\n    }[\"ProfessionalTerrainSystem.useFrame\"]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: Array.from(chunks.entries()).map((param)=>{\n            let [key, geometry] = param;\n            const [chunkX, chunkZ] = key.split(',').map(Number);\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                geometry: geometry,\n                material: terrainMaterial,\n                position: [\n                    chunkX * 40,\n                    0,\n                    chunkZ * 40\n                ],\n                castShadow: true,\n                receiveShadow: true\n            }, key, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 238,\n                columnNumber: 6\n            }, this);\n        })\n    }, void 0, false);\n}\n_s1(ProfessionalTerrainSystem, \"CdXElnYYAJWx+CzGlKMs0obQSzs=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D\n    ];\n});\n_c1 = ProfessionalTerrainSystem;\n// Professional foliage system with instancing\nfunction ProfessionalFoliageSystem(param) {\n    let { terrainEngine } = param;\n    _s2();\n    const instancedTreesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const instancedGrassRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ProfessionalFoliageSystem.useEffect\": ()=>{\n            if (!instancedTreesRef.current || !instancedGrassRef.current) return;\n            const treeCount = 800;\n            const grassCount = 2000;\n            const matrix = new three__WEBPACK_IMPORTED_MODULE_5__.Matrix4();\n            const color = new three__WEBPACK_IMPORTED_MODULE_5__.Color();\n            // Generate realistic trees\n            for(let i = 0; i < treeCount; i++){\n                const x = (Math.random() - 0.5) * 300;\n                const z = (Math.random() - 0.5) * 300;\n                const y = terrainEngine.getTerrainHeight(x, z);\n                const biome = terrainEngine.getBiome(x, z);\n                if ((biome === 'forest' || biome === 'grassland') && y > 0) {\n                    const scale = 0.8 + Math.random() * 2.0;\n                    matrix.compose(new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(x, y + scale * 0.8, z), new three__WEBPACK_IMPORTED_MODULE_5__.Quaternion().setFromAxisAngle(new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(0, 1, 0), Math.random() * Math.PI * 2), new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(scale, scale, scale));\n                    instancedTreesRef.current.setMatrixAt(i, matrix);\n                    color.setHSL(0.3 + Math.random() * 0.1, 0.7, 0.2 + Math.random() * 0.3);\n                    instancedTreesRef.current.setColorAt(i, color);\n                }\n            }\n            // Generate realistic grass\n            for(let i = 0; i < grassCount; i++){\n                const x = (Math.random() - 0.5) * 400;\n                const z = (Math.random() - 0.5) * 400;\n                const y = terrainEngine.getTerrainHeight(x, z);\n                const biome = terrainEngine.getBiome(x, z);\n                if ((biome === 'grassland' || biome === 'forest') && y > 0) {\n                    const scale = 0.3 + Math.random() * 0.4;\n                    matrix.compose(new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(x, y, z), new three__WEBPACK_IMPORTED_MODULE_5__.Quaternion().setFromAxisAngle(new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(0, 1, 0), Math.random() * Math.PI * 2), new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(scale, scale + Math.random() * 0.8, scale));\n                    instancedGrassRef.current.setMatrixAt(i, matrix);\n                    color.setHSL(0.28, 0.8, 0.25 + Math.random() * 0.4);\n                    instancedGrassRef.current.setColorAt(i, color);\n                }\n            }\n            instancedTreesRef.current.instanceMatrix.needsUpdate = true;\n            if (instancedTreesRef.current.instanceColor) instancedTreesRef.current.instanceColor.needsUpdate = true;\n            instancedGrassRef.current.instanceMatrix.needsUpdate = true;\n            if (instancedGrassRef.current.instanceColor) instancedGrassRef.current.instanceColor.needsUpdate = true;\n        }\n    }[\"ProfessionalFoliageSystem.useEffect\"], [\n        terrainEngine\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedMesh\", {\n                ref: instancedTreesRef,\n                args: [\n                    undefined,\n                    undefined,\n                    800\n                ],\n                castShadow: true,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"cylinderGeometry\", {\n                        args: [\n                            0.15,\n                            0.25,\n                            3\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 316,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshStandardMaterial\", {\n                        roughness: 0.9\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 317,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 315,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"instancedMesh\", {\n                ref: instancedGrassRef,\n                args: [\n                    undefined,\n                    undefined,\n                    2000\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"planeGeometry\", {\n                        args: [\n                            0.15,\n                            0.8\n                        ]\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 321,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshStandardMaterial\", {\n                        transparent: true,\n                        alphaTest: 0.6,\n                        roughness: 0.95,\n                        side: three__WEBPACK_IMPORTED_MODULE_5__.DoubleSide\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 322,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 320,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s2(ProfessionalFoliageSystem, \"bMz0LEphXwVfY1LcGbuk8ilepVA=\");\n_c2 = ProfessionalFoliageSystem;\n// Professional lighting system\nfunction ProfessionalLightingSystem() {\n    _s3();\n    const sunRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [timeOfDay, setTimeOfDay] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0.3);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D)({\n        \"ProfessionalLightingSystem.useFrame\": (state, delta)=>{\n            if (!sunRef.current) return;\n            // Dynamic day/night cycle\n            setTimeOfDay({\n                \"ProfessionalLightingSystem.useFrame\": (prev)=>(prev + delta * 0.01) % 1\n            }[\"ProfessionalLightingSystem.useFrame\"]);\n            const sunAngle = timeOfDay * Math.PI * 2;\n            const sunPosition = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(Math.cos(sunAngle) * 100, Math.sin(sunAngle) * 80 + 20, Math.sin(sunAngle) * 100);\n            sunRef.current.position.copy(sunPosition);\n            sunRef.current.target.position.set(0, 0, 0);\n            // Dynamic intensity and color\n            const dayIntensity = Math.max(0.2, Math.sin(sunAngle) * 0.8 + 0.5);\n            sunRef.current.intensity = dayIntensity;\n            const sunColor = new three__WEBPACK_IMPORTED_MODULE_5__.Color().setHSL(0.08, 0.3, 0.8 + dayIntensity * 0.2);\n            sunRef.current.color = sunColor;\n        }\n    }[\"ProfessionalLightingSystem.useFrame\"]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"directionalLight\", {\n                ref: sunRef,\n                intensity: 1,\n                castShadow: true,\n                \"shadow-mapSize\": [\n                    8192,\n                    8192\n                ],\n                \"shadow-camera-far\": 400,\n                \"shadow-camera-left\": -100,\n                \"shadow-camera-right\": 100,\n                \"shadow-camera-top\": 100,\n                \"shadow-camera-bottom\": -100,\n                \"shadow-bias\": -0.0002,\n                \"shadow-normalBias\": 0.02\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 364,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ambientLight\", {\n                color: \"#4A90E2\",\n                intensity: 0.25\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 378,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"hemisphereLight\", {\n                skyColor: \"#87CEEB\",\n                groundColor: \"#2F4F2F\",\n                intensity: 0.4\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 380,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s3(ProfessionalLightingSystem, \"A/64pvfUzJQhSmhBoDSXJQBf80E=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D\n    ];\n});\n_c3 = ProfessionalLightingSystem;\n// Enhanced FPS Arms with professional animation\nfunction ProfessionalFPSArms(param) {\n    let { position, cameraRotation, isMoving, isRunning, isCrouching } = param;\n    _s4();\n    const armsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { camera } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C)();\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D)({\n        \"ProfessionalFPSArms.useFrame\": (state, delta)=>{\n            if (!armsRef.current) return;\n            // Arms should follow camera position exactly\n            const cameraPosition = camera.position.clone();\n            armsRef.current.position.copy(cameraPosition);\n            // Arms should match camera rotation exactly\n            armsRef.current.rotation.order = 'YXZ';\n            armsRef.current.rotation.y = cameraRotation.yaw;\n            armsRef.current.rotation.x = cameraRotation.pitch;\n            armsRef.current.rotation.z = 0;\n            const time = state.clock.elapsedTime;\n            // Professional movement animation with offset from camera\n            if (isMoving) {\n                const speed = isRunning ? 12 : 8;\n                const intensity = isRunning ? 0.012 : 0.008;\n                const walkBob = Math.sin(time * speed) * intensity;\n                const walkSway = Math.cos(time * speed * 0.5) * intensity * 0.5;\n                // Apply movement animation as offset from camera position\n                armsRef.current.position.y += walkBob;\n                armsRef.current.position.x += walkSway;\n                armsRef.current.rotation.z += walkSway * 2;\n            } else {\n                // Breathing animation\n                const breathingIntensity = 0.002;\n                const breathingOffset = Math.sin(time * 1.2) * breathingIntensity;\n                armsRef.current.position.y += breathingOffset;\n            }\n            // Slight offset for crouch\n            if (isCrouching) {\n                armsRef.current.position.y -= 0.3;\n            }\n        }\n    }[\"ProfessionalFPSArms.useFrame\"]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n        ref: armsRef,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n                position: [\n                    -0.4,\n                    -0.3,\n                    0.2\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                        position: [\n                            0,\n                            -0.15,\n                            0\n                        ],\n                        castShadow: true,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"cylinderGeometry\", {\n                                args: [\n                                    0.05,\n                                    0.06,\n                                    0.35\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 451,\n                                columnNumber: 6\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshStandardMaterial\", {\n                                color: \"#F5DEB3\",\n                                roughness: 0.8\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 452,\n                                columnNumber: 6\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 450,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                        position: [\n                            0,\n                            -0.4,\n                            0.15\n                        ],\n                        castShadow: true,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"cylinderGeometry\", {\n                                args: [\n                                    0.04,\n                                    0.05,\n                                    0.28\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 455,\n                                columnNumber: 6\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshStandardMaterial\", {\n                                color: \"#F5DEB3\",\n                                roughness: 0.8\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 456,\n                                columnNumber: 6\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 454,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                        position: [\n                            0,\n                            -0.55,\n                            0.25\n                        ],\n                        castShadow: true,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"boxGeometry\", {\n                                args: [\n                                    0.08,\n                                    0.1,\n                                    0.15\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 459,\n                                columnNumber: 6\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshStandardMaterial\", {\n                                color: \"#F5DEB3\",\n                                roughness: 0.9\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 460,\n                                columnNumber: 6\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 458,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 449,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n                position: [\n                    0.4,\n                    -0.3,\n                    0.2\n                ],\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                        position: [\n                            0,\n                            -0.15,\n                            0\n                        ],\n                        castShadow: true,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"cylinderGeometry\", {\n                                args: [\n                                    0.05,\n                                    0.06,\n                                    0.35\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 467,\n                                columnNumber: 6\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshStandardMaterial\", {\n                                color: \"#F5DEB3\",\n                                roughness: 0.8\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 468,\n                                columnNumber: 6\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 466,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                        position: [\n                            0,\n                            -0.4,\n                            0.15\n                        ],\n                        castShadow: true,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"cylinderGeometry\", {\n                                args: [\n                                    0.04,\n                                    0.05,\n                                    0.28\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 471,\n                                columnNumber: 6\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshStandardMaterial\", {\n                                color: \"#F5DEB3\",\n                                roughness: 0.8\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 472,\n                                columnNumber: 6\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 470,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                        position: [\n                            0,\n                            -0.55,\n                            0.25\n                        ],\n                        castShadow: true,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"boxGeometry\", {\n                                args: [\n                                    0.08,\n                                    0.1,\n                                    0.15\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 475,\n                                columnNumber: 6\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshStandardMaterial\", {\n                                color: \"#F5DEB3\",\n                                roughness: 0.9\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 476,\n                                columnNumber: 6\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 474,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 465,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n        lineNumber: 447,\n        columnNumber: 3\n    }, this);\n}\n_s4(ProfessionalFPSArms, \"AejAwftMjsPKqbHZxeTqEBGU4+U=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D\n    ];\n});\n_c4 = ProfessionalFPSArms;\n// Professional FPS Player Controller\nfunction ProfessionalFPSPlayer(param) {\n    let { config } = param;\n    _s5();\n    const playerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { camera, gl } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C)();\n    const [isPointerLocked, setIsPointerLocked] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const terrainEngine = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ProfessionalFPSPlayer.useMemo[terrainEngine]\": ()=>new ProfessionalTerrainEngine()\n    }[\"ProfessionalFPSPlayer.useMemo[terrainEngine]\"], []);\n    // Professional FPS camera rotation state\n    const cameraRotation = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        yaw: 0,\n        pitch: 0,\n        targetYaw: 0,\n        targetPitch: 0\n    });\n    const movement = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        forward: false,\n        backward: false,\n        left: false,\n        right: false,\n        jump: false,\n        run: false,\n        crouch: false,\n        forwardAmount: 0,\n        backwardAmount: 0,\n        leftAmount: 0,\n        rightAmount: 0\n    });\n    const { gamepadState, isConnected: isGamepadConnected } = (0,_hooks_useGamepadController__WEBPACK_IMPORTED_MODULE_3__.useGamepadController)({\n        deadzone: 0.2,\n        enableHaptics: true,\n        actions: {\n            onPrimaryAction: {\n                \"ProfessionalFPSPlayer.useGamepadController\": ()=>movement.current.jump = true\n            }[\"ProfessionalFPSPlayer.useGamepadController\"],\n            onSecondaryAction: {\n                \"ProfessionalFPSPlayer.useGamepadController\": ()=>movement.current.run = !movement.current.run\n            }[\"ProfessionalFPSPlayer.useGamepadController\"],\n            onBackAction: {\n                \"ProfessionalFPSPlayer.useGamepadController\": ()=>{\n                    if (document.pointerLockElement) {\n                        document.exitPointerLock();\n                    }\n                }\n            }[\"ProfessionalFPSPlayer.useGamepadController\"]\n        }\n    });\n    // Professional FPS camera positioning - matches industry standards\n    const getInitialPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ProfessionalFPSPlayer.useCallback[getInitialPosition]\": ()=>{\n            const terrainHeight = terrainEngine.getTerrainHeight(0, 0);\n            const groundLevel = Math.max(terrainHeight + 1.75, 1.75); // Standard player height\n            return new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(0, groundLevel, 0);\n        }\n    }[\"ProfessionalFPSPlayer.useCallback[getInitialPosition]\"], [\n        terrainEngine\n    ]);\n    const [position, setPosition] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(getInitialPosition());\n    const [velocity, setVelocity] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new three__WEBPACK_IMPORTED_MODULE_5__.Vector3());\n    const [horizontalVelocity, setHorizontalVelocity] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new three__WEBPACK_IMPORTED_MODULE_5__.Vector3());\n    const [isMoving, setIsMoving] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Initialize professional FPS camera settings\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ProfessionalFPSPlayer.useEffect\": ()=>{\n            if (camera) {\n                // Professional FPS camera settings (industry standard)\n                camera.fov = 90; // Standard FPS FOV (Call of Duty, Counter-Strike style)\n                camera.near = 0.01; // Very close near plane for weapon visibility\n                camera.far = 1000; // Reasonable far plane for performance\n                camera.position.copy(getInitialPosition());\n                // Professional FPS camera positioning\n                const eyeHeight = 1.62; // Standard eye height (5'4\" person)\n                camera.position.y += eyeHeight;\n                // Look straight ahead initially (industry standard)\n                camera.rotation.set(0, 0, 0);\n                camera.updateProjectionMatrix();\n                // Initialize camera rotation state\n                cameraRotation.current.yaw = 0;\n                cameraRotation.current.pitch = 0;\n                cameraRotation.current.targetYaw = 0;\n                cameraRotation.current.targetPitch = 0;\n            }\n        }\n    }[\"ProfessionalFPSPlayer.useEffect\"], [\n        camera,\n        getInitialPosition\n    ]);\n    // Professional keyboard controls\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ProfessionalFPSPlayer.useEffect\": ()=>{\n            const handleKeyDown = {\n                \"ProfessionalFPSPlayer.useEffect.handleKeyDown\": (event)=>{\n                    switch(event.code){\n                        case 'KeyW':\n                            movement.current.forward = true;\n                            break;\n                        case 'KeyS':\n                            movement.current.backward = true;\n                            break;\n                        case 'KeyA':\n                            movement.current.left = true;\n                            break;\n                        case 'KeyD':\n                            movement.current.right = true;\n                            break;\n                        case 'Space':\n                            movement.current.jump = true;\n                            event.preventDefault();\n                            break;\n                        case 'ShiftLeft':\n                            movement.current.run = true;\n                            break;\n                        case 'ControlLeft':\n                            movement.current.crouch = true;\n                            break;\n                        case 'Escape':\n                            if (document.pointerLockElement) {\n                                document.exitPointerLock();\n                            }\n                            break;\n                    }\n                }\n            }[\"ProfessionalFPSPlayer.useEffect.handleKeyDown\"];\n            const handleKeyUp = {\n                \"ProfessionalFPSPlayer.useEffect.handleKeyUp\": (event)=>{\n                    switch(event.code){\n                        case 'KeyW':\n                            movement.current.forward = false;\n                            break;\n                        case 'KeyS':\n                            movement.current.backward = false;\n                            break;\n                        case 'KeyA':\n                            movement.current.left = false;\n                            break;\n                        case 'KeyD':\n                            movement.current.right = false;\n                            break;\n                        case 'Space':\n                            movement.current.jump = false;\n                            break;\n                        case 'ShiftLeft':\n                            movement.current.run = false;\n                            break;\n                        case 'ControlLeft':\n                            movement.current.crouch = false;\n                            break;\n                    }\n                }\n            }[\"ProfessionalFPSPlayer.useEffect.handleKeyUp\"];\n            document.addEventListener('keydown', handleKeyDown);\n            document.addEventListener('keyup', handleKeyUp);\n            return ({\n                \"ProfessionalFPSPlayer.useEffect\": ()=>{\n                    document.removeEventListener('keydown', handleKeyDown);\n                    document.removeEventListener('keyup', handleKeyUp);\n                }\n            })[\"ProfessionalFPSPlayer.useEffect\"];\n        }\n    }[\"ProfessionalFPSPlayer.useEffect\"], []);\n    // Professional pointer lock setup\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ProfessionalFPSPlayer.useEffect\": ()=>{\n            const handlePointerLockChange = {\n                \"ProfessionalFPSPlayer.useEffect.handlePointerLockChange\": ()=>{\n                    const isLocked = document.pointerLockElement === gl.domElement;\n                    setIsPointerLocked(isLocked);\n                }\n            }[\"ProfessionalFPSPlayer.useEffect.handlePointerLockChange\"];\n            const handleClick = {\n                \"ProfessionalFPSPlayer.useEffect.handleClick\": ()=>{\n                    if (!isPointerLocked) {\n                        gl.domElement.requestPointerLock();\n                    }\n                }\n            }[\"ProfessionalFPSPlayer.useEffect.handleClick\"];\n            document.addEventListener('pointerlockchange', handlePointerLockChange);\n            gl.domElement.addEventListener('click', handleClick);\n            return ({\n                \"ProfessionalFPSPlayer.useEffect\": ()=>{\n                    document.removeEventListener('pointerlockchange', handlePointerLockChange);\n                    gl.domElement.removeEventListener('click', handleClick);\n                }\n            })[\"ProfessionalFPSPlayer.useEffect\"];\n        }\n    }[\"ProfessionalFPSPlayer.useEffect\"], [\n        gl.domElement,\n        isPointerLocked\n    ]);\n    // Professional mouse look with industry-standard sensitivity\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ProfessionalFPSPlayer.useEffect\": ()=>{\n            if (!isPointerLocked) return;\n            const handleMouseMove = {\n                \"ProfessionalFPSPlayer.useEffect.handleMouseMove\": (event)=>{\n                    // Professional FPS sensitivity (matches CS:GO/Call of Duty standards)\n                    const sensitivity = config.player.mouseSensitivity * 0.002;\n                    cameraRotation.current.targetYaw -= event.movementX * sensitivity;\n                    cameraRotation.current.targetPitch -= event.movementY * sensitivity;\n                    // Industry standard pitch limits (90 degrees up/down)\n                    cameraRotation.current.targetPitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, cameraRotation.current.targetPitch));\n                }\n            }[\"ProfessionalFPSPlayer.useEffect.handleMouseMove\"];\n            document.addEventListener('mousemove', handleMouseMove);\n            return ({\n                \"ProfessionalFPSPlayer.useEffect\": ()=>document.removeEventListener('mousemove', handleMouseMove)\n            })[\"ProfessionalFPSPlayer.useEffect\"];\n        }\n    }[\"ProfessionalFPSPlayer.useEffect\"], [\n        isPointerLocked,\n        config.player.mouseSensitivity\n    ]);\n    // Professional physics and movement\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D)({\n        \"ProfessionalFPSPlayer.useFrame\": (state, delta)=>{\n            if (!playerRef.current) return;\n            // Professional camera smoothing (responsive but stable)\n            const cameraSmoothing = 25; // Industry standard responsiveness\n            cameraRotation.current.yaw = three__WEBPACK_IMPORTED_MODULE_5__.MathUtils.lerp(cameraRotation.current.yaw, cameraRotation.current.targetYaw, cameraSmoothing * delta);\n            cameraRotation.current.pitch = three__WEBPACK_IMPORTED_MODULE_5__.MathUtils.lerp(cameraRotation.current.pitch, cameraRotation.current.targetPitch, cameraSmoothing * delta);\n            // Apply professional FPS camera rotation\n            camera.rotation.order = 'YXZ';\n            camera.rotation.y = cameraRotation.current.yaw;\n            camera.rotation.x = cameraRotation.current.pitch;\n            camera.rotation.z = 0;\n            // Professional movement system\n            const baseSpeed = movement.current.run ? config.player.runSpeed * 1.5 : config.player.walkSpeed;\n            const crouchMultiplier = movement.current.crouch ? 0.4 : 1.0;\n            const maxSpeed = baseSpeed * crouchMultiplier;\n            const acceleration = 20;\n            const deceleration = 18;\n            const smoothingSpeed = 12;\n            // Input smoothing\n            const targetForward = movement.current.forward ? 1 : 0;\n            const targetBackward = movement.current.backward ? 1 : 0;\n            const targetLeft = movement.current.left ? 1 : 0;\n            const targetRight = movement.current.right ? 1 : 0;\n            movement.current.forwardAmount = three__WEBPACK_IMPORTED_MODULE_5__.MathUtils.lerp(movement.current.forwardAmount, targetForward, smoothingSpeed * delta);\n            movement.current.backwardAmount = three__WEBPACK_IMPORTED_MODULE_5__.MathUtils.lerp(movement.current.backwardAmount, targetBackward, smoothingSpeed * delta);\n            movement.current.leftAmount = three__WEBPACK_IMPORTED_MODULE_5__.MathUtils.lerp(movement.current.leftAmount, targetLeft, smoothingSpeed * delta);\n            movement.current.rightAmount = three__WEBPACK_IMPORTED_MODULE_5__.MathUtils.lerp(movement.current.rightAmount, targetRight, smoothingSpeed * delta);\n            const movementIntensity = movement.current.forwardAmount + movement.current.backwardAmount + movement.current.leftAmount + movement.current.rightAmount;\n            setIsMoving(movementIntensity > 0.1);\n            // Professional movement calculation\n            if (isPointerLocked || isGamepadConnected) {\n                const forward = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(0, 0, -1);\n                forward.applyQuaternion(camera.quaternion);\n                forward.y = 0;\n                forward.normalize();\n                const right = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(1, 0, 0);\n                right.applyQuaternion(camera.quaternion);\n                right.normalize();\n                let inputVector = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(0, 0, 0);\n                inputVector.add(forward.clone().multiplyScalar(movement.current.forwardAmount - movement.current.backwardAmount));\n                inputVector.add(right.clone().multiplyScalar(movement.current.rightAmount - movement.current.leftAmount));\n                if (isGamepadConnected && gamepadState) {\n                    const leftStickX = gamepadState.leftStick.x || 0;\n                    const leftStickY = gamepadState.leftStick.y || 0;\n                    inputVector.add(forward.clone().multiplyScalar(-leftStickY));\n                    inputVector.add(right.clone().multiplyScalar(leftStickX));\n                }\n                if (inputVector.length() > 1) {\n                    inputVector.normalize();\n                }\n                const targetVelocity = inputVector.multiplyScalar(maxSpeed);\n                const currentHorizontalVel = horizontalVelocity.clone();\n                const velDiff = targetVelocity.clone().sub(currentHorizontalVel);\n                const accelRate = velDiff.length() > 0.1 ? acceleration : deceleration;\n                const newHorizontalVel = currentHorizontalVel.add(velDiff.multiplyScalar(accelRate * delta));\n                if (newHorizontalVel.length() > maxSpeed) {\n                    newHorizontalVel.normalize().multiplyScalar(maxSpeed);\n                }\n                setHorizontalVelocity(newHorizontalVel);\n                // Gamepad camera with professional sensitivity\n                if (isGamepadConnected && gamepadState && isPointerLocked) {\n                    const rightStickX = gamepadState.rightStick.x || 0;\n                    const rightStickY = gamepadState.rightStick.y || 0;\n                    const gamepadSensitivity = config.player.mouseSensitivity * 0.04;\n                    cameraRotation.current.targetYaw -= rightStickX * gamepadSensitivity * delta;\n                    cameraRotation.current.targetPitch -= rightStickY * gamepadSensitivity * delta;\n                    cameraRotation.current.targetPitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, cameraRotation.current.targetPitch));\n                }\n            } else {\n                const newHorizontalVel = horizontalVelocity.clone().multiplyScalar(Math.pow(0.02, delta));\n                setHorizontalVelocity(newHorizontalVel);\n            }\n            // Professional gravity and jumping\n            const newVelocity = velocity.clone();\n            newVelocity.y -= config.environment.gravity * delta;\n            if (movement.current.jump) {\n                const terrainHeight = terrainEngine.getTerrainHeight(position.x, position.z);\n                const groundLevel = terrainHeight + 1.75; // Standard player height\n                if (Math.abs(position.y - groundLevel) < 0.4) {\n                    newVelocity.y = config.player.jumpHeight * 1.2;\n                    movement.current.jump = false;\n                }\n            }\n            const finalVelocity = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(horizontalVelocity.x, newVelocity.y, horizontalVelocity.z);\n            const newPosition = position.clone().add(finalVelocity.clone().multiplyScalar(delta));\n            // Professional terrain collision\n            const terrainHeight = terrainEngine.getTerrainHeight(newPosition.x, newPosition.z);\n            const groundLevel = terrainHeight + 1.75; // Standard player height\n            if (newPosition.y < groundLevel) {\n                newPosition.y = groundLevel;\n                newVelocity.y = 0;\n            }\n            setPosition(newPosition);\n            setVelocity(newVelocity);\n            // Professional FPS camera positioning (industry standard)\n            const eyeHeight = movement.current.crouch ? 1.2 : 1.62; // 5'4\" eye height standard\n            const cameraPosition = newPosition.clone();\n            cameraPosition.y += eyeHeight;\n            // Instant camera following for professional responsiveness\n            camera.position.copy(cameraPosition);\n        }\n    }[\"ProfessionalFPSPlayer.useFrame\"]);\n    if (!isPointerLocked) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_6__.Html, {\n            center: true,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"pointer-events-auto text-center p-10 bg-gradient-to-br from-black/95 to-slate-900/95 backdrop-blur-lg rounded-2xl border border-cyan-400/50 shadow-2xl\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-white mb-4 text-2xl font-bold bg-gradient-to-r from-cyan-400 to-blue-400 bg-clip-text text-transparent\",\n                        children: \"\\uD83C\\uDFAE Professional FPS\"\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 803,\n                        columnNumber: 6\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-cyan-300 text-lg mb-6 font-medium\",\n                        children: \"Click to enter FPS mode\"\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 806,\n                        columnNumber: 6\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-sm text-slate-300 space-y-3 max-w-md leading-relaxed\",\n                        children: isGamepadConnected ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"font-bold text-cyan-400\",\n                                    children: \"\\uD83C\\uDFAE Controller Ready:\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                    lineNumber: 810,\n                                    columnNumber: 9\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: \"Left Stick: Move • Right Stick: Look\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                    lineNumber: 811,\n                                    columnNumber: 9\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: \"A: Jump • B: Run • Select: Exit\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                    lineNumber: 812,\n                                    columnNumber: 9\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"mt-4 font-bold text-blue-400\",\n                                    children: \"⌨️ Keyboard Available:\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                    lineNumber: 813,\n                                    columnNumber: 9\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: \"WASD: Move • Mouse: Look • Shift: Run\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                    lineNumber: 814,\n                                    columnNumber: 9\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: \"Ctrl: Crouch • Space: Jump • ESC: Exit\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                    lineNumber: 815,\n                                    columnNumber: 9\n                                }, this)\n                            ]\n                        }, void 0, true) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"font-bold text-cyan-400\",\n                                    children: \"⌨️ Professional FPS Controls:\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                    lineNumber: 819,\n                                    columnNumber: 9\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: \"WASD: Move • Mouse: Look around\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                    lineNumber: 820,\n                                    columnNumber: 9\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: \"Shift: Run • Ctrl: Crouch • Space: Jump\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                    lineNumber: 821,\n                                    columnNumber: 9\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: \"ESC: Exit FPS mode\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                    lineNumber: 822,\n                                    columnNumber: 9\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-xs text-cyan-200 mt-2\",\n                                    children: \"90\\xb0 FOV • Professional sensitivity\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                    lineNumber: 823,\n                                    columnNumber: 9\n                                }, this)\n                            ]\n                        }, void 0, true)\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 807,\n                        columnNumber: 6\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 802,\n                columnNumber: 5\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n            lineNumber: 801,\n            columnNumber: 4\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n                ref: playerRef,\n                position: [\n                    position.x,\n                    position.y,\n                    position.z\n                ],\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                    visible: false,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"capsuleGeometry\", {\n                            args: [\n                                config.player.playerRadius,\n                                config.player.playerHeight\n                            ]\n                        }, void 0, false, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                            lineNumber: 836,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meshBasicMaterial\", {}, void 0, false, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                            lineNumber: 837,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                    lineNumber: 835,\n                    columnNumber: 5\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 834,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ProfessionalFPSArms, {\n                position: position,\n                cameraRotation: {\n                    pitch: cameraRotation.current.pitch,\n                    yaw: cameraRotation.current.yaw\n                },\n                isMoving: isMoving,\n                isRunning: movement.current.run,\n                isCrouching: movement.current.crouch\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 841,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s5(ProfessionalFPSPlayer, \"YBps88caJCNnkFe9/bRoxYQS5kY=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C,\n        _hooks_useGamepadController__WEBPACK_IMPORTED_MODULE_3__.useGamepadController,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D\n    ];\n});\n_c5 = ProfessionalFPSPlayer;\n// Main Professional FPS Renderer\nfunction FPSRenderer3D(param) {\n    let { config, onPerformanceUpdate } = param;\n    _s6();\n    const terrainEngine = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"FPSRenderer3D.useMemo[terrainEngine]\": ()=>new ProfessionalTerrainEngine()\n    }[\"FPSRenderer3D.useMemo[terrainEngine]\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full h-full relative bg-gradient-to-b from-blue-900 to-slate-900\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_fiber__WEBPACK_IMPORTED_MODULE_7__.Canvas, {\n            camera: {\n                fov: 90,\n                near: 0.01,\n                far: 1000,\n                position: [\n                    0,\n                    5,\n                    0\n                ] // Will be overridden by FPS player positioning\n            },\n            shadows: \"percentage\",\n            gl: {\n                antialias: true,\n                powerPreference: \"high-performance\",\n                alpha: false,\n                depth: true,\n                stencil: false,\n                preserveDrawingBuffer: false\n            },\n            onCreated: (param)=>{\n                let { gl, scene } = param;\n                gl.setClearColor(new three__WEBPACK_IMPORTED_MODULE_5__.Color('#1e3a8a'), 1);\n                gl.shadowMap.enabled = true;\n                gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap;\n                gl.toneMapping = three__WEBPACK_IMPORTED_MODULE_5__.ACESFilmicToneMapping;\n                gl.toneMappingExposure = 1.2;\n                gl.outputEncoding = three__WEBPACK_IMPORTED_MODULE_5__.sRGBEncoding;\n                scene.fog = new three__WEBPACK_IMPORTED_MODULE_5__.Fog('#1e3a8a', 100, 800);\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n                fallback: null,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_8__.Sky, {\n                        distance: 450000,\n                        sunPosition: [\n                            100,\n                            30,\n                            100\n                        ],\n                        inclination: 0,\n                        azimuth: 0.25,\n                        mieCoefficient: 0.003,\n                        mieDirectionalG: 0.85,\n                        rayleigh: 0.8,\n                        turbidity: 0.5\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 895,\n                        columnNumber: 6\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ProfessionalLightingSystem, {}, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 906,\n                        columnNumber: 6\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ProfessionalTerrainSystem, {\n                        terrainEngine: terrainEngine\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 907,\n                        columnNumber: 6\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ProfessionalWaterSystem, {}, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 908,\n                        columnNumber: 6\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ProfessionalFoliageSystem, {\n                        terrainEngine: terrainEngine\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 909,\n                        columnNumber: 6\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_9__.Stars, {\n                        radius: 500,\n                        depth: 80,\n                        count: 2000,\n                        factor: 6,\n                        saturation: 0,\n                        fade: true,\n                        speed: 1\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 911,\n                        columnNumber: 6\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_postprocessing__WEBPACK_IMPORTED_MODULE_10__.EffectComposer, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_postprocessing__WEBPACK_IMPORTED_MODULE_10__.NormalPass, {}, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 914,\n                                columnNumber: 7\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_postprocessing__WEBPACK_IMPORTED_MODULE_10__.SSAO, {\n                                blurPass: true,\n                                blurRadius: 2,\n                                blurSharpness: 10,\n                                luminanceInfluence: 0.5,\n                                luminanceThreshold: 0.025,\n                                luminanceSmoothing: 0.9,\n                                resolution: 0.5,\n                                blurPass: true\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 915,\n                                columnNumber: 7\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_postprocessing__WEBPACK_IMPORTED_MODULE_10__.Bloom, {\n                                luminanceThreshold: 0.5,\n                                luminanceSmoothing: 0.9,\n                                intensity: 1,\n                                blurPass: true\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 925,\n                                columnNumber: 7\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_postprocessing__WEBPACK_IMPORTED_MODULE_10__.Vignette, {\n                                offset: 0.1,\n                                darkness: 1.2\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 931,\n                                columnNumber: 7\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_postprocessing__WEBPACK_IMPORTED_MODULE_10__.ChromaticAberration, {\n                                blendMode: \"screen\",\n                                offset: [\n                                    0.002,\n                                    0.002\n                                ]\n                            }, void 0, false, {\n                                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                                lineNumber: 935,\n                                columnNumber: 7\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 913,\n                        columnNumber: 6\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ProfessionalFPSPlayer, {\n                        config: config\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                        lineNumber: 941,\n                        columnNumber: 6\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n                lineNumber: 894,\n                columnNumber: 5\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n            lineNumber: 867,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/byronwade/cosmic/src/components/generators/fps-renderer-3d.tsx\",\n        lineNumber: 866,\n        columnNumber: 3\n    }, this);\n}\n_s6(FPSRenderer3D, \"fBTBd++TADBJ7q3HHgRAJPRaLHE=\");\n_c6 = FPSRenderer3D;\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6;\n$RefreshReg$(_c, \"ProfessionalWaterSystem\");\n$RefreshReg$(_c1, \"ProfessionalTerrainSystem\");\n$RefreshReg$(_c2, \"ProfessionalFoliageSystem\");\n$RefreshReg$(_c3, \"ProfessionalLightingSystem\");\n$RefreshReg$(_c4, \"ProfessionalFPSArms\");\n$RefreshReg$(_c5, \"ProfessionalFPSPlayer\");\n$RefreshReg$(_c6, \"FPSRenderer3D\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2dlbmVyYXRvcnMvZnBzLXJlbmRlcmVyLTNkLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Q0FhQzs7QUFJMEY7QUFDM0I7QUFDWDtBQUNnRTtBQUN0RjtBQUM4QjtBQUNPO0FBa0JwRSxxQ0FBcUM7QUFDckMsTUFBTXVCO0lBYUwsc0RBQXNEO0lBQ3REQyxpQkFBaUJDLENBQVMsRUFBRUMsQ0FBUyxFQUFVO1FBQzlDLE1BQU1DLFFBQVE7UUFDZCxNQUFNQyxZQUFZO1FBRWxCLGdEQUFnRDtRQUNoRCxJQUFJQyxTQUFTO1FBQ2IsSUFBSUMsbUJBQW1CRjtRQUN2QixJQUFJRyxlQUFlSjtRQUVuQix3Q0FBd0M7UUFDeEMsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztZQUMzQkgsVUFBVSxJQUFJLENBQUNJLE9BQU8sQ0FBQ1IsSUFBSU0sY0FBY0wsSUFBSUssZ0JBQWdCRDtZQUM3REEsb0JBQW9CO1lBQ3BCQyxnQkFBZ0I7UUFDakI7UUFFQSxxQ0FBcUM7UUFDckMsTUFBTUcsU0FBU0MsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ0MsVUFBVSxDQUFDWixJQUFJLE9BQU9DLElBQUksVUFBVTtRQUNqRUcsVUFBVUs7UUFFVix3Q0FBd0M7UUFDeEMsTUFBTUksVUFBVSxJQUFJLENBQUNDLFlBQVksQ0FBQ2QsSUFBSSxPQUFPQyxJQUFJLFNBQVM7UUFDMURHLFNBQVNNLEtBQUtLLEdBQUcsQ0FBQ1gsU0FBU00sS0FBS0MsR0FBRyxDQUFDRSxVQUFVLENBQUM7UUFFL0MsT0FBT1Q7SUFDUjtJQUVBLHlDQUF5QztJQUN6Q1ksU0FBU2hCLENBQVMsRUFBRUMsQ0FBUyxFQUFVO1FBQ3RDLE1BQU1HLFNBQVMsSUFBSSxDQUFDTCxnQkFBZ0IsQ0FBQ0MsR0FBR0M7UUFDeEMsTUFBTWdCLFdBQVcsSUFBSSxDQUFDVCxPQUFPLENBQUNSLElBQUks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Q2QsOERBQUNLLG9FQUFVQTs7Ozs7MENBQ1gsOERBQUNKLDhEQUFJQTtnQ0FDSjBVLFVBQVU7Z0NBQ1ZDLFlBQVk7Z0NBQ1pDLGVBQWU7Z0NBQ2ZDLG9CQUFvQjtnQ0FDcEJDLG9CQUFvQjtnQ0FDcEJDLG9CQUFvQjtnQ0FDcEJDLFlBQVk7Z0NBQ1pOLFVBQVU7Ozs7OzswQ0FFWCw4REFBQ3pVLCtEQUFLQTtnQ0FDTDZVLG9CQUFvQjtnQ0FDcEJDLG9CQUFvQjtnQ0FDcEIzTCxXQUFXO2dDQUNYc0wsVUFBVTs7Ozs7OzBDQUVYLDhEQUFDeFUsa0VBQVFBO2dDQUNSK1UsUUFBUTtnQ0FDUkMsVUFBVTs7Ozs7OzBDQUVYLDhEQUFDL1UsNkVBQW1CQTtnQ0FDbkJnVixXQUFVO2dDQUNWRixRQUFRO29DQUFDO29DQUFPO2lDQUFNOzs7Ozs7Ozs7Ozs7a0NBSXhCLDhEQUFDNUo7d0JBQXNCQyxRQUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtwQztJQTFGZ0JpSDtNQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvc3JjL2NvbXBvbmVudHMvZ2VuZXJhdG9ycy9mcHMtcmVuZGVyZXItM2QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgZnBzLXJlbmRlcmVyLTNkLnRzeFxuICogQGRlc2NyaXB0aW9uIFByb2Zlc3Npb25hbCBBQUEtUXVhbGl0eSBGUFMgUmVuZGVyZXIgXG4gKiBAdmVyc2lvbiA0LjAuMCAtIEhpZ2gtRW5kIEdhbWluZyBRdWFsaXR5XG4gKiBAYXV0aG9yIEdhbGFjdGljIENsYW5zIERldmVsb3BtZW50IFRlYW1cbiAqIFxuICogQGZlYXR1cmVzXG4gKiAtIEFkdmFuY2VkIG11bHRpLW9jdGF2ZSB0ZXJyYWluIGdlbmVyYXRpb25cbiAqIC0gUHJvZmVzc2lvbmFsIGxpZ2h0aW5nIHdpdGggaGlnaC1xdWFsaXR5IHNoYWRvd3NcbiAqIC0gSW5zdGFuY2VkIGZvbGlhZ2Ugc3lzdGVtIGZvciBwZXJmb3JtYW5jZVxuICogLSBSZWFsaXN0aWMgd2F0ZXIgc2ltdWxhdGlvblxuICogLSBFbmhhbmNlZCBGUFMgY29udHJvbHMgd2l0aCBzbW9vdGggbW92ZW1lbnRcbiAqIC0gUHJvZmVzc2lvbmFsIHZpc3VhbCBlZmZlY3RzXG4gKi9cblxuJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlTWVtbywgU3VzcGVuc2UgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IENhbnZhcywgdXNlRnJhbWUsIHVzZVRocmVlIH0gZnJvbSBcIkByZWFjdC10aHJlZS9maWJlclwiO1xuaW1wb3J0IHsgSHRtbCwgU2t5LCBTdGFycyB9IGZyb20gXCJAcmVhY3QtdGhyZWUvZHJlaVwiO1xuaW1wb3J0IHsgRWZmZWN0Q29tcG9zZXIsIFNTQU8sIEJsb29tLCBWaWduZXR0ZSwgQ2hyb21hdGljQWJlcnJhdGlvbiwgTm9ybWFsUGFzcyB9IGZyb20gXCJAcmVhY3QtdGhyZWUvcG9zdHByb2Nlc3NpbmdcIjtcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgY3JlYXRlTm9pc2UyRCwgY3JlYXRlTm9pc2UzRCB9IGZyb20gXCJzaW1wbGV4LW5vaXNlXCI7XG5pbXBvcnQgeyB1c2VHYW1lcGFkQ29udHJvbGxlciB9IGZyb20gXCJAL2hvb2tzL3VzZUdhbWVwYWRDb250cm9sbGVyXCI7XG5cbi8vIEZQUyBDb25maWcgaW50ZXJmYWNlXG5pbnRlcmZhY2UgRlBTQ29uZmlnIHtcblx0cGxheWVyOiB7XG5cdFx0bW91c2VTZW5zaXRpdml0eTogbnVtYmVyO1xuXHRcdHdhbGtTcGVlZDogbnVtYmVyO1xuXHRcdHJ1blNwZWVkOiBudW1iZXI7XG5cdFx0anVtcEhlaWdodDogbnVtYmVyO1xuXHRcdHBsYXllclJhZGl1czogbnVtYmVyO1xuXHRcdHBsYXllckhlaWdodDogbnVtYmVyO1xuXHRcdGZvdjogbnVtYmVyO1xuXHR9O1xuXHRlbnZpcm9ubWVudDoge1xuXHRcdGdyYXZpdHk6IG51bWJlcjtcblx0fTtcbn1cblxuLy8gQWR2YW5jZWQgdGVycmFpbiBnZW5lcmF0aW9uIGVuZ2luZVxuY2xhc3MgUHJvZmVzc2lvbmFsVGVycmFpbkVuZ2luZSB7XG5cdHByaXZhdGUgbm9pc2UyRDogKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiBudW1iZXI7XG5cdHByaXZhdGUgbm9pc2UzRDogKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpID0+IG51bWJlcjtcblx0cHJpdmF0ZSByaWRnZU5vaXNlOiAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IG51bWJlcjtcblx0cHJpdmF0ZSBlcm9zaW9uTm9pc2U6ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gbnVtYmVyO1xuXHRcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5ub2lzZTJEID0gY3JlYXRlTm9pc2UyRCgpO1xuXHRcdHRoaXMubm9pc2UzRCA9IGNyZWF0ZU5vaXNlM0QoKTtcblx0XHR0aGlzLnJpZGdlTm9pc2UgPSBjcmVhdGVOb2lzZTJEKCk7XG5cdFx0dGhpcy5lcm9zaW9uTm9pc2UgPSBjcmVhdGVOb2lzZTJEKCk7XG5cdH1cblx0XG5cdC8vIE11bHRpLW9jdGF2ZSB0ZXJyYWluIGhlaWdodCB3aXRoIGdlb2xvZ2ljYWwgcmVhbGlzbVxuXHRnZXRUZXJyYWluSGVpZ2h0KHg6IG51bWJlciwgejogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRjb25zdCBzY2FsZSA9IDAuMDE7XG5cdFx0Y29uc3QgYW1wbGl0dWRlID0gMjA7XG5cdFx0XG5cdFx0Ly8gQmFzZSB0ZXJyYWluIHdpdGggbXVsdGlwbGUgb2N0YXZlcyBmb3IgZGV0YWlsXG5cdFx0bGV0IGhlaWdodCA9IDA7XG5cdFx0bGV0IGN1cnJlbnRBbXBsaXR1ZGUgPSBhbXBsaXR1ZGU7XG5cdFx0bGV0IGN1cnJlbnRTY2FsZSA9IHNjYWxlO1xuXHRcdFxuXHRcdC8vIDggb2N0YXZlcyBmb3IgaGlnaGx5IGRldGFpbGVkIHRlcnJhaW5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuXHRcdFx0aGVpZ2h0ICs9IHRoaXMubm9pc2UyRCh4ICogY3VycmVudFNjYWxlLCB6ICogY3VycmVudFNjYWxlKSAqIGN1cnJlbnRBbXBsaXR1ZGU7XG5cdFx0XHRjdXJyZW50QW1wbGl0dWRlICo9IDAuNTtcblx0XHRcdGN1cnJlbnRTY2FsZSAqPSAyLjE7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFJpZGdlIGZlYXR1cmVzIGZvciBtb3VudGFpbiByYW5nZXNcblx0XHRjb25zdCByaWRnZXMgPSBNYXRoLmFicyh0aGlzLnJpZGdlTm9pc2UoeCAqIDAuMDAzLCB6ICogMC4wMDMpKSAqIDEyO1xuXHRcdGhlaWdodCArPSByaWRnZXM7XG5cdFx0XG5cdFx0Ly8gRXJvc2lvbiBlZmZlY3RzIGZvciByZWFsaXN0aWMgdmFsbGV5c1xuXHRcdGNvbnN0IGVyb3Npb24gPSB0aGlzLmVyb3Npb25Ob2lzZSh4ICogMC4wMTUsIHogKiAwLjAxNSkgKiAzO1xuXHRcdGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIE1hdGguYWJzKGVyb3Npb24pLCAtMS41KTtcblx0XHRcblx0XHRyZXR1cm4gaGVpZ2h0O1xuXHR9XG5cdFxuXHQvLyBEZXRlcm1pbmUgYmlvbWUgZm9yIHJlYWxpc3RpYyBjb2xvcmluZ1xuXHRnZXRCaW9tZSh4OiBudW1iZXIsIHo6IG51bWJlcik6IHN0cmluZyB7XG5cdFx0Y29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRUZXJyYWluSGVpZ2h0KHgsIHopO1xuXHRcdGNvbnN0IG1vaXN0dXJlID0gdGhpcy5ub2lzZTJEKHggKiAwLjAwMiwgeiAqIDAuMDAyKTtcblx0XHRjb25zdCB0ZW1wZXJhdHVyZSA9IHRoaXMubm9pc2UyRCh4ICogMC4wMDEsIHogKiAwLjAwMSk7XG5cdFx0XG5cdFx0aWYgKGhlaWdodCA8IDApIHJldHVybiAnd2F0ZXInO1xuXHRcdGlmIChoZWlnaHQgPCAzKSByZXR1cm4gbW9pc3R1cmUgPiAwLjIgPyAnc3dhbXAnIDogJ2JlYWNoJztcblx0XHRpZiAoaGVpZ2h0IDwgOCkge1xuXHRcdFx0aWYgKHRlbXBlcmF0dXJlID4gMC4zKSByZXR1cm4gbW9pc3R1cmUgPiAwID8gJ2ZvcmVzdCcgOiAnZ3Jhc3NsYW5kJztcblx0XHRcdHJldHVybiAndHVuZHJhJztcblx0XHR9XG5cdFx0aWYgKGhlaWdodCA8IDE4KSByZXR1cm4gdGVtcGVyYXR1cmUgPiAwID8gJ21vdW50YWluJyA6ICdzbm93Jztcblx0XHRyZXR1cm4gJ3Nub3cnO1xuXHR9XG59XG5cbi8vIFByb2Zlc3Npb25hbCB3YXRlciBzaW11bGF0aW9uIHdpdGggcmVhbGlzdGljIHdhdmVzXG5mdW5jdGlvbiBQcm9mZXNzaW9uYWxXYXRlclN5c3RlbSgpIHtcblx0Y29uc3Qgd2F0ZXJSZWYgPSB1c2VSZWY8VEhSRUUuTWVzaD4obnVsbCk7XG5cdFxuXHR1c2VGcmFtZSgoc3RhdGUpID0+IHtcblx0XHRpZiAoIXdhdGVyUmVmLmN1cnJlbnQpIHJldHVybjtcblx0XHRcblx0XHRjb25zdCB0aW1lID0gc3RhdGUuY2xvY2suZWxhcHNlZFRpbWU7XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB3YXRlclJlZi5jdXJyZW50Lmdlb21ldHJ5IGFzIFRIUkVFLlBsYW5lR2VvbWV0cnk7XG5cdFx0Y29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSBhcyBGbG9hdDMyQXJyYXk7XG5cdFx0XG5cdFx0Ly8gQ3JlYXRlIHJlYWxpc3RpYyB3YXZlIG1vdGlvblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHRjb25zdCB4ID0gcG9zaXRpb25zW2ldO1xuXHRcdFx0Y29uc3QgeiA9IHBvc2l0aW9uc1tpICsgMl07XG5cdFx0XHRwb3NpdGlvbnNbaSArIDFdID0gXG5cdFx0XHRcdE1hdGguc2luKHRpbWUgKiAwLjggKyB4ICogMC4wMikgKiAwLjE1ICsgXG5cdFx0XHRcdE1hdGguY29zKHRpbWUgKiAxLjIgKyB6ICogMC4wMjUpICogMC4xICtcblx0XHRcdFx0TWF0aC5zaW4odGltZSAqIDAuNSArICh4ICsgeikgKiAwLjAxKSAqIDAuMDU7XG5cdFx0fVxuXHRcdFxuXHRcdGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdGdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cdH0pO1xuXHRcblx0cmV0dXJuIChcblx0XHQ8bWVzaCByZWY9e3dhdGVyUmVmfSBwb3NpdGlvbj17WzAsIC0wLjgsIDBdfSByb3RhdGlvbj17Wy1NYXRoLlBJIC8gMiwgMCwgMF19IHJlY2VpdmVTaGFkb3c+XG5cdFx0XHQ8cGxhbmVHZW9tZXRyeSBhcmdzPXtbODAwLCA4MDAsIDEyOCwgMTI4XX0gLz5cblx0XHRcdDxtZXNoU3RhbmRhcmRNYXRlcmlhbFxuXHRcdFx0XHRjb2xvcj1cIiMxZTQwYWZcIlxuXHRcdFx0XHR0cmFuc3BhcmVudFxuXHRcdFx0XHRvcGFjaXR5PXswLjd9XG5cdFx0XHRcdHJvdWdobmVzcz17MC4wNX1cblx0XHRcdFx0bWV0YWxuZXNzPXswLjF9XG5cdFx0XHRcdGVudk1hcEludGVuc2l0eT17Mn1cblx0XHRcdC8+XG5cdFx0PC9tZXNoPlxuXHQpO1xufVxuXG4vLyBBZHZhbmNlZCB0ZXJyYWluIHN5c3RlbSB3aXRoIExPRCBhbmQgYmlvbWUgY29sb3JpbmdcbmZ1bmN0aW9uIFByb2Zlc3Npb25hbFRlcnJhaW5TeXN0ZW0oeyB0ZXJyYWluRW5naW5lIH06IHsgdGVycmFpbkVuZ2luZTogUHJvZmVzc2lvbmFsVGVycmFpbkVuZ2luZSB9KSB7XG5cdGNvbnN0IHsgY2FtZXJhIH0gPSB1c2VUaHJlZSgpO1xuXHRjb25zdCBbY2h1bmtzLCBzZXRDaHVua3NdID0gdXNlU3RhdGU8TWFwPHN0cmluZywgVEhSRUUuQnVmZmVyR2VvbWV0cnk+PihuZXcgTWFwKCkpO1xuXHRcblx0Ly8gUHJvZmVzc2lvbmFsIHRlcnJhaW4gbWF0ZXJpYWxcblx0Y29uc3QgdGVycmFpbk1hdGVyaWFsID0gdXNlTWVtbygoKSA9PiB7XG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG5cdFx0XHR2ZXJ0ZXhDb2xvcnM6IHRydWUsXG5cdFx0XHRyb3VnaG5lc3M6IDAuODUsXG5cdFx0XHRtZXRhbG5lc3M6IDAuMDUsXG5cdFx0fSk7XG5cdH0sIFtdKTtcblx0XG5cdC8vIEdlbmVyYXRlIGhpZ2hseSBkZXRhaWxlZCB0ZXJyYWluIGNodW5rXG5cdGNvbnN0IGdlbmVyYXRlVGVycmFpbkNodW5rID0gdXNlQ2FsbGJhY2soKGNodW5rWDogbnVtYmVyLCBjaHVua1o6IG51bWJlciwgZGV0YWlsOiBudW1iZXIgPSA5NikgPT4ge1xuXHRcdGNvbnN0IHNpemUgPSA0MDtcblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KHNpemUsIHNpemUsIGRldGFpbCwgZGV0YWlsKTtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5IGFzIEZsb2F0MzJBcnJheTtcblx0XHRjb25zdCBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucy5sZW5ndGgpO1xuXHRcdFxuXHRcdC8vIEdlbmVyYXRlIGhlaWdodG1hcCB3aXRoIGJpb21lLWJhc2VkIGNvbG9yaW5nXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdGNvbnN0IGxvY2FsWCA9IHBvc2l0aW9uc1tpXTtcblx0XHRcdGNvbnN0IGxvY2FsWiA9IHBvc2l0aW9uc1tpICsgMl07XG5cdFx0XHRjb25zdCB3b3JsZFggPSBjaHVua1ggKiBzaXplICsgbG9jYWxYO1xuXHRcdFx0Y29uc3Qgd29ybGRaID0gY2h1bmtaICogc2l6ZSArIGxvY2FsWjtcblx0XHRcdFxuXHRcdFx0Ly8gU2V0IHJlYWxpc3RpYyBoZWlnaHRcblx0XHRcdHBvc2l0aW9uc1tpICsgMV0gPSB0ZXJyYWluRW5naW5lLmdldFRlcnJhaW5IZWlnaHQod29ybGRYLCB3b3JsZFopO1xuXHRcdFx0XG5cdFx0XHQvLyBQcm9mZXNzaW9uYWwgYmlvbWUgY29sb3Jpbmdcblx0XHRcdGNvbnN0IGJpb21lID0gdGVycmFpbkVuZ2luZS5nZXRCaW9tZSh3b3JsZFgsIHdvcmxkWik7XG5cdFx0XHRsZXQgciA9IDAuNCwgZyA9IDAuNiwgYiA9IDAuMzsgLy8gRGVmYXVsdCBncmFzc2xhbmRcblx0XHRcdFxuXHRcdFx0c3dpdGNoIChiaW9tZSkge1xuXHRcdFx0XHRjYXNlICd3YXRlcic6IHIgPSAwLjE7IGcgPSAwLjI7IGIgPSAwLjg7IGJyZWFrO1xuXHRcdFx0XHRjYXNlICdiZWFjaCc6IHIgPSAwLjk7IGcgPSAwLjg7IGIgPSAwLjY7IGJyZWFrO1xuXHRcdFx0XHRjYXNlICdzd2FtcCc6IHIgPSAwLjI7IGcgPSAwLjQ7IGIgPSAwLjI7IGJyZWFrO1xuXHRcdFx0XHRjYXNlICdmb3Jlc3QnOiByID0gMC4xNTsgZyA9IDAuNTsgYiA9IDAuMTU7IGJyZWFrO1xuXHRcdFx0XHRjYXNlICdtb3VudGFpbic6IHIgPSAwLjU7IGcgPSAwLjQ7IGIgPSAwLjM7IGJyZWFrO1xuXHRcdFx0XHRjYXNlICd0dW5kcmEnOiByID0gMC42OyBnID0gMC42OyBiID0gMC41OyBicmVhaztcblx0XHRcdFx0Y2FzZSAnc25vdyc6IHIgPSAwLjk1OyBnID0gMC45NTsgYiA9IDAuOTU7IGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBBZGQgaGVpZ2h0LWJhc2VkIHZhcmlhdGlvblxuXHRcdFx0Y29uc3QgaGVpZ2h0RmFjdG9yID0gTWF0aC5tYXgoMCwgcG9zaXRpb25zW2kgKyAxXSkgKiAwLjAyO1xuXHRcdFx0Y29sb3JzW2ldID0gTWF0aC5taW4oMSwgciArIGhlaWdodEZhY3Rvcik7XG5cdFx0XHRjb2xvcnNbaSArIDFdID0gTWF0aC5taW4oMSwgZyArIGhlaWdodEZhY3Rvcik7XG5cdFx0XHRjb2xvcnNbaSArIDJdID0gTWF0aC5taW4oMSwgYiArIGhlaWdodEZhY3Rvcik7XG5cdFx0fVxuXHRcdFxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuXHRcdGdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cdFx0Z2VvbWV0cnkucm90YXRlWCgtTWF0aC5QSSAvIDIpO1xuXHRcdFxuXHRcdHJldHVybiBnZW9tZXRyeTtcblx0fSwgW3RlcnJhaW5FbmdpbmVdKTtcblx0XG5cdC8vIEludGVsbGlnZW50IExPRCBtYW5hZ2VtZW50XG5cdHVzZUZyYW1lKCgpID0+IHtcblx0XHRjb25zdCBjYW1lcmFQb3MgPSBjYW1lcmEucG9zaXRpb247XG5cdFx0Y29uc3QgcmVuZGVyRGlzdGFuY2UgPSA2O1xuXHRcdGNvbnN0IG5ld0NodW5rcyA9IG5ldyBNYXAoKTtcblx0XHRcblx0XHRmb3IgKGxldCB4ID0gLXJlbmRlckRpc3RhbmNlOyB4IDw9IHJlbmRlckRpc3RhbmNlOyB4KyspIHtcblx0XHRcdGZvciAobGV0IHogPSAtcmVuZGVyRGlzdGFuY2U7IHogPD0gcmVuZGVyRGlzdGFuY2U7IHorKykge1xuXHRcdFx0XHRjb25zdCBjaHVua1ggPSBNYXRoLmZsb29yKGNhbWVyYVBvcy54IC8gNDApICsgeDtcblx0XHRcdFx0Y29uc3QgY2h1bmtaID0gTWF0aC5mbG9vcihjYW1lcmFQb3MueiAvIDQwKSArIHo7XG5cdFx0XHRcdGNvbnN0IGtleSA9IGAke2NodW5rWH0sJHtjaHVua1p9YDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghY2h1bmtzLmhhcyhrZXkpKSB7XG5cdFx0XHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoeCAqIHggKyB6ICogeik7XG5cdFx0XHRcdFx0Y29uc3QgZGV0YWlsID0gZGlzdGFuY2UgPCAyID8gOTYgOiBkaXN0YW5jZSA8IDQgPyA2NCA6IDMyO1xuXHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gZ2VuZXJhdGVUZXJyYWluQ2h1bmsoY2h1bmtYLCBjaHVua1osIGRldGFpbCk7XG5cdFx0XHRcdFx0bmV3Q2h1bmtzLnNldChrZXksIGdlb21ldHJ5KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdDaHVua3Muc2V0KGtleSwgY2h1bmtzLmdldChrZXkpISk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gQ2xlYW4gdXAgZGlzdGFudCBjaHVua3Ncblx0XHRjaHVua3MuZm9yRWFjaCgoZ2VvbWV0cnksIGtleSkgPT4ge1xuXHRcdFx0aWYgKCFuZXdDaHVua3MuaGFzKGtleSkpIHtcblx0XHRcdFx0Z2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdFxuXHRcdHNldENodW5rcyhuZXdDaHVua3MpO1xuXHR9KTtcblx0XG5cdHJldHVybiAoXG5cdFx0PD5cblx0XHRcdHtBcnJheS5mcm9tKGNodW5rcy5lbnRyaWVzKCkpLm1hcCgoW2tleSwgZ2VvbWV0cnldKSA9PiB7XG5cdFx0XHRcdGNvbnN0IFtjaHVua1gsIGNodW5rWl0gPSBrZXkuc3BsaXQoJywnKS5tYXAoTnVtYmVyKTtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQ8bWVzaFxuXHRcdFx0XHRcdFx0a2V5PXtrZXl9XG5cdFx0XHRcdFx0XHRnZW9tZXRyeT17Z2VvbWV0cnl9XG5cdFx0XHRcdFx0XHRtYXRlcmlhbD17dGVycmFpbk1hdGVyaWFsfVxuXHRcdFx0XHRcdFx0cG9zaXRpb249e1tjaHVua1ggKiA0MCwgMCwgY2h1bmtaICogNDBdfVxuXHRcdFx0XHRcdFx0Y2FzdFNoYWRvd1xuXHRcdFx0XHRcdFx0cmVjZWl2ZVNoYWRvd1xuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdCk7XG5cdFx0XHR9KX1cblx0XHQ8Lz5cblx0KTtcbn1cblxuLy8gUHJvZmVzc2lvbmFsIGZvbGlhZ2Ugc3lzdGVtIHdpdGggaW5zdGFuY2luZ1xuZnVuY3Rpb24gUHJvZmVzc2lvbmFsRm9saWFnZVN5c3RlbSh7IHRlcnJhaW5FbmdpbmUgfTogeyB0ZXJyYWluRW5naW5lOiBQcm9mZXNzaW9uYWxUZXJyYWluRW5naW5lIH0pIHtcblx0Y29uc3QgaW5zdGFuY2VkVHJlZXNSZWYgPSB1c2VSZWY8VEhSRUUuSW5zdGFuY2VkTWVzaD4obnVsbCk7XG5cdGNvbnN0IGluc3RhbmNlZEdyYXNzUmVmID0gdXNlUmVmPFRIUkVFLkluc3RhbmNlZE1lc2g+KG51bGwpO1xuXHRcblx0dXNlRWZmZWN0KCgpID0+IHtcblx0XHRpZiAoIWluc3RhbmNlZFRyZWVzUmVmLmN1cnJlbnQgfHwgIWluc3RhbmNlZEdyYXNzUmVmLmN1cnJlbnQpIHJldHVybjtcblx0XHRcblx0XHRjb25zdCB0cmVlQ291bnQgPSA4MDA7XG5cdFx0Y29uc3QgZ3Jhc3NDb3VudCA9IDIwMDA7XG5cdFx0Y29uc3QgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0XHRjb25zdCBjb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xuXHRcdFxuXHRcdC8vIEdlbmVyYXRlIHJlYWxpc3RpYyB0cmVlc1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZUNvdW50OyBpKyspIHtcblx0XHRcdGNvbnN0IHggPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAzMDA7XG5cdFx0XHRjb25zdCB6ID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMzAwO1xuXHRcdFx0Y29uc3QgeSA9IHRlcnJhaW5FbmdpbmUuZ2V0VGVycmFpbkhlaWdodCh4LCB6KTtcblx0XHRcdGNvbnN0IGJpb21lID0gdGVycmFpbkVuZ2luZS5nZXRCaW9tZSh4LCB6KTtcblx0XHRcdFxuXHRcdFx0aWYgKChiaW9tZSA9PT0gJ2ZvcmVzdCcgfHwgYmlvbWUgPT09ICdncmFzc2xhbmQnKSAmJiB5ID4gMCkge1xuXHRcdFx0XHRjb25zdCBzY2FsZSA9IDAuOCArIE1hdGgucmFuZG9tKCkgKiAyLjA7XG5cdFx0XHRcdG1hdHJpeC5jb21wb3NlKFxuXHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKHgsIHkgKyBzY2FsZSAqIDAuOCwgeiksXG5cdFx0XHRcdFx0bmV3IFRIUkVFLlF1YXRlcm5pb24oKS5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApLCBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIpLFxuXHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKHNjYWxlLCBzY2FsZSwgc2NhbGUpXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGluc3RhbmNlZFRyZWVzUmVmLmN1cnJlbnQuc2V0TWF0cml4QXQoaSwgbWF0cml4KTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbG9yLnNldEhTTCgwLjMgKyBNYXRoLnJhbmRvbSgpICogMC4xLCAwLjcsIDAuMiArIE1hdGgucmFuZG9tKCkgKiAwLjMpO1xuXHRcdFx0XHRpbnN0YW5jZWRUcmVlc1JlZi5jdXJyZW50LnNldENvbG9yQXQoaSwgY29sb3IpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBHZW5lcmF0ZSByZWFsaXN0aWMgZ3Jhc3Ncblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGdyYXNzQ291bnQ7IGkrKykge1xuXHRcdFx0Y29uc3QgeCA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDQwMDtcblx0XHRcdGNvbnN0IHogPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiA0MDA7XG5cdFx0XHRjb25zdCB5ID0gdGVycmFpbkVuZ2luZS5nZXRUZXJyYWluSGVpZ2h0KHgsIHopO1xuXHRcdFx0Y29uc3QgYmlvbWUgPSB0ZXJyYWluRW5naW5lLmdldEJpb21lKHgsIHopO1xuXHRcdFx0XG5cdFx0XHRpZiAoKGJpb21lID09PSAnZ3Jhc3NsYW5kJyB8fCBiaW9tZSA9PT0gJ2ZvcmVzdCcpICYmIHkgPiAwKSB7XG5cdFx0XHRcdGNvbnN0IHNjYWxlID0gMC4zICsgTWF0aC5yYW5kb20oKSAqIDAuNDtcblx0XHRcdFx0bWF0cml4LmNvbXBvc2UoXG5cdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoeCwgeSwgeiksXG5cdFx0XHRcdFx0bmV3IFRIUkVFLlF1YXRlcm5pb24oKS5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApLCBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIpLFxuXHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKHNjYWxlLCBzY2FsZSArIE1hdGgucmFuZG9tKCkgKiAwLjgsIHNjYWxlKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRpbnN0YW5jZWRHcmFzc1JlZi5jdXJyZW50LnNldE1hdHJpeEF0KGksIG1hdHJpeCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb2xvci5zZXRIU0woMC4yOCwgMC44LCAwLjI1ICsgTWF0aC5yYW5kb20oKSAqIDAuNCk7XG5cdFx0XHRcdGluc3RhbmNlZEdyYXNzUmVmLmN1cnJlbnQuc2V0Q29sb3JBdChpLCBjb2xvcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGluc3RhbmNlZFRyZWVzUmVmLmN1cnJlbnQuaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdGlmIChpbnN0YW5jZWRUcmVlc1JlZi5jdXJyZW50Lmluc3RhbmNlQ29sb3IpIGluc3RhbmNlZFRyZWVzUmVmLmN1cnJlbnQuaW5zdGFuY2VDb2xvci5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0aW5zdGFuY2VkR3Jhc3NSZWYuY3VycmVudC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0aWYgKGluc3RhbmNlZEdyYXNzUmVmLmN1cnJlbnQuaW5zdGFuY2VDb2xvcikgaW5zdGFuY2VkR3Jhc3NSZWYuY3VycmVudC5pbnN0YW5jZUNvbG9yLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0fSwgW3RlcnJhaW5FbmdpbmVdKTtcblx0XG5cdHJldHVybiAoXG5cdFx0PD5cblx0XHRcdDxpbnN0YW5jZWRNZXNoIHJlZj17aW5zdGFuY2VkVHJlZXNSZWZ9IGFyZ3M9e1t1bmRlZmluZWQsIHVuZGVmaW5lZCwgODAwXX0gY2FzdFNoYWRvdz5cblx0XHRcdFx0PGN5bGluZGVyR2VvbWV0cnkgYXJncz17WzAuMTUsIDAuMjUsIDNdfSAvPlxuXHRcdFx0XHQ8bWVzaFN0YW5kYXJkTWF0ZXJpYWwgcm91Z2huZXNzPXswLjl9IC8+XG5cdFx0XHQ8L2luc3RhbmNlZE1lc2g+XG5cdFx0XHRcblx0XHRcdDxpbnN0YW5jZWRNZXNoIHJlZj17aW5zdGFuY2VkR3Jhc3NSZWZ9IGFyZ3M9e1t1bmRlZmluZWQsIHVuZGVmaW5lZCwgMjAwMF19PlxuXHRcdFx0XHQ8cGxhbmVHZW9tZXRyeSBhcmdzPXtbMC4xNSwgMC44XX0gLz5cblx0XHRcdFx0PG1lc2hTdGFuZGFyZE1hdGVyaWFsXG5cdFx0XHRcdFx0dHJhbnNwYXJlbnRcblx0XHRcdFx0XHRhbHBoYVRlc3Q9ezAuNn1cblx0XHRcdFx0XHRyb3VnaG5lc3M9ezAuOTV9XG5cdFx0XHRcdFx0c2lkZT17VEhSRUUuRG91YmxlU2lkZX1cblx0XHRcdFx0Lz5cblx0XHRcdDwvaW5zdGFuY2VkTWVzaD5cblx0XHQ8Lz5cblx0KTtcbn1cblxuLy8gUHJvZmVzc2lvbmFsIGxpZ2h0aW5nIHN5c3RlbVxuZnVuY3Rpb24gUHJvZmVzc2lvbmFsTGlnaHRpbmdTeXN0ZW0oKSB7XG5cdGNvbnN0IHN1blJlZiA9IHVzZVJlZjxUSFJFRS5EaXJlY3Rpb25hbExpZ2h0PihudWxsKTtcblx0Y29uc3QgW3RpbWVPZkRheSwgc2V0VGltZU9mRGF5XSA9IHVzZVN0YXRlKDAuMyk7XG5cdFxuXHR1c2VGcmFtZSgoc3RhdGUsIGRlbHRhKSA9PiB7XG5cdFx0aWYgKCFzdW5SZWYuY3VycmVudCkgcmV0dXJuO1xuXHRcdFxuXHRcdC8vIER5bmFtaWMgZGF5L25pZ2h0IGN5Y2xlXG5cdFx0c2V0VGltZU9mRGF5KHByZXYgPT4gKHByZXYgKyBkZWx0YSAqIDAuMDEpICUgMSk7XG5cdFx0XG5cdFx0Y29uc3Qgc3VuQW5nbGUgPSB0aW1lT2ZEYXkgKiBNYXRoLlBJICogMjtcblx0XHRjb25zdCBzdW5Qb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuXHRcdFx0TWF0aC5jb3Moc3VuQW5nbGUpICogMTAwLFxuXHRcdFx0TWF0aC5zaW4oc3VuQW5nbGUpICogODAgKyAyMCxcblx0XHRcdE1hdGguc2luKHN1bkFuZ2xlKSAqIDEwMFxuXHRcdCk7XG5cdFx0XG5cdFx0c3VuUmVmLmN1cnJlbnQucG9zaXRpb24uY29weShzdW5Qb3NpdGlvbik7XG5cdFx0c3VuUmVmLmN1cnJlbnQudGFyZ2V0LnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcblx0XHRcblx0XHQvLyBEeW5hbWljIGludGVuc2l0eSBhbmQgY29sb3Jcblx0XHRjb25zdCBkYXlJbnRlbnNpdHkgPSBNYXRoLm1heCgwLjIsIE1hdGguc2luKHN1bkFuZ2xlKSAqIDAuOCArIDAuNSk7XG5cdFx0c3VuUmVmLmN1cnJlbnQuaW50ZW5zaXR5ID0gZGF5SW50ZW5zaXR5O1xuXHRcdFxuXHRcdGNvbnN0IHN1bkNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCkuc2V0SFNMKDAuMDgsIDAuMywgMC44ICsgZGF5SW50ZW5zaXR5ICogMC4yKTtcblx0XHRzdW5SZWYuY3VycmVudC5jb2xvciA9IHN1bkNvbG9yO1xuXHR9KTtcblx0XG5cdHJldHVybiAoXG5cdFx0PD5cblx0XHRcdDxkaXJlY3Rpb25hbExpZ2h0XG5cdFx0XHRcdHJlZj17c3VuUmVmfVxuXHRcdFx0XHRpbnRlbnNpdHk9ezF9XG5cdFx0XHRcdGNhc3RTaGFkb3dcblx0XHRcdFx0c2hhZG93LW1hcFNpemU9e1s4MTkyLCA4MTkyXX1cblx0XHRcdFx0c2hhZG93LWNhbWVyYS1mYXI9ezQwMH1cblx0XHRcdFx0c2hhZG93LWNhbWVyYS1sZWZ0PXstMTAwfVxuXHRcdFx0XHRzaGFkb3ctY2FtZXJhLXJpZ2h0PXsxMDB9XG5cdFx0XHRcdHNoYWRvdy1jYW1lcmEtdG9wPXsxMDB9XG5cdFx0XHRcdHNoYWRvdy1jYW1lcmEtYm90dG9tPXstMTAwfVxuXHRcdFx0XHRzaGFkb3ctYmlhcz17LTAuMDAwMn1cblx0XHRcdFx0c2hhZG93LW5vcm1hbEJpYXM9ezAuMDJ9XG5cdFx0XHQvPlxuXHRcdFx0XG5cdFx0XHQ8YW1iaWVudExpZ2h0IGNvbG9yPVwiIzRBOTBFMlwiIGludGVuc2l0eT17MC4yNX0gLz5cblx0XHRcdFxuXHRcdFx0PGhlbWlzcGhlcmVMaWdodFxuXHRcdFx0XHRza3lDb2xvcj1cIiM4N0NFRUJcIlxuXHRcdFx0XHRncm91bmRDb2xvcj1cIiMyRjRGMkZcIlxuXHRcdFx0XHRpbnRlbnNpdHk9ezAuNH1cblx0XHRcdC8+XG5cdFx0PC8+XG5cdCk7XG59XG5cbi8vIEVuaGFuY2VkIEZQUyBBcm1zIHdpdGggcHJvZmVzc2lvbmFsIGFuaW1hdGlvblxuZnVuY3Rpb24gUHJvZmVzc2lvbmFsRlBTQXJtcyh7IFxuXHRwb3NpdGlvbiwgXG5cdGNhbWVyYVJvdGF0aW9uLCBcblx0aXNNb3ZpbmcsIFxuXHRpc1J1bm5pbmcsIFxuXHRpc0Nyb3VjaGluZyBcbn06IHsgXG5cdHBvc2l0aW9uOiBUSFJFRS5WZWN0b3IzO1xuXHRjYW1lcmFSb3RhdGlvbjogeyBwaXRjaDogbnVtYmVyOyB5YXc6IG51bWJlciB9O1xuXHRpc01vdmluZzogYm9vbGVhbjtcblx0aXNSdW5uaW5nOiBib29sZWFuO1xuXHRpc0Nyb3VjaGluZzogYm9vbGVhbjtcbn0pIHtcblx0Y29uc3QgYXJtc1JlZiA9IHVzZVJlZjxUSFJFRS5Hcm91cD4obnVsbCk7XG5cdGNvbnN0IHsgY2FtZXJhIH0gPSB1c2VUaHJlZSgpO1xuXHRcblx0dXNlRnJhbWUoKHN0YXRlLCBkZWx0YSkgPT4ge1xuXHRcdGlmICghYXJtc1JlZi5jdXJyZW50KSByZXR1cm47XG5cdFx0XG5cdFx0Ly8gQXJtcyBzaG91bGQgZm9sbG93IGNhbWVyYSBwb3NpdGlvbiBleGFjdGx5XG5cdFx0Y29uc3QgY2FtZXJhUG9zaXRpb24gPSBjYW1lcmEucG9zaXRpb24uY2xvbmUoKTtcblx0XHRhcm1zUmVmLmN1cnJlbnQucG9zaXRpb24uY29weShjYW1lcmFQb3NpdGlvbik7XG5cdFx0XG5cdFx0Ly8gQXJtcyBzaG91bGQgbWF0Y2ggY2FtZXJhIHJvdGF0aW9uIGV4YWN0bHlcblx0XHRhcm1zUmVmLmN1cnJlbnQucm90YXRpb24ub3JkZXIgPSAnWVhaJztcblx0XHRhcm1zUmVmLmN1cnJlbnQucm90YXRpb24ueSA9IGNhbWVyYVJvdGF0aW9uLnlhdztcblx0XHRhcm1zUmVmLmN1cnJlbnQucm90YXRpb24ueCA9IGNhbWVyYVJvdGF0aW9uLnBpdGNoO1xuXHRcdGFybXNSZWYuY3VycmVudC5yb3RhdGlvbi56ID0gMDtcblx0XHRcblx0XHRjb25zdCB0aW1lID0gc3RhdGUuY2xvY2suZWxhcHNlZFRpbWU7XG5cdFx0XG5cdFx0Ly8gUHJvZmVzc2lvbmFsIG1vdmVtZW50IGFuaW1hdGlvbiB3aXRoIG9mZnNldCBmcm9tIGNhbWVyYVxuXHRcdGlmIChpc01vdmluZykge1xuXHRcdFx0Y29uc3Qgc3BlZWQgPSBpc1J1bm5pbmcgPyAxMiA6IDg7XG5cdFx0XHRjb25zdCBpbnRlbnNpdHkgPSBpc1J1bm5pbmcgPyAwLjAxMiA6IDAuMDA4O1xuXHRcdFx0XG5cdFx0XHRjb25zdCB3YWxrQm9iID0gTWF0aC5zaW4odGltZSAqIHNwZWVkKSAqIGludGVuc2l0eTtcblx0XHRcdGNvbnN0IHdhbGtTd2F5ID0gTWF0aC5jb3ModGltZSAqIHNwZWVkICogMC41KSAqIGludGVuc2l0eSAqIDAuNTtcblx0XHRcdFxuXHRcdFx0Ly8gQXBwbHkgbW92ZW1lbnQgYW5pbWF0aW9uIGFzIG9mZnNldCBmcm9tIGNhbWVyYSBwb3NpdGlvblxuXHRcdFx0YXJtc1JlZi5jdXJyZW50LnBvc2l0aW9uLnkgKz0gd2Fsa0JvYjtcblx0XHRcdGFybXNSZWYuY3VycmVudC5wb3NpdGlvbi54ICs9IHdhbGtTd2F5O1xuXHRcdFx0YXJtc1JlZi5jdXJyZW50LnJvdGF0aW9uLnogKz0gd2Fsa1N3YXkgKiAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBCcmVhdGhpbmcgYW5pbWF0aW9uXG5cdFx0XHRjb25zdCBicmVhdGhpbmdJbnRlbnNpdHkgPSAwLjAwMjtcblx0XHRcdGNvbnN0IGJyZWF0aGluZ09mZnNldCA9IE1hdGguc2luKHRpbWUgKiAxLjIpICogYnJlYXRoaW5nSW50ZW5zaXR5O1xuXHRcdFx0YXJtc1JlZi5jdXJyZW50LnBvc2l0aW9uLnkgKz0gYnJlYXRoaW5nT2Zmc2V0O1xuXHRcdH1cblx0XHRcblx0XHQvLyBTbGlnaHQgb2Zmc2V0IGZvciBjcm91Y2hcblx0XHRpZiAoaXNDcm91Y2hpbmcpIHtcblx0XHRcdGFybXNSZWYuY3VycmVudC5wb3NpdGlvbi55IC09IDAuMztcblx0XHR9XG5cdH0pO1xuXHRcblx0cmV0dXJuIChcblx0XHQ8Z3JvdXAgcmVmPXthcm1zUmVmfT5cblx0XHRcdHsvKiBMZWZ0IEFybSAtIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gY2FtZXJhIHZpZXcgKi99XG5cdFx0XHQ8Z3JvdXAgcG9zaXRpb249e1stMC40LCAtMC4zLCAwLjJdfT5cblx0XHRcdFx0PG1lc2ggcG9zaXRpb249e1swLCAtMC4xNSwgMF19IGNhc3RTaGFkb3c+XG5cdFx0XHRcdFx0PGN5bGluZGVyR2VvbWV0cnkgYXJncz17WzAuMDUsIDAuMDYsIDAuMzVdfSAvPlxuXHRcdFx0XHRcdDxtZXNoU3RhbmRhcmRNYXRlcmlhbCBjb2xvcj1cIiNGNURFQjNcIiByb3VnaG5lc3M9ezAuOH0gLz5cblx0XHRcdFx0PC9tZXNoPlxuXHRcdFx0XHQ8bWVzaCBwb3NpdGlvbj17WzAsIC0wLjQsIDAuMTVdfSBjYXN0U2hhZG93PlxuXHRcdFx0XHRcdDxjeWxpbmRlckdlb21ldHJ5IGFyZ3M9e1swLjA0LCAwLjA1LCAwLjI4XX0gLz5cblx0XHRcdFx0XHQ8bWVzaFN0YW5kYXJkTWF0ZXJpYWwgY29sb3I9XCIjRjVERUIzXCIgcm91Z2huZXNzPXswLjh9IC8+XG5cdFx0XHRcdDwvbWVzaD5cblx0XHRcdFx0PG1lc2ggcG9zaXRpb249e1swLCAtMC41NSwgMC4yNV19IGNhc3RTaGFkb3c+XG5cdFx0XHRcdFx0PGJveEdlb21ldHJ5IGFyZ3M9e1swLjA4LCAwLjEsIDAuMTVdfSAvPlxuXHRcdFx0XHRcdDxtZXNoU3RhbmRhcmRNYXRlcmlhbCBjb2xvcj1cIiNGNURFQjNcIiByb3VnaG5lc3M9ezAuOX0gLz5cblx0XHRcdFx0PC9tZXNoPlxuXHRcdFx0PC9ncm91cD5cblx0XHRcdFxuXHRcdFx0ey8qIFJpZ2h0IEFybSAtIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gY2FtZXJhIHZpZXcgKi99XG5cdFx0XHQ8Z3JvdXAgcG9zaXRpb249e1swLjQsIC0wLjMsIDAuMl19PlxuXHRcdFx0XHQ8bWVzaCBwb3NpdGlvbj17WzAsIC0wLjE1LCAwXX0gY2FzdFNoYWRvdz5cblx0XHRcdFx0XHQ8Y3lsaW5kZXJHZW9tZXRyeSBhcmdzPXtbMC4wNSwgMC4wNiwgMC4zNV19IC8+XG5cdFx0XHRcdFx0PG1lc2hTdGFuZGFyZE1hdGVyaWFsIGNvbG9yPVwiI0Y1REVCM1wiIHJvdWdobmVzcz17MC44fSAvPlxuXHRcdFx0XHQ8L21lc2g+XG5cdFx0XHRcdDxtZXNoIHBvc2l0aW9uPXtbMCwgLTAuNCwgMC4xNV19IGNhc3RTaGFkb3c+XG5cdFx0XHRcdFx0PGN5bGluZGVyR2VvbWV0cnkgYXJncz17WzAuMDQsIDAuMDUsIDAuMjhdfSAvPlxuXHRcdFx0XHRcdDxtZXNoU3RhbmRhcmRNYXRlcmlhbCBjb2xvcj1cIiNGNURFQjNcIiByb3VnaG5lc3M9ezAuOH0gLz5cblx0XHRcdFx0PC9tZXNoPlxuXHRcdFx0XHQ8bWVzaCBwb3NpdGlvbj17WzAsIC0wLjU1LCAwLjI1XX0gY2FzdFNoYWRvdz5cblx0XHRcdFx0XHQ8Ym94R2VvbWV0cnkgYXJncz17WzAuMDgsIDAuMSwgMC4xNV19IC8+XG5cdFx0XHRcdFx0PG1lc2hTdGFuZGFyZE1hdGVyaWFsIGNvbG9yPVwiI0Y1REVCM1wiIHJvdWdobmVzcz17MC45fSAvPlxuXHRcdFx0XHQ8L21lc2g+XG5cdFx0XHQ8L2dyb3VwPlxuXHRcdDwvZ3JvdXA+XG5cdCk7XG59XG5cbi8vIFByb2Zlc3Npb25hbCBGUFMgUGxheWVyIENvbnRyb2xsZXJcbmZ1bmN0aW9uIFByb2Zlc3Npb25hbEZQU1BsYXllcih7IGNvbmZpZyB9OiB7IGNvbmZpZzogRlBTQ29uZmlnIH0pIHtcblx0Y29uc3QgcGxheWVyUmVmID0gdXNlUmVmPFRIUkVFLkdyb3VwPihudWxsKTtcblx0Y29uc3QgeyBjYW1lcmEsIGdsIH0gPSB1c2VUaHJlZSgpO1xuXHRjb25zdCBbaXNQb2ludGVyTG9ja2VkLCBzZXRJc1BvaW50ZXJMb2NrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXHRjb25zdCB0ZXJyYWluRW5naW5lID0gdXNlTWVtbygoKSA9PiBuZXcgUHJvZmVzc2lvbmFsVGVycmFpbkVuZ2luZSgpLCBbXSk7XG5cdFxuXHQvLyBQcm9mZXNzaW9uYWwgRlBTIGNhbWVyYSByb3RhdGlvbiBzdGF0ZVxuXHRjb25zdCBjYW1lcmFSb3RhdGlvbiA9IHVzZVJlZih7XG5cdFx0eWF3OiAwLFxuXHRcdHBpdGNoOiAwLFxuXHRcdHRhcmdldFlhdzogMCxcblx0XHR0YXJnZXRQaXRjaDogMCxcblx0fSk7XG5cdFxuXHRjb25zdCBtb3ZlbWVudCA9IHVzZVJlZih7XG5cdFx0Zm9yd2FyZDogZmFsc2UsXG5cdFx0YmFja3dhcmQ6IGZhbHNlLFxuXHRcdGxlZnQ6IGZhbHNlLFxuXHRcdHJpZ2h0OiBmYWxzZSxcblx0XHRqdW1wOiBmYWxzZSxcblx0XHRydW46IGZhbHNlLFxuXHRcdGNyb3VjaDogZmFsc2UsXG5cdFx0Zm9yd2FyZEFtb3VudDogMCxcblx0XHRiYWNrd2FyZEFtb3VudDogMCxcblx0XHRsZWZ0QW1vdW50OiAwLFxuXHRcdHJpZ2h0QW1vdW50OiAwLFxuXHR9KTtcblx0XG5cdGNvbnN0IHsgZ2FtZXBhZFN0YXRlLCBpc0Nvbm5lY3RlZDogaXNHYW1lcGFkQ29ubmVjdGVkIH0gPSB1c2VHYW1lcGFkQ29udHJvbGxlcih7XG5cdFx0ZGVhZHpvbmU6IDAuMixcblx0XHRlbmFibGVIYXB0aWNzOiB0cnVlLFxuXHRcdGFjdGlvbnM6IHtcblx0XHRcdG9uUHJpbWFyeUFjdGlvbjogKCkgPT4gbW92ZW1lbnQuY3VycmVudC5qdW1wID0gdHJ1ZSxcblx0XHRcdG9uU2Vjb25kYXJ5QWN0aW9uOiAoKSA9PiBtb3ZlbWVudC5jdXJyZW50LnJ1biA9ICFtb3ZlbWVudC5jdXJyZW50LnJ1bixcblx0XHRcdG9uQmFja0FjdGlvbjogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50KSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHRcblx0Ly8gUHJvZmVzc2lvbmFsIEZQUyBjYW1lcmEgcG9zaXRpb25pbmcgLSBtYXRjaGVzIGluZHVzdHJ5IHN0YW5kYXJkc1xuXHRjb25zdCBnZXRJbml0aWFsUG9zaXRpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG5cdFx0Y29uc3QgdGVycmFpbkhlaWdodCA9IHRlcnJhaW5FbmdpbmUuZ2V0VGVycmFpbkhlaWdodCgwLCAwKTtcblx0XHRjb25zdCBncm91bmRMZXZlbCA9IE1hdGgubWF4KHRlcnJhaW5IZWlnaHQgKyAxLjc1LCAxLjc1KTsgLy8gU3RhbmRhcmQgcGxheWVyIGhlaWdodFxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMygwLCBncm91bmRMZXZlbCwgMCk7XG5cdH0sIFt0ZXJyYWluRW5naW5lXSk7XG5cdFxuXHRjb25zdCBbcG9zaXRpb24sIHNldFBvc2l0aW9uXSA9IHVzZVN0YXRlPFRIUkVFLlZlY3RvcjM+KGdldEluaXRpYWxQb3NpdGlvbigpKTtcblx0Y29uc3QgW3ZlbG9jaXR5LCBzZXRWZWxvY2l0eV0gPSB1c2VTdGF0ZTxUSFJFRS5WZWN0b3IzPihuZXcgVEhSRUUuVmVjdG9yMygpKTtcblx0Y29uc3QgW2hvcml6b250YWxWZWxvY2l0eSwgc2V0SG9yaXpvbnRhbFZlbG9jaXR5XSA9IHVzZVN0YXRlPFRIUkVFLlZlY3RvcjM+KG5ldyBUSFJFRS5WZWN0b3IzKCkpO1xuXHRjb25zdCBbaXNNb3ZpbmcsIHNldElzTW92aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcblx0XG5cdC8vIEluaXRpYWxpemUgcHJvZmVzc2lvbmFsIEZQUyBjYW1lcmEgc2V0dGluZ3Ncblx0dXNlRWZmZWN0KCgpID0+IHtcblx0XHRpZiAoY2FtZXJhKSB7XG5cdFx0XHQvLyBQcm9mZXNzaW9uYWwgRlBTIGNhbWVyYSBzZXR0aW5ncyAoaW5kdXN0cnkgc3RhbmRhcmQpXG5cdFx0XHRjYW1lcmEuZm92ID0gOTA7IC8vIFN0YW5kYXJkIEZQUyBGT1YgKENhbGwgb2YgRHV0eSwgQ291bnRlci1TdHJpa2Ugc3R5bGUpXG5cdFx0XHRjYW1lcmEubmVhciA9IDAuMDE7IC8vIFZlcnkgY2xvc2UgbmVhciBwbGFuZSBmb3Igd2VhcG9uIHZpc2liaWxpdHlcblx0XHRcdGNhbWVyYS5mYXIgPSAxMDAwOyAvLyBSZWFzb25hYmxlIGZhciBwbGFuZSBmb3IgcGVyZm9ybWFuY2Vcblx0XHRcdGNhbWVyYS5wb3NpdGlvbi5jb3B5KGdldEluaXRpYWxQb3NpdGlvbigpKTtcblx0XHRcdFxuXHRcdFx0Ly8gUHJvZmVzc2lvbmFsIEZQUyBjYW1lcmEgcG9zaXRpb25pbmdcblx0XHRcdGNvbnN0IGV5ZUhlaWdodCA9IDEuNjI7IC8vIFN0YW5kYXJkIGV5ZSBoZWlnaHQgKDUnNFwiIHBlcnNvbilcblx0XHRcdGNhbWVyYS5wb3NpdGlvbi55ICs9IGV5ZUhlaWdodDtcblx0XHRcdFxuXHRcdFx0Ly8gTG9vayBzdHJhaWdodCBhaGVhZCBpbml0aWFsbHkgKGluZHVzdHJ5IHN0YW5kYXJkKVxuXHRcdFx0Y2FtZXJhLnJvdGF0aW9uLnNldCgwLCAwLCAwKTtcblx0XHRcdGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0XHRcblx0XHRcdC8vIEluaXRpYWxpemUgY2FtZXJhIHJvdGF0aW9uIHN0YXRlXG5cdFx0XHRjYW1lcmFSb3RhdGlvbi5jdXJyZW50LnlhdyA9IDA7XG5cdFx0XHRjYW1lcmFSb3RhdGlvbi5jdXJyZW50LnBpdGNoID0gMDtcblx0XHRcdGNhbWVyYVJvdGF0aW9uLmN1cnJlbnQudGFyZ2V0WWF3ID0gMDtcblx0XHRcdGNhbWVyYVJvdGF0aW9uLmN1cnJlbnQudGFyZ2V0UGl0Y2ggPSAwO1xuXHRcdH1cblx0fSwgW2NhbWVyYSwgZ2V0SW5pdGlhbFBvc2l0aW9uXSk7XG5cdFxuXHQvLyBQcm9mZXNzaW9uYWwga2V5Ym9hcmQgY29udHJvbHNcblx0dXNlRWZmZWN0KCgpID0+IHtcblx0XHRjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG5cdFx0XHRzd2l0Y2ggKGV2ZW50LmNvZGUpIHtcblx0XHRcdFx0Y2FzZSAnS2V5Vyc6IG1vdmVtZW50LmN1cnJlbnQuZm9yd2FyZCA9IHRydWU7IGJyZWFrO1xuXHRcdFx0XHRjYXNlICdLZXlTJzogbW92ZW1lbnQuY3VycmVudC5iYWNrd2FyZCA9IHRydWU7IGJyZWFrO1xuXHRcdFx0XHRjYXNlICdLZXlBJzogbW92ZW1lbnQuY3VycmVudC5sZWZ0ID0gdHJ1ZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0tleUQnOiBtb3ZlbWVudC5jdXJyZW50LnJpZ2h0ID0gdHJ1ZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgJ1NwYWNlJzogbW92ZW1lbnQuY3VycmVudC5qdW1wID0gdHJ1ZTsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgJ1NoaWZ0TGVmdCc6IG1vdmVtZW50LmN1cnJlbnQucnVuID0gdHJ1ZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0NvbnRyb2xMZWZ0JzogbW92ZW1lbnQuY3VycmVudC5jcm91Y2ggPSB0cnVlOyBicmVhaztcblx0XHRcdFx0Y2FzZSAnRXNjYXBlJzpcblx0XHRcdFx0XHRpZiAoZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRkb2N1bWVudC5leGl0UG9pbnRlckxvY2soKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGNvbnN0IGhhbmRsZUtleVVwID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG5cdFx0XHRzd2l0Y2ggKGV2ZW50LmNvZGUpIHtcblx0XHRcdFx0Y2FzZSAnS2V5Vyc6IG1vdmVtZW50LmN1cnJlbnQuZm9yd2FyZCA9IGZhbHNlOyBicmVhaztcblx0XHRcdFx0Y2FzZSAnS2V5Uyc6IG1vdmVtZW50LmN1cnJlbnQuYmFja3dhcmQgPSBmYWxzZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0tleUEnOiBtb3ZlbWVudC5jdXJyZW50LmxlZnQgPSBmYWxzZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0tleUQnOiBtb3ZlbWVudC5jdXJyZW50LnJpZ2h0ID0gZmFsc2U7IGJyZWFrO1xuXHRcdFx0XHRjYXNlICdTcGFjZSc6IG1vdmVtZW50LmN1cnJlbnQuanVtcCA9IGZhbHNlOyBicmVhaztcblx0XHRcdFx0Y2FzZSAnU2hpZnRMZWZ0JzogbW92ZW1lbnQuY3VycmVudC5ydW4gPSBmYWxzZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0NvbnRyb2xMZWZ0JzogbW92ZW1lbnQuY3VycmVudC5jcm91Y2ggPSBmYWxzZTsgYnJlYWs7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZUtleVVwKTtcblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZUtleVVwKTtcblx0XHR9O1xuXHR9LCBbXSk7XG5cdFxuXHQvLyBQcm9mZXNzaW9uYWwgcG9pbnRlciBsb2NrIHNldHVwXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0Y29uc3QgaGFuZGxlUG9pbnRlckxvY2tDaGFuZ2UgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBpc0xvY2tlZCA9IGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCA9PT0gZ2wuZG9tRWxlbWVudDtcblx0XHRcdHNldElzUG9pbnRlckxvY2tlZChpc0xvY2tlZCk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IGhhbmRsZUNsaWNrID0gKCkgPT4ge1xuXHRcdFx0aWYgKCFpc1BvaW50ZXJMb2NrZWQpIHtcblx0XHRcdFx0Z2wuZG9tRWxlbWVudC5yZXF1ZXN0UG9pbnRlckxvY2soKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxvY2tjaGFuZ2UnLCBoYW5kbGVQb2ludGVyTG9ja0NoYW5nZSk7XG5cdFx0Z2wuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrKTtcblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2NoYW5nZScsIGhhbmRsZVBvaW50ZXJMb2NrQ2hhbmdlKTtcblx0XHRcdGdsLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XG5cdFx0fTtcblx0fSwgW2dsLmRvbUVsZW1lbnQsIGlzUG9pbnRlckxvY2tlZF0pO1xuXHRcblx0Ly8gUHJvZmVzc2lvbmFsIG1vdXNlIGxvb2sgd2l0aCBpbmR1c3RyeS1zdGFuZGFyZCBzZW5zaXRpdml0eVxuXHR1c2VFZmZlY3QoKCkgPT4ge1xuXHRcdGlmICghaXNQb2ludGVyTG9ja2VkKSByZXR1cm47XG5cblx0XHRjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcblx0XHRcdC8vIFByb2Zlc3Npb25hbCBGUFMgc2Vuc2l0aXZpdHkgKG1hdGNoZXMgQ1M6R08vQ2FsbCBvZiBEdXR5IHN0YW5kYXJkcylcblx0XHRcdGNvbnN0IHNlbnNpdGl2aXR5ID0gY29uZmlnLnBsYXllci5tb3VzZVNlbnNpdGl2aXR5ICogMC4wMDI7XG5cdFx0XHRcblx0XHRcdGNhbWVyYVJvdGF0aW9uLmN1cnJlbnQudGFyZ2V0WWF3IC09IGV2ZW50Lm1vdmVtZW50WCAqIHNlbnNpdGl2aXR5O1xuXHRcdFx0Y2FtZXJhUm90YXRpb24uY3VycmVudC50YXJnZXRQaXRjaCAtPSBldmVudC5tb3ZlbWVudFkgKiBzZW5zaXRpdml0eTtcblx0XHRcdFxuXHRcdFx0Ly8gSW5kdXN0cnkgc3RhbmRhcmQgcGl0Y2ggbGltaXRzICg5MCBkZWdyZWVzIHVwL2Rvd24pXG5cdFx0XHRjYW1lcmFSb3RhdGlvbi5jdXJyZW50LnRhcmdldFBpdGNoID0gTWF0aC5tYXgoXG5cdFx0XHRcdC1NYXRoLlBJIC8gMiArIDAuMDEsXG5cdFx0XHRcdE1hdGgubWluKE1hdGguUEkgLyAyIC0gMC4wMSwgY2FtZXJhUm90YXRpb24uY3VycmVudC50YXJnZXRQaXRjaClcblx0XHRcdCk7XG5cdFx0fTtcblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG5cdFx0cmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG5cdH0sIFtpc1BvaW50ZXJMb2NrZWQsIGNvbmZpZy5wbGF5ZXIubW91c2VTZW5zaXRpdml0eV0pO1xuXHRcblx0Ly8gUHJvZmVzc2lvbmFsIHBoeXNpY3MgYW5kIG1vdmVtZW50XG5cdHVzZUZyYW1lKChzdGF0ZSwgZGVsdGEpID0+IHtcblx0XHRpZiAoIXBsYXllclJlZi5jdXJyZW50KSByZXR1cm47XG5cdFx0XG5cdFx0Ly8gUHJvZmVzc2lvbmFsIGNhbWVyYSBzbW9vdGhpbmcgKHJlc3BvbnNpdmUgYnV0IHN0YWJsZSlcblx0XHRjb25zdCBjYW1lcmFTbW9vdGhpbmcgPSAyNTsgLy8gSW5kdXN0cnkgc3RhbmRhcmQgcmVzcG9uc2l2ZW5lc3Ncblx0XHRcblx0XHRjYW1lcmFSb3RhdGlvbi5jdXJyZW50LnlhdyA9IFRIUkVFLk1hdGhVdGlscy5sZXJwKFxuXHRcdFx0Y2FtZXJhUm90YXRpb24uY3VycmVudC55YXcsXG5cdFx0XHRjYW1lcmFSb3RhdGlvbi5jdXJyZW50LnRhcmdldFlhdyxcblx0XHRcdGNhbWVyYVNtb290aGluZyAqIGRlbHRhXG5cdFx0KTtcblx0XHRjYW1lcmFSb3RhdGlvbi5jdXJyZW50LnBpdGNoID0gVEhSRUUuTWF0aFV0aWxzLmxlcnAoXG5cdFx0XHRjYW1lcmFSb3RhdGlvbi5jdXJyZW50LnBpdGNoLFxuXHRcdFx0Y2FtZXJhUm90YXRpb24uY3VycmVudC50YXJnZXRQaXRjaCxcblx0XHRcdGNhbWVyYVNtb290aGluZyAqIGRlbHRhXG5cdFx0KTtcblx0XHRcblx0XHQvLyBBcHBseSBwcm9mZXNzaW9uYWwgRlBTIGNhbWVyYSByb3RhdGlvblxuXHRcdGNhbWVyYS5yb3RhdGlvbi5vcmRlciA9ICdZWFonO1xuXHRcdGNhbWVyYS5yb3RhdGlvbi55ID0gY2FtZXJhUm90YXRpb24uY3VycmVudC55YXc7XG5cdFx0Y2FtZXJhLnJvdGF0aW9uLnggPSBjYW1lcmFSb3RhdGlvbi5jdXJyZW50LnBpdGNoO1xuXHRcdGNhbWVyYS5yb3RhdGlvbi56ID0gMDtcblx0XHRcblx0XHQvLyBQcm9mZXNzaW9uYWwgbW92ZW1lbnQgc3lzdGVtXG5cdFx0Y29uc3QgYmFzZVNwZWVkID0gbW92ZW1lbnQuY3VycmVudC5ydW4gPyBjb25maWcucGxheWVyLnJ1blNwZWVkICogMS41IDogY29uZmlnLnBsYXllci53YWxrU3BlZWQ7XG5cdFx0Y29uc3QgY3JvdWNoTXVsdGlwbGllciA9IG1vdmVtZW50LmN1cnJlbnQuY3JvdWNoID8gMC40IDogMS4wO1xuXHRcdGNvbnN0IG1heFNwZWVkID0gYmFzZVNwZWVkICogY3JvdWNoTXVsdGlwbGllcjtcblx0XHRcblx0XHRjb25zdCBhY2NlbGVyYXRpb24gPSAyMDtcblx0XHRjb25zdCBkZWNlbGVyYXRpb24gPSAxODtcblx0XHRjb25zdCBzbW9vdGhpbmdTcGVlZCA9IDEyO1xuXHRcdFxuXHRcdC8vIElucHV0IHNtb290aGluZ1xuXHRcdGNvbnN0IHRhcmdldEZvcndhcmQgPSBtb3ZlbWVudC5jdXJyZW50LmZvcndhcmQgPyAxIDogMDtcblx0XHRjb25zdCB0YXJnZXRCYWNrd2FyZCA9IG1vdmVtZW50LmN1cnJlbnQuYmFja3dhcmQgPyAxIDogMDtcblx0XHRjb25zdCB0YXJnZXRMZWZ0ID0gbW92ZW1lbnQuY3VycmVudC5sZWZ0ID8gMSA6IDA7XG5cdFx0Y29uc3QgdGFyZ2V0UmlnaHQgPSBtb3ZlbWVudC5jdXJyZW50LnJpZ2h0ID8gMSA6IDA7XG5cdFx0XG5cdFx0bW92ZW1lbnQuY3VycmVudC5mb3J3YXJkQW1vdW50ID0gVEhSRUUuTWF0aFV0aWxzLmxlcnAobW92ZW1lbnQuY3VycmVudC5mb3J3YXJkQW1vdW50LCB0YXJnZXRGb3J3YXJkLCBzbW9vdGhpbmdTcGVlZCAqIGRlbHRhKTtcblx0XHRtb3ZlbWVudC5jdXJyZW50LmJhY2t3YXJkQW1vdW50ID0gVEhSRUUuTWF0aFV0aWxzLmxlcnAobW92ZW1lbnQuY3VycmVudC5iYWNrd2FyZEFtb3VudCwgdGFyZ2V0QmFja3dhcmQsIHNtb290aGluZ1NwZWVkICogZGVsdGEpO1xuXHRcdG1vdmVtZW50LmN1cnJlbnQubGVmdEFtb3VudCA9IFRIUkVFLk1hdGhVdGlscy5sZXJwKG1vdmVtZW50LmN1cnJlbnQubGVmdEFtb3VudCwgdGFyZ2V0TGVmdCwgc21vb3RoaW5nU3BlZWQgKiBkZWx0YSk7XG5cdFx0bW92ZW1lbnQuY3VycmVudC5yaWdodEFtb3VudCA9IFRIUkVFLk1hdGhVdGlscy5sZXJwKG1vdmVtZW50LmN1cnJlbnQucmlnaHRBbW91bnQsIHRhcmdldFJpZ2h0LCBzbW9vdGhpbmdTcGVlZCAqIGRlbHRhKTtcblx0XHRcblx0XHRjb25zdCBtb3ZlbWVudEludGVuc2l0eSA9IG1vdmVtZW50LmN1cnJlbnQuZm9yd2FyZEFtb3VudCArIG1vdmVtZW50LmN1cnJlbnQuYmFja3dhcmRBbW91bnQgKyBcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZW1lbnQuY3VycmVudC5sZWZ0QW1vdW50ICsgbW92ZW1lbnQuY3VycmVudC5yaWdodEFtb3VudDtcblx0XHRzZXRJc01vdmluZyhtb3ZlbWVudEludGVuc2l0eSA+IDAuMSk7XG5cdFx0XG5cdFx0Ly8gUHJvZmVzc2lvbmFsIG1vdmVtZW50IGNhbGN1bGF0aW9uXG5cdFx0aWYgKGlzUG9pbnRlckxvY2tlZCB8fCBpc0dhbWVwYWRDb25uZWN0ZWQpIHtcblx0XHRcdGNvbnN0IGZvcndhcmQgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAtMSk7XG5cdFx0XHRmb3J3YXJkLmFwcGx5UXVhdGVybmlvbihjYW1lcmEucXVhdGVybmlvbik7XG5cdFx0XHRmb3J3YXJkLnkgPSAwO1xuXHRcdFx0Zm9yd2FyZC5ub3JtYWxpemUoKTtcblxuXHRcdFx0Y29uc3QgcmlnaHQgPSBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKTtcblx0XHRcdHJpZ2h0LmFwcGx5UXVhdGVybmlvbihjYW1lcmEucXVhdGVybmlvbik7XG5cdFx0XHRyaWdodC5ub3JtYWxpemUoKTtcblxuXHRcdFx0bGV0IGlucHV0VmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCk7XG5cdFx0XHRcblx0XHRcdGlucHV0VmVjdG9yLmFkZChmb3J3YXJkLmNsb25lKCkubXVsdGlwbHlTY2FsYXIobW92ZW1lbnQuY3VycmVudC5mb3J3YXJkQW1vdW50IC0gbW92ZW1lbnQuY3VycmVudC5iYWNrd2FyZEFtb3VudCkpO1xuXHRcdFx0aW5wdXRWZWN0b3IuYWRkKHJpZ2h0LmNsb25lKCkubXVsdGlwbHlTY2FsYXIobW92ZW1lbnQuY3VycmVudC5yaWdodEFtb3VudCAtIG1vdmVtZW50LmN1cnJlbnQubGVmdEFtb3VudCkpO1xuXHRcdFx0XG5cdFx0XHRpZiAoaXNHYW1lcGFkQ29ubmVjdGVkICYmIGdhbWVwYWRTdGF0ZSkge1xuXHRcdFx0XHRjb25zdCBsZWZ0U3RpY2tYID0gZ2FtZXBhZFN0YXRlLmxlZnRTdGljay54IHx8IDA7XG5cdFx0XHRcdGNvbnN0IGxlZnRTdGlja1kgPSBnYW1lcGFkU3RhdGUubGVmdFN0aWNrLnkgfHwgMDtcblx0XHRcdFx0XG5cdFx0XHRcdGlucHV0VmVjdG9yLmFkZChmb3J3YXJkLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoLWxlZnRTdGlja1kpKTtcblx0XHRcdFx0aW5wdXRWZWN0b3IuYWRkKHJpZ2h0LmNsb25lKCkubXVsdGlwbHlTY2FsYXIobGVmdFN0aWNrWCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoaW5wdXRWZWN0b3IubGVuZ3RoKCkgPiAxKSB7XG5cdFx0XHRcdGlucHV0VmVjdG9yLm5vcm1hbGl6ZSgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCB0YXJnZXRWZWxvY2l0eSA9IGlucHV0VmVjdG9yLm11bHRpcGx5U2NhbGFyKG1heFNwZWVkKTtcblx0XHRcdGNvbnN0IGN1cnJlbnRIb3Jpem9udGFsVmVsID0gaG9yaXpvbnRhbFZlbG9jaXR5LmNsb25lKCk7XG5cdFx0XHRjb25zdCB2ZWxEaWZmID0gdGFyZ2V0VmVsb2NpdHkuY2xvbmUoKS5zdWIoY3VycmVudEhvcml6b250YWxWZWwpO1xuXHRcdFx0Y29uc3QgYWNjZWxSYXRlID0gdmVsRGlmZi5sZW5ndGgoKSA+IDAuMSA/IGFjY2VsZXJhdGlvbiA6IGRlY2VsZXJhdGlvbjtcblx0XHRcdFxuXHRcdFx0Y29uc3QgbmV3SG9yaXpvbnRhbFZlbCA9IGN1cnJlbnRIb3Jpem9udGFsVmVsLmFkZCh2ZWxEaWZmLm11bHRpcGx5U2NhbGFyKGFjY2VsUmF0ZSAqIGRlbHRhKSk7XG5cdFx0XHRcblx0XHRcdGlmIChuZXdIb3Jpem9udGFsVmVsLmxlbmd0aCgpID4gbWF4U3BlZWQpIHtcblx0XHRcdFx0bmV3SG9yaXpvbnRhbFZlbC5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihtYXhTcGVlZCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHNldEhvcml6b250YWxWZWxvY2l0eShuZXdIb3Jpem9udGFsVmVsKTtcblx0XHRcdFxuXHRcdFx0Ly8gR2FtZXBhZCBjYW1lcmEgd2l0aCBwcm9mZXNzaW9uYWwgc2Vuc2l0aXZpdHlcblx0XHRcdGlmIChpc0dhbWVwYWRDb25uZWN0ZWQgJiYgZ2FtZXBhZFN0YXRlICYmIGlzUG9pbnRlckxvY2tlZCkge1xuXHRcdFx0XHRjb25zdCByaWdodFN0aWNrWCA9IGdhbWVwYWRTdGF0ZS5yaWdodFN0aWNrLnggfHwgMDtcblx0XHRcdFx0Y29uc3QgcmlnaHRTdGlja1kgPSBnYW1lcGFkU3RhdGUucmlnaHRTdGljay55IHx8IDA7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBnYW1lcGFkU2Vuc2l0aXZpdHkgPSBjb25maWcucGxheWVyLm1vdXNlU2Vuc2l0aXZpdHkgKiAwLjA0O1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FtZXJhUm90YXRpb24uY3VycmVudC50YXJnZXRZYXcgLT0gcmlnaHRTdGlja1ggKiBnYW1lcGFkU2Vuc2l0aXZpdHkgKiBkZWx0YTtcblx0XHRcdFx0Y2FtZXJhUm90YXRpb24uY3VycmVudC50YXJnZXRQaXRjaCAtPSByaWdodFN0aWNrWSAqIGdhbWVwYWRTZW5zaXRpdml0eSAqIGRlbHRhO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FtZXJhUm90YXRpb24uY3VycmVudC50YXJnZXRQaXRjaCA9IE1hdGgubWF4KFxuXHRcdFx0XHRcdC1NYXRoLlBJIC8gMiArIDAuMDEsXG5cdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5QSSAvIDIgLSAwLjAxLCBjYW1lcmFSb3RhdGlvbi5jdXJyZW50LnRhcmdldFBpdGNoKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBuZXdIb3Jpem9udGFsVmVsID0gaG9yaXpvbnRhbFZlbG9jaXR5LmNsb25lKCkubXVsdGlwbHlTY2FsYXIoTWF0aC5wb3coMC4wMiwgZGVsdGEpKTtcblx0XHRcdHNldEhvcml6b250YWxWZWxvY2l0eShuZXdIb3Jpem9udGFsVmVsKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gUHJvZmVzc2lvbmFsIGdyYXZpdHkgYW5kIGp1bXBpbmdcblx0XHRjb25zdCBuZXdWZWxvY2l0eSA9IHZlbG9jaXR5LmNsb25lKCk7XG5cdFx0bmV3VmVsb2NpdHkueSAtPSBjb25maWcuZW52aXJvbm1lbnQuZ3Jhdml0eSAqIGRlbHRhO1xuXHRcdFxuXHRcdGlmIChtb3ZlbWVudC5jdXJyZW50Lmp1bXApIHtcblx0XHRcdGNvbnN0IHRlcnJhaW5IZWlnaHQgPSB0ZXJyYWluRW5naW5lLmdldFRlcnJhaW5IZWlnaHQocG9zaXRpb24ueCwgcG9zaXRpb24ueik7XG5cdFx0XHRjb25zdCBncm91bmRMZXZlbCA9IHRlcnJhaW5IZWlnaHQgKyAxLjc1OyAvLyBTdGFuZGFyZCBwbGF5ZXIgaGVpZ2h0XG5cdFx0XHRcblx0XHRcdGlmIChNYXRoLmFicyhwb3NpdGlvbi55IC0gZ3JvdW5kTGV2ZWwpIDwgMC40KSB7XG5cdFx0XHRcdG5ld1ZlbG9jaXR5LnkgPSBjb25maWcucGxheWVyLmp1bXBIZWlnaHQgKiAxLjI7XG5cdFx0XHRcdG1vdmVtZW50LmN1cnJlbnQuanVtcCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRjb25zdCBmaW5hbFZlbG9jaXR5ID0gbmV3IFRIUkVFLlZlY3RvcjMoXG5cdFx0XHRob3Jpem9udGFsVmVsb2NpdHkueCxcblx0XHRcdG5ld1ZlbG9jaXR5LnksXG5cdFx0XHRob3Jpem9udGFsVmVsb2NpdHkuelxuXHRcdCk7XG5cdFx0XG5cdFx0Y29uc3QgbmV3UG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpLmFkZChmaW5hbFZlbG9jaXR5LmNsb25lKCkubXVsdGlwbHlTY2FsYXIoZGVsdGEpKTtcblx0XHRcblx0XHQvLyBQcm9mZXNzaW9uYWwgdGVycmFpbiBjb2xsaXNpb25cblx0XHRjb25zdCB0ZXJyYWluSGVpZ2h0ID0gdGVycmFpbkVuZ2luZS5nZXRUZXJyYWluSGVpZ2h0KG5ld1Bvc2l0aW9uLngsIG5ld1Bvc2l0aW9uLnopO1xuXHRcdGNvbnN0IGdyb3VuZExldmVsID0gdGVycmFpbkhlaWdodCArIDEuNzU7IC8vIFN0YW5kYXJkIHBsYXllciBoZWlnaHRcblx0XHRcblx0XHRpZiAobmV3UG9zaXRpb24ueSA8IGdyb3VuZExldmVsKSB7XG5cdFx0XHRuZXdQb3NpdGlvbi55ID0gZ3JvdW5kTGV2ZWw7XG5cdFx0XHRuZXdWZWxvY2l0eS55ID0gMDtcblx0XHR9XG5cdFx0XG5cdFx0c2V0UG9zaXRpb24obmV3UG9zaXRpb24pO1xuXHRcdHNldFZlbG9jaXR5KG5ld1ZlbG9jaXR5KTtcblx0XHRcblx0XHQvLyBQcm9mZXNzaW9uYWwgRlBTIGNhbWVyYSBwb3NpdGlvbmluZyAoaW5kdXN0cnkgc3RhbmRhcmQpXG5cdFx0Y29uc3QgZXllSGVpZ2h0ID0gbW92ZW1lbnQuY3VycmVudC5jcm91Y2ggPyAxLjIgOiAxLjYyOyAvLyA1JzRcIiBleWUgaGVpZ2h0IHN0YW5kYXJkXG5cdFx0Y29uc3QgY2FtZXJhUG9zaXRpb24gPSBuZXdQb3NpdGlvbi5jbG9uZSgpO1xuXHRcdGNhbWVyYVBvc2l0aW9uLnkgKz0gZXllSGVpZ2h0O1xuXHRcdFxuXHRcdC8vIEluc3RhbnQgY2FtZXJhIGZvbGxvd2luZyBmb3IgcHJvZmVzc2lvbmFsIHJlc3BvbnNpdmVuZXNzXG5cdFx0Y2FtZXJhLnBvc2l0aW9uLmNvcHkoY2FtZXJhUG9zaXRpb24pO1xuXHR9KTtcblx0XG5cdGlmICghaXNQb2ludGVyTG9ja2VkKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxIdG1sIGNlbnRlcj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJwb2ludGVyLWV2ZW50cy1hdXRvIHRleHQtY2VudGVyIHAtMTAgYmctZ3JhZGllbnQtdG8tYnIgZnJvbS1ibGFjay85NSB0by1zbGF0ZS05MDAvOTUgYmFja2Ryb3AtYmx1ci1sZyByb3VuZGVkLTJ4bCBib3JkZXIgYm9yZGVyLWN5YW4tNDAwLzUwIHNoYWRvdy0yeGxcIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInRleHQtd2hpdGUgbWItNCB0ZXh0LTJ4bCBmb250LWJvbGQgYmctZ3JhZGllbnQtdG8tciBmcm9tLWN5YW4tNDAwIHRvLWJsdWUtNDAwIGJnLWNsaXAtdGV4dCB0ZXh0LXRyYW5zcGFyZW50XCI+XG5cdFx0XHRcdFx0XHTwn46uIFByb2Zlc3Npb25hbCBGUFNcblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInRleHQtY3lhbi0zMDAgdGV4dC1sZyBtYi02IGZvbnQtbWVkaXVtXCI+Q2xpY2sgdG8gZW50ZXIgRlBTIG1vZGU8L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1zbGF0ZS0zMDAgc3BhY2UteS0zIG1heC13LW1kIGxlYWRpbmctcmVsYXhlZFwiPlxuXHRcdFx0XHRcdFx0e2lzR2FtZXBhZENvbm5lY3RlZCA/IChcblx0XHRcdFx0XHRcdFx0PD5cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZvbnQtYm9sZCB0ZXh0LWN5YW4tNDAwXCI+8J+OriBDb250cm9sbGVyIFJlYWR5OjwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdDxkaXY+TGVmdCBTdGljazogTW92ZSDigKIgUmlnaHQgU3RpY2s6IExvb2s8L2Rpdj5cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2PkE6IEp1bXAg4oCiIEI6IFJ1biDigKIgU2VsZWN0OiBFeGl0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJtdC00IGZvbnQtYm9sZCB0ZXh0LWJsdWUtNDAwXCI+4oyo77iPIEtleWJvYXJkIEF2YWlsYWJsZTo8L2Rpdj5cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2PldBU0Q6IE1vdmUg4oCiIE1vdXNlOiBMb29rIOKAoiBTaGlmdDogUnVuPC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0PGRpdj5DdHJsOiBDcm91Y2gg4oCiIFNwYWNlOiBKdW1wIOKAoiBFU0M6IEV4aXQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0PC8+XG5cdFx0XHRcdFx0XHQpIDogKFxuXHRcdFx0XHRcdFx0XHQ8PlxuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZm9udC1ib2xkIHRleHQtY3lhbi00MDBcIj7ijKjvuI8gUHJvZmVzc2lvbmFsIEZQUyBDb250cm9sczo8L2Rpdj5cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2PldBU0Q6IE1vdmUg4oCiIE1vdXNlOiBMb29rIGFyb3VuZDwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdDxkaXY+U2hpZnQ6IFJ1biDigKIgQ3RybDogQ3JvdWNoIOKAoiBTcGFjZTogSnVtcDwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdDxkaXY+RVNDOiBFeGl0IEZQUyBtb2RlPC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtY3lhbi0yMDAgbXQtMlwiPjkwwrAgRk9WIOKAoiBQcm9mZXNzaW9uYWwgc2Vuc2l0aXZpdHk8L2Rpdj5cblx0XHRcdFx0XHRcdFx0PC8+XG5cdFx0XHRcdFx0XHQpfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvSHRtbD5cblx0XHQpO1xuXHR9XG5cdFxuXHRyZXR1cm4gKFxuXHRcdDw+XG5cdFx0XHQ8Z3JvdXAgcmVmPXtwbGF5ZXJSZWZ9IHBvc2l0aW9uPXtbcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24uel19PlxuXHRcdFx0XHQ8bWVzaCB2aXNpYmxlPXtmYWxzZX0+XG5cdFx0XHRcdFx0PGNhcHN1bGVHZW9tZXRyeSBhcmdzPXtbY29uZmlnLnBsYXllci5wbGF5ZXJSYWRpdXMsIGNvbmZpZy5wbGF5ZXIucGxheWVySGVpZ2h0XX0gLz5cblx0XHRcdFx0XHQ8bWVzaEJhc2ljTWF0ZXJpYWwgLz5cblx0XHRcdFx0PC9tZXNoPlxuXHRcdFx0PC9ncm91cD5cblx0XHRcdFxuXHRcdFx0PFByb2Zlc3Npb25hbEZQU0FybXMgXG5cdFx0XHRcdHBvc2l0aW9uPXtwb3NpdGlvbn0gXG5cdFx0XHRcdGNhbWVyYVJvdGF0aW9uPXt7XG5cdFx0XHRcdFx0cGl0Y2g6IGNhbWVyYVJvdGF0aW9uLmN1cnJlbnQucGl0Y2gsXG5cdFx0XHRcdFx0eWF3OiBjYW1lcmFSb3RhdGlvbi5jdXJyZW50Lnlhd1xuXHRcdFx0XHR9fVxuXHRcdFx0XHRpc01vdmluZz17aXNNb3Zpbmd9XG5cdFx0XHRcdGlzUnVubmluZz17bW92ZW1lbnQuY3VycmVudC5ydW59XG5cdFx0XHRcdGlzQ3JvdWNoaW5nPXttb3ZlbWVudC5jdXJyZW50LmNyb3VjaH1cblx0XHRcdC8+XG5cdFx0PC8+XG5cdCk7XG59XG5cbi8vIE1haW4gUHJvZmVzc2lvbmFsIEZQUyBSZW5kZXJlclxuZXhwb3J0IGZ1bmN0aW9uIEZQU1JlbmRlcmVyM0QoeyBcblx0Y29uZmlnLCBcblx0b25QZXJmb3JtYW5jZVVwZGF0ZSBcbn06IHsgXG5cdGNvbmZpZzogRlBTQ29uZmlnO1xuXHRvblBlcmZvcm1hbmNlVXBkYXRlPzogKG1ldHJpY3M6IGFueSkgPT4gdm9pZDtcbn0pIHtcblx0Y29uc3QgdGVycmFpbkVuZ2luZSA9IHVzZU1lbW8oKCkgPT4gbmV3IFByb2Zlc3Npb25hbFRlcnJhaW5FbmdpbmUoKSwgW10pO1xuXHRcblx0cmV0dXJuIChcblx0XHQ8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgcmVsYXRpdmUgYmctZ3JhZGllbnQtdG8tYiBmcm9tLWJsdWUtOTAwIHRvLXNsYXRlLTkwMFwiPlxuXHRcdFx0PENhbnZhc1xuXHRcdFx0XHRjYW1lcmE9e3sgXG5cdFx0XHRcdFx0Zm92OiA5MCwgICAgICAgIC8vIEluZHVzdHJ5IHN0YW5kYXJkIEZQUyBGT1YgKENhbGwgb2YgRHV0eSwgQ291bnRlci1TdHJpa2UpXG5cdFx0XHRcdFx0bmVhcjogMC4wMSwgICAgIC8vIFZlcnkgY2xvc2UgbmVhciBwbGFuZSBmb3Igd2VhcG9uL2FybSB2aXNpYmlsaXR5XG5cdFx0XHRcdFx0ZmFyOiAxMDAwLCAgICAgIC8vIE9wdGltaXplZCBmYXIgcGxhbmUgZm9yIHBlcmZvcm1hbmNlXG5cdFx0XHRcdFx0cG9zaXRpb246IFswLCA1LCAwXSAgLy8gV2lsbCBiZSBvdmVycmlkZGVuIGJ5IEZQUyBwbGF5ZXIgcG9zaXRpb25pbmdcblx0XHRcdFx0fX1cblx0XHRcdFx0c2hhZG93cz1cInBlcmNlbnRhZ2VcIlxuXHRcdFx0XHRnbD17eyBcblx0XHRcdFx0XHRhbnRpYWxpYXM6IHRydWUsXG5cdFx0XHRcdFx0cG93ZXJQcmVmZXJlbmNlOiBcImhpZ2gtcGVyZm9ybWFuY2VcIixcblx0XHRcdFx0XHRhbHBoYTogZmFsc2UsXG5cdFx0XHRcdFx0ZGVwdGg6IHRydWUsXG5cdFx0XHRcdFx0c3RlbmNpbDogZmFsc2UsXG5cdFx0XHRcdFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxuXHRcdFx0XHR9fVxuXHRcdFx0XHRvbkNyZWF0ZWQ9eyh7IGdsLCBzY2VuZSB9KSA9PiB7XG5cdFx0XHRcdFx0Z2wuc2V0Q2xlYXJDb2xvcihuZXcgVEhSRUUuQ29sb3IoJyMxZTNhOGEnKSwgMSk7XG5cdFx0XHRcdFx0Z2wuc2hhZG93TWFwLmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGdsLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcblx0XHRcdFx0XHRnbC50b25lTWFwcGluZyA9IFRIUkVFLkFDRVNGaWxtaWNUb25lTWFwcGluZztcblx0XHRcdFx0XHRnbC50b25lTWFwcGluZ0V4cG9zdXJlID0gMS4yO1xuXHRcdFx0XHRcdGdsLm91dHB1dEVuY29kaW5nID0gVEhSRUUuc1JHQkVuY29kaW5nO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHNjZW5lLmZvZyA9IG5ldyBUSFJFRS5Gb2coJyMxZTNhOGEnLCAxMDAsIDgwMCk7XG5cdFx0XHRcdH19XG5cdFx0XHQ+XG5cdFx0XHRcdDxTdXNwZW5zZSBmYWxsYmFjaz17bnVsbH0+XG5cdFx0XHRcdFx0PFNreVxuXHRcdFx0XHRcdFx0ZGlzdGFuY2U9ezQ1MDAwMH1cblx0XHRcdFx0XHRcdHN1blBvc2l0aW9uPXtbMTAwLCAzMCwgMTAwXX1cblx0XHRcdFx0XHRcdGluY2xpbmF0aW9uPXswfVxuXHRcdFx0XHRcdFx0YXppbXV0aD17MC4yNX1cblx0XHRcdFx0XHRcdG1pZUNvZWZmaWNpZW50PXswLjAwM31cblx0XHRcdFx0XHRcdG1pZURpcmVjdGlvbmFsRz17MC44NX1cblx0XHRcdFx0XHRcdHJheWxlaWdoPXswLjh9XG5cdFx0XHRcdFx0XHR0dXJiaWRpdHk9ezAuNX1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdDxQcm9mZXNzaW9uYWxMaWdodGluZ1N5c3RlbSAvPlxuXHRcdFx0XHRcdDxQcm9mZXNzaW9uYWxUZXJyYWluU3lzdGVtIHRlcnJhaW5FbmdpbmU9e3RlcnJhaW5FbmdpbmV9IC8+XG5cdFx0XHRcdFx0PFByb2Zlc3Npb25hbFdhdGVyU3lzdGVtIC8+XG5cdFx0XHRcdFx0PFByb2Zlc3Npb25hbEZvbGlhZ2VTeXN0ZW0gdGVycmFpbkVuZ2luZT17dGVycmFpbkVuZ2luZX0gLz5cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQ8U3RhcnMgcmFkaXVzPXs1MDB9IGRlcHRoPXs4MH0gY291bnQ9ezIwMDB9IGZhY3Rvcj17Nn0gc2F0dXJhdGlvbj17MH0gZmFkZSBzcGVlZD17MX0gLz5cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQ8RWZmZWN0Q29tcG9zZXI+XG5cdFx0XHRcdFx0XHQ8Tm9ybWFsUGFzcyAvPlxuXHRcdFx0XHRcdFx0PFNTQU9cblx0XHRcdFx0XHRcdFx0Ymx1clBhc3M9e3RydWV9XG5cdFx0XHRcdFx0XHRcdGJsdXJSYWRpdXM9ezJ9XG5cdFx0XHRcdFx0XHRcdGJsdXJTaGFycG5lc3M9ezEwfVxuXHRcdFx0XHRcdFx0XHRsdW1pbmFuY2VJbmZsdWVuY2U9ezAuNX1cblx0XHRcdFx0XHRcdFx0bHVtaW5hbmNlVGhyZXNob2xkPXswLjAyNX1cblx0XHRcdFx0XHRcdFx0bHVtaW5hbmNlU21vb3RoaW5nPXswLjl9XG5cdFx0XHRcdFx0XHRcdHJlc29sdXRpb249ezAuNX1cblx0XHRcdFx0XHRcdFx0Ymx1clBhc3M9e3RydWV9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PEJsb29tXG5cdFx0XHRcdFx0XHRcdGx1bWluYW5jZVRocmVzaG9sZD17MC41fVxuXHRcdFx0XHRcdFx0XHRsdW1pbmFuY2VTbW9vdGhpbmc9ezAuOX1cblx0XHRcdFx0XHRcdFx0aW50ZW5zaXR5PXsxfVxuXHRcdFx0XHRcdFx0XHRibHVyUGFzcz17dHJ1ZX1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHQ8VmlnbmV0dGVcblx0XHRcdFx0XHRcdFx0b2Zmc2V0PXswLjF9XG5cdFx0XHRcdFx0XHRcdGRhcmtuZXNzPXsxLjJ9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PENocm9tYXRpY0FiZXJyYXRpb25cblx0XHRcdFx0XHRcdFx0YmxlbmRNb2RlPVwic2NyZWVuXCJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0PXtbMC4wMDIsIDAuMDAyXX1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9FZmZlY3RDb21wb3Nlcj5cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQ8UHJvZmVzc2lvbmFsRlBTUGxheWVyIGNvbmZpZz17Y29uZmlnfSAvPlxuXHRcdFx0XHQ8L1N1c3BlbnNlPlxuXHRcdFx0PC9DYW52YXM+XG5cdFx0PC9kaXY+XG5cdCk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsIlN1c3BlbnNlIiwiQ2FudmFzIiwidXNlRnJhbWUiLCJ1c2VUaHJlZSIsIkh0bWwiLCJTa3kiLCJTdGFycyIsIkVmZmVjdENvbXBvc2VyIiwiU1NBTyIsIkJsb29tIiwiVmlnbmV0dGUiLCJDaHJvbWF0aWNBYmVycmF0aW9uIiwiTm9ybWFsUGFzcyIsIlRIUkVFIiwiY3JlYXRlTm9pc2UyRCIsImNyZWF0ZU5vaXNlM0QiLCJ1c2VHYW1lcGFkQ29udHJvbGxlciIsIlByb2Zlc3Npb25hbFRlcnJhaW5FbmdpbmUiLCJnZXRUZXJyYWluSGVpZ2h0IiwieCIsInoiLCJzY2FsZSIsImFtcGxpdHVkZSIsImhlaWdodCIsImN1cnJlbnRBbXBsaXR1ZGUiLCJjdXJyZW50U2NhbGUiLCJpIiwibm9pc2UyRCIsInJpZGdlcyIsIk1hdGgiLCJhYnMiLCJyaWRnZU5vaXNlIiwiZXJvc2lvbiIsImVyb3Npb25Ob2lzZSIsIm1heCIsImdldEJpb21lIiwibW9pc3R1cmUiLCJ0ZW1wZXJhdHVyZSIsIm5vaXNlM0QiLCJQcm9mZXNzaW9uYWxXYXRlclN5c3RlbSIsIndhdGVyUmVmIiwic3RhdGUiLCJjdXJyZW50IiwidGltZSIsImNsb2NrIiwiZWxhcHNlZFRpbWUiLCJnZW9tZXRyeSIsInBvc2l0aW9ucyIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbiIsImFycmF5IiwibGVuZ3RoIiwic2luIiwiY29zIiwibmVlZHNVcGRhdGUiLCJjb21wdXRlVmVydGV4Tm9ybWFscyIsIm1lc2giLCJyZWYiLCJyb3RhdGlvbiIsIlBJIiwicmVjZWl2ZVNoYWRvdyIsInBsYW5lR2VvbWV0cnkiLCJhcmdzIiwibWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJjb2xvciIsInRyYW5zcGFyZW50Iiwib3BhY2l0eSIsInJvdWdobmVzcyIsIm1ldGFsbmVzcyIsImVudk1hcEludGVuc2l0eSIsIlByb2Zlc3Npb25hbFRlcnJhaW5TeXN0ZW0iLCJ0ZXJyYWluRW5naW5lIiwiY2FtZXJhIiwiY2h1bmtzIiwic2V0Q2h1bmtzIiwiTWFwIiwidGVycmFpbk1hdGVyaWFsIiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJ2ZXJ0ZXhDb2xvcnMiLCJnZW5lcmF0ZVRlcnJhaW5DaHVuayIsImNodW5rWCIsImNodW5rWiIsImRldGFpbCIsInNpemUiLCJQbGFuZUdlb21ldHJ5IiwiY29sb3JzIiwiRmxvYXQzMkFycmF5IiwibG9jYWxYIiwibG9jYWxaIiwid29ybGRYIiwid29ybGRaIiwiYmlvbWUiLCJyIiwiZyIsImIiLCJoZWlnaHRGYWN0b3IiLCJtaW4iLCJzZXRBdHRyaWJ1dGUiLCJCdWZmZXJBdHRyaWJ1dGUiLCJyb3RhdGVYIiwiY2FtZXJhUG9zIiwicmVuZGVyRGlzdGFuY2UiLCJuZXdDaHVua3MiLCJmbG9vciIsImtleSIsImhhcyIsImRpc3RhbmNlIiwic3FydCIsInNldCIsImdldCIsImZvckVhY2giLCJkaXNwb3NlIiwiQXJyYXkiLCJmcm9tIiwiZW50cmllcyIsIm1hcCIsInNwbGl0IiwiTnVtYmVyIiwibWF0ZXJpYWwiLCJjYXN0U2hhZG93IiwiUHJvZmVzc2lvbmFsRm9saWFnZVN5c3RlbSIsImluc3RhbmNlZFRyZWVzUmVmIiwiaW5zdGFuY2VkR3Jhc3NSZWYiLCJ0cmVlQ291bnQiLCJncmFzc0NvdW50IiwibWF0cml4IiwiTWF0cml4NCIsIkNvbG9yIiwicmFuZG9tIiwieSIsImNvbXBvc2UiLCJWZWN0b3IzIiwiUXVhdGVybmlvbiIsInNldEZyb21BeGlzQW5nbGUiLCJzZXRNYXRyaXhBdCIsInNldEhTTCIsInNldENvbG9yQXQiLCJpbnN0YW5jZU1hdHJpeCIsImluc3RhbmNlQ29sb3IiLCJpbnN0YW5jZWRNZXNoIiwidW5kZWZpbmVkIiwiY3lsaW5kZXJHZW9tZXRyeSIsImFscGhhVGVzdCIsInNpZGUiLCJEb3VibGVTaWRlIiwiUHJvZmVzc2lvbmFsTGlnaHRpbmdTeXN0ZW0iLCJzdW5SZWYiLCJ0aW1lT2ZEYXkiLCJzZXRUaW1lT2ZEYXkiLCJkZWx0YSIsInByZXYiLCJzdW5BbmdsZSIsInN1blBvc2l0aW9uIiwiY29weSIsInRhcmdldCIsImRheUludGVuc2l0eSIsImludGVuc2l0eSIsInN1bkNvbG9yIiwiZGlyZWN0aW9uYWxMaWdodCIsInNoYWRvdy1tYXBTaXplIiwic2hhZG93LWNhbWVyYS1mYXIiLCJzaGFkb3ctY2FtZXJhLWxlZnQiLCJzaGFkb3ctY2FtZXJhLXJpZ2h0Iiwic2hhZG93LWNhbWVyYS10b3AiLCJzaGFkb3ctY2FtZXJhLWJvdHRvbSIsInNoYWRvdy1iaWFzIiwic2hhZG93LW5vcm1hbEJpYXMiLCJhbWJpZW50TGlnaHQiLCJoZW1pc3BoZXJlTGlnaHQiLCJza3lDb2xvciIsImdyb3VuZENvbG9yIiwiUHJvZmVzc2lvbmFsRlBTQXJtcyIsImNhbWVyYVJvdGF0aW9uIiwiaXNNb3ZpbmciLCJpc1J1bm5pbmciLCJpc0Nyb3VjaGluZyIsImFybXNSZWYiLCJjYW1lcmFQb3NpdGlvbiIsImNsb25lIiwib3JkZXIiLCJ5YXciLCJwaXRjaCIsInNwZWVkIiwid2Fsa0JvYiIsIndhbGtTd2F5IiwiYnJlYXRoaW5nSW50ZW5zaXR5IiwiYnJlYXRoaW5nT2Zmc2V0IiwiZ3JvdXAiLCJib3hHZW9tZXRyeSIsIlByb2Zlc3Npb25hbEZQU1BsYXllciIsImNvbmZpZyIsInBsYXllclJlZiIsImdsIiwiaXNQb2ludGVyTG9ja2VkIiwic2V0SXNQb2ludGVyTG9ja2VkIiwidGFyZ2V0WWF3IiwidGFyZ2V0UGl0Y2giLCJtb3ZlbWVudCIsImZvcndhcmQiLCJiYWNrd2FyZCIsImxlZnQiLCJyaWdodCIsImp1bXAiLCJydW4iLCJjcm91Y2giLCJmb3J3YXJkQW1vdW50IiwiYmFja3dhcmRBbW91bnQiLCJsZWZ0QW1vdW50IiwicmlnaHRBbW91bnQiLCJnYW1lcGFkU3RhdGUiLCJpc0Nvbm5lY3RlZCIsImlzR2FtZXBhZENvbm5lY3RlZCIsImRlYWR6b25lIiwiZW5hYmxlSGFwdGljcyIsImFjdGlvbnMiLCJvblByaW1hcnlBY3Rpb24iLCJvblNlY29uZGFyeUFjdGlvbiIsIm9uQmFja0FjdGlvbiIsImRvY3VtZW50IiwicG9pbnRlckxvY2tFbGVtZW50IiwiZXhpdFBvaW50ZXJMb2NrIiwiZ2V0SW5pdGlhbFBvc2l0aW9uIiwidGVycmFpbkhlaWdodCIsImdyb3VuZExldmVsIiwic2V0UG9zaXRpb24iLCJ2ZWxvY2l0eSIsInNldFZlbG9jaXR5IiwiaG9yaXpvbnRhbFZlbG9jaXR5Iiwic2V0SG9yaXpvbnRhbFZlbG9jaXR5Iiwic2V0SXNNb3ZpbmciLCJmb3YiLCJuZWFyIiwiZmFyIiwiZXllSGVpZ2h0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsImhhbmRsZUtleURvd24iLCJldmVudCIsImNvZGUiLCJwcmV2ZW50RGVmYXVsdCIsImhhbmRsZUtleVVwIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVQb2ludGVyTG9ja0NoYW5nZSIsImlzTG9ja2VkIiwiZG9tRWxlbWVudCIsImhhbmRsZUNsaWNrIiwicmVxdWVzdFBvaW50ZXJMb2NrIiwiaGFuZGxlTW91c2VNb3ZlIiwic2Vuc2l0aXZpdHkiLCJwbGF5ZXIiLCJtb3VzZVNlbnNpdGl2aXR5IiwibW92ZW1lbnRYIiwibW92ZW1lbnRZIiwiY2FtZXJhU21vb3RoaW5nIiwiTWF0aFV0aWxzIiwibGVycCIsImJhc2VTcGVlZCIsInJ1blNwZWVkIiwid2Fsa1NwZWVkIiwiY3JvdWNoTXVsdGlwbGllciIsIm1heFNwZWVkIiwiYWNjZWxlcmF0aW9uIiwiZGVjZWxlcmF0aW9uIiwic21vb3RoaW5nU3BlZWQiLCJ0YXJnZXRGb3J3YXJkIiwidGFyZ2V0QmFja3dhcmQiLCJ0YXJnZXRMZWZ0IiwidGFyZ2V0UmlnaHQiLCJtb3ZlbWVudEludGVuc2l0eSIsImFwcGx5UXVhdGVybmlvbiIsInF1YXRlcm5pb24iLCJub3JtYWxpemUiLCJpbnB1dFZlY3RvciIsImFkZCIsIm11bHRpcGx5U2NhbGFyIiwibGVmdFN0aWNrWCIsImxlZnRTdGljayIsImxlZnRTdGlja1kiLCJ0YXJnZXRWZWxvY2l0eSIsImN1cnJlbnRIb3Jpem9udGFsVmVsIiwidmVsRGlmZiIsInN1YiIsImFjY2VsUmF0ZSIsIm5ld0hvcml6b250YWxWZWwiLCJyaWdodFN0aWNrWCIsInJpZ2h0U3RpY2siLCJyaWdodFN0aWNrWSIsImdhbWVwYWRTZW5zaXRpdml0eSIsInBvdyIsIm5ld1ZlbG9jaXR5IiwiZW52aXJvbm1lbnQiLCJncmF2aXR5IiwianVtcEhlaWdodCIsImZpbmFsVmVsb2NpdHkiLCJuZXdQb3NpdGlvbiIsImNlbnRlciIsImRpdiIsImNsYXNzTmFtZSIsInZpc2libGUiLCJjYXBzdWxlR2VvbWV0cnkiLCJwbGF5ZXJSYWRpdXMiLCJwbGF5ZXJIZWlnaHQiLCJtZXNoQmFzaWNNYXRlcmlhbCIsIkZQU1JlbmRlcmVyM0QiLCJvblBlcmZvcm1hbmNlVXBkYXRlIiwic2hhZG93cyIsImFudGlhbGlhcyIsInBvd2VyUHJlZmVyZW5jZSIsImFscGhhIiwiZGVwdGgiLCJzdGVuY2lsIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwib25DcmVhdGVkIiwic2NlbmUiLCJzZXRDbGVhckNvbG9yIiwic2hhZG93TWFwIiwiZW5hYmxlZCIsInR5cGUiLCJQQ0ZTb2Z0U2hhZG93TWFwIiwidG9uZU1hcHBpbmciLCJBQ0VTRmlsbWljVG9uZU1hcHBpbmciLCJ0b25lTWFwcGluZ0V4cG9zdXJlIiwib3V0cHV0RW5jb2RpbmciLCJzUkdCRW5jb2RpbmciLCJmb2ciLCJGb2ciLCJmYWxsYmFjayIsImluY2xpbmF0aW9uIiwiYXppbXV0aCIsIm1pZUNvZWZmaWNpZW50IiwibWllRGlyZWN0aW9uYWxHIiwicmF5bGVpZ2giLCJ0dXJiaWRpdHkiLCJyYWRpdXMiLCJjb3VudCIsImZhY3RvciIsInNhdHVyYXRpb24iLCJmYWRlIiwiYmx1clBhc3MiLCJibHVyUmFkaXVzIiwiYmx1clNoYXJwbmVzcyIsImx1bWluYW5jZUluZmx1ZW5jZSIsImx1bWluYW5jZVRocmVzaG9sZCIsImx1bWluYW5jZVNtb290aGluZyIsInJlc29sdXRpb24iLCJvZmZzZXQiLCJkYXJrbmVzcyIsImJsZW5kTW9kZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/generators/fps-renderer-3d.tsx\n"));

/***/ })

});
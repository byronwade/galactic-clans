/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_generators_planet-generator_tsx",{

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _extends)\n/* harmony export */ });\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgcmV0dXJuIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKG4pIHtcbiAgICBmb3IgKHZhciBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHNbZV07XG4gICAgICBmb3IgKHZhciByIGluIHQpICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbCh0LCByKSAmJiAobltyXSA9IHRbcl0pO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfSwgX2V4dGVuZHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cbmV4cG9ydCB7IF9leHRlbmRzIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/OrbitControls.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/OrbitControls.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrbitControls: () => (/* binding */ OrbitControls)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(app-pages-browser)/./node_modules/three-stdlib/controls/OrbitControls.js\");\n\n\n\n\n\nconst OrbitControls = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  makeDefault,\n  camera,\n  regress,\n  domElement,\n  enableDamping = true,\n  keyEvents = false,\n  onChange,\n  onStart,\n  onEnd,\n  ...restProps\n}, ref) => {\n  const invalidate = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.invalidate);\n  const defaultCamera = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.camera);\n  const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.gl);\n  const events = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.events);\n  const setEvents = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.setEvents);\n  const set = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.set);\n  const get = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.get);\n  const performance = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.performance);\n  const explCamera = camera || defaultCamera;\n  const explDomElement = domElement || events.connected || gl.domElement;\n  const controls = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => new three_stdlib__WEBPACK_IMPORTED_MODULE_3__.OrbitControls(explCamera), [explCamera]);\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D)(() => {\n    if (controls.enabled) controls.update();\n  }, -1);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    if (keyEvents) {\n      controls.connect(keyEvents === true ? explDomElement : keyEvents);\n    }\n    controls.connect(explDomElement);\n    return () => void controls.dispose();\n  }, [keyEvents, explDomElement, regress, controls, invalidate]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    const callback = e => {\n      invalidate();\n      if (regress) performance.regress();\n      if (onChange) onChange(e);\n    };\n    const onStartCb = e => {\n      if (onStart) onStart(e);\n    };\n    const onEndCb = e => {\n      if (onEnd) onEnd(e);\n    };\n    controls.addEventListener('change', callback);\n    controls.addEventListener('start', onStartCb);\n    controls.addEventListener('end', onEndCb);\n    return () => {\n      controls.removeEventListener('start', onStartCb);\n      controls.removeEventListener('end', onEndCb);\n      controls.removeEventListener('change', callback);\n    };\n  }, [onChange, onStart, onEnd, controls, invalidate, setEvents]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      // @ts-ignore https://github.com/three-types/three-ts-types/pull/1398\n      set({\n        controls\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, controls]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ref: ref,\n    object: controls,\n    enableDamping: enableDamping\n  }, restProps));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL09yYml0Q29udHJvbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTBEO0FBQ0Y7QUFDekI7QUFDaUM7O0FBRWhFLHFDQUFxQyw2Q0FBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCLHFEQUFRO0FBQzdCLHdCQUF3QixxREFBUTtBQUNoQyxhQUFhLHFEQUFRO0FBQ3JCLGlCQUFpQixxREFBUTtBQUN6QixvQkFBb0IscURBQVE7QUFDNUIsY0FBYyxxREFBUTtBQUN0QixjQUFjLHFEQUFRO0FBQ3RCLHNCQUFzQixxREFBUTtBQUM5QjtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFhLFdBQVcsdURBQWU7QUFDMUQsRUFBRSxxREFBUTtBQUNWO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILHNCQUFzQixnREFBbUIsY0FBYyw4RUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFd0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL09yYml0Q29udHJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHsgdXNlVGhyZWUsIHVzZUZyYW1lIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE9yYml0Q29udHJvbHMgYXMgT3JiaXRDb250cm9scyQxIH0gZnJvbSAndGhyZWUtc3RkbGliJztcblxuY29uc3QgT3JiaXRDb250cm9scyA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgbWFrZURlZmF1bHQsXG4gIGNhbWVyYSxcbiAgcmVncmVzcyxcbiAgZG9tRWxlbWVudCxcbiAgZW5hYmxlRGFtcGluZyA9IHRydWUsXG4gIGtleUV2ZW50cyA9IGZhbHNlLFxuICBvbkNoYW5nZSxcbiAgb25TdGFydCxcbiAgb25FbmQsXG4gIC4uLnJlc3RQcm9wc1xufSwgcmVmKSA9PiB7XG4gIGNvbnN0IGludmFsaWRhdGUgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5pbnZhbGlkYXRlKTtcbiAgY29uc3QgZGVmYXVsdENhbWVyYSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmNhbWVyYSk7XG4gIGNvbnN0IGdsID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuZ2wpO1xuICBjb25zdCBldmVudHMgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5ldmVudHMpO1xuICBjb25zdCBzZXRFdmVudHMgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zZXRFdmVudHMpO1xuICBjb25zdCBzZXQgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zZXQpO1xuICBjb25zdCBnZXQgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5nZXQpO1xuICBjb25zdCBwZXJmb3JtYW5jZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnBlcmZvcm1hbmNlKTtcbiAgY29uc3QgZXhwbENhbWVyYSA9IGNhbWVyYSB8fCBkZWZhdWx0Q2FtZXJhO1xuICBjb25zdCBleHBsRG9tRWxlbWVudCA9IGRvbUVsZW1lbnQgfHwgZXZlbnRzLmNvbm5lY3RlZCB8fCBnbC5kb21FbGVtZW50O1xuICBjb25zdCBjb250cm9scyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gbmV3IE9yYml0Q29udHJvbHMkMShleHBsQ2FtZXJhKSwgW2V4cGxDYW1lcmFdKTtcbiAgdXNlRnJhbWUoKCkgPT4ge1xuICAgIGlmIChjb250cm9scy5lbmFibGVkKSBjb250cm9scy51cGRhdGUoKTtcbiAgfSwgLTEpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChrZXlFdmVudHMpIHtcbiAgICAgIGNvbnRyb2xzLmNvbm5lY3Qoa2V5RXZlbnRzID09PSB0cnVlID8gZXhwbERvbUVsZW1lbnQgOiBrZXlFdmVudHMpO1xuICAgIH1cbiAgICBjb250cm9scy5jb25uZWN0KGV4cGxEb21FbGVtZW50KTtcbiAgICByZXR1cm4gKCkgPT4gdm9pZCBjb250cm9scy5kaXNwb3NlKCk7XG4gIH0sIFtrZXlFdmVudHMsIGV4cGxEb21FbGVtZW50LCByZWdyZXNzLCBjb250cm9scywgaW52YWxpZGF0ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gZSA9PiB7XG4gICAgICBpbnZhbGlkYXRlKCk7XG4gICAgICBpZiAocmVncmVzcykgcGVyZm9ybWFuY2UucmVncmVzcygpO1xuICAgICAgaWYgKG9uQ2hhbmdlKSBvbkNoYW5nZShlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uU3RhcnRDYiA9IGUgPT4ge1xuICAgICAgaWYgKG9uU3RhcnQpIG9uU3RhcnQoZSk7XG4gICAgfTtcbiAgICBjb25zdCBvbkVuZENiID0gZSA9PiB7XG4gICAgICBpZiAob25FbmQpIG9uRW5kKGUpO1xuICAgIH07XG4gICAgY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2FsbGJhY2spO1xuICAgIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXJ0Jywgb25TdGFydENiKTtcbiAgICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCBvbkVuZENiKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RhcnQnLCBvblN0YXJ0Q2IpO1xuICAgICAgY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgb25FbmRDYik7XG4gICAgICBjb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgfSwgW29uQ2hhbmdlLCBvblN0YXJ0LCBvbkVuZCwgY29udHJvbHMsIGludmFsaWRhdGUsIHNldEV2ZW50c10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYWtlRGVmYXVsdCkge1xuICAgICAgY29uc3Qgb2xkID0gZ2V0KCkuY29udHJvbHM7XG4gICAgICAvLyBAdHMtaWdub3JlIGh0dHBzOi8vZ2l0aHViLmNvbS90aHJlZS10eXBlcy90aHJlZS10cy10eXBlcy9wdWxsLzEzOThcbiAgICAgIHNldCh7XG4gICAgICAgIGNvbnRyb2xzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiBzZXQoe1xuICAgICAgICBjb250cm9sczogb2xkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFttYWtlRGVmYXVsdCwgY29udHJvbHNdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICBvYmplY3Q6IGNvbnRyb2xzLFxuICAgIGVuYWJsZURhbXBpbmc6IGVuYWJsZURhbXBpbmdcbiAgfSwgcmVzdFByb3BzKSk7XG59KTtcblxuZXhwb3J0IHsgT3JiaXRDb250cm9scyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/OrbitControls.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/Stars.js":
/*!******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Stars.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stars: () => (/* binding */ Stars)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _helpers_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/constants.js */ \"(app-pages-browser)/./node_modules/@react-three/drei/helpers/constants.js\");\n\n\n\n\n\nclass StarfieldMaterial extends three__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        time: {\n          value: 0.0\n        },\n        fade: {\n          value: 1.0\n        }\n      },\n      vertexShader: /* glsl */`\n      uniform float time;\n      attribute float size;\n      varying vec3 vColor;\n      void main() {\n        vColor = color;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));\n        gl_Position = projectionMatrix * mvPosition;\n      }`,\n      fragmentShader: /* glsl */`\n      uniform sampler2D pointTexture;\n      uniform float fade;\n      varying vec3 vColor;\n      void main() {\n        float opacity = 1.0;\n        if (fade == 1.0) {\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\n        }\n        gl_FragColor = vec4(vColor, opacity);\n\n        #include <tonemapping_fragment>\n\t      #include <${_helpers_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n      }`\n    });\n  }\n}\nconst genStar = r => {\n  return new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().setFromSpherical(new three__WEBPACK_IMPORTED_MODULE_1__.Spherical(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));\n};\nconst Stars = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({\n  radius = 100,\n  depth = 50,\n  count = 5000,\n  saturation = 0,\n  factor = 4,\n  fade = false,\n  speed = 1\n}, ref) => {\n  const material = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const [position, color, size] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const positions = [];\n    const colors = [];\n    const sizes = Array.from({\n      length: count\n    }, () => (0.5 + 0.5 * Math.random()) * factor);\n    const color = new three__WEBPACK_IMPORTED_MODULE_1__.Color();\n    let r = radius + depth;\n    const increment = depth / count;\n    for (let i = 0; i < count; i++) {\n      r -= increment * Math.random();\n      positions.push(...genStar(r).toArray());\n      color.setHSL(i / count, saturation, 0.9);\n      colors.push(color.r, color.g, color.b);\n    }\n    return [new Float32Array(positions), new Float32Array(colors), new Float32Array(sizes)];\n  }, [count, depth, factor, radius, saturation]);\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.D)(state => material.current && (material.current.uniforms.time.value = state.clock.elapsedTime * speed));\n  const [starfieldMaterial] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new StarfieldMaterial());\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"points\", {\n    ref: ref\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"bufferGeometry\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"bufferAttribute\", {\n    attach: \"attributes-position\",\n    args: [position, 3]\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"bufferAttribute\", {\n    attach: \"attributes-color\",\n    args: [color, 3]\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"bufferAttribute\", {\n    attach: \"attributes-size\",\n    args: [size, 1]\n  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"primitive\", {\n    ref: material,\n    object: starfieldMaterial,\n    attach: \"material\",\n    blending: three__WEBPACK_IMPORTED_MODULE_1__.AdditiveBlending,\n    \"uniforms-fade-value\": fade,\n    depthWrite: false,\n    transparent: true,\n    vertexColors: true\n  }));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL1N0YXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErQjtBQUNlO0FBQ3NDO0FBQ2xDOztBQUVsRCxnQ0FBZ0MsaURBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsMERBQU8sdURBQXVEO0FBQ2pGLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQ0FBTyx3QkFBd0IsNENBQVM7QUFDckQ7QUFDQSw2QkFBNkIsNkNBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQix5Q0FBWTtBQUMvQixrQ0FBa0MsMENBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLHdDQUFLO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxxREFBUTtBQUNWLDhCQUE4QiwyQ0FBYztBQUM1QyxzQkFBc0IsZ0RBQW1CO0FBQ3pDO0FBQ0EsR0FBRyxlQUFlLGdEQUFtQixzQ0FBc0MsZ0RBQW1CO0FBQzlGO0FBQ0E7QUFDQSxHQUFHLGdCQUFnQixnREFBbUI7QUFDdEM7QUFDQTtBQUNBLEdBQUcsZ0JBQWdCLGdEQUFtQjtBQUN0QztBQUNBO0FBQ0EsR0FBRyxpQkFBaUIsZ0RBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbURBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRWdCIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9TdGFycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VGcmFtZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBDb2xvciwgQWRkaXRpdmVCbGVuZGluZywgU2hhZGVyTWF0ZXJpYWwsIFZlY3RvcjMsIFNwaGVyaWNhbCB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi9oZWxwZXJzL2NvbnN0YW50cy5qcyc7XG5cbmNsYXNzIFN0YXJmaWVsZE1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB0aW1lOiB7XG4gICAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgICB9LFxuICAgICAgICBmYWRlOiB7XG4gICAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmVydGV4U2hhZGVyOiAvKiBnbHNsICovYFxuICAgICAgdW5pZm9ybSBmbG9hdCB0aW1lO1xuICAgICAgYXR0cmlidXRlIGZsb2F0IHNpemU7XG4gICAgICB2YXJ5aW5nIHZlYzMgdkNvbG9yO1xuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2Q29sb3IgPSBjb2xvcjtcbiAgICAgICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMC41KTtcbiAgICAgICAgZ2xfUG9pbnRTaXplID0gc2l6ZSAqICgzMC4wIC8gLW12UG9zaXRpb24ueikgKiAoMy4wICsgc2luKHRpbWUgKyAxMDAuMCkpO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xuICAgICAgfWAsXG4gICAgICBmcmFnbWVudFNoYWRlcjogLyogZ2xzbCAqL2BcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHBvaW50VGV4dHVyZTtcbiAgICAgIHVuaWZvcm0gZmxvYXQgZmFkZTtcbiAgICAgIHZhcnlpbmcgdmVjMyB2Q29sb3I7XG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IG9wYWNpdHkgPSAxLjA7XG4gICAgICAgIGlmIChmYWRlID09IDEuMCkge1xuICAgICAgICAgIGZsb2F0IGQgPSBkaXN0YW5jZShnbF9Qb2ludENvb3JkLCB2ZWMyKDAuNSwgMC41KSk7XG4gICAgICAgICAgb3BhY2l0eSA9IDEuMCAvICgxLjAgKyBleHAoMTYuMCAqIChkIC0gMC4yNSkpKTtcbiAgICAgICAgfVxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZDb2xvciwgb3BhY2l0eSk7XG5cbiAgICAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxuXHQgICAgICAjaW5jbHVkZSA8JHt2ZXJzaW9uID49IDE1NCA/ICdjb2xvcnNwYWNlX2ZyYWdtZW50JyA6ICdlbmNvZGluZ3NfZnJhZ21lbnQnfT5cbiAgICAgIH1gXG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGdlblN0YXIgPSByID0+IHtcbiAgcmV0dXJuIG5ldyBWZWN0b3IzKCkuc2V0RnJvbVNwaGVyaWNhbChuZXcgU3BoZXJpY2FsKHIsIE1hdGguYWNvcygxIC0gTWF0aC5yYW5kb20oKSAqIDIpLCBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEkpKTtcbn07XG5jb25zdCBTdGFycyA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgcmFkaXVzID0gMTAwLFxuICBkZXB0aCA9IDUwLFxuICBjb3VudCA9IDUwMDAsXG4gIHNhdHVyYXRpb24gPSAwLFxuICBmYWN0b3IgPSA0LFxuICBmYWRlID0gZmFsc2UsXG4gIHNwZWVkID0gMVxufSwgcmVmKSA9PiB7XG4gIGNvbnN0IG1hdGVyaWFsID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBbcG9zaXRpb24sIGNvbG9yLCBzaXplXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGNvbG9ycyA9IFtdO1xuICAgIGNvbnN0IHNpemVzID0gQXJyYXkuZnJvbSh7XG4gICAgICBsZW5ndGg6IGNvdW50XG4gICAgfSwgKCkgPT4gKDAuNSArIDAuNSAqIE1hdGgucmFuZG9tKCkpICogZmFjdG9yKTtcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcigpO1xuICAgIGxldCByID0gcmFkaXVzICsgZGVwdGg7XG4gICAgY29uc3QgaW5jcmVtZW50ID0gZGVwdGggLyBjb3VudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIHIgLT0gaW5jcmVtZW50ICogTWF0aC5yYW5kb20oKTtcbiAgICAgIHBvc2l0aW9ucy5wdXNoKC4uLmdlblN0YXIocikudG9BcnJheSgpKTtcbiAgICAgIGNvbG9yLnNldEhTTChpIC8gY291bnQsIHNhdHVyYXRpb24sIDAuOSk7XG4gICAgICBjb2xvcnMucHVzaChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgICB9XG4gICAgcmV0dXJuIFtuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucyksIG5ldyBGbG9hdDMyQXJyYXkoY29sb3JzKSwgbmV3IEZsb2F0MzJBcnJheShzaXplcyldO1xuICB9LCBbY291bnQsIGRlcHRoLCBmYWN0b3IsIHJhZGl1cywgc2F0dXJhdGlvbl0pO1xuICB1c2VGcmFtZShzdGF0ZSA9PiBtYXRlcmlhbC5jdXJyZW50ICYmIChtYXRlcmlhbC5jdXJyZW50LnVuaWZvcm1zLnRpbWUudmFsdWUgPSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZSAqIHNwZWVkKSk7XG4gIGNvbnN0IFtzdGFyZmllbGRNYXRlcmlhbF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgU3RhcmZpZWxkTWF0ZXJpYWwoKSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBvaW50c1wiLCB7XG4gICAgcmVmOiByZWZcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJHZW9tZXRyeVwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLCB7XG4gICAgYXR0YWNoOiBcImF0dHJpYnV0ZXMtcG9zaXRpb25cIixcbiAgICBhcmdzOiBbcG9zaXRpb24sIDNdXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLCB7XG4gICAgYXR0YWNoOiBcImF0dHJpYnV0ZXMtY29sb3JcIixcbiAgICBhcmdzOiBbY29sb3IsIDNdXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLCB7XG4gICAgYXR0YWNoOiBcImF0dHJpYnV0ZXMtc2l6ZVwiLFxuICAgIGFyZ3M6IFtzaXplLCAxXVxuICB9KSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsIHtcbiAgICByZWY6IG1hdGVyaWFsLFxuICAgIG9iamVjdDogc3RhcmZpZWxkTWF0ZXJpYWwsXG4gICAgYXR0YWNoOiBcIm1hdGVyaWFsXCIsXG4gICAgYmxlbmRpbmc6IEFkZGl0aXZlQmxlbmRpbmcsXG4gICAgXCJ1bmlmb3Jtcy1mYWRlLXZhbHVlXCI6IGZhZGUsXG4gICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgdmVydGV4Q29sb3JzOiB0cnVlXG4gIH0pKTtcbn0pO1xuXG5leHBvcnQgeyBTdGFycyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/Stars.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/helpers/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\n\nconst getVersion = () => parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, ''));\nconst version = /* @__PURE__ */getVersion();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9oZWxwZXJzL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQzs7QUFFakMsa0NBQWtDLDJDQUFRO0FBQzFDOztBQUVtQiIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2hlbHBlcnMvY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJFVklTSU9OIH0gZnJvbSAndGhyZWUnO1xuXG5jb25zdCBnZXRWZXJzaW9uID0gKCkgPT4gcGFyc2VJbnQoUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLCAnJykpO1xuY29uc3QgdmVyc2lvbiA9IC8qIEBfX1BVUkVfXyAqL2dldFZlcnNpb24oKTtcblxuZXhwb3J0IHsgdmVyc2lvbiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/helpers/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/web/Html.js":
/*!****************************************************!*\
  !*** ./node_modules/@react-three/drei/web/Html.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html: () => (/* binding */ Html)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/client.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n\n\n\n\n\n\nconst v1 = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst v2 = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst v3 = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst v4 = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Vector2();\nfunction defaultCalculatePosition(el, camera, size) {\n  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n  objectPos.project(camera);\n  const widthHalf = size.width / 2;\n  const heightHalf = size.height / 2;\n  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];\n}\nfunction isObjectBehindCamera(el, camera) {\n  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n  const deltaCamObj = objectPos.sub(cameraPos);\n  const camDir = camera.getWorldDirection(v3);\n  return deltaCamObj.angleTo(camDir) > Math.PI / 2;\n}\nfunction isObjectVisible(el, camera, raycaster, occlude) {\n  const elPos = v1.setFromMatrixPosition(el.matrixWorld);\n  const screenPos = elPos.clone();\n  screenPos.project(camera);\n  v4.set(screenPos.x, screenPos.y);\n  raycaster.setFromCamera(v4, camera);\n  const intersects = raycaster.intersectObjects(occlude, true);\n  if (intersects.length) {\n    const intersectionDistance = intersects[0].distance;\n    const pointDistance = elPos.distanceTo(raycaster.ray.origin);\n    return pointDistance < intersectionDistance;\n  }\n  return true;\n}\nfunction objectScale(el, camera) {\n  if (camera instanceof three__WEBPACK_IMPORTED_MODULE_3__.OrthographicCamera) {\n    return camera.zoom;\n  } else if (camera instanceof three__WEBPACK_IMPORTED_MODULE_3__.PerspectiveCamera) {\n    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n    const vFOV = camera.fov * Math.PI / 180;\n    const dist = objectPos.distanceTo(cameraPos);\n    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;\n    return 1 / scaleFOV;\n  } else {\n    return 1;\n  }\n}\nfunction objectZIndex(el, camera, zIndexRange) {\n  if (camera instanceof three__WEBPACK_IMPORTED_MODULE_3__.PerspectiveCamera || camera instanceof three__WEBPACK_IMPORTED_MODULE_3__.OrthographicCamera) {\n    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n    const dist = objectPos.distanceTo(cameraPos);\n    const A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);\n    const B = zIndexRange[1] - A * camera.far;\n    return Math.round(A * dist + B);\n  }\n  return undefined;\n}\nconst epsilon = value => Math.abs(value) < 1e-10 ? 0 : value;\nfunction getCSSMatrix(matrix, multipliers, prepend = '') {\n  let matrix3d = 'matrix3d(';\n  for (let i = 0; i !== 16; i++) {\n    matrix3d += epsilon(multipliers[i] * matrix.elements[i]) + (i !== 15 ? ',' : ')');\n  }\n  return prepend + matrix3d;\n}\nconst getCameraCSSMatrix = (multipliers => {\n  return matrix => getCSSMatrix(matrix, multipliers);\n})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);\nconst getObjectCSSMatrix = (scaleMultipliers => {\n  return (matrix, factor) => getCSSMatrix(matrix, scaleMultipliers(factor), 'translate(-50%,-50%)');\n})(f => [1 / f, 1 / f, 1 / f, 1, -1 / f, -1 / f, -1 / f, -1, 1 / f, 1 / f, 1 / f, 1, 1, 1, 1, 1]);\nfunction isRefObject(ref) {\n  return ref && typeof ref === 'object' && 'current' in ref;\n}\nconst Html = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  children,\n  eps = 0.001,\n  style,\n  className,\n  prepend,\n  center,\n  fullscreen,\n  portal,\n  distanceFactor,\n  sprite = false,\n  transform = false,\n  occlude,\n  onOcclude,\n  castShadow,\n  receiveShadow,\n  material,\n  geometry,\n  zIndexRange = [16777271, 0],\n  calculatePosition = defaultCalculatePosition,\n  as = 'div',\n  wrapperClass,\n  pointerEvents = 'auto',\n  ...props\n}, ref) => {\n  const {\n    gl,\n    camera,\n    scene,\n    size,\n    raycaster,\n    events,\n    viewport\n  } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C)();\n  const [el] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => document.createElement(as));\n  const root = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const group = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const oldZoom = react__WEBPACK_IMPORTED_MODULE_1__.useRef(0);\n  const oldPosition = react__WEBPACK_IMPORTED_MODULE_1__.useRef([0, 0]);\n  const transformOuterRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const transformInnerRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  // Append to the connected element, which makes HTML work with views\n  const target = (portal == null ? void 0 : portal.current) || events.connected || gl.domElement.parentNode;\n  const occlusionMeshRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const isMeshSizeSet = react__WEBPACK_IMPORTED_MODULE_1__.useRef(false);\n  const isRayCastOcclusion = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    return occlude && occlude !== 'blending' || Array.isArray(occlude) && occlude.length && isRefObject(occlude[0]);\n  }, [occlude]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    const el = gl.domElement;\n    if (occlude && occlude === 'blending') {\n      el.style.zIndex = `${Math.floor(zIndexRange[0] / 2)}`;\n      el.style.position = 'absolute';\n      el.style.pointerEvents = 'none';\n    } else {\n      el.style.zIndex = null;\n      el.style.position = null;\n      el.style.pointerEvents = null;\n    }\n  }, [occlude]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (group.current) {\n      const currentRoot = root.current = react_dom_client__WEBPACK_IMPORTED_MODULE_2__.createRoot(el);\n      scene.updateMatrixWorld();\n      if (transform) {\n        el.style.cssText = `position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;`;\n      } else {\n        const vec = calculatePosition(group.current, camera, size);\n        el.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${vec[0]}px,${vec[1]}px,0);transform-origin:0 0;`;\n      }\n      if (target) {\n        if (prepend) target.prepend(el);else target.appendChild(el);\n      }\n      return () => {\n        if (target) target.removeChild(el);\n        currentRoot.unmount();\n      };\n    }\n  }, [target, transform]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (wrapperClass) el.className = wrapperClass;\n  }, [wrapperClass]);\n  const styles = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    if (transform) {\n      return {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: size.width,\n        height: size.height,\n        transformStyle: 'preserve-3d',\n        pointerEvents: 'none'\n      };\n    } else {\n      return {\n        position: 'absolute',\n        transform: center ? 'translate3d(-50%,-50%,0)' : 'none',\n        ...(fullscreen && {\n          top: -size.height / 2,\n          left: -size.width / 2,\n          width: size.width,\n          height: size.height\n        }),\n        ...style\n      };\n    }\n  }, [style, center, fullscreen, size, transform]);\n  const transformInnerStyles = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ({\n    position: 'absolute',\n    pointerEvents\n  }), [pointerEvents]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    isMeshSizeSet.current = false;\n    if (transform) {\n      var _root$current;\n      (_root$current = root.current) == null || _root$current.render(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n        ref: transformOuterRef,\n        style: styles\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n        ref: transformInnerRef,\n        style: transformInnerStyles\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n        ref: ref,\n        className: className,\n        style: style,\n        children: children\n      }))));\n    } else {\n      var _root$current2;\n      (_root$current2 = root.current) == null || _root$current2.render(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n        ref: ref,\n        style: styles,\n        className: className,\n        children: children\n      }));\n    }\n  });\n  const visible = react__WEBPACK_IMPORTED_MODULE_1__.useRef(true);\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D)(gl => {\n    if (group.current) {\n      camera.updateMatrixWorld();\n      group.current.updateWorldMatrix(true, false);\n      const vec = transform ? oldPosition.current : calculatePosition(group.current, camera, size);\n      if (transform || Math.abs(oldZoom.current - camera.zoom) > eps || Math.abs(oldPosition.current[0] - vec[0]) > eps || Math.abs(oldPosition.current[1] - vec[1]) > eps) {\n        const isBehindCamera = isObjectBehindCamera(group.current, camera);\n        let raytraceTarget = false;\n        if (isRayCastOcclusion) {\n          if (Array.isArray(occlude)) {\n            raytraceTarget = occlude.map(item => item.current);\n          } else if (occlude !== 'blending') {\n            raytraceTarget = [scene];\n          }\n        }\n        const previouslyVisible = visible.current;\n        if (raytraceTarget) {\n          const isvisible = isObjectVisible(group.current, camera, raycaster, raytraceTarget);\n          visible.current = isvisible && !isBehindCamera;\n        } else {\n          visible.current = !isBehindCamera;\n        }\n        if (previouslyVisible !== visible.current) {\n          if (onOcclude) onOcclude(!visible.current);else el.style.display = visible.current ? 'block' : 'none';\n        }\n        const halfRange = Math.floor(zIndexRange[0] / 2);\n        const zRange = occlude ? isRayCastOcclusion //\n        ? [zIndexRange[0], halfRange] : [halfRange - 1, 0] : zIndexRange;\n        el.style.zIndex = `${objectZIndex(group.current, camera, zRange)}`;\n        if (transform) {\n          const [widthHalf, heightHalf] = [size.width / 2, size.height / 2];\n          const fov = camera.projectionMatrix.elements[5] * heightHalf;\n          const {\n            isOrthographicCamera,\n            top,\n            left,\n            bottom,\n            right\n          } = camera;\n          const cameraMatrix = getCameraCSSMatrix(camera.matrixWorldInverse);\n          const cameraTransform = isOrthographicCamera ? `scale(${fov})translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${fov}px)`;\n          let matrix = group.current.matrixWorld;\n          if (sprite) {\n            matrix = camera.matrixWorldInverse.clone().transpose().copyPosition(matrix).scale(group.current.scale);\n            matrix.elements[3] = matrix.elements[7] = matrix.elements[11] = 0;\n            matrix.elements[15] = 1;\n          }\n          el.style.width = size.width + 'px';\n          el.style.height = size.height + 'px';\n          el.style.perspective = isOrthographicCamera ? '' : `${fov}px`;\n          if (transformOuterRef.current && transformInnerRef.current) {\n            transformOuterRef.current.style.transform = `${cameraTransform}${cameraMatrix}translate(${widthHalf}px,${heightHalf}px)`;\n            transformInnerRef.current.style.transform = getObjectCSSMatrix(matrix, 1 / ((distanceFactor || 10) / 400));\n          }\n        } else {\n          const scale = distanceFactor === undefined ? 1 : objectScale(group.current, camera) * distanceFactor;\n          el.style.transform = `translate3d(${vec[0]}px,${vec[1]}px,0) scale(${scale})`;\n        }\n        oldPosition.current = vec;\n        oldZoom.current = camera.zoom;\n      }\n    }\n    if (!isRayCastOcclusion && occlusionMeshRef.current && !isMeshSizeSet.current) {\n      if (transform) {\n        if (transformOuterRef.current) {\n          const el = transformOuterRef.current.children[0];\n          if (el != null && el.clientWidth && el != null && el.clientHeight) {\n            const {\n              isOrthographicCamera\n            } = camera;\n            if (isOrthographicCamera || geometry) {\n              if (props.scale) {\n                if (!Array.isArray(props.scale)) {\n                  occlusionMeshRef.current.scale.setScalar(1 / props.scale);\n                } else if (props.scale instanceof three__WEBPACK_IMPORTED_MODULE_3__.Vector3) {\n                  occlusionMeshRef.current.scale.copy(props.scale.clone().divideScalar(1));\n                } else {\n                  occlusionMeshRef.current.scale.set(1 / props.scale[0], 1 / props.scale[1], 1 / props.scale[2]);\n                }\n              }\n            } else {\n              const ratio = (distanceFactor || 10) / 400;\n              const w = el.clientWidth * ratio;\n              const h = el.clientHeight * ratio;\n              occlusionMeshRef.current.scale.set(w, h, 1);\n            }\n            isMeshSizeSet.current = true;\n          }\n        }\n      } else {\n        const ele = el.children[0];\n        if (ele != null && ele.clientWidth && ele != null && ele.clientHeight) {\n          const ratio = 1 / viewport.factor;\n          const w = ele.clientWidth * ratio;\n          const h = ele.clientHeight * ratio;\n          occlusionMeshRef.current.scale.set(w, h, 1);\n          isMeshSizeSet.current = true;\n        }\n        occlusionMeshRef.current.lookAt(gl.camera.position);\n      }\n    }\n  });\n  const shaders = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ({\n    vertexShader: !transform ? /* glsl */`\n          /*\n            This shader is from the THREE's SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if \"transfrom\"\n            is false.\n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n\n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ` : undefined,\n    fragmentShader: /* glsl */`\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `\n  }), [transform]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n    ref: group\n  }), occlude && !isRayCastOcclusion && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", {\n    castShadow: castShadow,\n    receiveShadow: receiveShadow,\n    ref: occlusionMeshRef\n  }, geometry || /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"planeGeometry\", null), material || /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"shaderMaterial\", {\n    side: three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide,\n    vertexShader: shaders.vertexShader,\n    fragmentShader: shaders.fragmentShader\n  })));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS93ZWIvSHRtbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBEO0FBQzNCO0FBQ2M7QUFDK0M7QUFDcEM7O0FBRXhELDhCQUE4QiwwQ0FBTztBQUNyQyw4QkFBOEIsMENBQU87QUFDckMsOEJBQThCLDBDQUFPO0FBQ3JDLDhCQUE4QiwwQ0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFrQjtBQUMxQztBQUNBLElBQUksMkJBQTJCLG9EQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQWlCLHNCQUFzQixxREFBa0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZDQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUscURBQVE7QUFDZCxlQUFlLDJDQUFjO0FBQzdCLGVBQWUseUNBQVk7QUFD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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQixnREFBbUIsVUFBVSw4RUFBUSxHQUFHO0FBQzlEO0FBQ0EsR0FBRyxrREFBa0QsZ0RBQW1CO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMkJBQTJCLGdEQUFtQixrREFBa0QsZ0RBQW1CO0FBQ3RILFVBQVUsNkNBQVU7QUFDcEI7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVlIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvd2ViL0h0bWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tL2NsaWVudCc7XG5pbXBvcnQgeyBWZWN0b3IzLCBEb3VibGVTaWRlLCBPcnRob2dyYXBoaWNDYW1lcmEsIFBlcnNwZWN0aXZlQ2FtZXJhLCBWZWN0b3IyIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgdXNlVGhyZWUsIHVzZUZyYW1lIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcblxuY29uc3QgdjEgPSAvKiBAX19QVVJFX18gKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgdjIgPSAvKiBAX19QVVJFX18gKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgdjMgPSAvKiBAX19QVVJFX18gKi9uZXcgVmVjdG9yMygpO1xuY29uc3QgdjQgPSAvKiBAX19QVVJFX18gKi9uZXcgVmVjdG9yMigpO1xuZnVuY3Rpb24gZGVmYXVsdENhbGN1bGF0ZVBvc2l0aW9uKGVsLCBjYW1lcmEsIHNpemUpIHtcbiAgY29uc3Qgb2JqZWN0UG9zID0gdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGVsLm1hdHJpeFdvcmxkKTtcbiAgb2JqZWN0UG9zLnByb2plY3QoY2FtZXJhKTtcbiAgY29uc3Qgd2lkdGhIYWxmID0gc2l6ZS53aWR0aCAvIDI7XG4gIGNvbnN0IGhlaWdodEhhbGYgPSBzaXplLmhlaWdodCAvIDI7XG4gIHJldHVybiBbb2JqZWN0UG9zLnggKiB3aWR0aEhhbGYgKyB3aWR0aEhhbGYsIC0ob2JqZWN0UG9zLnkgKiBoZWlnaHRIYWxmKSArIGhlaWdodEhhbGZdO1xufVxuZnVuY3Rpb24gaXNPYmplY3RCZWhpbmRDYW1lcmEoZWwsIGNhbWVyYSkge1xuICBjb25zdCBvYmplY3RQb3MgPSB2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oZWwubWF0cml4V29ybGQpO1xuICBjb25zdCBjYW1lcmFQb3MgPSB2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oY2FtZXJhLm1hdHJpeFdvcmxkKTtcbiAgY29uc3QgZGVsdGFDYW1PYmogPSBvYmplY3RQb3Muc3ViKGNhbWVyYVBvcyk7XG4gIGNvbnN0IGNhbURpciA9IGNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbih2Myk7XG4gIHJldHVybiBkZWx0YUNhbU9iai5hbmdsZVRvKGNhbURpcikgPiBNYXRoLlBJIC8gMjtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0VmlzaWJsZShlbCwgY2FtZXJhLCByYXljYXN0ZXIsIG9jY2x1ZGUpIHtcbiAgY29uc3QgZWxQb3MgPSB2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oZWwubWF0cml4V29ybGQpO1xuICBjb25zdCBzY3JlZW5Qb3MgPSBlbFBvcy5jbG9uZSgpO1xuICBzY3JlZW5Qb3MucHJvamVjdChjYW1lcmEpO1xuICB2NC5zZXQoc2NyZWVuUG9zLngsIHNjcmVlblBvcy55KTtcbiAgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEodjQsIGNhbWVyYSk7XG4gIGNvbnN0IGludGVyc2VjdHMgPSByYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0cyhvY2NsdWRlLCB0cnVlKTtcbiAgaWYgKGludGVyc2VjdHMubGVuZ3RoKSB7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uRGlzdGFuY2UgPSBpbnRlcnNlY3RzWzBdLmRpc3RhbmNlO1xuICAgIGNvbnN0IHBvaW50RGlzdGFuY2UgPSBlbFBvcy5kaXN0YW5jZVRvKHJheWNhc3Rlci5yYXkub3JpZ2luKTtcbiAgICByZXR1cm4gcG9pbnREaXN0YW5jZSA8IGludGVyc2VjdGlvbkRpc3RhbmNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gb2JqZWN0U2NhbGUoZWwsIGNhbWVyYSkge1xuICBpZiAoY2FtZXJhIGluc3RhbmNlb2YgT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgcmV0dXJuIGNhbWVyYS56b29tO1xuICB9IGVsc2UgaWYgKGNhbWVyYSBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhKSB7XG4gICAgY29uc3Qgb2JqZWN0UG9zID0gdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGVsLm1hdHJpeFdvcmxkKTtcbiAgICBjb25zdCBjYW1lcmFQb3MgPSB2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oY2FtZXJhLm1hdHJpeFdvcmxkKTtcbiAgICBjb25zdCB2Rk9WID0gY2FtZXJhLmZvdiAqIE1hdGguUEkgLyAxODA7XG4gICAgY29uc3QgZGlzdCA9IG9iamVjdFBvcy5kaXN0YW5jZVRvKGNhbWVyYVBvcyk7XG4gICAgY29uc3Qgc2NhbGVGT1YgPSAyICogTWF0aC50YW4odkZPViAvIDIpICogZGlzdDtcbiAgICByZXR1cm4gMSAvIHNjYWxlRk9WO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxO1xuICB9XG59XG5mdW5jdGlvbiBvYmplY3RaSW5kZXgoZWwsIGNhbWVyYSwgekluZGV4UmFuZ2UpIHtcbiAgaWYgKGNhbWVyYSBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhIHx8IGNhbWVyYSBpbnN0YW5jZW9mIE9ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgIGNvbnN0IG9iamVjdFBvcyA9IHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbihlbC5tYXRyaXhXb3JsZCk7XG4gICAgY29uc3QgY2FtZXJhUG9zID0gdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGNhbWVyYS5tYXRyaXhXb3JsZCk7XG4gICAgY29uc3QgZGlzdCA9IG9iamVjdFBvcy5kaXN0YW5jZVRvKGNhbWVyYVBvcyk7XG4gICAgY29uc3QgQSA9ICh6SW5kZXhSYW5nZVsxXSAtIHpJbmRleFJhbmdlWzBdKSAvIChjYW1lcmEuZmFyIC0gY2FtZXJhLm5lYXIpO1xuICAgIGNvbnN0IEIgPSB6SW5kZXhSYW5nZVsxXSAtIEEgKiBjYW1lcmEuZmFyO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKEEgKiBkaXN0ICsgQik7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNvbnN0IGVwc2lsb24gPSB2YWx1ZSA9PiBNYXRoLmFicyh2YWx1ZSkgPCAxZS0xMCA/IDAgOiB2YWx1ZTtcbmZ1bmN0aW9uIGdldENTU01hdHJpeChtYXRyaXgsIG11bHRpcGxpZXJzLCBwcmVwZW5kID0gJycpIHtcbiAgbGV0IG1hdHJpeDNkID0gJ21hdHJpeDNkKCc7XG4gIGZvciAobGV0IGkgPSAwOyBpICE9PSAxNjsgaSsrKSB7XG4gICAgbWF0cml4M2QgKz0gZXBzaWxvbihtdWx0aXBsaWVyc1tpXSAqIG1hdHJpeC5lbGVtZW50c1tpXSkgKyAoaSAhPT0gMTUgPyAnLCcgOiAnKScpO1xuICB9XG4gIHJldHVybiBwcmVwZW5kICsgbWF0cml4M2Q7XG59XG5jb25zdCBnZXRDYW1lcmFDU1NNYXRyaXggPSAobXVsdGlwbGllcnMgPT4ge1xuICByZXR1cm4gbWF0cml4ID0+IGdldENTU01hdHJpeChtYXRyaXgsIG11bHRpcGxpZXJzKTtcbn0pKFsxLCAtMSwgMSwgMSwgMSwgLTEsIDEsIDEsIDEsIC0xLCAxLCAxLCAxLCAtMSwgMSwgMV0pO1xuY29uc3QgZ2V0T2JqZWN0Q1NTTWF0cml4ID0gKHNjYWxlTXVsdGlwbGllcnMgPT4ge1xuICByZXR1cm4gKG1hdHJpeCwgZmFjdG9yKSA9PiBnZXRDU1NNYXRyaXgobWF0cml4LCBzY2FsZU11bHRpcGxpZXJzKGZhY3RvciksICd0cmFuc2xhdGUoLTUwJSwtNTAlKScpO1xufSkoZiA9PiBbMSAvIGYsIDEgLyBmLCAxIC8gZiwgMSwgLTEgLyBmLCAtMSAvIGYsIC0xIC8gZiwgLTEsIDEgLyBmLCAxIC8gZiwgMSAvIGYsIDEsIDEsIDEsIDEsIDFdKTtcbmZ1bmN0aW9uIGlzUmVmT2JqZWN0KHJlZikge1xuICByZXR1cm4gcmVmICYmIHR5cGVvZiByZWYgPT09ICdvYmplY3QnICYmICdjdXJyZW50JyBpbiByZWY7XG59XG5jb25zdCBIdG1sID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBjaGlsZHJlbixcbiAgZXBzID0gMC4wMDEsXG4gIHN0eWxlLFxuICBjbGFzc05hbWUsXG4gIHByZXBlbmQsXG4gIGNlbnRlcixcbiAgZnVsbHNjcmVlbixcbiAgcG9ydGFsLFxuICBkaXN0YW5jZUZhY3RvcixcbiAgc3ByaXRlID0gZmFsc2UsXG4gIHRyYW5zZm9ybSA9IGZhbHNlLFxuICBvY2NsdWRlLFxuICBvbk9jY2x1ZGUsXG4gIGNhc3RTaGFkb3csXG4gIHJlY2VpdmVTaGFkb3csXG4gIG1hdGVyaWFsLFxuICBnZW9tZXRyeSxcbiAgekluZGV4UmFuZ2UgPSBbMTY3NzcyNzEsIDBdLFxuICBjYWxjdWxhdGVQb3NpdGlvbiA9IGRlZmF1bHRDYWxjdWxhdGVQb3NpdGlvbixcbiAgYXMgPSAnZGl2JyxcbiAgd3JhcHBlckNsYXNzLFxuICBwb2ludGVyRXZlbnRzID0gJ2F1dG8nLFxuICAuLi5wcm9wc1xufSwgcmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBnbCxcbiAgICBjYW1lcmEsXG4gICAgc2NlbmUsXG4gICAgc2l6ZSxcbiAgICByYXljYXN0ZXIsXG4gICAgZXZlbnRzLFxuICAgIHZpZXdwb3J0XG4gIH0gPSB1c2VUaHJlZSgpO1xuICBjb25zdCBbZWxdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChhcykpO1xuICBjb25zdCByb290ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBncm91cCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgb2xkWm9vbSA9IFJlYWN0LnVzZVJlZigwKTtcbiAgY29uc3Qgb2xkUG9zaXRpb24gPSBSZWFjdC51c2VSZWYoWzAsIDBdKTtcbiAgY29uc3QgdHJhbnNmb3JtT3V0ZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHRyYW5zZm9ybUlubmVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAvLyBBcHBlbmQgdG8gdGhlIGNvbm5lY3RlZCBlbGVtZW50LCB3aGljaCBtYWtlcyBIVE1MIHdvcmsgd2l0aCB2aWV3c1xuICBjb25zdCB0YXJnZXQgPSAocG9ydGFsID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWwuY3VycmVudCkgfHwgZXZlbnRzLmNvbm5lY3RlZCB8fCBnbC5kb21FbGVtZW50LnBhcmVudE5vZGU7XG4gIGNvbnN0IG9jY2x1c2lvbk1lc2hSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGlzTWVzaFNpemVTZXQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpc1JheUNhc3RPY2NsdXNpb24gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gb2NjbHVkZSAmJiBvY2NsdWRlICE9PSAnYmxlbmRpbmcnIHx8IEFycmF5LmlzQXJyYXkob2NjbHVkZSkgJiYgb2NjbHVkZS5sZW5ndGggJiYgaXNSZWZPYmplY3Qob2NjbHVkZVswXSk7XG4gIH0sIFtvY2NsdWRlXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZWwgPSBnbC5kb21FbGVtZW50O1xuICAgIGlmIChvY2NsdWRlICYmIG9jY2x1ZGUgPT09ICdibGVuZGluZycpIHtcbiAgICAgIGVsLnN0eWxlLnpJbmRleCA9IGAke01hdGguZmxvb3IoekluZGV4UmFuZ2VbMF0gLyAyKX1gO1xuICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuekluZGV4ID0gbnVsbDtcbiAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gbnVsbDtcbiAgICAgIGVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBudWxsO1xuICAgIH1cbiAgfSwgW29jY2x1ZGVdKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZ3JvdXAuY3VycmVudCkge1xuICAgICAgY29uc3QgY3VycmVudFJvb3QgPSByb290LmN1cnJlbnQgPSBSZWFjdERPTS5jcmVhdGVSb290KGVsKTtcbiAgICAgIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBgcG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3BvaW50ZXItZXZlbnRzOm5vbmU7b3ZlcmZsb3c6aGlkZGVuO2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2ZWMgPSBjYWxjdWxhdGVQb3NpdGlvbihncm91cC5jdXJyZW50LCBjYW1lcmEsIHNpemUpO1xuICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gYHBvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoJHt2ZWNbMF19cHgsJHt2ZWNbMV19cHgsMCk7dHJhbnNmb3JtLW9yaWdpbjowIDA7YDtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHByZXBlbmQpIHRhcmdldC5wcmVwZW5kKGVsKTtlbHNlIHRhcmdldC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAodGFyZ2V0KSB0YXJnZXQucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICBjdXJyZW50Um9vdC51bm1vdW50KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3RhcmdldCwgdHJhbnNmb3JtXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHdyYXBwZXJDbGFzcykgZWwuY2xhc3NOYW1lID0gd3JhcHBlckNsYXNzO1xuICB9LCBbd3JhcHBlckNsYXNzXSk7XG4gIGNvbnN0IHN0eWxlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICB0cmFuc2Zvcm1TdHlsZTogJ3ByZXNlcnZlLTNkJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdHJhbnNmb3JtOiBjZW50ZXIgPyAndHJhbnNsYXRlM2QoLTUwJSwtNTAlLDApJyA6ICdub25lJyxcbiAgICAgICAgLi4uKGZ1bGxzY3JlZW4gJiYge1xuICAgICAgICAgIHRvcDogLXNpemUuaGVpZ2h0IC8gMixcbiAgICAgICAgICBsZWZ0OiAtc2l6ZS53aWR0aCAvIDIsXG4gICAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uc3R5bGVcbiAgICAgIH07XG4gICAgfVxuICB9LCBbc3R5bGUsIGNlbnRlciwgZnVsbHNjcmVlbiwgc2l6ZSwgdHJhbnNmb3JtXSk7XG4gIGNvbnN0IHRyYW5zZm9ybUlubmVyU3R5bGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHBvaW50ZXJFdmVudHNcbiAgfSksIFtwb2ludGVyRXZlbnRzXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaXNNZXNoU2l6ZVNldC5jdXJyZW50ID0gZmFsc2U7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgdmFyIF9yb290JGN1cnJlbnQ7XG4gICAgICAoX3Jvb3QkY3VycmVudCA9IHJvb3QuY3VycmVudCkgPT0gbnVsbCB8fCBfcm9vdCRjdXJyZW50LnJlbmRlcigvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHJlZjogdHJhbnNmb3JtT3V0ZXJSZWYsXG4gICAgICAgIHN0eWxlOiBzdHlsZXNcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgcmVmOiB0cmFuc2Zvcm1Jbm5lclJlZixcbiAgICAgICAgc3R5bGU6IHRyYW5zZm9ybUlubmVyU3R5bGVzXG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHJlZjogcmVmLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3Jvb3QkY3VycmVudDI7XG4gICAgICAoX3Jvb3QkY3VycmVudDIgPSByb290LmN1cnJlbnQpID09IG51bGwgfHwgX3Jvb3QkY3VycmVudDIucmVuZGVyKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgcmVmOiByZWYsXG4gICAgICAgIHN0eWxlOiBzdHlsZXMsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCB2aXNpYmxlID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICB1c2VGcmFtZShnbCA9PiB7XG4gICAgaWYgKGdyb3VwLmN1cnJlbnQpIHtcbiAgICAgIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgZ3JvdXAuY3VycmVudC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG4gICAgICBjb25zdCB2ZWMgPSB0cmFuc2Zvcm0gPyBvbGRQb3NpdGlvbi5jdXJyZW50IDogY2FsY3VsYXRlUG9zaXRpb24oZ3JvdXAuY3VycmVudCwgY2FtZXJhLCBzaXplKTtcbiAgICAgIGlmICh0cmFuc2Zvcm0gfHwgTWF0aC5hYnMob2xkWm9vbS5jdXJyZW50IC0gY2FtZXJhLnpvb20pID4gZXBzIHx8IE1hdGguYWJzKG9sZFBvc2l0aW9uLmN1cnJlbnRbMF0gLSB2ZWNbMF0pID4gZXBzIHx8IE1hdGguYWJzKG9sZFBvc2l0aW9uLmN1cnJlbnRbMV0gLSB2ZWNbMV0pID4gZXBzKSB7XG4gICAgICAgIGNvbnN0IGlzQmVoaW5kQ2FtZXJhID0gaXNPYmplY3RCZWhpbmRDYW1lcmEoZ3JvdXAuY3VycmVudCwgY2FtZXJhKTtcbiAgICAgICAgbGV0IHJheXRyYWNlVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgIGlmIChpc1JheUNhc3RPY2NsdXNpb24pIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvY2NsdWRlKSkge1xuICAgICAgICAgICAgcmF5dHJhY2VUYXJnZXQgPSBvY2NsdWRlLm1hcChpdGVtID0+IGl0ZW0uY3VycmVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvY2NsdWRlICE9PSAnYmxlbmRpbmcnKSB7XG4gICAgICAgICAgICByYXl0cmFjZVRhcmdldCA9IFtzY2VuZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzbHlWaXNpYmxlID0gdmlzaWJsZS5jdXJyZW50O1xuICAgICAgICBpZiAocmF5dHJhY2VUYXJnZXQpIHtcbiAgICAgICAgICBjb25zdCBpc3Zpc2libGUgPSBpc09iamVjdFZpc2libGUoZ3JvdXAuY3VycmVudCwgY2FtZXJhLCByYXljYXN0ZXIsIHJheXRyYWNlVGFyZ2V0KTtcbiAgICAgICAgICB2aXNpYmxlLmN1cnJlbnQgPSBpc3Zpc2libGUgJiYgIWlzQmVoaW5kQ2FtZXJhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZpc2libGUuY3VycmVudCA9ICFpc0JlaGluZENhbWVyYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNseVZpc2libGUgIT09IHZpc2libGUuY3VycmVudCkge1xuICAgICAgICAgIGlmIChvbk9jY2x1ZGUpIG9uT2NjbHVkZSghdmlzaWJsZS5jdXJyZW50KTtlbHNlIGVsLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlLmN1cnJlbnQgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbGZSYW5nZSA9IE1hdGguZmxvb3IoekluZGV4UmFuZ2VbMF0gLyAyKTtcbiAgICAgICAgY29uc3QgelJhbmdlID0gb2NjbHVkZSA/IGlzUmF5Q2FzdE9jY2x1c2lvbiAvL1xuICAgICAgICA/IFt6SW5kZXhSYW5nZVswXSwgaGFsZlJhbmdlXSA6IFtoYWxmUmFuZ2UgLSAxLCAwXSA6IHpJbmRleFJhbmdlO1xuICAgICAgICBlbC5zdHlsZS56SW5kZXggPSBgJHtvYmplY3RaSW5kZXgoZ3JvdXAuY3VycmVudCwgY2FtZXJhLCB6UmFuZ2UpfWA7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICBjb25zdCBbd2lkdGhIYWxmLCBoZWlnaHRIYWxmXSA9IFtzaXplLndpZHRoIC8gMiwgc2l6ZS5oZWlnaHQgLyAyXTtcbiAgICAgICAgICBjb25zdCBmb3YgPSBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1s1XSAqIGhlaWdodEhhbGY7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaXNPcnRob2dyYXBoaWNDYW1lcmEsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgcmlnaHRcbiAgICAgICAgICB9ID0gY2FtZXJhO1xuICAgICAgICAgIGNvbnN0IGNhbWVyYU1hdHJpeCA9IGdldENhbWVyYUNTU01hdHJpeChjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlKTtcbiAgICAgICAgICBjb25zdCBjYW1lcmFUcmFuc2Zvcm0gPSBpc09ydGhvZ3JhcGhpY0NhbWVyYSA/IGBzY2FsZSgke2Zvdn0pdHJhbnNsYXRlKCR7ZXBzaWxvbigtKHJpZ2h0ICsgbGVmdCkgLyAyKX1weCwke2Vwc2lsb24oKHRvcCArIGJvdHRvbSkgLyAyKX1weClgIDogYHRyYW5zbGF0ZVooJHtmb3Z9cHgpYDtcbiAgICAgICAgICBsZXQgbWF0cml4ID0gZ3JvdXAuY3VycmVudC5tYXRyaXhXb3JsZDtcbiAgICAgICAgICBpZiAoc3ByaXRlKSB7XG4gICAgICAgICAgICBtYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmNsb25lKCkudHJhbnNwb3NlKCkuY29weVBvc2l0aW9uKG1hdHJpeCkuc2NhbGUoZ3JvdXAuY3VycmVudC5zY2FsZSk7XG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbM10gPSBtYXRyaXguZWxlbWVudHNbN10gPSBtYXRyaXguZWxlbWVudHNbMTFdID0gMDtcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sxNV0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbC5zdHlsZS53aWR0aCA9IHNpemUud2lkdGggKyAncHgnO1xuICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IHNpemUuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICBlbC5zdHlsZS5wZXJzcGVjdGl2ZSA9IGlzT3J0aG9ncmFwaGljQ2FtZXJhID8gJycgOiBgJHtmb3Z9cHhgO1xuICAgICAgICAgIGlmICh0cmFuc2Zvcm1PdXRlclJlZi5jdXJyZW50ICYmIHRyYW5zZm9ybUlubmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybU91dGVyUmVmLmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtID0gYCR7Y2FtZXJhVHJhbnNmb3JtfSR7Y2FtZXJhTWF0cml4fXRyYW5zbGF0ZSgke3dpZHRoSGFsZn1weCwke2hlaWdodEhhbGZ9cHgpYDtcbiAgICAgICAgICAgIHRyYW5zZm9ybUlubmVyUmVmLmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtID0gZ2V0T2JqZWN0Q1NTTWF0cml4KG1hdHJpeCwgMSAvICgoZGlzdGFuY2VGYWN0b3IgfHwgMTApIC8gNDAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHNjYWxlID0gZGlzdGFuY2VGYWN0b3IgPT09IHVuZGVmaW5lZCA/IDEgOiBvYmplY3RTY2FsZShncm91cC5jdXJyZW50LCBjYW1lcmEpICogZGlzdGFuY2VGYWN0b3I7XG4gICAgICAgICAgZWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dmVjWzBdfXB4LCR7dmVjWzFdfXB4LDApIHNjYWxlKCR7c2NhbGV9KWA7XG4gICAgICAgIH1cbiAgICAgICAgb2xkUG9zaXRpb24uY3VycmVudCA9IHZlYztcbiAgICAgICAgb2xkWm9vbS5jdXJyZW50ID0gY2FtZXJhLnpvb207XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNSYXlDYXN0T2NjbHVzaW9uICYmIG9jY2x1c2lvbk1lc2hSZWYuY3VycmVudCAmJiAhaXNNZXNoU2l6ZVNldC5jdXJyZW50KSB7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1PdXRlclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgY29uc3QgZWwgPSB0cmFuc2Zvcm1PdXRlclJlZi5jdXJyZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICAgIGlmIChlbCAhPSBudWxsICYmIGVsLmNsaWVudFdpZHRoICYmIGVsICE9IG51bGwgJiYgZWwuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGlzT3J0aG9ncmFwaGljQ2FtZXJhXG4gICAgICAgICAgICB9ID0gY2FtZXJhO1xuICAgICAgICAgICAgaWYgKGlzT3J0aG9ncmFwaGljQ2FtZXJhIHx8IGdlb21ldHJ5KSB7XG4gICAgICAgICAgICAgIGlmIChwcm9wcy5zY2FsZSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wcy5zY2FsZSkpIHtcbiAgICAgICAgICAgICAgICAgIG9jY2x1c2lvbk1lc2hSZWYuY3VycmVudC5zY2FsZS5zZXRTY2FsYXIoMSAvIHByb3BzLnNjYWxlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzLnNjYWxlIGluc3RhbmNlb2YgVmVjdG9yMykge1xuICAgICAgICAgICAgICAgICAgb2NjbHVzaW9uTWVzaFJlZi5jdXJyZW50LnNjYWxlLmNvcHkocHJvcHMuc2NhbGUuY2xvbmUoKS5kaXZpZGVTY2FsYXIoMSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvY2NsdXNpb25NZXNoUmVmLmN1cnJlbnQuc2NhbGUuc2V0KDEgLyBwcm9wcy5zY2FsZVswXSwgMSAvIHByb3BzLnNjYWxlWzFdLCAxIC8gcHJvcHMuc2NhbGVbMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPSAoZGlzdGFuY2VGYWN0b3IgfHwgMTApIC8gNDAwO1xuICAgICAgICAgICAgICBjb25zdCB3ID0gZWwuY2xpZW50V2lkdGggKiByYXRpbztcbiAgICAgICAgICAgICAgY29uc3QgaCA9IGVsLmNsaWVudEhlaWdodCAqIHJhdGlvO1xuICAgICAgICAgICAgICBvY2NsdXNpb25NZXNoUmVmLmN1cnJlbnQuc2NhbGUuc2V0KHcsIGgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNNZXNoU2l6ZVNldC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVsZSA9IGVsLmNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAoZWxlICE9IG51bGwgJiYgZWxlLmNsaWVudFdpZHRoICYmIGVsZSAhPSBudWxsICYmIGVsZS5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICBjb25zdCByYXRpbyA9IDEgLyB2aWV3cG9ydC5mYWN0b3I7XG4gICAgICAgICAgY29uc3QgdyA9IGVsZS5jbGllbnRXaWR0aCAqIHJhdGlvO1xuICAgICAgICAgIGNvbnN0IGggPSBlbGUuY2xpZW50SGVpZ2h0ICogcmF0aW87XG4gICAgICAgICAgb2NjbHVzaW9uTWVzaFJlZi5jdXJyZW50LnNjYWxlLnNldCh3LCBoLCAxKTtcbiAgICAgICAgICBpc01lc2hTaXplU2V0LmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG9jY2x1c2lvbk1lc2hSZWYuY3VycmVudC5sb29rQXQoZ2wuY2FtZXJhLnBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBzaGFkZXJzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHZlcnRleFNoYWRlcjogIXRyYW5zZm9ybSA/IC8qIGdsc2wgKi9gXG4gICAgICAgICAgLypcbiAgICAgICAgICAgIFRoaXMgc2hhZGVyIGlzIGZyb20gdGhlIFRIUkVFJ3MgU3ByaXRlTWF0ZXJpYWwuXG4gICAgICAgICAgICBXZSBuZWVkIHRvIHR1cm4gdGhlIGJhY2tpbmcgcGxhbmUgaW50byBhIFNwcml0ZVxuICAgICAgICAgICAgKG1ha2UgaXQgYWx3YXlzIGZhY2UgdGhlIGNhbWVyYSkgaWYgXCJ0cmFuc2Zyb21cIlxuICAgICAgICAgICAgaXMgZmFsc2UuXG4gICAgICAgICAgKi9cbiAgICAgICAgICAjaW5jbHVkZSA8Y29tbW9uPlxuXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgdmVjMiBjZW50ZXIgPSB2ZWMyKDAuLCAxLik7XG4gICAgICAgICAgICBmbG9hdCByb3RhdGlvbiA9IDAuMDtcblxuICAgICAgICAgICAgLy8gVGhpcyBpcyBzb21ld2hhdCBhcmJpdHJhcnksIGJ1dCBpdCBzZWVtcyB0byB3b3JrIHdlbGxcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gZmlndXJlIG91dCBob3cgdG8gZGVyaXZlIHRoaXMgZHluYW1pY2FsbHkgaWYgaXQgZXZlbiBtYXR0ZXJzXG4gICAgICAgICAgICBmbG9hdCBzaXplID0gMC4wMztcblxuICAgICAgICAgICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7XG4gICAgICAgICAgICB2ZWMyIHNjYWxlO1xuICAgICAgICAgICAgc2NhbGUueCA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDAgXS54LCBtb2RlbE1hdHJpeFsgMCBdLnksIG1vZGVsTWF0cml4WyAwIF0ueiApICk7XG4gICAgICAgICAgICBzY2FsZS55ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMSBdLngsIG1vZGVsTWF0cml4WyAxIF0ueSwgbW9kZWxNYXRyaXhbIDEgXS56ICkgKTtcblxuICAgICAgICAgICAgYm9vbCBpc1BlcnNwZWN0aXZlID0gaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApO1xuICAgICAgICAgICAgaWYgKCBpc1BlcnNwZWN0aXZlICkgc2NhbGUgKj0gLSBtdlBvc2l0aW9uLno7XG5cbiAgICAgICAgICAgIHZlYzIgYWxpZ25lZFBvc2l0aW9uID0gKCBwb3NpdGlvbi54eSAtICggY2VudGVyIC0gdmVjMiggMC41ICkgKSApICogc2NhbGUgKiBzaXplO1xuICAgICAgICAgICAgdmVjMiByb3RhdGVkUG9zaXRpb247XG4gICAgICAgICAgICByb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7XG4gICAgICAgICAgICByb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7XG4gICAgICAgICAgICBtdlBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjtcblxuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICBgIDogdW5kZWZpbmVkLFxuICAgIGZyYWdtZW50U2hhZGVyOiAvKiBnbHNsICovYFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICB9XG4gICAgICBgXG4gIH0pLCBbdHJhbnNmb3JtXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHJlZjogZ3JvdXBcbiAgfSksIG9jY2x1ZGUgJiYgIWlzUmF5Q2FzdE9jY2x1c2lvbiAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwge1xuICAgIGNhc3RTaGFkb3c6IGNhc3RTaGFkb3csXG4gICAgcmVjZWl2ZVNoYWRvdzogcmVjZWl2ZVNoYWRvdyxcbiAgICByZWY6IG9jY2x1c2lvbk1lc2hSZWZcbiAgfSwgZ2VvbWV0cnkgfHwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIsIG51bGwpLCBtYXRlcmlhbCB8fCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNoYWRlck1hdGVyaWFsXCIsIHtcbiAgICBzaWRlOiBEb3VibGVTaWRlLFxuICAgIHZlcnRleFNoYWRlcjogc2hhZGVycy52ZXJ0ZXhTaGFkZXIsXG4gICAgZnJhZ21lbnRTaGFkZXI6IHNoYWRlcnMuZnJhZ21lbnRTaGFkZXJcbiAgfSkpKTtcbn0pO1xuXG5leHBvcnQgeyBIdG1sIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/web/Html.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useStore),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useThree),\n/* harmony export */   D: () => (/* binding */ useFrame),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useGraph),\n/* harmony export */   G: () => (/* binding */ useLoader),\n/* harmony export */   _: () => (/* binding */ _roots),\n/* harmony export */   a: () => (/* binding */ useMutableCallback),\n/* harmony export */   b: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   c: () => (/* binding */ createRoot),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ createPointerEvents),\n/* harmony export */   g: () => (/* binding */ createEvents),\n/* harmony export */   h: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ addEffect),\n/* harmony export */   k: () => (/* binding */ addAfterEffect),\n/* harmony export */   l: () => (/* binding */ addTail),\n/* harmony export */   m: () => (/* binding */ invalidate),\n/* harmony export */   n: () => (/* binding */ advance),\n/* harmony export */   o: () => (/* binding */ createPortal),\n/* harmony export */   p: () => (/* binding */ flushSync),\n/* harmony export */   q: () => (/* binding */ context),\n/* harmony export */   r: () => (/* binding */ reconciler),\n/* harmony export */   s: () => (/* binding */ applyProps),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useBridge),\n/* harmony export */   v: () => (/* binding */ getRootState),\n/* harmony export */   w: () => (/* binding */ dispose),\n/* harmony export */   x: () => (/* binding */ act),\n/* harmony export */   y: () => (/* binding */ buildGraph),\n/* harmony export */   z: () => (/* binding */ useInstanceHandle)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(app-pages-browser)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! zustand/traditional */ \"(app-pages-browser)/./node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-reconciler */ \"(app-pages-browser)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduler */ \"(app-pages-browser)/./node_modules/scheduler/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! suspend-react */ \"(app-pages-browser)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! its-fine */ \"(app-pages-browser)/./node_modules/its-fine/dist/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\n/**\n * Returns the instance's initial (outmost) root.\n */\nfunction findInitialRoot(instance) {\n  let root = instance.root;\n  while (root.getState().previousRoot) root = root.getState().previousRoot;\n  return root;\n}\n/**\n * Safely flush async effects when testing, simulating a legacy root.\n * @deprecated Import from React instead. import { act } from 'react'\n */\n// Reference with computed key to break Webpack static analysis\n// https://github.com/webpack/webpack/issues/14814\nconst act = react__WEBPACK_IMPORTED_MODULE_0__['act' + ''];\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nconst isRef = obj => obj && obj.hasOwnProperty('current');\nconst isColorRepresentation = value => value != null && (typeof value === 'string' || typeof value === 'number' || value.isColor);\n\n/**\n * An SSR-friendly useLayoutEffect.\n *\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect elsewhere.\n *\n * @see https://github.com/facebook/react/issues/14927\n */\nconst useIsomorphicLayoutEffect = /* @__PURE__ */((_window$document, _window$navigator) => typeof window !== 'undefined' && (((_window$document = window.document) == null ? void 0 : _window$document.createElement) || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === 'ReactNative'))() ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n  useIsomorphicLayoutEffect(() => void (ref.current = fn), [fn]);\n  return ref;\n}\n/**\n * Bridges renderer Context and StrictMode from a primary renderer.\n */\nfunction useBridge() {\n  const fiber = (0,its_fine__WEBPACK_IMPORTED_MODULE_5__.useFiber)();\n  const ContextBridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_5__.useContextBridge)();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    children\n  }) => {\n    const strict = !!(0,its_fine__WEBPACK_IMPORTED_MODULE_5__.traverseFiber)(fiber, true, node => node.type === react__WEBPACK_IMPORTED_MODULE_0__.StrictMode);\n    const Root = strict ? react__WEBPACK_IMPORTED_MODULE_0__.StrictMode : react__WEBPACK_IMPORTED_MODULE_0__.Fragment;\n    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Root, {\n      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ContextBridge, {\n        children: children\n      })\n    });\n  }, [fiber, ContextBridge]);\n}\nfunction Block({\n  set\n}) {\n  useIsomorphicLayoutEffect(() => {\n    set(new Promise(() => null));\n    return () => set(false);\n  }, [set]);\n  return null;\n}\n\n// NOTE: static members get down-level transpiled to mutations which break tree-shaking\nconst ErrorBoundary = /* @__PURE__ */(_ErrorBoundary => (_ErrorBoundary = class ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      error: false\n    };\n  }\n  componentDidCatch(err) {\n    this.props.set(err);\n  }\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n}, _ErrorBoundary.getDerivedStateFromError = () => ({\n  error: true\n}), _ErrorBoundary))();\nfunction calculateDpr(dpr) {\n  var _window$devicePixelRa;\n  // Err on the side of progress by assuming 2x dpr if we can't detect it\n  // This will happen in workers where window is defined but dpr isn't.\n  const target = typeof window !== 'undefined' ? (_window$devicePixelRa = window.devicePixelRatio) != null ? _window$devicePixelRa : 2 : 1;\n  return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n\n/**\n * Returns instance root state\n */\nfunction getRootState(obj) {\n  var _r3f;\n  return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n}\n// A collection of compare functions\nconst is = {\n  obj: a => a === Object(a) && !is.arr(a) && typeof a !== 'function',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  boo: a => typeof a === 'boolean',\n  und: a => a === void 0,\n  nul: a => a === null,\n  arr: a => Array.isArray(a),\n  equ(a, b, {\n    arrays = 'shallow',\n    objects = 'reference',\n    strict = true\n  } = {}) {\n    // Wrong type or one of the two undefined, doesn't match\n    if (typeof a !== typeof b || !!a !== !!b) return false;\n    // Atomic, just compare a against b\n    if (is.str(a) || is.num(a) || is.boo(a)) return a === b;\n    const isObj = is.obj(a);\n    if (isObj && objects === 'reference') return a === b;\n    const isArr = is.arr(a);\n    if (isArr && arrays === 'reference') return a === b;\n    // Array or Object, shallow compare first to see if it's a match\n    if ((isArr || isObj) && a === b) return true;\n    // Last resort, go through keys\n    let i;\n    // Check if a has all the keys of b\n    for (i in a) if (!(i in b)) return false;\n    // Check if values between keys match\n    if (isObj && arrays === 'shallow' && objects === 'shallow') {\n      for (i in strict ? b : a) if (!is.equ(a[i], b[i], {\n        strict,\n        objects: 'reference'\n      })) return false;\n    } else {\n      for (i in strict ? b : a) if (a[i] !== b[i]) return false;\n    }\n    // If i is undefined\n    if (is.und(i)) {\n      // If both arrays are empty we consider them equal\n      if (isArr && a.length === 0 && b.length === 0) return true;\n      // If both objects are empty we consider them equal\n      if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n      // Otherwise match them by value\n      if (a !== b) return false;\n    }\n    return true;\n  }\n};\n\n// Collects nodes and materials from a THREE.Object3D\nfunction buildGraph(object) {\n  const data = {\n    nodes: {},\n    materials: {},\n    meshes: {}\n  };\n  if (object) {\n    object.traverse(obj => {\n      if (obj.name) data.nodes[obj.name] = obj;\n      if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n      if (obj.isMesh && !data.meshes[obj.name]) data.meshes[obj.name] = obj;\n    });\n  }\n  return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n  if (obj.type !== 'Scene') obj.dispose == null ? void 0 : obj.dispose();\n  for (const p in obj) {\n    const prop = obj[p];\n    if ((prop == null ? void 0 : prop.type) !== 'Scene') prop == null ? void 0 : prop.dispose == null ? void 0 : prop.dispose();\n  }\n}\nconst REACT_INTERNAL_PROPS = ['children', 'key', 'ref'];\n\n// Gets only instance props from reconciler fibers\nfunction getInstanceProps(queue) {\n  const props = {};\n  for (const key in queue) {\n    if (!REACT_INTERNAL_PROPS.includes(key)) props[key] = queue[key];\n  }\n  return props;\n}\n\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(target, root, type, props) {\n  const object = target;\n\n  // Create instance descriptor\n  let instance = object == null ? void 0 : object.__r3f;\n  if (!instance) {\n    instance = {\n      root,\n      type,\n      parent: null,\n      children: [],\n      props: getInstanceProps(props),\n      object,\n      eventCount: 0,\n      handlers: {},\n      isHidden: false\n    };\n    if (object) object.__r3f = instance;\n  }\n  return instance;\n}\nfunction resolve(root, key) {\n  let target = root[key];\n  if (!key.includes('-')) return {\n    root,\n    key,\n    target\n  };\n\n  // Resolve pierced target\n  target = root;\n  for (const part of key.split('-')) {\n    var _target;\n    key = part;\n    root = target;\n    target = (_target = target) == null ? void 0 : _target[key];\n  }\n\n  // TODO: change key to 'foo-bar' if target is undefined?\n\n  return {\n    root,\n    key,\n    target\n  };\n}\n\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child) {\n  if (is.str(child.props.attach)) {\n    // If attaching into an array (foo-0), create one\n    if (INDEX_REGEX.test(child.props.attach)) {\n      const index = child.props.attach.replace(INDEX_REGEX, '');\n      const {\n        root,\n        key\n      } = resolve(parent.object, index);\n      if (!Array.isArray(root[key])) root[key] = [];\n    }\n    const {\n      root,\n      key\n    } = resolve(parent.object, child.props.attach);\n    child.previousAttach = root[key];\n    root[key] = child.object;\n  } else if (is.fun(child.props.attach)) {\n    child.previousAttach = child.props.attach(parent.object, child.object);\n  }\n}\nfunction detach(parent, child) {\n  if (is.str(child.props.attach)) {\n    const {\n      root,\n      key\n    } = resolve(parent.object, child.props.attach);\n    const previous = child.previousAttach;\n    // When the previous value was undefined, it means the value was never set to begin with\n    if (previous === undefined) delete root[key];\n    // Otherwise set the previous value\n    else root[key] = previous;\n  } else {\n    child.previousAttach == null ? void 0 : child.previousAttach(parent.object, child.object);\n  }\n  delete child.previousAttach;\n}\nconst RESERVED_PROPS = [...REACT_INTERNAL_PROPS,\n// Instance props\n'args', 'dispose', 'attach', 'object', 'onUpdate',\n// Behavior flags\n'dispose'];\nconst MEMOIZED_PROTOTYPES = new Map();\nfunction getMemoizedPrototype(root) {\n  let ctor = MEMOIZED_PROTOTYPES.get(root.constructor);\n  try {\n    if (!ctor) {\n      ctor = new root.constructor();\n      MEMOIZED_PROTOTYPES.set(root.constructor, ctor);\n    }\n  } catch (e) {\n    // ...\n  }\n  return ctor;\n}\n\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, newProps) {\n  const changedProps = {};\n\n  // Sort through props\n  for (const prop in newProps) {\n    // Skip reserved keys\n    if (RESERVED_PROPS.includes(prop)) continue;\n    // Skip if props match\n    if (is.equ(newProps[prop], instance.props[prop])) continue;\n\n    // Props changed, add them\n    changedProps[prop] = newProps[prop];\n\n    // Reset pierced props\n    for (const other in newProps) {\n      if (other.startsWith(`${prop}-`)) changedProps[other] = newProps[other];\n    }\n  }\n\n  // Reset removed props for HMR\n  for (const prop in instance.props) {\n    if (RESERVED_PROPS.includes(prop) || newProps.hasOwnProperty(prop)) continue;\n    const {\n      root,\n      key\n    } = resolve(instance.object, prop);\n\n    // https://github.com/mrdoob/three.js/issues/21209\n    // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n    // has no means to do this. Hence we curate a small collection of value-classes\n    // with their respective constructor/set arguments\n    // For removed props, try to set default values, if possible\n    if (root.constructor && root.constructor.length === 0) {\n      // create a blank slate of the instance and copy the particular parameter.\n      const ctor = getMemoizedPrototype(root);\n      if (!is.und(ctor)) changedProps[key] = ctor[key];\n    } else {\n      // instance does not have constructor, just set it to 0\n      changedProps[key] = 0;\n    }\n  }\n  return changedProps;\n}\n\n// https://github.com/mrdoob/three.js/pull/27042\n// https://github.com/mrdoob/three.js/pull/22748\nconst colorMaps = ['map', 'emissiveMap', 'sheenColorMap', 'specularColorMap', 'envMap'];\nconst EVENT_REGEX = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;\n// This function applies a set of changes to the instance\nfunction applyProps(object, props) {\n  var _instance$object;\n  const instance = object.__r3f;\n  const rootState = instance && findInitialRoot(instance).getState();\n  const prevHandlers = instance == null ? void 0 : instance.eventCount;\n  for (const prop in props) {\n    let value = props[prop];\n\n    // Don't mutate reserved keys\n    if (RESERVED_PROPS.includes(prop)) continue;\n\n    // Deal with pointer events, including removing them if undefined\n    if (instance && EVENT_REGEX.test(prop)) {\n      if (typeof value === 'function') instance.handlers[prop] = value;else delete instance.handlers[prop];\n      instance.eventCount = Object.keys(instance.handlers).length;\n      continue;\n    }\n\n    // Ignore setting undefined props\n    // https://github.com/pmndrs/react-three-fiber/issues/274\n    if (value === undefined) continue;\n    let {\n      root,\n      key,\n      target\n    } = resolve(object, prop);\n\n    // Layers must be written to the mask property\n    if (target instanceof three__WEBPACK_IMPORTED_MODULE_6__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_6__.Layers) {\n      target.mask = value.mask;\n    }\n    // Set colors if valid color representation for automatic conversion (copy)\n    else if (target instanceof three__WEBPACK_IMPORTED_MODULE_6__.Color && isColorRepresentation(value)) {\n      target.set(value);\n    }\n    // Copy if properties match signatures and implement math interface (likely read-only)\n    else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && typeof target.copy === 'function' && value != null && value.constructor && target.constructor === value.constructor) {\n      target.copy(value);\n    }\n    // Set array types\n    else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && Array.isArray(value)) {\n      if (typeof target.fromArray === 'function') target.fromArray(value);else target.set(...value);\n    }\n    // Set literal types\n    else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && typeof value === 'number') {\n      // Allow setting array scalars\n      if (typeof target.setScalar === 'function') target.setScalar(value);\n      // Otherwise just set single value\n      else target.set(value);\n    }\n    // Else, just overwrite the value\n    else {\n      var _root$key;\n      root[key] = value;\n\n      // Auto-convert sRGB texture parameters for built-in materials\n      // https://github.com/pmndrs/react-three-fiber/issues/344\n      // https://github.com/mrdoob/three.js/pull/25857\n      if (rootState && !rootState.linear && colorMaps.includes(key) && (_root$key = root[key]) != null && _root$key.isTexture &&\n      // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n      root[key].format === three__WEBPACK_IMPORTED_MODULE_6__.RGBAFormat && root[key].type === three__WEBPACK_IMPORTED_MODULE_6__.UnsignedByteType) {\n        // NOTE: this cannot be set from the renderer (e.g. sRGB source textures rendered to P3)\n        root[key].colorSpace = three__WEBPACK_IMPORTED_MODULE_6__.SRGBColorSpace;\n      }\n    }\n  }\n\n  // Register event handlers\n  if (instance != null && instance.parent && rootState != null && rootState.internal && (_instance$object = instance.object) != null && _instance$object.isObject3D && prevHandlers !== instance.eventCount) {\n    const object = instance.object;\n    // Pre-emptively remove the instance from the interaction manager\n    const index = rootState.internal.interaction.indexOf(object);\n    if (index > -1) rootState.internal.interaction.splice(index, 1);\n    // Add the instance to the interaction manager only when it has handlers\n    if (instance.eventCount && object.raycast !== null) {\n      rootState.internal.interaction.push(object);\n    }\n  }\n\n  // Auto-attach geometries and materials\n  if (instance && instance.props.attach === undefined) {\n    if (instance.object.isBufferGeometry) instance.props.attach = 'geometry';else if (instance.object.isMaterial) instance.props.attach = 'material';\n  }\n\n  // Instance was updated, request a frame\n  if (instance) invalidateInstance(instance);\n  return object;\n}\nfunction invalidateInstance(instance) {\n  var _instance$root;\n  if (!instance.parent) return;\n  instance.props.onUpdate == null ? void 0 : instance.props.onUpdate(instance.object);\n  const state = (_instance$root = instance.root) == null ? void 0 : _instance$root.getState == null ? void 0 : _instance$root.getState();\n  if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateCamera(camera, size) {\n  // Do not mess with the camera if it belongs to the user\n  // https://github.com/pmndrs/react-three-fiber/issues/92\n  if (camera.manual) return;\n  if (isOrthographicCamera(camera)) {\n    camera.left = size.width / -2;\n    camera.right = size.width / 2;\n    camera.top = size.height / 2;\n    camera.bottom = size.height / -2;\n  } else {\n    camera.aspect = size.width / size.height;\n  }\n  camera.updateProjectionMatrix();\n}\nconst isObject3D = object => object == null ? void 0 : object.isObject3D;\n\nfunction makeId(event) {\n  return (event.eventObject || event.object).uuid + '/' + event.index + event.instanceId;\n}\n\n/**\n * Release pointer captures.\n * This is called by releasePointerCapture in the API, and when an object is removed.\n */\nfunction releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n  const captureData = captures.get(obj);\n  if (captureData) {\n    captures.delete(obj);\n    // If this was the last capturing object for this pointer\n    if (captures.size === 0) {\n      capturedMap.delete(pointerId);\n      captureData.target.releasePointerCapture(pointerId);\n    }\n  }\n}\nfunction removeInteractivity(store, object) {\n  const {\n    internal\n  } = store.getState();\n  // Removes every trace of an object from the data store\n  internal.interaction = internal.interaction.filter(o => o !== object);\n  internal.initialHits = internal.initialHits.filter(o => o !== object);\n  internal.hovered.forEach((value, key) => {\n    if (value.eventObject === object || value.object === object) {\n      // Clear out intersects, they are outdated by now\n      internal.hovered.delete(key);\n    }\n  });\n  internal.capturedMap.forEach((captures, pointerId) => {\n    releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n  });\n}\nfunction createEvents(store) {\n  /** Calculates delta */\n  function calculateDistance(event) {\n    const {\n      internal\n    } = store.getState();\n    const dx = event.offsetX - internal.initialClick[0];\n    const dy = event.offsetY - internal.initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }\n\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n  function filterPointerEvents(objects) {\n    return objects.filter(obj => ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(name => {\n      var _r3f;\n      return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers['onPointer' + name];\n    }));\n  }\n  function intersect(event, filter) {\n    const state = store.getState();\n    const duplicates = new Set();\n    const intersections = [];\n    // Allow callers to eliminate event objects\n    const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n    // Reset all raycaster cameras to undefined\n    for (let i = 0; i < eventsObjects.length; i++) {\n      const state = getRootState(eventsObjects[i]);\n      if (state) {\n        state.raycaster.camera = undefined;\n      }\n    }\n    if (!state.previousRoot) {\n      // Make sure root-level pointer and ray are set up\n      state.events.compute == null ? void 0 : state.events.compute(event, state);\n    }\n    function handleRaycast(obj) {\n      const state = getRootState(obj);\n      // Skip event handling when noEvents is set, or when the raycasters camera is null\n      if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n\n      // When the camera is undefined we have to call the event layers update function\n      if (state.raycaster.camera === undefined) {\n        var _state$previousRoot;\n        state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n        // If the camera is still undefined we have to skip this layer entirely\n        if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n      }\n\n      // Intersect object by object\n      return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n    }\n\n    // Collect events\n    let hits = eventsObjects\n    // Intersect objects\n    .flatMap(handleRaycast)\n    // Sort by event priority and distance\n    .sort((a, b) => {\n      const aState = getRootState(a.object);\n      const bState = getRootState(b.object);\n      if (!aState || !bState) return a.distance - b.distance;\n      return bState.events.priority - aState.events.priority || a.distance - b.distance;\n    })\n    // Filter out duplicates\n    .filter(item => {\n      const id = makeId(item);\n      if (duplicates.has(id)) return false;\n      duplicates.add(id);\n      return true;\n    });\n\n    // https://github.com/mrdoob/three.js/issues/16031\n    // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n    if (state.events.filter) hits = state.events.filter(hits, state);\n\n    // Bubble up the events, find the event source (eventObject)\n    for (const hit of hits) {\n      let eventObject = hit.object;\n      // Bubble event up\n      while (eventObject) {\n        var _r3f2;\n        if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n          ...hit,\n          eventObject\n        });\n        eventObject = eventObject.parent;\n      }\n    }\n\n    // If the interaction is captured, make all capturing targets part of the intersect.\n    if ('pointerId' in event && state.internal.capturedMap.has(event.pointerId)) {\n      for (let captureData of state.internal.capturedMap.get(event.pointerId).values()) {\n        if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n      }\n    }\n    return intersections;\n  }\n\n  /**  Handles intersections by forwarding them to handlers */\n  function handleIntersects(intersections, event, delta, callback) {\n    // If anything has been found, forward it to the event listeners\n    if (intersections.length) {\n      const localState = {\n        stopped: false\n      };\n      for (const hit of intersections) {\n        let state = getRootState(hit.object);\n\n        // If the object is not managed by R3F, it might be parented to an element which is.\n        // Traverse upwards until we find a managed parent and use its state instead.\n        if (!state) {\n          hit.object.traverseAncestors(obj => {\n            const parentState = getRootState(obj);\n            if (parentState) {\n              state = parentState;\n              return false;\n            }\n          });\n        }\n        if (state) {\n          const {\n            raycaster,\n            pointer,\n            camera,\n            internal\n          } = state;\n          const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n          const hasPointerCapture = id => {\n            var _internal$capturedMap, _internal$capturedMap2;\n            return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n          };\n          const setPointerCapture = id => {\n            const captureData = {\n              intersection: hit,\n              target: event.target\n            };\n            if (internal.capturedMap.has(id)) {\n              // if the pointerId was previously captured, we add the hit to the\n              // event capturedMap.\n              internal.capturedMap.get(id).set(hit.eventObject, captureData);\n            } else {\n              // if the pointerId was not previously captured, we create a map\n              // containing the hitObject, and the hit. hitObject is used for\n              // faster access.\n              internal.capturedMap.set(id, new Map([[hit.eventObject, captureData]]));\n            }\n            event.target.setPointerCapture(id);\n          };\n          const releasePointerCapture = id => {\n            const captures = internal.capturedMap.get(id);\n            if (captures) {\n              releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n            }\n          };\n\n          // Add native event props\n          let extractEventProps = {};\n          // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n          for (let prop in event) {\n            let property = event[prop];\n            // Only copy over atomics, leave functions alone as these should be\n            // called as event.nativeEvent.fn()\n            if (typeof property !== 'function') extractEventProps[prop] = property;\n          }\n          let raycastEvent = {\n            ...hit,\n            ...extractEventProps,\n            pointer,\n            intersections,\n            stopped: localState.stopped,\n            delta,\n            unprojectedPoint,\n            ray: raycaster.ray,\n            camera: camera,\n            // Hijack stopPropagation, which just sets a flag\n            stopPropagation() {\n              // https://github.com/pmndrs/react-three-fiber/issues/596\n              // Events are not allowed to stop propagation if the pointer has been captured\n              const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId);\n\n              // We only authorize stopPropagation...\n              if (\n              // ...if this pointer hasn't been captured\n              !capturesForPointer ||\n              // ... or if the hit object is capturing the pointer\n              capturesForPointer.has(hit.eventObject)) {\n                raycastEvent.stopped = localState.stopped = true;\n                // Propagation is stopped, remove all other hover records\n                // An event handler is only allowed to flush other handlers if it is hovered itself\n                if (internal.hovered.size && Array.from(internal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\n                  // Objects cannot flush out higher up objects that have already caught the event\n                  const higher = intersections.slice(0, intersections.indexOf(hit));\n                  cancelPointer([...higher, hit]);\n                }\n              }\n            },\n            // there should be a distinction between target and currentTarget\n            target: {\n              hasPointerCapture,\n              setPointerCapture,\n              releasePointerCapture\n            },\n            currentTarget: {\n              hasPointerCapture,\n              setPointerCapture,\n              releasePointerCapture\n            },\n            nativeEvent: event\n          };\n\n          // Call subscribers\n          callback(raycastEvent);\n          // Event bubbling may be interrupted by stopPropagation\n          if (localState.stopped === true) break;\n        }\n      }\n    }\n    return intersections;\n  }\n  function cancelPointer(intersections) {\n    const {\n      internal\n    } = store.getState();\n    for (const hoveredObj of internal.hovered.values()) {\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n      if (!intersections.length || !intersections.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n        const eventObject = hoveredObj.eventObject;\n        const instance = eventObject.__r3f;\n        internal.hovered.delete(makeId(hoveredObj));\n        if (instance != null && instance.eventCount) {\n          const handlers = instance.handlers;\n          // Clear out intersects, they are outdated by now\n          const data = {\n            ...hoveredObj,\n            intersections\n          };\n          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n        }\n      }\n    }\n  }\n  function pointerMissed(event, objects) {\n    for (let i = 0; i < objects.length; i++) {\n      const instance = objects[i].__r3f;\n      instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n    }\n  }\n  function handlePointer(name) {\n    // Deal with cancelation\n    switch (name) {\n      case 'onPointerLeave':\n      case 'onPointerCancel':\n        return () => cancelPointer([]);\n      case 'onLostPointerCapture':\n        return event => {\n          const {\n            internal\n          } = store.getState();\n          if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n            // If the object event interface had onLostPointerCapture, we'd call it here on every\n            // object that's getting removed. We call it on the next frame because onLostPointerCapture\n            // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n            // happen in the object it originated from, leaving components in a in-between state.\n            requestAnimationFrame(() => {\n              // Only release if pointer-up didn't do it already\n              if (internal.capturedMap.has(event.pointerId)) {\n                internal.capturedMap.delete(event.pointerId);\n                cancelPointer([]);\n              }\n            });\n          }\n        };\n    }\n\n    // Any other pointer goes here ...\n    return function handleEvent(event) {\n      const {\n        onPointerMissed,\n        internal\n      } = store.getState();\n\n      // prepareRay(event)\n      internal.lastEvent.current = event;\n\n      // Get fresh intersects\n      const isPointerMove = name === 'onPointerMove';\n      const isClickEvent = name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick';\n      const filter = isPointerMove ? filterPointerEvents : undefined;\n      const hits = intersect(event, filter);\n      const delta = isClickEvent ? calculateDistance(event) : 0;\n\n      // Save initial coordinates on pointer-down\n      if (name === 'onPointerDown') {\n        internal.initialClick = [event.offsetX, event.offsetY];\n        internal.initialHits = hits.map(hit => hit.eventObject);\n      }\n\n      // If a click yields no results, pass it back to the user as a miss\n      // Missed events have to come first in order to establish user-land side-effect clean up\n      if (isClickEvent && !hits.length) {\n        if (delta <= 2) {\n          pointerMissed(event, internal.interaction);\n          if (onPointerMissed) onPointerMissed(event);\n        }\n      }\n      // Take care of unhover\n      if (isPointerMove) cancelPointer(hits);\n      function onIntersect(data) {\n        const eventObject = data.eventObject;\n        const instance = eventObject.__r3f;\n\n        // Check presence of handlers\n        if (!(instance != null && instance.eventCount)) return;\n        const handlers = instance.handlers;\n\n        /*\n        MAYBE TODO, DELETE IF NOT: \n          Check if the object is captured, captured events should not have intersects running in parallel\n          But wouldn't it be better to just replace capturedMap with a single entry?\n          Also, are we OK with straight up making picking up multiple objects impossible?\n          \n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \n        if (pointerId !== undefined) {\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\n          if (capturedMeshSet) {\n            const captured = capturedMeshSet.get(eventObject)\n            if (captured && captured.localState.stopped) return\n          }\n        }*/\n\n        if (isPointerMove) {\n          // Move event ...\n          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n            // When enter or out is present take care of hover-state\n            const id = makeId(data);\n            const hoveredItem = internal.hovered.get(id);\n            if (!hoveredItem) {\n              // If the object wasn't previously hovered, book it and call its handler\n              internal.hovered.set(id, data);\n              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n            } else if (hoveredItem.stopped) {\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n              data.stopPropagation();\n            }\n          }\n          // Call mouse move\n          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n        } else {\n          // All other events ...\n          const handler = handlers[name];\n          if (handler) {\n            // Forward all events back to their respective handlers with the exception of click events,\n            // which must use the initial target\n            if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n              // Missed events have to come first\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object)));\n              // Now call the handler\n              handler(data);\n            }\n          } else {\n            // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n            if (isClickEvent && internal.initialHits.includes(eventObject)) {\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object)));\n            }\n          }\n        }\n      }\n      handleIntersects(hits, event, delta, onIntersect);\n    };\n  }\n  return {\n    handlePointer\n  };\n}\n\nconst isRenderer = def => !!(def != null && def.render);\nconst context = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance) => {\n  const rootStore = (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_7__.createWithEqualityFn)((set, get) => {\n    const position = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n    const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n    const tempTarget = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n    function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n      const {\n        width,\n        height,\n        top,\n        left\n      } = size;\n      const aspect = width / height;\n      if (target.isVector3) tempTarget.copy(target);else tempTarget.set(...target);\n      const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n      if (isOrthographicCamera(camera)) {\n        return {\n          width: width / camera.zoom,\n          height: height / camera.zoom,\n          top,\n          left,\n          factor: 1,\n          distance,\n          aspect\n        };\n      } else {\n        const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n        const h = 2 * Math.tan(fov / 2) * distance; // visible height\n        const w = h * (width / height);\n        return {\n          width: w,\n          height: h,\n          top,\n          left,\n          factor: width / w,\n          distance,\n          aspect\n        };\n      }\n    }\n    let performanceTimeout = undefined;\n    const setPerformanceCurrent = current => set(state => ({\n      performance: {\n        ...state.performance,\n        current\n      }\n    }));\n    const pointer = new three__WEBPACK_IMPORTED_MODULE_6__.Vector2();\n    const rootState = {\n      set,\n      get,\n      // Mock objects that have to be configured\n      gl: null,\n      camera: null,\n      raycaster: null,\n      events: {\n        priority: 1,\n        enabled: true,\n        connected: false\n      },\n      scene: null,\n      xr: null,\n      invalidate: (frames = 1) => invalidate(get(), frames),\n      advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\n      legacy: false,\n      linear: false,\n      flat: false,\n      controls: null,\n      clock: new three__WEBPACK_IMPORTED_MODULE_6__.Clock(),\n      pointer,\n      mouse: pointer,\n      frameloop: 'always',\n      onPointerMissed: undefined,\n      performance: {\n        current: 1,\n        min: 0.5,\n        max: 1,\n        debounce: 200,\n        regress: () => {\n          const state = get();\n          // Clear timeout\n          if (performanceTimeout) clearTimeout(performanceTimeout);\n          // Set lower bound performance\n          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n          // Go back to upper bound performance after a while unless something regresses meanwhile\n          performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\n        }\n      },\n      size: {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n      },\n      viewport: {\n        initialDpr: 0,\n        dpr: 0,\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        aspect: 0,\n        distance: 0,\n        factor: 0,\n        getCurrentViewport\n      },\n      setEvents: events => set(state => ({\n        ...state,\n        events: {\n          ...state.events,\n          ...events\n        }\n      })),\n      setSize: (width, height, top = 0, left = 0) => {\n        const camera = get().camera;\n        const size = {\n          width,\n          height,\n          top,\n          left\n        };\n        set(state => ({\n          size,\n          viewport: {\n            ...state.viewport,\n            ...getCurrentViewport(camera, defaultTarget, size)\n          }\n        }));\n      },\n      setDpr: dpr => set(state => {\n        const resolved = calculateDpr(dpr);\n        return {\n          viewport: {\n            ...state.viewport,\n            dpr: resolved,\n            initialDpr: state.viewport.initialDpr || resolved\n          }\n        };\n      }),\n      setFrameloop: (frameloop = 'always') => {\n        const clock = get().clock;\n\n        // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n        clock.stop();\n        clock.elapsedTime = 0;\n        if (frameloop !== 'never') {\n          clock.start();\n          clock.elapsedTime = 0;\n        }\n        set(() => ({\n          frameloop\n        }));\n      },\n      previousRoot: undefined,\n      internal: {\n        // Events\n        interaction: [],\n        hovered: new Map(),\n        subscribers: [],\n        initialClick: [0, 0],\n        initialHits: [],\n        capturedMap: new Map(),\n        lastEvent: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n        // Updates\n        active: false,\n        frames: 0,\n        priority: 0,\n        subscribe: (ref, priority, store) => {\n          const internal = get().internal;\n          // If this subscription was given a priority, it takes rendering into its own hands\n          // For that reason we switch off automatic rendering and increase the manual flag\n          // As long as this flag is positive there can be no internal rendering at all\n          // because there could be multiple render subscriptions\n          internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n          internal.subscribers.push({\n            ref,\n            priority,\n            store\n          });\n          // Register subscriber and sort layers from lowest to highest, meaning,\n          // highest priority renders last (on top of the other frames)\n          internal.subscribers = internal.subscribers.sort((a, b) => a.priority - b.priority);\n          return () => {\n            const internal = get().internal;\n            if (internal != null && internal.subscribers) {\n              // Decrease manual flag if this subscription had a priority\n              internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n              // Remove subscriber from list\n              internal.subscribers = internal.subscribers.filter(s => s.ref !== ref);\n            }\n          };\n        }\n      }\n    };\n    return rootState;\n  });\n  const state = rootStore.getState();\n  let oldSize = state.size;\n  let oldDpr = state.viewport.dpr;\n  let oldCamera = state.camera;\n  rootStore.subscribe(() => {\n    const {\n      camera,\n      size,\n      viewport,\n      gl,\n      set\n    } = rootStore.getState();\n\n    // Resize camera and renderer on changes to size and pixelratio\n    if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n      oldSize = size;\n      oldDpr = viewport.dpr;\n      // Update camera & renderer\n      updateCamera(camera, size);\n      if (viewport.dpr > 0) gl.setPixelRatio(viewport.dpr);\n      const updateStyle = typeof HTMLCanvasElement !== 'undefined' && gl.domElement instanceof HTMLCanvasElement;\n      gl.setSize(size.width, size.height, updateStyle);\n    }\n\n    // Update viewport once the camera changes\n    if (camera !== oldCamera) {\n      oldCamera = camera;\n      // Update viewport\n      set(state => ({\n        viewport: {\n          ...state.viewport,\n          ...state.viewport.getCurrentViewport(camera)\n        }\n      }));\n    }\n  });\n\n  // Invalidate on any change\n  rootStore.subscribe(state => invalidate(state));\n\n  // Return root state\n  return rootStore;\n};\n\n/**\n * Exposes an object's {@link Instance}.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\n *\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\n */\nfunction useInstanceHandle(ref) {\n  const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(instance, () => ref.current.__r3f, [ref]);\n  return instance;\n}\n\n/**\n * Returns the R3F Canvas' Zustand store. Useful for [transient updates](https://github.com/pmndrs/zustand#transient-updates-for-often-occurring-state-changes).\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usestore\n */\nfunction useStore() {\n  const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n  if (!store) throw new Error('R3F: Hooks can only be used within the Canvas component!');\n  return store;\n}\n\n/**\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\n */\nfunction useThree(selector = state => state, equalityFn) {\n  return useStore()(selector, equalityFn);\n}\n\n/**\n * Executes a callback before render in a shared frame loop.\n * Can order effects with render priority or manually render with a positive priority.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\n */\nfunction useFrame(callback, renderPriority = 0) {\n  const store = useStore();\n  const subscribe = store.getState().internal.subscribe;\n  // Memoize ref\n  const ref = useMutableCallback(callback);\n  // Subscribe on mount, unsubscribe on unmount\n  useIsomorphicLayoutEffect(() => subscribe(ref, renderPriority, store), [renderPriority, subscribe, store]);\n  return null;\n}\n\n/**\n * Returns a node graph of an object with named nodes & materials.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\n */\nfunction useGraph(object) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => buildGraph(object), [object]);\n}\nconst memoizedLoaders = new WeakMap();\nconst isConstructor$1 = value => {\n  var _value$prototype;\n  return typeof value === 'function' && (value == null ? void 0 : (_value$prototype = value.prototype) == null ? void 0 : _value$prototype.constructor) === value;\n};\nfunction loadingFn(extensions, onProgress) {\n  return function (Proto, ...input) {\n    let loader;\n\n    // Construct and cache loader if constructor was passed\n    if (isConstructor$1(Proto)) {\n      loader = memoizedLoaders.get(Proto);\n      if (!loader) {\n        loader = new Proto();\n        memoizedLoaders.set(Proto, loader);\n      }\n    } else {\n      loader = Proto;\n    }\n\n    // Apply loader extensions\n    if (extensions) extensions(loader);\n\n    // Go through the urls and load them\n    return Promise.all(input.map(input => new Promise((res, reject) => loader.load(input, data => {\n      if (isObject3D(data == null ? void 0 : data.scene)) Object.assign(data, buildGraph(data.scene));\n      res(data);\n    }, onProgress, error => reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`))))));\n  };\n}\n\n/**\n * Synchronously loads and caches assets with a three loader.\n *\n * Note: this hook's caller must be wrapped with `React.Suspense`\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\n */\nfunction useLoader(loader, input, extensions, onProgress) {\n  // Use suspense to load async assets\n  const keys = Array.isArray(input) ? input : [input];\n  const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.suspend)(loadingFn(extensions, onProgress), [loader, ...keys], {\n    equal: is.equ\n  });\n  // Return the object(s)\n  return Array.isArray(input) ? results : results[0];\n}\n\n/**\n * Preloads an asset into cache as a side-effect.\n */\nuseLoader.preload = function (loader, input, extensions) {\n  const keys = Array.isArray(input) ? input : [input];\n  return (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.preload)(loadingFn(extensions), [loader, ...keys]);\n};\n\n/**\n * Removes a loaded asset from cache.\n */\nuseLoader.clear = function (loader, input) {\n  const keys = Array.isArray(input) ? input : [input];\n  return (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.clear)([loader, ...keys]);\n};\n\n// TODO: upstream to DefinitelyTyped for React 19\n// https://github.com/facebook/react/issues/28956\n\nfunction createReconciler(config) {\n  const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_2___default()(config);\n  reconciler.injectIntoDevTools({\n    bundleType: typeof process !== 'undefined' && \"development\" !== 'production' ? 1 : 0,\n    rendererPackageName: '@react-three/fiber',\n    version: react__WEBPACK_IMPORTED_MODULE_0__.version\n  });\n  return reconciler;\n}\nconst NoEventPriority = 0;\n\n// TODO: handle constructor overloads\n// https://github.com/pmndrs/react-three-fiber/pull/2931\n// https://github.com/microsoft/TypeScript/issues/37079\n\nconst catalogue = {};\nconst PREFIX_REGEX = /^three(?=[A-Z])/;\nconst toPascalCase = type => `${type[0].toUpperCase()}${type.slice(1)}`;\nlet i = 0;\nconst isConstructor = object => typeof object === 'function';\nfunction extend(objects) {\n  if (isConstructor(objects)) {\n    const Component = `${i++}`;\n    catalogue[Component] = objects;\n    return Component;\n  } else {\n    Object.assign(catalogue, objects);\n  }\n}\nfunction validateInstance(type, props) {\n  // Get target from catalogue\n  const name = toPascalCase(type);\n  const target = catalogue[name];\n\n  // Validate element target\n  if (type !== 'primitive' && !target) throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n\n  // Validate primitives\n  if (type === 'primitive' && !props.object) throw new Error(`R3F: Primitives without 'object' are invalid!`);\n\n  // Throw if an object or literal was passed for args\n  if (props.args !== undefined && !Array.isArray(props.args)) throw new Error('R3F: The args prop must be an array!');\n}\nfunction createInstance(type, props, root) {\n  var _props$object;\n  // Remove three* prefix from elements if native element not present\n  type = toPascalCase(type) in catalogue ? type : type.replace(PREFIX_REGEX, '');\n  validateInstance(type, props);\n\n  // Regenerate the R3F instance for primitives to simulate a new object\n  if (type === 'primitive' && (_props$object = props.object) != null && _props$object.__r3f) delete props.object.__r3f;\n  return prepare(props.object, root, type, props);\n}\nfunction hideInstance(instance) {\n  if (!instance.isHidden) {\n    var _instance$parent;\n    if (instance.props.attach && (_instance$parent = instance.parent) != null && _instance$parent.object) {\n      detach(instance.parent, instance);\n    } else if (isObject3D(instance.object)) {\n      instance.object.visible = false;\n    }\n    instance.isHidden = true;\n    invalidateInstance(instance);\n  }\n}\nfunction unhideInstance(instance) {\n  if (instance.isHidden) {\n    var _instance$parent2;\n    if (instance.props.attach && (_instance$parent2 = instance.parent) != null && _instance$parent2.object) {\n      attach(instance.parent, instance);\n    } else if (isObject3D(instance.object) && instance.props.visible !== false) {\n      instance.object.visible = true;\n    }\n    instance.isHidden = false;\n    invalidateInstance(instance);\n  }\n}\n\n// https://github.com/facebook/react/issues/20271\n// This will make sure events and attach are only handled once when trees are complete\nfunction handleContainerEffects(parent, child, beforeChild) {\n  // Bail if tree isn't mounted or parent is not a container.\n  // This ensures that the tree is finalized and React won't discard results to Suspense\n  const state = child.root.getState();\n  if (!parent.parent && parent.object !== state.scene) return;\n\n  // Create & link object on first run\n  if (!child.object) {\n    var _child$props$object, _child$props$args;\n    // Get target from catalogue\n    const target = catalogue[toPascalCase(child.type)];\n\n    // Create object\n    child.object = (_child$props$object = child.props.object) != null ? _child$props$object : new target(...((_child$props$args = child.props.args) != null ? _child$props$args : []));\n    child.object.__r3f = child;\n  }\n\n  // Set initial props\n  applyProps(child.object, child.props);\n\n  // Append instance\n  if (child.props.attach) {\n    attach(parent, child);\n  } else if (isObject3D(child.object) && isObject3D(parent.object)) {\n    const childIndex = parent.object.children.indexOf(beforeChild == null ? void 0 : beforeChild.object);\n    if (beforeChild && childIndex !== -1) {\n      // If the child is already in the parent's children array, move it to the new position\n      // Otherwise, just insert it at the target position\n      const existingIndex = parent.object.children.indexOf(child.object);\n      if (existingIndex !== -1) {\n        parent.object.children.splice(existingIndex, 1);\n        const adjustedIndex = existingIndex < childIndex ? childIndex - 1 : childIndex;\n        parent.object.children.splice(adjustedIndex, 0, child.object);\n      } else {\n        child.object.parent = parent.object;\n        parent.object.children.splice(childIndex, 0, child.object);\n        child.object.dispatchEvent({\n          type: 'added'\n        });\n        parent.object.dispatchEvent({\n          type: 'childadded',\n          child: child.object\n        });\n      }\n    } else {\n      parent.object.add(child.object);\n    }\n  }\n\n  // Link subtree\n  for (const childInstance of child.children) handleContainerEffects(child, childInstance);\n\n  // Tree was updated, request a frame\n  invalidateInstance(child);\n}\nfunction appendChild(parent, child) {\n  if (!child) return;\n\n  // Link instances\n  child.parent = parent;\n  parent.children.push(child);\n\n  // Attach tree once complete\n  handleContainerEffects(parent, child);\n}\nfunction insertBefore(parent, child, beforeChild) {\n  if (!child || !beforeChild) return;\n\n  // Link instances\n  child.parent = parent;\n  const childIndex = parent.children.indexOf(beforeChild);\n  if (childIndex !== -1) parent.children.splice(childIndex, 0, child);else parent.children.push(child);\n\n  // Attach tree once complete\n  handleContainerEffects(parent, child, beforeChild);\n}\nfunction disposeOnIdle(object) {\n  if (typeof object.dispose === 'function') {\n    const handleDispose = () => {\n      try {\n        object.dispose();\n      } catch {\n        // no-op\n      }\n    };\n\n    // In a testing environment, cleanup immediately\n    if (typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined') handleDispose();\n    // Otherwise, using a real GPU so schedule cleanup to prevent stalls\n    else (0,scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_IdlePriority, handleDispose);\n  }\n}\nfunction removeChild(parent, child, dispose) {\n  if (!child) return;\n\n  // Unlink instances\n  child.parent = null;\n  const childIndex = parent.children.indexOf(child);\n  if (childIndex !== -1) parent.children.splice(childIndex, 1);\n\n  // Eagerly tear down tree\n  if (child.props.attach) {\n    detach(parent, child);\n  } else if (isObject3D(child.object) && isObject3D(parent.object)) {\n    parent.object.remove(child.object);\n    removeInteractivity(findInitialRoot(child), child.object);\n  }\n\n  // Allow objects to bail out of unmount disposal with dispose={null}\n  const shouldDispose = child.props.dispose !== null && dispose !== false;\n\n  // Recursively remove instance children\n  for (let i = child.children.length - 1; i >= 0; i--) {\n    const node = child.children[i];\n    removeChild(child, node, shouldDispose);\n  }\n  child.children.length = 0;\n\n  // Unlink instance object\n  delete child.object.__r3f;\n\n  // Dispose object whenever the reconciler feels like it.\n  // Never dispose of primitives because their state may be kept outside of React!\n  // In order for an object to be able to dispose it\n  //   - has a dispose method\n  //   - cannot be a <primitive object={...} />\n  //   - cannot be a THREE.Scene, because three has broken its own API\n  if (shouldDispose && child.type !== 'primitive' && child.object.type !== 'Scene') {\n    disposeOnIdle(child.object);\n  }\n\n  // Tree was updated, request a frame for top-level instance\n  if (dispose === undefined) invalidateInstance(child);\n}\nfunction setFiberRef(fiber, publicInstance) {\n  for (const _fiber of [fiber, fiber.alternate]) {\n    if (_fiber !== null) {\n      if (typeof _fiber.ref === 'function') {\n        _fiber.refCleanup == null ? void 0 : _fiber.refCleanup();\n        const cleanup = _fiber.ref(publicInstance);\n        if (typeof cleanup === 'function') _fiber.refCleanup = cleanup;\n      } else if (_fiber.ref) {\n        _fiber.ref.current = publicInstance;\n      }\n    }\n  }\n}\nconst reconstructed = [];\nfunction swapInstances() {\n  // Detach instance\n  for (const [instance] of reconstructed) {\n    const parent = instance.parent;\n    if (parent) {\n      if (instance.props.attach) {\n        detach(parent, instance);\n      } else if (isObject3D(instance.object) && isObject3D(parent.object)) {\n        parent.object.remove(instance.object);\n      }\n      for (const child of instance.children) {\n        if (child.props.attach) {\n          detach(instance, child);\n        } else if (isObject3D(child.object) && isObject3D(instance.object)) {\n          instance.object.remove(child.object);\n        }\n      }\n    }\n\n    // If the old instance is hidden, we need to unhide it.\n    // React assumes it can discard instances since they're pure for DOM.\n    // This isn't true for us since our lifetimes are impure and longliving.\n    // So, we manually check if an instance was hidden and unhide it.\n    if (instance.isHidden) unhideInstance(instance);\n\n    // Dispose of old object if able\n    if (instance.object.__r3f) delete instance.object.__r3f;\n    if (instance.type !== 'primitive') disposeOnIdle(instance.object);\n  }\n\n  // Update instance\n  for (const [instance, props, fiber] of reconstructed) {\n    instance.props = props;\n    const parent = instance.parent;\n    if (parent) {\n      var _instance$props$objec, _instance$props$args;\n      // Get target from catalogue\n      const target = catalogue[toPascalCase(instance.type)];\n\n      // Create object\n      instance.object = (_instance$props$objec = instance.props.object) != null ? _instance$props$objec : new target(...((_instance$props$args = instance.props.args) != null ? _instance$props$args : []));\n      instance.object.__r3f = instance;\n      setFiberRef(fiber, instance.object);\n\n      // Set initial props\n      applyProps(instance.object, instance.props);\n      if (instance.props.attach) {\n        attach(parent, instance);\n      } else if (isObject3D(instance.object) && isObject3D(parent.object)) {\n        parent.object.add(instance.object);\n      }\n      for (const child of instance.children) {\n        if (child.props.attach) {\n          attach(instance, child);\n        } else if (isObject3D(child.object) && isObject3D(instance.object)) {\n          instance.object.add(child.object);\n        }\n      }\n\n      // Tree was updated, request a frame\n      invalidateInstance(instance);\n    }\n  }\n  reconstructed.length = 0;\n}\n\n// Don't handle text instances, make it no-op\nconst handleTextInstance = () => {};\nconst NO_CONTEXT = {};\nlet currentUpdatePriority = NoEventPriority;\n\n// https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberFlags.js\nconst NoFlags = 0;\nconst Update = 4;\nconst reconciler = /* @__PURE__ */createReconciler({\n  isPrimaryRenderer: false,\n  warnsIfNotActing: false,\n  supportsMutation: true,\n  supportsPersistence: false,\n  supportsHydration: false,\n  createInstance,\n  removeChild,\n  appendChild,\n  appendInitialChild: appendChild,\n  insertBefore,\n  appendChildToContainer(container, child) {\n    const scene = container.getState().scene.__r3f;\n    if (!child || !scene) return;\n    appendChild(scene, child);\n  },\n  removeChildFromContainer(container, child) {\n    const scene = container.getState().scene.__r3f;\n    if (!child || !scene) return;\n    removeChild(scene, child);\n  },\n  insertInContainerBefore(container, child, beforeChild) {\n    const scene = container.getState().scene.__r3f;\n    if (!child || !beforeChild || !scene) return;\n    insertBefore(scene, child, beforeChild);\n  },\n  getRootHostContext: () => NO_CONTEXT,\n  getChildHostContext: () => NO_CONTEXT,\n  commitUpdate(instance, type, oldProps, newProps, fiber) {\n    var _newProps$args, _oldProps$args, _newProps$args2;\n    validateInstance(type, newProps);\n    let reconstruct = false;\n\n    // Reconstruct primitives if object prop changes\n    if (instance.type === 'primitive' && oldProps.object !== newProps.object) reconstruct = true;\n    // Reconstruct instance if args were added or removed\n    else if (((_newProps$args = newProps.args) == null ? void 0 : _newProps$args.length) !== ((_oldProps$args = oldProps.args) == null ? void 0 : _oldProps$args.length)) reconstruct = true;\n    // Reconstruct instance if args were changed\n    else if ((_newProps$args2 = newProps.args) != null && _newProps$args2.some((value, index) => {\n      var _oldProps$args2;\n      return value !== ((_oldProps$args2 = oldProps.args) == null ? void 0 : _oldProps$args2[index]);\n    })) reconstruct = true;\n\n    // Reconstruct when args or <primitive object={...} have changes\n    if (reconstruct) {\n      reconstructed.push([instance, {\n        ...newProps\n      }, fiber]);\n    } else {\n      // Create a diff-set, flag if there are any changes\n      const changedProps = diffProps(instance, newProps);\n      if (Object.keys(changedProps).length) {\n        Object.assign(instance.props, changedProps);\n        applyProps(instance.object, changedProps);\n      }\n    }\n\n    // Flush reconstructed siblings when we hit the last updated child in a sequence\n    const isTailSibling = fiber.sibling === null || (fiber.flags & Update) === NoFlags;\n    if (isTailSibling) swapInstances();\n  },\n  finalizeInitialChildren: () => false,\n  commitMount() {},\n  getPublicInstance: instance => instance == null ? void 0 : instance.object,\n  prepareForCommit: () => null,\n  preparePortalMount: container => prepare(container.getState().scene, container, '', {}),\n  resetAfterCommit: () => {},\n  shouldSetTextContent: () => false,\n  clearContainer: () => false,\n  hideInstance,\n  unhideInstance,\n  createTextInstance: handleTextInstance,\n  hideTextInstance: handleTextInstance,\n  unhideTextInstance: handleTextInstance,\n  scheduleTimeout: typeof setTimeout === 'function' ? setTimeout : undefined,\n  cancelTimeout: typeof clearTimeout === 'function' ? clearTimeout : undefined,\n  noTimeout: -1,\n  getInstanceFromNode: () => null,\n  beforeActiveInstanceBlur() {},\n  afterActiveInstanceBlur() {},\n  detachDeletedInstance() {},\n  prepareScopeUpdate() {},\n  getInstanceFromScope: () => null,\n  shouldAttemptEagerTransition: () => false,\n  trackSchedulerEvent: () => {},\n  resolveEventType: () => null,\n  resolveEventTimeStamp: () => -1.1,\n  requestPostPaintCallback() {},\n  maySuspendCommit: () => false,\n  preloadInstance: () => true,\n  // true indicates already loaded\n  startSuspendingCommit() {},\n  suspendInstance() {},\n  waitForCommitToBeReady: () => null,\n  NotPendingTransition: null,\n  HostTransitionContext: /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createContext(null),\n  setCurrentUpdatePriority(newPriority) {\n    currentUpdatePriority = newPriority;\n  },\n  getCurrentUpdatePriority() {\n    return currentUpdatePriority;\n  },\n  resolveUpdatePriority() {\n    var _window$event;\n    if (currentUpdatePriority !== NoEventPriority) return currentUpdatePriority;\n    switch (typeof window !== 'undefined' && ((_window$event = window.event) == null ? void 0 : _window$event.type)) {\n      case 'click':\n      case 'contextmenu':\n      case 'dblclick':\n      case 'pointercancel':\n      case 'pointerdown':\n      case 'pointerup':\n        return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n      case 'pointermove':\n      case 'pointerout':\n      case 'pointerover':\n      case 'pointerenter':\n      case 'pointerleave':\n      case 'wheel':\n        return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n      default:\n        return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    }\n  },\n  resetFormInstance() {}\n});\n\nconst _roots = new Map();\nconst shallowLoose = {\n  objects: 'shallow',\n  strict: false\n};\nfunction computeInitialSize(canvas, size) {\n  if (!size && typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n    const {\n      width,\n      height,\n      top,\n      left\n    } = canvas.parentElement.getBoundingClientRect();\n    return {\n      width,\n      height,\n      top,\n      left\n    };\n  } else if (!size && typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n    return {\n      width: canvas.width,\n      height: canvas.height,\n      top: 0,\n      left: 0\n    };\n  }\n  return {\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0,\n    ...size\n  };\n}\nfunction createRoot(canvas) {\n  // Check against mistaken use of createRoot\n  const prevRoot = _roots.get(canvas);\n  const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n  const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n  if (prevRoot) console.warn('R3F.createRoot should only be called once!');\n\n  // Report when an error was detected in a previous render\n  // https://github.com/pmndrs/react-three-fiber/pull/2261\n  const logRecoverableError = typeof reportError === 'function' ?\n  // In modern browsers, reportError will dispatch an error event,\n  // emulating an uncaught JavaScript error.\n  reportError :\n  // In older browsers and test environments, fallback to console.error.\n  console.error;\n\n  // Create store\n  const store = prevStore || createStore(invalidate, advance);\n  // Create renderer\n  const fiber = prevFiber || reconciler.createContainer(store,\n  // container\n  react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot,\n  // tag\n  null,\n  // hydration callbacks\n  false,\n  // isStrictMode\n  null,\n  // concurrentUpdatesByDefaultOverride\n  '',\n  // identifierPrefix\n  logRecoverableError,\n  // onUncaughtError\n  logRecoverableError,\n  // onCaughtError\n  logRecoverableError,\n  // onRecoverableError\n  null // transitionCallbacks\n  );\n  // Map it\n  if (!prevRoot) _roots.set(canvas, {\n    fiber,\n    store\n  });\n\n  // Locals\n  let onCreated;\n  let lastCamera;\n  let configured = false;\n  let pending = null;\n  return {\n    async configure(props = {}) {\n      let resolve;\n      pending = new Promise(_resolve => resolve = _resolve);\n      let {\n        gl: glConfig,\n        size: propsSize,\n        scene: sceneOptions,\n        events,\n        onCreated: onCreatedCallback,\n        shadows = false,\n        linear = false,\n        flat = false,\n        legacy = false,\n        orthographic = false,\n        frameloop = 'always',\n        dpr = [1, 2],\n        performance,\n        raycaster: raycastOptions,\n        camera: cameraOptions,\n        onPointerMissed\n      } = props;\n      let state = store.getState();\n\n      // Set up renderer (one time only!)\n      let gl = state.gl;\n      if (!state.gl) {\n        const defaultProps = {\n          canvas: canvas,\n          powerPreference: 'high-performance',\n          antialias: true,\n          alpha: true\n        };\n        const customRenderer = typeof glConfig === 'function' ? await glConfig(defaultProps) : glConfig;\n        if (isRenderer(customRenderer)) {\n          gl = customRenderer;\n        } else {\n          gl = new three__WEBPACK_IMPORTED_MODULE_6__.WebGLRenderer({\n            ...defaultProps,\n            ...glConfig\n          });\n        }\n        state.set({\n          gl\n        });\n      }\n\n      // Set up raycaster (one time only!)\n      let raycaster = state.raycaster;\n      if (!raycaster) state.set({\n        raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_6__.Raycaster()\n      });\n\n      // Set raycaster options\n      const {\n        params,\n        ...options\n      } = raycastOptions || {};\n      if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n        ...options\n      });\n      if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n        params: {\n          ...raycaster.params,\n          ...params\n        }\n      });\n\n      // Create default camera, don't overwrite any user-set state\n      if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n        lastCamera = cameraOptions;\n        const isCamera = cameraOptions == null ? void 0 : cameraOptions.isCamera;\n        const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_6__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_6__.PerspectiveCamera(75, 0, 0.1, 1000);\n        if (!isCamera) {\n          camera.position.z = 5;\n          if (cameraOptions) {\n            applyProps(camera, cameraOptions);\n            // Preserve user-defined frustum if possible\n            // https://github.com/pmndrs/react-three-fiber/issues/3160\n            if (!camera.manual) {\n              if ('aspect' in cameraOptions || 'left' in cameraOptions || 'right' in cameraOptions || 'bottom' in cameraOptions || 'top' in cameraOptions) {\n                camera.manual = true;\n                camera.updateProjectionMatrix();\n              }\n            }\n          }\n          // Always look at center by default\n          if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n        }\n        state.set({\n          camera\n        });\n\n        // Configure raycaster\n        // https://github.com/pmndrs/react-xr/issues/300\n        raycaster.camera = camera;\n      }\n\n      // Set up scene (one time only!)\n      if (!state.scene) {\n        let scene;\n        if (sceneOptions != null && sceneOptions.isScene) {\n          scene = sceneOptions;\n          prepare(scene, store, '', {});\n        } else {\n          scene = new three__WEBPACK_IMPORTED_MODULE_6__.Scene();\n          prepare(scene, store, '', {});\n          if (sceneOptions) applyProps(scene, sceneOptions);\n        }\n        state.set({\n          scene\n        });\n      }\n\n      // Store events internally\n      if (events && !state.events.handlers) state.set({\n        events: events(store)\n      });\n      // Check size, allow it to take on container bounds initially\n      const size = computeInitialSize(canvas, propsSize);\n      if (!is.equ(size, state.size, shallowLoose)) {\n        state.setSize(size.width, size.height, size.top, size.left);\n      }\n      // Check pixelratio\n      if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n      // Check frameloop\n      if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n      // Check pointer missed\n      if (!state.onPointerMissed) state.set({\n        onPointerMissed\n      });\n      // Check performance\n      if (performance && !is.equ(performance, state.performance, shallowLoose)) state.set(state => ({\n        performance: {\n          ...state.performance,\n          ...performance\n        }\n      }));\n\n      // Set up XR (one time only!)\n      if (!state.xr) {\n        var _gl$xr;\n        // Handle frame behavior in WebXR\n        const handleXRFrame = (timestamp, frame) => {\n          const state = store.getState();\n          if (state.frameloop === 'never') return;\n          advance(timestamp, true, state, frame);\n        };\n\n        // Toggle render switching on session\n        const handleSessionChange = () => {\n          const state = store.getState();\n          state.gl.xr.enabled = state.gl.xr.isPresenting;\n          state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n          if (!state.gl.xr.isPresenting) invalidate(state);\n        };\n\n        // WebXR session manager\n        const xr = {\n          connect() {\n            const gl = store.getState().gl;\n            gl.xr.addEventListener('sessionstart', handleSessionChange);\n            gl.xr.addEventListener('sessionend', handleSessionChange);\n          },\n          disconnect() {\n            const gl = store.getState().gl;\n            gl.xr.removeEventListener('sessionstart', handleSessionChange);\n            gl.xr.removeEventListener('sessionend', handleSessionChange);\n          }\n        };\n\n        // Subscribe to WebXR session events\n        if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === 'function') xr.connect();\n        state.set({\n          xr\n        });\n      }\n\n      // Set shadowmap\n      if (gl.shadowMap) {\n        const oldEnabled = gl.shadowMap.enabled;\n        const oldType = gl.shadowMap.type;\n        gl.shadowMap.enabled = !!shadows;\n        if (is.boo(shadows)) {\n          gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap;\n        } else if (is.str(shadows)) {\n          var _types$shadows;\n          const types = {\n            basic: three__WEBPACK_IMPORTED_MODULE_6__.BasicShadowMap,\n            percentage: three__WEBPACK_IMPORTED_MODULE_6__.PCFShadowMap,\n            soft: three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap,\n            variance: three__WEBPACK_IMPORTED_MODULE_6__.VSMShadowMap\n          };\n          gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap;\n        } else if (is.obj(shadows)) {\n          Object.assign(gl.shadowMap, shadows);\n        }\n        if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n      }\n      three__WEBPACK_IMPORTED_MODULE_6__.ColorManagement.enabled = !legacy;\n\n      // Set color space and tonemapping preferences\n      if (!configured) {\n        gl.outputColorSpace = linear ? three__WEBPACK_IMPORTED_MODULE_6__.LinearSRGBColorSpace : three__WEBPACK_IMPORTED_MODULE_6__.SRGBColorSpace;\n        gl.toneMapping = flat ? three__WEBPACK_IMPORTED_MODULE_6__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_6__.ACESFilmicToneMapping;\n      }\n\n      // Update color management state\n      if (state.legacy !== legacy) state.set(() => ({\n        legacy\n      }));\n      if (state.linear !== linear) state.set(() => ({\n        linear\n      }));\n      if (state.flat !== flat) state.set(() => ({\n        flat\n      }));\n\n      // Set gl props\n      if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n\n      // Set locals\n      onCreated = onCreatedCallback;\n      configured = true;\n      resolve();\n      return this;\n    },\n    render(children) {\n      // The root has to be configured before it can be rendered\n      if (!configured && !pending) this.configure();\n      pending.then(() => {\n        reconciler.updateContainer( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Provider, {\n          store: store,\n          children: children,\n          onCreated: onCreated,\n          rootElement: canvas\n        }), fiber, null, () => undefined);\n      });\n      return store;\n    },\n    unmount() {\n      unmountComponentAtNode(canvas);\n    }\n  };\n}\nfunction Provider({\n  store,\n  children,\n  onCreated,\n  rootElement\n}) {\n  useIsomorphicLayoutEffect(() => {\n    const state = store.getState();\n    // Flag the canvas active, rendering will now begin\n    state.set(state => ({\n      internal: {\n        ...state.internal,\n        active: true\n      }\n    }));\n    // Notify that init is completed, the scene graph exists, but nothing has yet rendered\n    if (onCreated) onCreated(state);\n    // Connect events to the targets parent, this is done to ensure events are registered on\n    // a shared target, and not on the canvas itself\n    if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(context.Provider, {\n    value: store,\n    children: children\n  });\n}\nfunction unmountComponentAtNode(canvas, callback) {\n  const root = _roots.get(canvas);\n  const fiber = root == null ? void 0 : root.fiber;\n  if (fiber) {\n    const state = root == null ? void 0 : root.store.getState();\n    if (state) state.internal.active = false;\n    reconciler.updateContainer(null, fiber, null, () => {\n      if (state) {\n        setTimeout(() => {\n          try {\n            var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n            state.events.disconnect == null ? void 0 : state.events.disconnect();\n            (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n            (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n            if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n            dispose(state.scene);\n            _roots.delete(canvas);\n            if (callback) callback(canvas);\n          } catch (e) {\n            /* ... */\n          }\n        }, 500);\n      }\n    });\n  }\n}\nfunction createPortal(children, container, state) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Portal, {\n    children: children,\n    container: container,\n    state: state\n  });\n}\nfunction Portal({\n  state = {},\n  children,\n  container\n}) {\n  /** This has to be a component because it would not be able to call useThree/useStore otherwise since\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\n   *  <Canvas>\n   *    {createPortal(...)} */\n  const {\n    events,\n    size,\n    ...rest\n  } = state;\n  const previousRoot = useStore();\n  const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new three__WEBPACK_IMPORTED_MODULE_6__.Raycaster());\n  const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new three__WEBPACK_IMPORTED_MODULE_6__.Vector2());\n  const inject = useMutableCallback((rootState, injectState) => {\n    let viewport = undefined;\n    if (injectState.camera && size) {\n      const camera = injectState.camera;\n      // Calculate the override viewport, if present\n      viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(), size);\n      // Update the portal camera, if it differs from the previous layer\n      if (camera !== rootState.camera) updateCamera(camera, size);\n    }\n    return {\n      // The intersect consists of the previous root state\n      ...rootState,\n      ...injectState,\n      // Portals have their own scene, which forms the root, a raycaster and a pointer\n      scene: container,\n      raycaster,\n      pointer,\n      mouse: pointer,\n      // Their previous root is the layer before it\n      previousRoot,\n      // Events, size and viewport can be overridden by the inject layer\n      events: {\n        ...rootState.events,\n        ...injectState.events,\n        ...events\n      },\n      size: {\n        ...rootState.size,\n        ...size\n      },\n      viewport: {\n        ...rootState.viewport,\n        ...viewport\n      },\n      // Layers are allowed to override events\n      setEvents: events => injectState.set(state => ({\n        ...state,\n        events: {\n          ...state.events,\n          ...events\n        }\n      }))\n    };\n  });\n  const usePortalStore = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    // Create a mirrored store, based on the previous root with a few overrides ...\n    const store = (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_7__.createWithEqualityFn)((set, get) => ({\n      ...rest,\n      set,\n      get\n    }));\n\n    // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n    const onMutate = prev => store.setState(state => inject.current(prev, state));\n    onMutate(previousRoot.getState());\n    previousRoot.subscribe(onMutate);\n    return store;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [previousRoot, container]);\n  return (\n    /*#__PURE__*/\n    // @ts-ignore, reconciler types are not maintained\n    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {\n      children: reconciler.createPortal( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(context.Provider, {\n        value: usePortalStore,\n        children: children\n      }), usePortalStore, null)\n    })\n  );\n}\n\n/**\n * Force React to flush any updates inside the provided callback synchronously and immediately.\n * All the same caveats documented for react-dom's `flushSync` apply here (see https://react.dev/reference/react-dom/flushSync).\n * Nevertheless, sometimes one needs to render synchronously, for example to keep DOM and 3D changes in lock-step without\n * having to revert to a non-React solution.\n */\nfunction flushSync(fn) {\n  return reconciler.flushSync(fn);\n}\n\nfunction createSubs(callback, subs) {\n  const sub = {\n    callback\n  };\n  subs.add(sub);\n  return () => void subs.delete(sub);\n}\nconst globalEffects = new Set();\nconst globalAfterEffects = new Set();\nconst globalTailEffects = new Set();\n\n/**\n * Adds a global render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\n */\nconst addEffect = callback => createSubs(callback, globalEffects);\n\n/**\n * Adds a global after-render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\n */\nconst addAfterEffect = callback => createSubs(callback, globalAfterEffects);\n\n/**\n * Adds a global callback which is called when rendering stops.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\n */\nconst addTail = callback => createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n  if (!effects.size) return;\n  for (const {\n    callback\n  } of effects.values()) {\n    callback(timestamp);\n  }\n}\nfunction flushGlobalEffects(type, timestamp) {\n  switch (type) {\n    case 'before':\n      return run(globalEffects, timestamp);\n    case 'after':\n      return run(globalAfterEffects, timestamp);\n    case 'tail':\n      return run(globalTailEffects, timestamp);\n  }\n}\nlet subscribers;\nlet subscription;\nfunction update(timestamp, state, frame) {\n  // Run local effects\n  let delta = state.clock.getDelta();\n\n  // In frameloop='never' mode, clock times are updated using the provided timestamp\n  if (state.frameloop === 'never' && typeof timestamp === 'number') {\n    delta = timestamp - state.clock.elapsedTime;\n    state.clock.oldTime = state.clock.elapsedTime;\n    state.clock.elapsedTime = timestamp;\n  }\n\n  // Call subscribers (useFrame)\n  subscribers = state.internal.subscribers;\n  for (let i = 0; i < subscribers.length; i++) {\n    subscription = subscribers[i];\n    subscription.ref.current(subscription.store.getState(), delta, frame);\n  }\n\n  // Render content\n  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n\n  // Decrease frame count\n  state.internal.frames = Math.max(0, state.internal.frames - 1);\n  return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\nlet running = false;\nlet useFrameInProgress = false;\nlet repeat;\nlet frame;\nlet state;\nfunction loop(timestamp) {\n  frame = requestAnimationFrame(loop);\n  running = true;\n  repeat = 0;\n\n  // Run effects\n  flushGlobalEffects('before', timestamp);\n\n  // Render all roots\n  useFrameInProgress = true;\n  for (const root of _roots.values()) {\n    var _state$gl$xr;\n    state = root.store.getState();\n\n    // If the frameloop is invalidated, do not run another frame\n    if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n      repeat += update(timestamp, state);\n    }\n  }\n  useFrameInProgress = false;\n\n  // Run after-effects\n  flushGlobalEffects('after', timestamp);\n\n  // Stop the loop if nothing invalidates it\n  if (repeat === 0) {\n    // Tail call effects, they are called when rendering stops\n    flushGlobalEffects('tail', timestamp);\n\n    // Flag end of operation\n    running = false;\n    return cancelAnimationFrame(frame);\n  }\n}\n\n/**\n * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\n */\nfunction invalidate(state, frames = 1) {\n  var _state$gl$xr2;\n  if (!state) return _roots.forEach(root => invalidate(root.store.getState(), frames));\n  if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === 'never') return;\n  if (frames > 1) {\n    // legacy support for people using frames parameters\n    // Increase frames, do not go higher than 60\n    state.internal.frames = Math.min(60, state.internal.frames + frames);\n  } else {\n    if (useFrameInProgress) {\n      //called from within a useFrame, it means the user wants an additional frame\n      state.internal.frames = 2;\n    } else {\n      //the user need a new frame, no need to increment further than 1\n      state.internal.frames = 1;\n    }\n  }\n\n  // If the render-loop isn't active, start it\n  if (!running) {\n    running = true;\n    requestAnimationFrame(loop);\n  }\n}\n\n/**\n * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\n */\nfunction advance(timestamp, runGlobalEffects = true, state, frame) {\n  if (runGlobalEffects) flushGlobalEffects('before', timestamp);\n  if (!state) for (const root of _roots.values()) update(timestamp, root.store.getState());else update(timestamp, state, frame);\n  if (runGlobalEffects) flushGlobalEffects('after', timestamp);\n}\n\nconst DOM_EVENTS = {\n  onClick: ['click', false],\n  onContextMenu: ['contextmenu', false],\n  onDoubleClick: ['dblclick', false],\n  onWheel: ['wheel', true],\n  onPointerDown: ['pointerdown', true],\n  onPointerUp: ['pointerup', true],\n  onPointerLeave: ['pointerleave', true],\n  onPointerMove: ['pointermove', true],\n  onPointerCancel: ['pointercancel', true],\n  onLostPointerCapture: ['lostpointercapture', true]\n};\n\n/** Default R3F event manager for web */\nfunction createPointerEvents(store) {\n  const {\n    handlePointer\n  } = createEvents(store);\n  return {\n    priority: 1,\n    enabled: true,\n    compute(event, state, previous) {\n      // https://github.com/pmndrs/react-three-fiber/pull/782\n      // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n      state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    },\n    connected: undefined,\n    handlers: Object.keys(DOM_EVENTS).reduce((acc, key) => ({\n      ...acc,\n      [key]: handlePointer(key)\n    }), {}),\n    update: () => {\n      var _internal$lastEvent;\n      const {\n        events,\n        internal\n      } = store.getState();\n      if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n    },\n    connect: target => {\n      const {\n        set,\n        events\n      } = store.getState();\n      events.disconnect == null ? void 0 : events.disconnect();\n      set(state => ({\n        events: {\n          ...state.events,\n          connected: target\n        }\n      }));\n      if (events.handlers) {\n        for (const name in events.handlers) {\n          const event = events.handlers[name];\n          const [eventName, passive] = DOM_EVENTS[name];\n          target.addEventListener(eventName, event, {\n            passive\n          });\n        }\n      }\n    },\n    disconnect: () => {\n      const {\n        set,\n        events\n      } = store.getState();\n      if (events.connected) {\n        if (events.handlers) {\n          for (const name in events.handlers) {\n            const event = events.handlers[name];\n            const [eventName] = DOM_EVENTS[name];\n            events.connected.removeEventListener(eventName, event);\n          }\n        }\n        set(state => ({\n          events: {\n            ...state.events,\n            connected: undefined\n          }\n        }));\n      }\n    }\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvZGlzdC9ldmVudHMtY2Y1N2IyMjAuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDQTtBQUNtRztBQUN2RTtBQUNqQjtBQUNtQztBQUNyQjtBQUNOO0FBQ21COztBQUVyRTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQUs7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVVQUF1VSxrREFBcUIsR0FBRyw0Q0FBZTtBQUM5VztBQUNBLGNBQWMseUNBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQVE7QUFDeEIsd0JBQXdCLDBEQUFnQjtBQUN4QyxTQUFTLDBDQUFhO0FBQ3RCO0FBQ0EsR0FBRztBQUNILHFCQUFxQix1REFBYSxvQ0FBb0MsNkNBQWdCO0FBQ3RGLDBCQUEwQiw2Q0FBZ0IsR0FBRywyQ0FBYztBQUMzRCx3QkFBd0Isc0RBQUc7QUFDM0IsNkJBQTZCLHNEQUFHO0FBQ2hDO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0Esc0dBQXNHLDRDQUFlO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLDBCQUEwQix5Q0FBWSxxQkFBcUIseUNBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdDQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkNBQWdCLHVCQUF1QixtREFBc0I7QUFDeEY7QUFDQSwrQkFBK0IsaURBQW9CO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRDQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUs7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFbW1CIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvZXZlbnRzLWNmNTdiMjIwLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBEZWZhdWx0RXZlbnRQcmlvcml0eSwgQ29udGludW91c0V2ZW50UHJpb3JpdHksIERpc2NyZXRlRXZlbnRQcmlvcml0eSwgQ29uY3VycmVudFJvb3QgfSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjcmVhdGVXaXRoRXF1YWxpdHlGbiB9IGZyb20gJ3p1c3RhbmQvdHJhZGl0aW9uYWwnO1xuaW1wb3J0IFJlY29uY2lsZXIgZnJvbSAncmVhY3QtcmVjb25jaWxlcic7XG5pbXBvcnQgeyB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLCB1bnN0YWJsZV9JZGxlUHJpb3JpdHkgfSBmcm9tICdzY2hlZHVsZXInO1xuaW1wb3J0IHsgc3VzcGVuZCwgcHJlbG9hZCwgY2xlYXIgfSBmcm9tICdzdXNwZW5kLXJlYWN0JztcbmltcG9ydCB7IGpzeCwgRnJhZ21lbnQgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyB1c2VGaWJlciwgdXNlQ29udGV4dEJyaWRnZSwgdHJhdmVyc2VGaWJlciB9IGZyb20gJ2l0cy1maW5lJztcblxudmFyIHRocmVlVHlwZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW5zdGFuY2UncyBpbml0aWFsIChvdXRtb3N0KSByb290LlxuICovXG5mdW5jdGlvbiBmaW5kSW5pdGlhbFJvb3QoaW5zdGFuY2UpIHtcbiAgbGV0IHJvb3QgPSBpbnN0YW5jZS5yb290O1xuICB3aGlsZSAocm9vdC5nZXRTdGF0ZSgpLnByZXZpb3VzUm9vdCkgcm9vdCA9IHJvb3QuZ2V0U3RhdGUoKS5wcmV2aW91c1Jvb3Q7XG4gIHJldHVybiByb290O1xufVxuLyoqXG4gKiBTYWZlbHkgZmx1c2ggYXN5bmMgZWZmZWN0cyB3aGVuIHRlc3RpbmcsIHNpbXVsYXRpbmcgYSBsZWdhY3kgcm9vdC5cbiAqIEBkZXByZWNhdGVkIEltcG9ydCBmcm9tIFJlYWN0IGluc3RlYWQuIGltcG9ydCB7IGFjdCB9IGZyb20gJ3JlYWN0J1xuICovXG4vLyBSZWZlcmVuY2Ugd2l0aCBjb21wdXRlZCBrZXkgdG8gYnJlYWsgV2VicGFjayBzdGF0aWMgYW5hbHlzaXNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svaXNzdWVzLzE0ODE0XG5jb25zdCBhY3QgPSBSZWFjdFsnYWN0JyArICcnXTtcbmNvbnN0IGlzT3J0aG9ncmFwaGljQ2FtZXJhID0gZGVmID0+IGRlZiAmJiBkZWYuaXNPcnRob2dyYXBoaWNDYW1lcmE7XG5jb25zdCBpc1JlZiA9IG9iaiA9PiBvYmogJiYgb2JqLmhhc093blByb3BlcnR5KCdjdXJyZW50Jyk7XG5jb25zdCBpc0NvbG9yUmVwcmVzZW50YXRpb24gPSB2YWx1ZSA9PiB2YWx1ZSAhPSBudWxsICYmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUuaXNDb2xvcik7XG5cbi8qKlxuICogQW4gU1NSLWZyaWVuZGx5IHVzZUxheW91dEVmZmVjdC5cbiAqXG4gKiBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxuICogVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbiAqIHVzZUxheW91dEVmZmVjdCBlbHNld2hlcmUuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0OTI3XG4gKi9cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSAvKiBAX19QVVJFX18gKi8oKF93aW5kb3ckZG9jdW1lbnQsIF93aW5kb3ckbmF2aWdhdG9yKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKChfd2luZG93JGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyRkb2N1bWVudC5jcmVhdGVFbGVtZW50KSB8fCAoKF93aW5kb3ckbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckbmF2aWdhdG9yLnByb2R1Y3QpID09PSAnUmVhY3ROYXRpdmUnKSkoKSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbmZ1bmN0aW9uIHVzZU11dGFibGVDYWxsYmFjayhmbikge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoZm4pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKHJlZi5jdXJyZW50ID0gZm4pLCBbZm5dKTtcbiAgcmV0dXJuIHJlZjtcbn1cbi8qKlxuICogQnJpZGdlcyByZW5kZXJlciBDb250ZXh0IGFuZCBTdHJpY3RNb2RlIGZyb20gYSBwcmltYXJ5IHJlbmRlcmVyLlxuICovXG5mdW5jdGlvbiB1c2VCcmlkZ2UoKSB7XG4gIGNvbnN0IGZpYmVyID0gdXNlRmliZXIoKTtcbiAgY29uc3QgQ29udGV4dEJyaWRnZSA9IHVzZUNvbnRleHRCcmlkZ2UoKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiB7XG4gICAgY29uc3Qgc3RyaWN0ID0gISF0cmF2ZXJzZUZpYmVyKGZpYmVyLCB0cnVlLCBub2RlID0+IG5vZGUudHlwZSA9PT0gUmVhY3QuU3RyaWN0TW9kZSk7XG4gICAgY29uc3QgUm9vdCA9IHN0cmljdCA/IFJlYWN0LlN0cmljdE1vZGUgOiBSZWFjdC5GcmFnbWVudDtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChSb290LCB7XG4gICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChDb250ZXh0QnJpZGdlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSlcbiAgICB9KTtcbiAgfSwgW2ZpYmVyLCBDb250ZXh0QnJpZGdlXSk7XG59XG5mdW5jdGlvbiBCbG9jayh7XG4gIHNldFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBzZXQobmV3IFByb21pc2UoKCkgPT4gbnVsbCkpO1xuICAgIHJldHVybiAoKSA9PiBzZXQoZmFsc2UpO1xuICB9LCBbc2V0XSk7XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBOT1RFOiBzdGF0aWMgbWVtYmVycyBnZXQgZG93bi1sZXZlbCB0cmFuc3BpbGVkIHRvIG11dGF0aW9ucyB3aGljaCBicmVhayB0cmVlLXNoYWtpbmdcbmNvbnN0IEVycm9yQm91bmRhcnkgPSAvKiBAX19QVVJFX18gKi8oX0Vycm9yQm91bmRhcnkgPT4gKF9FcnJvckJvdW5kYXJ5ID0gY2xhc3MgRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZXJyb3I6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnIpIHtcbiAgICB0aGlzLnByb3BzLnNldChlcnIpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciA/IG51bGwgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59LCBfRXJyb3JCb3VuZGFyeS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSAoKSA9PiAoe1xuICBlcnJvcjogdHJ1ZVxufSksIF9FcnJvckJvdW5kYXJ5KSkoKTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZURwcihkcHIpIHtcbiAgdmFyIF93aW5kb3ckZGV2aWNlUGl4ZWxSYTtcbiAgLy8gRXJyIG9uIHRoZSBzaWRlIG9mIHByb2dyZXNzIGJ5IGFzc3VtaW5nIDJ4IGRwciBpZiB3ZSBjYW4ndCBkZXRlY3QgaXRcbiAgLy8gVGhpcyB3aWxsIGhhcHBlbiBpbiB3b3JrZXJzIHdoZXJlIHdpbmRvdyBpcyBkZWZpbmVkIGJ1dCBkcHIgaXNuJ3QuXG4gIGNvbnN0IHRhcmdldCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gKF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSAhPSBudWxsID8gX3dpbmRvdyRkZXZpY2VQaXhlbFJhIDogMiA6IDE7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRwcikgPyBNYXRoLm1pbihNYXRoLm1heChkcHJbMF0sIHRhcmdldCksIGRwclsxXSkgOiBkcHI7XG59XG5cbi8qKlxuICogUmV0dXJucyBpbnN0YW5jZSByb290IHN0YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3RTdGF0ZShvYmopIHtcbiAgdmFyIF9yM2Y7XG4gIHJldHVybiAoX3IzZiA9IG9iai5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9yM2Yucm9vdC5nZXRTdGF0ZSgpO1xufVxuLy8gQSBjb2xsZWN0aW9uIG9mIGNvbXBhcmUgZnVuY3Rpb25zXG5jb25zdCBpcyA9IHtcbiAgb2JqOiBhID0+IGEgPT09IE9iamVjdChhKSAmJiAhaXMuYXJyKGEpICYmIHR5cGVvZiBhICE9PSAnZnVuY3Rpb24nLFxuICBmdW46IGEgPT4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbicsXG4gIHN0cjogYSA9PiB0eXBlb2YgYSA9PT0gJ3N0cmluZycsXG4gIG51bTogYSA9PiB0eXBlb2YgYSA9PT0gJ251bWJlcicsXG4gIGJvbzogYSA9PiB0eXBlb2YgYSA9PT0gJ2Jvb2xlYW4nLFxuICB1bmQ6IGEgPT4gYSA9PT0gdm9pZCAwLFxuICBudWw6IGEgPT4gYSA9PT0gbnVsbCxcbiAgYXJyOiBhID0+IEFycmF5LmlzQXJyYXkoYSksXG4gIGVxdShhLCBiLCB7XG4gICAgYXJyYXlzID0gJ3NoYWxsb3cnLFxuICAgIG9iamVjdHMgPSAncmVmZXJlbmNlJyxcbiAgICBzdHJpY3QgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIC8vIFdyb25nIHR5cGUgb3Igb25lIG9mIHRoZSB0d28gdW5kZWZpbmVkLCBkb2Vzbid0IG1hdGNoXG4gICAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYiB8fCAhIWEgIT09ICEhYikgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEF0b21pYywganVzdCBjb21wYXJlIGEgYWdhaW5zdCBiXG4gICAgaWYgKGlzLnN0cihhKSB8fCBpcy5udW0oYSkgfHwgaXMuYm9vKGEpKSByZXR1cm4gYSA9PT0gYjtcbiAgICBjb25zdCBpc09iaiA9IGlzLm9iaihhKTtcbiAgICBpZiAoaXNPYmogJiYgb2JqZWN0cyA9PT0gJ3JlZmVyZW5jZScpIHJldHVybiBhID09PSBiO1xuICAgIGNvbnN0IGlzQXJyID0gaXMuYXJyKGEpO1xuICAgIGlmIChpc0FyciAmJiBhcnJheXMgPT09ICdyZWZlcmVuY2UnKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBBcnJheSBvciBPYmplY3QsIHNoYWxsb3cgY29tcGFyZSBmaXJzdCB0byBzZWUgaWYgaXQncyBhIG1hdGNoXG4gICAgaWYgKChpc0FyciB8fCBpc09iaikgJiYgYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgLy8gTGFzdCByZXNvcnQsIGdvIHRocm91Z2gga2V5c1xuICAgIGxldCBpO1xuICAgIC8vIENoZWNrIGlmIGEgaGFzIGFsbCB0aGUga2V5cyBvZiBiXG4gICAgZm9yIChpIGluIGEpIGlmICghKGkgaW4gYikpIHJldHVybiBmYWxzZTtcbiAgICAvLyBDaGVjayBpZiB2YWx1ZXMgYmV0d2VlbiBrZXlzIG1hdGNoXG4gICAgaWYgKGlzT2JqICYmIGFycmF5cyA9PT0gJ3NoYWxsb3cnICYmIG9iamVjdHMgPT09ICdzaGFsbG93Jykge1xuICAgICAgZm9yIChpIGluIHN0cmljdCA/IGIgOiBhKSBpZiAoIWlzLmVxdShhW2ldLCBiW2ldLCB7XG4gICAgICAgIHN0cmljdCxcbiAgICAgICAgb2JqZWN0czogJ3JlZmVyZW5jZSdcbiAgICAgIH0pKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSBpbiBzdHJpY3QgPyBiIDogYSkgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgaSBpcyB1bmRlZmluZWRcbiAgICBpZiAoaXMudW5kKGkpKSB7XG4gICAgICAvLyBJZiBib3RoIGFycmF5cyBhcmUgZW1wdHkgd2UgY29uc2lkZXIgdGhlbSBlcXVhbFxuICAgICAgaWYgKGlzQXJyICYmIGEubGVuZ3RoID09PSAwICYmIGIubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIElmIGJvdGggb2JqZWN0cyBhcmUgZW1wdHkgd2UgY29uc2lkZXIgdGhlbSBlcXVhbFxuICAgICAgaWYgKGlzT2JqICYmIE9iamVjdC5rZXlzKGEpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhiKS5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgLy8gT3RoZXJ3aXNlIG1hdGNoIHRoZW0gYnkgdmFsdWVcbiAgICAgIGlmIChhICE9PSBiKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBDb2xsZWN0cyBub2RlcyBhbmQgbWF0ZXJpYWxzIGZyb20gYSBUSFJFRS5PYmplY3QzRFxuZnVuY3Rpb24gYnVpbGRHcmFwaChvYmplY3QpIHtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICBub2Rlczoge30sXG4gICAgbWF0ZXJpYWxzOiB7fSxcbiAgICBtZXNoZXM6IHt9XG4gIH07XG4gIGlmIChvYmplY3QpIHtcbiAgICBvYmplY3QudHJhdmVyc2Uob2JqID0+IHtcbiAgICAgIGlmIChvYmoubmFtZSkgZGF0YS5ub2Rlc1tvYmoubmFtZV0gPSBvYmo7XG4gICAgICBpZiAob2JqLm1hdGVyaWFsICYmICFkYXRhLm1hdGVyaWFsc1tvYmoubWF0ZXJpYWwubmFtZV0pIGRhdGEubWF0ZXJpYWxzW29iai5tYXRlcmlhbC5uYW1lXSA9IG9iai5tYXRlcmlhbDtcbiAgICAgIGlmIChvYmouaXNNZXNoICYmICFkYXRhLm1lc2hlc1tvYmoubmFtZV0pIGRhdGEubWVzaGVzW29iai5uYW1lXSA9IG9iajtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbi8vIERpc3Bvc2VzIGFuIG9iamVjdCBhbmQgYWxsIGl0cyBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBkaXNwb3NlKG9iaikge1xuICBpZiAob2JqLnR5cGUgIT09ICdTY2VuZScpIG9iai5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBvYmouZGlzcG9zZSgpO1xuICBmb3IgKGNvbnN0IHAgaW4gb2JqKSB7XG4gICAgY29uc3QgcHJvcCA9IG9ialtwXTtcbiAgICBpZiAoKHByb3AgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3AudHlwZSkgIT09ICdTY2VuZScpIHByb3AgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3AuZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogcHJvcC5kaXNwb3NlKCk7XG4gIH1cbn1cbmNvbnN0IFJFQUNUX0lOVEVSTkFMX1BST1BTID0gWydjaGlsZHJlbicsICdrZXknLCAncmVmJ107XG5cbi8vIEdldHMgb25seSBpbnN0YW5jZSBwcm9wcyBmcm9tIHJlY29uY2lsZXIgZmliZXJzXG5mdW5jdGlvbiBnZXRJbnN0YW5jZVByb3BzKHF1ZXVlKSB7XG4gIGNvbnN0IHByb3BzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHF1ZXVlKSB7XG4gICAgaWYgKCFSRUFDVF9JTlRFUk5BTF9QUk9QUy5pbmNsdWRlcyhrZXkpKSBwcm9wc1trZXldID0gcXVldWVba2V5XTtcbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBzY2VuZSBjYXJyaWVzIGEgc21hbGwgTG9jYWxTdGF0ZSBkZXNjcmlwdG9yXG5mdW5jdGlvbiBwcmVwYXJlKHRhcmdldCwgcm9vdCwgdHlwZSwgcHJvcHMpIHtcbiAgY29uc3Qgb2JqZWN0ID0gdGFyZ2V0O1xuXG4gIC8vIENyZWF0ZSBpbnN0YW5jZSBkZXNjcmlwdG9yXG4gIGxldCBpbnN0YW5jZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0Ll9fcjNmO1xuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UgPSB7XG4gICAgICByb290LFxuICAgICAgdHlwZSxcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIHByb3BzOiBnZXRJbnN0YW5jZVByb3BzKHByb3BzKSxcbiAgICAgIG9iamVjdCxcbiAgICAgIGV2ZW50Q291bnQ6IDAsXG4gICAgICBoYW5kbGVyczoge30sXG4gICAgICBpc0hpZGRlbjogZmFsc2VcbiAgICB9O1xuICAgIGlmIChvYmplY3QpIG9iamVjdC5fX3IzZiA9IGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmUocm9vdCwga2V5KSB7XG4gIGxldCB0YXJnZXQgPSByb290W2tleV07XG4gIGlmICgha2V5LmluY2x1ZGVzKCctJykpIHJldHVybiB7XG4gICAgcm9vdCxcbiAgICBrZXksXG4gICAgdGFyZ2V0XG4gIH07XG5cbiAgLy8gUmVzb2x2ZSBwaWVyY2VkIHRhcmdldFxuICB0YXJnZXQgPSByb290O1xuICBmb3IgKGNvbnN0IHBhcnQgb2Yga2V5LnNwbGl0KCctJykpIHtcbiAgICB2YXIgX3RhcmdldDtcbiAgICBrZXkgPSBwYXJ0O1xuICAgIHJvb3QgPSB0YXJnZXQ7XG4gICAgdGFyZ2V0ID0gKF90YXJnZXQgPSB0YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0W2tleV07XG4gIH1cblxuICAvLyBUT0RPOiBjaGFuZ2Uga2V5IHRvICdmb28tYmFyJyBpZiB0YXJnZXQgaXMgdW5kZWZpbmVkP1xuXG4gIHJldHVybiB7XG4gICAgcm9vdCxcbiAgICBrZXksXG4gICAgdGFyZ2V0XG4gIH07XG59XG5cbi8vIENoZWNrcyBpZiBhIGRhc2gtY2FzZWQgc3RyaW5nIGVuZHMgd2l0aCBhbiBpbnRlZ2VyXG5jb25zdCBJTkRFWF9SRUdFWCA9IC8tXFxkKyQvO1xuZnVuY3Rpb24gYXR0YWNoKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKGlzLnN0cihjaGlsZC5wcm9wcy5hdHRhY2gpKSB7XG4gICAgLy8gSWYgYXR0YWNoaW5nIGludG8gYW4gYXJyYXkgKGZvby0wKSwgY3JlYXRlIG9uZVxuICAgIGlmIChJTkRFWF9SRUdFWC50ZXN0KGNoaWxkLnByb3BzLmF0dGFjaCkpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gY2hpbGQucHJvcHMuYXR0YWNoLnJlcGxhY2UoSU5ERVhfUkVHRVgsICcnKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm9vdCxcbiAgICAgICAga2V5XG4gICAgICB9ID0gcmVzb2x2ZShwYXJlbnQub2JqZWN0LCBpbmRleCk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocm9vdFtrZXldKSkgcm9vdFtrZXldID0gW107XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHJvb3QsXG4gICAgICBrZXlcbiAgICB9ID0gcmVzb2x2ZShwYXJlbnQub2JqZWN0LCBjaGlsZC5wcm9wcy5hdHRhY2gpO1xuICAgIGNoaWxkLnByZXZpb3VzQXR0YWNoID0gcm9vdFtrZXldO1xuICAgIHJvb3Rba2V5XSA9IGNoaWxkLm9iamVjdDtcbiAgfSBlbHNlIGlmIChpcy5mdW4oY2hpbGQucHJvcHMuYXR0YWNoKSkge1xuICAgIGNoaWxkLnByZXZpb3VzQXR0YWNoID0gY2hpbGQucHJvcHMuYXR0YWNoKHBhcmVudC5vYmplY3QsIGNoaWxkLm9iamVjdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGFjaChwYXJlbnQsIGNoaWxkKSB7XG4gIGlmIChpcy5zdHIoY2hpbGQucHJvcHMuYXR0YWNoKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJvb3QsXG4gICAgICBrZXlcbiAgICB9ID0gcmVzb2x2ZShwYXJlbnQub2JqZWN0LCBjaGlsZC5wcm9wcy5hdHRhY2gpO1xuICAgIGNvbnN0IHByZXZpb3VzID0gY2hpbGQucHJldmlvdXNBdHRhY2g7XG4gICAgLy8gV2hlbiB0aGUgcHJldmlvdXMgdmFsdWUgd2FzIHVuZGVmaW5lZCwgaXQgbWVhbnMgdGhlIHZhbHVlIHdhcyBuZXZlciBzZXQgdG8gYmVnaW4gd2l0aFxuICAgIGlmIChwcmV2aW91cyA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcm9vdFtrZXldO1xuICAgIC8vIE90aGVyd2lzZSBzZXQgdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgZWxzZSByb290W2tleV0gPSBwcmV2aW91cztcbiAgfSBlbHNlIHtcbiAgICBjaGlsZC5wcmV2aW91c0F0dGFjaCA9PSBudWxsID8gdm9pZCAwIDogY2hpbGQucHJldmlvdXNBdHRhY2gocGFyZW50Lm9iamVjdCwgY2hpbGQub2JqZWN0KTtcbiAgfVxuICBkZWxldGUgY2hpbGQucHJldmlvdXNBdHRhY2g7XG59XG5jb25zdCBSRVNFUlZFRF9QUk9QUyA9IFsuLi5SRUFDVF9JTlRFUk5BTF9QUk9QUyxcbi8vIEluc3RhbmNlIHByb3BzXG4nYXJncycsICdkaXNwb3NlJywgJ2F0dGFjaCcsICdvYmplY3QnLCAnb25VcGRhdGUnLFxuLy8gQmVoYXZpb3IgZmxhZ3NcbidkaXNwb3NlJ107XG5jb25zdCBNRU1PSVpFRF9QUk9UT1RZUEVTID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0TWVtb2l6ZWRQcm90b3R5cGUocm9vdCkge1xuICBsZXQgY3RvciA9IE1FTU9JWkVEX1BST1RPVFlQRVMuZ2V0KHJvb3QuY29uc3RydWN0b3IpO1xuICB0cnkge1xuICAgIGlmICghY3Rvcikge1xuICAgICAgY3RvciA9IG5ldyByb290LmNvbnN0cnVjdG9yKCk7XG4gICAgICBNRU1PSVpFRF9QUk9UT1RZUEVTLnNldChyb290LmNvbnN0cnVjdG9yLCBjdG9yKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyAuLi5cbiAgfVxuICByZXR1cm4gY3Rvcjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBwcmVwYXJlcyBhIHNldCBvZiBjaGFuZ2VzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGluc3RhbmNlXG5mdW5jdGlvbiBkaWZmUHJvcHMoaW5zdGFuY2UsIG5ld1Byb3BzKSB7XG4gIGNvbnN0IGNoYW5nZWRQcm9wcyA9IHt9O1xuXG4gIC8vIFNvcnQgdGhyb3VnaCBwcm9wc1xuICBmb3IgKGNvbnN0IHByb3AgaW4gbmV3UHJvcHMpIHtcbiAgICAvLyBTa2lwIHJlc2VydmVkIGtleXNcbiAgICBpZiAoUkVTRVJWRURfUFJPUFMuaW5jbHVkZXMocHJvcCkpIGNvbnRpbnVlO1xuICAgIC8vIFNraXAgaWYgcHJvcHMgbWF0Y2hcbiAgICBpZiAoaXMuZXF1KG5ld1Byb3BzW3Byb3BdLCBpbnN0YW5jZS5wcm9wc1twcm9wXSkpIGNvbnRpbnVlO1xuXG4gICAgLy8gUHJvcHMgY2hhbmdlZCwgYWRkIHRoZW1cbiAgICBjaGFuZ2VkUHJvcHNbcHJvcF0gPSBuZXdQcm9wc1twcm9wXTtcblxuICAgIC8vIFJlc2V0IHBpZXJjZWQgcHJvcHNcbiAgICBmb3IgKGNvbnN0IG90aGVyIGluIG5ld1Byb3BzKSB7XG4gICAgICBpZiAob3RoZXIuc3RhcnRzV2l0aChgJHtwcm9wfS1gKSkgY2hhbmdlZFByb3BzW290aGVyXSA9IG5ld1Byb3BzW290aGVyXTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXNldCByZW1vdmVkIHByb3BzIGZvciBITVJcbiAgZm9yIChjb25zdCBwcm9wIGluIGluc3RhbmNlLnByb3BzKSB7XG4gICAgaWYgKFJFU0VSVkVEX1BST1BTLmluY2x1ZGVzKHByb3ApIHx8IG5ld1Byb3BzLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTtcbiAgICBjb25zdCB7XG4gICAgICByb290LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUoaW5zdGFuY2Uub2JqZWN0LCBwcm9wKTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzIxMjA5XG4gICAgLy8gSE1SL2Zhc3QtcmVmcmVzaCByZWxpZXMgb24gdGhlIGFiaWxpdHkgdG8gY2FuY2VsIG91dCBwcm9wcywgYnV0IHRocmVlanNcbiAgICAvLyBoYXMgbm8gbWVhbnMgdG8gZG8gdGhpcy4gSGVuY2Ugd2UgY3VyYXRlIGEgc21hbGwgY29sbGVjdGlvbiBvZiB2YWx1ZS1jbGFzc2VzXG4gICAgLy8gd2l0aCB0aGVpciByZXNwZWN0aXZlIGNvbnN0cnVjdG9yL3NldCBhcmd1bWVudHNcbiAgICAvLyBGb3IgcmVtb3ZlZCBwcm9wcywgdHJ5IHRvIHNldCBkZWZhdWx0IHZhbHVlcywgaWYgcG9zc2libGVcbiAgICBpZiAocm9vdC5jb25zdHJ1Y3RvciAmJiByb290LmNvbnN0cnVjdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gY3JlYXRlIGEgYmxhbmsgc2xhdGUgb2YgdGhlIGluc3RhbmNlIGFuZCBjb3B5IHRoZSBwYXJ0aWN1bGFyIHBhcmFtZXRlci5cbiAgICAgIGNvbnN0IGN0b3IgPSBnZXRNZW1vaXplZFByb3RvdHlwZShyb290KTtcbiAgICAgIGlmICghaXMudW5kKGN0b3IpKSBjaGFuZ2VkUHJvcHNba2V5XSA9IGN0b3Jba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBjb25zdHJ1Y3RvciwganVzdCBzZXQgaXQgdG8gMFxuICAgICAgY2hhbmdlZFByb3BzW2tleV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlZFByb3BzO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjcwNDJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMjc0OFxuY29uc3QgY29sb3JNYXBzID0gWydtYXAnLCAnZW1pc3NpdmVNYXAnLCAnc2hlZW5Db2xvck1hcCcsICdzcGVjdWxhckNvbG9yTWFwJywgJ2Vudk1hcCddO1xuY29uc3QgRVZFTlRfUkVHRVggPSAvXm9uKFBvaW50ZXJ8Q2xpY2t8RG91YmxlQ2xpY2t8Q29udGV4dE1lbnV8V2hlZWwpLztcbi8vIFRoaXMgZnVuY3Rpb24gYXBwbGllcyBhIHNldCBvZiBjaGFuZ2VzIHRvIHRoZSBpbnN0YW5jZVxuZnVuY3Rpb24gYXBwbHlQcm9wcyhvYmplY3QsIHByb3BzKSB7XG4gIHZhciBfaW5zdGFuY2Ukb2JqZWN0O1xuICBjb25zdCBpbnN0YW5jZSA9IG9iamVjdC5fX3IzZjtcbiAgY29uc3Qgcm9vdFN0YXRlID0gaW5zdGFuY2UgJiYgZmluZEluaXRpYWxSb290KGluc3RhbmNlKS5nZXRTdGF0ZSgpO1xuICBjb25zdCBwcmV2SGFuZGxlcnMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuZXZlbnRDb3VudDtcbiAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzKSB7XG4gICAgbGV0IHZhbHVlID0gcHJvcHNbcHJvcF07XG5cbiAgICAvLyBEb24ndCBtdXRhdGUgcmVzZXJ2ZWQga2V5c1xuICAgIGlmIChSRVNFUlZFRF9QUk9QUy5pbmNsdWRlcyhwcm9wKSkgY29udGludWU7XG5cbiAgICAvLyBEZWFsIHdpdGggcG9pbnRlciBldmVudHMsIGluY2x1ZGluZyByZW1vdmluZyB0aGVtIGlmIHVuZGVmaW5lZFxuICAgIGlmIChpbnN0YW5jZSAmJiBFVkVOVF9SRUdFWC50ZXN0KHByb3ApKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSBpbnN0YW5jZS5oYW5kbGVyc1twcm9wXSA9IHZhbHVlO2Vsc2UgZGVsZXRlIGluc3RhbmNlLmhhbmRsZXJzW3Byb3BdO1xuICAgICAgaW5zdGFuY2UuZXZlbnRDb3VudCA9IE9iamVjdC5rZXlzKGluc3RhbmNlLmhhbmRsZXJzKS5sZW5ndGg7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgc2V0dGluZyB1bmRlZmluZWQgcHJvcHNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8yNzRcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgbGV0IHtcbiAgICAgIHJvb3QsXG4gICAgICBrZXksXG4gICAgICB0YXJnZXRcbiAgICB9ID0gcmVzb2x2ZShvYmplY3QsIHByb3ApO1xuXG4gICAgLy8gTGF5ZXJzIG11c3QgYmUgd3JpdHRlbiB0byB0aGUgbWFzayBwcm9wZXJ0eVxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5MYXllcnMgJiYgdmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5MYXllcnMpIHtcbiAgICAgIHRhcmdldC5tYXNrID0gdmFsdWUubWFzaztcbiAgICB9XG4gICAgLy8gU2V0IGNvbG9ycyBpZiB2YWxpZCBjb2xvciByZXByZXNlbnRhdGlvbiBmb3IgYXV0b21hdGljIGNvbnZlcnNpb24gKGNvcHkpXG4gICAgZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgJiYgaXNDb2xvclJlcHJlc2VudGF0aW9uKHZhbHVlKSkge1xuICAgICAgdGFyZ2V0LnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIENvcHkgaWYgcHJvcGVydGllcyBtYXRjaCBzaWduYXR1cmVzIGFuZCBpbXBsZW1lbnQgbWF0aCBpbnRlcmZhY2UgKGxpa2VseSByZWFkLW9ubHkpXG4gICAgZWxzZSBpZiAodGFyZ2V0ICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXQuc2V0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0YXJnZXQuY29weSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHRhcmdldC5jb25zdHJ1Y3RvciA9PT0gdmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgIHRhcmdldC5jb3B5KHZhbHVlKTtcbiAgICB9XG4gICAgLy8gU2V0IGFycmF5IHR5cGVzXG4gICAgZWxzZSBpZiAodGFyZ2V0ICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXQuc2V0ID09PSAnZnVuY3Rpb24nICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodHlwZW9mIHRhcmdldC5mcm9tQXJyYXkgPT09ICdmdW5jdGlvbicpIHRhcmdldC5mcm9tQXJyYXkodmFsdWUpO2Vsc2UgdGFyZ2V0LnNldCguLi52YWx1ZSk7XG4gICAgfVxuICAgIC8vIFNldCBsaXRlcmFsIHR5cGVzXG4gICAgZWxzZSBpZiAodGFyZ2V0ICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXQuc2V0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIEFsbG93IHNldHRpbmcgYXJyYXkgc2NhbGFyc1xuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQuc2V0U2NhbGFyID09PSAnZnVuY3Rpb24nKSB0YXJnZXQuc2V0U2NhbGFyKHZhbHVlKTtcbiAgICAgIC8vIE90aGVyd2lzZSBqdXN0IHNldCBzaW5nbGUgdmFsdWVcbiAgICAgIGVsc2UgdGFyZ2V0LnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIEVsc2UsIGp1c3Qgb3ZlcndyaXRlIHRoZSB2YWx1ZVxuICAgIGVsc2Uge1xuICAgICAgdmFyIF9yb290JGtleTtcbiAgICAgIHJvb3Rba2V5XSA9IHZhbHVlO1xuXG4gICAgICAvLyBBdXRvLWNvbnZlcnQgc1JHQiB0ZXh0dXJlIHBhcmFtZXRlcnMgZm9yIGJ1aWx0LWluIG1hdGVyaWFsc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzQ0XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjU4NTdcbiAgICAgIGlmIChyb290U3RhdGUgJiYgIXJvb3RTdGF0ZS5saW5lYXIgJiYgY29sb3JNYXBzLmluY2x1ZGVzKGtleSkgJiYgKF9yb290JGtleSA9IHJvb3Rba2V5XSkgIT0gbnVsbCAmJiBfcm9vdCRrZXkuaXNUZXh0dXJlICYmXG4gICAgICAvLyBzUkdCIHRleHR1cmVzIG11c3QgYmUgUkdCQTggc2luY2UgcjEzNyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjMxMjlcbiAgICAgIHJvb3Rba2V5XS5mb3JtYXQgPT09IFRIUkVFLlJHQkFGb3JtYXQgJiYgcm9vdFtrZXldLnR5cGUgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUpIHtcbiAgICAgICAgLy8gTk9URTogdGhpcyBjYW5ub3QgYmUgc2V0IGZyb20gdGhlIHJlbmRlcmVyIChlLmcuIHNSR0Igc291cmNlIHRleHR1cmVzIHJlbmRlcmVkIHRvIFAzKVxuICAgICAgICByb290W2tleV0uY29sb3JTcGFjZSA9IFRIUkVFLlNSR0JDb2xvclNwYWNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLnBhcmVudCAmJiByb290U3RhdGUgIT0gbnVsbCAmJiByb290U3RhdGUuaW50ZXJuYWwgJiYgKF9pbnN0YW5jZSRvYmplY3QgPSBpbnN0YW5jZS5vYmplY3QpICE9IG51bGwgJiYgX2luc3RhbmNlJG9iamVjdC5pc09iamVjdDNEICYmIHByZXZIYW5kbGVycyAhPT0gaW5zdGFuY2UuZXZlbnRDb3VudCkge1xuICAgIGNvbnN0IG9iamVjdCA9IGluc3RhbmNlLm9iamVjdDtcbiAgICAvLyBQcmUtZW1wdGl2ZWx5IHJlbW92ZSB0aGUgaW5zdGFuY2UgZnJvbSB0aGUgaW50ZXJhY3Rpb24gbWFuYWdlclxuICAgIGNvbnN0IGluZGV4ID0gcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLmluZGV4T2Yob2JqZWN0KTtcbiAgICBpZiAoaW5kZXggPiAtMSkgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnNwbGljZShpbmRleCwgMSk7XG4gICAgLy8gQWRkIHRoZSBpbnN0YW5jZSB0byB0aGUgaW50ZXJhY3Rpb24gbWFuYWdlciBvbmx5IHdoZW4gaXQgaGFzIGhhbmRsZXJzXG4gICAgaWYgKGluc3RhbmNlLmV2ZW50Q291bnQgJiYgb2JqZWN0LnJheWNhc3QgIT09IG51bGwpIHtcbiAgICAgIHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5wdXNoKG9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXV0by1hdHRhY2ggZ2VvbWV0cmllcyBhbmQgbWF0ZXJpYWxzXG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm9wcy5hdHRhY2ggPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpbnN0YW5jZS5vYmplY3QuaXNCdWZmZXJHZW9tZXRyeSkgaW5zdGFuY2UucHJvcHMuYXR0YWNoID0gJ2dlb21ldHJ5JztlbHNlIGlmIChpbnN0YW5jZS5vYmplY3QuaXNNYXRlcmlhbCkgaW5zdGFuY2UucHJvcHMuYXR0YWNoID0gJ21hdGVyaWFsJztcbiAgfVxuXG4gIC8vIEluc3RhbmNlIHdhcyB1cGRhdGVkLCByZXF1ZXN0IGEgZnJhbWVcbiAgaWYgKGluc3RhbmNlKSBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICByZXR1cm4gb2JqZWN0O1xufVxuZnVuY3Rpb24gaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHZhciBfaW5zdGFuY2Ukcm9vdDtcbiAgaWYgKCFpbnN0YW5jZS5wYXJlbnQpIHJldHVybjtcbiAgaW5zdGFuY2UucHJvcHMub25VcGRhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLnByb3BzLm9uVXBkYXRlKGluc3RhbmNlLm9iamVjdCk7XG4gIGNvbnN0IHN0YXRlID0gKF9pbnN0YW5jZSRyb290ID0gaW5zdGFuY2Uucm9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRyb290LmdldFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2Ukcm9vdC5nZXRTdGF0ZSgpO1xuICBpZiAoc3RhdGUgJiYgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID09PSAwKSBzdGF0ZS5pbnZhbGlkYXRlKCk7XG59XG5mdW5jdGlvbiB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKSB7XG4gIC8vIERvIG5vdCBtZXNzIHdpdGggdGhlIGNhbWVyYSBpZiBpdCBiZWxvbmdzIHRvIHRoZSB1c2VyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzkyXG4gIGlmIChjYW1lcmEubWFudWFsKSByZXR1cm47XG4gIGlmIChpc09ydGhvZ3JhcGhpY0NhbWVyYShjYW1lcmEpKSB7XG4gICAgY2FtZXJhLmxlZnQgPSBzaXplLndpZHRoIC8gLTI7XG4gICAgY2FtZXJhLnJpZ2h0ID0gc2l6ZS53aWR0aCAvIDI7XG4gICAgY2FtZXJhLnRvcCA9IHNpemUuaGVpZ2h0IC8gMjtcbiAgICBjYW1lcmEuYm90dG9tID0gc2l6ZS5oZWlnaHQgLyAtMjtcbiAgfSBlbHNlIHtcbiAgICBjYW1lcmEuYXNwZWN0ID0gc2l6ZS53aWR0aCAvIHNpemUuaGVpZ2h0O1xuICB9XG4gIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG59XG5jb25zdCBpc09iamVjdDNEID0gb2JqZWN0ID0+IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0LmlzT2JqZWN0M0Q7XG5cbmZ1bmN0aW9uIG1ha2VJZChldmVudCkge1xuICByZXR1cm4gKGV2ZW50LmV2ZW50T2JqZWN0IHx8IGV2ZW50Lm9iamVjdCkudXVpZCArICcvJyArIGV2ZW50LmluZGV4ICsgZXZlbnQuaW5zdGFuY2VJZDtcbn1cblxuLyoqXG4gKiBSZWxlYXNlIHBvaW50ZXIgY2FwdHVyZXMuXG4gKiBUaGlzIGlzIGNhbGxlZCBieSByZWxlYXNlUG9pbnRlckNhcHR1cmUgaW4gdGhlIEFQSSwgYW5kIHdoZW4gYW4gb2JqZWN0IGlzIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGNhcHR1cmVkTWFwLCBvYmosIGNhcHR1cmVzLCBwb2ludGVySWQpIHtcbiAgY29uc3QgY2FwdHVyZURhdGEgPSBjYXB0dXJlcy5nZXQob2JqKTtcbiAgaWYgKGNhcHR1cmVEYXRhKSB7XG4gICAgY2FwdHVyZXMuZGVsZXRlKG9iaik7XG4gICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3QgY2FwdHVyaW5nIG9iamVjdCBmb3IgdGhpcyBwb2ludGVyXG4gICAgaWYgKGNhcHR1cmVzLnNpemUgPT09IDApIHtcbiAgICAgIGNhcHR1cmVkTWFwLmRlbGV0ZShwb2ludGVySWQpO1xuICAgICAgY2FwdHVyZURhdGEudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlSW50ZXJhY3Rpdml0eShzdG9yZSwgb2JqZWN0KSB7XG4gIGNvbnN0IHtcbiAgICBpbnRlcm5hbFxuICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgLy8gUmVtb3ZlcyBldmVyeSB0cmFjZSBvZiBhbiBvYmplY3QgZnJvbSB0aGUgZGF0YSBzdG9yZVxuICBpbnRlcm5hbC5pbnRlcmFjdGlvbiA9IGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvID0+IG8gIT09IG9iamVjdCk7XG4gIGludGVybmFsLmluaXRpYWxIaXRzID0gaW50ZXJuYWwuaW5pdGlhbEhpdHMuZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaG92ZXJlZC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKHZhbHVlLmV2ZW50T2JqZWN0ID09PSBvYmplY3QgfHwgdmFsdWUub2JqZWN0ID09PSBvYmplY3QpIHtcbiAgICAgIC8vIENsZWFyIG91dCBpbnRlcnNlY3RzLCB0aGV5IGFyZSBvdXRkYXRlZCBieSBub3dcbiAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9KTtcbiAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZm9yRWFjaCgoY2FwdHVyZXMsIHBvaW50ZXJJZCkgPT4ge1xuICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGludGVybmFsLmNhcHR1cmVkTWFwLCBvYmplY3QsIGNhcHR1cmVzLCBwb2ludGVySWQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50cyhzdG9yZSkge1xuICAvKiogQ2FsY3VsYXRlcyBkZWx0YSAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZShldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZHggPSBldmVudC5vZmZzZXRYIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzBdO1xuICAgIGNvbnN0IGR5ID0gZXZlbnQub2Zmc2V0WSAtIGludGVybmFsLmluaXRpYWxDbGlja1sxXTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgYW4gaW5zdGFuY2UgaGFzIGEgdmFsaWQgcG9pbnRlci1ldmVudCByZWdpc3RlcmVkLCB0aGlzIGV4Y2x1ZGVzIHNjcm9sbCwgY2xpY2tzIGV0YyAqL1xuICBmdW5jdGlvbiBmaWx0ZXJQb2ludGVyRXZlbnRzKG9iamVjdHMpIHtcbiAgICByZXR1cm4gb2JqZWN0cy5maWx0ZXIob2JqID0+IFsnTW92ZScsICdPdmVyJywgJ0VudGVyJywgJ091dCcsICdMZWF2ZSddLnNvbWUobmFtZSA9PiB7XG4gICAgICB2YXIgX3IzZjtcbiAgICAgIHJldHVybiAoX3IzZiA9IG9iai5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9yM2YuaGFuZGxlcnNbJ29uUG9pbnRlcicgKyBuYW1lXTtcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGV2ZW50LCBmaWx0ZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZHVwbGljYXRlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgLy8gQWxsb3cgY2FsbGVycyB0byBlbGltaW5hdGUgZXZlbnQgb2JqZWN0c1xuICAgIGNvbnN0IGV2ZW50c09iamVjdHMgPSBmaWx0ZXIgPyBmaWx0ZXIoc3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24pIDogc3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb247XG4gICAgLy8gUmVzZXQgYWxsIHJheWNhc3RlciBjYW1lcmFzIHRvIHVuZGVmaW5lZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzT2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUoZXZlbnRzT2JqZWN0c1tpXSk7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5wcmV2aW91c1Jvb3QpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSByb290LWxldmVsIHBvaW50ZXIgYW5kIHJheSBhcmUgc2V0IHVwXG4gICAgICBzdGF0ZS5ldmVudHMuY29tcHV0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbXB1dGUoZXZlbnQsIHN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUmF5Y2FzdChvYmopIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0Um9vdFN0YXRlKG9iaik7XG4gICAgICAvLyBTa2lwIGV2ZW50IGhhbmRsaW5nIHdoZW4gbm9FdmVudHMgaXMgc2V0LCBvciB3aGVuIHRoZSByYXljYXN0ZXJzIGNhbWVyYSBpcyBudWxsXG4gICAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5ldmVudHMuZW5hYmxlZCB8fCBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSBudWxsKSByZXR1cm4gW107XG5cbiAgICAgIC8vIFdoZW4gdGhlIGNhbWVyYSBpcyB1bmRlZmluZWQgd2UgaGF2ZSB0byBjYWxsIHRoZSBldmVudCBsYXllcnMgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICBpZiAoc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfc3RhdGUkcHJldmlvdXNSb290O1xuICAgICAgICBzdGF0ZS5ldmVudHMuY29tcHV0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbXB1dGUoZXZlbnQsIHN0YXRlLCAoX3N0YXRlJHByZXZpb3VzUm9vdCA9IHN0YXRlLnByZXZpb3VzUm9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKSk7XG4gICAgICAgIC8vIElmIHRoZSBjYW1lcmEgaXMgc3RpbGwgdW5kZWZpbmVkIHdlIGhhdmUgdG8gc2tpcCB0aGlzIGxheWVyIGVudGlyZWx5XG4gICAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcnNlY3Qgb2JqZWN0IGJ5IG9iamVjdFxuICAgICAgcmV0dXJuIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPyBzdGF0ZS5yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KG9iaiwgdHJ1ZSkgOiBbXTtcbiAgICB9XG5cbiAgICAvLyBDb2xsZWN0IGV2ZW50c1xuICAgIGxldCBoaXRzID0gZXZlbnRzT2JqZWN0c1xuICAgIC8vIEludGVyc2VjdCBvYmplY3RzXG4gICAgLmZsYXRNYXAoaGFuZGxlUmF5Y2FzdClcbiAgICAvLyBTb3J0IGJ5IGV2ZW50IHByaW9yaXR5IGFuZCBkaXN0YW5jZVxuICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBhU3RhdGUgPSBnZXRSb290U3RhdGUoYS5vYmplY3QpO1xuICAgICAgY29uc3QgYlN0YXRlID0gZ2V0Um9vdFN0YXRlKGIub2JqZWN0KTtcbiAgICAgIGlmICghYVN0YXRlIHx8ICFiU3RhdGUpIHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICAgIHJldHVybiBiU3RhdGUuZXZlbnRzLnByaW9yaXR5IC0gYVN0YXRlLmV2ZW50cy5wcmlvcml0eSB8fCBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICB9KVxuICAgIC8vIEZpbHRlciBvdXQgZHVwbGljYXRlc1xuICAgIC5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICBjb25zdCBpZCA9IG1ha2VJZChpdGVtKTtcbiAgICAgIGlmIChkdXBsaWNhdGVzLmhhcyhpZCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGR1cGxpY2F0ZXMuYWRkKGlkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTYwMzFcbiAgICAvLyBBbGxvdyBjdXN0b20gdXNlcmxhbmQgaW50ZXJzZWN0IHNvcnQgb3JkZXIsIHRoaXMgbGlrZWx5IG9ubHkgbWFrZXMgc2Vuc2Ugb24gdGhlIHJvb3QgZmlsdGVyXG4gICAgaWYgKHN0YXRlLmV2ZW50cy5maWx0ZXIpIGhpdHMgPSBzdGF0ZS5ldmVudHMuZmlsdGVyKGhpdHMsIHN0YXRlKTtcblxuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZXZlbnRzLCBmaW5kIHRoZSBldmVudCBzb3VyY2UgKGV2ZW50T2JqZWN0KVxuICAgIGZvciAoY29uc3QgaGl0IG9mIGhpdHMpIHtcbiAgICAgIGxldCBldmVudE9iamVjdCA9IGhpdC5vYmplY3Q7XG4gICAgICAvLyBCdWJibGUgZXZlbnQgdXBcbiAgICAgIHdoaWxlIChldmVudE9iamVjdCkge1xuICAgICAgICB2YXIgX3IzZjI7XG4gICAgICAgIGlmICgoX3IzZjIgPSBldmVudE9iamVjdC5fX3IzZikgIT0gbnVsbCAmJiBfcjNmMi5ldmVudENvdW50KSBpbnRlcnNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICBldmVudE9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRPYmplY3QgPSBldmVudE9iamVjdC5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGludGVyYWN0aW9uIGlzIGNhcHR1cmVkLCBtYWtlIGFsbCBjYXB0dXJpbmcgdGFyZ2V0cyBwYXJ0IG9mIHRoZSBpbnRlcnNlY3QuXG4gICAgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50ICYmIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICBmb3IgKGxldCBjYXB0dXJlRGF0YSBvZiBzdGF0ZS5pbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoZXZlbnQucG9pbnRlcklkKS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoIWR1cGxpY2F0ZXMuaGFzKG1ha2VJZChjYXB0dXJlRGF0YS5pbnRlcnNlY3Rpb24pKSkgaW50ZXJzZWN0aW9ucy5wdXNoKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG5cbiAgLyoqICBIYW5kbGVzIGludGVyc2VjdGlvbnMgYnkgZm9yd2FyZGluZyB0aGVtIHRvIGhhbmRsZXJzICovXG4gIGZ1bmN0aW9uIGhhbmRsZUludGVyc2VjdHMoaW50ZXJzZWN0aW9ucywgZXZlbnQsIGRlbHRhLCBjYWxsYmFjaykge1xuICAgIC8vIElmIGFueXRoaW5nIGhhcyBiZWVuIGZvdW5kLCBmb3J3YXJkIGl0IHRvIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSB7XG4gICAgICAgIHN0b3BwZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBoaXQgb2YgaW50ZXJzZWN0aW9ucykge1xuICAgICAgICBsZXQgc3RhdGUgPSBnZXRSb290U3RhdGUoaGl0Lm9iamVjdCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBpcyBub3QgbWFuYWdlZCBieSBSM0YsIGl0IG1pZ2h0IGJlIHBhcmVudGVkIHRvIGFuIGVsZW1lbnQgd2hpY2ggaXMuXG4gICAgICAgIC8vIFRyYXZlcnNlIHVwd2FyZHMgdW50aWwgd2UgZmluZCBhIG1hbmFnZWQgcGFyZW50IGFuZCB1c2UgaXRzIHN0YXRlIGluc3RlYWQuXG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICBoaXQub2JqZWN0LnRyYXZlcnNlQW5jZXN0b3JzKG9iaiA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRTdGF0ZSA9IGdldFJvb3RTdGF0ZShvYmopO1xuICAgICAgICAgICAgaWYgKHBhcmVudFN0YXRlKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gcGFyZW50U3RhdGU7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgY2FtZXJhLFxuICAgICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgICB9ID0gc3RhdGU7XG4gICAgICAgICAgY29uc3QgdW5wcm9qZWN0ZWRQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKHBvaW50ZXIueCwgcG9pbnRlci55LCAwKS51bnByb2plY3QoY2FtZXJhKTtcbiAgICAgICAgICBjb25zdCBoYXNQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICAgIHZhciBfaW50ZXJuYWwkY2FwdHVyZWRNYXAsIF9pbnRlcm5hbCRjYXB0dXJlZE1hcDI7XG4gICAgICAgICAgICByZXR1cm4gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA9IChfaW50ZXJuYWwkY2FwdHVyZWRNYXAyID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIuaGFzKGhpdC5ldmVudE9iamVjdCkpICE9IG51bGwgPyBfaW50ZXJuYWwkY2FwdHVyZWRNYXAgOiBmYWxzZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHNldFBvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FwdHVyZURhdGEgPSB7XG4gICAgICAgICAgICAgIGludGVyc2VjdGlvbjogaGl0LFxuICAgICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludGVySWQgd2FzIHByZXZpb3VzbHkgY2FwdHVyZWQsIHdlIGFkZCB0aGUgaGl0IHRvIHRoZVxuICAgICAgICAgICAgICAvLyBldmVudCBjYXB0dXJlZE1hcC5cbiAgICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKS5zZXQoaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlRGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBub3QgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgY3JlYXRlIGEgbWFwXG4gICAgICAgICAgICAgIC8vIGNvbnRhaW5pbmcgdGhlIGhpdE9iamVjdCwgYW5kIHRoZSBoaXQuIGhpdE9iamVjdCBpcyB1c2VkIGZvclxuICAgICAgICAgICAgICAvLyBmYXN0ZXIgYWNjZXNzLlxuICAgICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5zZXQoaWQsIG5ldyBNYXAoW1toaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVEYXRhXV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShpZCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCByZWxlYXNlUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlcyA9IGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZXMpIHtcbiAgICAgICAgICAgICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZXMsIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gQWRkIG5hdGl2ZSBldmVudCBwcm9wc1xuICAgICAgICAgIGxldCBleHRyYWN0RXZlbnRQcm9wcyA9IHt9O1xuICAgICAgICAgIC8vIFRoaXMgaXRlcmF0ZXMgb3ZlciB0aGUgZXZlbnQncyBwcm9wZXJ0aWVzIGluY2x1ZGluZyB0aGUgaW5oZXJpdGVkIG9uZXMuIE5hdGl2ZSBQb2ludGVyRXZlbnRzIGhhdmUgbW9zdCBvZiB0aGVpciBwcm9wcyBhcyBnZXR0ZXJzIHdoaWNoIGFyZSBpbmhlcml0ZWQsIGJ1dCBwb2x5ZmlsbGVkIFBvaW50ZXJFdmVudHMgaGF2ZSB0aGVtIGFsbCBhcyB0aGVpciBvd24gcHJvcGVydGllcyAoaS5lLiBub3QgaW5oZXJpdGVkKS4gV2UgY2FuJ3QgdXNlIE9iamVjdC5rZXlzKCkgb3IgT2JqZWN0LmVudHJpZXMoKSBhcyB0aGV5IG9ubHkgcmV0dXJuIFwib3duXCIgcHJvcGVydGllczsgbm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkgYXMgdGhhdCAqZG9lc24ndCogcmV0dXJuIFwib3duXCIgcHJvcGVydGllcywgb25seSBpbmhlcml0ZWQgb25lcy5cbiAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBldmVudFtwcm9wXTtcbiAgICAgICAgICAgIC8vIE9ubHkgY29weSBvdmVyIGF0b21pY3MsIGxlYXZlIGZ1bmN0aW9ucyBhbG9uZSBhcyB0aGVzZSBzaG91bGQgYmVcbiAgICAgICAgICAgIC8vIGNhbGxlZCBhcyBldmVudC5uYXRpdmVFdmVudC5mbigpXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnZnVuY3Rpb24nKSBleHRyYWN0RXZlbnRQcm9wc1twcm9wXSA9IHByb3BlcnR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmF5Y2FzdEV2ZW50ID0ge1xuICAgICAgICAgICAgLi4uaGl0LFxuICAgICAgICAgICAgLi4uZXh0cmFjdEV2ZW50UHJvcHMsXG4gICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9ucyxcbiAgICAgICAgICAgIHN0b3BwZWQ6IGxvY2FsU3RhdGUuc3RvcHBlZCxcbiAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgdW5wcm9qZWN0ZWRQb2ludCxcbiAgICAgICAgICAgIHJheTogcmF5Y2FzdGVyLnJheSxcbiAgICAgICAgICAgIGNhbWVyYTogY2FtZXJhLFxuICAgICAgICAgICAgLy8gSGlqYWNrIHN0b3BQcm9wYWdhdGlvbiwgd2hpY2gganVzdCBzZXRzIGEgZmxhZ1xuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy81OTZcbiAgICAgICAgICAgICAgLy8gRXZlbnRzIGFyZSBub3QgYWxsb3dlZCB0byBzdG9wIHByb3BhZ2F0aW9uIGlmIHRoZSBwb2ludGVyIGhhcyBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVzRm9yUG9pbnRlciA9ICdwb2ludGVySWQnIGluIGV2ZW50ICYmIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpO1xuXG4gICAgICAgICAgICAgIC8vIFdlIG9ubHkgYXV0aG9yaXplIHN0b3BQcm9wYWdhdGlvbi4uLlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIC8vIC4uLmlmIHRoaXMgcG9pbnRlciBoYXNuJ3QgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgICAhY2FwdHVyZXNGb3JQb2ludGVyIHx8XG4gICAgICAgICAgICAgIC8vIC4uLiBvciBpZiB0aGUgaGl0IG9iamVjdCBpcyBjYXB0dXJpbmcgdGhlIHBvaW50ZXJcbiAgICAgICAgICAgICAgY2FwdHVyZXNGb3JQb2ludGVyLmhhcyhoaXQuZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmF5Y2FzdEV2ZW50LnN0b3BwZWQgPSBsb2NhbFN0YXRlLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIFByb3BhZ2F0aW9uIGlzIHN0b3BwZWQsIHJlbW92ZSBhbGwgb3RoZXIgaG92ZXIgcmVjb3Jkc1xuICAgICAgICAgICAgICAgIC8vIEFuIGV2ZW50IGhhbmRsZXIgaXMgb25seSBhbGxvd2VkIHRvIGZsdXNoIG90aGVyIGhhbmRsZXJzIGlmIGl0IGlzIGhvdmVyZWQgaXRzZWxmXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFsLmhvdmVyZWQuc2l6ZSAmJiBBcnJheS5mcm9tKGludGVybmFsLmhvdmVyZWQudmFsdWVzKCkpLmZpbmQoaSA9PiBpLmV2ZW50T2JqZWN0ID09PSBoaXQuZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBPYmplY3RzIGNhbm5vdCBmbHVzaCBvdXQgaGlnaGVyIHVwIG9iamVjdHMgdGhhdCBoYXZlIGFscmVhZHkgY2F1Z2h0IHRoZSBldmVudFxuICAgICAgICAgICAgICAgICAgY29uc3QgaGlnaGVyID0gaW50ZXJzZWN0aW9ucy5zbGljZSgwLCBpbnRlcnNlY3Rpb25zLmluZGV4T2YoaGl0KSk7XG4gICAgICAgICAgICAgICAgICBjYW5jZWxQb2ludGVyKFsuLi5oaWdoZXIsIGhpdF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHRoZXJlIHNob3VsZCBiZSBhIGRpc3RpbmN0aW9uIGJldHdlZW4gdGFyZ2V0IGFuZCBjdXJyZW50VGFyZ2V0XG4gICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICAgIHNldFBvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB7XG4gICAgICAgICAgICAgIGhhc1BvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIENhbGwgc3Vic2NyaWJlcnNcbiAgICAgICAgICBjYWxsYmFjayhyYXljYXN0RXZlbnQpO1xuICAgICAgICAgIC8vIEV2ZW50IGJ1YmJsaW5nIG1heSBiZSBpbnRlcnJ1cHRlZCBieSBzdG9wUHJvcGFnYXRpb25cbiAgICAgICAgICBpZiAobG9jYWxTdGF0ZS5zdG9wcGVkID09PSB0cnVlKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWxQb2ludGVyKGludGVyc2VjdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcm5hbFxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGZvciAoY29uc3QgaG92ZXJlZE9iaiBvZiBpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKSB7XG4gICAgICAvLyBXaGVuIG5vIG9iamVjdHMgd2VyZSBoaXQgb3IgdGhlIHRoZSBob3ZlcmVkIG9iamVjdCB3YXNuJ3QgZm91bmQgdW5kZXJuZWF0aCB0aGUgY3Vyc29yXG4gICAgICAvLyB3ZSBjYWxsIG9uUG9pbnRlck91dCBhbmQgZGVsZXRlIHRoZSBvYmplY3QgZnJvbSB0aGUgaG92ZXJlZC1lbGVtZW50cyBtYXBcbiAgICAgIGlmICghaW50ZXJzZWN0aW9ucy5sZW5ndGggfHwgIWludGVyc2VjdGlvbnMuZmluZChoaXQgPT4gaGl0Lm9iamVjdCA9PT0gaG92ZXJlZE9iai5vYmplY3QgJiYgaGl0LmluZGV4ID09PSBob3ZlcmVkT2JqLmluZGV4ICYmIGhpdC5pbnN0YW5jZUlkID09PSBob3ZlcmVkT2JqLmluc3RhbmNlSWQpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gaG92ZXJlZE9iai5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBldmVudE9iamVjdC5fX3IzZjtcbiAgICAgICAgaW50ZXJuYWwuaG92ZXJlZC5kZWxldGUobWFrZUlkKGhvdmVyZWRPYmopKTtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwgJiYgaW5zdGFuY2UuZXZlbnRDb3VudCkge1xuICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gaW5zdGFuY2UuaGFuZGxlcnM7XG4gICAgICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAuLi5ob3ZlcmVkT2JqLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uc1xuICAgICAgICAgIH07XG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyT3V0ID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJPdXQoZGF0YSk7XG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyTGVhdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlckxlYXZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJNaXNzZWQoZXZlbnQsIG9iamVjdHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gb2JqZWN0c1tpXS5fX3IzZjtcbiAgICAgIGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycy5vblBvaW50ZXJNaXNzZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXIobmFtZSkge1xuICAgIC8vIERlYWwgd2l0aCBjYW5jZWxhdGlvblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnb25Qb2ludGVyTGVhdmUnOlxuICAgICAgY2FzZSAnb25Qb2ludGVyQ2FuY2VsJzpcbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbFBvaW50ZXIoW10pO1xuICAgICAgY2FzZSAnb25Mb3N0UG9pbnRlckNhcHR1cmUnOlxuICAgICAgICByZXR1cm4gZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGludGVybmFsXG4gICAgICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50ICYmIGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGV2ZW50IGludGVyZmFjZSBoYWQgb25Mb3N0UG9pbnRlckNhcHR1cmUsIHdlJ2QgY2FsbCBpdCBoZXJlIG9uIGV2ZXJ5XG4gICAgICAgICAgICAvLyBvYmplY3QgdGhhdCdzIGdldHRpbmcgcmVtb3ZlZC4gV2UgY2FsbCBpdCBvbiB0aGUgbmV4dCBmcmFtZSBiZWNhdXNlIG9uTG9zdFBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgICAvLyBmaXJlcyBiZWZvcmUgb25Qb2ludGVyVXAuIE90aGVyd2lzZSBwb2ludGVyVXAgd291bGQgbmV2ZXIgYmUgY2FsbGVkIGlmIHRoZSBldmVudCBkaWRuJ3RcbiAgICAgICAgICAgIC8vIGhhcHBlbiBpbiB0aGUgb2JqZWN0IGl0IG9yaWdpbmF0ZWQgZnJvbSwgbGVhdmluZyBjb21wb25lbnRzIGluIGEgaW4tYmV0d2VlbiBzdGF0ZS5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgcmVsZWFzZSBpZiBwb2ludGVyLXVwIGRpZG4ndCBkbyBpdCBhbHJlYWR5XG4gICAgICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmRlbGV0ZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgICAgIGNhbmNlbFBvaW50ZXIoW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQW55IG90aGVyIHBvaW50ZXIgZ29lcyBoZXJlIC4uLlxuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvblBvaW50ZXJNaXNzZWQsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gcHJlcGFyZVJheShldmVudClcbiAgICAgIGludGVybmFsLmxhc3RFdmVudC5jdXJyZW50ID0gZXZlbnQ7XG5cbiAgICAgIC8vIEdldCBmcmVzaCBpbnRlcnNlY3RzXG4gICAgICBjb25zdCBpc1BvaW50ZXJNb3ZlID0gbmFtZSA9PT0gJ29uUG9pbnRlck1vdmUnO1xuICAgICAgY29uc3QgaXNDbGlja0V2ZW50ID0gbmFtZSA9PT0gJ29uQ2xpY2snIHx8IG5hbWUgPT09ICdvbkNvbnRleHRNZW51JyB8fCBuYW1lID09PSAnb25Eb3VibGVDbGljayc7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBpc1BvaW50ZXJNb3ZlID8gZmlsdGVyUG9pbnRlckV2ZW50cyA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGhpdHMgPSBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcik7XG4gICAgICBjb25zdCBkZWx0YSA9IGlzQ2xpY2tFdmVudCA/IGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSA6IDA7XG5cbiAgICAgIC8vIFNhdmUgaW5pdGlhbCBjb29yZGluYXRlcyBvbiBwb2ludGVyLWRvd25cbiAgICAgIGlmIChuYW1lID09PSAnb25Qb2ludGVyRG93bicpIHtcbiAgICAgICAgaW50ZXJuYWwuaW5pdGlhbENsaWNrID0gW2V2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFldO1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsSGl0cyA9IGhpdHMubWFwKGhpdCA9PiBoaXQuZXZlbnRPYmplY3QpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhIGNsaWNrIHlpZWxkcyBubyByZXN1bHRzLCBwYXNzIGl0IGJhY2sgdG8gdGhlIHVzZXIgYXMgYSBtaXNzXG4gICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdCBpbiBvcmRlciB0byBlc3RhYmxpc2ggdXNlci1sYW5kIHNpZGUtZWZmZWN0IGNsZWFuIHVwXG4gICAgICBpZiAoaXNDbGlja0V2ZW50ICYmICFoaXRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoZGVsdGEgPD0gMikge1xuICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uKTtcbiAgICAgICAgICBpZiAob25Qb2ludGVyTWlzc2VkKSBvblBvaW50ZXJNaXNzZWQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUYWtlIGNhcmUgb2YgdW5ob3ZlclxuICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIGNhbmNlbFBvaW50ZXIoaGl0cyk7XG4gICAgICBmdW5jdGlvbiBvbkludGVyc2VjdChkYXRhKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gZGF0YS5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBldmVudE9iamVjdC5fX3IzZjtcblxuICAgICAgICAvLyBDaGVjayBwcmVzZW5jZSBvZiBoYW5kbGVyc1xuICAgICAgICBpZiAoIShpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gaW5zdGFuY2UuaGFuZGxlcnM7XG5cbiAgICAgICAgLypcbiAgICAgICAgTUFZQkUgVE9ETywgREVMRVRFIElGIE5PVDogXG4gICAgICAgICAgQ2hlY2sgaWYgdGhlIG9iamVjdCBpcyBjYXB0dXJlZCwgY2FwdHVyZWQgZXZlbnRzIHNob3VsZCBub3QgaGF2ZSBpbnRlcnNlY3RzIHJ1bm5pbmcgaW4gcGFyYWxsZWxcbiAgICAgICAgICBCdXQgd291bGRuJ3QgaXQgYmUgYmV0dGVyIHRvIGp1c3QgcmVwbGFjZSBjYXB0dXJlZE1hcCB3aXRoIGEgc2luZ2xlIGVudHJ5P1xuICAgICAgICAgIEFsc28sIGFyZSB3ZSBPSyB3aXRoIHN0cmFpZ2h0IHVwIG1ha2luZyBwaWNraW5nIHVwIG11bHRpcGxlIG9iamVjdHMgaW1wb3NzaWJsZT9cbiAgICAgICAgICBcbiAgICAgICAgY29uc3QgcG9pbnRlcklkID0gKGRhdGEgYXMgVGhyZWVFdmVudDxQb2ludGVyRXZlbnQ+KS5wb2ludGVySWQgICAgICAgIFxuICAgICAgICBpZiAocG9pbnRlcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlZE1lc2hTZXQgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQocG9pbnRlcklkKVxuICAgICAgICAgIGlmIChjYXB0dXJlZE1lc2hTZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVkID0gY2FwdHVyZWRNZXNoU2V0LmdldChldmVudE9iamVjdClcbiAgICAgICAgICAgIGlmIChjYXB0dXJlZCAmJiBjYXB0dXJlZC5sb2NhbFN0YXRlLnN0b3BwZWQpIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIHtcbiAgICAgICAgICAvLyBNb3ZlIGV2ZW50IC4uLlxuICAgICAgICAgIGlmIChoYW5kbGVycy5vblBvaW50ZXJPdmVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlckVudGVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlck91dCB8fCBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSkge1xuICAgICAgICAgICAgLy8gV2hlbiBlbnRlciBvciBvdXQgaXMgcHJlc2VudCB0YWtlIGNhcmUgb2YgaG92ZXItc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZEl0ZW0gPSBpbnRlcm5hbC5ob3ZlcmVkLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoIWhvdmVyZWRJdGVtKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2Fzbid0IHByZXZpb3VzbHkgaG92ZXJlZCwgYm9vayBpdCBhbmQgY2FsbCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLnNldChpZCwgZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck92ZXIoZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlckVudGVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJFbnRlcihkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0uc3RvcHBlZCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhcyBwcmV2aW91c2x5IGhvdmVyZWQgYW5kIHN0b3BwZWQsIHdlIHNob3VsZG4ndCBhbGxvdyBvdGhlciBpdGVtcyB0byBwcm9jZWVkXG4gICAgICAgICAgICAgIGRhdGEuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhbGwgbW91c2UgbW92ZVxuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck1vdmUoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxsIG90aGVyIGV2ZW50cyAuLi5cbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIEZvcndhcmQgYWxsIGV2ZW50cyBiYWNrIHRvIHRoZWlyIHJlc3BlY3RpdmUgaGFuZGxlcnMgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGNsaWNrIGV2ZW50cyxcbiAgICAgICAgICAgIC8vIHdoaWNoIG11c3QgdXNlIHRoZSBpbml0aWFsIHRhcmdldFxuICAgICAgICAgICAgaWYgKCFpc0NsaWNrRXZlbnQgfHwgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgICAgLy8gTm93IGNhbGwgdGhlIGhhbmRsZXJcbiAgICAgICAgICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBvblBvaW50ZXJNaXNzZWQgb24gYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBwb2ludGVyIG92ZXIvb3V0IGhhbmRsZXJzLCBidXQgbm90IGNsaWNrIGFuZCB3ZXJlbid0IGhpdFxuICAgICAgICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiBpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG9iamVjdCA9PiAhaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMob2JqZWN0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlSW50ZXJzZWN0cyhoaXRzLCBldmVudCwgZGVsdGEsIG9uSW50ZXJzZWN0KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFuZGxlUG9pbnRlclxuICB9O1xufVxuXG5jb25zdCBpc1JlbmRlcmVyID0gZGVmID0+ICEhKGRlZiAhPSBudWxsICYmIGRlZi5yZW5kZXIpO1xuY29uc3QgY29udGV4dCA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBjcmVhdGVTdG9yZSA9IChpbnZhbGlkYXRlLCBhZHZhbmNlKSA9PiB7XG4gIGNvbnN0IHJvb3RTdG9yZSA9IGNyZWF0ZVdpdGhFcXVhbGl0eUZuKChzZXQsIGdldCkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCBkZWZhdWx0VGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCB0ZW1wVGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhID0gZ2V0KCkuY2FtZXJhLCB0YXJnZXQgPSBkZWZhdWx0VGFyZ2V0LCBzaXplID0gZ2V0KCkuc2l6ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0b3AsXG4gICAgICAgIGxlZnRcbiAgICAgIH0gPSBzaXplO1xuICAgICAgY29uc3QgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICBpZiAodGFyZ2V0LmlzVmVjdG9yMykgdGVtcFRhcmdldC5jb3B5KHRhcmdldCk7ZWxzZSB0ZW1wVGFyZ2V0LnNldCguLi50YXJnZXQpO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBjYW1lcmEuZ2V0V29ybGRQb3NpdGlvbihwb3NpdGlvbikuZGlzdGFuY2VUbyh0ZW1wVGFyZ2V0KTtcbiAgICAgIGlmIChpc09ydGhvZ3JhcGhpY0NhbWVyYShjYW1lcmEpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoIC8gY2FtZXJhLnpvb20sXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLyBjYW1lcmEuem9vbSxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICBmYWN0b3I6IDEsXG4gICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgYXNwZWN0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmb3YgPSBjYW1lcmEuZm92ICogTWF0aC5QSSAvIDE4MDsgLy8gY29udmVydCB2ZXJ0aWNhbCBmb3YgdG8gcmFkaWFuc1xuICAgICAgICBjb25zdCBoID0gMiAqIE1hdGgudGFuKGZvdiAvIDIpICogZGlzdGFuY2U7IC8vIHZpc2libGUgaGVpZ2h0XG4gICAgICAgIGNvbnN0IHcgPSBoICogKHdpZHRoIC8gaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgZmFjdG9yOiB3aWR0aCAvIHcsXG4gICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgYXNwZWN0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBwZXJmb3JtYW5jZVRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc2V0UGVyZm9ybWFuY2VDdXJyZW50ID0gY3VycmVudCA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIC4uLnN0YXRlLnBlcmZvcm1hbmNlLFxuICAgICAgICBjdXJyZW50XG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHBvaW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIGNvbnN0IHJvb3RTdGF0ZSA9IHtcbiAgICAgIHNldCxcbiAgICAgIGdldCxcbiAgICAgIC8vIE1vY2sgb2JqZWN0cyB0aGF0IGhhdmUgdG8gYmUgY29uZmlndXJlZFxuICAgICAgZ2w6IG51bGwsXG4gICAgICBjYW1lcmE6IG51bGwsXG4gICAgICByYXljYXN0ZXI6IG51bGwsXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgcHJpb3JpdHk6IDEsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGNvbm5lY3RlZDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzY2VuZTogbnVsbCxcbiAgICAgIHhyOiBudWxsLFxuICAgICAgaW52YWxpZGF0ZTogKGZyYW1lcyA9IDEpID0+IGludmFsaWRhdGUoZ2V0KCksIGZyYW1lcyksXG4gICAgICBhZHZhbmNlOiAodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzKSA9PiBhZHZhbmNlKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cywgZ2V0KCkpLFxuICAgICAgbGVnYWN5OiBmYWxzZSxcbiAgICAgIGxpbmVhcjogZmFsc2UsXG4gICAgICBmbGF0OiBmYWxzZSxcbiAgICAgIGNvbnRyb2xzOiBudWxsLFxuICAgICAgY2xvY2s6IG5ldyBUSFJFRS5DbG9jaygpLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgZnJhbWVsb29wOiAnYWx3YXlzJyxcbiAgICAgIG9uUG9pbnRlck1pc3NlZDogdW5kZWZpbmVkLFxuICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgY3VycmVudDogMSxcbiAgICAgICAgbWluOiAwLjUsXG4gICAgICAgIG1heDogMSxcbiAgICAgICAgZGVib3VuY2U6IDIwMCxcbiAgICAgICAgcmVncmVzczogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgICAgLy8gQ2xlYXIgdGltZW91dFxuICAgICAgICAgIGlmIChwZXJmb3JtYW5jZVRpbWVvdXQpIGNsZWFyVGltZW91dChwZXJmb3JtYW5jZVRpbWVvdXQpO1xuICAgICAgICAgIC8vIFNldCBsb3dlciBib3VuZCBwZXJmb3JtYW5jZVxuICAgICAgICAgIGlmIChzdGF0ZS5wZXJmb3JtYW5jZS5jdXJyZW50ICE9PSBzdGF0ZS5wZXJmb3JtYW5jZS5taW4pIHNldFBlcmZvcm1hbmNlQ3VycmVudChzdGF0ZS5wZXJmb3JtYW5jZS5taW4pO1xuICAgICAgICAgIC8vIEdvIGJhY2sgdG8gdXBwZXIgYm91bmQgcGVyZm9ybWFuY2UgYWZ0ZXIgYSB3aGlsZSB1bmxlc3Mgc29tZXRoaW5nIHJlZ3Jlc3NlcyBtZWFud2hpbGVcbiAgICAgICAgICBwZXJmb3JtYW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHNldFBlcmZvcm1hbmNlQ3VycmVudChnZXQoKS5wZXJmb3JtYW5jZS5tYXgpLCBzdGF0ZS5wZXJmb3JtYW5jZS5kZWJvdW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMFxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGluaXRpYWxEcHI6IDAsXG4gICAgICAgIGRwcjogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBhc3BlY3Q6IDAsXG4gICAgICAgIGRpc3RhbmNlOiAwLFxuICAgICAgICBmYWN0b3I6IDAsXG4gICAgICAgIGdldEN1cnJlbnRWaWV3cG9ydFxuICAgICAgfSxcbiAgICAgIHNldEV2ZW50czogZXZlbnRzID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KSksXG4gICAgICBzZXRTaXplOiAod2lkdGgsIGhlaWdodCwgdG9wID0gMCwgbGVmdCA9IDApID0+IHtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gZ2V0KCkuY2FtZXJhO1xuICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdFxuICAgICAgICB9O1xuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAgIC4uLmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEsIGRlZmF1bHRUYXJnZXQsIHNpemUpXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgc2V0RHByOiBkcHIgPT4gc2V0KHN0YXRlID0+IHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBjYWxjdWxhdGVEcHIoZHByKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICBkcHI6IHJlc29sdmVkLFxuICAgICAgICAgICAgaW5pdGlhbERwcjogc3RhdGUudmlld3BvcnQuaW5pdGlhbERwciB8fCByZXNvbHZlZFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgc2V0RnJhbWVsb29wOiAoZnJhbWVsb29wID0gJ2Fsd2F5cycpID0+IHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSBnZXQoKS5jbG9jaztcblxuICAgICAgICAvLyBpZiBmcmFtZWxvb3AgPT09IFwibmV2ZXJcIiBjbG9jay5lbGFwc2VkVGltZSBpcyB1cGRhdGVkIHVzaW5nIGFkdmFuY2UodGltZXN0YW1wKVxuICAgICAgICBjbG9jay5zdG9wKCk7XG4gICAgICAgIGNsb2NrLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgaWYgKGZyYW1lbG9vcCAhPT0gJ25ldmVyJykge1xuICAgICAgICAgIGNsb2NrLnN0YXJ0KCk7XG4gICAgICAgICAgY2xvY2suZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHNldCgoKSA9PiAoe1xuICAgICAgICAgIGZyYW1lbG9vcFxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgcHJldmlvdXNSb290OiB1bmRlZmluZWQsXG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICAvLyBFdmVudHNcbiAgICAgICAgaW50ZXJhY3Rpb246IFtdLFxuICAgICAgICBob3ZlcmVkOiBuZXcgTWFwKCksXG4gICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgaW5pdGlhbENsaWNrOiBbMCwgMF0sXG4gICAgICAgIGluaXRpYWxIaXRzOiBbXSxcbiAgICAgICAgY2FwdHVyZWRNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgbGFzdEV2ZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCksXG4gICAgICAgIC8vIFVwZGF0ZXNcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgZnJhbWVzOiAwLFxuICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgc3Vic2NyaWJlOiAocmVmLCBwcmlvcml0eSwgc3RvcmUpID0+IHtcbiAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGdldCgpLmludGVybmFsO1xuICAgICAgICAgIC8vIElmIHRoaXMgc3Vic2NyaXB0aW9uIHdhcyBnaXZlbiBhIHByaW9yaXR5LCBpdCB0YWtlcyByZW5kZXJpbmcgaW50byBpdHMgb3duIGhhbmRzXG4gICAgICAgICAgLy8gRm9yIHRoYXQgcmVhc29uIHdlIHN3aXRjaCBvZmYgYXV0b21hdGljIHJlbmRlcmluZyBhbmQgaW5jcmVhc2UgdGhlIG1hbnVhbCBmbGFnXG4gICAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGlzIGZsYWcgaXMgcG9zaXRpdmUgdGhlcmUgY2FuIGJlIG5vIGludGVybmFsIHJlbmRlcmluZyBhdCBhbGxcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIHJlbmRlciBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgaW50ZXJuYWwucHJpb3JpdHkgPSBpbnRlcm5hbC5wcmlvcml0eSArIChwcmlvcml0eSA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMucHVzaCh7XG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gUmVnaXN0ZXIgc3Vic2NyaWJlciBhbmQgc29ydCBsYXllcnMgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCwgbWVhbmluZyxcbiAgICAgICAgICAvLyBoaWdoZXN0IHByaW9yaXR5IHJlbmRlcnMgbGFzdCAob24gdG9wIG9mIHRoZSBvdGhlciBmcmFtZXMpXG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMgPSBpbnRlcm5hbC5zdWJzY3JpYmVycy5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsID0gZ2V0KCkuaW50ZXJuYWw7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwgIT0gbnVsbCAmJiBpbnRlcm5hbC5zdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAvLyBEZWNyZWFzZSBtYW51YWwgZmxhZyBpZiB0aGlzIHN1YnNjcmlwdGlvbiBoYWQgYSBwcmlvcml0eVxuICAgICAgICAgICAgICBpbnRlcm5hbC5wcmlvcml0eSA9IGludGVybmFsLnByaW9yaXR5IC0gKHByaW9yaXR5ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXIgZnJvbSBsaXN0XG4gICAgICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzID0gaW50ZXJuYWwuc3Vic2NyaWJlcnMuZmlsdGVyKHMgPT4gcy5yZWYgIT09IHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJvb3RTdGF0ZTtcbiAgfSk7XG4gIGNvbnN0IHN0YXRlID0gcm9vdFN0b3JlLmdldFN0YXRlKCk7XG4gIGxldCBvbGRTaXplID0gc3RhdGUuc2l6ZTtcbiAgbGV0IG9sZERwciA9IHN0YXRlLnZpZXdwb3J0LmRwcjtcbiAgbGV0IG9sZENhbWVyYSA9IHN0YXRlLmNhbWVyYTtcbiAgcm9vdFN0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FtZXJhLFxuICAgICAgc2l6ZSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgZ2wsXG4gICAgICBzZXRcbiAgICB9ID0gcm9vdFN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBSZXNpemUgY2FtZXJhIGFuZCByZW5kZXJlciBvbiBjaGFuZ2VzIHRvIHNpemUgYW5kIHBpeGVscmF0aW9cbiAgICBpZiAoc2l6ZS53aWR0aCAhPT0gb2xkU2l6ZS53aWR0aCB8fCBzaXplLmhlaWdodCAhPT0gb2xkU2l6ZS5oZWlnaHQgfHwgdmlld3BvcnQuZHByICE9PSBvbGREcHIpIHtcbiAgICAgIG9sZFNpemUgPSBzaXplO1xuICAgICAgb2xkRHByID0gdmlld3BvcnQuZHByO1xuICAgICAgLy8gVXBkYXRlIGNhbWVyYSAmIHJlbmRlcmVyXG4gICAgICB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICAgIGlmICh2aWV3cG9ydC5kcHIgPiAwKSBnbC5zZXRQaXhlbFJhdGlvKHZpZXdwb3J0LmRwcik7XG4gICAgICBjb25zdCB1cGRhdGVTdHlsZSA9IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2wuZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xuICAgICAgZ2wuc2V0U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdXBkYXRlU3R5bGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB2aWV3cG9ydCBvbmNlIHRoZSBjYW1lcmEgY2hhbmdlc1xuICAgIGlmIChjYW1lcmEgIT09IG9sZENhbWVyYSkge1xuICAgICAgb2xkQ2FtZXJhID0gY2FtZXJhO1xuICAgICAgLy8gVXBkYXRlIHZpZXdwb3J0XG4gICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydC5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhKVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJbnZhbGlkYXRlIG9uIGFueSBjaGFuZ2VcbiAgcm9vdFN0b3JlLnN1YnNjcmliZShzdGF0ZSA9PiBpbnZhbGlkYXRlKHN0YXRlKSk7XG5cbiAgLy8gUmV0dXJuIHJvb3Qgc3RhdGVcbiAgcmV0dXJuIHJvb3RTdG9yZTtcbn07XG5cbi8qKlxuICogRXhwb3NlcyBhbiBvYmplY3QncyB7QGxpbmsgSW5zdGFuY2V9LlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI3VzZUluc3RhbmNlSGFuZGxlXG4gKlxuICogKipOb3RlKio6IHRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIHRvIHJlYWN0LWludGVybmFsIGZpZWxkcy4gRXhwZWN0IHRoaXMgdG8gY2hhbmdlIHNpZ25pZmljYW50bHkgYmV0d2VlbiB2ZXJzaW9ucy5cbiAqL1xuZnVuY3Rpb24gdXNlSW5zdGFuY2VIYW5kbGUocmVmKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGluc3RhbmNlLCAoKSA9PiByZWYuY3VycmVudC5fX3IzZiwgW3JlZl0pO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgUjNGIENhbnZhcycgWnVzdGFuZCBzdG9yZS4gVXNlZnVsIGZvciBbdHJhbnNpZW50IHVwZGF0ZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvenVzdGFuZCN0cmFuc2llbnQtdXBkYXRlcy1mb3Itb2Z0ZW4tb2NjdXJyaW5nLXN0YXRlLWNoYW5nZXMpLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlc3RvcmVcbiAqL1xuZnVuY3Rpb24gdXNlU3RvcmUoKSB7XG4gIGNvbnN0IHN0b3JlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgaWYgKCFzdG9yZSkgdGhyb3cgbmV3IEVycm9yKCdSM0Y6IEhvb2tzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSBDYW52YXMgY29tcG9uZW50IScpO1xuICByZXR1cm4gc3RvcmU7XG59XG5cbi8qKlxuICogQWNjZXNzZXMgUjNGJ3MgaW50ZXJuYWwgc3RhdGUsIGNvbnRhaW5pbmcgcmVuZGVyZXIsIGNhbnZhcywgc2NlbmUsIGV0Yy5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZXRocmVlXG4gKi9cbmZ1bmN0aW9uIHVzZVRocmVlKHNlbGVjdG9yID0gc3RhdGUgPT4gc3RhdGUsIGVxdWFsaXR5Rm4pIHtcbiAgcmV0dXJuIHVzZVN0b3JlKCkoc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIGEgY2FsbGJhY2sgYmVmb3JlIHJlbmRlciBpbiBhIHNoYXJlZCBmcmFtZSBsb29wLlxuICogQ2FuIG9yZGVyIGVmZmVjdHMgd2l0aCByZW5kZXIgcHJpb3JpdHkgb3IgbWFudWFsbHkgcmVuZGVyIHdpdGggYSBwb3NpdGl2ZSBwcmlvcml0eS5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZWZyYW1lXG4gKi9cbmZ1bmN0aW9uIHVzZUZyYW1lKGNhbGxiYWNrLCByZW5kZXJQcmlvcml0eSA9IDApIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSBzdG9yZS5nZXRTdGF0ZSgpLmludGVybmFsLnN1YnNjcmliZTtcbiAgLy8gTWVtb2l6ZSByZWZcbiAgY29uc3QgcmVmID0gdXNlTXV0YWJsZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgLy8gU3Vic2NyaWJlIG9uIG1vdW50LCB1bnN1YnNjcmliZSBvbiB1bm1vdW50XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gc3Vic2NyaWJlKHJlZiwgcmVuZGVyUHJpb3JpdHksIHN0b3JlKSwgW3JlbmRlclByaW9yaXR5LCBzdWJzY3JpYmUsIHN0b3JlXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBub2RlIGdyYXBoIG9mIGFuIG9iamVjdCB3aXRoIG5hbWVkIG5vZGVzICYgbWF0ZXJpYWxzLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZ3JhcGhcbiAqL1xuZnVuY3Rpb24gdXNlR3JhcGgob2JqZWN0KSB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGJ1aWxkR3JhcGgob2JqZWN0KSwgW29iamVjdF0pO1xufVxuY29uc3QgbWVtb2l6ZWRMb2FkZXJzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGlzQ29uc3RydWN0b3IkMSA9IHZhbHVlID0+IHtcbiAgdmFyIF92YWx1ZSRwcm90b3R5cGU7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgKHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiAoX3ZhbHVlJHByb3RvdHlwZSA9IHZhbHVlLnByb3RvdHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF92YWx1ZSRwcm90b3R5cGUuY29uc3RydWN0b3IpID09PSB2YWx1ZTtcbn07XG5mdW5jdGlvbiBsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcykge1xuICByZXR1cm4gZnVuY3Rpb24gKFByb3RvLCAuLi5pbnB1dCkge1xuICAgIGxldCBsb2FkZXI7XG5cbiAgICAvLyBDb25zdHJ1Y3QgYW5kIGNhY2hlIGxvYWRlciBpZiBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkXG4gICAgaWYgKGlzQ29uc3RydWN0b3IkMShQcm90bykpIHtcbiAgICAgIGxvYWRlciA9IG1lbW9pemVkTG9hZGVycy5nZXQoUHJvdG8pO1xuICAgICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyID0gbmV3IFByb3RvKCk7XG4gICAgICAgIG1lbW9pemVkTG9hZGVycy5zZXQoUHJvdG8sIGxvYWRlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRlciA9IFByb3RvO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGxvYWRlciBleHRlbnNpb25zXG4gICAgaWYgKGV4dGVuc2lvbnMpIGV4dGVuc2lvbnMobG9hZGVyKTtcblxuICAgIC8vIEdvIHRocm91Z2ggdGhlIHVybHMgYW5kIGxvYWQgdGhlbVxuICAgIHJldHVybiBQcm9taXNlLmFsbChpbnB1dC5tYXAoaW5wdXQgPT4gbmV3IFByb21pc2UoKHJlcywgcmVqZWN0KSA9PiBsb2FkZXIubG9hZChpbnB1dCwgZGF0YSA9PiB7XG4gICAgICBpZiAoaXNPYmplY3QzRChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLnNjZW5lKSkgT2JqZWN0LmFzc2lnbihkYXRhLCBidWlsZEdyYXBoKGRhdGEuc2NlbmUpKTtcbiAgICAgIHJlcyhkYXRhKTtcbiAgICB9LCBvblByb2dyZXNzLCBlcnJvciA9PiByZWplY3QobmV3IEVycm9yKGBDb3VsZCBub3QgbG9hZCAke2lucHV0fTogJHtlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZX1gKSkpKSkpO1xuICB9O1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgbG9hZHMgYW5kIGNhY2hlcyBhc3NldHMgd2l0aCBhIHRocmVlIGxvYWRlci5cbiAqXG4gKiBOb3RlOiB0aGlzIGhvb2sncyBjYWxsZXIgbXVzdCBiZSB3cmFwcGVkIHdpdGggYFJlYWN0LlN1c3BlbnNlYFxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlbG9hZGVyXG4gKi9cbmZ1bmN0aW9uIHVzZUxvYWRlcihsb2FkZXIsIGlucHV0LCBleHRlbnNpb25zLCBvblByb2dyZXNzKSB7XG4gIC8vIFVzZSBzdXNwZW5zZSB0byBsb2FkIGFzeW5jIGFzc2V0c1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIGNvbnN0IHJlc3VsdHMgPSBzdXNwZW5kKGxvYWRpbmdGbihleHRlbnNpb25zLCBvblByb2dyZXNzKSwgW2xvYWRlciwgLi4ua2V5c10sIHtcbiAgICBlcXVhbDogaXMuZXF1XG4gIH0pO1xuICAvLyBSZXR1cm4gdGhlIG9iamVjdChzKVxuICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgPyByZXN1bHRzIDogcmVzdWx0c1swXTtcbn1cblxuLyoqXG4gKiBQcmVsb2FkcyBhbiBhc3NldCBpbnRvIGNhY2hlIGFzIGEgc2lkZS1lZmZlY3QuXG4gKi9cbnVzZUxvYWRlci5wcmVsb2FkID0gZnVuY3Rpb24gKGxvYWRlciwgaW5wdXQsIGV4dGVuc2lvbnMpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICByZXR1cm4gcHJlbG9hZChsb2FkaW5nRm4oZXh0ZW5zaW9ucyksIFtsb2FkZXIsIC4uLmtleXNdKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGxvYWRlZCBhc3NldCBmcm9tIGNhY2hlLlxuICovXG51c2VMb2FkZXIuY2xlYXIgPSBmdW5jdGlvbiAobG9hZGVyLCBpbnB1dCkge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIHJldHVybiBjbGVhcihbbG9hZGVyLCAuLi5rZXlzXSk7XG59O1xuXG4vLyBUT0RPOiB1cHN0cmVhbSB0byBEZWZpbml0ZWx5VHlwZWQgZm9yIFJlYWN0IDE5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzI4OTU2XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlY29uY2lsZXIoY29uZmlnKSB7XG4gIGNvbnN0IHJlY29uY2lsZXIgPSBSZWNvbmNpbGVyKGNvbmZpZyk7XG4gIHJlY29uY2lsZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgICBidW5kbGVUeXBlOiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IDEgOiAwLFxuICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdAcmVhY3QtdGhyZWUvZmliZXInLFxuICAgIHZlcnNpb246IFJlYWN0LnZlcnNpb25cbiAgfSk7XG4gIHJldHVybiByZWNvbmNpbGVyO1xufVxuY29uc3QgTm9FdmVudFByaW9yaXR5ID0gMDtcblxuLy8gVE9ETzogaGFuZGxlIGNvbnN0cnVjdG9yIG92ZXJsb2Fkc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzI5MzFcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzcwNzlcblxuY29uc3QgY2F0YWxvZ3VlID0ge307XG5jb25zdCBQUkVGSVhfUkVHRVggPSAvXnRocmVlKD89W0EtWl0pLztcbmNvbnN0IHRvUGFzY2FsQ2FzZSA9IHR5cGUgPT4gYCR7dHlwZVswXS50b1VwcGVyQ2FzZSgpfSR7dHlwZS5zbGljZSgxKX1gO1xubGV0IGkgPSAwO1xuY29uc3QgaXNDb25zdHJ1Y3RvciA9IG9iamVjdCA9PiB0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nO1xuZnVuY3Rpb24gZXh0ZW5kKG9iamVjdHMpIHtcbiAgaWYgKGlzQ29uc3RydWN0b3Iob2JqZWN0cykpIHtcbiAgICBjb25zdCBDb21wb25lbnQgPSBgJHtpKyt9YDtcbiAgICBjYXRhbG9ndWVbQ29tcG9uZW50XSA9IG9iamVjdHM7XG4gICAgcmV0dXJuIENvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuYXNzaWduKGNhdGFsb2d1ZSwgb2JqZWN0cyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSW5zdGFuY2UodHlwZSwgcHJvcHMpIHtcbiAgLy8gR2V0IHRhcmdldCBmcm9tIGNhdGFsb2d1ZVxuICBjb25zdCBuYW1lID0gdG9QYXNjYWxDYXNlKHR5cGUpO1xuICBjb25zdCB0YXJnZXQgPSBjYXRhbG9ndWVbbmFtZV07XG5cbiAgLy8gVmFsaWRhdGUgZWxlbWVudCB0YXJnZXRcbiAgaWYgKHR5cGUgIT09ICdwcmltaXRpdmUnICYmICF0YXJnZXQpIHRocm93IG5ldyBFcnJvcihgUjNGOiAke25hbWV9IGlzIG5vdCBwYXJ0IG9mIHRoZSBUSFJFRSBuYW1lc3BhY2UhIERpZCB5b3UgZm9yZ2V0IHRvIGV4dGVuZD8gU2VlOiBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvb2JqZWN0cyN1c2luZy0zcmQtcGFydHktb2JqZWN0cy1kZWNsYXJhdGl2ZWx5YCk7XG5cbiAgLy8gVmFsaWRhdGUgcHJpbWl0aXZlc1xuICBpZiAodHlwZSA9PT0gJ3ByaW1pdGl2ZScgJiYgIXByb3BzLm9iamVjdCkgdGhyb3cgbmV3IEVycm9yKGBSM0Y6IFByaW1pdGl2ZXMgd2l0aG91dCAnb2JqZWN0JyBhcmUgaW52YWxpZCFgKTtcblxuICAvLyBUaHJvdyBpZiBhbiBvYmplY3Qgb3IgbGl0ZXJhbCB3YXMgcGFzc2VkIGZvciBhcmdzXG4gIGlmIChwcm9wcy5hcmdzICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkocHJvcHMuYXJncykpIHRocm93IG5ldyBFcnJvcignUjNGOiBUaGUgYXJncyBwcm9wIG11c3QgYmUgYW4gYXJyYXkhJyk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh0eXBlLCBwcm9wcywgcm9vdCkge1xuICB2YXIgX3Byb3BzJG9iamVjdDtcbiAgLy8gUmVtb3ZlIHRocmVlKiBwcmVmaXggZnJvbSBlbGVtZW50cyBpZiBuYXRpdmUgZWxlbWVudCBub3QgcHJlc2VudFxuICB0eXBlID0gdG9QYXNjYWxDYXNlKHR5cGUpIGluIGNhdGFsb2d1ZSA/IHR5cGUgOiB0eXBlLnJlcGxhY2UoUFJFRklYX1JFR0VYLCAnJyk7XG4gIHZhbGlkYXRlSW5zdGFuY2UodHlwZSwgcHJvcHMpO1xuXG4gIC8vIFJlZ2VuZXJhdGUgdGhlIFIzRiBpbnN0YW5jZSBmb3IgcHJpbWl0aXZlcyB0byBzaW11bGF0ZSBhIG5ldyBvYmplY3RcbiAgaWYgKHR5cGUgPT09ICdwcmltaXRpdmUnICYmIChfcHJvcHMkb2JqZWN0ID0gcHJvcHMub2JqZWN0KSAhPSBudWxsICYmIF9wcm9wcyRvYmplY3QuX19yM2YpIGRlbGV0ZSBwcm9wcy5vYmplY3QuX19yM2Y7XG4gIHJldHVybiBwcmVwYXJlKHByb3BzLm9iamVjdCwgcm9vdCwgdHlwZSwgcHJvcHMpO1xufVxuZnVuY3Rpb24gaGlkZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIGlmICghaW5zdGFuY2UuaXNIaWRkZW4pIHtcbiAgICB2YXIgX2luc3RhbmNlJHBhcmVudDtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuYXR0YWNoICYmIChfaW5zdGFuY2UkcGFyZW50ID0gaW5zdGFuY2UucGFyZW50KSAhPSBudWxsICYmIF9pbnN0YW5jZSRwYXJlbnQub2JqZWN0KSB7XG4gICAgICBkZXRhY2goaW5zdGFuY2UucGFyZW50LCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdDNEKGluc3RhbmNlLm9iamVjdCkpIHtcbiAgICAgIGluc3RhbmNlLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGluc3RhbmNlLmlzSGlkZGVuID0gdHJ1ZTtcbiAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICB9XG59XG5mdW5jdGlvbiB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpZiAoaW5zdGFuY2UuaXNIaWRkZW4pIHtcbiAgICB2YXIgX2luc3RhbmNlJHBhcmVudDI7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmF0dGFjaCAmJiAoX2luc3RhbmNlJHBhcmVudDIgPSBpbnN0YW5jZS5wYXJlbnQpICE9IG51bGwgJiYgX2luc3RhbmNlJHBhcmVudDIub2JqZWN0KSB7XG4gICAgICBhdHRhY2goaW5zdGFuY2UucGFyZW50LCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdDNEKGluc3RhbmNlLm9iamVjdCkgJiYgaW5zdGFuY2UucHJvcHMudmlzaWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgIGluc3RhbmNlLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgaW5zdGFuY2UuaXNIaWRkZW4gPSBmYWxzZTtcbiAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICB9XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAyNzFcbi8vIFRoaXMgd2lsbCBtYWtlIHN1cmUgZXZlbnRzIGFuZCBhdHRhY2ggYXJlIG9ubHkgaGFuZGxlZCBvbmNlIHdoZW4gdHJlZXMgYXJlIGNvbXBsZXRlXG5mdW5jdGlvbiBoYW5kbGVDb250YWluZXJFZmZlY3RzKHBhcmVudCwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIC8vIEJhaWwgaWYgdHJlZSBpc24ndCBtb3VudGVkIG9yIHBhcmVudCBpcyBub3QgYSBjb250YWluZXIuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSB0cmVlIGlzIGZpbmFsaXplZCBhbmQgUmVhY3Qgd29uJ3QgZGlzY2FyZCByZXN1bHRzIHRvIFN1c3BlbnNlXG4gIGNvbnN0IHN0YXRlID0gY2hpbGQucm9vdC5nZXRTdGF0ZSgpO1xuICBpZiAoIXBhcmVudC5wYXJlbnQgJiYgcGFyZW50Lm9iamVjdCAhPT0gc3RhdGUuc2NlbmUpIHJldHVybjtcblxuICAvLyBDcmVhdGUgJiBsaW5rIG9iamVjdCBvbiBmaXJzdCBydW5cbiAgaWYgKCFjaGlsZC5vYmplY3QpIHtcbiAgICB2YXIgX2NoaWxkJHByb3BzJG9iamVjdCwgX2NoaWxkJHByb3BzJGFyZ3M7XG4gICAgLy8gR2V0IHRhcmdldCBmcm9tIGNhdGFsb2d1ZVxuICAgIGNvbnN0IHRhcmdldCA9IGNhdGFsb2d1ZVt0b1Bhc2NhbENhc2UoY2hpbGQudHlwZSldO1xuXG4gICAgLy8gQ3JlYXRlIG9iamVjdFxuICAgIGNoaWxkLm9iamVjdCA9IChfY2hpbGQkcHJvcHMkb2JqZWN0ID0gY2hpbGQucHJvcHMub2JqZWN0KSAhPSBudWxsID8gX2NoaWxkJHByb3BzJG9iamVjdCA6IG5ldyB0YXJnZXQoLi4uKChfY2hpbGQkcHJvcHMkYXJncyA9IGNoaWxkLnByb3BzLmFyZ3MpICE9IG51bGwgPyBfY2hpbGQkcHJvcHMkYXJncyA6IFtdKSk7XG4gICAgY2hpbGQub2JqZWN0Ll9fcjNmID0gY2hpbGQ7XG4gIH1cblxuICAvLyBTZXQgaW5pdGlhbCBwcm9wc1xuICBhcHBseVByb3BzKGNoaWxkLm9iamVjdCwgY2hpbGQucHJvcHMpO1xuXG4gIC8vIEFwcGVuZCBpbnN0YW5jZVxuICBpZiAoY2hpbGQucHJvcHMuYXR0YWNoKSB7XG4gICAgYXR0YWNoKHBhcmVudCwgY2hpbGQpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0M0QoY2hpbGQub2JqZWN0KSAmJiBpc09iamVjdDNEKHBhcmVudC5vYmplY3QpKSB7XG4gICAgY29uc3QgY2hpbGRJbmRleCA9IHBhcmVudC5vYmplY3QuY2hpbGRyZW4uaW5kZXhPZihiZWZvcmVDaGlsZCA9PSBudWxsID8gdm9pZCAwIDogYmVmb3JlQ2hpbGQub2JqZWN0KTtcbiAgICBpZiAoYmVmb3JlQ2hpbGQgJiYgY2hpbGRJbmRleCAhPT0gLTEpIHtcbiAgICAgIC8vIElmIHRoZSBjaGlsZCBpcyBhbHJlYWR5IGluIHRoZSBwYXJlbnQncyBjaGlsZHJlbiBhcnJheSwgbW92ZSBpdCB0byB0aGUgbmV3IHBvc2l0aW9uXG4gICAgICAvLyBPdGhlcndpc2UsIGp1c3QgaW5zZXJ0IGl0IGF0IHRoZSB0YXJnZXQgcG9zaXRpb25cbiAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBwYXJlbnQub2JqZWN0LmNoaWxkcmVuLmluZGV4T2YoY2hpbGQub2JqZWN0KTtcbiAgICAgIGlmIChleGlzdGluZ0luZGV4ICE9PSAtMSkge1xuICAgICAgICBwYXJlbnQub2JqZWN0LmNoaWxkcmVuLnNwbGljZShleGlzdGluZ0luZGV4LCAxKTtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRJbmRleCA9IGV4aXN0aW5nSW5kZXggPCBjaGlsZEluZGV4ID8gY2hpbGRJbmRleCAtIDEgOiBjaGlsZEluZGV4O1xuICAgICAgICBwYXJlbnQub2JqZWN0LmNoaWxkcmVuLnNwbGljZShhZGp1c3RlZEluZGV4LCAwLCBjaGlsZC5vYmplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQub2JqZWN0LnBhcmVudCA9IHBhcmVudC5vYmplY3Q7XG4gICAgICAgIHBhcmVudC5vYmplY3QuY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDAsIGNoaWxkLm9iamVjdCk7XG4gICAgICAgIGNoaWxkLm9iamVjdC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICB0eXBlOiAnYWRkZWQnXG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQub2JqZWN0LmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdjaGlsZGFkZGVkJyxcbiAgICAgICAgICBjaGlsZDogY2hpbGQub2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQub2JqZWN0LmFkZChjaGlsZC5vYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIC8vIExpbmsgc3VidHJlZVxuICBmb3IgKGNvbnN0IGNoaWxkSW5zdGFuY2Ugb2YgY2hpbGQuY2hpbGRyZW4pIGhhbmRsZUNvbnRhaW5lckVmZmVjdHMoY2hpbGQsIGNoaWxkSW5zdGFuY2UpO1xuXG4gIC8vIFRyZWUgd2FzIHVwZGF0ZWQsIHJlcXVlc3QgYSBmcmFtZVxuICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xufVxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50LCBjaGlsZCkge1xuICBpZiAoIWNoaWxkKSByZXR1cm47XG5cbiAgLy8gTGluayBpbnN0YW5jZXNcbiAgY2hpbGQucGFyZW50ID0gcGFyZW50O1xuICBwYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgLy8gQXR0YWNoIHRyZWUgb25jZSBjb21wbGV0ZVxuICBoYW5kbGVDb250YWluZXJFZmZlY3RzKHBhcmVudCwgY2hpbGQpO1xufVxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudCwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIGlmICghY2hpbGQgfHwgIWJlZm9yZUNoaWxkKSByZXR1cm47XG5cbiAgLy8gTGluayBpbnN0YW5jZXNcbiAgY2hpbGQucGFyZW50ID0gcGFyZW50O1xuICBjb25zdCBjaGlsZEluZGV4ID0gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YoYmVmb3JlQ2hpbGQpO1xuICBpZiAoY2hpbGRJbmRleCAhPT0gLTEpIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMCwgY2hpbGQpO2Vsc2UgcGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gIC8vIEF0dGFjaCB0cmVlIG9uY2UgY29tcGxldGVcbiAgaGFuZGxlQ29udGFpbmVyRWZmZWN0cyhwYXJlbnQsIGNoaWxkLCBiZWZvcmVDaGlsZCk7XG59XG5mdW5jdGlvbiBkaXNwb3NlT25JZGxlKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdC5kaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgaGFuZGxlRGlzcG9zZSA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9iamVjdC5kaXNwb3NlKCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gbm8tb3BcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW4gYSB0ZXN0aW5nIGVudmlyb25tZW50LCBjbGVhbnVwIGltbWVkaWF0ZWx5XG4gICAgaWYgKHR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgIT09ICd1bmRlZmluZWQnKSBoYW5kbGVEaXNwb3NlKCk7XG4gICAgLy8gT3RoZXJ3aXNlLCB1c2luZyBhIHJlYWwgR1BVIHNvIHNjaGVkdWxlIGNsZWFudXAgdG8gcHJldmVudCBzdGFsbHNcbiAgICBlbHNlIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sodW5zdGFibGVfSWRsZVByaW9yaXR5LCBoYW5kbGVEaXNwb3NlKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50LCBjaGlsZCwgZGlzcG9zZSkge1xuICBpZiAoIWNoaWxkKSByZXR1cm47XG5cbiAgLy8gVW5saW5rIGluc3RhbmNlc1xuICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICBjb25zdCBjaGlsZEluZGV4ID0gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICBpZiAoY2hpbGRJbmRleCAhPT0gLTEpIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMSk7XG5cbiAgLy8gRWFnZXJseSB0ZWFyIGRvd24gdHJlZVxuICBpZiAoY2hpbGQucHJvcHMuYXR0YWNoKSB7XG4gICAgZGV0YWNoKHBhcmVudCwgY2hpbGQpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0M0QoY2hpbGQub2JqZWN0KSAmJiBpc09iamVjdDNEKHBhcmVudC5vYmplY3QpKSB7XG4gICAgcGFyZW50Lm9iamVjdC5yZW1vdmUoY2hpbGQub2JqZWN0KTtcbiAgICByZW1vdmVJbnRlcmFjdGl2aXR5KGZpbmRJbml0aWFsUm9vdChjaGlsZCksIGNoaWxkLm9iamVjdCk7XG4gIH1cblxuICAvLyBBbGxvdyBvYmplY3RzIHRvIGJhaWwgb3V0IG9mIHVubW91bnQgZGlzcG9zYWwgd2l0aCBkaXNwb3NlPXtudWxsfVxuICBjb25zdCBzaG91bGREaXNwb3NlID0gY2hpbGQucHJvcHMuZGlzcG9zZSAhPT0gbnVsbCAmJiBkaXNwb3NlICE9PSBmYWxzZTtcblxuICAvLyBSZWN1cnNpdmVseSByZW1vdmUgaW5zdGFuY2UgY2hpbGRyZW5cbiAgZm9yIChsZXQgaSA9IGNoaWxkLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgbm9kZSA9IGNoaWxkLmNoaWxkcmVuW2ldO1xuICAgIHJlbW92ZUNoaWxkKGNoaWxkLCBub2RlLCBzaG91bGREaXNwb3NlKTtcbiAgfVxuICBjaGlsZC5jaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gIC8vIFVubGluayBpbnN0YW5jZSBvYmplY3RcbiAgZGVsZXRlIGNoaWxkLm9iamVjdC5fX3IzZjtcblxuICAvLyBEaXNwb3NlIG9iamVjdCB3aGVuZXZlciB0aGUgcmVjb25jaWxlciBmZWVscyBsaWtlIGl0LlxuICAvLyBOZXZlciBkaXNwb3NlIG9mIHByaW1pdGl2ZXMgYmVjYXVzZSB0aGVpciBzdGF0ZSBtYXkgYmUga2VwdCBvdXRzaWRlIG9mIFJlYWN0IVxuICAvLyBJbiBvcmRlciBmb3IgYW4gb2JqZWN0IHRvIGJlIGFibGUgdG8gZGlzcG9zZSBpdFxuICAvLyAgIC0gaGFzIGEgZGlzcG9zZSBtZXRob2RcbiAgLy8gICAtIGNhbm5vdCBiZSBhIDxwcmltaXRpdmUgb2JqZWN0PXsuLi59IC8+XG4gIC8vICAgLSBjYW5ub3QgYmUgYSBUSFJFRS5TY2VuZSwgYmVjYXVzZSB0aHJlZSBoYXMgYnJva2VuIGl0cyBvd24gQVBJXG4gIGlmIChzaG91bGREaXNwb3NlICYmIGNoaWxkLnR5cGUgIT09ICdwcmltaXRpdmUnICYmIGNoaWxkLm9iamVjdC50eXBlICE9PSAnU2NlbmUnKSB7XG4gICAgZGlzcG9zZU9uSWRsZShjaGlsZC5vYmplY3QpO1xuICB9XG5cbiAgLy8gVHJlZSB3YXMgdXBkYXRlZCwgcmVxdWVzdCBhIGZyYW1lIGZvciB0b3AtbGV2ZWwgaW5zdGFuY2VcbiAgaWYgKGRpc3Bvc2UgPT09IHVuZGVmaW5lZCkgaW52YWxpZGF0ZUluc3RhbmNlKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIHNldEZpYmVyUmVmKGZpYmVyLCBwdWJsaWNJbnN0YW5jZSkge1xuICBmb3IgKGNvbnN0IF9maWJlciBvZiBbZmliZXIsIGZpYmVyLmFsdGVybmF0ZV0pIHtcbiAgICBpZiAoX2ZpYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIF9maWJlci5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgX2ZpYmVyLnJlZkNsZWFudXAgPT0gbnVsbCA/IHZvaWQgMCA6IF9maWJlci5yZWZDbGVhbnVwKCk7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBfZmliZXIucmVmKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhbnVwID09PSAnZnVuY3Rpb24nKSBfZmliZXIucmVmQ2xlYW51cCA9IGNsZWFudXA7XG4gICAgICB9IGVsc2UgaWYgKF9maWJlci5yZWYpIHtcbiAgICAgICAgX2ZpYmVyLnJlZi5jdXJyZW50ID0gcHVibGljSW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCByZWNvbnN0cnVjdGVkID0gW107XG5mdW5jdGlvbiBzd2FwSW5zdGFuY2VzKCkge1xuICAvLyBEZXRhY2ggaW5zdGFuY2VcbiAgZm9yIChjb25zdCBbaW5zdGFuY2VdIG9mIHJlY29uc3RydWN0ZWQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmF0dGFjaCkge1xuICAgICAgICBkZXRhY2gocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0M0QoaW5zdGFuY2Uub2JqZWN0KSAmJiBpc09iamVjdDNEKHBhcmVudC5vYmplY3QpKSB7XG4gICAgICAgIHBhcmVudC5vYmplY3QucmVtb3ZlKGluc3RhbmNlLm9iamVjdCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC5wcm9wcy5hdHRhY2gpIHtcbiAgICAgICAgICBkZXRhY2goaW5zdGFuY2UsIGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdDNEKGNoaWxkLm9iamVjdCkgJiYgaXNPYmplY3QzRChpbnN0YW5jZS5vYmplY3QpKSB7XG4gICAgICAgICAgaW5zdGFuY2Uub2JqZWN0LnJlbW92ZShjaGlsZC5vYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9sZCBpbnN0YW5jZSBpcyBoaWRkZW4sIHdlIG5lZWQgdG8gdW5oaWRlIGl0LlxuICAgIC8vIFJlYWN0IGFzc3VtZXMgaXQgY2FuIGRpc2NhcmQgaW5zdGFuY2VzIHNpbmNlIHRoZXkncmUgcHVyZSBmb3IgRE9NLlxuICAgIC8vIFRoaXMgaXNuJ3QgdHJ1ZSBmb3IgdXMgc2luY2Ugb3VyIGxpZmV0aW1lcyBhcmUgaW1wdXJlIGFuZCBsb25nbGl2aW5nLlxuICAgIC8vIFNvLCB3ZSBtYW51YWxseSBjaGVjayBpZiBhbiBpbnN0YW5jZSB3YXMgaGlkZGVuIGFuZCB1bmhpZGUgaXQuXG4gICAgaWYgKGluc3RhbmNlLmlzSGlkZGVuKSB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSk7XG5cbiAgICAvLyBEaXNwb3NlIG9mIG9sZCBvYmplY3QgaWYgYWJsZVxuICAgIGlmIChpbnN0YW5jZS5vYmplY3QuX19yM2YpIGRlbGV0ZSBpbnN0YW5jZS5vYmplY3QuX19yM2Y7XG4gICAgaWYgKGluc3RhbmNlLnR5cGUgIT09ICdwcmltaXRpdmUnKSBkaXNwb3NlT25JZGxlKGluc3RhbmNlLm9iamVjdCk7XG4gIH1cblxuICAvLyBVcGRhdGUgaW5zdGFuY2VcbiAgZm9yIChjb25zdCBbaW5zdGFuY2UsIHByb3BzLCBmaWJlcl0gb2YgcmVjb25zdHJ1Y3RlZCkge1xuICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XG4gICAgY29uc3QgcGFyZW50ID0gaW5zdGFuY2UucGFyZW50O1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkcHJvcHMkb2JqZWMsIF9pbnN0YW5jZSRwcm9wcyRhcmdzO1xuICAgICAgLy8gR2V0IHRhcmdldCBmcm9tIGNhdGFsb2d1ZVxuICAgICAgY29uc3QgdGFyZ2V0ID0gY2F0YWxvZ3VlW3RvUGFzY2FsQ2FzZShpbnN0YW5jZS50eXBlKV07XG5cbiAgICAgIC8vIENyZWF0ZSBvYmplY3RcbiAgICAgIGluc3RhbmNlLm9iamVjdCA9IChfaW5zdGFuY2UkcHJvcHMkb2JqZWMgPSBpbnN0YW5jZS5wcm9wcy5vYmplY3QpICE9IG51bGwgPyBfaW5zdGFuY2UkcHJvcHMkb2JqZWMgOiBuZXcgdGFyZ2V0KC4uLigoX2luc3RhbmNlJHByb3BzJGFyZ3MgPSBpbnN0YW5jZS5wcm9wcy5hcmdzKSAhPSBudWxsID8gX2luc3RhbmNlJHByb3BzJGFyZ3MgOiBbXSkpO1xuICAgICAgaW5zdGFuY2Uub2JqZWN0Ll9fcjNmID0gaW5zdGFuY2U7XG4gICAgICBzZXRGaWJlclJlZihmaWJlciwgaW5zdGFuY2Uub2JqZWN0KTtcblxuICAgICAgLy8gU2V0IGluaXRpYWwgcHJvcHNcbiAgICAgIGFwcGx5UHJvcHMoaW5zdGFuY2Uub2JqZWN0LCBpbnN0YW5jZS5wcm9wcyk7XG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuYXR0YWNoKSB7XG4gICAgICAgIGF0dGFjaChwYXJlbnQsIGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QzRChpbnN0YW5jZS5vYmplY3QpICYmIGlzT2JqZWN0M0QocGFyZW50Lm9iamVjdCkpIHtcbiAgICAgICAgcGFyZW50Lm9iamVjdC5hZGQoaW5zdGFuY2Uub2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaW5zdGFuY2UuY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkLnByb3BzLmF0dGFjaCkge1xuICAgICAgICAgIGF0dGFjaChpbnN0YW5jZSwgY2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0M0QoY2hpbGQub2JqZWN0KSAmJiBpc09iamVjdDNEKGluc3RhbmNlLm9iamVjdCkpIHtcbiAgICAgICAgICBpbnN0YW5jZS5vYmplY3QuYWRkKGNoaWxkLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVHJlZSB3YXMgdXBkYXRlZCwgcmVxdWVzdCBhIGZyYW1lXG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICByZWNvbnN0cnVjdGVkLmxlbmd0aCA9IDA7XG59XG5cbi8vIERvbid0IGhhbmRsZSB0ZXh0IGluc3RhbmNlcywgbWFrZSBpdCBuby1vcFxuY29uc3QgaGFuZGxlVGV4dEluc3RhbmNlID0gKCkgPT4ge307XG5jb25zdCBOT19DT05URVhUID0ge307XG5sZXQgY3VycmVudFVwZGF0ZVByaW9yaXR5ID0gTm9FdmVudFByaW9yaXR5O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYWluL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJGbGFncy5qc1xuY29uc3QgTm9GbGFncyA9IDA7XG5jb25zdCBVcGRhdGUgPSA0O1xuY29uc3QgcmVjb25jaWxlciA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZVJlY29uY2lsZXIoe1xuICBpc1ByaW1hcnlSZW5kZXJlcjogZmFsc2UsXG4gIHdhcm5zSWZOb3RBY3Rpbmc6IGZhbHNlLFxuICBzdXBwb3J0c011dGF0aW9uOiB0cnVlLFxuICBzdXBwb3J0c1BlcnNpc3RlbmNlOiBmYWxzZSxcbiAgc3VwcG9ydHNIeWRyYXRpb246IGZhbHNlLFxuICBjcmVhdGVJbnN0YW5jZSxcbiAgcmVtb3ZlQ2hpbGQsXG4gIGFwcGVuZENoaWxkLFxuICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBpbnNlcnRCZWZvcmUsXG4gIGFwcGVuZENoaWxkVG9Db250YWluZXIoY29udGFpbmVyLCBjaGlsZCkge1xuICAgIGNvbnN0IHNjZW5lID0gY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUuX19yM2Y7XG4gICAgaWYgKCFjaGlsZCB8fCAhc2NlbmUpIHJldHVybjtcbiAgICBhcHBlbmRDaGlsZChzY2VuZSwgY2hpbGQpO1xuICB9LFxuICByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY29udGFpbmVyLCBjaGlsZCkge1xuICAgIGNvbnN0IHNjZW5lID0gY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUuX19yM2Y7XG4gICAgaWYgKCFjaGlsZCB8fCAhc2NlbmUpIHJldHVybjtcbiAgICByZW1vdmVDaGlsZChzY2VuZSwgY2hpbGQpO1xuICB9LFxuICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgIGNvbnN0IHNjZW5lID0gY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUuX19yM2Y7XG4gICAgaWYgKCFjaGlsZCB8fCAhYmVmb3JlQ2hpbGQgfHwgIXNjZW5lKSByZXR1cm47XG4gICAgaW5zZXJ0QmVmb3JlKHNjZW5lLCBjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICB9LFxuICBnZXRSb290SG9zdENvbnRleHQ6ICgpID0+IE5PX0NPTlRFWFQsXG4gIGdldENoaWxkSG9zdENvbnRleHQ6ICgpID0+IE5PX0NPTlRFWFQsXG4gIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBmaWJlcikge1xuICAgIHZhciBfbmV3UHJvcHMkYXJncywgX29sZFByb3BzJGFyZ3MsIF9uZXdQcm9wcyRhcmdzMjtcbiAgICB2YWxpZGF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzKTtcbiAgICBsZXQgcmVjb25zdHJ1Y3QgPSBmYWxzZTtcblxuICAgIC8vIFJlY29uc3RydWN0IHByaW1pdGl2ZXMgaWYgb2JqZWN0IHByb3AgY2hhbmdlc1xuICAgIGlmIChpbnN0YW5jZS50eXBlID09PSAncHJpbWl0aXZlJyAmJiBvbGRQcm9wcy5vYmplY3QgIT09IG5ld1Byb3BzLm9iamVjdCkgcmVjb25zdHJ1Y3QgPSB0cnVlO1xuICAgIC8vIFJlY29uc3RydWN0IGluc3RhbmNlIGlmIGFyZ3Mgd2VyZSBhZGRlZCBvciByZW1vdmVkXG4gICAgZWxzZSBpZiAoKChfbmV3UHJvcHMkYXJncyA9IG5ld1Byb3BzLmFyZ3MpID09IG51bGwgPyB2b2lkIDAgOiBfbmV3UHJvcHMkYXJncy5sZW5ndGgpICE9PSAoKF9vbGRQcm9wcyRhcmdzID0gb2xkUHJvcHMuYXJncykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vbGRQcm9wcyRhcmdzLmxlbmd0aCkpIHJlY29uc3RydWN0ID0gdHJ1ZTtcbiAgICAvLyBSZWNvbnN0cnVjdCBpbnN0YW5jZSBpZiBhcmdzIHdlcmUgY2hhbmdlZFxuICAgIGVsc2UgaWYgKChfbmV3UHJvcHMkYXJnczIgPSBuZXdQcm9wcy5hcmdzKSAhPSBudWxsICYmIF9uZXdQcm9wcyRhcmdzMi5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIHZhciBfb2xkUHJvcHMkYXJnczI7XG4gICAgICByZXR1cm4gdmFsdWUgIT09ICgoX29sZFByb3BzJGFyZ3MyID0gb2xkUHJvcHMuYXJncykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vbGRQcm9wcyRhcmdzMltpbmRleF0pO1xuICAgIH0pKSByZWNvbnN0cnVjdCA9IHRydWU7XG5cbiAgICAvLyBSZWNvbnN0cnVjdCB3aGVuIGFyZ3Mgb3IgPHByaW1pdGl2ZSBvYmplY3Q9ey4uLn0gaGF2ZSBjaGFuZ2VzXG4gICAgaWYgKHJlY29uc3RydWN0KSB7XG4gICAgICByZWNvbnN0cnVjdGVkLnB1c2goW2luc3RhbmNlLCB7XG4gICAgICAgIC4uLm5ld1Byb3BzXG4gICAgICB9LCBmaWJlcl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSBkaWZmLXNldCwgZmxhZyBpZiB0aGVyZSBhcmUgYW55IGNoYW5nZXNcbiAgICAgIGNvbnN0IGNoYW5nZWRQcm9wcyA9IGRpZmZQcm9wcyhpbnN0YW5jZSwgbmV3UHJvcHMpO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGNoYW5nZWRQcm9wcykubGVuZ3RoKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UucHJvcHMsIGNoYW5nZWRQcm9wcyk7XG4gICAgICAgIGFwcGx5UHJvcHMoaW5zdGFuY2Uub2JqZWN0LCBjaGFuZ2VkUHJvcHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZsdXNoIHJlY29uc3RydWN0ZWQgc2libGluZ3Mgd2hlbiB3ZSBoaXQgdGhlIGxhc3QgdXBkYXRlZCBjaGlsZCBpbiBhIHNlcXVlbmNlXG4gICAgY29uc3QgaXNUYWlsU2libGluZyA9IGZpYmVyLnNpYmxpbmcgPT09IG51bGwgfHwgKGZpYmVyLmZsYWdzICYgVXBkYXRlKSA9PT0gTm9GbGFncztcbiAgICBpZiAoaXNUYWlsU2libGluZykgc3dhcEluc3RhbmNlcygpO1xuICB9LFxuICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjogKCkgPT4gZmFsc2UsXG4gIGNvbW1pdE1vdW50KCkge30sXG4gIGdldFB1YmxpY0luc3RhbmNlOiBpbnN0YW5jZSA9PiBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2Uub2JqZWN0LFxuICBwcmVwYXJlRm9yQ29tbWl0OiAoKSA9PiBudWxsLFxuICBwcmVwYXJlUG9ydGFsTW91bnQ6IGNvbnRhaW5lciA9PiBwcmVwYXJlKGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lLCBjb250YWluZXIsICcnLCB7fSksXG4gIHJlc2V0QWZ0ZXJDb21taXQ6ICgpID0+IHt9LFxuICBzaG91bGRTZXRUZXh0Q29udGVudDogKCkgPT4gZmFsc2UsXG4gIGNsZWFyQ29udGFpbmVyOiAoKSA9PiBmYWxzZSxcbiAgaGlkZUluc3RhbmNlLFxuICB1bmhpZGVJbnN0YW5jZSxcbiAgY3JlYXRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gIGhpZGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgdW5oaWRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gIHNjaGVkdWxlVGltZW91dDogdHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogdW5kZWZpbmVkLFxuICBjYW5jZWxUaW1lb3V0OiB0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gY2xlYXJUaW1lb3V0IDogdW5kZWZpbmVkLFxuICBub1RpbWVvdXQ6IC0xLFxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiAoKSA9PiBudWxsLFxuICBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIoKSB7fSxcbiAgYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIoKSB7fSxcbiAgZGV0YWNoRGVsZXRlZEluc3RhbmNlKCkge30sXG4gIHByZXBhcmVTY29wZVVwZGF0ZSgpIHt9LFxuICBnZXRJbnN0YW5jZUZyb21TY29wZTogKCkgPT4gbnVsbCxcbiAgc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbjogKCkgPT4gZmFsc2UsXG4gIHRyYWNrU2NoZWR1bGVyRXZlbnQ6ICgpID0+IHt9LFxuICByZXNvbHZlRXZlbnRUeXBlOiAoKSA9PiBudWxsLFxuICByZXNvbHZlRXZlbnRUaW1lU3RhbXA6ICgpID0+IC0xLjEsXG4gIHJlcXVlc3RQb3N0UGFpbnRDYWxsYmFjaygpIHt9LFxuICBtYXlTdXNwZW5kQ29tbWl0OiAoKSA9PiBmYWxzZSxcbiAgcHJlbG9hZEluc3RhbmNlOiAoKSA9PiB0cnVlLFxuICAvLyB0cnVlIGluZGljYXRlcyBhbHJlYWR5IGxvYWRlZFxuICBzdGFydFN1c3BlbmRpbmdDb21taXQoKSB7fSxcbiAgc3VzcGVuZEluc3RhbmNlKCkge30sXG4gIHdhaXRGb3JDb21taXRUb0JlUmVhZHk6ICgpID0+IG51bGwsXG4gIE5vdFBlbmRpbmdUcmFuc2l0aW9uOiBudWxsLFxuICBIb3N0VHJhbnNpdGlvbkNvbnRleHQ6IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCksXG4gIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShuZXdQcmlvcml0eSkge1xuICAgIGN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IG5ld1ByaW9yaXR5O1xuICB9LFxuICBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbiAgfSxcbiAgcmVzb2x2ZVVwZGF0ZVByaW9yaXR5KCkge1xuICAgIHZhciBfd2luZG93JGV2ZW50O1xuICAgIGlmIChjdXJyZW50VXBkYXRlUHJpb3JpdHkgIT09IE5vRXZlbnRQcmlvcml0eSkgcmV0dXJuIGN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbiAgICBzd2l0Y2ggKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgoX3dpbmRvdyRldmVudCA9IHdpbmRvdy5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckZXZlbnQudHlwZSkpIHtcbiAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICAgIGNhc2UgJ2RibGNsaWNrJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgICAgY2FzZSAncG9pbnRlcmRvd24nOlxuICAgICAgY2FzZSAncG9pbnRlcnVwJzpcbiAgICAgICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgICAgIGNhc2UgJ3BvaW50ZXJtb3ZlJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgICAgY2FzZSAncG9pbnRlcm92ZXInOlxuICAgICAgY2FzZSAncG9pbnRlcmVudGVyJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJsZWF2ZSc6XG4gICAgICBjYXNlICd3aGVlbCc6XG4gICAgICAgIHJldHVybiBDb250aW51b3VzRXZlbnRQcmlvcml0eTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgICB9XG4gIH0sXG4gIHJlc2V0Rm9ybUluc3RhbmNlKCkge31cbn0pO1xuXG5jb25zdCBfcm9vdHMgPSBuZXcgTWFwKCk7XG5jb25zdCBzaGFsbG93TG9vc2UgPSB7XG4gIG9iamVjdHM6ICdzaGFsbG93JyxcbiAgc3RyaWN0OiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIHNpemUpIHtcbiAgaWYgKCFzaXplICYmIHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgJiYgY2FudmFzLnBhcmVudEVsZW1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnRcbiAgICB9ID0gY2FudmFzLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdFxuICAgIH07XG4gIH0gZWxzZSBpZiAoIXNpemUgJiYgdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5zaXplXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSb290KGNhbnZhcykge1xuICAvLyBDaGVjayBhZ2FpbnN0IG1pc3Rha2VuIHVzZSBvZiBjcmVhdGVSb290XG4gIGNvbnN0IHByZXZSb290ID0gX3Jvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBwcmV2RmliZXIgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3QuZmliZXI7XG4gIGNvbnN0IHByZXZTdG9yZSA9IHByZXZSb290ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Um9vdC5zdG9yZTtcbiAgaWYgKHByZXZSb290KSBjb25zb2xlLndhcm4oJ1IzRi5jcmVhdGVSb290IHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIScpO1xuXG4gIC8vIFJlcG9ydCB3aGVuIGFuIGVycm9yIHdhcyBkZXRlY3RlZCBpbiBhIHByZXZpb3VzIHJlbmRlclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjI2MVxuICBjb25zdCBsb2dSZWNvdmVyYWJsZUVycm9yID0gdHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nID9cbiAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCByZXBvcnRFcnJvciB3aWxsIGRpc3BhdGNoIGFuIGVycm9yIGV2ZW50LFxuICAvLyBlbXVsYXRpbmcgYW4gdW5jYXVnaHQgSmF2YVNjcmlwdCBlcnJvci5cbiAgcmVwb3J0RXJyb3IgOlxuICAvLyBJbiBvbGRlciBicm93c2VycyBhbmQgdGVzdCBlbnZpcm9ubWVudHMsIGZhbGxiYWNrIHRvIGNvbnNvbGUuZXJyb3IuXG4gIGNvbnNvbGUuZXJyb3I7XG5cbiAgLy8gQ3JlYXRlIHN0b3JlXG4gIGNvbnN0IHN0b3JlID0gcHJldlN0b3JlIHx8IGNyZWF0ZVN0b3JlKGludmFsaWRhdGUsIGFkdmFuY2UpO1xuICAvLyBDcmVhdGUgcmVuZGVyZXJcbiAgY29uc3QgZmliZXIgPSBwcmV2RmliZXIgfHwgcmVjb25jaWxlci5jcmVhdGVDb250YWluZXIoc3RvcmUsXG4gIC8vIGNvbnRhaW5lclxuICBDb25jdXJyZW50Um9vdCxcbiAgLy8gdGFnXG4gIG51bGwsXG4gIC8vIGh5ZHJhdGlvbiBjYWxsYmFja3NcbiAgZmFsc2UsXG4gIC8vIGlzU3RyaWN0TW9kZVxuICBudWxsLFxuICAvLyBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlXG4gICcnLFxuICAvLyBpZGVudGlmaWVyUHJlZml4XG4gIGxvZ1JlY292ZXJhYmxlRXJyb3IsXG4gIC8vIG9uVW5jYXVnaHRFcnJvclxuICBsb2dSZWNvdmVyYWJsZUVycm9yLFxuICAvLyBvbkNhdWdodEVycm9yXG4gIGxvZ1JlY292ZXJhYmxlRXJyb3IsXG4gIC8vIG9uUmVjb3ZlcmFibGVFcnJvclxuICBudWxsIC8vIHRyYW5zaXRpb25DYWxsYmFja3NcbiAgKTtcbiAgLy8gTWFwIGl0XG4gIGlmICghcHJldlJvb3QpIF9yb290cy5zZXQoY2FudmFzLCB7XG4gICAgZmliZXIsXG4gICAgc3RvcmVcbiAgfSk7XG5cbiAgLy8gTG9jYWxzXG4gIGxldCBvbkNyZWF0ZWQ7XG4gIGxldCBsYXN0Q2FtZXJhO1xuICBsZXQgY29uZmlndXJlZCA9IGZhbHNlO1xuICBsZXQgcGVuZGluZyA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgYXN5bmMgY29uZmlndXJlKHByb3BzID0ge30pIHtcbiAgICAgIGxldCByZXNvbHZlO1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKF9yZXNvbHZlID0+IHJlc29sdmUgPSBfcmVzb2x2ZSk7XG4gICAgICBsZXQge1xuICAgICAgICBnbDogZ2xDb25maWcsXG4gICAgICAgIHNpemU6IHByb3BzU2l6ZSxcbiAgICAgICAgc2NlbmU6IHNjZW5lT3B0aW9ucyxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZENhbGxiYWNrLFxuICAgICAgICBzaGFkb3dzID0gZmFsc2UsXG4gICAgICAgIGxpbmVhciA9IGZhbHNlLFxuICAgICAgICBmbGF0ID0gZmFsc2UsXG4gICAgICAgIGxlZ2FjeSA9IGZhbHNlLFxuICAgICAgICBvcnRob2dyYXBoaWMgPSBmYWxzZSxcbiAgICAgICAgZnJhbWVsb29wID0gJ2Fsd2F5cycsXG4gICAgICAgIGRwciA9IFsxLCAyXSxcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcjogcmF5Y2FzdE9wdGlvbnMsXG4gICAgICAgIGNhbWVyYTogY2FtZXJhT3B0aW9ucyxcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkXG4gICAgICB9ID0gcHJvcHM7XG4gICAgICBsZXQgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBTZXQgdXAgcmVuZGVyZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IGdsID0gc3RhdGUuZ2w7XG4gICAgICBpZiAoIXN0YXRlLmdsKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgICAgICBwb3dlclByZWZlcmVuY2U6ICdoaWdoLXBlcmZvcm1hbmNlJyxcbiAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAgICAgYWxwaGE6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3VzdG9tUmVuZGVyZXIgPSB0eXBlb2YgZ2xDb25maWcgPT09ICdmdW5jdGlvbicgPyBhd2FpdCBnbENvbmZpZyhkZWZhdWx0UHJvcHMpIDogZ2xDb25maWc7XG4gICAgICAgIGlmIChpc1JlbmRlcmVyKGN1c3RvbVJlbmRlcmVyKSkge1xuICAgICAgICAgIGdsID0gY3VzdG9tUmVuZGVyZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2wgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgICAgICAuLi5nbENvbmZpZ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgZ2xcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCByYXljYXN0ZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IHJheWNhc3RlciA9IHN0YXRlLnJheWNhc3RlcjtcbiAgICAgIGlmICghcmF5Y2FzdGVyKSBzdGF0ZS5zZXQoe1xuICAgICAgICByYXljYXN0ZXI6IHJheWNhc3RlciA9IG5ldyBUSFJFRS5SYXljYXN0ZXIoKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCByYXljYXN0ZXIgb3B0aW9uc1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0gPSByYXljYXN0T3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmICghaXMuZXF1KG9wdGlvbnMsIHJheWNhc3Rlciwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhyYXljYXN0ZXIsIHtcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBpZiAoIWlzLmVxdShwYXJhbXMsIHJheWNhc3Rlci5wYXJhbXMsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIC4uLnJheWNhc3Rlci5wYXJhbXMsXG4gICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgZGVmYXVsdCBjYW1lcmEsIGRvbid0IG92ZXJ3cml0ZSBhbnkgdXNlci1zZXQgc3RhdGVcbiAgICAgIGlmICghc3RhdGUuY2FtZXJhIHx8IHN0YXRlLmNhbWVyYSA9PT0gbGFzdENhbWVyYSAmJiAhaXMuZXF1KGxhc3RDYW1lcmEsIGNhbWVyYU9wdGlvbnMsIHNoYWxsb3dMb29zZSkpIHtcbiAgICAgICAgbGFzdENhbWVyYSA9IGNhbWVyYU9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGlzQ2FtZXJhID0gY2FtZXJhT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY2FtZXJhT3B0aW9ucy5pc0NhbWVyYTtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gaXNDYW1lcmEgPyBjYW1lcmFPcHRpb25zIDogb3J0aG9ncmFwaGljID8gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgwLCAwLCAwLCAwLCAwLjEsIDEwMDApIDogbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCAwLCAwLjEsIDEwMDApO1xuICAgICAgICBpZiAoIWlzQ2FtZXJhKSB7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnogPSA1O1xuICAgICAgICAgIGlmIChjYW1lcmFPcHRpb25zKSB7XG4gICAgICAgICAgICBhcHBseVByb3BzKGNhbWVyYSwgY2FtZXJhT3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSB1c2VyLWRlZmluZWQgZnJ1c3R1bSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzE2MFxuICAgICAgICAgICAgaWYgKCFjYW1lcmEubWFudWFsKSB7XG4gICAgICAgICAgICAgIGlmICgnYXNwZWN0JyBpbiBjYW1lcmFPcHRpb25zIHx8ICdsZWZ0JyBpbiBjYW1lcmFPcHRpb25zIHx8ICdyaWdodCcgaW4gY2FtZXJhT3B0aW9ucyB8fCAnYm90dG9tJyBpbiBjYW1lcmFPcHRpb25zIHx8ICd0b3AnIGluIGNhbWVyYU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjYW1lcmEubWFudWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFsd2F5cyBsb29rIGF0IGNlbnRlciBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKCFzdGF0ZS5jYW1lcmEgJiYgIShjYW1lcmFPcHRpb25zICE9IG51bGwgJiYgY2FtZXJhT3B0aW9ucy5yb3RhdGlvbikpIGNhbWVyYS5sb29rQXQoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBjYW1lcmFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHJheWNhc3RlclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXhyL2lzc3Vlcy8zMDBcbiAgICAgICAgcmF5Y2FzdGVyLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIHNjZW5lIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUuc2NlbmUpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBpZiAoc2NlbmVPcHRpb25zICE9IG51bGwgJiYgc2NlbmVPcHRpb25zLmlzU2NlbmUpIHtcbiAgICAgICAgICBzY2VuZSA9IHNjZW5lT3B0aW9ucztcbiAgICAgICAgICBwcmVwYXJlKHNjZW5lLCBzdG9yZSwgJycsIHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgICAgIHByZXBhcmUoc2NlbmUsIHN0b3JlLCAnJywge30pO1xuICAgICAgICAgIGlmIChzY2VuZU9wdGlvbnMpIGFwcGx5UHJvcHMoc2NlbmUsIHNjZW5lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBzY2VuZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgZXZlbnRzIGludGVybmFsbHlcbiAgICAgIGlmIChldmVudHMgJiYgIXN0YXRlLmV2ZW50cy5oYW5kbGVycykgc3RhdGUuc2V0KHtcbiAgICAgICAgZXZlbnRzOiBldmVudHMoc3RvcmUpXG4gICAgICB9KTtcbiAgICAgIC8vIENoZWNrIHNpemUsIGFsbG93IGl0IHRvIHRha2Ugb24gY29udGFpbmVyIGJvdW5kcyBpbml0aWFsbHlcbiAgICAgIGNvbnN0IHNpemUgPSBjb21wdXRlSW5pdGlhbFNpemUoY2FudmFzLCBwcm9wc1NpemUpO1xuICAgICAgaWYgKCFpcy5lcXUoc2l6ZSwgc3RhdGUuc2l6ZSwgc2hhbGxvd0xvb3NlKSkge1xuICAgICAgICBzdGF0ZS5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCBzaXplLnRvcCwgc2l6ZS5sZWZ0KTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHBpeGVscmF0aW9cbiAgICAgIGlmIChkcHIgJiYgc3RhdGUudmlld3BvcnQuZHByICE9PSBjYWxjdWxhdGVEcHIoZHByKSkgc3RhdGUuc2V0RHByKGRwcik7XG4gICAgICAvLyBDaGVjayBmcmFtZWxvb3BcbiAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgIT09IGZyYW1lbG9vcCkgc3RhdGUuc2V0RnJhbWVsb29wKGZyYW1lbG9vcCk7XG4gICAgICAvLyBDaGVjayBwb2ludGVyIG1pc3NlZFxuICAgICAgaWYgKCFzdGF0ZS5vblBvaW50ZXJNaXNzZWQpIHN0YXRlLnNldCh7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZFxuICAgICAgfSk7XG4gICAgICAvLyBDaGVjayBwZXJmb3JtYW5jZVxuICAgICAgaWYgKHBlcmZvcm1hbmNlICYmICFpcy5lcXUocGVyZm9ybWFuY2UsIHN0YXRlLnBlcmZvcm1hbmNlLCBzaGFsbG93TG9vc2UpKSBzdGF0ZS5zZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgICAuLi5wZXJmb3JtYW5jZVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCB1cCBYUiAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnhyKSB7XG4gICAgICAgIHZhciBfZ2wkeHI7XG4gICAgICAgIC8vIEhhbmRsZSBmcmFtZSBiZWhhdmlvciBpbiBXZWJYUlxuICAgICAgICBjb25zdCBoYW5kbGVYUkZyYW1lID0gKHRpbWVzdGFtcCwgZnJhbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJykgcmV0dXJuO1xuICAgICAgICAgIGFkdmFuY2UodGltZXN0YW1wLCB0cnVlLCBzdGF0ZSwgZnJhbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvZ2dsZSByZW5kZXIgc3dpdGNoaW5nIG9uIHNlc3Npb25cbiAgICAgICAgY29uc3QgaGFuZGxlU2Vzc2lvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuZW5hYmxlZCA9IHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZztcbiAgICAgICAgICBzdGF0ZS5nbC54ci5zZXRBbmltYXRpb25Mb29wKHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZyA/IGhhbmRsZVhSRnJhbWUgOiBudWxsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmdsLnhyLmlzUHJlc2VudGluZykgaW52YWxpZGF0ZShzdGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV2ViWFIgc2Vzc2lvbiBtYW5hZ2VyXG4gICAgICAgIGNvbnN0IHhyID0ge1xuICAgICAgICAgIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIFdlYlhSIHNlc3Npb24gZXZlbnRzXG4gICAgICAgIGlmICh0eXBlb2YgKChfZ2wkeHIgPSBnbC54cikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbCR4ci5hZGRFdmVudExpc3RlbmVyKSA9PT0gJ2Z1bmN0aW9uJykgeHIuY29ubmVjdCgpO1xuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIHhyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgc2hhZG93bWFwXG4gICAgICBpZiAoZ2wuc2hhZG93TWFwKSB7XG4gICAgICAgIGNvbnN0IG9sZEVuYWJsZWQgPSBnbC5zaGFkb3dNYXAuZW5hYmxlZDtcbiAgICAgICAgY29uc3Qgb2xkVHlwZSA9IGdsLnNoYWRvd01hcC50eXBlO1xuICAgICAgICBnbC5zaGFkb3dNYXAuZW5hYmxlZCA9ICEhc2hhZG93cztcbiAgICAgICAgaWYgKGlzLmJvbyhzaGFkb3dzKSkge1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5zdHIoc2hhZG93cykpIHtcbiAgICAgICAgICB2YXIgX3R5cGVzJHNoYWRvd3M7XG4gICAgICAgICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgICAgICBiYXNpYzogVEhSRUUuQmFzaWNTaGFkb3dNYXAsXG4gICAgICAgICAgICBwZXJjZW50YWdlOiBUSFJFRS5QQ0ZTaGFkb3dNYXAsXG4gICAgICAgICAgICBzb2Z0OiBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwLFxuICAgICAgICAgICAgdmFyaWFuY2U6IFRIUkVFLlZTTVNoYWRvd01hcFxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2wuc2hhZG93TWFwLnR5cGUgPSAoX3R5cGVzJHNoYWRvd3MgPSB0eXBlc1tzaGFkb3dzXSkgIT0gbnVsbCA/IF90eXBlcyRzaGFkb3dzIDogVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5vYmooc2hhZG93cykpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGdsLnNoYWRvd01hcCwgc2hhZG93cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZEVuYWJsZWQgIT09IGdsLnNoYWRvd01hcC5lbmFibGVkIHx8IG9sZFR5cGUgIT09IGdsLnNoYWRvd01hcC50eXBlKSBnbC5zaGFkb3dNYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgVEhSRUUuQ29sb3JNYW5hZ2VtZW50LmVuYWJsZWQgPSAhbGVnYWN5O1xuXG4gICAgICAvLyBTZXQgY29sb3Igc3BhY2UgYW5kIHRvbmVtYXBwaW5nIHByZWZlcmVuY2VzXG4gICAgICBpZiAoIWNvbmZpZ3VyZWQpIHtcbiAgICAgICAgZ2wub3V0cHV0Q29sb3JTcGFjZSA9IGxpbmVhciA/IFRIUkVFLkxpbmVhclNSR0JDb2xvclNwYWNlIDogVEhSRUUuU1JHQkNvbG9yU3BhY2U7XG4gICAgICAgIGdsLnRvbmVNYXBwaW5nID0gZmxhdCA/IFRIUkVFLk5vVG9uZU1hcHBpbmcgOiBUSFJFRS5BQ0VTRmlsbWljVG9uZU1hcHBpbmc7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2xvciBtYW5hZ2VtZW50IHN0YXRlXG4gICAgICBpZiAoc3RhdGUubGVnYWN5ICE9PSBsZWdhY3kpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBsZWdhY3lcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdGF0ZS5saW5lYXIgIT09IGxpbmVhcikgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGxpbmVhclxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YXRlLmZsYXQgIT09IGZsYXQpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBmbGF0XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCBnbCBwcm9wc1xuICAgICAgaWYgKGdsQ29uZmlnICYmICFpcy5mdW4oZ2xDb25maWcpICYmICFpc1JlbmRlcmVyKGdsQ29uZmlnKSAmJiAhaXMuZXF1KGdsQ29uZmlnLCBnbCwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhnbCwgZ2xDb25maWcpO1xuXG4gICAgICAvLyBTZXQgbG9jYWxzXG4gICAgICBvbkNyZWF0ZWQgPSBvbkNyZWF0ZWRDYWxsYmFjaztcbiAgICAgIGNvbmZpZ3VyZWQgPSB0cnVlO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW5kZXIoY2hpbGRyZW4pIHtcbiAgICAgIC8vIFRoZSByb290IGhhcyB0byBiZSBjb25maWd1cmVkIGJlZm9yZSBpdCBjYW4gYmUgcmVuZGVyZWRcbiAgICAgIGlmICghY29uZmlndXJlZCAmJiAhcGVuZGluZykgdGhpcy5jb25maWd1cmUoKTtcbiAgICAgIHBlbmRpbmcudGhlbigoKSA9PiB7XG4gICAgICAgIHJlY29uY2lsZXIudXBkYXRlQ29udGFpbmVyKCAvKiNfX1BVUkVfXyovanN4KFByb3ZpZGVyLCB7XG4gICAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZCxcbiAgICAgICAgICByb290RWxlbWVudDogY2FudmFzXG4gICAgICAgIH0pLCBmaWJlciwgbnVsbCwgKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH0sXG4gICAgdW5tb3VudCgpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBQcm92aWRlcih7XG4gIHN0b3JlLFxuICBjaGlsZHJlbixcbiAgb25DcmVhdGVkLFxuICByb290RWxlbWVudFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gRmxhZyB0aGUgY2FudmFzIGFjdGl2ZSwgcmVuZGVyaW5nIHdpbGwgbm93IGJlZ2luXG4gICAgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcm5hbCxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSkpO1xuICAgIC8vIE5vdGlmeSB0aGF0IGluaXQgaXMgY29tcGxldGVkLCB0aGUgc2NlbmUgZ3JhcGggZXhpc3RzLCBidXQgbm90aGluZyBoYXMgeWV0IHJlbmRlcmVkXG4gICAgaWYgKG9uQ3JlYXRlZCkgb25DcmVhdGVkKHN0YXRlKTtcbiAgICAvLyBDb25uZWN0IGV2ZW50cyB0byB0aGUgdGFyZ2V0cyBwYXJlbnQsIHRoaXMgaXMgZG9uZSB0byBlbnN1cmUgZXZlbnRzIGFyZSByZWdpc3RlcmVkIG9uXG4gICAgLy8gYSBzaGFyZWQgdGFyZ2V0LCBhbmQgbm90IG9uIHRoZSBjYW52YXMgaXRzZWxmXG4gICAgaWYgKCFzdG9yZS5nZXRTdGF0ZSgpLmV2ZW50cy5jb25uZWN0ZWQpIHN0YXRlLmV2ZW50cy5jb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29ubmVjdChyb290RWxlbWVudCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RvcmUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb3QgPSBfcm9vdHMuZ2V0KGNhbnZhcyk7XG4gIGNvbnN0IGZpYmVyID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5maWJlcjtcbiAgaWYgKGZpYmVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LnN0b3JlLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlKSBzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgPSBmYWxzZTtcbiAgICByZWNvbmNpbGVyLnVwZGF0ZUNvbnRhaW5lcihudWxsLCBmaWJlciwgbnVsbCwgKCkgPT4ge1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX3N0YXRlJGdsLCBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMsIF9zdGF0ZSRnbDIsIF9zdGF0ZSRnbDM7XG4gICAgICAgICAgICBzdGF0ZS5ldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIChfc3RhdGUkZ2wgPSBzdGF0ZS5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IChfc3RhdGUkZ2wkcmVuZGVyTGlzdHMgPSBfc3RhdGUkZ2wucmVuZGVyTGlzdHMpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMuZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsJHJlbmRlckxpc3RzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIChfc3RhdGUkZ2wyID0gc3RhdGUuZ2wpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wyLmZvcmNlQ29udGV4dExvc3MgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbDIuZm9yY2VDb250ZXh0TG9zcygpO1xuICAgICAgICAgICAgaWYgKChfc3RhdGUkZ2wzID0gc3RhdGUuZ2wpICE9IG51bGwgJiYgX3N0YXRlJGdsMy54cikgc3RhdGUueHIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZGlzcG9zZShzdGF0ZS5zY2VuZSk7XG4gICAgICAgICAgICBfcm9vdHMuZGVsZXRlKGNhbnZhcyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGNhbnZhcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogLi4uICovXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lciwgc3RhdGUpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goUG9ydGFsLCB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFBvcnRhbCh7XG4gIHN0YXRlID0ge30sXG4gIGNoaWxkcmVuLFxuICBjb250YWluZXJcbn0pIHtcbiAgLyoqIFRoaXMgaGFzIHRvIGJlIGEgY29tcG9uZW50IGJlY2F1c2UgaXQgd291bGQgbm90IGJlIGFibGUgdG8gY2FsbCB1c2VUaHJlZS91c2VTdG9yZSBvdGhlcndpc2Ugc2luY2VcbiAgICogIGlmIHRoaXMgaXMgb3VyIGVudmlyb25tZW50LCB0aGVuIHdlIGFyZSBub3QgaW4gcjNmJ3MgcmVuZGVyZXIgYnV0IGluIHJlYWN0LWRvbSwgaXQgd291bGQgdHJpZ2dlclxuICAgKiAgdGhlIFwiUjNGIGhvb2tzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSBDYW52YXMgY29tcG9uZW50IVwiIHdhcm5pbmc6XG4gICAqICA8Q2FudmFzPlxuICAgKiAgICB7Y3JlYXRlUG9ydGFsKC4uLil9ICovXG4gIGNvbnN0IHtcbiAgICBldmVudHMsXG4gICAgc2l6ZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcHJldmlvdXNSb290ID0gdXNlU3RvcmUoKTtcbiAgY29uc3QgW3JheWNhc3Rlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUUuUmF5Y2FzdGVyKCkpO1xuICBjb25zdCBbcG9pbnRlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMigpKTtcbiAgY29uc3QgaW5qZWN0ID0gdXNlTXV0YWJsZUNhbGxiYWNrKChyb290U3RhdGUsIGluamVjdFN0YXRlKSA9PiB7XG4gICAgbGV0IHZpZXdwb3J0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChpbmplY3RTdGF0ZS5jYW1lcmEgJiYgc2l6ZSkge1xuICAgICAgY29uc3QgY2FtZXJhID0gaW5qZWN0U3RhdGUuY2FtZXJhO1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvdmVycmlkZSB2aWV3cG9ydCwgaWYgcHJlc2VudFxuICAgICAgdmlld3BvcnQgPSByb290U3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgc2l6ZSk7XG4gICAgICAvLyBVcGRhdGUgdGhlIHBvcnRhbCBjYW1lcmEsIGlmIGl0IGRpZmZlcnMgZnJvbSB0aGUgcHJldmlvdXMgbGF5ZXJcbiAgICAgIGlmIChjYW1lcmEgIT09IHJvb3RTdGF0ZS5jYW1lcmEpIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLy8gVGhlIGludGVyc2VjdCBjb25zaXN0cyBvZiB0aGUgcHJldmlvdXMgcm9vdCBzdGF0ZVxuICAgICAgLi4ucm9vdFN0YXRlLFxuICAgICAgLi4uaW5qZWN0U3RhdGUsXG4gICAgICAvLyBQb3J0YWxzIGhhdmUgdGhlaXIgb3duIHNjZW5lLCB3aGljaCBmb3JtcyB0aGUgcm9vdCwgYSByYXljYXN0ZXIgYW5kIGEgcG9pbnRlclxuICAgICAgc2NlbmU6IGNvbnRhaW5lcixcbiAgICAgIHJheWNhc3RlcixcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIC8vIFRoZWlyIHByZXZpb3VzIHJvb3QgaXMgdGhlIGxheWVyIGJlZm9yZSBpdFxuICAgICAgcHJldmlvdXNSb290LFxuICAgICAgLy8gRXZlbnRzLCBzaXplIGFuZCB2aWV3cG9ydCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgaW5qZWN0IGxheWVyXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLmV2ZW50cyxcbiAgICAgICAgLi4uaW5qZWN0U3RhdGUuZXZlbnRzLFxuICAgICAgICAuLi5ldmVudHNcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS5zaXplLFxuICAgICAgICAuLi5zaXplXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAuLi52aWV3cG9ydFxuICAgICAgfSxcbiAgICAgIC8vIExheWVycyBhcmUgYWxsb3dlZCB0byBvdmVycmlkZSBldmVudHNcbiAgICAgIHNldEV2ZW50czogZXZlbnRzID0+IGluamVjdFN0YXRlLnNldChzdGF0ZSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KSlcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgdXNlUG9ydGFsU3RvcmUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAvLyBDcmVhdGUgYSBtaXJyb3JlZCBzdG9yZSwgYmFzZWQgb24gdGhlIHByZXZpb3VzIHJvb3Qgd2l0aCBhIGZldyBvdmVycmlkZXMgLi4uXG4gICAgY29uc3Qgc3RvcmUgPSBjcmVhdGVXaXRoRXF1YWxpdHlGbigoc2V0LCBnZXQpID0+ICh7XG4gICAgICAuLi5yZXN0LFxuICAgICAgc2V0LFxuICAgICAgZ2V0XG4gICAgfSkpO1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIHByZXZpb3VzIHJvb3Qtc3RhdGUgYW5kIGNvcHkgY2hhbmdlcyBvdmVyIHRvIHRoZSBtaXJyb3JlZCBwb3J0YWwtc3RhdGVcbiAgICBjb25zdCBvbk11dGF0ZSA9IHByZXYgPT4gc3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4gaW5qZWN0LmN1cnJlbnQocHJldiwgc3RhdGUpKTtcbiAgICBvbk11dGF0ZShwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKSk7XG4gICAgcHJldmlvdXNSb290LnN1YnNjcmliZShvbk11dGF0ZSk7XG4gICAgcmV0dXJuIHN0b3JlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW3ByZXZpb3VzUm9vdCwgY29udGFpbmVyXSk7XG4gIHJldHVybiAoXG4gICAgLyojX19QVVJFX18qL1xuICAgIC8vIEB0cy1pZ25vcmUsIHJlY29uY2lsZXIgdHlwZXMgYXJlIG5vdCBtYWludGFpbmVkXG4gICAganN4KEZyYWdtZW50LCB7XG4gICAgICBjaGlsZHJlbjogcmVjb25jaWxlci5jcmVhdGVQb3J0YWwoIC8qI19fUFVSRV9fKi9qc3goY29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogdXNlUG9ydGFsU3RvcmUsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSksIHVzZVBvcnRhbFN0b3JlLCBudWxsKVxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRm9yY2UgUmVhY3QgdG8gZmx1c2ggYW55IHVwZGF0ZXMgaW5zaWRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBzeW5jaHJvbm91c2x5IGFuZCBpbW1lZGlhdGVseS5cbiAqIEFsbCB0aGUgc2FtZSBjYXZlYXRzIGRvY3VtZW50ZWQgZm9yIHJlYWN0LWRvbSdzIGBmbHVzaFN5bmNgIGFwcGx5IGhlcmUgKHNlZSBodHRwczovL3JlYWN0LmRldi9yZWZlcmVuY2UvcmVhY3QtZG9tL2ZsdXNoU3luYykuXG4gKiBOZXZlcnRoZWxlc3MsIHNvbWV0aW1lcyBvbmUgbmVlZHMgdG8gcmVuZGVyIHN5bmNocm9ub3VzbHksIGZvciBleGFtcGxlIHRvIGtlZXAgRE9NIGFuZCAzRCBjaGFuZ2VzIGluIGxvY2stc3RlcCB3aXRob3V0XG4gKiBoYXZpbmcgdG8gcmV2ZXJ0IHRvIGEgbm9uLVJlYWN0IHNvbHV0aW9uLlxuICovXG5mdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcbiAgcmV0dXJuIHJlY29uY2lsZXIuZmx1c2hTeW5jKGZuKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3VicyhjYWxsYmFjaywgc3Vicykge1xuICBjb25zdCBzdWIgPSB7XG4gICAgY2FsbGJhY2tcbiAgfTtcbiAgc3Vicy5hZGQoc3ViKTtcbiAgcmV0dXJuICgpID0+IHZvaWQgc3Vicy5kZWxldGUoc3ViKTtcbn1cbmNvbnN0IGdsb2JhbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5jb25zdCBnbG9iYWxBZnRlckVmZmVjdHMgPSBuZXcgU2V0KCk7XG5jb25zdCBnbG9iYWxUYWlsRWZmZWN0cyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBBZGRzIGEgZ2xvYmFsIHJlbmRlciBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgZWFjaCBmcmFtZS5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRFZmZlY3RcbiAqL1xuY29uc3QgYWRkRWZmZWN0ID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsRWZmZWN0cyk7XG5cbi8qKlxuICogQWRkcyBhIGdsb2JhbCBhZnRlci1yZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkQWZ0ZXJFZmZlY3RcbiAqL1xuY29uc3QgYWRkQWZ0ZXJFZmZlY3QgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxBZnRlckVmZmVjdHMpO1xuXG4vKipcbiAqIEFkZHMgYSBnbG9iYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gcmVuZGVyaW5nIHN0b3BzLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZFRhaWxcbiAqL1xuY29uc3QgYWRkVGFpbCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbFRhaWxFZmZlY3RzKTtcbmZ1bmN0aW9uIHJ1bihlZmZlY3RzLCB0aW1lc3RhbXApIHtcbiAgaWYgKCFlZmZlY3RzLnNpemUpIHJldHVybjtcbiAgZm9yIChjb25zdCB7XG4gICAgY2FsbGJhY2tcbiAgfSBvZiBlZmZlY3RzLnZhbHVlcygpKSB7XG4gICAgY2FsbGJhY2sodGltZXN0YW1wKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hHbG9iYWxFZmZlY3RzKHR5cGUsIHRpbWVzdGFtcCkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdiZWZvcmUnOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxFZmZlY3RzLCB0aW1lc3RhbXApO1xuICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsQWZ0ZXJFZmZlY3RzLCB0aW1lc3RhbXApO1xuICAgIGNhc2UgJ3RhaWwnOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxUYWlsRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgfVxufVxubGV0IHN1YnNjcmliZXJzO1xubGV0IHN1YnNjcmlwdGlvbjtcbmZ1bmN0aW9uIHVwZGF0ZSh0aW1lc3RhbXAsIHN0YXRlLCBmcmFtZSkge1xuICAvLyBSdW4gbG9jYWwgZWZmZWN0c1xuICBsZXQgZGVsdGEgPSBzdGF0ZS5jbG9jay5nZXREZWx0YSgpO1xuXG4gIC8vIEluIGZyYW1lbG9vcD0nbmV2ZXInIG1vZGUsIGNsb2NrIHRpbWVzIGFyZSB1cGRhdGVkIHVzaW5nIHRoZSBwcm92aWRlZCB0aW1lc3RhbXBcbiAgaWYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJyAmJiB0eXBlb2YgdGltZXN0YW1wID09PSAnbnVtYmVyJykge1xuICAgIGRlbHRhID0gdGltZXN0YW1wIC0gc3RhdGUuY2xvY2suZWxhcHNlZFRpbWU7XG4gICAgc3RhdGUuY2xvY2sub2xkVGltZSA9IHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lO1xuICAgIHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lID0gdGltZXN0YW1wO1xuICB9XG5cbiAgLy8gQ2FsbCBzdWJzY3JpYmVycyAodXNlRnJhbWUpXG4gIHN1YnNjcmliZXJzID0gc3RhdGUuaW50ZXJuYWwuc3Vic2NyaWJlcnM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBzdWJzY3JpcHRpb24ucmVmLmN1cnJlbnQoc3Vic2NyaXB0aW9uLnN0b3JlLmdldFN0YXRlKCksIGRlbHRhLCBmcmFtZSk7XG4gIH1cblxuICAvLyBSZW5kZXIgY29udGVudFxuICBpZiAoIXN0YXRlLmludGVybmFsLnByaW9yaXR5ICYmIHN0YXRlLmdsLnJlbmRlcikgc3RhdGUuZ2wucmVuZGVyKHN0YXRlLnNjZW5lLCBzdGF0ZS5jYW1lcmEpO1xuXG4gIC8vIERlY3JlYXNlIGZyYW1lIGNvdW50XG4gIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IE1hdGgubWF4KDAsIHN0YXRlLmludGVybmFsLmZyYW1lcyAtIDEpO1xuICByZXR1cm4gc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyA/IDEgOiBzdGF0ZS5pbnRlcm5hbC5mcmFtZXM7XG59XG5sZXQgcnVubmluZyA9IGZhbHNlO1xubGV0IHVzZUZyYW1lSW5Qcm9ncmVzcyA9IGZhbHNlO1xubGV0IHJlcGVhdDtcbmxldCBmcmFtZTtcbmxldCBzdGF0ZTtcbmZ1bmN0aW9uIGxvb3AodGltZXN0YW1wKSB7XG4gIGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICBydW5uaW5nID0gdHJ1ZTtcbiAgcmVwZWF0ID0gMDtcblxuICAvLyBSdW4gZWZmZWN0c1xuICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2JlZm9yZScsIHRpbWVzdGFtcCk7XG5cbiAgLy8gUmVuZGVyIGFsbCByb290c1xuICB1c2VGcmFtZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICBmb3IgKGNvbnN0IHJvb3Qgb2YgX3Jvb3RzLnZhbHVlcygpKSB7XG4gICAgdmFyIF9zdGF0ZSRnbCR4cjtcbiAgICBzdGF0ZSA9IHJvb3Quc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIElmIHRoZSBmcmFtZWxvb3AgaXMgaW52YWxpZGF0ZWQsIGRvIG5vdCBydW4gYW5vdGhlciBmcmFtZVxuICAgIGlmIChzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgJiYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ2Fsd2F5cycgfHwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID4gMCkgJiYgISgoX3N0YXRlJGdsJHhyID0gc3RhdGUuZ2wueHIpICE9IG51bGwgJiYgX3N0YXRlJGdsJHhyLmlzUHJlc2VudGluZykpIHtcbiAgICAgIHJlcGVhdCArPSB1cGRhdGUodGltZXN0YW1wLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIHVzZUZyYW1lSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gIC8vIFJ1biBhZnRlci1lZmZlY3RzXG4gIGZsdXNoR2xvYmFsRWZmZWN0cygnYWZ0ZXInLCB0aW1lc3RhbXApO1xuXG4gIC8vIFN0b3AgdGhlIGxvb3AgaWYgbm90aGluZyBpbnZhbGlkYXRlcyBpdFxuICBpZiAocmVwZWF0ID09PSAwKSB7XG4gICAgLy8gVGFpbCBjYWxsIGVmZmVjdHMsIHRoZXkgYXJlIGNhbGxlZCB3aGVuIHJlbmRlcmluZyBzdG9wc1xuICAgIGZsdXNoR2xvYmFsRWZmZWN0cygndGFpbCcsIHRpbWVzdGFtcCk7XG5cbiAgICAvLyBGbGFnIGVuZCBvZiBvcGVyYXRpb25cbiAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgcmV0dXJuIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIEludmFsaWRhdGVzIHRoZSB2aWV3LCByZXF1ZXN0aW5nIGEgZnJhbWUgdG8gYmUgcmVuZGVyZWQuIFdpbGwgZ2xvYmFsbHkgaW52YWxpZGF0ZSB1bmxlc3MgcGFzc2VkIGEgcm9vdCdzIHN0YXRlLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2ludmFsaWRhdGVcbiAqL1xuZnVuY3Rpb24gaW52YWxpZGF0ZShzdGF0ZSwgZnJhbWVzID0gMSkge1xuICB2YXIgX3N0YXRlJGdsJHhyMjtcbiAgaWYgKCFzdGF0ZSkgcmV0dXJuIF9yb290cy5mb3JFYWNoKHJvb3QgPT4gaW52YWxpZGF0ZShyb290LnN0b3JlLmdldFN0YXRlKCksIGZyYW1lcykpO1xuICBpZiAoKF9zdGF0ZSRnbCR4cjIgPSBzdGF0ZS5nbC54cikgIT0gbnVsbCAmJiBfc3RhdGUkZ2wkeHIyLmlzUHJlc2VudGluZyB8fCAhc3RhdGUuaW50ZXJuYWwuYWN0aXZlIHx8IHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJykgcmV0dXJuO1xuICBpZiAoZnJhbWVzID4gMSkge1xuICAgIC8vIGxlZ2FjeSBzdXBwb3J0IGZvciBwZW9wbGUgdXNpbmcgZnJhbWVzIHBhcmFtZXRlcnNcbiAgICAvLyBJbmNyZWFzZSBmcmFtZXMsIGRvIG5vdCBnbyBoaWdoZXIgdGhhbiA2MFxuICAgIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IE1hdGgubWluKDYwLCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgKyBmcmFtZXMpO1xuICB9IGVsc2Uge1xuICAgIGlmICh1c2VGcmFtZUluUHJvZ3Jlc3MpIHtcbiAgICAgIC8vY2FsbGVkIGZyb20gd2l0aGluIGEgdXNlRnJhbWUsIGl0IG1lYW5zIHRoZSB1c2VyIHdhbnRzIGFuIGFkZGl0aW9uYWwgZnJhbWVcbiAgICAgIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vdGhlIHVzZXIgbmVlZCBhIG5ldyBmcmFtZSwgbm8gbmVlZCB0byBpbmNyZW1lbnQgZnVydGhlciB0aGFuIDFcbiAgICAgIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IDE7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIHJlbmRlci1sb29wIGlzbid0IGFjdGl2ZSwgc3RhcnQgaXRcbiAgaWYgKCFydW5uaW5nKSB7XG4gICAgcnVubmluZyA9IHRydWU7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICB9XG59XG5cbi8qKlxuICogQWR2YW5jZXMgdGhlIGZyYW1lbG9vcCBhbmQgcnVucyByZW5kZXIgZWZmZWN0cywgdXNlZnVsIGZvciB3aGVuIG1hbnVhbGx5IHJlbmRlcmluZyB2aWEgYGZyYW1lbG9vcD1cIm5ldmVyXCJgLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkdmFuY2VcbiAqL1xuZnVuY3Rpb24gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMgPSB0cnVlLCBzdGF0ZSwgZnJhbWUpIHtcbiAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcbiAgaWYgKCFzdGF0ZSkgZm9yIChjb25zdCByb290IG9mIF9yb290cy52YWx1ZXMoKSkgdXBkYXRlKHRpbWVzdGFtcCwgcm9vdC5zdG9yZS5nZXRTdGF0ZSgpKTtlbHNlIHVwZGF0ZSh0aW1lc3RhbXAsIHN0YXRlLCBmcmFtZSk7XG4gIGlmIChydW5HbG9iYWxFZmZlY3RzKSBmbHVzaEdsb2JhbEVmZmVjdHMoJ2FmdGVyJywgdGltZXN0YW1wKTtcbn1cblxuY29uc3QgRE9NX0VWRU5UUyA9IHtcbiAgb25DbGljazogWydjbGljaycsIGZhbHNlXSxcbiAgb25Db250ZXh0TWVudTogWydjb250ZXh0bWVudScsIGZhbHNlXSxcbiAgb25Eb3VibGVDbGljazogWydkYmxjbGljaycsIGZhbHNlXSxcbiAgb25XaGVlbDogWyd3aGVlbCcsIHRydWVdLFxuICBvblBvaW50ZXJEb3duOiBbJ3BvaW50ZXJkb3duJywgdHJ1ZV0sXG4gIG9uUG9pbnRlclVwOiBbJ3BvaW50ZXJ1cCcsIHRydWVdLFxuICBvblBvaW50ZXJMZWF2ZTogWydwb2ludGVybGVhdmUnLCB0cnVlXSxcbiAgb25Qb2ludGVyTW92ZTogWydwb2ludGVybW92ZScsIHRydWVdLFxuICBvblBvaW50ZXJDYW5jZWw6IFsncG9pbnRlcmNhbmNlbCcsIHRydWVdLFxuICBvbkxvc3RQb2ludGVyQ2FwdHVyZTogWydsb3N0cG9pbnRlcmNhcHR1cmUnLCB0cnVlXVxufTtcblxuLyoqIERlZmF1bHQgUjNGIGV2ZW50IG1hbmFnZXIgZm9yIHdlYiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9pbnRlckV2ZW50cyhzdG9yZSkge1xuICBjb25zdCB7XG4gICAgaGFuZGxlUG9pbnRlclxuICB9ID0gY3JlYXRlRXZlbnRzKHN0b3JlKTtcbiAgcmV0dXJuIHtcbiAgICBwcmlvcml0eTogMSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGNvbXB1dGUoZXZlbnQsIHN0YXRlLCBwcmV2aW91cykge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzc4MlxuICAgICAgLy8gRXZlbnRzIHRyaWdnZXIgb3V0c2lkZSBvZiBjYW52YXMgd2hlbiBtb3ZlZCwgdXNlIG9mZnNldFgvWSBieSBkZWZhdWx0IGFuZCBhbGxvdyBvdmVycmlkZXNcbiAgICAgIHN0YXRlLnBvaW50ZXIuc2V0KGV2ZW50Lm9mZnNldFggLyBzdGF0ZS5zaXplLndpZHRoICogMiAtIDEsIC0oZXZlbnQub2Zmc2V0WSAvIHN0YXRlLnNpemUuaGVpZ2h0KSAqIDIgKyAxKTtcbiAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgfSxcbiAgICBjb25uZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICBoYW5kbGVyczogT2JqZWN0LmtleXMoRE9NX0VWRU5UUykucmVkdWNlKChhY2MsIGtleSkgPT4gKHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIFtrZXldOiBoYW5kbGVQb2ludGVyKGtleSlcbiAgICB9KSwge30pLFxuICAgIHVwZGF0ZTogKCkgPT4ge1xuICAgICAgdmFyIF9pbnRlcm5hbCRsYXN0RXZlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKChfaW50ZXJuYWwkbGFzdEV2ZW50ID0gaW50ZXJuYWwubGFzdEV2ZW50KSAhPSBudWxsICYmIF9pbnRlcm5hbCRsYXN0RXZlbnQuY3VycmVudCAmJiBldmVudHMuaGFuZGxlcnMpIGV2ZW50cy5oYW5kbGVycy5vblBvaW50ZXJNb3ZlKGludGVybmFsLmxhc3RFdmVudC5jdXJyZW50KTtcbiAgICB9LFxuICAgIGNvbm5lY3Q6IHRhcmdldCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGV2ZW50cy5kaXNjb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBldmVudHMuZGlzY29ubmVjdCgpO1xuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICBjb25uZWN0ZWQ6IHRhcmdldFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBpZiAoZXZlbnRzLmhhbmRsZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBldmVudHMuaGFuZGxlcnMpIHtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50cy5oYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgICBjb25zdCBbZXZlbnROYW1lLCBwYXNzaXZlXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudCwge1xuICAgICAgICAgICAgcGFzc2l2ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChldmVudHMuY29ubmVjdGVkKSB7XG4gICAgICAgIGlmIChldmVudHMuaGFuZGxlcnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZXZlbnRzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50cy5oYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IFtldmVudE5hbWVdID0gRE9NX0VWRU5UU1tuYW1lXTtcbiAgICAgICAgICAgIGV2ZW50cy5jb25uZWN0ZWQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgICBjb25uZWN0ZWQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IHsgdXNlU3RvcmUgYXMgQSwgQmxvY2sgYXMgQiwgdXNlVGhyZWUgYXMgQywgdXNlRnJhbWUgYXMgRCwgRXJyb3JCb3VuZGFyeSBhcyBFLCB1c2VHcmFwaCBhcyBGLCB1c2VMb2FkZXIgYXMgRywgX3Jvb3RzIGFzIF8sIHVzZU11dGFibGVDYWxsYmFjayBhcyBhLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGFzIGIsIGNyZWF0ZVJvb3QgYXMgYywgdW5tb3VudENvbXBvbmVudEF0Tm9kZSBhcyBkLCBleHRlbmQgYXMgZSwgY3JlYXRlUG9pbnRlckV2ZW50cyBhcyBmLCBjcmVhdGVFdmVudHMgYXMgZywgZmx1c2hHbG9iYWxFZmZlY3RzIGFzIGgsIGlzUmVmIGFzIGksIGFkZEVmZmVjdCBhcyBqLCBhZGRBZnRlckVmZmVjdCBhcyBrLCBhZGRUYWlsIGFzIGwsIGludmFsaWRhdGUgYXMgbSwgYWR2YW5jZSBhcyBuLCBjcmVhdGVQb3J0YWwgYXMgbywgZmx1c2hTeW5jIGFzIHAsIGNvbnRleHQgYXMgcSwgcmVjb25jaWxlciBhcyByLCBhcHBseVByb3BzIGFzIHMsIHRocmVlVHlwZXMgYXMgdCwgdXNlQnJpZGdlIGFzIHUsIGdldFJvb3RTdGF0ZSBhcyB2LCBkaXNwb3NlIGFzIHcsIGFjdCBhcyB4LCBidWlsZEdyYXBoIGFzIHksIHVzZUluc3RhbmNlSGFuZGxlIGFzIHogfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   act: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   addEffect: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   addTail: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   advance: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   applyProps: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   context: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   createEvents: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createPortal: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   createRoot: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   dispose: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   events: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   extend: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   flushSync: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   getRootState: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   invalidate: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   reconciler: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   useGraph: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   useLoader: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   useStore: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   useThree: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.C)\n/* harmony export */ });\n/* harmony import */ var _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events-cf57b220.esm.js */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-use-measure */ \"(app-pages-browser)/./node_modules/react-use-measure/dist/index.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! its-fine */ \"(app-pages-browser)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(app-pages-browser)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(app-pages-browser)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(app-pages-browser)/./node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction CanvasImpl({\n  ref,\n  children,\n  fallback,\n  resize,\n  style,\n  gl,\n  events = _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.f,\n  eventSource,\n  eventPrefix,\n  shadows,\n  linear,\n  flat,\n  legacy,\n  orthographic,\n  frameloop,\n  dpr,\n  performance,\n  raycaster,\n  camera,\n  scene,\n  onPointerMissed,\n  onCreated,\n  ...props\n}) {\n  // Create a known catalogue of Threejs-native elements\n  // This will include the entire THREE namespace by default, users can extend\n  // their own elements by using the createRoot API instead\n  react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__), []);\n  const Bridge = (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)();\n  const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n    scroll: true,\n    debounce: {\n      scroll: 50,\n      resize: 0\n    },\n    ...resize\n  });\n  const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const divRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, () => canvasRef.current);\n  const handlePointerMissed = (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(onPointerMissed);\n  const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n  const [error, setError] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n\n  // Suspend this component if block is a promise (2nd run)\n  if (block) throw block;\n  // Throw exception outwards if anything within canvas throws\n  if (error) throw error;\n  const root = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(() => {\n    const canvas = canvasRef.current;\n    if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n      if (!root.current) root.current = (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(canvas);\n      async function run() {\n        await root.current.configure({\n          gl,\n          scene,\n          events,\n          shadows,\n          linear,\n          flat,\n          legacy,\n          orthographic,\n          frameloop,\n          dpr,\n          performance,\n          raycaster,\n          camera,\n          size: containerRect,\n          // Pass mutable reference to onPointerMissed so it's free to update\n          onPointerMissed: (...args) => handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n          onCreated: state => {\n            // Connect to event source\n            state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n            // Set up compute function\n            if (eventPrefix) {\n              state.setEvents({\n                compute: (event, state) => {\n                  const x = event[eventPrefix + 'X'];\n                  const y = event[eventPrefix + 'Y'];\n                  state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                  state.raycaster.setFromCamera(state.pointer, state.camera);\n                }\n              });\n            }\n            // Call onCreated callback\n            onCreated == null ? void 0 : onCreated(state);\n          }\n        });\n        root.current.render( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Bridge, {\n          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n            set: setError,\n            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n              fallback: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                set: setBlock\n              }),\n              children: children != null ? children : null\n            })\n          })\n        }));\n      }\n      run();\n    }\n  });\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) return () => (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n  }, []);\n\n  // When the event source is not this div, we need to set pointer-events to none\n  // Or else the canvas will block events from reaching the event source\n  const pointerEvents = eventSource ? 'none' : 'auto';\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n    ref: divRef,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      pointerEvents,\n      ...style\n    },\n    ...props,\n    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n      ref: containerRef,\n      style: {\n        width: '100%',\n        height: '100%'\n      },\n      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"canvas\", {\n        ref: canvasRef,\n        style: {\n          display: 'block'\n        },\n        children: fallback\n      })\n    })\n  });\n}\n\n/**\n * A DOM canvas which accepts threejs elements as children.\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\n */\nfunction Canvas(props) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(its_fine__WEBPACK_IMPORTED_MODULE_8__.FiberProvider, {\n    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CanvasImpl, {\n      ...props\n    })\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvZGlzdC9yZWFjdC10aHJlZS1maWJlci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvUDtBQUNrUjtBQUN2ZTtBQUNBO0FBQ1k7QUFDRjtBQUNEO0FBQ0o7QUFDUDtBQUNIO0FBQ1A7QUFDSTs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNEQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFFLDBDQUFhLE9BQU8sMERBQU0sQ0FBQyxrQ0FBSztBQUNsQyxpQkFBaUIsMERBQVM7QUFDMUIsd0NBQXdDLDZEQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILG9CQUFvQix5Q0FBWTtBQUNoQyxpQkFBaUIseUNBQVk7QUFDN0IsRUFBRSxzREFBeUI7QUFDM0IsOEJBQThCLDBEQUFrQjtBQUNoRCw0QkFBNEIsMkNBQWM7QUFDMUMsNEJBQTRCLDJDQUFjOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUNBQVk7QUFDM0IsRUFBRSwwREFBeUI7QUFDM0I7QUFDQTtBQUNBLHdDQUF3QywwREFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLDBEQUFLO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwwQ0FBMEMsc0RBQUc7QUFDN0MsaUNBQWlDLHNEQUFHLENBQUMsc0RBQWE7QUFDbEQ7QUFDQSxtQ0FBbUMsc0RBQUcsQ0FBQywyQ0FBYztBQUNyRCxxQ0FBcUMsc0RBQUcsQ0FBQyxzREFBSztBQUM5QztBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0EsNkJBQTZCLDBEQUFzQjtBQUNuRCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBRztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkJBQTJCLHNEQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QixzREFBRztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFHLENBQUMsbURBQWE7QUFDdkMsMkJBQTJCLHNEQUFHO0FBQzlCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFa0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvZGlzdC9yZWFjdC10aHJlZS1maWJlci5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZSBhcyBleHRlbmQsIHUgYXMgdXNlQnJpZGdlLCBhIGFzIHVzZU11dGFibGVDYWxsYmFjaywgYiBhcyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCBjIGFzIGNyZWF0ZVJvb3QsIGkgYXMgaXNSZWYsIEUgYXMgRXJyb3JCb3VuZGFyeSwgQiBhcyBCbG9jaywgZCBhcyB1bm1vdW50Q29tcG9uZW50QXROb2RlLCBmIGFzIGNyZWF0ZVBvaW50ZXJFdmVudHMgfSBmcm9tICcuL2V2ZW50cy1jZjU3YjIyMC5lc20uanMnO1xuZXhwb3J0IHsgdCBhcyBSZWFjdFRocmVlRmliZXIsIF8gYXMgX3Jvb3RzLCB4IGFzIGFjdCwgayBhcyBhZGRBZnRlckVmZmVjdCwgaiBhcyBhZGRFZmZlY3QsIGwgYXMgYWRkVGFpbCwgbiBhcyBhZHZhbmNlLCBzIGFzIGFwcGx5UHJvcHMsIHkgYXMgYnVpbGRHcmFwaCwgcSBhcyBjb250ZXh0LCBnIGFzIGNyZWF0ZUV2ZW50cywgbyBhcyBjcmVhdGVQb3J0YWwsIGMgYXMgY3JlYXRlUm9vdCwgdyBhcyBkaXNwb3NlLCBmIGFzIGV2ZW50cywgZSBhcyBleHRlbmQsIGggYXMgZmx1c2hHbG9iYWxFZmZlY3RzLCBwIGFzIGZsdXNoU3luYywgdiBhcyBnZXRSb290U3RhdGUsIG0gYXMgaW52YWxpZGF0ZSwgciBhcyByZWNvbmNpbGVyLCBkIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUsIEQgYXMgdXNlRnJhbWUsIEYgYXMgdXNlR3JhcGgsIHogYXMgdXNlSW5zdGFuY2VIYW5kbGUsIEcgYXMgdXNlTG9hZGVyLCBBIGFzIHVzZVN0b3JlLCBDIGFzIHVzZVRocmVlIH0gZnJvbSAnLi9ldmVudHMtY2Y1N2IyMjAuZXNtLmpzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB1c2VNZWFzdXJlIGZyb20gJ3JlYWN0LXVzZS1tZWFzdXJlJztcbmltcG9ydCB7IEZpYmVyUHJvdmlkZXIgfSBmcm9tICdpdHMtZmluZSc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgJ3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzJztcbmltcG9ydCAnenVzdGFuZC90cmFkaXRpb25hbCc7XG5pbXBvcnQgJ3JlYWN0LXJlY29uY2lsZXInO1xuaW1wb3J0ICdzY2hlZHVsZXInO1xuaW1wb3J0ICdzdXNwZW5kLXJlYWN0JztcblxuZnVuY3Rpb24gQ2FudmFzSW1wbCh7XG4gIHJlZixcbiAgY2hpbGRyZW4sXG4gIGZhbGxiYWNrLFxuICByZXNpemUsXG4gIHN0eWxlLFxuICBnbCxcbiAgZXZlbnRzID0gY3JlYXRlUG9pbnRlckV2ZW50cyxcbiAgZXZlbnRTb3VyY2UsXG4gIGV2ZW50UHJlZml4LFxuICBzaGFkb3dzLFxuICBsaW5lYXIsXG4gIGZsYXQsXG4gIGxlZ2FjeSxcbiAgb3J0aG9ncmFwaGljLFxuICBmcmFtZWxvb3AsXG4gIGRwcixcbiAgcGVyZm9ybWFuY2UsXG4gIHJheWNhc3RlcixcbiAgY2FtZXJhLFxuICBzY2VuZSxcbiAgb25Qb2ludGVyTWlzc2VkLFxuICBvbkNyZWF0ZWQsXG4gIC4uLnByb3BzXG59KSB7XG4gIC8vIENyZWF0ZSBhIGtub3duIGNhdGFsb2d1ZSBvZiBUaHJlZWpzLW5hdGl2ZSBlbGVtZW50c1xuICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgZW50aXJlIFRIUkVFIG5hbWVzcGFjZSBieSBkZWZhdWx0LCB1c2VycyBjYW4gZXh0ZW5kXG4gIC8vIHRoZWlyIG93biBlbGVtZW50cyBieSB1c2luZyB0aGUgY3JlYXRlUm9vdCBBUEkgaW5zdGVhZFxuICBSZWFjdC51c2VNZW1vKCgpID0+IGV4dGVuZChUSFJFRSksIFtdKTtcbiAgY29uc3QgQnJpZGdlID0gdXNlQnJpZGdlKCk7XG4gIGNvbnN0IFtjb250YWluZXJSZWYsIGNvbnRhaW5lclJlY3RdID0gdXNlTWVhc3VyZSh7XG4gICAgc2Nyb2xsOiB0cnVlLFxuICAgIGRlYm91bmNlOiB7XG4gICAgICBzY3JvbGw6IDUwLFxuICAgICAgcmVzaXplOiAwXG4gICAgfSxcbiAgICAuLi5yZXNpemVcbiAgfSk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZGl2UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gY2FudmFzUmVmLmN1cnJlbnQpO1xuICBjb25zdCBoYW5kbGVQb2ludGVyTWlzc2VkID0gdXNlTXV0YWJsZUNhbGxiYWNrKG9uUG9pbnRlck1pc3NlZCk7XG4gIGNvbnN0IFtibG9jaywgc2V0QmxvY2tdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBTdXNwZW5kIHRoaXMgY29tcG9uZW50IGlmIGJsb2NrIGlzIGEgcHJvbWlzZSAoMm5kIHJ1bilcbiAgaWYgKGJsb2NrKSB0aHJvdyBibG9jaztcbiAgLy8gVGhyb3cgZXhjZXB0aW9uIG91dHdhcmRzIGlmIGFueXRoaW5nIHdpdGhpbiBjYW52YXMgdGhyb3dzXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gIGNvbnN0IHJvb3QgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmIChjb250YWluZXJSZWN0LndpZHRoID4gMCAmJiBjb250YWluZXJSZWN0LmhlaWdodCA+IDAgJiYgY2FudmFzKSB7XG4gICAgICBpZiAoIXJvb3QuY3VycmVudCkgcm9vdC5jdXJyZW50ID0gY3JlYXRlUm9vdChjYW52YXMpO1xuICAgICAgYXN5bmMgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgICBhd2FpdCByb290LmN1cnJlbnQuY29uZmlndXJlKHtcbiAgICAgICAgICBnbCxcbiAgICAgICAgICBzY2VuZSxcbiAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgc2hhZG93cyxcbiAgICAgICAgICBsaW5lYXIsXG4gICAgICAgICAgZmxhdCxcbiAgICAgICAgICBsZWdhY3ksXG4gICAgICAgICAgb3J0aG9ncmFwaGljLFxuICAgICAgICAgIGZyYW1lbG9vcCxcbiAgICAgICAgICBkcHIsXG4gICAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgICAgcmF5Y2FzdGVyLFxuICAgICAgICAgIGNhbWVyYSxcbiAgICAgICAgICBzaXplOiBjb250YWluZXJSZWN0LFxuICAgICAgICAgIC8vIFBhc3MgbXV0YWJsZSByZWZlcmVuY2UgdG8gb25Qb2ludGVyTWlzc2VkIHNvIGl0J3MgZnJlZSB0byB1cGRhdGVcbiAgICAgICAgICBvblBvaW50ZXJNaXNzZWQ6ICguLi5hcmdzKSA9PiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCguLi5hcmdzKSxcbiAgICAgICAgICBvbkNyZWF0ZWQ6IHN0YXRlID0+IHtcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gZXZlbnQgc291cmNlXG4gICAgICAgICAgICBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3QoZXZlbnRTb3VyY2UgPyBpc1JlZihldmVudFNvdXJjZSkgPyBldmVudFNvdXJjZS5jdXJyZW50IDogZXZlbnRTb3VyY2UgOiBkaXZSZWYuY3VycmVudCk7XG4gICAgICAgICAgICAvLyBTZXQgdXAgY29tcHV0ZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKGV2ZW50UHJlZml4KSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNldEV2ZW50cyh7XG4gICAgICAgICAgICAgICAgY29tcHV0ZTogKGV2ZW50LCBzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IGV2ZW50W2V2ZW50UHJlZml4ICsgJ1gnXTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBldmVudFtldmVudFByZWZpeCArICdZJ107XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5wb2ludGVyLnNldCh4IC8gc3RhdGUuc2l6ZS53aWR0aCAqIDIgLSAxLCAtKHkgLyBzdGF0ZS5zaXplLmhlaWdodCkgKiAyICsgMSk7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxsIG9uQ3JlYXRlZCBjYWxsYmFja1xuICAgICAgICAgICAgb25DcmVhdGVkID09IG51bGwgPyB2b2lkIDAgOiBvbkNyZWF0ZWQoc3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJvb3QuY3VycmVudC5yZW5kZXIoIC8qI19fUFVSRV9fKi9qc3goQnJpZGdlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICAgICAgc2V0OiBzZXRFcnJvcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KFJlYWN0LlN1c3BlbnNlLCB7XG4gICAgICAgICAgICAgIGZhbGxiYWNrOiAvKiNfX1BVUkVfXyovanN4KEJsb2NrLCB7XG4gICAgICAgICAgICAgICAgc2V0OiBzZXRCbG9ja1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuICE9IG51bGwgPyBjaGlsZHJlbiA6IG51bGxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgcnVuKCk7XG4gICAgfVxuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY2FudmFzKSByZXR1cm4gKCkgPT4gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMpO1xuICB9LCBbXSk7XG5cbiAgLy8gV2hlbiB0aGUgZXZlbnQgc291cmNlIGlzIG5vdCB0aGlzIGRpdiwgd2UgbmVlZCB0byBzZXQgcG9pbnRlci1ldmVudHMgdG8gbm9uZVxuICAvLyBPciBlbHNlIHRoZSBjYW52YXMgd2lsbCBibG9jayBldmVudHMgZnJvbSByZWFjaGluZyB0aGUgZXZlbnQgc291cmNlXG4gIGNvbnN0IHBvaW50ZXJFdmVudHMgPSBldmVudFNvdXJjZSA/ICdub25lJyA6ICdhdXRvJztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgIHJlZjogZGl2UmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIHBvaW50ZXJFdmVudHMsXG4gICAgICAuLi5zdHlsZVxuICAgIH0sXG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgICBzdHlsZToge1xuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KFwiY2FudmFzXCIsIHtcbiAgICAgICAgcmVmOiBjYW52YXNSZWYsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZmFsbGJhY2tcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59XG5cbi8qKlxuICogQSBET00gY2FudmFzIHdoaWNoIGFjY2VwdHMgdGhyZWVqcyBlbGVtZW50cyBhcyBjaGlsZHJlbi5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2NhbnZhc1xuICovXG5mdW5jdGlvbiBDYW52YXMocHJvcHMpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goRmliZXJQcm92aWRlciwge1xuICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KENhbnZhc0ltcGwsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IENhbnZhcyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs":
/*!*****************************************!*\
  !*** ./node_modules/clsx/dist/clsx.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: () => (/* binding */ clsx),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxjQUFjLGFBQWEsK0NBQStDLGdEQUFnRCxlQUFlLFFBQVEsSUFBSSwwQ0FBMEMseUNBQXlDLFNBQWdCLGdCQUFnQix3Q0FBd0MsSUFBSSxtREFBbUQsU0FBUyxpRUFBZSxJQUFJIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/its-fine/dist/index.js":
/*!*********************************************!*\
  !*** ./node_modules/its-fine/dist/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FiberProvider: () => (/* binding */ m),\n/* harmony export */   traverseFiber: () => (/* binding */ i),\n/* harmony export */   useContainer: () => (/* binding */ w),\n/* harmony export */   useContextBridge: () => (/* binding */ x),\n/* harmony export */   useContextMap: () => (/* binding */ h),\n/* harmony export */   useFiber: () => (/* binding */ c),\n/* harmony export */   useNearestChild: () => (/* binding */ v),\n/* harmony export */   useNearestParent: () => (/* binding */ y)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nconst f = /* @__PURE__ */ (() => {\n  var e, t;\n  return typeof window != \"undefined\" && (((e = window.document) == null ? void 0 : e.createElement) || ((t = window.navigator) == null ? void 0 : t.product) === \"ReactNative\");\n})() ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction i(e, t, r) {\n  if (!e) return;\n  if (r(e) === !0) return e;\n  let n = t ? e.return : e.child;\n  for (; n; ) {\n    const u = i(n, t, r);\n    if (u) return u;\n    n = t ? null : n.sibling;\n  }\n}\nfunction l(e) {\n  try {\n    return Object.defineProperties(e, {\n      _currentRenderer: {\n        get() {\n          return null;\n        },\n        set() {\n        }\n      },\n      _currentRenderer2: {\n        get() {\n          return null;\n        },\n        set() {\n        }\n      }\n    });\n  } catch (t) {\n    return e;\n  }\n}\nconst a = /* @__PURE__ */ l(/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null));\nclass m extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  render() {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(a.Provider, { value: this._reactInternals }, this.props.children);\n  }\n}\nfunction c() {\n  const e = react__WEBPACK_IMPORTED_MODULE_0__.useContext(a);\n  if (e === null) throw new Error(\"its-fine: useFiber must be called within a <FiberProvider />!\");\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useId();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    for (const n of [e, e == null ? void 0 : e.alternate]) {\n      if (!n) continue;\n      const u = i(n, !1, (d) => {\n        let s = d.memoizedState;\n        for (; s; ) {\n          if (s.memoizedState === t) return !0;\n          s = s.next;\n        }\n      });\n      if (u) return u;\n    }\n  }, [e, t]);\n}\nfunction w() {\n  const e = c(), t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => i(e, !0, (r) => {\n      var n;\n      return ((n = r.stateNode) == null ? void 0 : n.containerInfo) != null;\n    }),\n    [e]\n  );\n  return t == null ? void 0 : t.stateNode.containerInfo;\n}\nfunction v(e) {\n  const t = c(), r = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n  return f(() => {\n    var n;\n    r.current = (n = i(\n      t,\n      !1,\n      (u) => typeof u.type == \"string\" && (e === void 0 || u.type === e)\n    )) == null ? void 0 : n.stateNode;\n  }, [t]), r;\n}\nfunction y(e) {\n  const t = c(), r = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n  return f(() => {\n    var n;\n    r.current = (n = i(\n      t,\n      !0,\n      (u) => typeof u.type == \"string\" && (e === void 0 || u.type === e)\n    )) == null ? void 0 : n.stateNode;\n  }, [t]), r;\n}\nconst p = Symbol.for(\"react.context\"), b = (e) => e !== null && typeof e == \"object\" && \"$$typeof\" in e && e.$$typeof === p;\nfunction h() {\n  const e = c(), [t] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => /* @__PURE__ */ new Map());\n  t.clear();\n  let r = e;\n  for (; r; ) {\n    const n = r.type;\n    b(n) && n !== a && !t.has(n) && t.set(n, react__WEBPACK_IMPORTED_MODULE_0__.use(l(n))), r = r.return;\n  }\n  return t;\n}\nfunction x() {\n  const e = h();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => Array.from(e.keys()).reduce(\n      (t, r) => (n) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(t, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(r.Provider, { ...n, value: e.get(r) })),\n      (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(m, { ...t })\n    ),\n    [e]\n  );\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pdHMtZmluZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDLE1BQU0sa0RBQWlCLEdBQUcsNENBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdEQUFlO0FBQzNELGdCQUFnQiw0Q0FBVztBQUMzQjtBQUNBLDJCQUEyQixnREFBZSxlQUFlLDZCQUE2QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFZO0FBQ3hCO0FBQ0EsWUFBWSx3Q0FBTztBQUNuQixTQUFTLDBDQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQkFBcUIsMENBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUNBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQix5Q0FBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkNBQVU7QUFDakM7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaO0FBQ0EsNkNBQTZDLHNDQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBDQUFTO0FBQ2xCO0FBQ0EsdUNBQXVDLGdEQUFlLDBCQUEwQixnREFBZSxlQUFlLHVCQUF1QjtBQUNySSw2QkFBNkIsZ0RBQWUsTUFBTSxNQUFNO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBVUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL2l0cy1maW5lL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbyBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgdmFyIGUsIHQ7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgJiYgKCgoZSA9IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGUuY3JlYXRlRWxlbWVudCkgfHwgKCh0ID0gd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IHQucHJvZHVjdCkgPT09IFwiUmVhY3ROYXRpdmVcIik7XG59KSgpID8gby51c2VMYXlvdXRFZmZlY3QgOiBvLnVzZUVmZmVjdDtcbmZ1bmN0aW9uIGkoZSwgdCwgcikge1xuICBpZiAoIWUpIHJldHVybjtcbiAgaWYgKHIoZSkgPT09ICEwKSByZXR1cm4gZTtcbiAgbGV0IG4gPSB0ID8gZS5yZXR1cm4gOiBlLmNoaWxkO1xuICBmb3IgKDsgbjsgKSB7XG4gICAgY29uc3QgdSA9IGkobiwgdCwgcik7XG4gICAgaWYgKHUpIHJldHVybiB1O1xuICAgIG4gPSB0ID8gbnVsbCA6IG4uc2libGluZztcbiAgfVxufVxuZnVuY3Rpb24gbChlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIHtcbiAgICAgIF9jdXJyZW50UmVuZGVyZXI6IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoKSB7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFJlbmRlcmVyMjoge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCgpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoICh0KSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cbmNvbnN0IGEgPSAvKiBAX19QVVJFX18gKi8gbCgvKiBAX19QVVJFX18gKi8gby5jcmVhdGVDb250ZXh0KG51bGwpKTtcbmNsYXNzIG0gZXh0ZW5kcyBvLkNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIG8uY3JlYXRlRWxlbWVudChhLlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLl9yZWFjdEludGVybmFscyB9LCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfVxufVxuZnVuY3Rpb24gYygpIHtcbiAgY29uc3QgZSA9IG8udXNlQ29udGV4dChhKTtcbiAgaWYgKGUgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIml0cy1maW5lOiB1c2VGaWJlciBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYSA8RmliZXJQcm92aWRlciAvPiFcIik7XG4gIGNvbnN0IHQgPSBvLnVzZUlkKCk7XG4gIHJldHVybiBvLnVzZU1lbW8oKCkgPT4ge1xuICAgIGZvciAoY29uc3QgbiBvZiBbZSwgZSA9PSBudWxsID8gdm9pZCAwIDogZS5hbHRlcm5hdGVdKSB7XG4gICAgICBpZiAoIW4pIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdSA9IGkobiwgITEsIChkKSA9PiB7XG4gICAgICAgIGxldCBzID0gZC5tZW1vaXplZFN0YXRlO1xuICAgICAgICBmb3IgKDsgczsgKSB7XG4gICAgICAgICAgaWYgKHMubWVtb2l6ZWRTdGF0ZSA9PT0gdCkgcmV0dXJuICEwO1xuICAgICAgICAgIHMgPSBzLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHUpIHJldHVybiB1O1xuICAgIH1cbiAgfSwgW2UsIHRdKTtcbn1cbmZ1bmN0aW9uIHcoKSB7XG4gIGNvbnN0IGUgPSBjKCksIHQgPSBvLnVzZU1lbW8oXG4gICAgKCkgPT4gaShlLCAhMCwgKHIpID0+IHtcbiAgICAgIHZhciBuO1xuICAgICAgcmV0dXJuICgobiA9IHIuc3RhdGVOb2RlKSA9PSBudWxsID8gdm9pZCAwIDogbi5jb250YWluZXJJbmZvKSAhPSBudWxsO1xuICAgIH0pLFxuICAgIFtlXVxuICApO1xuICByZXR1cm4gdCA9PSBudWxsID8gdm9pZCAwIDogdC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbn1cbmZ1bmN0aW9uIHYoZSkge1xuICBjb25zdCB0ID0gYygpLCByID0gby51c2VSZWYodm9pZCAwKTtcbiAgcmV0dXJuIGYoKCkgPT4ge1xuICAgIHZhciBuO1xuICAgIHIuY3VycmVudCA9IChuID0gaShcbiAgICAgIHQsXG4gICAgICAhMSxcbiAgICAgICh1KSA9PiB0eXBlb2YgdS50eXBlID09IFwic3RyaW5nXCIgJiYgKGUgPT09IHZvaWQgMCB8fCB1LnR5cGUgPT09IGUpXG4gICAgKSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uc3RhdGVOb2RlO1xuICB9LCBbdF0pLCByO1xufVxuZnVuY3Rpb24geShlKSB7XG4gIGNvbnN0IHQgPSBjKCksIHIgPSBvLnVzZVJlZih2b2lkIDApO1xuICByZXR1cm4gZigoKSA9PiB7XG4gICAgdmFyIG47XG4gICAgci5jdXJyZW50ID0gKG4gPSBpKFxuICAgICAgdCxcbiAgICAgICEwLFxuICAgICAgKHUpID0+IHR5cGVvZiB1LnR5cGUgPT0gXCJzdHJpbmdcIiAmJiAoZSA9PT0gdm9pZCAwIHx8IHUudHlwZSA9PT0gZSlcbiAgICApKSA9PSBudWxsID8gdm9pZCAwIDogbi5zdGF0ZU5vZGU7XG4gIH0sIFt0XSksIHI7XG59XG5jb25zdCBwID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIGIgPSAoZSkgPT4gZSAhPT0gbnVsbCAmJiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIFwiJCR0eXBlb2ZcIiBpbiBlICYmIGUuJCR0eXBlb2YgPT09IHA7XG5mdW5jdGlvbiBoKCkge1xuICBjb25zdCBlID0gYygpLCBbdF0gPSBvLnVzZVN0YXRlKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICB0LmNsZWFyKCk7XG4gIGxldCByID0gZTtcbiAgZm9yICg7IHI7ICkge1xuICAgIGNvbnN0IG4gPSByLnR5cGU7XG4gICAgYihuKSAmJiBuICE9PSBhICYmICF0LmhhcyhuKSAmJiB0LnNldChuLCBvLnVzZShsKG4pKSksIHIgPSByLnJldHVybjtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIHgoKSB7XG4gIGNvbnN0IGUgPSBoKCk7XG4gIHJldHVybiBvLnVzZU1lbW8oXG4gICAgKCkgPT4gQXJyYXkuZnJvbShlLmtleXMoKSkucmVkdWNlKFxuICAgICAgKHQsIHIpID0+IChuKSA9PiAvKiBAX19QVVJFX18gKi8gby5jcmVhdGVFbGVtZW50KHQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBvLmNyZWF0ZUVsZW1lbnQoci5Qcm92aWRlciwgeyAuLi5uLCB2YWx1ZTogZS5nZXQocikgfSkpLFxuICAgICAgKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBvLmNyZWF0ZUVsZW1lbnQobSwgeyAuLi50IH0pXG4gICAgKSxcbiAgICBbZV1cbiAgKTtcbn1cbmV4cG9ydCB7XG4gIG0gYXMgRmliZXJQcm92aWRlcixcbiAgaSBhcyB0cmF2ZXJzZUZpYmVyLFxuICB3IGFzIHVzZUNvbnRhaW5lcixcbiAgeCBhcyB1c2VDb250ZXh0QnJpZGdlLFxuICBoIGFzIHVzZUNvbnRleHRNYXAsXG4gIGMgYXMgdXNlRmliZXIsXG4gIHYgYXMgdXNlTmVhcmVzdENoaWxkLFxuICB5IGFzIHVzZU5lYXJlc3RQYXJlbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/its-fine/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/atom.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/atom.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: () => (/* binding */ __iconNode),\n/* harmony export */   \"default\": () => (/* binding */ Atom)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.525.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"12\",\n            r: \"1\",\n            key: \"41hilf\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M20.2 20.2c2.04-2.03.02-7.36-4.5-11.9-4.54-4.52-9.87-6.54-11.9-4.5-2.04 2.03-.02 7.36 4.5 11.9 4.54 4.52 9.87 6.54 11.9 4.5Z\",\n            key: \"1l2ple\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M15.7 15.7c4.52-4.54 6.54-9.87 4.5-11.9-2.03-2.04-7.36-.02-11.9 4.5-4.52 4.54-6.54 9.87-4.5 11.9 2.03 2.04 7.36.02 11.9-4.5Z\",\n            key: \"1wam0m\"\n        }\n    ]\n];\nconst Atom = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"atom\", __iconNode);\n //# sourceMappingURL=atom.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvYXRvbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFHTyxNQUFNLFVBQXVCO0lBQ2xDO1FBQUMsUUFBVTtRQUFBO1lBQUUsRUFBSTtZQUFNLENBQUksUUFBTTtZQUFBLENBQUc7WUFBSyxHQUFLO1FBQUEsQ0FBVTtLQUFBO0lBQ3hEO1FBQ0U7UUFDQTtZQUNFLENBQUc7WUFDSCxHQUFLO1FBQUE7S0FFVDtJQUNBO1FBQ0U7UUFDQTtZQUNFLENBQUc7WUFDSCxHQUFLO1FBQUE7S0FDUDtDQUVKO0FBYU0sV0FBTyxrRUFBaUIsU0FBUSxDQUFVIiwic291cmNlcyI6WyIvc3JjL2ljb25zL2F0b20udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbic7XG5pbXBvcnQgeyBJY29uTm9kZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IF9faWNvbk5vZGU6IEljb25Ob2RlID0gW1xuICBbJ2NpcmNsZScsIHsgY3g6ICcxMicsIGN5OiAnMTInLCByOiAnMScsIGtleTogJzQxaGlsZicgfV0sXG4gIFtcbiAgICAncGF0aCcsXG4gICAge1xuICAgICAgZDogJ00yMC4yIDIwLjJjMi4wNC0yLjAzLjAyLTcuMzYtNC41LTExLjktNC41NC00LjUyLTkuODctNi41NC0xMS45LTQuNS0yLjA0IDIuMDMtLjAyIDcuMzYgNC41IDExLjkgNC41NCA0LjUyIDkuODcgNi41NCAxMS45IDQuNVonLFxuICAgICAga2V5OiAnMWwycGxlJyxcbiAgICB9LFxuICBdLFxuICBbXG4gICAgJ3BhdGgnLFxuICAgIHtcbiAgICAgIGQ6ICdNMTUuNyAxNS43YzQuNTItNC41NCA2LjU0LTkuODcgNC41LTExLjktMi4wMy0yLjA0LTcuMzYtLjAyLTExLjkgNC41LTQuNTIgNC41NC02LjU0IDkuODctNC41IDExLjkgMi4wMyAyLjA0IDcuMzYuMDIgMTEuOS00LjVaJyxcbiAgICAgIGtleTogJzF3YW0wbScsXG4gICAgfSxcbiAgXSxcbl07XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBBdG9tXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThZMmx5WTJ4bElHTjRQU0l4TWlJZ1kzazlJakV5SWlCeVBTSXhJaUF2UGdvZ0lEeHdZWFJvSUdROUlrMHlNQzR5SURJd0xqSmpNaTR3TkMweUxqQXpMakF5TFRjdU16WXROQzQxTFRFeExqa3ROQzQxTkMwMExqVXlMVGt1T0RjdE5pNDFOQzB4TVM0NUxUUXVOUzB5TGpBMElESXVNRE10TGpBeUlEY3VNellnTkM0MUlERXhMamtnTkM0MU5DQTBMalV5SURrdU9EY2dOaTQxTkNBeE1TNDVJRFF1TlZvaUlDOCtDaUFnUEhCaGRHZ2daRDBpVFRFMUxqY2dNVFV1TjJNMExqVXlMVFF1TlRRZ05pNDFOQzA1TGpnM0lEUXVOUzB4TVM0NUxUSXVNRE10TWk0d05DMDNMak0yTFM0d01pMHhNUzQ1SURRdU5TMDBMalV5SURRdU5UUXROaTQxTkNBNUxqZzNMVFF1TlNBeE1TNDVJREl1TURNZ01pNHdOQ0EzTGpNMkxqQXlJREV4TGprdE5DNDFXaUlnTHo0S1BDOXpkbWMrQ2c9PSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvYXRvbVxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IEF0b20gPSBjcmVhdGVMdWNpZGVJY29uKCdhdG9tJywgX19pY29uTm9kZSk7XG5cbmV4cG9ydCBkZWZhdWx0IEF0b207XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/atom.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/droplets.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/droplets.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: () => (/* binding */ __iconNode),\n/* harmony export */   \"default\": () => (/* binding */ Droplets)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.525.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M7 16.3c2.2 0 4-1.83 4-4.05 0-1.16-.57-2.26-1.71-3.19S7.29 6.75 7 5.3c-.29 1.45-1.14 2.84-2.29 3.76S3 11.1 3 12.25c0 2.22 1.8 4.05 4 4.05z\",\n            key: \"1ptgy4\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M12.56 6.6A10.97 10.97 0 0 0 14 3.02c.5 2.5 2 4.9 4 6.5s3 3.5 3 5.5a6.98 6.98 0 0 1-11.91 4.97\",\n            key: \"1sl1rz\"\n        }\n    ]\n];\nconst Droplets = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"droplets\", __iconNode);\n //# sourceMappingURL=droplets.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvZHJvcGxldHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR08sTUFBTSxVQUF1QjtJQUNsQztRQUNFO1FBQ0E7WUFDRSxDQUFHO1lBQ0gsR0FBSztRQUFBO0tBRVQ7SUFDQTtRQUNFO1FBQ0E7WUFDRSxDQUFHO1lBQ0gsR0FBSztRQUFBO0tBQ1A7Q0FFSjtBQWFNLGVBQVcsa0VBQWlCLGFBQVksQ0FBVSIsInNvdXJjZXMiOlsiL3NyYy9pY29ucy9kcm9wbGV0cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcbmltcG9ydCB7IEljb25Ob2RlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgX19pY29uTm9kZTogSWNvbk5vZGUgPSBbXG4gIFtcbiAgICAncGF0aCcsXG4gICAge1xuICAgICAgZDogJ003IDE2LjNjMi4yIDAgNC0xLjgzIDQtNC4wNSAwLTEuMTYtLjU3LTIuMjYtMS43MS0zLjE5UzcuMjkgNi43NSA3IDUuM2MtLjI5IDEuNDUtMS4xNCAyLjg0LTIuMjkgMy43NlMzIDExLjEgMyAxMi4yNWMwIDIuMjIgMS44IDQuMDUgNCA0LjA1eicsXG4gICAgICBrZXk6ICcxcHRneTQnLFxuICAgIH0sXG4gIF0sXG4gIFtcbiAgICAncGF0aCcsXG4gICAge1xuICAgICAgZDogJ00xMi41NiA2LjZBMTAuOTcgMTAuOTcgMCAwIDAgMTQgMy4wMmMuNSAyLjUgMiA0LjkgNCA2LjVzMyAzLjUgMyA1LjVhNi45OCA2Ljk4IDAgMCAxLTExLjkxIDQuOTcnLFxuICAgICAga2V5OiAnMXNsMXJ6JyxcbiAgICB9LFxuICBdLFxuXTtcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIERyb3BsZXRzXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5OeUF4Tmk0ell6SXVNaUF3SURRdE1TNDRNeUEwTFRRdU1EVWdNQzB4TGpFMkxTNDFOeTB5TGpJMkxURXVOekV0TXk0eE9WTTNMakk1SURZdU56VWdOeUExTGpOakxTNHlPU0F4TGpRMUxURXVNVFFnTWk0NE5DMHlMakk1SURNdU56WlRNeUF4TVM0eElETWdNVEl1TWpWak1DQXlMakl5SURFdU9DQTBMakExSURRZ05DNHdOWG9pSUM4K0NpQWdQSEJoZEdnZ1pEMGlUVEV5TGpVMklEWXVOa0V4TUM0NU55QXhNQzQ1TnlBd0lEQWdNQ0F4TkNBekxqQXlZeTQxSURJdU5TQXlJRFF1T1NBMElEWXVOWE16SURNdU5TQXpJRFV1TldFMkxqazRJRFl1T1RnZ01DQXdJREV0TVRFdU9URWdOQzQ1TnlJZ0x6NEtQQzl6ZG1jK0NnPT0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2Ryb3BsZXRzXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgRHJvcGxldHMgPSBjcmVhdGVMdWNpZGVJY29uKCdkcm9wbGV0cycsIF9faWNvbk5vZGUpO1xuXG5leHBvcnQgZGVmYXVsdCBEcm9wbGV0cztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/droplets.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/gauge.js":
/*!***********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/gauge.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: () => (/* binding */ __iconNode),\n/* harmony export */   \"default\": () => (/* binding */ Gauge)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.525.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"m12 14 4-4\",\n            key: \"9kzdfg\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M3.34 19a10 10 0 1 1 17.32 0\",\n            key: \"19p75a\"\n        }\n    ]\n];\nconst Gauge = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"gauge\", __iconNode);\n //# sourceMappingURL=gauge.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvZ2F1Z2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR08sTUFBTSxVQUF1QjtJQUNsQztRQUFDLE1BQVE7UUFBQTtZQUFFLEdBQUcsQ0FBYztZQUFBLEtBQUs7UUFBQSxDQUFVO0tBQUE7SUFDM0M7UUFBQyxDQUFRO1FBQUEsQ0FBRTtZQUFBLEVBQUcsK0JBQWdDO1lBQUEsSUFBSztRQUFVO0tBQUE7Q0FDL0Q7QUFhTSxZQUFRLGtFQUFpQixVQUFTLENBQVUiLCJzb3VyY2VzIjpbIi9zcmMvaWNvbnMvZ2F1Z2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbic7XG5pbXBvcnQgeyBJY29uTm9kZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IF9faWNvbk5vZGU6IEljb25Ob2RlID0gW1xuICBbJ3BhdGgnLCB7IGQ6ICdtMTIgMTQgNC00Jywga2V5OiAnOWt6ZGZnJyB9XSxcbiAgWydwYXRoJywgeyBkOiAnTTMuMzQgMTlhMTAgMTAgMCAxIDEgMTcuMzIgMCcsIGtleTogJzE5cDc1YScgfV0sXG5dO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgR2F1Z2VcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKdE1USWdNVFFnTkMwMElpQXZQZ29nSUR4d1lYUm9JR1E5SWswekxqTTBJREU1WVRFd0lERXdJREFnTVNBeElERTNMak15SURBaUlDOCtDand2YzNablBnbz0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2dhdWdlXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgR2F1Z2UgPSBjcmVhdGVMdWNpZGVJY29uKCdnYXVnZScsIF9faWNvbk5vZGUpO1xuXG5leHBvcnQgZGVmYXVsdCBHYXVnZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/gauge.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mountain.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/mountain.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: () => (/* binding */ __iconNode),\n/* harmony export */   \"default\": () => (/* binding */ Mountain)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.525.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"m8 3 4 8 5-5 5 15H2L8 3z\",\n            key: \"otkl63\"\n        }\n    ]\n];\nconst Mountain = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"mountain\", __iconNode);\n //# sourceMappingURL=mountain.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvbW91bnRhaW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR2EsbUJBQXVCO0lBQUM7UUFBQyxNQUFRO1FBQUE7WUFBRSxHQUFHLDBCQUE0QjtZQUFBLElBQUssU0FBUztRQUFBLENBQUM7S0FBQztDQUFBO0FBYXpGLGVBQVcsa0VBQWlCLGFBQVksQ0FBVSIsInNvdXJjZXMiOlsiL3NyYy9pY29ucy9tb3VudGFpbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcbmltcG9ydCB7IEljb25Ob2RlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgX19pY29uTm9kZTogSWNvbk5vZGUgPSBbWydwYXRoJywgeyBkOiAnbTggMyA0IDggNS01IDUgMTVIMkw4IDN6Jywga2V5OiAnb3RrbDYzJyB9XV07XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBNb3VudGFpblxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0p0T0NBeklEUWdPQ0ExTFRVZ05TQXhOVWd5VERnZ00zb2lJQzgrQ2p3dmMzWm5QZ289KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9tb3VudGFpblxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IE1vdW50YWluID0gY3JlYXRlTHVjaWRlSWNvbignbW91bnRhaW4nLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IGRlZmF1bHQgTW91bnRhaW47XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mountain.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/thermometer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/thermometer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: () => (/* binding */ __iconNode),\n/* harmony export */   \"default\": () => (/* binding */ Thermometer)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.525.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z\",\n            key: \"17jzev\"\n        }\n    ]\n];\nconst Thermometer = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"thermometer\", __iconNode);\n //# sourceMappingURL=thermometer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvdGhlcm1vbWV0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR08sTUFBTSxVQUF1QjtJQUNsQztRQUFDLENBQVE7UUFBQSxDQUFFO1lBQUEsRUFBRyw2Q0FBOEM7WUFBQSxJQUFLO1FBQVU7S0FBQTtDQUM3RTtBQWFNLGtCQUFjLGtFQUFpQixnQkFBZSxDQUFVIiwic291cmNlcyI6WyIvc3JjL2ljb25zL3RoZXJtb21ldGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuaW1wb3J0IHsgSWNvbk5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBfX2ljb25Ob2RlOiBJY29uTm9kZSA9IFtcbiAgWydwYXRoJywgeyBkOiAnTTE0IDR2MTAuNTRhNCA0IDAgMSAxLTQgMFY0YTIgMiAwIDAgMSA0IDBaJywga2V5OiAnMTdqemV2JyB9XSxcbl07XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBUaGVybW9tZXRlclxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTVRRZ05IWXhNQzQxTkdFMElEUWdNQ0F4SURFdE5DQXdWalJoTWlBeUlEQWdNQ0F4SURRZ01Gb2lJQzgrQ2p3dmMzWm5QZ289KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy90aGVybW9tZXRlclxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IFRoZXJtb21ldGVyID0gY3JlYXRlTHVjaWRlSWNvbigndGhlcm1vbWV0ZXInLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IGRlZmF1bHQgVGhlcm1vbWV0ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/thermometer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/tree-pine.js":
/*!***************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/tree-pine.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: () => (/* binding */ __iconNode),\n/* harmony export */   \"default\": () => (/* binding */ TreePine)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.525.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"m17 14 3 3.3a1 1 0 0 1-.7 1.7H4.7a1 1 0 0 1-.7-1.7L7 14h-.3a1 1 0 0 1-.7-1.7L9 9h-.2A1 1 0 0 1 8 7.3L12 3l4 4.3a1 1 0 0 1-.8 1.7H15l3 3.3a1 1 0 0 1-.7 1.7H17Z\",\n            key: \"cpyugq\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M12 22v-3\",\n            key: \"kmzjlo\"\n        }\n    ]\n];\nconst TreePine = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"tree-pine\", __iconNode);\n //# sourceMappingURL=tree-pine.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvdHJlZS1waW5lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUdPLE1BQU0sVUFBdUI7SUFDbEM7UUFDRTtRQUNBO1lBQ0UsQ0FBRztZQUNILEdBQUs7UUFBQTtLQUVUO0lBQ0E7UUFBQyxDQUFRO1FBQUEsQ0FBRTtZQUFBLEVBQUcsWUFBYTtZQUFBLElBQUs7UUFBVTtLQUFBO0NBQzVDO0FBYU0sZUFBVyxrRUFBaUIsY0FBYSxDQUFVIiwic291cmNlcyI6WyIvc3JjL2ljb25zL3RyZWUtcGluZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcbmltcG9ydCB7IEljb25Ob2RlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgX19pY29uTm9kZTogSWNvbk5vZGUgPSBbXG4gIFtcbiAgICAncGF0aCcsXG4gICAge1xuICAgICAgZDogJ20xNyAxNCAzIDMuM2ExIDEgMCAwIDEtLjcgMS43SDQuN2ExIDEgMCAwIDEtLjctMS43TDcgMTRoLS4zYTEgMSAwIDAgMS0uNy0xLjdMOSA5aC0uMkExIDEgMCAwIDEgOCA3LjNMMTIgM2w0IDQuM2ExIDEgMCAwIDEtLjggMS43SDE1bDMgMy4zYTEgMSAwIDAgMS0uNyAxLjdIMTdaJyxcbiAgICAgIGtleTogJ2NweXVncScsXG4gICAgfSxcbiAgXSxcbiAgWydwYXRoJywgeyBkOiAnTTEyIDIydi0zJywga2V5OiAna216amxvJyB9XSxcbl07XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBUcmVlUGluZVxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0p0TVRjZ01UUWdNeUF6TGpOaE1TQXhJREFnTUNBeExTNDNJREV1TjBnMExqZGhNU0F4SURBZ01DQXhMUzQzTFRFdU4wdzNJREUwYUMwdU0yRXhJREVnTUNBd0lERXRMamN0TVM0M1REa2dPV2d0TGpKQk1TQXhJREFnTUNBeElEZ2dOeTR6VERFeUlETnNOQ0EwTGpOaE1TQXhJREFnTUNBeExTNDRJREV1TjBneE5Xd3pJRE11TTJFeElERWdNQ0F3SURFdExqY2dNUzQzU0RFM1dpSWdMejRLSUNBOGNHRjBhQ0JrUFNKTk1USWdNakoyTFRNaUlDOCtDand2YzNablBnbz0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL3RyZWUtcGluZVxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IFRyZWVQaW5lID0gY3JlYXRlTHVjaWRlSWNvbigndHJlZS1waW5lJywgX19pY29uTm9kZSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRyZWVQaW5lO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/tree-pine.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/wind.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/wind.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: () => (/* binding */ __iconNode),\n/* harmony export */   \"default\": () => (/* binding */ Wind)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.525.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M12.8 19.6A2 2 0 1 0 14 16H2\",\n            key: \"148xed\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M17.5 8a2.5 2.5 0 1 1 2 4H2\",\n            key: \"1u4tom\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M9.8 4.4A2 2 0 1 1 11 8H2\",\n            key: \"75valh\"\n        }\n    ]\n];\nconst Wind = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"wind\", __iconNode);\n //# sourceMappingURL=wind.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvd2luZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFHTyxNQUFNLFVBQXVCO0lBQ2xDO1FBQUMsTUFBUTtRQUFBO1lBQUUsR0FBRyxDQUFnQztZQUFBLEtBQUs7UUFBQSxDQUFVO0tBQUE7SUFDN0Q7UUFBQyxNQUFRO1FBQUE7WUFBRSxHQUFHLENBQStCO1lBQUEsS0FBSztRQUFBLENBQVU7S0FBQTtJQUM1RDtRQUFDLENBQVE7UUFBQSxDQUFFO1lBQUEsRUFBRyw0QkFBNkI7WUFBQSxJQUFLO1FBQVU7S0FBQTtDQUM1RDtBQWFNLFdBQU8sa0VBQWlCLFNBQVEsQ0FBVSIsInNvdXJjZXMiOlsiL3NyYy9pY29ucy93aW5kLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuaW1wb3J0IHsgSWNvbk5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBfX2ljb25Ob2RlOiBJY29uTm9kZSA9IFtcbiAgWydwYXRoJywgeyBkOiAnTTEyLjggMTkuNkEyIDIgMCAxIDAgMTQgMTZIMicsIGtleTogJzE0OHhlZCcgfV0sXG4gIFsncGF0aCcsIHsgZDogJ00xNy41IDhhMi41IDIuNSAwIDEgMSAyIDRIMicsIGtleTogJzF1NHRvbScgfV0sXG4gIFsncGF0aCcsIHsgZDogJ005LjggNC40QTIgMiAwIDEgMSAxMSA4SDInLCBrZXk6ICc3NXZhbGgnIH1dLFxuXTtcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIFdpbmRcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKTk1USXVPQ0F4T1M0MlFUSWdNaUF3SURFZ01DQXhOQ0F4TmtneUlpQXZQZ29nSUR4d1lYUm9JR1E5SWsweE55NDFJRGhoTWk0MUlESXVOU0F3SURFZ01TQXlJRFJJTWlJZ0x6NEtJQ0E4Y0dGMGFDQmtQU0pOT1M0NElEUXVORUV5SURJZ01DQXhJREVnTVRFZ09FZ3lJaUF2UGdvOEwzTjJaejRLKSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy93aW5kXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgV2luZCA9IGNyZWF0ZUx1Y2lkZUljb24oJ3dpbmQnLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IGRlZmF1bHQgV2luZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/wind.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/zap.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/zap.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: () => (/* binding */ __iconNode),\n/* harmony export */   \"default\": () => (/* binding */ Zap)\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.525.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z\",\n            key: \"1xq2db\"\n        }\n    ]\n];\nconst Zap = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"zap\", __iconNode);\n //# sourceMappingURL=zap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvemFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUdPLE1BQU0sVUFBdUI7SUFDbEM7UUFDRTtRQUNBO1lBQ0UsQ0FBRztZQUNILEdBQUs7UUFBQTtLQUNQO0NBRUo7QUFhTSxVQUFNLGtFQUFpQixRQUFPLENBQVUiLCJzb3VyY2VzIjpbIi9zcmMvaWNvbnMvemFwLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuaW1wb3J0IHsgSWNvbk5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBfX2ljb25Ob2RlOiBJY29uTm9kZSA9IFtcbiAgW1xuICAgICdwYXRoJyxcbiAgICB7XG4gICAgICBkOiAnTTQgMTRhMSAxIDAgMCAxLS43OC0xLjYzbDkuOS0xMC4yYS41LjUgMCAwIDEgLjg2LjQ2bC0xLjkyIDYuMDJBMSAxIDAgMCAwIDEzIDEwaDdhMSAxIDAgMCAxIC43OCAxLjYzbC05LjkgMTAuMmEuNS41IDAgMCAxLS44Ni0uNDZsMS45Mi02LjAyQTEgMSAwIDAgMCAxMSAxNHonLFxuICAgICAga2V5OiAnMXhxMmRiJyxcbiAgICB9LFxuICBdLFxuXTtcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIFphcFxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTkNBeE5HRXhJREVnTUNBd0lERXRMamM0TFRFdU5qTnNPUzQ1TFRFd0xqSmhMalV1TlNBd0lEQWdNU0F1T0RZdU5EWnNMVEV1T1RJZ05pNHdNa0V4SURFZ01DQXdJREFnTVRNZ01UQm9OMkV4SURFZ01DQXdJREVnTGpjNElERXVOak5zTFRrdU9TQXhNQzR5WVM0MUxqVWdNQ0F3SURFdExqZzJMUzQwTm13eExqa3lMVFl1TURKQk1TQXhJREFnTUNBd0lERXhJREUwZWlJZ0x6NEtQQzl6ZG1jK0NnPT0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL3phcFxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IFphcCA9IGNyZWF0ZUx1Y2lkZUljb24oJ3phcCcsIF9faWNvbk5vZGUpO1xuXG5leHBvcnQgZGVmYXVsdCBaYXA7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/zap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/compiled/client-only/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {



/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  ((exports.ConcurrentRoot = 1),\n  (exports.ContinuousEventPriority = 8),\n  (exports.DefaultEventPriority = 32),\n  (exports.DiscreteEventPriority = 2),\n  (exports.IdleEventPriority = 268435456),\n  (exports.LegacyRoot = 0),\n  (exports.NoEventPriority = 0));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQyxJQUFJLHNCQUFzQjtBQUMxQixHQUFHLCtCQUErQjtBQUNsQyxHQUFHLDRCQUE0QjtBQUMvQixHQUFHLDZCQUE2QjtBQUNoQyxHQUFHLHlCQUF5QjtBQUM1QixHQUFHLGtCQUFrQjtBQUNyQixHQUFHLHVCQUF1QiIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoKGV4cG9ydHMuQ29uY3VycmVudFJvb3QgPSAxKSxcbiAgKGV4cG9ydHMuQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSA4KSxcbiAgKGV4cG9ydHMuRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSAzMiksXG4gIChleHBvcnRzLkRpc2NyZXRlRXZlbnRQcmlvcml0eSA9IDIpLFxuICAoZXhwb3J0cy5JZGxlRXZlbnRQcmlvcml0eSA9IDI2ODQzNTQ1NiksXG4gIChleHBvcnRzLkxlZ2FjeVJvb3QgPSAwKSxcbiAgKGV4cG9ydHMuTm9FdmVudFByaW9yaXR5ID0gMCkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \n true && (module.exports = function($$$config) {\n    var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$();\n    function findHook(fiber, id) {\n        for(fiber = fiber.memoizedState; null !== fiber && 0 < id;)fiber = fiber.next, id--;\n        return fiber;\n    }\n    function copyWithSetImpl(obj, path, index, value) {\n        if (index >= path.length) return value;\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n        return updated;\n    }\n    function copyWithRename(obj, oldPath, newPath) {\n        if (oldPath.length !== newPath.length) console.warn(\"copyWithRename() expects paths of the same length\");\n        else {\n            for(var i = 0; i < newPath.length - 1; i++)if (oldPath[i] !== newPath[i]) {\n                console.warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                return;\n            }\n            return copyWithRenameImpl(obj, oldPath, newPath, 0);\n        }\n    }\n    function copyWithRenameImpl(obj, oldPath, newPath, index) {\n        var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n        return updated;\n    }\n    function copyWithDeleteImpl(obj, path, index) {\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        if (index + 1 === path.length) return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;\n        updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n        return updated;\n    }\n    function shouldSuspendImpl() {\n        return !1;\n    }\n    function shouldErrorImpl() {\n        return null;\n    }\n    function createFiber(tag, pendingProps, key, mode) {\n        return new FiberNode(tag, pendingProps, key, mode);\n    }\n    function scheduleRoot(root, element) {\n        root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork());\n    }\n    function scheduleRefresh(root, update) {\n        if (null !== resolveFamily) {\n            var staleFamilies = update.staleFamilies;\n            update = update.updatedFamilies;\n            flushPassiveEffects();\n            scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);\n            flushSyncWork();\n        }\n    }\n    function setRefreshHandler(handler) {\n        resolveFamily = handler;\n    }\n    function warnInvalidHookAccess() {\n        console.error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\");\n    }\n    function warnInvalidContextAccess() {\n        console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n    }\n    function noop() {}\n    function warnForMissingKey() {}\n    function setToSortedString(set) {\n        var array = [];\n        set.forEach(function(value) {\n            array.push(value);\n        });\n        return array.sort().join(\", \");\n    }\n    function getIteratorFn(maybeIterable) {\n        if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[\"@@iterator\"];\n        return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function getComponentNameFromType(type) {\n        if (null == type) return null;\n        if (\"function\" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;\n        if (\"string\" === typeof type) return type;\n        switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n                return \"Portal\";\n            case REACT_PROFILER_TYPE:\n                return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n                return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n                return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n                return \"SuspenseList\";\n        }\n        if (\"object\" === typeof type) switch(\"number\" === typeof type.tag && console.error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), type.$$typeof){\n            case REACT_CONTEXT_TYPE:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case REACT_CONSUMER_TYPE:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case REACT_FORWARD_REF_TYPE:\n                var innerType = type.render;\n                type = type.displayName;\n                type || (type = innerType.displayName || innerType.name || \"\", type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\");\n                return type;\n            case REACT_MEMO_TYPE:\n                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || \"Memo\";\n            case REACT_LAZY_TYPE:\n                innerType = type._payload;\n                type = type._init;\n                try {\n                    return getComponentNameFromType(type(innerType));\n                } catch (x) {}\n        }\n        return null;\n    }\n    function getComponentNameFromFiber(fiber) {\n        var type = fiber.type;\n        switch(fiber.tag){\n            case 24:\n                return \"Cache\";\n            case 9:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case 10:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case 18:\n                return \"DehydratedFragment\";\n            case 11:\n                return fiber = type.render, fiber = fiber.displayName || fiber.name || \"\", type.displayName || (\"\" !== fiber ? \"ForwardRef(\" + fiber + \")\" : \"ForwardRef\");\n            case 7:\n                return \"Fragment\";\n            case 26:\n            case 27:\n            case 5:\n                return type;\n            case 4:\n                return \"Portal\";\n            case 3:\n                return \"Root\";\n            case 6:\n                return \"Text\";\n            case 16:\n                return getComponentNameFromType(type);\n            case 8:\n                return type === REACT_STRICT_MODE_TYPE ? \"StrictMode\" : \"Mode\";\n            case 22:\n                return \"Offscreen\";\n            case 12:\n                return \"Profiler\";\n            case 21:\n                return \"Scope\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 25:\n                return \"TracingMarker\";\n            case 1:\n            case 0:\n            case 14:\n            case 15:\n                if (\"function\" === typeof type) return type.displayName || type.name || null;\n                if (\"string\" === typeof type) return type;\n                break;\n            case 29:\n                type = fiber._debugInfo;\n                if (null != type) {\n                    for(var i = type.length - 1; 0 <= i; i--)if (\"string\" === typeof type[i].name) return type[i].name;\n                }\n                if (null !== fiber.return) return getComponentNameFromFiber(fiber.return);\n        }\n        return null;\n    }\n    function disabledLog() {}\n    function disableLogs() {\n        if (0 === disabledDepth) {\n            prevLog = console.log;\n            prevInfo = console.info;\n            prevWarn = console.warn;\n            prevError = console.error;\n            prevGroup = console.group;\n            prevGroupCollapsed = console.groupCollapsed;\n            prevGroupEnd = console.groupEnd;\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                value: disabledLog,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n            });\n        }\n        disabledDepth++;\n    }\n    function reenableLogs() {\n        disabledDepth--;\n        if (0 === disabledDepth) {\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                log: assign({}, props, {\n                    value: prevLog\n                }),\n                info: assign({}, props, {\n                    value: prevInfo\n                }),\n                warn: assign({}, props, {\n                    value: prevWarn\n                }),\n                error: assign({}, props, {\n                    value: prevError\n                }),\n                group: assign({}, props, {\n                    value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                    value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                    value: prevGroupEnd\n                })\n            });\n        }\n        0 > disabledDepth && console.error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n    }\n    function describeBuiltInComponentFrame(name) {\n        if (void 0 === prefix) try {\n            throw Error();\n        } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || \"\";\n            suffix = -1 < x.stack.indexOf(\"\\n    at\") ? \" (<anonymous>)\" : -1 < x.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n        }\n        return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n        if (!fn || reentry) return \"\";\n        var frame = componentFrameCache.get(fn);\n        if (void 0 !== frame) return frame;\n        reentry = !0;\n        frame = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        var previousDispatcher = null;\n        previousDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = null;\n        disableLogs();\n        try {\n            var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    try {\n                        if (construct) {\n                            var Fake = function() {\n                                throw Error();\n                            };\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    throw Error();\n                                }\n                            });\n                            if (\"object\" === typeof Reflect && Reflect.construct) {\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    var control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x$0) {\n                                    control = x$0;\n                                }\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x$1) {\n                                control = x$1;\n                            }\n                            (Fake = fn()) && \"function\" === typeof Fake.catch && Fake.catch(function() {});\n                        }\n                    } catch (sample) {\n                        if (sample && control && \"string\" === typeof sample.stack) return [\n                            sample.stack,\n                            control.stack\n                        ];\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            };\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\");\n            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, \"name\", {\n                value: \"DetermineComponentFrameRoot\"\n            });\n            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n            if (sampleStack && controlStack) {\n                var sampleLines = sampleStack.split(\"\\n\"), controlLines = controlStack.split(\"\\n\");\n                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(\"DetermineComponentFrameRoot\");)namePropDescriptor++;\n                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(\"DetermineComponentFrameRoot\");)_RunInRootFrame$Deter++;\n                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;\n                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                            var _frame = \"\\n\" + sampleLines[namePropDescriptor].replace(\" at new \", \" at \");\n                            fn.displayName && _frame.includes(\"<anonymous>\") && (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                            \"function\" === typeof fn && componentFrameCache.set(fn, _frame);\n                            return _frame;\n                        }\n                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n                    }\n                    break;\n                }\n            }\n        } finally{\n            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;\n        }\n        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\") ? describeBuiltInComponentFrame(sampleLines) : \"\";\n        \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n        return sampleLines;\n    }\n    function describeFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return describeBuiltInComponentFrame(fiber.type);\n            case 16:\n                return describeBuiltInComponentFrame(\"Lazy\");\n            case 13:\n                return describeBuiltInComponentFrame(\"Suspense\");\n            case 19:\n                return describeBuiltInComponentFrame(\"SuspenseList\");\n            case 0:\n            case 15:\n                return fiber = describeNativeComponentFrame(fiber.type, !1), fiber;\n            case 11:\n                return fiber = describeNativeComponentFrame(fiber.type.render, !1), fiber;\n            case 1:\n                return fiber = describeNativeComponentFrame(fiber.type, !0), fiber;\n            default:\n                return \"\";\n        }\n    }\n    function getStackByFiberInDevAndProd(workInProgress) {\n        try {\n            var info = \"\";\n            do {\n                info += describeFiber(workInProgress);\n                var debugInfo = workInProgress._debugInfo;\n                if (debugInfo) for(var i = debugInfo.length - 1; 0 <= i; i--){\n                    var entry = debugInfo[i];\n                    if (\"string\" === typeof entry.name) {\n                        var JSCompiler_temp_const = info, env = entry.env;\n                        var JSCompiler_inline_result = describeBuiltInComponentFrame(entry.name + (env ? \" [\" + env + \"]\" : \"\"));\n                        info = JSCompiler_temp_const + JSCompiler_inline_result;\n                    }\n                }\n                workInProgress = workInProgress.return;\n            }while (workInProgress);\n            return info;\n        } catch (x) {\n            return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n    }\n    function getCurrentFiberStackInDev() {\n        return null === current ? \"\" : getStackByFiberInDevAndProd(current);\n    }\n    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {\n        var previousFiber = current;\n        ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;\n        isRendering = !1;\n        current = fiber;\n        try {\n            return callback(arg0, arg1, arg2, arg3, arg4);\n        } finally{\n            current = previousFiber;\n        }\n        throw Error(\"runWithFiberInDEV should never be called in production. This is a bug in React.\");\n    }\n    function getNearestMountedFiber(fiber) {\n        var node = fiber, nearestMounted = fiber;\n        if (fiber.alternate) for(; node.return;)node = node.return;\n        else {\n            fiber = node;\n            do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;\n            while (fiber);\n        }\n        return 3 === node.tag ? nearestMounted : null;\n    }\n    function assertIsMounted(fiber) {\n        if (getNearestMountedFiber(fiber) !== fiber) throw Error(\"Unable to find node on an unmounted component.\");\n    }\n    function findCurrentFiberUsingSlowPath(fiber) {\n        var alternate = fiber.alternate;\n        if (!alternate) {\n            alternate = getNearestMountedFiber(fiber);\n            if (null === alternate) throw Error(\"Unable to find node on an unmounted component.\");\n            return alternate !== fiber ? null : fiber;\n        }\n        for(var a = fiber, b = alternate;;){\n            var parentA = a.return;\n            if (null === parentA) break;\n            var parentB = parentA.alternate;\n            if (null === parentB) {\n                b = parentA.return;\n                if (null !== b) {\n                    a = b;\n                    continue;\n                }\n                break;\n            }\n            if (parentA.child === parentB.child) {\n                for(parentB = parentA.child; parentB;){\n                    if (parentB === a) return assertIsMounted(parentA), fiber;\n                    if (parentB === b) return assertIsMounted(parentA), alternate;\n                    parentB = parentB.sibling;\n                }\n                throw Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.return !== b.return) a = parentA, b = parentB;\n            else {\n                for(var didFindChild = !1, _child = parentA.child; _child;){\n                    if (_child === a) {\n                        didFindChild = !0;\n                        a = parentA;\n                        b = parentB;\n                        break;\n                    }\n                    if (_child === b) {\n                        didFindChild = !0;\n                        b = parentA;\n                        a = parentB;\n                        break;\n                    }\n                    _child = _child.sibling;\n                }\n                if (!didFindChild) {\n                    for(_child = parentB.child; _child;){\n                        if (_child === a) {\n                            didFindChild = !0;\n                            a = parentB;\n                            b = parentA;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = !0;\n                            b = parentB;\n                            a = parentA;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) throw Error(\"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\");\n                }\n            }\n            if (a.alternate !== b) throw Error(\"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        if (3 !== a.tag) throw Error(\"Unable to find node on an unmounted component.\");\n        return a.stateNode.current === a ? fiber : alternate;\n    }\n    function findCurrentHostFiber(parent) {\n        parent = findCurrentFiberUsingSlowPath(parent);\n        return null !== parent ? findCurrentHostFiberImpl(parent) : null;\n    }\n    function findCurrentHostFiberImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            tag = findCurrentHostFiberImpl(node);\n            if (null !== tag) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function findCurrentHostFiberWithNoPortalsImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            if (4 !== node.tag && (tag = findCurrentHostFiberWithNoPortalsImpl(node), null !== tag)) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function createCursor(defaultValue) {\n        return {\n            current: defaultValue\n        };\n    }\n    function pop(cursor, fiber) {\n        0 > index$jscomp$0 ? console.error(\"Unexpected pop.\") : (fiber !== fiberStack[index$jscomp$0] && console.error(\"Unexpected Fiber popped.\"), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);\n    }\n    function push(cursor, value, fiber) {\n        index$jscomp$0++;\n        valueStack[index$jscomp$0] = cursor.current;\n        fiberStack[index$jscomp$0] = fiber;\n        cursor.current = value;\n    }\n    function clz32Fallback(x) {\n        x >>>= 0;\n        return 0 === x ? 32 : 31 - (log$1(x) / LN2 | 0) | 0;\n    }\n    function getLabelForLane(lane) {\n        if (lane & 1) return \"SyncHydrationLane\";\n        if (lane & 2) return \"Sync\";\n        if (lane & 4) return \"InputContinuousHydration\";\n        if (lane & 8) return \"InputContinuous\";\n        if (lane & 16) return \"DefaultHydration\";\n        if (lane & 32) return \"Default\";\n        if (lane & 64) return \"TransitionHydration\";\n        if (lane & 4194176) return \"Transition\";\n        if (lane & 62914560) return \"Retry\";\n        if (lane & 67108864) return \"SelectiveHydration\";\n        if (lane & 134217728) return \"IdleHydration\";\n        if (lane & 268435456) return \"Idle\";\n        if (lane & 536870912) return \"Offscreen\";\n        if (lane & 1073741824) return \"Deferred\";\n    }\n    function getHighestPriorityLanes(lanes) {\n        var pendingSyncLanes = lanes & 42;\n        if (0 !== pendingSyncLanes) return pendingSyncLanes;\n        switch(lanes & -lanes){\n            case 1:\n                return 1;\n            case 2:\n                return 2;\n            case 4:\n                return 4;\n            case 8:\n                return 8;\n            case 16:\n                return 16;\n            case 32:\n                return 32;\n            case 64:\n                return 64;\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return lanes & 4194176;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return lanes & 62914560;\n            case 67108864:\n                return 67108864;\n            case 134217728:\n                return 134217728;\n            case 268435456:\n                return 268435456;\n            case 536870912:\n                return 536870912;\n            case 1073741824:\n                return 0;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), lanes;\n        }\n    }\n    function getNextLanes(root, wipLanes) {\n        var pendingLanes = root.pendingLanes;\n        if (0 === pendingLanes) return 0;\n        var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, warmLanes = root.warmLanes;\n        root = 0 !== root.finishedLanes;\n        var nonIdlePendingLanes = pendingLanes & 134217727;\n        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));\n        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;\n    }\n    function checkIfRootIsPrerendering(root, renderLanes) {\n        return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);\n    }\n    function computeExpirationTime(lane, currentTime) {\n        switch(lane){\n            case 1:\n            case 2:\n            case 4:\n            case 8:\n                return currentTime + 250;\n            case 16:\n            case 32:\n            case 64:\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return currentTime + 5e3;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return -1;\n            case 67108864:\n            case 134217728:\n            case 268435456:\n            case 536870912:\n            case 1073741824:\n                return -1;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), -1;\n        }\n    }\n    function claimNextTransitionLane() {\n        var lane = nextTransitionLane;\n        nextTransitionLane <<= 1;\n        0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);\n        return lane;\n    }\n    function claimNextRetryLane() {\n        var lane = nextRetryLane;\n        nextRetryLane <<= 1;\n        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\n        return lane;\n    }\n    function createLaneMap(initial) {\n        for(var laneMap = [], i = 0; 31 > i; i++)laneMap.push(initial);\n        return laneMap;\n    }\n    function markRootUpdated$1(root, updateLane) {\n        root.pendingLanes |= updateLane;\n        268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);\n    }\n    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        var previouslyPendingLanes = root.pendingLanes;\n        root.pendingLanes = remainingLanes;\n        root.suspendedLanes = 0;\n        root.pingedLanes = 0;\n        root.warmLanes = 0;\n        root.expiredLanes &= remainingLanes;\n        root.entangledLanes &= remainingLanes;\n        root.errorRecoveryDisabledLanes &= remainingLanes;\n        root.shellSuspendCounter = 0;\n        var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;\n        for(remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;){\n            var index = 31 - clz32(remainingLanes), lane = 1 << index;\n            entanglements[index] = 0;\n            expirationTimes[index] = -1;\n            var hiddenUpdatesForLane = hiddenUpdates[index];\n            if (null !== hiddenUpdatesForLane) for(hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++){\n                var update = hiddenUpdatesForLane[index];\n                null !== update && (update.lane &= -536870913);\n            }\n            remainingLanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\n        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\n    }\n    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n        root.pendingLanes |= spawnedLane;\n        root.suspendedLanes &= ~spawnedLane;\n        var spawnedLaneIndex = 31 - clz32(spawnedLane);\n        root.entangledLanes |= spawnedLane;\n        root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;\n    }\n    function markRootEntangled(root, entangledLanes) {\n        var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n        for(root = root.entanglements; rootEntangledLanes;){\n            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;\n            lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);\n            rootEntangledLanes &= ~lane;\n        }\n    }\n    function addFiberToLanesMap(root, fiber, lanes) {\n        if (isDevToolsPresent) for(root = root.pendingUpdatersLaneMap; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            root[index].add(fiber);\n            lanes &= ~lane;\n        }\n    }\n    function movePendingFibersToMemoized(root, lanes) {\n        if (isDevToolsPresent) for(var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes;){\n            var index = 31 - clz32(lanes);\n            root = 1 << index;\n            index = pendingUpdatersLaneMap[index];\n            0 < index.size && (index.forEach(function(fiber) {\n                var alternate = fiber.alternate;\n                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);\n            }), index.clear());\n            lanes &= ~root;\n        }\n    }\n    function lanesToEventPriority(lanes) {\n        lanes &= -lanes;\n        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;\n    }\n    function injectInternals(internals) {\n        if (\"undefined\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;\n        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook.isDisabled) return !0;\n        if (!hook.supportsFiber) return console.error(\"The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools\"), !0;\n        try {\n            rendererID = hook.inject(internals), injectedHook = hook;\n        } catch (err) {\n            console.error(\"React instrumentation encountered an error: %s.\", err);\n        }\n        return hook.checkDCE ? !0 : !1;\n    }\n    function onCommitRoot$1(root, eventPriority) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberRoot) try {\n            var didError = 128 === (root.current.flags & 128);\n            switch(eventPriority){\n                case 2:\n                    var schedulerPriority = ImmediatePriority;\n                    break;\n                case 8:\n                    schedulerPriority = UserBlockingPriority;\n                    break;\n                case 32:\n                    schedulerPriority = NormalPriority$1;\n                    break;\n                case 268435456:\n                    schedulerPriority = IdlePriority;\n                    break;\n                default:\n                    schedulerPriority = NormalPriority$1;\n            }\n            injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function setIsStrictModeForDevtools(newIsStrictMode) {\n        \"function\" === typeof log && unstable_setDisableYieldValue(newIsStrictMode);\n        if (injectedHook && \"function\" === typeof injectedHook.setStrictMode) try {\n            injectedHook.setStrictMode(rendererID, newIsStrictMode);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function injectProfilingHooks(profilingHooks) {\n        injectedProfilingHooks = profilingHooks;\n    }\n    function markCommitStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();\n    }\n    function markComponentRenderStarted(fiber) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);\n    }\n    function markComponentRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();\n    }\n    function markRenderStarted(lanes) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);\n    }\n    function markRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();\n    }\n    function markStateUpdateScheduled(fiber, lane) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n    }\n    function is(x, y) {\n        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;\n    }\n    function createCapturedValueAtFiber(value, source) {\n        if (\"object\" === typeof value && null !== value) {\n            var existing = CapturedStacks.get(value);\n            if (void 0 !== existing) return existing;\n            source = {\n                value: value,\n                source: source,\n                stack: getStackByFiberInDevAndProd(source)\n            };\n            CapturedStacks.set(value, source);\n            return source;\n        }\n        return {\n            value: value,\n            source: source,\n            stack: getStackByFiberInDevAndProd(source)\n        };\n    }\n    function pushTreeFork(workInProgress, totalChildren) {\n        warnIfNotHydrating();\n        forkStack[forkStackIndex++] = treeForkCount;\n        forkStack[forkStackIndex++] = treeForkProvider;\n        treeForkProvider = workInProgress;\n        treeForkCount = totalChildren;\n    }\n    function pushTreeId(workInProgress, totalChildren, index) {\n        warnIfNotHydrating();\n        idStack[idStackIndex++] = treeContextId;\n        idStack[idStackIndex++] = treeContextOverflow;\n        idStack[idStackIndex++] = treeContextProvider;\n        treeContextProvider = workInProgress;\n        var baseIdWithLeadingBit = treeContextId;\n        workInProgress = treeContextOverflow;\n        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n        baseIdWithLeadingBit &= ~(1 << baseLength);\n        index += 1;\n        var length = 32 - clz32(totalChildren) + baseLength;\n        if (30 < length) {\n            var numberOfOverflowBits = baseLength - baseLength % 5;\n            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);\n            baseIdWithLeadingBit >>= numberOfOverflowBits;\n            baseLength -= numberOfOverflowBits;\n            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;\n            treeContextOverflow = length + workInProgress;\n        } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;\n    }\n    function pushMaterializedTreeId(workInProgress) {\n        warnIfNotHydrating();\n        null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\n    }\n    function popTreeContext(workInProgress) {\n        for(; workInProgress === treeForkProvider;)treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;\n        for(; workInProgress === treeContextProvider;)treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;\n    }\n    function warnIfNotHydrating() {\n        isHydrating || console.error(\"Expected to be hydrating. This is a bug in React. Please file an issue.\");\n    }\n    function requiredContext(c) {\n        null === c && console.error(\"Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.\");\n        return c;\n    }\n    function pushHostContainer(fiber, nextRootInstance) {\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, null, fiber);\n        nextRootInstance = getRootHostContext(nextRootInstance);\n        pop(contextStackCursor, fiber);\n        push(contextStackCursor, nextRootInstance, fiber);\n    }\n    function popHostContainer(fiber) {\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n    }\n    function getHostContext() {\n        return requiredContext(contextStackCursor.current);\n    }\n    function pushHostContext(fiber) {\n        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);\n        var context = requiredContext(contextStackCursor.current), nextContext = getChildHostContext(context, fiber.type);\n        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));\n    }\n    function popHostContext(fiber) {\n        contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));\n        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), isPrimaryRenderer ? HostTransitionContext._currentValue = NotPendingTransition : HostTransitionContext._currentValue2 = NotPendingTransition);\n    }\n    function findNotableNode(node, indent) {\n        return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;\n    }\n    function indentation(indent) {\n        return \"  \" + \"  \".repeat(indent);\n    }\n    function added(indent) {\n        return \"+ \" + \"  \".repeat(indent);\n    }\n    function removed(indent) {\n        return \"- \" + \"  \".repeat(indent);\n    }\n    function describeFiberType(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return fiber.type;\n            case 16:\n                return \"Lazy\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 0:\n            case 15:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            case 11:\n                return fiber = fiber.type.render, fiber.displayName || fiber.name || null;\n            case 1:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            default:\n                return null;\n        }\n    }\n    function describeTextNode(content, maxLength) {\n        return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{\"...\"}' : \"{\" + content.slice(0, maxLength - 7) + '...\"}' : \"{\" + content + \"}\") : content.length > maxLength ? 5 > maxLength ? '{\"...\"}' : content.slice(0, maxLength - 3) + \"...\" : content;\n    }\n    function describeTextDiff(clientText, serverProps, indent) {\n        var maxLength = 120 - 2 * indent;\n        if (null === serverProps) return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n        if (\"string\" === typeof serverProps) {\n            for(var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++);\n            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = \"...\" + clientText.slice(firstDiff - 8), serverProps = \"...\" + serverProps.slice(firstDiff - 8));\n            return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\" + removed(indent) + describeTextNode(serverProps, maxLength) + \"\\n\";\n        }\n        return indentation(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n    }\n    function objectName(object) {\n        return Object.prototype.toString.call(object).replace(/^\\[object (.*)\\]$/, function(m, p0) {\n            return p0;\n        });\n    }\n    function describeValue(value, maxLength) {\n        switch(typeof value){\n            case \"string\":\n                return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '\"...\"' : value.slice(0, maxLength - 4) + '...\"' : value;\n            case \"object\":\n                if (null === value) return \"null\";\n                if (isArrayImpl(value)) return \"[...]\";\n                if (value.$$typeof === REACT_ELEMENT_TYPE) return (maxLength = getComponentNameFromType(value.type)) ? \"<\" + maxLength + \">\" : \"<...>\";\n                var name = objectName(value);\n                if (\"Object\" === name) {\n                    name = \"\";\n                    maxLength -= 2;\n                    for(var propName in value)if (value.hasOwnProperty(propName)) {\n                        var jsonPropName = JSON.stringify(propName);\n                        jsonPropName !== '\"' + propName + '\"' && (propName = jsonPropName);\n                        maxLength -= propName.length - 2;\n                        jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);\n                        maxLength -= jsonPropName.length;\n                        if (0 > maxLength) {\n                            name += \"\" === name ? \"...\" : \", ...\";\n                            break;\n                        }\n                        name += (\"\" === name ? \"\" : \",\") + propName + \":\" + jsonPropName;\n                    }\n                    return \"{\" + name + \"}\";\n                }\n                return name;\n            case \"function\":\n                return (maxLength = value.displayName || value.name) ? \"function \" + maxLength : \"function\";\n            default:\n                return String(value);\n        }\n    }\n    function describePropValue(value, maxLength) {\n        return \"string\" !== typeof value || needsEscaping.test(value) ? \"{\" + describeValue(value, maxLength - 2) + \"}\" : value.length > maxLength - 2 ? 5 > maxLength ? '\"...\"' : '\"' + value.slice(0, maxLength - 5) + '...\"' : '\"' + value + '\"';\n    }\n    function describeExpandedElement(type, props, rowPrefix) {\n        var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;\n        for(propName in props)if (props.hasOwnProperty(propName) && \"children\" !== propName) {\n            var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);\n            remainingRowLength -= propName.length + propValue.length + 2;\n            properties.push(propName + \"=\" + propValue);\n        }\n        return 0 === properties.length ? rowPrefix + \"<\" + type + \">\\n\" : 0 < remainingRowLength ? rowPrefix + \"<\" + type + \" \" + properties.join(\" \") + \">\\n\" : rowPrefix + \"<\" + type + \"\\n\" + rowPrefix + \"  \" + properties.join(\"\\n\" + rowPrefix + \"  \") + \"\\n\" + rowPrefix + \">\\n\";\n    }\n    function describePropertiesDiff(clientObject, serverObject, indent) {\n        var properties = \"\", remainingServerProperties = assign({}, serverObject), propName;\n        for(propName in clientObject)if (clientObject.hasOwnProperty(propName)) {\n            delete remainingServerProperties[propName];\n            var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);\n            serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\", properties += removed(indent) + propName + \": \" + maxLength + \"\\n\") : properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\";\n        }\n        for(var _propName in remainingServerProperties)remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + \": \" + clientObject + \"\\n\");\n        return properties;\n    }\n    function describeElementDiff(type, clientProps, serverProps, indent) {\n        var content = \"\", serverPropNames = new Map();\n        for(propName$jscomp$0 in serverProps)serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);\n        if (1 === serverPropNames.size && serverPropNames.has(\"children\")) content += describeExpandedElement(type, clientProps, indentation(indent));\n        else {\n            for(var _propName2 in clientProps)if (clientProps.hasOwnProperty(_propName2) && \"children\" !== _propName2) {\n                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());\n                if (void 0 !== serverPropName) {\n                    serverPropNames.delete(_propName2.toLowerCase());\n                    var propName$jscomp$0 = clientProps[_propName2];\n                    serverPropName = serverProps[serverPropName];\n                    var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);\n                    maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);\n                    \"object\" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && \"object\" === typeof serverPropName && null !== serverPropName && \"Object\" === objectName(propName$jscomp$0) && \"Object\" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf(\"...\") || -1 < maxLength$jscomp$0.indexOf(\"...\")) ? content += indentation(indent + 1) + _propName2 + \"={{\\n\" + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + \"}}\\n\" : (content += added(indent + 1) + _propName2 + \"=\" + clientPropValue + \"\\n\", content += removed(indent + 1) + _propName2 + \"=\" + maxLength$jscomp$0 + \"\\n\");\n                } else content += indentation(indent + 1) + _propName2 + \"=\" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + \"\\n\";\n            }\n            serverPropNames.forEach(function(propName) {\n                if (\"children\" !== propName) {\n                    var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;\n                    content += removed(indent + 1) + propName + \"=\" + describePropValue(serverProps[propName], maxLength) + \"\\n\";\n                }\n            });\n            content = \"\" === content ? indentation(indent) + \"<\" + type + \">\\n\" : indentation(indent) + \"<\" + type + \"\\n\" + content + indentation(indent) + \">\\n\";\n        }\n        type = serverProps.children;\n        clientProps = clientProps.children;\n        if (\"string\" === typeof type || \"number\" === typeof type || \"bigint\" === typeof type) {\n            serverPropNames = \"\";\n            if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) serverPropNames = \"\" + clientProps;\n            content += describeTextDiff(serverPropNames, \"\" + type, indent + 1);\n        } else if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) content = null == type ? content + describeTextDiff(\"\" + clientProps, null, indent + 1) : content + describeTextDiff(\"\" + clientProps, void 0, indent + 1);\n        return content;\n    }\n    function describeSiblingFiber(fiber, indent) {\n        var type = describeFiberType(fiber);\n        if (null === type) {\n            type = \"\";\n            for(fiber = fiber.child; fiber;)type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;\n            return type;\n        }\n        return indentation(indent) + \"<\" + type + \">\\n\";\n    }\n    function describeNode(node, indent) {\n        var skipToNode = findNotableNode(node, indent);\n        if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode)) return indentation(indent) + \"...\\n\" + describeNode(skipToNode, indent + 1);\n        skipToNode = \"\";\n        var debugInfo = node.fiber._debugInfo;\n        if (debugInfo) for(var i = 0; i < debugInfo.length; i++){\n            var serverComponentName = debugInfo[i].name;\n            \"string\" === typeof serverComponentName && (skipToNode += indentation(indent) + \"<\" + serverComponentName + \">\\n\", indent++);\n        }\n        debugInfo = \"\";\n        i = node.fiber.pendingProps;\n        if (6 === node.fiber.tag) debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;\n        else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName) if (void 0 === node.serverProps) {\n            debugInfo = indent;\n            var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = \"\";\n            for(propName in i)if (i.hasOwnProperty(propName) && \"children\" !== propName) {\n                var propValue = describePropValue(i[propName], 15);\n                maxLength -= propName.length + propValue.length + 2;\n                if (0 > maxLength) {\n                    content += \" ...\";\n                    break;\n                }\n                content += \" \" + propName + \"=\" + propValue;\n            }\n            debugInfo = indentation(debugInfo) + \"<\" + serverComponentName + content + \">\\n\";\n            indent++;\n        } else null === node.serverProps ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : \"string\" === typeof node.serverProps ? console.error(\"Should not have matched a non HostText fiber to a Text node. This is a bug in React.\") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);\n        var propName = \"\";\n        i = node.fiber.child;\n        for(serverComponentName = 0; i && serverComponentName < node.children.length;)maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;\n        i && 0 < node.children.length && (propName += indentation(indent) + \"...\\n\");\n        i = node.serverTail;\n        null === node.serverProps && indent--;\n        for(node = 0; node < i.length; node++)serverComponentName = i[node], propName = \"string\" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + \"\\n\") : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));\n        return skipToNode + debugInfo + propName;\n    }\n    function describeDiff(rootNode) {\n        try {\n            return \"\\n\\n\" + describeNode(rootNode, 0);\n        } catch (x) {\n            return \"\";\n        }\n    }\n    function buildHydrationDiffNode(fiber, distanceFromLeaf) {\n        if (null === fiber.return) {\n            if (null === hydrationDiffRootDEV) hydrationDiffRootDEV = {\n                fiber: fiber,\n                children: [],\n                serverProps: void 0,\n                serverTail: [],\n                distanceFromLeaf: distanceFromLeaf\n            };\n            else {\n                if (hydrationDiffRootDEV.fiber !== fiber) throw Error(\"Saw multiple hydration diff roots in a pass. This is a bug in React.\");\n                hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);\n            }\n            return hydrationDiffRootDEV;\n        }\n        var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;\n        if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber) return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;\n        distanceFromLeaf = {\n            fiber: fiber,\n            children: [],\n            serverProps: void 0,\n            serverTail: [],\n            distanceFromLeaf: distanceFromLeaf\n        };\n        siblings.push(distanceFromLeaf);\n        return distanceFromLeaf;\n    }\n    function warnNonHydratedInstance(fiber, rejectedCandidate) {\n        didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));\n    }\n    function throwOnHydrationMismatch(fiber) {\n        var diff = \"\", diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));\n        queueHydrationError(createCapturedValueAtFiber(Error(\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\nhttps://react.dev/link/hydration-mismatch\" + diff), fiber));\n        throw HydrationMismatchException;\n    }\n    function prepareToHydrateHostInstance(fiber, hostContext) {\n        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n        hydrateInstance(fiber.stateNode, fiber.type, fiber.memoizedProps, hostContext, fiber) || throwOnHydrationMismatch(fiber);\n    }\n    function popToNextHostParent(fiber) {\n        for(hydrationParentFiber = fiber.return; hydrationParentFiber;)switch(hydrationParentFiber.tag){\n            case 3:\n            case 27:\n                rootOrSingletonContext = !0;\n                return;\n            case 5:\n            case 13:\n                rootOrSingletonContext = !1;\n                return;\n            default:\n                hydrationParentFiber = hydrationParentFiber.return;\n        }\n    }\n    function popHydrationState(fiber) {\n        if (!supportsHydration || fiber !== hydrationParentFiber) return !1;\n        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;\n        var shouldClear = !1;\n        supportsSingletons ? 3 !== fiber.tag && 27 !== fiber.tag && (5 !== fiber.tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && (shouldClear = !0) : 3 !== fiber.tag && (5 !== fiber.tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && (shouldClear = !0);\n        if (shouldClear && nextHydratableInstance) {\n            for(shouldClear = nextHydratableInstance; shouldClear;){\n                var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(shouldClear);\n                diffNode.serverTail.push(description);\n                shouldClear = \"Suspense\" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear) : getNextHydratableSibling(shouldClear);\n            }\n            throwOnHydrationMismatch(fiber);\n        }\n        popToNextHostParent(fiber);\n        if (13 === fiber.tag) {\n            if (!supportsHydration) throw Error(\"Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n            fiber = fiber.memoizedState;\n            fiber = null !== fiber ? fiber.dehydrated : null;\n            if (!fiber) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);\n        } else nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        return !0;\n    }\n    function resetHydrationState() {\n        supportsHydration && (nextHydratableInstance = hydrationParentFiber = null, didSuspendOrErrorDEV = isHydrating = !1);\n    }\n    function queueHydrationError(error) {\n        null === hydrationErrors ? hydrationErrors = [\n            error\n        ] : hydrationErrors.push(error);\n    }\n    function emitPendingHydrationWarnings() {\n        var diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diffRoot = describeDiff(diffRoot), console.error(\"A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\n%s%s\", \"https://react.dev/link/hydration-mismatch\", diffRoot));\n    }\n    function finishQueueingConcurrentUpdates() {\n        for(var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;){\n            var fiber = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var queue = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var update = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var lane = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            if (null !== queue && null !== update) {\n                var pending = queue.pending;\n                null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n                queue.pending = update;\n            }\n            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\n        }\n    }\n    function enqueueUpdate$1(fiber, queue, update, lane) {\n        concurrentQueues[concurrentQueuesIndex++] = fiber;\n        concurrentQueues[concurrentQueuesIndex++] = queue;\n        concurrentQueues[concurrentQueuesIndex++] = update;\n        concurrentQueues[concurrentQueuesIndex++] = lane;\n        concurrentlyUpdatedLanes |= lane;\n        fiber.lanes |= lane;\n        fiber = fiber.alternate;\n        null !== fiber && (fiber.lanes |= lane);\n    }\n    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n        enqueueUpdate$1(fiber, queue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function enqueueConcurrentRenderForLane(fiber, lane) {\n        enqueueUpdate$1(fiber, null, null, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n        sourceFiber.lanes |= lane;\n        var alternate = sourceFiber.alternate;\n        null !== alternate && (alternate.lanes |= lane);\n        for(var isHidden = !1, parent = sourceFiber.return; null !== parent;)parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)), sourceFiber = parent, parent = parent.return;\n        isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [\n            update\n        ] : sourceFiber.push(update), update.lane = lane | 536870912);\n    }\n    function getRootForUpdatedFiber(sourceFiber) {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(\"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\");\n        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(\"Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.\"));\n        null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        for(var node = sourceFiber, parent = node.return; null !== parent;)null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;\n        return 3 === node.tag ? node.stateNode : null;\n    }\n    function pushNestedEffectDurations() {\n        var prevEffectDuration = profilerEffectDuration;\n        profilerEffectDuration = 0;\n        return prevEffectDuration;\n    }\n    function popNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration = prevEffectDuration;\n        return elapsedTime;\n    }\n    function bubbleNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration += prevEffectDuration;\n        return elapsedTime;\n    }\n    function startProfilerTimer(fiber) {\n        profilerStartTime = now();\n        0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);\n    }\n    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            fiber.selfBaseDuration = elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function recordEffectDuration() {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            profilerStartTime = -1;\n            profilerEffectDuration += elapsedTime;\n        }\n    }\n    function startEffectTimer() {\n        profilerStartTime = now();\n    }\n    function transferActualDuration(fiber) {\n        for(var child = fiber.child; child;)fiber.actualDuration += child.actualDuration, child = child.sibling;\n    }\n    function ensureRootIsScheduled(root) {\n        root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);\n        mightHavePendingSyncWork = !0;\n        null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = !0, scheduleImmediateTask(processRootScheduleInMicrotask)) : didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateTask(processRootScheduleInMicrotask));\n    }\n    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {\n        if (!isFlushingWork && mightHavePendingSyncWork) {\n            isFlushingWork = !0;\n            do {\n                var didPerformSomeWork = !1;\n                for(var root = firstScheduledRoot; null !== root;){\n                    if (!onlyLegacy) if (0 !== syncTransitionLanes) {\n                        var pendingLanes = root.pendingLanes;\n                        if (0 === pendingLanes) var nextLanes = 0;\n                        else {\n                            var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;\n                            nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;\n                            nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);\n                            nextLanes = nextLanes & 201326677 ? nextLanes & 201326677 | 1 : nextLanes ? nextLanes | 2 : 0;\n                        }\n                        0 !== nextLanes && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    } else nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    root = root.next;\n                }\n            }while (didPerformSomeWork);\n            isFlushingWork = !1;\n        }\n    }\n    function processRootScheduleInMicrotask() {\n        mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = !1;\n        var syncTransitionLanes = 0;\n        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);\n        for(var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root;){\n            var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n            if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);\n            else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;\n            root = next;\n        }\n        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);\n    }\n    function scheduleTaskForRootDuringMicrotask(root, currentTime) {\n        for(var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];\n            if (-1 === expirationTime) {\n                if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index] = computeExpirationTime(lane, currentTime);\n            } else expirationTime <= currentTime && (root.expiredLanes |= lane);\n            lanes &= ~lane;\n        }\n        currentTime = workInProgressRoot;\n        suspendedLanes = workInProgressRootRenderLanes;\n        suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0);\n        pingedLanes = root.callbackNode;\n        if (0 === suspendedLanes || root === currentTime && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;\n        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {\n            currentTime = suspendedLanes & -suspendedLanes;\n            if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode$1) cancelCallback(pingedLanes);\n            else return currentTime;\n            switch(lanesToEventPriority(suspendedLanes)){\n                case 2:\n                case 8:\n                    suspendedLanes = UserBlockingPriority;\n                    break;\n                case 32:\n                    suspendedLanes = NormalPriority$1;\n                    break;\n                case 268435456:\n                    suspendedLanes = IdlePriority;\n                    break;\n                default:\n                    suspendedLanes = NormalPriority$1;\n            }\n            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);\n            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode$1) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);\n            root.callbackPriority = currentTime;\n            root.callbackNode = suspendedLanes;\n            return currentTime;\n        }\n        null !== pingedLanes && cancelCallback(pingedLanes);\n        root.callbackPriority = 2;\n        root.callbackNode = null;\n        return 2;\n    }\n    function performWorkOnRootViaSchedulerTask(root, didTimeout) {\n        nestedUpdateScheduled = currentUpdateIsNested = !1;\n        var originalCallbackNode = root.callbackNode;\n        if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode) return null;\n        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;\n        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0);\n        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;\n        performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);\n        scheduleTaskForRootDuringMicrotask(root, now$1());\n        return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;\n    }\n    function performSyncWorkOnRoot(root, lanes) {\n        if (flushPassiveEffects()) return null;\n        currentUpdateIsNested = nestedUpdateScheduled;\n        nestedUpdateScheduled = !1;\n        performWorkOnRoot(root, lanes, !0);\n    }\n    function cancelCallback(callbackNode) {\n        callbackNode !== fakeActCallbackNode$1 && null !== callbackNode && cancelCallback$1(callbackNode);\n    }\n    function scheduleImmediateTask(cb) {\n        null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {\n            cb();\n            return null;\n        });\n        supportsMicrotasks ? scheduleMicrotask(function() {\n            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, cb) : cb();\n        }) : scheduleCallback$3(ImmediatePriority, cb);\n    }\n    function requestTransitionLane() {\n        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());\n        return currentEventTransitionLane;\n    }\n    function entangleAsyncAction(transition, thenable) {\n        if (null === currentEntangledListeners) {\n            var entangledListeners = currentEntangledListeners = [];\n            currentEntangledPendingCount = 0;\n            currentEntangledLane = requestTransitionLane();\n            currentEntangledActionThenable = {\n                status: \"pending\",\n                value: void 0,\n                then: function(resolve) {\n                    entangledListeners.push(resolve);\n                }\n            };\n        }\n        currentEntangledPendingCount++;\n        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n        return thenable;\n    }\n    function pingEngtangledActionScope() {\n        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {\n            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = \"fulfilled\");\n            var listeners = currentEntangledListeners;\n            currentEntangledListeners = null;\n            currentEntangledLane = 0;\n            currentEntangledActionThenable = null;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])();\n        }\n    }\n    function chainThenableValue(thenable, result) {\n        var listeners = [], thenableWithOverride = {\n            status: \"pending\",\n            value: null,\n            reason: null,\n            then: function(resolve) {\n                listeners.push(resolve);\n            }\n        };\n        thenable.then(function() {\n            thenableWithOverride.status = \"fulfilled\";\n            thenableWithOverride.value = result;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])(result);\n        }, function(error) {\n            thenableWithOverride.status = \"rejected\";\n            thenableWithOverride.reason = error;\n            for(error = 0; error < listeners.length; error++)(0, listeners[error])(void 0);\n        });\n        return thenableWithOverride;\n    }\n    function initializeUpdateQueue(fiber) {\n        fiber.updateQueue = {\n            baseState: fiber.memoizedState,\n            firstBaseUpdate: null,\n            lastBaseUpdate: null,\n            shared: {\n                pending: null,\n                lanes: 0,\n                hiddenCallbacks: null\n            },\n            callbacks: null\n        };\n    }\n    function cloneUpdateQueue(current, workInProgress) {\n        current = current.updateQueue;\n        workInProgress.updateQueue === current && (workInProgress.updateQueue = {\n            baseState: current.baseState,\n            firstBaseUpdate: current.firstBaseUpdate,\n            lastBaseUpdate: current.lastBaseUpdate,\n            shared: current.shared,\n            callbacks: null\n        });\n    }\n    function createUpdate(lane) {\n        return {\n            lane: lane,\n            tag: UpdateState,\n            payload: null,\n            callback: null,\n            next: null\n        };\n    }\n    function enqueueUpdate(fiber, update, lane) {\n        var updateQueue = fiber.updateQueue;\n        if (null === updateQueue) return null;\n        updateQueue = updateQueue.shared;\n        if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {\n            var componentName = getComponentNameFromFiber(fiber);\n            console.error(\"An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\\n\\nPlease update the following component: %s\", componentName);\n            didWarnUpdateInsideUpdate = !0;\n        }\n        if ((executionContext & RenderContext) !== NoContext) return componentName = updateQueue.pending, null === componentName ? update.next = update : (update.next = componentName.next, componentName.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;\n        enqueueUpdate$1(fiber, updateQueue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function entangleTransitions(root, fiber, lane) {\n        fiber = fiber.updateQueue;\n        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {\n            var queueLanes = fiber.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            fiber.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n        var queue = workInProgress.updateQueue, current = workInProgress.alternate;\n        if (null !== current && (current = current.updateQueue, queue === current)) {\n            var newFirst = null, newLast = null;\n            queue = queue.firstBaseUpdate;\n            if (null !== queue) {\n                do {\n                    var clone = {\n                        lane: queue.lane,\n                        tag: queue.tag,\n                        payload: queue.payload,\n                        callback: null,\n                        next: null\n                    };\n                    null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;\n                    queue = queue.next;\n                }while (null !== queue);\n                null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;\n            } else newFirst = newLast = capturedUpdate;\n            queue = {\n                baseState: current.baseState,\n                firstBaseUpdate: newFirst,\n                lastBaseUpdate: newLast,\n                shared: current.shared,\n                callbacks: current.callbacks\n            };\n            workInProgress.updateQueue = queue;\n            return;\n        }\n        workInProgress = queue.lastBaseUpdate;\n        null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;\n        queue.lastBaseUpdate = capturedUpdate;\n    }\n    function suspendIfUpdateReadFromEntangledAsyncAction() {\n        if (didReadFromEntangledAsyncAction) {\n            var entangledActionThenable = currentEntangledActionThenable;\n            if (null !== entangledActionThenable) throw entangledActionThenable;\n        }\n    }\n    function processUpdateQueue(workInProgress, props, instance$jscomp$0, renderLanes) {\n        didReadFromEntangledAsyncAction = !1;\n        var queue = workInProgress.updateQueue;\n        hasForceUpdate = !1;\n        currentlyProcessingQueue = queue.shared;\n        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;\n        if (null !== pendingQueue) {\n            queue.shared.pending = null;\n            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;\n            lastPendingUpdate.next = null;\n            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;\n            lastBaseUpdate = lastPendingUpdate;\n            var current = workInProgress.alternate;\n            null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));\n        }\n        if (null !== firstBaseUpdate) {\n            var newState = queue.baseState;\n            lastBaseUpdate = 0;\n            current = firstPendingUpdate = lastPendingUpdate = null;\n            pendingQueue = firstBaseUpdate;\n            do {\n                var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;\n                if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    null !== current && (current = current.next = {\n                        lane: 0,\n                        tag: pendingQueue.tag,\n                        payload: pendingQueue.payload,\n                        callback: null,\n                        next: null\n                    });\n                    a: {\n                        updateLane = workInProgress;\n                        var partialState = pendingQueue;\n                        var nextProps = props, instance = instance$jscomp$0;\n                        switch(partialState.tag){\n                            case ReplaceState:\n                                partialState = partialState.payload;\n                                if (\"function\" === typeof partialState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    var nextState = partialState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            partialState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                    newState = nextState;\n                                    break a;\n                                }\n                                newState = partialState;\n                                break a;\n                            case CaptureUpdate:\n                                updateLane.flags = updateLane.flags & -65537 | 128;\n                            case UpdateState:\n                                nextState = partialState.payload;\n                                if (\"function\" === typeof nextState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    partialState = nextState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            nextState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                } else partialState = nextState;\n                                if (null === partialState || void 0 === partialState) break a;\n                                newState = assign({}, newState, partialState);\n                                break a;\n                            case ForceUpdate:\n                                hasForceUpdate = !0;\n                        }\n                    }\n                    updateLane = pendingQueue.callback;\n                    null !== updateLane && (workInProgress.flags |= 64, isHiddenUpdate && (workInProgress.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [\n                        updateLane\n                    ] : isHiddenUpdate.push(updateLane));\n                } else isHiddenUpdate = {\n                    lane: updateLane,\n                    tag: pendingQueue.tag,\n                    payload: pendingQueue.payload,\n                    callback: pendingQueue.callback,\n                    next: null\n                }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;\n                pendingQueue = pendingQueue.next;\n                if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;\n                else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;\n            }while (1);\n            null === current && (lastPendingUpdate = newState);\n            queue.baseState = lastPendingUpdate;\n            queue.firstBaseUpdate = firstPendingUpdate;\n            queue.lastBaseUpdate = current;\n            null === firstBaseUpdate && (queue.shared.lanes = 0);\n            workInProgressRootSkippedLanes |= lastBaseUpdate;\n            workInProgress.lanes = lastBaseUpdate;\n            workInProgress.memoizedState = newState;\n        }\n        currentlyProcessingQueue = null;\n    }\n    function callCallback(callback, context) {\n        if (\"function\" !== typeof callback) throw Error(\"Invalid argument passed as callback. Expected a function. Instead received: \" + callback);\n        callback.call(context);\n    }\n    function commitHiddenCallbacks(updateQueue, context) {\n        var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n        if (null !== hiddenCallbacks) for(updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)callCallback(hiddenCallbacks[updateQueue], context);\n    }\n    function commitCallbacks(updateQueue, context) {\n        var callbacks = updateQueue.callbacks;\n        if (null !== callbacks) for(updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)callCallback(callbacks[updateQueue], context);\n    }\n    function shallowEqual(objA, objB) {\n        if (objectIs(objA, objB)) return !0;\n        if (\"object\" !== typeof objA || null === objA || \"object\" !== typeof objB || null === objB) return !1;\n        var keysA = Object.keys(objA), keysB = Object.keys(objB);\n        if (keysA.length !== keysB.length) return !1;\n        for(keysB = 0; keysB < keysA.length; keysB++){\n            var currentKey = keysA[keysB];\n            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;\n        }\n        return !0;\n    }\n    function createThenableState() {\n        return {\n            didWarnAboutUncachedPromise: !1,\n            thenables: []\n        };\n    }\n    function isThenableResolved(thenable) {\n        thenable = thenable.status;\n        return \"fulfilled\" === thenable || \"rejected\" === thenable;\n    }\n    function noop$1() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n        null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = !0);\n        var trackedThenables = thenableState.thenables;\n        index = trackedThenables[index];\n        void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState.didWarnAboutUncachedPromise || (thenableState.didWarnAboutUncachedPromise = !0, console.error(\"A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.\")), thenable.then(noop$1, noop$1), thenable = index);\n        switch(thenable.status){\n            case \"fulfilled\":\n                return thenable.value;\n            case \"rejected\":\n                throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n            default:\n                if (\"string\" === typeof thenable.status) thenable.then(noop$1, noop$1);\n                else {\n                    thenableState = workInProgressRoot;\n                    if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error(\"async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n                    thenableState = thenable;\n                    thenableState.status = \"pending\";\n                    thenableState.then(function(fulfilledValue) {\n                        if (\"pending\" === thenable.status) {\n                            var fulfilledThenable = thenable;\n                            fulfilledThenable.status = \"fulfilled\";\n                            fulfilledThenable.value = fulfilledValue;\n                        }\n                    }, function(error) {\n                        if (\"pending\" === thenable.status) {\n                            var rejectedThenable = thenable;\n                            rejectedThenable.status = \"rejected\";\n                            rejectedThenable.reason = error;\n                        }\n                    });\n                }\n                switch(thenable.status){\n                    case \"fulfilled\":\n                        return thenable.value;\n                    case \"rejected\":\n                        throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n                }\n                suspendedThenable = thenable;\n                needsToResetSuspendedThenableDEV = !0;\n                throw SuspenseException;\n        }\n    }\n    function getSuspendedThenable() {\n        if (null === suspendedThenable) throw Error(\"Expected a suspended thenable. This is a bug in React. Please file an issue.\");\n        var thenable = suspendedThenable;\n        suspendedThenable = null;\n        needsToResetSuspendedThenableDEV = !1;\n        return thenable;\n    }\n    function checkIfUseWrappedInAsyncCatch(rejectedReason) {\n        if (rejectedReason === SuspenseException) throw Error(\"Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n    }\n    function pushDebugInfo(debugInfo) {\n        var previousDebugInfo = currentDebugInfo;\n        null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));\n        return previousDebugInfo;\n    }\n    function validateFragmentProps(element, fiber, returnFiber) {\n        for(var keys = Object.keys(element.props), i = 0; i < keys.length; i++){\n            var key = keys[i];\n            if (\"children\" !== key && \"key\" !== key) {\n                null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);\n                runWithFiberInDEV(fiber, function(erroredKey) {\n                    console.error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", erroredKey);\n                }, key);\n                break;\n            }\n        }\n    }\n    function unwrapThenable(thenable) {\n        var index = thenableIndexCounter$1;\n        thenableIndexCounter$1 += 1;\n        null === thenableState$1 && (thenableState$1 = createThenableState());\n        return trackUsedThenable(thenableState$1, thenable, index);\n    }\n    function coerceRef(workInProgress, element) {\n        element = element.props.ref;\n        workInProgress.ref = void 0 !== element ? element : null;\n    }\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\\n- Multiple copies of the \"react\" package is used.\\n- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n- A compiler tries to \"inline\" JSX instead of using the runtime.');\n        returnFiber = Object.prototype.toString.call(newChild);\n        throw Error(\"Objects are not valid as a React child (found: \" + (\"[object Object]\" === returnFiber ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : returnFiber) + \"). If you meant to render a collection of children, use an array instead.\");\n    }\n    function warnOnFunctionType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = !0, invalidChild = invalidChild.displayName || invalidChild.name || \"Component\", 3 === returnFiber.tag ? console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  root.render(%s)\", invalidChild, invalidChild, invalidChild) : console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  <%s>{%s}</%s>\", invalidChild, invalidChild, parentName, invalidChild, parentName));\n    }\n    function warnOnSymbolType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = !0, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(\"Symbols are not valid as a React child.\\n  root.render(%s)\", invalidChild) : console.error(\"Symbols are not valid as a React child.\\n  <%s>%s</%s>\", parentName, invalidChild, parentName));\n    }\n    function createChildReconciler(shouldTrackSideEffects) {\n        var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$();\n        function deleteChild(returnFiber, childToDelete) {\n            if (shouldTrackSideEffects) {\n                var deletions = returnFiber.deletions;\n                null === deletions ? (returnFiber.deletions = [\n                    childToDelete\n                ], returnFiber.flags |= 16) : deletions.push(childToDelete);\n            }\n        }\n        function deleteRemainingChildren(returnFiber, currentFirstChild) {\n            if (!shouldTrackSideEffects) return null;\n            for(; null !== currentFirstChild;)deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return null;\n        }\n        function mapRemainingChildren(currentFirstChild) {\n            for(var existingChildren = new Map(); null !== currentFirstChild;)null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return existingChildren;\n        }\n        function useFiber(fiber, pendingProps) {\n            fiber = createWorkInProgress(fiber, pendingProps);\n            fiber.index = 0;\n            fiber.sibling = null;\n            return fiber;\n        }\n        function placeChild(newFiber, lastPlacedIndex, newIndex) {\n            newFiber.index = newIndex;\n            if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;\n            newIndex = newFiber.alternate;\n            if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;\n            newFiber.flags |= 33554434;\n            return lastPlacedIndex;\n        }\n        function placeSingleChild(newFiber) {\n            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);\n            return newFiber;\n        }\n        function updateTextNode(returnFiber, current, textContent, lanes) {\n            _s();\n            if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, textContent);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        _s(updateTextNode, \"lUPY7CMORj7BFRpIKY3KHDkSuVI=\", false, function() {\n            return [\n                useFiber\n            ];\n        });\n        function updateElement(returnFiber, current, element, lanes) {\n            _s1();\n            var elementType = element.type;\n            if (elementType === REACT_FRAGMENT_TYPE) return current = updateFragment(returnFiber, current, element.props.children, lanes, element.key), validateFragmentProps(element, current, returnFiber), current;\n            if (null !== current && (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || \"object\" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current._debugOwner = element._owner, current._debugInfo = currentDebugInfo, current;\n            current = createFiberFromElement(element, returnFiber.mode, lanes);\n            coerceRef(current, element);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        _s1(updateElement, \"lUPY7CMORj7BFRpIKY3KHDkSuVI=\", false, function() {\n            return [\n                useFiber\n            ];\n        });\n        function updatePortal(returnFiber, current, portal, lanes) {\n            _s2();\n            if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, portal.children || []);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        _s2(updatePortal, \"lUPY7CMORj7BFRpIKY3KHDkSuVI=\", false, function() {\n            return [\n                useFiber\n            ];\n        });\n        function updateFragment(returnFiber, current, fragment, lanes, key) {\n            _s3();\n            if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, fragment);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        _s3(updateFragment, \"lUPY7CMORj7BFRpIKY3KHDkSuVI=\", false, function() {\n            return [\n                useFiber\n            ];\n        });\n        function createChild(returnFiber, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return newChild = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                    case REACT_PORTAL_TYPE:\n                        return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = createChild(returnFiber, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n            var key = null !== oldFiber ? oldFiber.key : null;\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;\n                    case REACT_PORTAL_TYPE:\n                        return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;\n                    case REACT_LAZY_TYPE:\n                        return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) {\n                    if (null !== key) return null;\n                    key = pushDebugInfo(newChild._debugInfo);\n                    returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n                    currentDebugInfo = key;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newIdx = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo7;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {\n            if (\"object\" !== typeof child || null === child) return knownKeys;\n            switch(child.$$typeof){\n                case REACT_ELEMENT_TYPE:\n                case REACT_PORTAL_TYPE:\n                    warnForMissingKey(returnFiber, workInProgress, child);\n                    var key = child.key;\n                    if (\"string\" !== typeof key) break;\n                    if (null === knownKeys) {\n                        knownKeys = new Set();\n                        knownKeys.add(key);\n                        break;\n                    }\n                    if (!knownKeys.has(key)) {\n                        knownKeys.add(key);\n                        break;\n                    }\n                    runWithFiberInDEV(workInProgress, function() {\n                        console.error(\"Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \\u2014 the behavior is unsupported and could change in a future version.\", key);\n                    });\n                    break;\n                case REACT_LAZY_TYPE:\n                    child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);\n            }\n            return knownKeys;\n        }\n        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n            for(var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; newIdx < newChildren.length; newIdx++)oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {\n            if (null == newChildren) throw Error(\"An iterable object provided no iterator.\");\n            for(var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; !step.done; newIdx++, step = newChildren.next())oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {\n            _s4();\n            \"object\" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        var prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        a: {\n                            for(var key = newChild.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === key) {\n                                    key = newChild.type;\n                                    if (key === REACT_FRAGMENT_TYPE) {\n                                        if (7 === currentFirstChild.tag) {\n                                            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                            lanes = useFiber(currentFirstChild, newChild.props.children);\n                                            lanes.return = returnFiber;\n                                            lanes._debugOwner = newChild._owner;\n                                            lanes._debugInfo = currentDebugInfo;\n                                            validateFragmentProps(newChild, lanes, returnFiber);\n                                            returnFiber = lanes;\n                                            break a;\n                                        }\n                                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || \"object\" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {\n                                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                        lanes = useFiber(currentFirstChild, newChild.props);\n                                        coerceRef(lanes, newChild);\n                                        lanes.return = returnFiber;\n                                        lanes._debugOwner = newChild._owner;\n                                        lanes._debugInfo = currentDebugInfo;\n                                        returnFiber = lanes;\n                                        break a;\n                                    }\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                } else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);\n                        }\n                        returnFiber = placeSingleChild(returnFiber);\n                        currentDebugInfo = prevDebugInfo;\n                        return returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        a: {\n                            prevDebugInfo = newChild;\n                            for(newChild = prevDebugInfo.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === newChild) if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                    lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);\n                                    lanes.return = returnFiber;\n                                    returnFiber = lanes;\n                                    break a;\n                                } else {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                }\n                                else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);\n                            lanes.return = returnFiber;\n                            returnFiber = lanes;\n                        }\n                        return placeSingleChild(returnFiber);\n                    case REACT_LAZY_TYPE:\n                        return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                }\n                if (isArrayImpl(newChild)) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (getIteratorFn(newChild)) {\n                    prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                    key = getIteratorFn(newChild);\n                    if (\"function\" !== typeof key) throw Error(\"An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.\");\n                    var newChildren = key.call(newChild);\n                    if (newChildren === newChild) {\n                        if (0 !== returnFiber.tag || \"[object GeneratorFunction]\" !== Object.prototype.toString.call(returnFiber.type) || \"[object Generator]\" !== Object.prototype.toString.call(newChildren)) didWarnAboutGenerators || console.error(\"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"), didWarnAboutGenerators = !0;\n                    } else newChild.entries !== key || didWarnAboutMaps || (console.error(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"), didWarnAboutMaps = !0);\n                    returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);\n                    currentDebugInfo = prevDebugInfo;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return prevDebugInfo = \"\" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return deleteRemainingChildren(returnFiber, currentFirstChild);\n        }\n        _s4(reconcileChildFibersImpl, \"lUPY7CMORj7BFRpIKY3KHDkSuVI=\", false, function() {\n            return [\n                useFiber\n            ];\n        });\n        return function(returnFiber, currentFirstChild, newChild, lanes) {\n            var prevDebugInfo = currentDebugInfo;\n            currentDebugInfo = null;\n            try {\n                thenableIndexCounter$1 = 0;\n                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);\n                thenableState$1 = null;\n                return firstChildFiber;\n            } catch (x) {\n                if (x === SuspenseException) throw x;\n                var fiber = createFiber(29, x, null, returnFiber.mode);\n                fiber.lanes = lanes;\n                fiber.return = returnFiber;\n                var debugInfo = fiber._debugInfo = currentDebugInfo;\n                fiber._debugOwner = returnFiber._debugOwner;\n                if (null != debugInfo) {\n                    for(var i = debugInfo.length - 1; 0 <= i; i--)if (\"string\" === typeof debugInfo[i].stack) {\n                        fiber._debugOwner = debugInfo[i];\n                        break;\n                    }\n                }\n                return fiber;\n            } finally{\n                currentDebugInfo = prevDebugInfo;\n            }\n        };\n    }\n    function pushHiddenContext(fiber, context) {\n        var prevEntangledRenderLanes = entangledRenderLanes;\n        push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, context, fiber);\n        entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;\n    }\n    function reuseHiddenContextOnStack(fiber) {\n        push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);\n    }\n    function popHiddenContext(fiber) {\n        entangledRenderLanes = prevEntangledRenderLanesCursor.current;\n        pop(currentTreeHiddenStackCursor, fiber);\n        pop(prevEntangledRenderLanesCursor, fiber);\n    }\n    function pushPrimaryTreeSuspenseHandler(handler) {\n        var current = handler.alternate;\n        push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);\n        push(suspenseHandlerStackCursor, handler, handler);\n        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));\n    }\n    function pushOffscreenSuspenseHandler(fiber) {\n        if (22 === fiber.tag) {\n            if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {\n                var current = fiber.alternate;\n                null !== current && null !== current.memoizedState && (shellBoundary = fiber);\n            }\n        } else reuseSuspenseHandlerOnStack(fiber);\n    }\n    function reuseSuspenseHandlerOnStack(fiber) {\n        push(suspenseStackCursor, suspenseStackCursor.current, fiber);\n        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);\n    }\n    function popSuspenseHandler(fiber) {\n        pop(suspenseHandlerStackCursor, fiber);\n        shellBoundary === fiber && (shellBoundary = null);\n        pop(suspenseStackCursor, fiber);\n    }\n    function findFirstSuspended(row) {\n        for(var node = row; null !== node;){\n            if (13 === node.tag) {\n                var state = node.memoizedState;\n                if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state))) return node;\n            } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\n                if (0 !== (node.flags & 128)) return node;\n            } else if (null !== node.child) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n            }\n            if (node === row) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === row) return null;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function mountHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        null === hookTypesDev ? hookTypesDev = [\n            hookName\n        ] : hookTypesDev.push(hookName);\n    }\n    function updateHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {\n            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n            if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)) {\n                for(var table = \"\", i = 0; i <= hookTypesUpdateIndexDev; i++){\n                    var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;\n                    for(oldHookName = i + 1 + \". \" + oldHookName; 30 > oldHookName.length;)oldHookName += \" \";\n                    oldHookName += newHookName + \"\\n\";\n                    table += oldHookName;\n                }\n                console.error(\"React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\\n\\n   Previous render            Next render\\n   ------------------------------------------------------\\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n            }\n        }\n    }\n    function checkDepsAreArrayDev(deps) {\n        void 0 === deps || null === deps || isArrayImpl(deps) || console.error(\"%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n    }\n    function warnOnUseFormStateInDev() {\n        var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n        didWarnAboutUseFormState.has(componentName) || (didWarnAboutUseFormState.add(componentName), console.error(\"ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.\", componentName));\n    }\n    function throwInvalidHookError() {\n        throw Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n    }\n    function areHookInputsEqual(nextDeps, prevDeps) {\n        if (ignorePreviousDependencies) return !1;\n        if (null === prevDeps) return console.error(\"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\", currentHookNameInDev), !1;\n        nextDeps.length !== prevDeps.length && console.error(\"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++)if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\n        return !0;\n    }\n    function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n        renderLanes = nextRenderLanes;\n        currentlyRenderingFiber$1 = workInProgress;\n        hookTypesDev = null !== current ? current._debugHookTypes : null;\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        if (\"[object AsyncFunction]\" === Object.prototype.toString.call(Component) || \"[object AsyncGeneratorFunction]\" === Object.prototype.toString.call(Component)) nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber$1), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(\"async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\"));\n        workInProgress.memoizedState = null;\n        workInProgress.updateQueue = null;\n        workInProgress.lanes = 0;\n        ReactSharedInternals.H = null !== current && null !== current.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;\n        shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress.mode & 8) !== NoMode;\n        var children = callComponentInDEV(Component, props, secondArg);\n        shouldDoubleInvokeUserFnsInHooksDEV = !1;\n        didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress, Component, props, secondArg));\n        if (nextRenderLanes) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        finishRenderingHooks(current, workInProgress);\n        return children;\n    }\n    function finishRenderingHooks(current, workInProgress) {\n        workInProgress._debugHookTypes = hookTypesDev;\n        null === workInProgress.dependencies ? null !== thenableState && (workInProgress.dependencies = {\n            lanes: 0,\n            firstContext: null,\n            _debugThenableState: thenableState\n        }) : workInProgress.dependencies._debugThenableState = thenableState;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\n        renderLanes = 0;\n        hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n        hookTypesUpdateIndexDev = -1;\n        null !== current && (current.flags & 31457280) !== (workInProgress.flags & 31457280) && console.error(\"Internal React error: Expected static flag was missing. Please notify the React team.\");\n        didScheduleRenderPhaseUpdate = !1;\n        thenableIndexCounter = 0;\n        thenableState = null;\n        if (didRenderTooFewHooks) throw Error(\"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\");\n        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));\n        needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = !1, current = !0) : current = !1;\n        current && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Unknown\", didWarnAboutUseWrappedInTryCatch.has(workInProgress) || didWarnAboutAsyncClientComponent.has(workInProgress) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress), console.error(\"`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.\")));\n    }\n    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n        currentlyRenderingFiber$1 = workInProgress;\n        var numberOfReRenders = 0;\n        do {\n            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);\n            thenableIndexCounter = 0;\n            didScheduleRenderPhaseUpdateDuringThisPass = !1;\n            if (numberOfReRenders >= RE_RENDER_LIMIT) throw Error(\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\");\n            numberOfReRenders += 1;\n            ignorePreviousDependencies = !1;\n            workInProgressHook = currentHook = null;\n            if (null != workInProgress.updateQueue) {\n                var children = workInProgress.updateQueue;\n                children.lastEffect = null;\n                children.events = null;\n                children.stores = null;\n                null != children.memoCache && (children.memoCache.index = 0);\n            }\n            hookTypesUpdateIndexDev = -1;\n            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;\n            children = callComponentInDEV(Component, props, secondArg);\n        }while (didScheduleRenderPhaseUpdateDuringThisPass);\n        return children;\n    }\n    function TransitionAwareHostComponent() {\n        _s();\n        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];\n        maybeThenable = \"function\" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;\n        dispatcher = dispatcher.useState()[0];\n        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);\n        return maybeThenable;\n    }\n    _s(TransitionAwareHostComponent, \"8e0m97MbHCt0PaZ9VuKk20pjBsg=\", false, function() {\n        return [\n            useThenable\n        ];\n    });\n    function checkDidRenderIdHook() {\n        var didRenderIdHook = 0 !== localIdCounter;\n        localIdCounter = 0;\n        return didRenderIdHook;\n    }\n    function bailoutHooks(current, workInProgress, lanes) {\n        workInProgress.updateQueue = current.updateQueue;\n        workInProgress.flags = (workInProgress.mode & 16) !== NoMode ? workInProgress.flags & -201328645 : workInProgress.flags & -2053;\n        current.lanes &= ~lanes;\n    }\n    function resetHooksOnUnwind(workInProgress) {\n        if (didScheduleRenderPhaseUpdate) {\n            for(workInProgress = workInProgress.memoizedState; null !== workInProgress;){\n                var queue = workInProgress.queue;\n                null !== queue && (queue.pending = null);\n                workInProgress = workInProgress.next;\n            }\n            didScheduleRenderPhaseUpdate = !1;\n        }\n        renderLanes = 0;\n        hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n        hookTypesUpdateIndexDev = -1;\n        currentHookNameInDev = null;\n        didScheduleRenderPhaseUpdateDuringThisPass = !1;\n        thenableIndexCounter = localIdCounter = 0;\n        thenableState = null;\n    }\n    function mountWorkInProgressHook() {\n        var hook = {\n            memoizedState: null,\n            baseState: null,\n            baseQueue: null,\n            queue: null,\n            next: null\n        };\n        null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;\n        return workInProgressHook;\n    }\n    function updateWorkInProgressHook() {\n        if (null === currentHook) {\n            var nextCurrentHook = currentlyRenderingFiber$1.alternate;\n            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\n        } else nextCurrentHook = currentHook.next;\n        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;\n        if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;\n        else {\n            if (null === nextCurrentHook) {\n                if (null === currentlyRenderingFiber$1.alternate) throw Error(\"Update hook called on initial render. This is likely a bug in React. Please file an issue.\");\n                throw Error(\"Rendered more hooks than during the previous render.\");\n            }\n            currentHook = nextCurrentHook;\n            nextCurrentHook = {\n                memoizedState: currentHook.memoizedState,\n                baseState: currentHook.baseState,\n                baseQueue: currentHook.baseQueue,\n                queue: currentHook.queue,\n                next: null\n            };\n            null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;\n        }\n        return workInProgressHook;\n    }\n    function useThenable(thenable) {\n        var index = thenableIndexCounter;\n        thenableIndexCounter += 1;\n        null === thenableState && (thenableState = createThenableState());\n        thenable = trackUsedThenable(thenableState, thenable, index);\n        index = currentlyRenderingFiber$1;\n        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);\n        return thenable;\n    }\n    function use(usable) {\n        if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then) return useThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\n        }\n        throw Error(\"An unsupported type was passed to use(): \" + String(usable));\n    }\n    function useMemoCache(size) {\n        var memoCache = null, updateQueue = currentlyRenderingFiber$1.updateQueue;\n        null !== updateQueue && (memoCache = updateQueue.memoCache);\n        if (null == memoCache) {\n            var current = currentlyRenderingFiber$1.alternate;\n            null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {\n                data: current.data.map(function(array) {\n                    return array.slice();\n                }),\n                index: 0\n            })));\n        }\n        null == memoCache && (memoCache = {\n            data: [],\n            index: 0\n        });\n        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);\n        updateQueue.memoCache = memoCache;\n        updateQueue = memoCache.data[memoCache.index];\n        if (void 0 === updateQueue || ignorePreviousDependencies) for(updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\n        else updateQueue.length !== size && console.error(\"Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.\", updateQueue.length, size);\n        memoCache.index++;\n        return updateQueue;\n    }\n    function basicStateReducer(state, action) {\n        return \"function\" === typeof action ? action(state) : action;\n    }\n    function mountReducer(reducer, initialArg, init) {\n        var hook = mountWorkInProgressHook();\n        if (void 0 !== init) {\n            var initialState = init(initialArg);\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    init(initialArg);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        } else initialState = initialArg;\n        hook.memoizedState = hook.baseState = initialState;\n        reducer = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: reducer,\n            lastRenderedState: initialState\n        };\n        hook.queue = reducer;\n        reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, reducer);\n        return [\n            hook.memoizedState,\n            reducer\n        ];\n    }\n    function updateReducer(reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateReducerImpl(hook, currentHook, reducer);\n    }\n    function updateReducerImpl(hook, current, reducer) {\n        var queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;\n        if (null !== pendingQueue) {\n            if (null !== baseQueue) {\n                var baseFirst = baseQueue.next;\n                baseQueue.next = pendingQueue.next;\n                pendingQueue.next = baseFirst;\n            }\n            current.baseQueue !== baseQueue && console.error(\"Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.\");\n            current.baseQueue = baseQueue = pendingQueue;\n            queue.pending = null;\n        }\n        pendingQueue = hook.baseState;\n        if (null === baseQueue) hook.memoizedState = pendingQueue;\n        else {\n            current = baseQueue.next;\n            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction = !1;\n            do {\n                var updateLane = update.lane & -536870913;\n                if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    var revertLane = update.revertLane;\n                    if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {\n                        lane: 0,\n                        revertLane: 0,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    else if ((renderLanes & revertLane) === revertLane) {\n                        update = update.next;\n                        revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                        continue;\n                    } else updateLane = {\n                        lane: 0,\n                        revertLane: update.revertLane,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;\n                    updateLane = update.action;\n                    shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);\n                    pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);\n                } else revertLane = {\n                    lane: updateLane,\n                    revertLane: update.revertLane,\n                    action: update.action,\n                    hasEagerState: update.hasEagerState,\n                    eagerState: update.eagerState,\n                    next: null\n                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;\n                update = update.next;\n            }while (null !== update && update !== current);\n            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;\n            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;\n            hook.memoizedState = pendingQueue;\n            hook.baseState = baseFirst;\n            hook.baseQueue = newBaseQueueLast;\n            queue.lastRenderedState = pendingQueue;\n        }\n        null === baseQueue && (queue.lanes = 0);\n        return [\n            hook.memoizedState,\n            queue.dispatch\n        ];\n    }\n    function rerenderReducer(reducer) {\n        var hook = updateWorkInProgressHook(), queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;\n        if (null !== lastRenderPhaseUpdate) {\n            queue.pending = null;\n            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n            do newState = reducer(newState, update.action), update = update.next;\n            while (update !== lastRenderPhaseUpdate);\n            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\n            hook.memoizedState = newState;\n            null === hook.baseQueue && (hook.baseState = newState);\n            queue.lastRenderedState = newState;\n        }\n        return [\n            newState,\n            dispatch\n        ];\n    }\n    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1, hook = mountWorkInProgressHook();\n        if (isHydrating) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            var nextSnapshot = getServerSnapshot();\n            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        } else {\n            nextSnapshot = getSnapshot();\n            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0));\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n        }\n        hook.memoizedState = nextSnapshot;\n        getServerSnapshot = {\n            value: nextSnapshot,\n            getSnapshot: getSnapshot\n        };\n        hook.queue = getServerSnapshot;\n        mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [\n            subscribe\n        ]);\n        fiber.flags |= 2048;\n        pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), {\n            destroy: void 0\n        }, null);\n        return nextSnapshot;\n    }\n    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;\n        if (isHydrating$jscomp$0) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            getServerSnapshot = getServerSnapshot();\n        } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {\n            var cachedSnapshot = getSnapshot();\n            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        }\n        if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot)) hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0;\n        hook = hook.queue;\n        var create = subscribeToStore.bind(null, fiber, hook, subscribe);\n        updateEffectImpl(2048, Passive, create, [\n            subscribe\n        ]);\n        if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {\n            fiber.flags |= 2048;\n            pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), {\n                destroy: void 0\n            }, null);\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n        }\n        return getServerSnapshot;\n    }\n    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n        fiber.flags |= 16384;\n        fiber = {\n            getSnapshot: getSnapshot,\n            value: renderedSnapshot\n        };\n        getSnapshot = currentlyRenderingFiber$1.updateQueue;\n        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [\n            fiber\n        ]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [\n            fiber\n        ] : renderedSnapshot.push(fiber));\n    }\n    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n        inst.value = nextSnapshot;\n        inst.getSnapshot = getSnapshot;\n        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n    }\n    function subscribeToStore(fiber, inst, subscribe) {\n        return subscribe(function() {\n            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n        });\n    }\n    function checkIfSnapshotChanged(inst) {\n        var latestGetSnapshot = inst.getSnapshot;\n        inst = inst.value;\n        try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(inst, nextValue);\n        } catch (error) {\n            return !0;\n        }\n    }\n    function forceStoreRerender(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    }\n    function mountStateImpl(initialState) {\n        var hook = mountWorkInProgressHook();\n        if (\"function\" === typeof initialState) {\n            var initialStateInitializer = initialState;\n            initialState = initialStateInitializer();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    initialStateInitializer();\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        }\n        hook.memoizedState = hook.baseState = initialState;\n        hook.queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: basicStateReducer,\n            lastRenderedState: initialState\n        };\n        return hook;\n    }\n    function mountState(initialState) {\n        initialState = mountStateImpl(initialState);\n        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n        queue.dispatch = dispatch;\n        return [\n            initialState.memoizedState,\n            dispatch\n        ];\n    }\n    function mountOptimistic(passthrough) {\n        var hook = mountWorkInProgressHook();\n        hook.memoizedState = hook.baseState = passthrough;\n        var queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: null,\n            lastRenderedState: null\n        };\n        hook.queue = queue;\n        hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !0, queue);\n        queue.dispatch = hook;\n        return [\n            passthrough,\n            hook\n        ];\n    }\n    function updateOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n    }\n    function updateOptimisticImpl(hook, current, passthrough, reducer) {\n        hook.baseState = passthrough;\n        return updateReducerImpl(hook, currentHook, \"function\" === typeof reducer ? reducer : basicStateReducer);\n    }\n    function rerenderOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n        hook.baseState = passthrough;\n        return [\n            passthrough,\n            hook.queue.dispatch\n        ];\n    }\n    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {\n        if (isRenderPhaseUpdate(fiber)) throw Error(\"Cannot update form state while rendering.\");\n        fiber = actionQueue.action;\n        if (null !== fiber) {\n            var actionNode = {\n                payload: payload,\n                action: fiber,\n                next: null,\n                isTransition: !0,\n                status: \"pending\",\n                value: null,\n                reason: null,\n                listeners: [],\n                then: function(listener) {\n                    actionNode.listeners.push(listener);\n                }\n            };\n            null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;\n            setState(actionNode);\n            setPendingState = actionQueue.pending;\n            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);\n        }\n    }\n    function runActionStateAction(actionQueue, node) {\n        var action = node.action, payload = node.payload, prevState = actionQueue.state;\n        if (node.isTransition) {\n            var prevTransition = ReactSharedInternals.T, currentTransition = {};\n            ReactSharedInternals.T = currentTransition;\n            ReactSharedInternals.T._updatedFibers = new Set();\n            try {\n                var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;\n                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n                handleActionReturnValue(actionQueue, node, returnValue);\n            } catch (error) {\n                onActionError(actionQueue, node, error);\n            } finally{\n                ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n            }\n        } else try {\n            currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);\n        } catch (error$2) {\n            onActionError(actionQueue, node, error$2);\n        }\n    }\n    function handleActionReturnValue(actionQueue, node, returnValue) {\n        null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then ? (returnValue.then(function(nextState) {\n            onActionSuccess(actionQueue, node, nextState);\n        }, function(error) {\n            return onActionError(actionQueue, node, error);\n        }), node.isTransition || console.error(\"An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`\")) : onActionSuccess(actionQueue, node, returnValue);\n    }\n    function onActionSuccess(actionQueue, actionNode, nextState) {\n        actionNode.status = \"fulfilled\";\n        actionNode.value = nextState;\n        notifyActionListeners(actionNode);\n        actionQueue.state = nextState;\n        actionNode = actionQueue.pending;\n        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));\n    }\n    function onActionError(actionQueue, actionNode, error) {\n        var last = actionQueue.pending;\n        actionQueue.pending = null;\n        if (null !== last) {\n            last = last.next;\n            do actionNode.status = \"rejected\", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;\n            while (actionNode !== last);\n        }\n        actionQueue.action = null;\n    }\n    function notifyActionListeners(actionNode) {\n        actionNode = actionNode.listeners;\n        for(var i = 0; i < actionNode.length; i++)(0, actionNode[i])();\n    }\n    function actionStateReducer(oldState, newState) {\n        return newState;\n    }\n    function mountActionState(action, initialStateProp) {\n        if (isHydrating) {\n            var ssrFormState = workInProgressRoot.formState;\n            if (null !== ssrFormState) {\n                a: {\n                    var isMatching = currentlyRenderingFiber$1;\n                    if (isHydrating) {\n                        if (nextHydratableInstance) {\n                            var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);\n                            if (markerInstance) {\n                                nextHydratableInstance = getNextHydratableSibling(markerInstance);\n                                isMatching = isFormStateMarkerMatching(markerInstance);\n                                break a;\n                            }\n                        }\n                        throwOnHydrationMismatch(isMatching);\n                    }\n                    isMatching = !1;\n                }\n                isMatching && (initialStateProp = ssrFormState[0]);\n            }\n        }\n        ssrFormState = mountWorkInProgressHook();\n        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\n        isMatching = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: actionStateReducer,\n            lastRenderedState: initialStateProp\n        };\n        ssrFormState.queue = isMatching;\n        ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber$1, isMatching);\n        isMatching.dispatch = ssrFormState;\n        isMatching = mountStateImpl(!1);\n        var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !1, isMatching.queue);\n        isMatching = mountWorkInProgressHook();\n        markerInstance = {\n            state: initialStateProp,\n            dispatch: null,\n            action: action,\n            pending: null\n        };\n        isMatching.queue = markerInstance;\n        ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber$1, markerInstance, setPendingState, ssrFormState);\n        markerInstance.dispatch = ssrFormState;\n        isMatching.memoizedState = action;\n        return [\n            initialStateProp,\n            ssrFormState,\n            !1\n        ];\n    }\n    function updateActionState(action) {\n        var stateHook = updateWorkInProgressHook();\n        return updateActionStateImpl(stateHook, currentHook, action);\n    }\n    function updateActionStateImpl(stateHook, currentStateHook, action) {\n        _s1();\n        currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];\n        stateHook = updateReducer(basicStateReducer)[0];\n        currentStateHook = \"object\" === typeof currentStateHook && null !== currentStateHook && \"function\" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;\n        var actionQueueHook = updateWorkInProgressHook(), actionQueue = actionQueueHook.queue, dispatch = actionQueue.dispatch;\n        action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), {\n            destroy: void 0\n        }, null));\n        return [\n            currentStateHook,\n            dispatch,\n            stateHook\n        ];\n    }\n    _s1(updateActionStateImpl, \"EfKEwTxx33s/F+4QdJ8NA7j9Xjk=\", false, function() {\n        return [\n            useThenable\n        ];\n    });\n    function actionStateActionEffect(actionQueue, action) {\n        actionQueue.action = action;\n    }\n    function rerenderActionState(action) {\n        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;\n        if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);\n        updateWorkInProgressHook();\n        stateHook = stateHook.memoizedState;\n        currentStateHook = updateWorkInProgressHook();\n        var dispatch = currentStateHook.queue.dispatch;\n        currentStateHook.memoizedState = action;\n        return [\n            stateHook,\n            dispatch,\n            !1\n        ];\n    }\n    function pushEffect(tag, create, inst, deps) {\n        tag = {\n            tag: tag,\n            create: create,\n            inst: inst,\n            deps: deps,\n            next: null\n        };\n        create = currentlyRenderingFiber$1.updateQueue;\n        null === create && (create = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create);\n        inst = create.lastEffect;\n        null === inst ? create.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create.lastEffect = tag);\n        return tag;\n    }\n    function mountRef(initialValue) {\n        var hook = mountWorkInProgressHook();\n        initialValue = {\n            current: initialValue\n        };\n        return hook.memoizedState = initialValue;\n    }\n    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = mountWorkInProgressHook();\n        currentlyRenderingFiber$1.flags |= fiberFlags;\n        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, {\n            destroy: void 0\n        }, void 0 === deps ? null : deps);\n    }\n    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var inst = hook.memoizedState.inst;\n        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, deps));\n    }\n    function mountEffect(create, deps) {\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (currentlyRenderingFiber$1.mode & 64) === NoMode ? mountEffectImpl(142608384, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);\n    }\n    function mountLayoutEffect(create, deps) {\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (fiberFlags |= 67108864);\n        return mountEffectImpl(fiberFlags, Layout, create, deps);\n    }\n    function imperativeHandleEffect(create, ref) {\n        if (\"function\" === typeof ref) {\n            create = create();\n            var refCleanup = ref(create);\n            return function() {\n                \"function\" === typeof refCleanup ? refCleanup() : ref(null);\n            };\n        }\n        if (null !== ref && void 0 !== ref) return ref.hasOwnProperty(\"current\") || console.error(\"Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(ref).join(\", \") + \"}\"), create = create(), ref.current = create, function() {\n            ref.current = null;\n        };\n    }\n    function mountImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (fiberFlags |= 67108864);\n        mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function updateImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function mountCallback(callback, deps) {\n        mountWorkInProgressHook().memoizedState = [\n            callback,\n            void 0 === deps ? null : deps\n        ];\n        return callback;\n    }\n    function updateCallback(callback, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        hook.memoizedState = [\n            callback,\n            deps\n        ];\n        return callback;\n    }\n    function mountMemo(nextCreate, deps) {\n        var hook = mountWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var nextValue = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            nextValue,\n            deps\n        ];\n        return nextValue;\n    }\n    function updateMemo(nextCreate, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        prevState = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            prevState,\n            deps\n        ];\n        return prevState;\n    }\n    function mountDeferredValue(value, initialValue) {\n        var hook = mountWorkInProgressHook();\n        return mountDeferredValueImpl(hook, value, initialValue);\n    }\n    function updateDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function rerenderDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function mountDeferredValueImpl(hook, value, initialValue) {\n        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;\n        hook.memoizedState = initialValue;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber$1.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return initialValue;\n    }\n    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n        if (objectIs(value, prevValue)) return value;\n        if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;\n        if (0 === (renderLanes & 42)) return didReceiveUpdate = !0, hook.memoizedState = value;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber$1.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return prevValue;\n    }\n    function startTransition(fiber, queue, pendingState, finishedState, callback) {\n        var previousPriority = getCurrentUpdatePriority();\n        setCurrentUpdatePriority(0 !== previousPriority && 8 > previousPriority ? previousPriority : 8);\n        var prevTransition = ReactSharedInternals.T, currentTransition = {};\n        ReactSharedInternals.T = currentTransition;\n        dispatchOptimisticSetState(fiber, !1, queue, pendingState);\n        currentTransition._updatedFibers = new Set();\n        try {\n            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;\n            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n            if (null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then) {\n                var thenableForFinishedState = chainThenableValue(returnValue, finishedState);\n                dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));\n            } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));\n        } catch (error) {\n            dispatchSetStateInternal(fiber, queue, {\n                then: function() {},\n                status: \"rejected\",\n                reason: error\n            }, requestUpdateLane(fiber));\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n        }\n    }\n    function ensureFormComponentIsStateful(formFiber) {\n        var existingStateHook = formFiber.memoizedState;\n        if (null !== existingStateHook) return existingStateHook;\n        existingStateHook = {\n            memoizedState: NotPendingTransition,\n            baseState: NotPendingTransition,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: NotPendingTransition\n            },\n            next: null\n        };\n        var initialResetState = {};\n        existingStateHook.next = {\n            memoizedState: initialResetState,\n            baseState: initialResetState,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialResetState\n            },\n            next: null\n        };\n        formFiber.memoizedState = existingStateHook;\n        formFiber = formFiber.alternate;\n        null !== formFiber && (formFiber.memoizedState = existingStateHook);\n        return existingStateHook;\n    }\n    function mountTransition() {\n        var stateHook = mountStateImpl(!1);\n        stateHook = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, !0, !1);\n        mountWorkInProgressHook().memoizedState = stateHook;\n        return [\n            !1,\n            stateHook\n        ];\n    }\n    function updateTransition() {\n        _s2();\n        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    _s2(updateTransition, \"EfKEwTxx33s/F+4QdJ8NA7j9Xjk=\", false, function() {\n        return [\n            useThenable\n        ];\n    });\n    function rerenderTransition() {\n        _s3();\n        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    _s3(rerenderTransition, \"EfKEwTxx33s/F+4QdJ8NA7j9Xjk=\", false, function() {\n        return [\n            useThenable\n        ];\n    });\n    function useHostTransitionStatus() {\n        return readContext(HostTransitionContext);\n    }\n    function mountId() {\n        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;\n        if (isHydrating) {\n            var treeId = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;\n            identifierPrefix = \":\" + identifierPrefix + \"R\" + treeId;\n            treeId = localIdCounter++;\n            0 < treeId && (identifierPrefix += \"H\" + treeId.toString(32));\n            identifierPrefix += \":\";\n        } else treeId = globalClientIdCounter++, identifierPrefix = \":\" + identifierPrefix + \"r\" + treeId.toString(32) + \":\";\n        return hook.memoizedState = identifierPrefix;\n    }\n    function mountRefresh() {\n        return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);\n    }\n    function refreshCache(fiber, seedKey) {\n        for(var provider = fiber.return; null !== provider;){\n            switch(provider.tag){\n                case 24:\n                case 3:\n                    var lane = requestUpdateLane(provider);\n                    fiber = createUpdate(lane);\n                    var root = enqueueUpdate(provider, fiber, lane);\n                    null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));\n                    provider = createCache();\n                    null !== seedKey && void 0 !== seedKey && null !== root && console.error(\"The seed argument is not enabled outside experimental channels.\");\n                    fiber.payload = {\n                        cache: provider\n                    };\n                    return;\n            }\n            provider = provider.return;\n        }\n    }\n    function dispatchReducerAction(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0) {\n        \"function\" === typeof JSCompiler_OptimizeArgumentsArray_p0 && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        JSCompiler_OptimizeArgumentsArray_p0 = requestUpdateLane(fiber);\n        action = {\n            lane: JSCompiler_OptimizeArgumentsArray_p0,\n            revertLane: 0,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0), null !== action && (scheduleUpdateOnFiber(action, fiber, JSCompiler_OptimizeArgumentsArray_p0), entangleTransitionUpdate(action, queue, JSCompiler_OptimizeArgumentsArray_p0)));\n        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p0);\n    }\n    function dispatchSetState(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1) {\n        \"function\" === typeof JSCompiler_OptimizeArgumentsArray_p1 && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        JSCompiler_OptimizeArgumentsArray_p1 = requestUpdateLane(fiber);\n        dispatchSetStateInternal(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1);\n        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p1);\n    }\n    function dispatchSetStateInternal(fiber, queue, action, lane) {\n        var update = {\n            lane: lane,\n            revertLane: 0,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\n        else {\n            var alternate = fiber.alternate;\n            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {\n                var prevDispatcher = ReactSharedInternals.H;\n                ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                try {\n                    var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);\n                    update.hasEagerState = !0;\n                    update.eagerState = eagerState;\n                    if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;\n                } catch (error) {} finally{\n                    ReactSharedInternals.H = prevDispatcher;\n                }\n            }\n            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n            if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;\n        }\n        return !1;\n    }\n    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n        null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(\"An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.\");\n        action = {\n            lane: 2,\n            revertLane: requestTransitionLane(),\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) {\n            if (throwIfDuringRender) throw Error(\"Cannot update optimistic state while rendering.\");\n            console.error(\"Cannot call startTransition while rendering.\");\n        } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\n        markStateUpdateScheduled(fiber, 2);\n    }\n    function isRenderPhaseUpdate(fiber) {\n        var alternate = fiber.alternate;\n        return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;\n    }\n    function enqueueRenderPhaseUpdate(queue, update) {\n        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;\n        var pending = queue.pending;\n        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n        queue.pending = update;\n    }\n    function entangleTransitionUpdate(root, queue, lane) {\n        if (0 !== (lane & 4194176)) {\n            var queueLanes = queue.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            queue.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function warnOnInvalidCallback(callback) {\n        if (null !== callback && \"function\" !== typeof callback) {\n            var key = String(callback);\n            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback));\n        }\n    }\n    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n        var prevState = workInProgress.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);\n        if (workInProgress.mode & 8) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                partialState = getDerivedStateFromProps(nextProps, prevState);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        void 0 === partialState && (ctor = getComponentNameFromType(ctor) || \"Component\", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\", ctor)));\n        prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);\n        workInProgress.memoizedState = prevState;\n        0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = prevState);\n    }\n    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n        var instance = workInProgress.stateNode;\n        if (\"function\" === typeof instance.shouldComponentUpdate) {\n            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            void 0 === oldProps && console.error(\"%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n            return oldProps;\n        }\n        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;\n    }\n    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n        var oldState = instance.state;\n        \"function\" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);\n        \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n        instance.state !== oldState && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Component\", didWarnAboutStateAssignmentForComponent.has(workInProgress) || (didWarnAboutStateAssignmentForComponent.add(workInProgress), console.error(\"%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", workInProgress)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));\n    }\n    function resolveClassComponentProps(Component, baseProps) {\n        var newProps = baseProps;\n        if (\"ref\" in baseProps) {\n            newProps = {};\n            for(var propName in baseProps)\"ref\" !== propName && (newProps[propName] = baseProps[propName]);\n        }\n        if (Component = Component.defaultProps) {\n            newProps === baseProps && (newProps = assign({}, newProps));\n            for(var _propName in Component)void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);\n        }\n        return newProps;\n    }\n    function logUncaughtError(root, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = null;\n            var error = errorInfo.value;\n            if (null !== ReactSharedInternals.actQueue) ReactSharedInternals.thrownErrors.push(error);\n            else {\n                var onUncaughtError = root.onUncaughtError;\n                onUncaughtError(error, {\n                    componentStack: errorInfo.stack\n                });\n            }\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function logCaughtError(root, boundary, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = getComponentNameFromFiber(boundary);\n            var onCaughtError = root.onCaughtError;\n            onCaughtError(errorInfo.value, {\n                componentStack: errorInfo.stack,\n                errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\n            });\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function createRootErrorUpdate(root, errorInfo, lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        lane.payload = {\n            element: null\n        };\n        lane.callback = function() {\n            runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);\n        };\n        return lane;\n    }\n    function createClassErrorUpdate(lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        return lane;\n    }\n    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n        if (\"function\" === typeof getDerivedStateFromError) {\n            var error = errorInfo.value;\n            update.payload = function() {\n                return getDerivedStateFromError(error);\n            };\n            update.callback = function() {\n                markFailedErrorBoundaryForHotReloading(fiber);\n                runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            };\n        }\n        var inst = fiber.stateNode;\n        null !== inst && \"function\" === typeof inst.componentDidCatch && (update.callback = function() {\n            markFailedErrorBoundaryForHotReloading(fiber);\n            runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            \"function\" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([\n                this\n            ]) : legacyErrorBoundariesThatAlreadyFailed.add(this));\n            callComponentDidCatchInDEV(this, errorInfo);\n            \"function\" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(\"%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n        });\n    }\n    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n        sourceFiber.flags |= 32768;\n        isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);\n        if (null !== value && \"object\" === typeof value && \"function\" === typeof value.then) {\n            returnFiber = sourceFiber.alternate;\n            null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);\n            isHydrating && (didSuspendOrErrorDEV = !0);\n            sourceFiber = suspenseHandlerStackCursor.current;\n            if (null !== sourceFiber) {\n                switch(sourceFiber.tag){\n                    case 13:\n                        return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([\n                            value\n                        ]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;\n                    case 22:\n                        return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {\n                            transitions: null,\n                            markerInstances: null,\n                            retryQueue: new Set([\n                                value\n                            ])\n                        }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([\n                            value\n                        ]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;\n                }\n                throw Error(\"Unexpected Suspense handler tag (\" + sourceFiber.tag + \"). This is a bug in React.\");\n            }\n            attachPingListener(root, value, rootRenderLanes);\n            renderDidSuspendDelayIfPossible();\n            return !1;\n        }\n        if (isHydrating) return didSuspendOrErrorDEV = !0, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.\", {\n            cause: value\n        }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering the entire root.\", {\n            cause: value\n        }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), !1;\n        var error = createCapturedValueAtFiber(Error(\"There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.\", {\n            cause: value\n        }), sourceFiber);\n        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [\n            error\n        ] : workInProgressRootConcurrentErrors.push(error);\n        workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);\n        if (null === returnFiber) return !0;\n        value = createCapturedValueAtFiber(value, sourceFiber);\n        sourceFiber = returnFiber;\n        do {\n            switch(sourceFiber.tag){\n                case 3:\n                    return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;\n                case 1:\n                    if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && (\"function\" === typeof returnFiber.getDerivedStateFromError || null !== error && \"function\" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;\n            }\n            sourceFiber = sourceFiber.return;\n        }while (null !== sourceFiber);\n        return !1;\n    }\n    function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n        workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n    }\n    function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n        Component = Component.render;\n        var ref = workInProgress.ref;\n        if (\"ref\" in nextProps) {\n            var propsWithoutRef = {};\n            for(var key in nextProps)\"ref\" !== key && (propsWithoutRef[key] = nextProps[key]);\n        } else propsWithoutRef = nextProps;\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);\n        key = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && key && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null === current) {\n            var type = Component.type;\n            if (\"function\" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return Component = resolveFunctionForHotReloading(type), workInProgress.tag = 15, workInProgress.type = Component, validateFunctionComponentInDev(workInProgress, type), updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes);\n            current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n            current.ref = workInProgress.ref;\n            current.return = workInProgress;\n            return workInProgress.child = current;\n        }\n        type = current.child;\n        if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n            var prevProps = type.memoizedProps;\n            Component = Component.compare;\n            Component = null !== Component ? Component : shallowEqual;\n            if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        workInProgress.flags |= 1;\n        current = createWorkInProgress(type, nextProps);\n        current.ref = workInProgress.ref;\n        current.return = workInProgress;\n        return workInProgress.child = current;\n    }\n    function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null !== current) {\n            var prevProps = current.memoizedProps;\n            if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\n            else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n    }\n    function updateOffscreenComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, nextChildren = nextProps.children, nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2), prevState = null !== current ? current.memoizedState : null;\n        markRef(current, workInProgress);\n        if (\"hidden\" === nextProps.mode || nextIsDetached) {\n            if (0 !== (workInProgress.flags & 128)) {\n                nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\n                if (null !== current) {\n                    nextChildren = workInProgress.child = current.child;\n                    for(nextIsDetached = 0; null !== nextChildren;)nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;\n                    workInProgress.childLanes = nextIsDetached & ~nextProps;\n                } else workInProgress.childLanes = 0, workInProgress.child = null;\n                return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);\n            }\n            if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {\n                baseLanes: 0,\n                cachePool: null\n            }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(workInProgress), pushOffscreenSuspenseHandler(workInProgress);\n            else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);\n        } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(workInProgress), reuseSuspenseHandlerOnStack(workInProgress));\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {\n        var JSCompiler_inline_result = peekCacheFromPool();\n        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: JSCompiler_inline_result\n        };\n        workInProgress.memoizedState = {\n            baseLanes: nextBaseLanes,\n            cachePool: JSCompiler_inline_result\n        };\n        null !== current && pushTransition(workInProgress, null);\n        reuseHiddenContextOnStack(workInProgress);\n        pushOffscreenSuspenseHandler(workInProgress);\n        null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);\n        return null;\n    }\n    function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n        if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 2097664);\n        else {\n            if (\"function\" !== typeof ref && \"object\" !== typeof ref) throw Error(\"Expected ref to be a function, an object returned by React.createRef(), or undefined/null.\");\n            if (null === current || current.ref !== ref) workInProgress.flags |= 2097664;\n        }\n    }\n    function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (Component.prototype && \"function\" === typeof Component.prototype.render) {\n            var componentName = getComponentNameFromType(Component) || \"Unknown\";\n            didWarnAboutBadClass[componentName] || (console.error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName), didWarnAboutBadClass[componentName] = !0);\n        }\n        workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n        null === current && (validateFunctionComponentInDev(workInProgress, workInProgress.type), Component.contextTypes && (componentName = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypes[componentName] || (didWarnAboutContextTypes[componentName] = !0, console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\", componentName))));\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);\n        nextProps = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, Component, renderLanes);\n        return workInProgress.child;\n    }\n    function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        workInProgress.updateQueue = null;\n        nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);\n        finishRenderingHooks(current, workInProgress);\n        Component = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && Component && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateClassComponent(current$jscomp$0, workInProgress, Component, nextProps, renderLanes) {\n        switch(shouldErrorImpl(workInProgress)){\n            case !1:\n                var _instance = workInProgress.stateNode, state = new workInProgress.type(workInProgress.memoizedProps, _instance.context).state;\n                _instance.updater.enqueueSetState(_instance, state, null);\n                break;\n            case !0:\n                workInProgress.flags |= 128;\n                workInProgress.flags |= 65536;\n                _instance = Error(\"Simulated error coming from DevTools\");\n                var lane = renderLanes & -renderLanes;\n                workInProgress.lanes |= lane;\n                state = workInProgressRoot;\n                if (null === state) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                lane = createClassErrorUpdate(lane);\n                initializeClassErrorUpdate(lane, state, workInProgress, createCapturedValueAtFiber(_instance, workInProgress));\n                enqueueCapturedUpdate(workInProgress, lane);\n        }\n        prepareToReadContext(workInProgress);\n        if (null === workInProgress.stateNode) {\n            state = emptyContextObject;\n            _instance = Component.contextType;\n            \"contextType\" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\" : \"object\" !== typeof _instance ? \" However, it is set to a \" + typeof _instance + \".\" : _instance.$$typeof === REACT_CONSUMER_TYPE ? \" Did you accidentally pass the Context.Consumer instead?\" : \" However, it is set to an object with keys {\" + Object.keys(_instance).join(\", \") + \"}.\", console.error(\"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(Component) || \"Component\", lane));\n            \"object\" === typeof _instance && null !== _instance && (state = readContext(_instance));\n            _instance = new Component(nextProps, state);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    _instance = new Component(nextProps, state);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            state = workInProgress.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;\n            _instance.updater = classComponentUpdater;\n            workInProgress.stateNode = _instance;\n            _instance._reactInternals = workInProgress;\n            _instance._reactInternalInstance = fakeInternalInstance;\n            \"function\" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(\"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", state, null === _instance.state ? \"null\" : \"undefined\", state)));\n            if (\"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) {\n                var foundWillUpdateName = lane = state = null;\n                \"function\" === typeof _instance.componentWillMount && !0 !== _instance.componentWillMount.__suppressDeprecationWarning ? state = \"componentWillMount\" : \"function\" === typeof _instance.UNSAFE_componentWillMount && (state = \"UNSAFE_componentWillMount\");\n                \"function\" === typeof _instance.componentWillReceiveProps && !0 !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = \"componentWillReceiveProps\" : \"function\" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = \"UNSAFE_componentWillReceiveProps\");\n                \"function\" === typeof _instance.componentWillUpdate && !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = \"componentWillUpdate\" : \"function\" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n                if (null !== state || null !== lane || null !== foundWillUpdateName) {\n                    _instance = getComponentNameFromType(Component) || \"Component\";\n                    var newApiName = \"function\" === typeof Component.getDerivedStateFromProps ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                    didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\", _instance, newApiName, null !== state ? \"\\n  \" + state : \"\", null !== lane ? \"\\n  \" + lane : \"\", null !== foundWillUpdateName ? \"\\n  \" + foundWillUpdateName : \"\"));\n                }\n            }\n            _instance = workInProgress.stateNode;\n            state = getComponentNameFromType(Component) || \"Component\";\n            _instance.render || (Component.prototype && \"function\" === typeof Component.prototype.render ? console.error(\"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\", state) : console.error(\"No `render` method found on the %s instance: you may have forgotten to define `render`.\", state));\n            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(\"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\", state);\n            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(\"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\", state);\n            _instance.contextType && console.error(\"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\", state);\n            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(\"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\", state));\n            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\", state));\n            \"function\" === typeof _instance.componentShouldUpdate && console.error(\"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\", state);\n            Component.prototype && Component.prototype.isPureReactComponent && \"undefined\" !== typeof _instance.shouldComponentUpdate && console.error(\"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(Component) || \"A pure component\");\n            \"function\" === typeof _instance.componentDidUnmount && console.error(\"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\", state);\n            \"function\" === typeof _instance.componentDidReceiveProps && console.error(\"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", state);\n            \"function\" === typeof _instance.componentWillRecieveProps && console.error(\"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", state);\n            \"function\" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(\"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", state);\n            lane = _instance.props !== nextProps;\n            void 0 !== _instance.props && lane && console.error(\"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\", state);\n            _instance.defaultProps && console.error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\", state, state);\n            \"function\" !== typeof _instance.getSnapshotBeforeUpdate || \"function\" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(Component)));\n            \"function\" === typeof _instance.getDerivedStateFromProps && console.error(\"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof _instance.getDerivedStateFromError && console.error(\"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof Component.getSnapshotBeforeUpdate && console.error(\"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\", state);\n            (lane = _instance.state) && (\"object\" !== typeof lane || isArrayImpl(lane)) && console.error(\"%s.state: must be set to an object or null\", state);\n            \"function\" === typeof _instance.getChildContext && \"object\" !== typeof Component.childContextTypes && console.error(\"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\", state);\n            _instance = workInProgress.stateNode;\n            _instance.props = nextProps;\n            _instance.state = workInProgress.memoizedState;\n            _instance.refs = {};\n            initializeUpdateQueue(workInProgress);\n            state = Component.contextType;\n            _instance.context = \"object\" === typeof state && null !== state ? readContext(state) : emptyContextObject;\n            _instance.state === nextProps && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(\"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\", state)));\n            workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, _instance);\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, _instance);\n            _instance.state = workInProgress.memoizedState;\n            state = Component.getDerivedStateFromProps;\n            \"function\" === typeof state && (applyDerivedStateFromProps(workInProgress, Component, state, nextProps), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (state = _instance.state, \"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(\"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress) || \"Component\"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress, nextProps, _instance, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308);\n            (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864);\n            _instance = !0;\n        } else if (null === current$jscomp$0) {\n            _instance = workInProgress.stateNode;\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            lane = resolveClassComponentProps(Component, unresolvedOldProps);\n            _instance.props = lane;\n            var oldContext = _instance.context;\n            foundWillUpdateName = Component.contextType;\n            state = emptyContextObject;\n            \"object\" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));\n            newApiName = Component.getDerivedStateFromProps;\n            foundWillUpdateName = \"function\" === typeof newApiName || \"function\" === typeof _instance.getSnapshotBeforeUpdate;\n            unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\n            foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, state);\n            hasForceUpdate = !1;\n            var oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            oldContext = workInProgress.memoizedState;\n            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (\"function\" === typeof newApiName && (applyDerivedStateFromProps(workInProgress, Component, newApiName, nextProps), oldContext = workInProgress.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (\"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864)) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864), _instance = !1);\n        } else {\n            _instance = workInProgress.stateNode;\n            cloneUpdateQueue(current$jscomp$0, workInProgress);\n            state = workInProgress.memoizedProps;\n            foundWillUpdateName = resolveClassComponentProps(Component, state);\n            _instance.props = foundWillUpdateName;\n            newApiName = workInProgress.pendingProps;\n            oldState = _instance.context;\n            oldContext = Component.contextType;\n            lane = emptyContextObject;\n            \"object\" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));\n            unresolvedOldProps = Component.getDerivedStateFromProps;\n            (oldContext = \"function\" === typeof unresolvedOldProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, lane);\n            hasForceUpdate = !1;\n            oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            var newState = workInProgress.memoizedState;\n            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies) ? (\"function\" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies)) ? (oldContext || \"function\" !== typeof _instance.UNSAFE_componentWillUpdate && \"function\" !== typeof _instance.componentWillUpdate || (\"function\" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), \"function\" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), \"function\" === typeof _instance.componentDidUpdate && (workInProgress.flags |= 4), \"function\" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : (\"function\" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : (\"function\" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), _instance = !1);\n        }\n        lane = _instance;\n        markRef(current$jscomp$0, workInProgress);\n        state = 0 !== (workInProgress.flags & 128);\n        if (lane || state) {\n            lane = workInProgress.stateNode;\n            ReactSharedInternals.getCurrentStack = null === workInProgress ? null : getCurrentFiberStackInDev;\n            isRendering = !1;\n            current = workInProgress;\n            if (state && \"function\" !== typeof Component.getDerivedStateFromError) Component = null, profilerStartTime = -1;\n            else {\n                markComponentRenderStarted(workInProgress);\n                Component = callRenderInDEV(lane);\n                if (workInProgress.mode & 8) {\n                    setIsStrictModeForDevtools(!0);\n                    try {\n                        callRenderInDEV(lane);\n                    } finally{\n                        setIsStrictModeForDevtools(!1);\n                    }\n                }\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= 1;\n            null !== current$jscomp$0 && state ? (workInProgress.child = reconcileChildFibers(workInProgress, current$jscomp$0.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current$jscomp$0, workInProgress, Component, renderLanes);\n            workInProgress.memoizedState = lane.state;\n            current$jscomp$0 = workInProgress.child;\n        } else current$jscomp$0 = bailoutOnAlreadyFinishedWork(current$jscomp$0, workInProgress, renderLanes);\n        renderLanes = workInProgress.stateNode;\n        _instance && renderLanes.props !== nextProps && (didWarnAboutReassigningProps || console.error(\"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress) || \"a component\"), didWarnAboutReassigningProps = !0);\n        return current$jscomp$0;\n    }\n    function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {\n        resetHydrationState();\n        workInProgress.flags |= 256;\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function validateFunctionComponentInDev(workInProgress, Component) {\n        Component && Component.childContextTypes && console.error(\"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\", Component.displayName || Component.name || \"Component\");\n        \"function\" === typeof Component.getDerivedStateFromProps && (workInProgress = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] || (console.error(\"%s: Function components do not support getDerivedStateFromProps.\", workInProgress), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] = !0));\n        \"object\" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(\"%s: Function components do not support contextType.\", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = !0));\n    }\n    function mountSuspenseOffscreenState(renderLanes) {\n        return {\n            baseLanes: renderLanes,\n            cachePool: getSuspendedCache()\n        };\n    }\n    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {\n        current = null !== current ? current.childLanes & ~renderLanes : 0;\n        primaryTreeDidDefer && (current |= workInProgressDeferredLane);\n        return current;\n    }\n    function updateSuspenseComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps;\n        shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);\n        var showFallback = !1, didSuspend = 0 !== (workInProgress.flags & 128), JSCompiler_temp;\n        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));\n        JSCompiler_temp && (showFallback = !0, workInProgress.flags &= -129);\n        JSCompiler_temp = 0 !== (workInProgress.flags & 32);\n        workInProgress.flags &= -33;\n        if (null === current) {\n            if (isHydrating) {\n                showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);\n                if (isHydrating) {\n                    var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;\n                    (JSCompiler_temp$jscomp$0 = !nextInstance) || (JSCompiler_temp$jscomp$0 = canHydrateSuspenseInstance(nextInstance, rootOrSingletonContext), null !== JSCompiler_temp$jscomp$0 ? (warnIfNotHydrating(), workInProgress.memoizedState = {\n                        dehydrated: JSCompiler_temp$jscomp$0,\n                        treeContext: null !== treeContextProvider ? {\n                            id: treeContextId,\n                            overflow: treeContextOverflow\n                        } : null,\n                        retryLane: 536870912\n                    }, didSuspend = createFiber(18, null, null, NoMode), didSuspend.stateNode = JSCompiler_temp$jscomp$0, didSuspend.return = workInProgress, workInProgress.child = didSuspend, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = !0) : JSCompiler_temp$jscomp$0 = !1, JSCompiler_temp$jscomp$0 = !JSCompiler_temp$jscomp$0);\n                    JSCompiler_temp$jscomp$0 && (warnNonHydratedInstance(workInProgress, nextInstance), throwOnHydrationMismatch(workInProgress));\n                }\n                nextInstance = workInProgress.memoizedState;\n                if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance)) return isSuspenseInstanceFallback(nextInstance) ? workInProgress.lanes = 16 : workInProgress.lanes = 536870912, null;\n                popSuspenseHandler(workInProgress);\n            }\n            nextInstance = nextProps.children;\n            nextProps = nextProps.fallback;\n            if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = workInProgress.mode, nextInstance = mountWorkInProgressOffscreenFiber({\n                mode: \"hidden\",\n                children: nextInstance\n            }, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes, null), nextInstance.return = workInProgress, nextProps.return = workInProgress, nextInstance.sibling = nextProps, workInProgress.child = nextInstance, showFallback = workInProgress.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes), showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;\n            pushPrimaryTreeSuspenseHandler(workInProgress);\n            return mountSuspensePrimaryChildren(workInProgress, nextInstance);\n        }\n        JSCompiler_temp$jscomp$0 = current.memoizedState;\n        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {\n            if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, nextProps = mountWorkInProgressOffscreenFiber({\n                mode: \"visible\",\n                children: nextProps.children\n            }, nextInstance), showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2, nextProps.return = workInProgress, showFallback.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, reconcileChildFibers(workInProgress, current.child, null, renderLanes), nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = showFallback);\n            else if (pushPrimaryTreeSuspenseHandler(workInProgress), isHydrating && console.error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\"), isSuspenseInstanceFallback(nextInstance)) nextInstance = getSuspenseInstanceFallbackErrorDetails(nextInstance), JSCompiler_temp = nextInstance.digest, showFallback = nextInstance.message, nextProps = nextInstance.stack, nextInstance = nextInstance.componentStack, showFallback = showFallback ? Error(showFallback) : Error(\"The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.\"), showFallback.stack = nextProps || \"\", showFallback.digest = JSCompiler_temp, JSCompiler_temp = void 0 === nextInstance ? null : nextInstance, nextProps = {\n                value: showFallback,\n                source: null,\n                stack: JSCompiler_temp\n            }, \"string\" === typeof JSCompiler_temp && CapturedStacks.set(showFallback, nextProps), queueHydrationError(nextProps), workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_temp = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_temp) {\n                JSCompiler_temp = workInProgressRoot;\n                if (null !== JSCompiler_temp) {\n                    nextProps = renderLanes & -renderLanes;\n                    if (0 !== (nextProps & 42)) nextProps = 1;\n                    else switch(nextProps){\n                        case 2:\n                            nextProps = 1;\n                            break;\n                        case 8:\n                            nextProps = 4;\n                            break;\n                        case 32:\n                            nextProps = 16;\n                            break;\n                        case 128:\n                        case 256:\n                        case 512:\n                        case 1024:\n                        case 2048:\n                        case 4096:\n                        case 8192:\n                        case 16384:\n                        case 32768:\n                        case 65536:\n                        case 131072:\n                        case 262144:\n                        case 524288:\n                        case 1048576:\n                        case 2097152:\n                        case 4194304:\n                        case 8388608:\n                        case 16777216:\n                        case 33554432:\n                            nextProps = 64;\n                            break;\n                        case 268435456:\n                            nextProps = 134217728;\n                            break;\n                        default:\n                            nextProps = 0;\n                    }\n                    nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes)) ? 0 : nextProps;\n                    if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane) throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;\n                }\n                isSuspenseInstancePending(nextInstance) || renderDidSuspendDelayIfPossible();\n                workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            } else isSuspenseInstancePending(nextInstance) ? (workInProgress.flags |= 128, workInProgress.child = current.child, workInProgress = retryDehydratedSuspenseBoundary.bind(null, current), registerSuspenseInstanceRetry(nextInstance, workInProgress), workInProgress = null) : (current = JSCompiler_temp$jscomp$0.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(nextInstance), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress)), workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children), workInProgress.flags |= 4096);\n            return workInProgress;\n        }\n        if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, JSCompiler_temp$jscomp$0 = current.child, didSuspend = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {\n            mode: \"hidden\",\n            children: nextProps.children\n        }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 31457280, null !== didSuspend ? showFallback = createWorkInProgress(didSuspend, showFallback) : (showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2), showFallback.return = workInProgress, nextProps.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, nextProps = showFallback, showFallback = workInProgress.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (didSuspend = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== didSuspend ? {\n            parent: didSuspend,\n            pool: didSuspend\n        } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {\n            baseLanes: nextInstance.baseLanes | renderLanes,\n            cachePool: JSCompiler_temp$jscomp$0\n        }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n        renderLanes = current.child;\n        current = renderLanes.sibling;\n        renderLanes = createWorkInProgress(renderLanes, {\n            mode: \"visible\",\n            children: nextProps.children\n        });\n        renderLanes.return = workInProgress;\n        renderLanes.sibling = null;\n        null !== current && (JSCompiler_temp = workInProgress.deletions, null === JSCompiler_temp ? (workInProgress.deletions = [\n            current\n        ], workInProgress.flags |= 16) : JSCompiler_temp.push(current));\n        workInProgress.child = renderLanes;\n        workInProgress.memoizedState = null;\n        return renderLanes;\n    }\n    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\n        primaryChildren = mountWorkInProgressOffscreenFiber({\n            mode: \"visible\",\n            children: primaryChildren\n        }, workInProgress.mode);\n        primaryChildren.return = workInProgress;\n        return workInProgress.child = primaryChildren;\n    }\n    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\n        return createFiberFromOffscreen(offscreenProps, mode, 0, null);\n    }\n    function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n        reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n        current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);\n        current.flags |= 2;\n        workInProgress.memoizedState = null;\n        return current;\n    }\n    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n        fiber.lanes |= renderLanes;\n        var alternate = fiber.alternate;\n        null !== alternate && (alternate.lanes |= renderLanes);\n        scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n    }\n    function validateSuspenseListNestedChild(childSlot, index) {\n        var isAnArray = isArrayImpl(childSlot);\n        childSlot = !isAnArray && \"function\" === typeof getIteratorFn(childSlot);\n        return isAnArray || childSlot ? (isAnArray = isAnArray ? \"array\" : \"iterable\", console.error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>\", isAnArray, index, isAnArray), !1) : !0;\n    }\n    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n        var renderState = workInProgress.memoizedState;\n        null === renderState ? workInProgress.memoizedState = {\n            isBackwards: isBackwards,\n            rendering: null,\n            renderingStartTime: 0,\n            last: lastContentRow,\n            tail: tail,\n            tailMode: tailMode\n        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);\n    }\n    function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;\n        nextProps = nextProps.children;\n        if (void 0 !== revealOrder && \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && \"together\" !== revealOrder && !didWarnAboutRevealOrder[revealOrder]) if (didWarnAboutRevealOrder[revealOrder] = !0, \"string\" === typeof revealOrder) switch(revealOrder.toLowerCase()){\n            case \"together\":\n            case \"forwards\":\n            case \"backwards\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            case \"forward\":\n            case \"backward\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            default:\n                console.error('\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        }\n        else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        void 0 === tailMode || didWarnAboutTailOptions[tailMode] || (\"collapsed\" !== tailMode && \"hidden\" !== tailMode ? (didWarnAboutTailOptions[tailMode] = !0, console.error('\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"collapsed\" or \"hidden\"?', tailMode)) : \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && (didWarnAboutTailOptions[tailMode] = !0, console.error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?', tailMode)));\n        a: if ((\"forwards\" === revealOrder || \"backwards\" === revealOrder) && void 0 !== nextProps && null !== nextProps && !1 !== nextProps) if (isArrayImpl(nextProps)) for(var i = 0; i < nextProps.length; i++){\n            if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;\n        }\n        else if (i = getIteratorFn(nextProps), \"function\" === typeof i) {\n            if (i = i.call(nextProps)) for(var step = i.next(), _i = 0; !step.done; step = i.next()){\n                if (!validateSuspenseListNestedChild(step.value, _i)) break a;\n                _i++;\n            }\n        } else console.error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        nextProps = suspenseStackCursor.current;\n        if (0 !== (nextProps & ForceSuspenseFallback)) nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress.flags |= 128;\n        else {\n            if (null !== current && 0 !== (current.flags & 128)) a: for(current = workInProgress.child; null !== current;){\n                if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (null !== current.child) {\n                    current.child.return = current;\n                    current = current.child;\n                    continue;\n                }\n                if (current === workInProgress) break a;\n                for(; null === current.sibling;){\n                    if (null === current.return || current.return === workInProgress) break a;\n                    current = current.return;\n                }\n                current.sibling.return = current.return;\n                current = current.sibling;\n            }\n            nextProps &= SubtreeSuspenseContextMask;\n        }\n        push(suspenseStackCursor, nextProps, workInProgress);\n        switch(revealOrder){\n            case \"forwards\":\n                renderLanes = workInProgress.child;\n                for(revealOrder = null; null !== renderLanes;)current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;\n                renderLanes = revealOrder;\n                null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);\n                initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);\n                break;\n            case \"backwards\":\n                renderLanes = null;\n                revealOrder = workInProgress.child;\n                for(workInProgress.child = null; null !== revealOrder;){\n                    current = revealOrder.alternate;\n                    if (null !== current && null === findFirstSuspended(current)) {\n                        workInProgress.child = revealOrder;\n                        break;\n                    }\n                    current = revealOrder.sibling;\n                    revealOrder.sibling = renderLanes;\n                    renderLanes = revealOrder;\n                    revealOrder = current;\n                }\n                initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);\n                break;\n            case \"together\":\n                initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\n                break;\n            default:\n                workInProgress.memoizedState = null;\n        }\n        return workInProgress.child;\n    }\n    function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n        null !== current && (workInProgress.dependencies = current.dependencies);\n        profilerStartTime = -1;\n        workInProgressRootSkippedLanes |= workInProgress.lanes;\n        if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {\n            if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;\n        } else return null;\n        if (null !== current && workInProgress.child !== current.child) throw Error(\"Resuming work not yet implemented.\");\n        if (null !== workInProgress.child) {\n            current = workInProgress.child;\n            renderLanes = createWorkInProgress(current, current.pendingProps);\n            workInProgress.child = renderLanes;\n            for(renderLanes.return = workInProgress; null !== current.sibling;)current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;\n            renderLanes.sibling = null;\n        }\n        return workInProgress.child;\n    }\n    function checkScheduledUpdateOrContext(current, renderLanes) {\n        if (0 !== (current.lanes & renderLanes)) return !0;\n        current = current.dependencies;\n        return null !== current && checkIfContextChanged(current) ? !0 : !1;\n    }\n    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n        switch(workInProgress.tag){\n            case 3:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n                resetHydrationState();\n                break;\n            case 27:\n            case 5:\n                pushHostContext(workInProgress);\n                break;\n            case 4:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                break;\n            case 10:\n                pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);\n                break;\n            case 12:\n                0 !== (renderLanes & workInProgress.childLanes) && (workInProgress.flags |= 4);\n                workInProgress.flags |= 2048;\n                var stateNode = workInProgress.stateNode;\n                stateNode.effectDuration = -0;\n                stateNode.passiveEffectDuration = -0;\n                break;\n            case 13:\n                stateNode = workInProgress.memoizedState;\n                if (null !== stateNode) {\n                    if (null !== stateNode.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;\n                    if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    return null !== current ? current.sibling : null;\n                }\n                pushPrimaryTreeSuspenseHandler(workInProgress);\n                break;\n            case 19:\n                var didSuspendBefore = 0 !== (current.flags & 128);\n                stateNode = 0 !== (renderLanes & workInProgress.childLanes);\n                stateNode || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), stateNode = 0 !== (renderLanes & workInProgress.childLanes));\n                if (didSuspendBefore) {\n                    if (stateNode) return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    workInProgress.flags |= 128;\n                }\n                didSuspendBefore = workInProgress.memoizedState;\n                null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);\n                push(suspenseStackCursor, suspenseStackCursor.current, workInProgress);\n                if (stateNode) break;\n                else return null;\n            case 22:\n            case 23:\n                return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n        }\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n    function beginWork(current, workInProgress, renderLanes) {\n        if (workInProgress._debugNeedsRemount && null !== current) {\n            renderLanes = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);\n            var returnFiber = workInProgress.return;\n            if (null === returnFiber) throw Error(\"Cannot swap the root fiber.\");\n            current.alternate = null;\n            workInProgress.alternate = null;\n            renderLanes.index = workInProgress.index;\n            renderLanes.sibling = workInProgress.sibling;\n            renderLanes.return = workInProgress.return;\n            renderLanes.ref = workInProgress.ref;\n            renderLanes._debugInfo = workInProgress._debugInfo;\n            if (workInProgress === returnFiber.child) returnFiber.child = renderLanes;\n            else {\n                var prevSibling = returnFiber.child;\n                if (null === prevSibling) throw Error(\"Expected parent to have a child.\");\n                for(; prevSibling.sibling !== workInProgress;)if (prevSibling = prevSibling.sibling, null === prevSibling) throw Error(\"Expected to find the previous sibling.\");\n                prevSibling.sibling = renderLanes;\n            }\n            workInProgress = returnFiber.deletions;\n            null === workInProgress ? (returnFiber.deletions = [\n                current\n            ], returnFiber.flags |= 16) : workInProgress.push(current);\n            renderLanes.flags |= 2;\n            return renderLanes;\n        }\n        if (null !== current) if (current.memoizedProps !== workInProgress.pendingProps || workInProgress.type !== current.type) didReceiveUpdate = !0;\n        else {\n            if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n            didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\n        }\n        else {\n            didReceiveUpdate = !1;\n            if (returnFiber = isHydrating) warnIfNotHydrating(), returnFiber = 0 !== (workInProgress.flags & 1048576);\n            returnFiber && (returnFiber = workInProgress.index, warnIfNotHydrating(), pushTreeId(workInProgress, treeForkCount, returnFiber));\n        }\n        workInProgress.lanes = 0;\n        switch(workInProgress.tag){\n            case 16:\n                a: if (returnFiber = workInProgress.pendingProps, current = callLazyInitInDEV(workInProgress.elementType), workInProgress.type = current, \"function\" === typeof current) shouldConstruct(current) ? (returnFiber = resolveClassComponentProps(current, returnFiber), workInProgress.tag = 1, workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateClassComponent(null, workInProgress, current, returnFiber, renderLanes)) : (workInProgress.tag = 0, validateFunctionComponentInDev(workInProgress, current), workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateFunctionComponent(null, workInProgress, current, returnFiber, renderLanes));\n                else {\n                    if (void 0 !== current && null !== current) {\n                        if (prevSibling = current.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {\n                            workInProgress.tag = 11;\n                            workInProgress.type = current = resolveForwardRefForHotReloading(current);\n                            workInProgress = updateForwardRef(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        } else if (prevSibling === REACT_MEMO_TYPE) {\n                            workInProgress.tag = 14;\n                            workInProgress = updateMemoComponent(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        }\n                    }\n                    workInProgress = \"\";\n                    null !== current && \"object\" === typeof current && current.$$typeof === REACT_LAZY_TYPE && (workInProgress = \" Did you wrap a component in React.lazy() more than once?\");\n                    current = getComponentNameFromType(current) || current;\n                    throw Error(\"Element type is invalid. Received a promise that resolves to: \" + current + \". Lazy element type must resolve to a class or function.\" + workInProgress);\n                }\n                return workInProgress;\n            case 0:\n                return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 1:\n                return returnFiber = workInProgress.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress.pendingProps), updateClassComponent(current, workInProgress, returnFiber, prevSibling, renderLanes);\n            case 3:\n                a: {\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    if (null === current) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                    var nextProps = workInProgress.pendingProps;\n                    prevSibling = workInProgress.memoizedState;\n                    returnFiber = prevSibling.element;\n                    cloneUpdateQueue(current, workInProgress);\n                    processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n                    var nextState = workInProgress.memoizedState;\n                    nextProps = nextState.cache;\n                    pushProvider(workInProgress, CacheContext, nextProps);\n                    nextProps !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                        CacheContext\n                    ], renderLanes, !0);\n                    suspendIfUpdateReadFromEntangledAsyncAction();\n                    nextProps = nextState.element;\n                    if (supportsHydration && prevSibling.isDehydrated) if (prevSibling = {\n                        element: nextProps,\n                        isDehydrated: !1,\n                        cache: nextState.cache\n                    }, workInProgress.updateQueue.baseState = prevSibling, workInProgress.memoizedState = prevSibling, workInProgress.flags & 256) {\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else if (nextProps !== returnFiber) {\n                        returnFiber = createCapturedValueAtFiber(Error(\"This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.\"), workInProgress);\n                        queueHydrationError(returnFiber);\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else for(supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinContainer(workInProgress.stateNode.containerInfo), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !0), current = mountChildFibers(workInProgress, null, nextProps, renderLanes), workInProgress.child = current; current;)current.flags = current.flags & -3 | 4096, current = current.sibling;\n                    else {\n                        resetHydrationState();\n                        if (nextProps === returnFiber) {\n                            workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                            break a;\n                        }\n                        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n                    }\n                    workInProgress = workInProgress.child;\n                }\n                return workInProgress;\n            case 26:\n                if (supportsResources) return markRef(current, workInProgress), null === current ? (current = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = current : isHydrating || (workInProgress.stateNode = createHoistableInstance(workInProgress.type, workInProgress.pendingProps, requiredContext(rootInstanceStackCursor.current), workInProgress)) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;\n            case 27:\n                if (supportsSingletons) return pushHostContext(workInProgress), null === current && supportsSingletons && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, prevSibling, returnFiber, !1), didSuspendOrErrorDEV || (returnFiber = diffHydratedPropsForDevWarnings(prevSibling, workInProgress.type, workInProgress.pendingProps, returnFiber), null !== returnFiber && (buildHydrationDiffNode(workInProgress, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, nextHydratableInstance = getFirstHydratableChild(prevSibling)), returnFiber = workInProgress.pendingProps.children, null !== current || isHydrating ? reconcileChildren(current, workInProgress, returnFiber, renderLanes) : workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes), markRef(current, workInProgress), workInProgress.child;\n            case 5:\n                return null === current && isHydrating && (nextProps = getHostContext(), returnFiber = validateHydratableInstance(workInProgress.type, workInProgress.pendingProps, nextProps), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== nextState ? (workInProgress.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedPropsForDevWarnings(nextState, workInProgress.type, workInProgress.pendingProps, nextProps), null !== nextProps && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress, nextHydratableInstance = getFirstHydratableChild(nextState), rootOrSingletonContext = !1, nextProps = !0) : nextProps = !1, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress, prevSibling), throwOnHydrationMismatch(workInProgress))), pushHostContext(workInProgress), prevSibling = workInProgress.type, nextProps = workInProgress.pendingProps, nextState = null !== current ? current.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress.flags |= 32), null !== workInProgress.memoizedState && (prevSibling = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), isPrimaryRenderer ? HostTransitionContext._currentValue = prevSibling : HostTransitionContext._currentValue2 = prevSibling), markRef(current, workInProgress), reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 6:\n                return null === current && isHydrating && (current = workInProgress.pendingProps, renderLanes = getHostContext(), current = validateHydratableTextInstance(current, renderLanes), renderLanes = nextHydratableInstance, (returnFiber = !renderLanes) || (returnFiber = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== returnFiber ? (workInProgress.stateNode = returnFiber, hydrationParentFiber = workInProgress, nextHydratableInstance = null, returnFiber = !0) : returnFiber = !1, returnFiber = !returnFiber), returnFiber && (current && warnNonHydratedInstance(workInProgress, renderLanes), throwOnHydrationMismatch(workInProgress))), null;\n            case 13:\n                return updateSuspenseComponent(current, workInProgress, renderLanes);\n            case 4:\n                return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), returnFiber = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes) : reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 11:\n                return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 7:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;\n            case 8:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 12:\n                return workInProgress.flags |= 4, workInProgress.flags |= 2048, returnFiber = workInProgress.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 10:\n                return returnFiber = workInProgress.type, prevSibling = workInProgress.pendingProps, nextProps = prevSibling.value, \"value\" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, console.error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\")), pushProvider(workInProgress, returnFiber, nextProps), reconcileChildren(current, workInProgress, prevSibling.children, renderLanes), workInProgress.child;\n            case 9:\n                return prevSibling = workInProgress.type._context, returnFiber = workInProgress.pendingProps.children, \"function\" !== typeof returnFiber && console.error(\"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"), prepareToReadContext(workInProgress), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress), returnFiber = callComponentInDEV(returnFiber, prevSibling, void 0), markComponentRenderStopped(), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 14:\n                return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 15:\n                return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 19:\n                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n            case 22:\n                return updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                return prepareToReadContext(workInProgress), returnFiber = readContext(CacheContext), null === current ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), null !== nextProps && (prevSibling.pooledCacheLanes |= renderLanes), prevSibling = nextProps), workInProgress.memoizedState = {\n                    parent: returnFiber,\n                    cache: prevSibling\n                }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, prevSibling)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current.memoizedState, nextProps = workInProgress.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {\n                    parent: returnFiber,\n                    cache: returnFiber\n                }, workInProgress.memoizedState = prevSibling, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = prevSibling), pushProvider(workInProgress, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                    CacheContext\n                ], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 29:\n                throw workInProgress.pendingProps;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function resetContextDependencies() {\n        lastContextDependency = currentlyRenderingFiber = null;\n        isDisallowedContextReadInDEV = !1;\n    }\n    function pushProvider(providerFiber, context, nextValue) {\n        isPrimaryRenderer ? (push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, push(rendererCursorDEV, context._currentRenderer, providerFiber), void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer = rendererSigil) : (push(valueCursor, context._currentValue2, providerFiber), context._currentValue2 = nextValue, push(renderer2CursorDEV, context._currentRenderer2, providerFiber), void 0 !== context._currentRenderer2 && null !== context._currentRenderer2 && context._currentRenderer2 !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer2 = rendererSigil);\n    }\n    function popProvider(context, providerFiber) {\n        var currentValue = valueCursor.current;\n        isPrimaryRenderer ? (context._currentValue = currentValue, currentValue = rendererCursorDEV.current, pop(rendererCursorDEV, providerFiber), context._currentRenderer = currentValue) : (context._currentValue2 = currentValue, currentValue = renderer2CursorDEV.current, pop(renderer2CursorDEV, providerFiber), context._currentRenderer2 = currentValue);\n        pop(valueCursor, providerFiber);\n    }\n    function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n        for(; null !== parent;){\n            var alternate = parent.alternate;\n            (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);\n            if (parent === propagationRoot) break;\n            parent = parent.return;\n        }\n        parent !== propagationRoot && console.error(\"Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {\n        var fiber = workInProgress.child;\n        null !== fiber && (fiber.return = workInProgress);\n        for(; null !== fiber;){\n            var list = fiber.dependencies;\n            if (null !== list) {\n                var nextFiber = fiber.child;\n                list = list.firstContext;\n                a: for(; null !== list;){\n                    var dependency = list;\n                    list = fiber;\n                    for(var i = 0; i < contexts.length; i++)if (dependency.context === contexts[i]) {\n                        list.lanes |= renderLanes;\n                        dependency = list.alternate;\n                        null !== dependency && (dependency.lanes |= renderLanes);\n                        scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);\n                        forcePropagateEntireTree || (nextFiber = null);\n                        break a;\n                    }\n                    list = dependency.next;\n                }\n            } else if (18 === fiber.tag) {\n                nextFiber = fiber.return;\n                if (null === nextFiber) throw Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n                nextFiber.lanes |= renderLanes;\n                list = nextFiber.alternate;\n                null !== list && (list.lanes |= renderLanes);\n                scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\n                nextFiber = null;\n            } else nextFiber = fiber.child;\n            if (null !== nextFiber) nextFiber.return = fiber;\n            else for(nextFiber = fiber; null !== nextFiber;){\n                if (nextFiber === workInProgress) {\n                    nextFiber = null;\n                    break;\n                }\n                fiber = nextFiber.sibling;\n                if (null !== fiber) {\n                    fiber.return = nextFiber.return;\n                    nextFiber = fiber;\n                    break;\n                }\n                nextFiber = nextFiber.return;\n            }\n            fiber = nextFiber;\n        }\n    }\n    function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {\n        current = null;\n        for(var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;){\n            if (!isInsidePropagationBailout) {\n                if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\n                else if (0 !== (parent.flags & 262144)) break;\n            }\n            if (10 === parent.tag) {\n                var currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent = currentParent.memoizedProps;\n                if (null !== currentParent) {\n                    var context = parent.type;\n                    objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [\n                        context\n                    ]);\n                }\n            } else if (parent === hostTransitionProviderCursor.current) {\n                currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [\n                    HostTransitionContext\n                ]);\n            }\n            parent = parent.return;\n        }\n        null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);\n        workInProgress.flags |= 262144;\n    }\n    function checkIfContextChanged(currentDependencies) {\n        for(currentDependencies = currentDependencies.firstContext; null !== currentDependencies;){\n            var context = currentDependencies.context;\n            if (!objectIs(isPrimaryRenderer ? context._currentValue : context._currentValue2, currentDependencies.memoizedValue)) return !0;\n            currentDependencies = currentDependencies.next;\n        }\n        return !1;\n    }\n    function prepareToReadContext(workInProgress) {\n        currentlyRenderingFiber = workInProgress;\n        lastContextDependency = null;\n        workInProgress = workInProgress.dependencies;\n        null !== workInProgress && (workInProgress.firstContext = null);\n    }\n    function readContext(context) {\n        isDisallowedContextReadInDEV && console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n        return readContextForConsumer(currentlyRenderingFiber, context);\n    }\n    function readContextDuringReconciliation(consumer, context) {\n        null === currentlyRenderingFiber && prepareToReadContext(consumer);\n        return readContextForConsumer(consumer, context);\n    }\n    function readContextForConsumer(consumer, context) {\n        var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n        context = {\n            context: context,\n            memoizedValue: value,\n            next: null\n        };\n        if (null === lastContextDependency) {\n            if (null === consumer) throw Error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n            lastContextDependency = context;\n            consumer.dependencies = {\n                lanes: 0,\n                firstContext: context,\n                _debugThenableState: null\n            };\n            consumer.flags |= 524288;\n        } else lastContextDependency = lastContextDependency.next = context;\n        return value;\n    }\n    function createCache() {\n        return {\n            controller: new AbortControllerLocal(),\n            data: new Map(),\n            refCount: 0\n        };\n    }\n    function retainCache(cache) {\n        cache.controller.signal.aborted && console.warn(\"A cache instance was retained after it was already freed. This likely indicates a bug in React.\");\n        cache.refCount++;\n    }\n    function releaseCache(cache) {\n        cache.refCount--;\n        0 > cache.refCount && console.warn(\"A cache instance was released after it was already freed. This likely indicates a bug in React.\");\n        0 === cache.refCount && scheduleCallback$1(NormalPriority, function() {\n            cache.controller.abort();\n        });\n    }\n    function peekCacheFromPool() {\n        var cacheResumedFromPreviousRender = resumedCache.current;\n        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;\n    }\n    function pushTransition(offscreenWorkInProgress, prevCachePool) {\n        null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n    }\n    function getSuspendedCache() {\n        var cacheFromPool = peekCacheFromPool();\n        return null === cacheFromPool ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: cacheFromPool\n        };\n    }\n    function markUpdate(workInProgress) {\n        workInProgress.flags |= 4;\n    }\n    function doesRequireClone(current, completedWork) {\n        if (null !== current && current.child === completedWork.child) return !1;\n        if (0 !== (completedWork.flags & 16)) return !0;\n        for(current = completedWork.child; null !== current;){\n            if (0 !== (current.flags & 13878) || 0 !== (current.subtreeFlags & 13878)) return !0;\n            current = current.sibling;\n        }\n        return !1;\n    }\n    function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsMutation) for(needsVisibilityToggle = workInProgress.child; null !== needsVisibilityToggle;){\n            if (5 === needsVisibilityToggle.tag || 6 === needsVisibilityToggle.tag) appendInitialChild(parent, needsVisibilityToggle.stateNode);\n            else if (!(4 === needsVisibilityToggle.tag || supportsSingletons && 27 === needsVisibilityToggle.tag) && null !== needsVisibilityToggle.child) {\n                needsVisibilityToggle.child.return = needsVisibilityToggle;\n                needsVisibilityToggle = needsVisibilityToggle.child;\n                continue;\n            }\n            if (needsVisibilityToggle === workInProgress) break;\n            for(; null === needsVisibilityToggle.sibling;){\n                if (null === needsVisibilityToggle.return || needsVisibilityToggle.return === workInProgress) return;\n                needsVisibilityToggle = needsVisibilityToggle.return;\n            }\n            needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;\n            needsVisibilityToggle = needsVisibilityToggle.sibling;\n        }\n        else if (supportsPersistence) for(var _node = workInProgress.child; null !== _node;){\n            if (5 === _node.tag) {\n                var instance = _node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, _node.type, _node.memoizedProps));\n                appendInitialChild(parent, instance);\n            } else if (6 === _node.tag) instance = _node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, _node.memoizedProps)), appendInitialChild(parent, instance);\n            else if (4 !== _node.tag) {\n                if (22 === _node.tag && null !== _node.memoizedState) instance = _node.child, null !== instance && (instance.return = _node), appendAllChildren(parent, _node, !0, !0);\n                else if (null !== _node.child) {\n                    _node.child.return = _node;\n                    _node = _node.child;\n                    continue;\n                }\n            }\n            if (_node === workInProgress) break;\n            for(; null === _node.sibling;){\n                if (null === _node.return || _node.return === workInProgress) return;\n                _node = _node.return;\n            }\n            _node.sibling.return = _node.return;\n            _node = _node.sibling;\n        }\n    }\n    function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsPersistence) for(var node = workInProgress.child; null !== node;){\n            if (5 === node.tag) {\n                var instance = node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, node.type, node.memoizedProps));\n                appendChildToContainerChildSet(containerChildSet, instance);\n            } else if (6 === node.tag) instance = node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, node.memoizedProps)), appendChildToContainerChildSet(containerChildSet, instance);\n            else if (4 !== node.tag) {\n                if (22 === node.tag && null !== node.memoizedState) instance = node.child, null !== instance && (instance.return = node), appendAllChildrenToContainer(containerChildSet, node, !(null !== node.memoizedProps && \"manual\" === node.memoizedProps.mode), !0);\n                else if (null !== node.child) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n            }\n            if (node === workInProgress) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === workInProgress) return;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n    }\n    function updateHostContainer(current, workInProgress) {\n        if (supportsPersistence && doesRequireClone(current, workInProgress)) {\n            current = workInProgress.stateNode;\n            var container = current.containerInfo, newChildSet = createContainerChildSet();\n            appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);\n            current.pendingChildren = newChildSet;\n            markUpdate(workInProgress);\n            finalizeContainerChildren(container, newChildSet);\n        }\n    }\n    function updateHostComponent(current, workInProgress, type, newProps) {\n        if (supportsMutation) current.memoizedProps !== newProps && markUpdate(workInProgress);\n        else if (supportsPersistence) {\n            var currentInstance = current.stateNode, _oldProps = current.memoizedProps;\n            if ((current = doesRequireClone(current, workInProgress)) || _oldProps !== newProps) {\n                var currentHostContext = getHostContext();\n                _oldProps = cloneInstance(currentInstance, type, _oldProps, newProps, !current, null);\n                _oldProps === currentInstance ? workInProgress.stateNode = currentInstance : (finalizeInitialChildren(_oldProps, type, newProps, currentHostContext) && markUpdate(workInProgress), workInProgress.stateNode = _oldProps, current ? appendAllChildren(_oldProps, workInProgress, !1, !1) : markUpdate(workInProgress));\n            } else workInProgress.stateNode = currentInstance;\n        }\n    }\n    function preloadInstanceAndSuspendIfNeeded(workInProgress, type, props) {\n        if (maySuspendCommit(type, props)) {\n            if (workInProgress.flags |= 16777216, !preloadInstance(type, props)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\n        if (mayResourceSuspendCommit(resource)) {\n            if (workInProgress.flags |= 16777216, !preloadResource(resource)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function scheduleRetryEffect(workInProgress, retryQueue) {\n        null !== retryQueue && (workInProgress.flags |= 4);\n        workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);\n    }\n    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n        if (!isHydrating) switch(renderState.tailMode){\n            case \"hidden\":\n                hasRenderedATailFallback = renderState.tail;\n                for(var lastTailNode = null; null !== hasRenderedATailFallback;)null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;\n                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;\n                break;\n            case \"collapsed\":\n                lastTailNode = renderState.tail;\n                for(var _lastTailNode = null; null !== lastTailNode;)null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;\n                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;\n        }\n    }\n    function bubbleProperties(completedWork) {\n        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;\n        if (didBailout) if ((completedWork.mode & 2) !== NoMode) {\n            for(var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2;)newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 31457280, subtreeFlags |= _child2.flags & 31457280, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;\n            completedWork.treeBaseDuration = _treeBaseDuration;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 31457280, subtreeFlags |= _treeBaseDuration.flags & 31457280, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        else if ((completedWork.mode & 2) !== NoMode) {\n            _treeBaseDuration = completedWork.actualDuration;\n            _child2 = completedWork.selfBaseDuration;\n            for(var child = completedWork.child; null !== child;)newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;\n            completedWork.actualDuration = _treeBaseDuration;\n            completedWork.treeBaseDuration = _child2;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        completedWork.subtreeFlags |= subtreeFlags;\n        completedWork.childLanes = newChildLanes;\n        return didBailout;\n    }\n    function completeWork(current, workInProgress, renderLanes) {\n        var newProps = workInProgress.pendingProps;\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 16:\n            case 15:\n            case 0:\n            case 11:\n            case 7:\n            case 8:\n            case 12:\n            case 9:\n            case 14:\n                return bubbleProperties(workInProgress), null;\n            case 1:\n                return bubbleProperties(workInProgress), null;\n            case 3:\n                renderLanes = workInProgress.stateNode;\n                newProps = null;\n                null !== current && (newProps = current.memoizedState.cache);\n                workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);\n                popProvider(CacheContext, workInProgress);\n                popHostContainer(workInProgress);\n                renderLanes.pendingContext && (renderLanes.context = renderLanes.pendingContext, renderLanes.pendingContext = null);\n                if (null === current || null === current.child) popHydrationState(workInProgress) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress)) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));\n                updateHostContainer(current, workInProgress);\n                bubbleProperties(workInProgress);\n                return null;\n            case 26:\n                if (supportsResources) {\n                    renderLanes = workInProgress.type;\n                    var nextResource = workInProgress.memoizedState;\n                    null === current ? (markUpdate(workInProgress), null !== nextResource ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, renderLanes, newProps))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, renderLanes, newProps), bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, renderLanes, newProps));\n                    return null;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    popHostContext(workInProgress);\n                    renderLanes = requiredContext(rootInstanceStackCursor.current);\n                    nextResource = workInProgress.type;\n                    if (null !== current && null != workInProgress.stateNode) supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, nextResource, newProps);\n                    else {\n                        if (!newProps) {\n                            if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        current = getHostContext();\n                        popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(nextResource, newProps, renderLanes, current, !0), workInProgress.stateNode = current, markUpdate(workInProgress));\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                }\n            case 5:\n                popHostContext(workInProgress);\n                renderLanes = workInProgress.type;\n                if (null !== current && null != workInProgress.stateNode) updateHostComponent(current, workInProgress, renderLanes, newProps);\n                else {\n                    if (!newProps) {\n                        if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                    current = getHostContext();\n                    popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (nextResource = requiredContext(rootInstanceStackCursor.current), nextResource = createInstance(renderLanes, newProps, nextResource, current, workInProgress), appendAllChildren(nextResource, workInProgress, !1, !1), workInProgress.stateNode = nextResource, finalizeInitialChildren(nextResource, renderLanes, newProps, current) && markUpdate(workInProgress));\n                }\n                bubbleProperties(workInProgress);\n                preloadInstanceAndSuspendIfNeeded(workInProgress, workInProgress.type, workInProgress.pendingProps);\n                return null;\n            case 6:\n                if (current && null != workInProgress.stateNode) renderLanes = current.memoizedProps, supportsMutation ? renderLanes !== newProps && markUpdate(workInProgress) : supportsPersistence && (renderLanes !== newProps ? (current = requiredContext(rootInstanceStackCursor.current), renderLanes = getHostContext(), workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress), markUpdate(workInProgress)) : workInProgress.stateNode = current.stateNode);\n                else {\n                    if (\"string\" !== typeof newProps && null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                    current = requiredContext(rootInstanceStackCursor.current);\n                    renderLanes = getHostContext();\n                    if (popHydrationState(workInProgress)) {\n                        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                        current = workInProgress.stateNode;\n                        renderLanes = workInProgress.memoizedProps;\n                        nextResource = !didSuspendOrErrorDEV;\n                        newProps = null;\n                        var returnFiber = hydrationParentFiber;\n                        if (null !== returnFiber) switch(returnFiber.tag){\n                            case 3:\n                                nextResource && (nextResource = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== nextResource && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextResource));\n                                break;\n                            case 27:\n                            case 5:\n                                newProps = returnFiber.memoizedProps, nextResource && (nextResource = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== nextResource && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextResource));\n                        }\n                        hydrateTextInstance(current, renderLanes, workInProgress, newProps) || throwOnHydrationMismatch(workInProgress);\n                    } else workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress);\n                }\n                bubbleProperties(workInProgress);\n                return null;\n            case 13:\n                newProps = workInProgress.memoizedState;\n                if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {\n                    nextResource = popHydrationState(workInProgress);\n                    if (null !== newProps && null !== newProps.dehydrated) {\n                        if (null === current) {\n                            if (!nextResource) throw Error(\"A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.\");\n                            if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                            nextResource = workInProgress.memoizedState;\n                            nextResource = null !== nextResource ? nextResource.dehydrated : null;\n                            if (!nextResource) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n                            hydrateSuspenseInstance(nextResource, workInProgress);\n                            bubbleProperties(workInProgress);\n                            (workInProgress.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress.child, null !== nextResource && (workInProgress.treeBaseDuration -= nextResource.treeBaseDuration));\n                        } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress.child, null !== nextResource && (workInProgress.treeBaseDuration -= nextResource.treeBaseDuration));\n                        nextResource = !1;\n                    } else null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), nextResource = !0;\n                    if (!nextResource) {\n                        if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;\n                        popSuspenseHandler(workInProgress);\n                        return null;\n                    }\n                }\n                popSuspenseHandler(workInProgress);\n                if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress;\n                renderLanes = null !== newProps;\n                current = null !== current && null !== current.memoizedState;\n                renderLanes && (newProps = workInProgress.child, nextResource = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (nextResource = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== nextResource && (newProps.flags |= 2048));\n                renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);\n                scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\n                bubbleProperties(workInProgress);\n                (workInProgress.mode & 2) !== NoMode && renderLanes && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));\n                return null;\n            case 4:\n                return popHostContainer(workInProgress), updateHostContainer(current, workInProgress), null === current && preparePortalMount(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), bubbleProperties(workInProgress), null;\n            case 19:\n                pop(suspenseStackCursor, workInProgress);\n                nextResource = workInProgress.memoizedState;\n                if (null === nextResource) return bubbleProperties(workInProgress), null;\n                newProps = 0 !== (workInProgress.flags & 128);\n                returnFiber = nextResource.rendering;\n                if (null === returnFiber) if (newProps) cutOffTailIfNeeded(nextResource, !1);\n                else {\n                    if (workInProgressRootExitStatus !== RootInProgress || null !== current && 0 !== (current.flags & 128)) for(current = workInProgress.child; null !== current;){\n                        returnFiber = findFirstSuspended(current);\n                        if (null !== returnFiber) {\n                            workInProgress.flags |= 128;\n                            cutOffTailIfNeeded(nextResource, !1);\n                            current = returnFiber.updateQueue;\n                            workInProgress.updateQueue = current;\n                            scheduleRetryEffect(workInProgress, current);\n                            workInProgress.subtreeFlags = 0;\n                            current = renderLanes;\n                            for(renderLanes = workInProgress.child; null !== renderLanes;)resetWorkInProgress(renderLanes, current), renderLanes = renderLanes.sibling;\n                            push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress);\n                            return workInProgress.child;\n                        }\n                        current = current.sibling;\n                    }\n                    null !== nextResource.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress.lanes = 4194304);\n                }\n                else {\n                    if (!newProps) if (current = findFirstSuspended(returnFiber), null !== current) {\n                        if (workInProgress.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(nextResource, !0), null === nextResource.tail && \"hidden\" === nextResource.tailMode && !returnFiber.alternate && !isHydrating) return bubbleProperties(workInProgress), null;\n                    } else 2 * now$1() - nextResource.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress.lanes = 4194304);\n                    nextResource.isBackwards ? (returnFiber.sibling = workInProgress.child, workInProgress.child = returnFiber) : (current = nextResource.last, null !== current ? current.sibling = returnFiber : workInProgress.child = returnFiber, nextResource.last = returnFiber);\n                }\n                if (null !== nextResource.tail) return current = nextResource.tail, nextResource.rendering = current, nextResource.tail = current.sibling, nextResource.renderingStartTime = now$1(), current.sibling = null, renderLanes = suspenseStackCursor.current, renderLanes = newProps ? renderLanes & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes, workInProgress), current;\n                bubbleProperties(workInProgress);\n                return null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes = workInProgress.updateQueue, null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), renderLanes = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache, workInProgress), null;\n            case 24:\n                return renderLanes = null, null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext, workInProgress), bubbleProperties(workInProgress), null;\n            case 25:\n                return null;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function unwindWork(current, workInProgress) {\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 1:\n                return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 3:\n                return popProvider(CacheContext, workInProgress), popHostContainer(workInProgress), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;\n            case 26:\n            case 27:\n            case 5:\n                return popHostContext(workInProgress), null;\n            case 13:\n                popSuspenseHandler(workInProgress);\n                current = workInProgress.memoizedState;\n                if (null !== current && null !== current.dehydrated) {\n                    if (null === workInProgress.alternate) throw Error(\"Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.\");\n                    resetHydrationState();\n                }\n                current = workInProgress.flags;\n                return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 19:\n                return pop(suspenseStackCursor, workInProgress), null;\n            case 4:\n                return popHostContainer(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), null !== current && pop(resumedCache, workInProgress), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 24:\n                return popProvider(CacheContext, workInProgress), null;\n            case 25:\n                return null;\n            default:\n                return null;\n        }\n    }\n    function unwindInterruptedWork(current, interruptedWork) {\n        popTreeContext(interruptedWork);\n        switch(interruptedWork.tag){\n            case 3:\n                popProvider(CacheContext, interruptedWork);\n                popHostContainer(interruptedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                popHostContext(interruptedWork);\n                break;\n            case 4:\n                popHostContainer(interruptedWork);\n                break;\n            case 13:\n                popSuspenseHandler(interruptedWork);\n                break;\n            case 19:\n                pop(suspenseStackCursor, interruptedWork);\n                break;\n            case 10:\n                popProvider(interruptedWork.type, interruptedWork);\n                break;\n            case 22:\n            case 23:\n                popSuspenseHandler(interruptedWork);\n                popHiddenContext(interruptedWork);\n                null !== current && pop(resumedCache, interruptedWork);\n                break;\n            case 24:\n                popProvider(CacheContext, interruptedWork);\n        }\n    }\n    function shouldProfile(current) {\n        return (current.mode & 2) !== NoMode;\n    }\n    function commitHookLayoutEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitHookEffectListMount(flags, finishedWork) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && \"function\" !== typeof lastEffect)) {\n                        var hookName = void 0;\n                        hookName = 0 !== (updateQueue.tag & Layout) ? \"useLayoutEffect\" : 0 !== (updateQueue.tag & Insertion) ? \"useInsertionEffect\" : \"useEffect\";\n                        var addendum = void 0;\n                        addendum = null === lastEffect ? \" You returned null. If your effect does not require clean up, return undefined (or nothing).\" : \"function\" === typeof lastEffect.then ? \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\\n\\n\" + hookName + \"(() => {\\n  async function fetchData() {\\n    // You can await here\\n    const response = await MyAPI.getData(someId);\\n    // ...\\n  }\\n  fetchData();\\n}, [someId]); // Or [] if effect doesn't need props or state\\n\\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching\" : \" You returned: \" + lastEffect;\n                        runWithFiberInDEV(finishedWork, function(n, a) {\n                            console.error(\"%s must not return anything besides a function, which is used for clean-up.%s\", n, a);\n                        }, hookName, addendum);\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags) {\n                        var inst = updateQueue.inst, destroy = inst.destroy;\n                        void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), runWithFiberInDEV(finishedWork, callDestroyInDEV, finishedWork, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookPassiveMountEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitClassCallbacks(finishedWork) {\n        var updateQueue = finishedWork.updateQueue;\n        if (null !== updateQueue) {\n            var instance = finishedWork.stateNode;\n            finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), instance.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n            try {\n                runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }\n    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {\n        return instance.getSnapshotBeforeUpdate(prevProps, prevState);\n    }\n    function commitClassSnapshot(finishedWork, current) {\n        var prevProps = current.memoizedProps, prevState = current.memoizedState;\n        current = finishedWork.stateNode;\n        finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), current.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n        try {\n            var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps, finishedWork.elementType === finishedWork.type);\n            var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current, resolvedPrevProps, prevState);\n            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;\n            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {\n                console.error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n            }));\n            current.__reactInternalSnapshotBeforeUpdate = snapshot;\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n        instance.props = resolveClassComponentProps(current.type, current.memoizedProps);\n        instance.state = current.memoizedState;\n        shouldProfile(current) ? (startEffectTimer(), runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance);\n    }\n    function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n        if (null !== ref) {\n            var instance = finishedWork.stateNode;\n            switch(finishedWork.tag){\n                case 26:\n                case 27:\n                case 5:\n                    instance = getPublicInstance(instance);\n            }\n            if (\"function\" === typeof ref) if (shouldProfile(finishedWork)) try {\n                startEffectTimer(), finishedWork.refCleanup = ref(instance);\n            } finally{\n                recordEffectDuration();\n            }\n            else finishedWork.refCleanup = ref(instance);\n            else \"string\" === typeof ref ? console.error(\"String refs are no longer supported.\") : ref.hasOwnProperty(\"current\") || console.error(\"Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork)), ref.current = instance;\n        }\n    }\n    function safelyAttachRef(current, nearestMountedAncestor) {\n        try {\n            runWithFiberInDEV(current, commitAttachRef, current);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        }\n    }\n    function safelyDetachRef(current, nearestMountedAncestor) {\n        var ref = current.ref, refCleanup = current.refCleanup;\n        if (null !== ref) if (\"function\" === typeof refCleanup) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, refCleanup);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, refCleanup);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        } finally{\n            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);\n        }\n        else if (\"function\" === typeof ref) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, ref, null);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, ref, null);\n        } catch (error$3) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error$3);\n        }\n        else ref.current = null;\n    }\n    function commitProfiler(finishedWork, current, commitStartTime, effectDuration) {\n        var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;\n        _finishedWork$memoize = _finishedWork$memoize.onRender;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize && _finishedWork$memoize(id, current, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime);\n        \"function\" === typeof onCommit && onCommit(finishedWork.memoizedProps.id, current, effectDuration, commitStartTime);\n    }\n    function commitProfilerPostCommitImpl(finishedWork, current, commitStartTime, passiveEffectDuration) {\n        var _finishedWork$memoize2 = finishedWork.memoizedProps;\n        finishedWork = _finishedWork$memoize2.id;\n        _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(finishedWork, current, passiveEffectDuration, commitStartTime);\n    }\n    function commitHostMount(finishedWork) {\n        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;\n        try {\n            runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHostUpdate(finishedWork, newProps, oldProps) {\n        try {\n            runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function isHostParent(fiber) {\n        return 5 === fiber.tag || 3 === fiber.tag || (supportsResources ? 26 === fiber.tag : !1) || (supportsSingletons ? 27 === fiber.tag : !1) || 4 === fiber.tag;\n    }\n    function getHostSibling(fiber) {\n        a: for(;;){\n            for(; null === fiber.sibling;){\n                if (null === fiber.return || isHostParent(fiber.return)) return null;\n                fiber = fiber.return;\n            }\n            fiber.sibling.return = fiber.return;\n            for(fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && (supportsSingletons ? 27 !== fiber.tag : 1) && 18 !== fiber.tag;){\n                if (fiber.flags & 2) continue a;\n                if (null === fiber.child || 4 === fiber.tag) continue a;\n                else fiber.child.return = fiber, fiber = fiber.child;\n            }\n            if (!(fiber.flags & 2)) return fiber.stateNode;\n        }\n    }\n    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertInContainerBefore(parent, node, before) : appendChildToContainer(parent, node);\n        else if (!(4 === tag || supportsSingletons && 27 === tag) && (node = node.child, null !== node)) for(insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;\n    }\n    function insertOrAppendPlacementNode(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertBefore(parent, node, before) : appendChild(parent, node);\n        else if (!(4 === tag || supportsSingletons && 27 === tag) && (node = node.child, null !== node)) for(insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\n    }\n    function commitPlacement(finishedWork) {\n        if (supportsMutation && (!supportsSingletons || 27 !== finishedWork.tag)) {\n            a: {\n                for(var parent = finishedWork.return; null !== parent;){\n                    if (isHostParent(parent)) {\n                        var parentFiber = parent;\n                        break a;\n                    }\n                    parent = parent.return;\n                }\n                throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            switch(parentFiber.tag){\n                case 27:\n                    if (supportsSingletons) {\n                        parent = parentFiber.stateNode;\n                        parentFiber = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNode(finishedWork, parentFiber, parent);\n                        break;\n                    }\n                case 5:\n                    parent = parentFiber.stateNode;\n                    parentFiber.flags & 32 && (resetTextContent(parent), parentFiber.flags &= -33);\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNode(finishedWork, parentFiber, parent);\n                    break;\n                case 3:\n                case 4:\n                    parent = parentFiber.stateNode.containerInfo;\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, parent);\n                    break;\n                default:\n                    throw Error(\"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n    }\n    function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {\n        portal = portal.containerInfo;\n        try {\n            runWithFiberInDEV(finishedWork, replaceContainerChildren, portal, pendingChildren);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitBeforeMutationEffects(root, firstChild) {\n        prepareForCommit(root.containerInfo);\n        for(nextEffect = firstChild; null !== nextEffect;)if (root = nextEffect, firstChild = root.child, 0 !== (root.subtreeFlags & 1028) && null !== firstChild) firstChild.return = root, nextEffect = firstChild;\n        else for(; null !== nextEffect;){\n            firstChild = root = nextEffect;\n            var current = firstChild.alternate, flags = firstChild.flags;\n            switch(firstChild.tag){\n                case 0:\n                    break;\n                case 11:\n                case 15:\n                    break;\n                case 1:\n                    0 !== (flags & 1024) && null !== current && commitClassSnapshot(firstChild, current);\n                    break;\n                case 3:\n                    0 !== (flags & 1024) && supportsMutation && clearContainer(firstChild.stateNode.containerInfo);\n                    break;\n                case 5:\n                case 26:\n                case 27:\n                case 6:\n                case 4:\n                case 17:\n                    break;\n                default:\n                    if (0 !== (flags & 1024)) throw Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            firstChild = root.sibling;\n            if (null !== firstChild) {\n                firstChild.return = root.return;\n                nextEffect = firstChild;\n                break;\n            }\n            nextEffect = root.return;\n        }\n        root = shouldFireAfterActiveInstanceBlur;\n        shouldFireAfterActiveInstanceBlur = !1;\n        return root;\n    }\n    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);\n                break;\n            case 1:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);\n                else {\n                    var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);\n                    current = current.memoizedState;\n                    finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n                    shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);\n                }\n                flags & 64 && commitClassCallbacks(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 3:\n                current = pushNestedEffectDurations();\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {\n                    prevProps = null;\n                    if (null !== finishedWork.child) switch(finishedWork.child.tag){\n                        case 27:\n                        case 5:\n                            prevProps = getPublicInstance(finishedWork.child.stateNode);\n                            break;\n                        case 1:\n                            prevProps = finishedWork.child.stateNode;\n                    }\n                    try {\n                        runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                finishedRoot.effectDuration += popNestedEffectDurations(current);\n                break;\n            case 26:\n                if (supportsResources) {\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                    break;\n                }\n            case 27:\n            case 5:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                null === current && flags & 4 && commitHostMount(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, finishedRoot.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                break;\n            case 13:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\n                if (!prevProps) {\n                    current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;\n                    var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                    offscreenSubtreeIsHidden = prevProps;\n                    (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                    offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                }\n                flags & 512 && (\"manual\" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));\n                break;\n            default:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n        }\n    }\n    function detachFiberAfterEffects(fiber) {\n        var alternate = fiber.alternate;\n        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));\n        fiber.child = null;\n        fiber.deletions = null;\n        fiber.sibling = null;\n        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));\n        fiber.stateNode = null;\n        fiber._debugOwner = null;\n        fiber.return = null;\n        fiber.dependencies = null;\n        fiber.memoizedProps = null;\n        fiber.memoizedState = null;\n        fiber.pendingProps = null;\n        fiber.stateNode = null;\n        fiber.updateQueue = null;\n    }\n    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n        for(parent = parent.child; null !== parent;)commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;\n    }\n    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberUnmount) try {\n            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        switch(deletedFiber.tag){\n            case 26:\n                if (supportsResources) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    deletedFiber.memoizedState ? releaseResource(deletedFiber.memoizedState) : deletedFiber.stateNode && unmountHoistable(deletedFiber.stateNode);\n                    break;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;\n                    hostParent = deletedFiber.stateNode;\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    releaseSingletonInstance(deletedFiber.stateNode);\n                    hostParent = prevHostParent;\n                    hostParentIsContainer = prevHostParentIsContainer;\n                    break;\n                }\n            case 5:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n            case 6:\n                if (supportsMutation) {\n                    if (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, null !== hostParent) if (hostParentIsContainer) try {\n                        runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                    else try {\n                        runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                } else recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 18:\n                supportsMutation && null !== hostParent && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\n                break;\n            case 4:\n                supportsMutation ? (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = !0, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer) : (supportsPersistence && commitHostPortalContainerChildren(deletedFiber.stateNode, deletedFiber, createContainerChildSet()), recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber));\n                break;\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                offscreenSubtreeWasHidden || commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 1:\n                offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, \"function\" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 21:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 22:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                offscreenSubtreeWasHidden = prevHostParent;\n                break;\n            default:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n    }\n    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n        if (supportsHydration && null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {\n            runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function getRetryCache(finishedWork) {\n        switch(finishedWork.tag){\n            case 13:\n            case 19:\n                var retryCache = finishedWork.stateNode;\n                null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\n                return retryCache;\n            case 22:\n                return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;\n            default:\n                throw Error(\"Unexpected Suspense handler tag (\" + finishedWork.tag + \"). This is a bug in React.\");\n        }\n    }\n    function attachSuspenseRetryListeners(finishedWork, wakeables) {\n        var retryCache = getRetryCache(finishedWork);\n        wakeables.forEach(function(wakeable) {\n            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n            if (!retryCache.has(wakeable)) {\n                retryCache.add(wakeable);\n                if (isDevToolsPresent) if (null !== inProgressLanes && null !== inProgressRoot) restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                else throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                wakeable.then(retry, retry);\n            }\n        });\n    }\n    function commitMutationEffects(root, finishedWork, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root;\n        commitMutationEffectsOnFiber(finishedWork, root);\n        inProgressRoot = inProgressLanes = null;\n    }\n    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n            var root = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i];\n            if (supportsMutation) {\n                var parent = returnFiber;\n                a: for(; null !== parent;){\n                    switch(parent.tag){\n                        case 27:\n                        case 5:\n                            hostParent = parent.stateNode;\n                            hostParentIsContainer = !1;\n                            break a;\n                        case 3:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                        case 4:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                    }\n                    parent = parent.return;\n                }\n                if (null === hostParent) throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n                hostParent = null;\n                hostParentIsContainer = !1;\n            } else commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n            root = deletedFiber;\n            returnFiber = root.alternate;\n            null !== returnFiber && (returnFiber.return = null);\n            root.return = null;\n        }\n        if (parentFiber.subtreeFlags & 13878) for(parentFiber = parentFiber.child; null !== parentFiber;)commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;\n    }\n    function commitMutationEffectsOnFiber(finishedWork, root) {\n        var current = finishedWork.alternate, flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));\n                break;\n            case 1:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));\n                break;\n            case 26:\n                if (supportsResources) {\n                    var hoistableRoot = currentHoistableRoot;\n                    recursivelyTraverseMutationEffects(root, finishedWork);\n                    commitReconciliationEffects(finishedWork);\n                    flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                    flags & 4 && (flags = null !== current ? current.memoizedState : null, root = finishedWork.memoizedState, null === current ? null === root ? null === finishedWork.stateNode ? finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork) : mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : finishedWork.stateNode = acquireResource(hoistableRoot, root, finishedWork.memoizedProps) : flags !== root ? (null === flags ? null !== current.stateNode && unmountHoistable(current.stateNode) : releaseResource(flags), null === root ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, root, finishedWork.memoizedProps)) : null === root && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps));\n                    break;\n                }\n            case 27:\n                if (supportsSingletons && flags & 4 && null === finishedWork.alternate) {\n                    hoistableRoot = finishedWork.stateNode;\n                    var props = finishedWork.memoizedProps;\n                    try {\n                        clearSingleton(hoistableRoot), runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, hoistableRoot, finishedWork);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            case 5:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                if (supportsMutation) {\n                    if (finishedWork.flags & 32) {\n                        root = finishedWork.stateNode;\n                        try {\n                            runWithFiberInDEV(finishedWork, resetTextContent, root);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                    flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, null !== current ? current.memoizedProps : root));\n                    flags & 1024 && (needsFormReset = !0, \"form\" !== finishedWork.type && console.error(\"Unexpected host component type. Expected a form. This is a bug in React.\"));\n                }\n                break;\n            case 6:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4 && supportsMutation) {\n                    if (null === finishedWork.stateNode) throw Error(\"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.\");\n                    flags = finishedWork.memoizedProps;\n                    current = null !== current ? current.memoizedProps : flags;\n                    root = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitTextUpdate, root, current, flags);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                break;\n            case 3:\n                hoistableRoot = pushNestedEffectDurations();\n                supportsResources ? (prepareToCommitHoistables(), props = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(root.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), currentHoistableRoot = props) : recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4) {\n                    if (supportsMutation && supportsHydration && null !== current && current.memoizedState.isDehydrated) try {\n                        runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    if (supportsPersistence) {\n                        flags = root.containerInfo;\n                        current = root.pendingChildren;\n                        try {\n                            runWithFiberInDEV(finishedWork, replaceContainerChildren, flags, current);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                }\n                needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));\n                root.effectDuration += popNestedEffectDurations(hoistableRoot);\n                break;\n            case 4:\n                supportsResources ? (current = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), currentHoistableRoot = current) : (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork));\n                flags & 4 && supportsPersistence && commitHostPortalContainerChildren(finishedWork.stateNode, finishedWork, finishedWork.stateNode.pendingChildren);\n                break;\n            case 12:\n                flags = pushNestedEffectDurations();\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);\n                break;\n            case 13:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now$1());\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 22:\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                hoistableRoot = null !== finishedWork.memoizedState;\n                var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                commitReconciliationEffects(finishedWork);\n                root = finishedWork.stateNode;\n                root._current = finishedWork;\n                root._visibility &= -3;\n                root._visibility |= root._pendingVisibility & 2;\n                if (flags & 8192 && (root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1, hoistableRoot && (root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current || wasHidden || root || recursivelyTraverseDisappearLayoutEffects(finishedWork)), supportsMutation && (null === finishedWork.memoizedProps || \"manual\" !== finishedWork.memoizedProps.mode))) {\n                    a: if (current = null, supportsMutation) for(root = finishedWork;;){\n                        if (5 === root.tag || supportsResources && 26 === root.tag || supportsSingletons && 27 === root.tag) {\n                            if (null === current) {\n                                wasHidden = current = root;\n                                try {\n                                    props = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, props) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if (6 === root.tag) {\n                            if (null === current) {\n                                wasHidden = root;\n                                try {\n                                    var instance = wasHidden.stateNode;\n                                    hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, instance) : runWithFiberInDEV(wasHidden, unhideTextInstance, instance, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {\n                            root.child.return = root;\n                            root = root.child;\n                            continue;\n                        }\n                        if (root === finishedWork) break a;\n                        for(; null === root.sibling;){\n                            if (null === root.return || root.return === finishedWork) break a;\n                            current === root && (current = null);\n                            root = root.return;\n                        }\n                        current === root && (current = null);\n                        root.sibling.return = root.return;\n                        root = root.sibling;\n                    }\n                }\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));\n                break;\n            case 19:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 21:\n                break;\n            default:\n                recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);\n        }\n    }\n    function commitReconciliationEffects(finishedWork) {\n        var flags = finishedWork.flags;\n        if (flags & 2) {\n            try {\n                runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n            finishedWork.flags &= -3;\n        }\n        flags & 4096 && (finishedWork.flags &= -4097);\n    }\n    function recursivelyResetForms(parentFiber) {\n        if (parentFiber.subtreeFlags & 1024) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var fiber = parentFiber;\n            recursivelyResetForms(fiber);\n            5 === fiber.tag && fiber.flags & 1024 && resetFormInstance(fiber.stateNode);\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function commitLayoutEffects(finishedWork, root, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root;\n        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);\n        inProgressRoot = inProgressLanes = null;\n    }\n    function recursivelyTraverseLayoutEffects(root, parentFiber) {\n        if (parentFiber.subtreeFlags & 8772) for(parentFiber = parentFiber.child; null !== parentFiber;)commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disappearLayoutEffects(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 1:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                var instance = finishedWork.stateNode;\n                \"function\" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 22:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        }\n    }\n    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function reappearLayoutEffects(finishedRoot, current, finishedWork, includeWorkInProgressEffects) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                commitHookLayoutEffects(finishedWork, Layout);\n                break;\n            case 1:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                current = finishedWork.stateNode;\n                \"function\" === typeof current.componentDidMount && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current);\n                current = finishedWork.updateQueue;\n                if (null !== current) {\n                    finishedRoot = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current, finishedRoot);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (includeWorkInProgressEffects && flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                    includeWorkInProgressEffects = finishedWork.stateNode;\n                    includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, includeWorkInProgressEffects.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                break;\n            case 13:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            default:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n        }\n    }\n    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function commitOffscreenPassiveMountEffects(current, finishedWork) {\n        var previousCache = null;\n        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);\n        current = null;\n        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);\n        current !== previousCache && (null != current && retainCache(current), null != previousCache && releaseCache(previousCache));\n    }\n    function commitCachePassiveMountEffect(current, finishedWork) {\n        current = null;\n        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);\n        finishedWork = finishedWork.memoizedState.cache;\n        finishedWork !== current && (retainCache(finishedWork), null != current && releaseCache(current));\n    }\n    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);\n                break;\n            case 3:\n                var prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));\n                finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);\n                break;\n            case 12:\n                if (flags & 2048) {\n                    prevEffectDuration = pushNestedEffectDurations();\n                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                break;\n            case 23:\n                break;\n            case 22:\n                prevEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? prevEffectDuration._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : prevEffectDuration._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (prevEffectDuration._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));\n                flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n        }\n    }\n    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                commitHookPassiveMountEffects(finishedWork, Passive);\n                break;\n            case 23:\n                break;\n            case 22:\n                var _instance2 = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? _instance2._visibility & 4 ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (_instance2._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));\n                includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n        }\n    }\n    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case 22:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                    break;\n                case 24:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                    break;\n                default:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n            }\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function recursivelyAccumulateSuspenseyCommit(parentFiber) {\n        if (parentFiber.subtreeFlags & suspenseyCommitFlag) for(parentFiber = parentFiber.child; null !== parentFiber;)accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function accumulateSuspenseyCommitOnFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && (null !== fiber.memoizedState ? suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps) : suspendInstance(fiber.type, fiber.memoizedProps));\n                break;\n            case 5:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && suspendInstance(fiber.type, fiber.memoizedProps);\n                break;\n            case 3:\n            case 4:\n                if (supportsResources) {\n                    var previousHoistableRoot = currentHoistableRoot;\n                    currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);\n                    recursivelyAccumulateSuspenseyCommit(fiber);\n                    currentHoistableRoot = previousHoistableRoot;\n                } else recursivelyAccumulateSuspenseyCommit(fiber);\n                break;\n            case 22:\n                null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));\n                break;\n            default:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n        }\n    }\n    function detachAlternateSiblings(parentFiber) {\n        var previousFiber = parentFiber.alternate;\n        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {\n            previousFiber.child = null;\n            do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;\n            while (null !== parentFiber);\n        }\n    }\n    function recursivelyTraversePassiveUnmountEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i];\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveUnmountOnFiber(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);\n                break;\n            case 3:\n                var prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);\n                break;\n            case 12:\n                prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);\n                break;\n            case 22:\n                prevEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState && prevEffectDuration._visibility & 4 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n        }\n    }\n    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i];\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disconnectPassiveEffect(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                break;\n            case 22:\n                var instance = finishedWork.stateNode;\n                instance._visibility & 4 && (instance._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork));\n                break;\n            default:\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n        }\n    }\n    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n        for(; null !== nextEffect;){\n            var fiber = nextEffect, current = fiber;\n            switch(current.tag){\n                case 0:\n                case 11:\n                case 15:\n                    commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);\n                    break;\n                case 23:\n                case 22:\n                    null !== current.memoizedState && null !== current.memoizedState.cachePool && (current = current.memoizedState.cachePool.pool, null != current && retainCache(current));\n                    break;\n                case 24:\n                    releaseCache(current.memoizedState.cache);\n            }\n            current = fiber.child;\n            if (null !== current) current.return = fiber, nextEffect = current;\n            else a: for(fiber = deletedSubtreeRoot; null !== nextEffect;){\n                current = nextEffect;\n                var sibling = current.sibling, returnFiber = current.return;\n                detachFiberAfterEffects(current);\n                if (current === fiber) {\n                    nextEffect = null;\n                    break a;\n                }\n                if (null !== sibling) {\n                    sibling.return = returnFiber;\n                    nextEffect = sibling;\n                    break a;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n    }\n    function findFiberRootForHostRoot(hostRoot) {\n        var maybeFiber = getInstanceFromNode(hostRoot);\n        if (null != maybeFiber) {\n            if (\"string\" !== typeof maybeFiber.memoizedProps[\"data-testname\"]) throw Error(\"Invalid host root specified. Should be either a React container or a node with a testname attribute.\");\n            return maybeFiber;\n        }\n        hostRoot = findFiberRoot(hostRoot);\n        if (null === hostRoot) throw Error(\"Could not find React container within specified host subtree.\");\n        return hostRoot.stateNode.current;\n    }\n    function matchSelector(fiber$jscomp$0, selector) {\n        var tag = fiber$jscomp$0.tag;\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                if (fiber$jscomp$0.type === selector.value) return !0;\n                break;\n            case HAS_PSEUDO_CLASS_TYPE:\n                a: {\n                    selector = selector.value;\n                    fiber$jscomp$0 = [\n                        fiber$jscomp$0,\n                        0\n                    ];\n                    for(tag = 0; tag < fiber$jscomp$0.length;){\n                        var fiber = fiber$jscomp$0[tag++], tag$jscomp$0 = fiber.tag, selectorIndex = fiber$jscomp$0[tag++], selector$jscomp$0 = selector[selectorIndex];\n                        if (5 !== tag$jscomp$0 && 26 !== tag$jscomp$0 && 27 !== tag$jscomp$0 || !isHiddenSubtree(fiber)) {\n                            for(; null != selector$jscomp$0 && matchSelector(fiber, selector$jscomp$0);)selectorIndex++, selector$jscomp$0 = selector[selectorIndex];\n                            if (selectorIndex === selector.length) {\n                                selector = !0;\n                                break a;\n                            } else for(fiber = fiber.child; null !== fiber;)fiber$jscomp$0.push(fiber, selectorIndex), fiber = fiber.sibling;\n                        }\n                    }\n                    selector = !1;\n                }\n                return selector;\n            case ROLE_TYPE:\n                if ((5 === tag || 26 === tag || 27 === tag) && matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value)) return !0;\n                break;\n            case TEXT_TYPE:\n                if (5 === tag || 6 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = getTextContent(fiber$jscomp$0), null !== fiber$jscomp$0 && 0 <= fiber$jscomp$0.indexOf(selector.value)) return !0;\n                }\n                break;\n            case TEST_NAME_TYPE:\n                if (5 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = fiber$jscomp$0.memoizedProps[\"data-testname\"], \"string\" === typeof fiber$jscomp$0 && fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase()) return !0;\n                }\n                break;\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n        return !1;\n    }\n    function selectorToString(selector) {\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                return \"<\" + (getComponentNameFromType(selector.value) || \"Unknown\") + \">\";\n            case HAS_PSEUDO_CLASS_TYPE:\n                return \":has(\" + (selectorToString(selector) || \"\") + \")\";\n            case ROLE_TYPE:\n                return '[role=\"' + selector.value + '\"]';\n            case TEXT_TYPE:\n                return '\"' + selector.value + '\"';\n            case TEST_NAME_TYPE:\n                return '[data-testname=\"' + selector.value + '\"]';\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n    }\n    function findPaths(root, selectors) {\n        var matchingFibers = [];\n        root = [\n            root,\n            0\n        ];\n        for(var index = 0; index < root.length;){\n            var fiber = root[index++], tag = fiber.tag, selectorIndex = root[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                for(; null != selector && matchSelector(fiber, selector);)selectorIndex++, selector = selectors[selectorIndex];\n                if (selectorIndex === selectors.length) matchingFibers.push(fiber);\n                else for(fiber = fiber.child; null !== fiber;)root.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        return matchingFibers;\n    }\n    function findAllNodes(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        hostRoot = findPaths(hostRoot, selectors);\n        selectors = [];\n        hostRoot = Array.from(hostRoot);\n        for(var index = 0; index < hostRoot.length;){\n            var node = hostRoot[index++], tag = node.tag;\n            if (5 === tag || 26 === tag || 27 === tag) isHiddenSubtree(node) || selectors.push(node.stateNode);\n            else for(node = node.child; null !== node;)hostRoot.push(node), node = node.sibling;\n        }\n        return selectors;\n    }\n    function onCommitRoot() {\n        supportsTestSelectors && commitHooks.forEach(function(commitHook) {\n            return commitHook();\n        });\n    }\n    function isConcurrentActEnvironment() {\n        var isReactActEnvironmentGlobal = \"undefined\" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;\n        isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(\"The current testing environment is not configured to support act(...)\");\n        return isReactActEnvironmentGlobal;\n    }\n    function requestUpdateLane(fiber) {\n        if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;\n        var transition = ReactSharedInternals.T;\n        return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();\n    }\n    function requestDeferredLane() {\n        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);\n        var suspenseHandler = suspenseHandlerStackCursor.current;\n        null !== suspenseHandler && (suspenseHandler.flags |= 32);\n        return workInProgressDeferredLane;\n    }\n    function scheduleUpdateOnFiber(root, fiber, lane) {\n        isRunningInsertionEffect && console.error(\"useInsertionEffect must not schedule updates.\");\n        isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);\n        if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n        markRootUpdated$1(root, lane);\n        if (0 !== (executionContext & RenderContext) && root === workInProgressRoot) {\n            if (isRendering) switch(fiber.tag){\n                case 0:\n                case 11:\n                case 15:\n                    root = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                    didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || \"Unknown\", console.error(\"Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render\", fiber, root, root));\n                    break;\n                case 1:\n                    didWarnAboutUpdateInRender || (console.error(\"Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.\"), didWarnAboutUpdateInRender = !0);\n            }\n        } else isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);\n    }\n    function performWorkOnRoot(root, lanes, forceSync) {\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, !0), renderWasConcurrent = shouldTimeSlice;\n        do {\n            if (exitStatus === RootInProgress) {\n                workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root, lanes, 0, !1);\n                break;\n            } else if (exitStatus === RootDidNotComplete) markRootSuspended(root, lanes, 0, !workInProgressRootDidSkipSuspendedSiblings);\n            else {\n                forceSync = root.current.alternate;\n                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {\n                    exitStatus = renderRootSync(root, lanes, !1);\n                    renderWasConcurrent = !1;\n                    continue;\n                }\n                if (exitStatus === RootErrored) {\n                    renderWasConcurrent = lanes;\n                    if (root.errorRecoveryDisabledLanes & renderWasConcurrent) var errorRetryLanes = 0;\n                    else errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;\n                    if (0 !== errorRetryLanes) {\n                        lanes = errorRetryLanes;\n                        a: {\n                            exitStatus = root;\n                            var errorRetryLanes$jscomp$0 = errorRetryLanes;\n                            errorRetryLanes = workInProgressRootConcurrentErrors;\n                            var wasRootDehydrated = supportsHydration && exitStatus.current.memoizedState.isDehydrated;\n                            wasRootDehydrated && (prepareFreshStack(exitStatus, errorRetryLanes$jscomp$0).flags |= 256);\n                            errorRetryLanes$jscomp$0 = renderRootSync(exitStatus, errorRetryLanes$jscomp$0, !1);\n                            if (errorRetryLanes$jscomp$0 !== RootErrored) {\n                                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n                                    exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;\n                                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;\n                                    exitStatus = RootSuspendedWithDelay;\n                                    break a;\n                                }\n                                exitStatus = workInProgressRootRecoverableErrors;\n                                workInProgressRootRecoverableErrors = errorRetryLanes;\n                                null !== exitStatus && queueRecoverableErrors(exitStatus);\n                            }\n                            exitStatus = errorRetryLanes$jscomp$0;\n                        }\n                        renderWasConcurrent = !1;\n                        if (exitStatus !== RootErrored) continue;\n                    }\n                }\n                if (exitStatus === RootFatalErrored) {\n                    prepareFreshStack(root, 0);\n                    markRootSuspended(root, lanes, 0, !0);\n                    break;\n                }\n                a: {\n                    shouldTimeSlice = root;\n                    switch(exitStatus){\n                        case RootInProgress:\n                        case RootFatalErrored:\n                            throw Error(\"Root did not complete. This is a bug in React.\");\n                        case RootSuspendedWithDelay:\n                            if ((lanes & 4194176) === lanes) {\n                                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                                break a;\n                            }\n                            break;\n                        case RootErrored:\n                            workInProgressRootRecoverableErrors = null;\n                            break;\n                        case RootSuspended:\n                        case RootCompleted:\n                            break;\n                        default:\n                            throw Error(\"Unknown root exit status.\");\n                    }\n                    shouldTimeSlice.finishedWork = forceSync;\n                    shouldTimeSlice.finishedLanes = lanes;\n                    if (null !== ReactSharedInternals.actQueue) commitRoot(shouldTimeSlice, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, IMMEDIATE_COMMIT, -0, 0);\n                    else {\n                        if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < exitStatus)) {\n                            markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                            if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;\n                            shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, THROTTLED_COMMIT, -0, 0), exitStatus);\n                            break a;\n                        }\n                        commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, IMMEDIATE_COMMIT, -0, 0);\n                    }\n                }\n            }\n            break;\n        }while (1);\n        ensureRootIsScheduled(root);\n    }\n    function queueRecoverableErrors(errors) {\n        null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n    }\n    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        var subtreeFlags = finishedWork.subtreeFlags;\n        if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {\n            if (startSuspendingCommit(), accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {\n                root.cancelPendingCommit = finishedWork(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, SUSPENDED_COMMIT, completedRenderStartTime, completedRenderEndTime));\n                markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);\n                return;\n            }\n        }\n        commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n    }\n    function isRenderConsistentWithExternalStores(finishedWork) {\n        for(var node = finishedWork;;){\n            var tag = node.tag;\n            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for(var i = 0; i < tag.length; i++){\n                var check = tag[i], getSnapshot = check.getSnapshot;\n                check = check.value;\n                try {\n                    if (!objectIs(getSnapshot(), check)) return !1;\n                } catch (error) {\n                    return !1;\n                }\n            }\n            tag = node.child;\n            if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;\n            else {\n                if (node === finishedWork) break;\n                for(; null === node.sibling;){\n                    if (null === node.return || node.return === finishedWork) return !0;\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        return !0;\n    }\n    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {\n        suspendedLanes &= ~workInProgressRootPingedLanes;\n        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;\n        root.suspendedLanes |= suspendedLanes;\n        root.pingedLanes &= ~suspendedLanes;\n        didAttemptEntireTree && (root.warmLanes |= suspendedLanes);\n        didAttemptEntireTree = root.expirationTimes;\n        for(var lanes = suspendedLanes; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            didAttemptEntireTree[index] = -1;\n            lanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n    }\n    function flushSyncWork() {\n        return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;\n    }\n    function resetWorkInProgressStack() {\n        if (null !== workInProgress) {\n            if (workInProgressSuspendedReason === NotSuspended) var interruptedWork = workInProgress.return;\n            else interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;\n            for(; null !== interruptedWork;)unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;\n            workInProgress = null;\n        }\n    }\n    function prepareFreshStack(root, lanes) {\n        root.finishedWork = null;\n        root.finishedLanes = 0;\n        var timeoutHandle = root.timeoutHandle;\n        timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));\n        timeoutHandle = root.cancelPendingCommit;\n        null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());\n        resetWorkInProgressStack();\n        workInProgressRoot = root;\n        workInProgress = timeoutHandle = createWorkInProgress(root.current, null);\n        workInProgressRootRenderLanes = lanes;\n        workInProgressSuspendedReason = NotSuspended;\n        workInProgressThrownValue = null;\n        workInProgressRootDidSkipSuspendedSiblings = !1;\n        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        workInProgressRootDidAttachPingListener = !1;\n        workInProgressRootExitStatus = RootInProgress;\n        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;\n        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;\n        workInProgressRootDidIncludeRecursiveRenderUpdate = !1;\n        0 !== (lanes & 8) && (lanes |= lanes & 32);\n        var allEntangledLanes = root.entangledLanes;\n        if (0 !== allEntangledLanes) for(root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;){\n            var index = 31 - clz32(allEntangledLanes), lane = 1 << index;\n            lanes |= root[index];\n            allEntangledLanes &= ~lane;\n        }\n        entangledRenderLanes = lanes;\n        finishQueueingConcurrentUpdates();\n        ReactStrictModeWarnings.discardPendingWarnings();\n        return timeoutHandle;\n    }\n    function handleThrow(root, thrownValue) {\n        currentlyRenderingFiber$1 = null;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        ReactSharedInternals.getCurrentStack = null;\n        isRendering = !1;\n        current = null;\n        thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && \"object\" === typeof thrownValue && \"function\" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;\n        workInProgressThrownValue = thrownValue;\n        var erroredWork = workInProgress;\n        if (null === erroredWork) workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n        else switch(erroredWork.mode & 2 && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason){\n            case SuspendedOnError:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                break;\n            case SuspendedOnData:\n            case SuspendedOnImmediate:\n            case SuspendedOnDeprecatedThrowPromise:\n            case SuspendedAndReadyToContinue:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(erroredWork, thrownValue, workInProgressRootRenderLanes);\n        }\n    }\n    function shouldRemainOnPreviousScreen() {\n        var handler = suspenseHandlerStackCursor.current;\n        return null === handler ? !0 : (workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null === shellBoundary ? !0 : !1 : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : !1;\n    }\n    function pushDispatcher() {\n        var prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;\n    }\n    function pushAsyncDispatcher() {\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        return prevAsyncDispatcher;\n    }\n    function renderDidSuspendDelayIfPossible() {\n        workInProgressRootExitStatus = RootSuspendedWithDelay;\n        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);\n        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n    }\n    function renderRootSync(root, lanes, shouldYieldForPrerendering) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            prepareFreshStack(root, lanes);\n        }\n        markRenderStarted(lanes);\n        lanes = !1;\n        memoizedUpdaters = workInProgressRootExitStatus;\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {\n                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;\n                switch(workInProgressSuspendedReason){\n                    case SuspendedOnHydration:\n                        resetWorkInProgressStack();\n                        memoizedUpdaters = RootDidNotComplete;\n                        break a;\n                    case SuspendedOnImmediate:\n                    case SuspendedOnData:\n                    case SuspendedOnDeprecatedThrowPromise:\n                        null === suspenseHandlerStackCursor.current && (lanes = !0);\n                        var reason = workInProgressSuspendedReason;\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                        if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {\n                            memoizedUpdaters = RootInProgress;\n                            break a;\n                        }\n                        break;\n                    default:\n                        reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                }\n            }\n            workLoopSync();\n            memoizedUpdaters = workInProgressRootExitStatus;\n            break;\n        } catch (thrownValue$4) {\n            handleThrow(root, thrownValue$4);\n        }\n        while (1);\n        lanes && root.shellSuspendCounter++;\n        resetContextDependencies();\n        executionContext = prevExecutionContext;\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        markRenderStopped();\n        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());\n        return memoizedUpdaters;\n    }\n    function workLoopSync() {\n        for(; null !== workInProgress;)performUnitOfWork(workInProgress);\n    }\n    function renderRootConcurrent(root, lanes) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n            prepareFreshStack(root, lanes);\n        } else workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        markRenderStarted(lanes);\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) b: switch(lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason){\n                case SuspendedOnError:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);\n                    break;\n                case SuspendedOnData:\n                    if (isThenableResolved(memoizedUpdaters)) {\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        replaySuspendedUnitOfWork(lanes);\n                        break;\n                    }\n                    lanes = function() {\n                        workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root && (workInProgressSuspendedReason = SuspendedAndReadyToContinue);\n                        ensureRootIsScheduled(root);\n                    };\n                    memoizedUpdaters.then(lanes, lanes);\n                    break a;\n                case SuspendedOnImmediate:\n                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                    break a;\n                case SuspendedOnInstance:\n                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;\n                    break a;\n                case SuspendedAndReadyToContinue:\n                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));\n                    break;\n                case SuspendedOnInstanceAndReadyToContinue:\n                    var resource = null;\n                    switch(workInProgress.tag){\n                        case 26:\n                            resource = workInProgress.memoizedState;\n                        case 5:\n                        case 27:\n                            var hostFiber = workInProgress, type = hostFiber.type, props = hostFiber.pendingProps;\n                            if (resource ? preloadResource(resource) : preloadInstance(type, props)) {\n                                workInProgressSuspendedReason = NotSuspended;\n                                workInProgressThrownValue = null;\n                                var sibling = hostFiber.sibling;\n                                if (null !== sibling) workInProgress = sibling;\n                                else {\n                                    var returnFiber = hostFiber.return;\n                                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;\n                                }\n                                break b;\n                            }\n                            break;\n                        default:\n                            console.error(\"Unexpected type of fiber triggered a suspensey commit. This is a bug in React.\");\n                    }\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);\n                    break;\n                case SuspendedOnDeprecatedThrowPromise:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);\n                    break;\n                case SuspendedOnHydration:\n                    resetWorkInProgressStack();\n                    workInProgressRootExitStatus = RootDidNotComplete;\n                    break a;\n                default:\n                    throw Error(\"Unexpected SuspendedReason. This is a bug in React.\");\n            }\n            null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrent();\n            break;\n        } catch (thrownValue$5) {\n            handleThrow(root, thrownValue$5);\n        }\n        while (1);\n        resetContextDependencies();\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        executionContext = prevExecutionContext;\n        if (null !== workInProgress) return null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;\n        markRenderStopped();\n        workInProgressRoot = null;\n        workInProgressRootRenderLanes = 0;\n        finishQueueingConcurrentUpdates();\n        return workInProgressRootExitStatus;\n    }\n    function workLoopConcurrent() {\n        for(; null !== workInProgress && !shouldYield();)performUnitOfWork(workInProgress);\n    }\n    function performUnitOfWork(unitOfWork) {\n        var current = unitOfWork.alternate;\n        (unitOfWork.mode & 2) !== NoMode ? (startProfilerTimer(unitOfWork), current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === current ? completeUnitOfWork(unitOfWork) : workInProgress = current;\n    }\n    function replaySuspendedUnitOfWork(unitOfWork) {\n        var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;\n    }\n    function replayBeginWork(unitOfWork) {\n        var current = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & 2) !== NoMode;\n        isProfilingMode && startProfilerTimer(unitOfWork);\n        switch(unitOfWork.tag){\n            case 15:\n            case 0:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, void 0, workInProgressRootRenderLanes);\n                break;\n            case 11:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);\n                break;\n            case 5:\n                resetHooksOnUnwind(unitOfWork);\n            default:\n                unwindInterruptedWork(current, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current = beginWork(current, unitOfWork, entangledRenderLanes);\n        }\n        isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);\n        return current;\n    }\n    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {\n        resetContextDependencies();\n        resetHooksOnUnwind(unitOfWork);\n        thenableState$1 = null;\n        thenableIndexCounter$1 = 0;\n        var returnFiber = unitOfWork.return;\n        try {\n            if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {\n                workInProgressRootExitStatus = RootFatalErrored;\n                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n                workInProgress = null;\n                return;\n            }\n        } catch (error) {\n            if (null !== returnFiber) throw workInProgress = returnFiber, error;\n            workInProgressRootExitStatus = RootFatalErrored;\n            logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n            workInProgress = null;\n            return;\n        }\n        if (unitOfWork.flags & 32768) {\n            if (isHydrating || suspendedReason === SuspendedOnError) root = !0;\n            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;\n            else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);\n            unwindUnitOfWork(unitOfWork, root);\n        } else completeUnitOfWork(unitOfWork);\n    }\n    function completeUnitOfWork(unitOfWork) {\n        var completedWork = unitOfWork;\n        do {\n            if (0 !== (completedWork.flags & 32768)) {\n                unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);\n                return;\n            }\n            var current = completedWork.alternate;\n            unitOfWork = completedWork.return;\n            startProfilerTimer(completedWork);\n            current = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);\n            (completedWork.mode & 2) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);\n            if (null !== current) {\n                workInProgress = current;\n                return;\n            }\n            completedWork = completedWork.sibling;\n            if (null !== completedWork) {\n                workInProgress = completedWork;\n                return;\n            }\n            workInProgress = completedWork = unitOfWork;\n        }while (null !== completedWork);\n        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);\n    }\n    function unwindUnitOfWork(unitOfWork, skipSiblings) {\n        do {\n            var next = unwindWork(unitOfWork.alternate, unitOfWork);\n            if (null !== next) {\n                next.flags &= 32767;\n                workInProgress = next;\n                return;\n            }\n            if ((unitOfWork.mode & 2) !== NoMode) {\n                stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);\n                next = unitOfWork.actualDuration;\n                for(var child = unitOfWork.child; null !== child;)next += child.actualDuration, child = child.sibling;\n                unitOfWork.actualDuration = next;\n            }\n            next = unitOfWork.return;\n            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);\n            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {\n                workInProgress = unitOfWork;\n                return;\n            }\n            workInProgress = unitOfWork = next;\n        }while (null !== unitOfWork);\n        workInProgressRootExitStatus = RootDidNotComplete;\n        workInProgress = null;\n    }\n    function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        var prevTransition = ReactSharedInternals.T, previousUpdateLanePriority = getCurrentUpdatePriority();\n        try {\n            setCurrentUpdatePriority(2), ReactSharedInternals.T = null, commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n        } finally{\n            ReactSharedInternals.T = prevTransition, setCurrentUpdatePriority(previousUpdateLanePriority);\n        }\n    }\n    function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        do flushPassiveEffects();\n        while (null !== rootWithPendingPassiveEffects);\n        ReactStrictModeWarnings.flushLegacyContextWarning();\n        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var finishedWork = root.finishedWork;\n        didIncludeRenderPhaseUpdate = root.finishedLanes;\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(didIncludeRenderPhaseUpdate);\n        if (null === finishedWork) return markCommitStopped(), null;\n        0 === didIncludeRenderPhaseUpdate && console.error(\"root.finishedLanes should not be empty during a commit. This is a bug in React.\");\n        root.finishedWork = null;\n        root.finishedLanes = 0;\n        if (finishedWork === root.current) throw Error(\"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.\");\n        root.callbackNode = null;\n        root.callbackPriority = 0;\n        root.cancelPendingCommit = null;\n        var remainingLanes = finishedWork.lanes | finishedWork.childLanes;\n        remainingLanes |= concurrentlyUpdatedLanes;\n        markRootFinished(root, didIncludeRenderPhaseUpdate, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes);\n        root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);\n        0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback(NormalPriority$1, function() {\n            flushPassiveEffects(!0);\n            return null;\n        }));\n        commitStartTime = now();\n        transitions = 0 !== (finishedWork.flags & 15990);\n        0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = getCurrentUpdatePriority(), setCurrentUpdatePriority(2), updatedLanes = executionContext, executionContext |= CommitContext, commitBeforeMutationEffects(root, finishedWork), commitMutationEffects(root, finishedWork, didIncludeRenderPhaseUpdate), resetAfterCommit(root.containerInfo), root.current = finishedWork, null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(didIncludeRenderPhaseUpdate), commitLayoutEffects(finishedWork, root, didIncludeRenderPhaseUpdate), null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped(), requestPaint(), executionContext = updatedLanes, setCurrentUpdatePriority(spawnedLane), ReactSharedInternals.T = transitions) : root.current = finishedWork;\n        (transitions = rootDoesHavePassiveEffects) ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : (releaseRootPooledCache(root, remainingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);\n        remainingLanes = root.pendingLanes;\n        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);\n        transitions || commitDoubleInvokeEffectsInDEV(root);\n        onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);\n        isDevToolsPresent && root.memoizedUpdaters.clear();\n        onCommitRoot();\n        ensureRootIsScheduled(root);\n        if (null !== recoverableErrors) for(renderPriorityLevel = root.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++)remainingLanes = recoverableErrors[finishedWork], transitions = makeErrorInfo(remainingLanes.stack), runWithFiberInDEV(remainingLanes.source, renderPriorityLevel, remainingLanes.value, transitions);\n        0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();\n        remainingLanes = root.pendingLanes;\n        0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = !0, root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0;\n        flushSyncWorkAcrossRoots_impl(0, !1);\n        markCommitStopped();\n        return null;\n    }\n    function makeErrorInfo(componentStack) {\n        componentStack = {\n            componentStack: componentStack\n        };\n        Object.defineProperty(componentStack, \"digest\", {\n            get: function() {\n                console.error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');\n            }\n        });\n        return componentStack;\n    }\n    function releaseRootPooledCache(root, remainingLanes) {\n        0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));\n    }\n    function flushPassiveEffects() {\n        if (null !== rootWithPendingPassiveEffects) {\n            var root = rootWithPendingPassiveEffects, remainingLanes = pendingPassiveEffectsRemainingLanes;\n            pendingPassiveEffectsRemainingLanes = 0;\n            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes), priority = 32 > renderPriority ? 32 : renderPriority;\n            renderPriority = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(priority);\n                ReactSharedInternals.T = null;\n                if (null === rootWithPendingPassiveEffects) var JSCompiler_inline_result = !1;\n                else {\n                    priority = pendingPassiveTransitions;\n                    pendingPassiveTransitions = null;\n                    var root$jscomp$0 = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;\n                    rootWithPendingPassiveEffects = null;\n                    pendingPassiveEffectsLanes = 0;\n                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Cannot flush passive effects while already rendering.\");\n                    isFlushingPassiveEffects = !0;\n                    didScheduleUpdateDuringPassiveEffects = !1;\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                    var prevExecutionContext = executionContext;\n                    executionContext |= CommitContext;\n                    commitPassiveUnmountOnFiber(root$jscomp$0.current);\n                    commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, priority);\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();\n                    commitDoubleInvokeEffectsInDEV(root$jscomp$0);\n                    executionContext = prevExecutionContext;\n                    flushSyncWorkAcrossRoots_impl(0, !1);\n                    didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;\n                    didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;\n                    if (injectedHook && \"function\" === typeof injectedHook.onPostCommitFiberRoot) try {\n                        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);\n                    } catch (err) {\n                        hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n                    }\n                    var stateNode = root$jscomp$0.current.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                    JSCompiler_inline_result = !0;\n                }\n                return JSCompiler_inline_result;\n            } finally{\n                setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);\n            }\n        }\n        return !1;\n    }\n    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);\n        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);\n        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));\n    }\n    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n        isRunningInsertionEffect = !1;\n        if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n        else {\n            for(; null !== nearestMountedAncestor;){\n                if (3 === nearestMountedAncestor.tag) {\n                    captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);\n                    return;\n                }\n                if (1 === nearestMountedAncestor.tag) {\n                    var instance = nearestMountedAncestor.stateNode;\n                    if (\"function\" === typeof nearestMountedAncestor.type.getDerivedStateFromError || \"function\" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {\n                        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n                        error = createClassErrorUpdate(2);\n                        instance = enqueueUpdate(nearestMountedAncestor, error, 2);\n                        null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));\n                        return;\n                    }\n                }\n                nearestMountedAncestor = nearestMountedAncestor.return;\n            }\n            console.error(\"Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\\n\\nError message:\\n\\n%s\", error);\n        }\n    }\n    function attachPingListener(root, wakeable, lanes) {\n        var pingCache = root.pingCache;\n        if (null === pingCache) {\n            pingCache = root.pingCache = new PossiblyWeakMap();\n            var threadIDs = new Set();\n            pingCache.set(wakeable, threadIDs);\n        } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));\n        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));\n    }\n    function pingSuspendedRoot(root, wakeable, pingedLanes) {\n        var pingCache = root.pingCache;\n        null !== pingCache && pingCache.delete(wakeable);\n        root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        root.warmLanes &= ~pingedLanes;\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(\"A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\\n\\nWhen testing, code that resolves suspended data should be wrapped into act(...):\\n\\nact(() => {\\n  /* finish loading suspended data */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\");\n        workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));\n        ensureRootIsScheduled(root);\n    }\n    function retryTimedOutBoundary(boundaryFiber, retryLane) {\n        0 === retryLane && (retryLane = claimNextRetryLane());\n        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));\n    }\n    function retryDehydratedSuspenseBoundary(boundaryFiber) {\n        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;\n        null !== suspenseState && (retryLane = suspenseState.retryLane);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function resolveRetryWakeable(boundaryFiber, wakeable) {\n        var retryLane = 0;\n        switch(boundaryFiber.tag){\n            case 13:\n                var retryCache = boundaryFiber.stateNode;\n                var suspenseState = boundaryFiber.memoizedState;\n                null !== suspenseState && (retryLane = suspenseState.retryLane);\n                break;\n            case 19:\n                retryCache = boundaryFiber.stateNode;\n                break;\n            case 22:\n                retryCache = boundaryFiber.stateNode._retryCache;\n                break;\n            default:\n                throw Error(\"Pinged unknown suspense boundary type. This is probably a bug in React.\");\n        }\n        null !== retryCache && retryCache.delete(wakeable);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {\n        if (0 !== (parentFiber.subtreeFlags & 33562624)) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var root = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n            isStrictModeFiber = isInStrictMode || isStrictModeFiber;\n            22 !== fiber.tag ? fiber.flags & 33554432 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber, (fiber.mode & 64) === NoMode) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 33554432 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function doubleInvokeEffectsOnFiber(root, fiber) {\n        var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;\n        setIsStrictModeForDevtools(!0);\n        try {\n            disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, !1), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root, fiber, 0, null, !1);\n        } finally{\n            setIsStrictModeForDevtools(!1);\n        }\n    }\n    function commitDoubleInvokeEffectsInDEV(root) {\n        var doubleInvokeEffects = !0;\n        root.current.mode & 24 || (doubleInvokeEffects = !1);\n        recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n    }\n    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n        if ((executionContext & RenderContext) === NoContext) {\n            var tag = fiber.tag;\n            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {\n                tag = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n                if (null !== didWarnStateUpdateForNotYetMountedComponent) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;\n                    didWarnStateUpdateForNotYetMountedComponent.add(tag);\n                } else didWarnStateUpdateForNotYetMountedComponent = new Set([\n                    tag\n                ]);\n                runWithFiberInDEV(fiber, function() {\n                    console.error(\"Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.\");\n                });\n            }\n        }\n    }\n    function restorePendingUpdaters(root, lanes) {\n        isDevToolsPresent && root.memoizedUpdaters.forEach(function(schedulingFiber) {\n            addFiberToLanesMap(root, schedulingFiber, lanes);\n        });\n    }\n    function scheduleCallback(priorityLevel, callback) {\n        var actQueue = ReactSharedInternals.actQueue;\n        return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode) : scheduleCallback$3(priorityLevel, callback);\n    }\n    function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {\n            console.error(\"An update to %s inside a test was not wrapped in act(...).\\n\\nWhen testing, code that causes React state updates should be wrapped into act(...):\\n\\nact(() => {\\n  /* fire events that update state */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n        });\n    }\n    function resolveFunctionForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? type : family.current;\n    }\n    function resolveForwardRefForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? null !== type && void 0 !== type && \"function\" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: family\n        }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;\n    }\n    function isCompatibleFamilyForHotReloading(fiber, element) {\n        if (null === resolveFamily) return !1;\n        var prevType = fiber.elementType;\n        element = element.type;\n        var needsCompareFamilies = !1, $$typeofNextType = \"object\" === typeof element && null !== element ? element.$$typeof : null;\n        switch(fiber.tag){\n            case 1:\n                \"function\" === typeof element && (needsCompareFamilies = !0);\n                break;\n            case 0:\n                \"function\" === typeof element ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 11:\n                $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 14:\n            case 15:\n                $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            default:\n                return !1;\n        }\n        return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? !0 : !1;\n    }\n    function markFailedErrorBoundaryForHotReloading(fiber) {\n        null !== resolveFamily && \"function\" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));\n    }\n    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;\n        switch(tag){\n            case 0:\n            case 15:\n            case 1:\n                candidateType = type;\n                break;\n            case 11:\n                candidateType = type.render;\n        }\n        if (null === resolveFamily) throw Error(\"Expected resolveFamily to be set during hot reload.\");\n        var needsRender = !1;\n        type = !1;\n        null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = !0 : updatedFamilies.has(candidateType) && (1 === tag ? type = !0 : needsRender = !0)));\n        null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = !0);\n        type && (fiber._debugNeedsRemount = !0);\n        if (type || needsRender) alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);\n        null === child || type || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n        null !== sibling && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n    }\n    function FiberNode(tag, pendingProps, key, mode) {\n        this.tag = tag;\n        this.key = key;\n        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;\n        this.index = 0;\n        this.refCleanup = this.ref = null;\n        this.pendingProps = pendingProps;\n        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;\n        this.mode = mode;\n        this.subtreeFlags = this.flags = 0;\n        this.deletions = null;\n        this.childLanes = this.lanes = 0;\n        this.alternate = null;\n        this.actualDuration = -0;\n        this.actualStartTime = -1.1;\n        this.treeBaseDuration = this.selfBaseDuration = -0;\n        this._debugOwner = this._debugInfo = null;\n        this._debugNeedsRemount = !1;\n        this._debugHookTypes = null;\n        hasBadMapPolyfill || \"function\" !== typeof Object.preventExtensions || Object.preventExtensions(this);\n    }\n    function shouldConstruct(Component) {\n        Component = Component.prototype;\n        return !(!Component || !Component.isReactComponent);\n    }\n    function createWorkInProgress(current, pendingProps) {\n        var workInProgress = current.alternate;\n        null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress._debugOwner = current._debugOwner, workInProgress._debugHookTypes = current._debugHookTypes, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.actualDuration = -0, workInProgress.actualStartTime = -1.1);\n        workInProgress.flags = current.flags & 31457280;\n        workInProgress.childLanes = current.childLanes;\n        workInProgress.lanes = current.lanes;\n        workInProgress.child = current.child;\n        workInProgress.memoizedProps = current.memoizedProps;\n        workInProgress.memoizedState = current.memoizedState;\n        workInProgress.updateQueue = current.updateQueue;\n        pendingProps = current.dependencies;\n        workInProgress.dependencies = null === pendingProps ? null : {\n            lanes: pendingProps.lanes,\n            firstContext: pendingProps.firstContext,\n            _debugThenableState: pendingProps._debugThenableState\n        };\n        workInProgress.sibling = current.sibling;\n        workInProgress.index = current.index;\n        workInProgress.ref = current.ref;\n        workInProgress.refCleanup = current.refCleanup;\n        workInProgress.selfBaseDuration = current.selfBaseDuration;\n        workInProgress.treeBaseDuration = current.treeBaseDuration;\n        workInProgress._debugInfo = current._debugInfo;\n        workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n        switch(workInProgress.tag){\n            case 0:\n            case 15:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 1:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 11:\n                workInProgress.type = resolveForwardRefForHotReloading(current.type);\n        }\n        return workInProgress;\n    }\n    function resetWorkInProgress(workInProgress, renderLanes) {\n        workInProgress.flags &= 31457282;\n        var current = workInProgress.alternate;\n        null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null, workInProgress.selfBaseDuration = 0, workInProgress.treeBaseDuration = 0) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {\n            lanes: renderLanes.lanes,\n            firstContext: renderLanes.firstContext,\n            _debugThenableState: renderLanes._debugThenableState\n        }, workInProgress.selfBaseDuration = current.selfBaseDuration, workInProgress.treeBaseDuration = current.treeBaseDuration);\n        return workInProgress;\n    }\n    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n        var fiberTag = 0, resolvedType = type;\n        if (\"function\" === typeof type) shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);\n        else if (\"string\" === typeof type) supportsResources && supportsSingletons ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : isHostSingletonType(type) ? 27 : 5) : supportsResources ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : 5) : fiberTag = supportsSingletons ? isHostSingletonType(type) ? 27 : 5 : 5;\n        else a: switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n            case REACT_STRICT_MODE_TYPE:\n                fiberTag = 8;\n                mode |= 24;\n                break;\n            case REACT_PROFILER_TYPE:\n                return type = pendingProps, owner = mode, \"string\" !== typeof type.id && console.error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | 2), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                }, key;\n            case REACT_SUSPENSE_TYPE:\n                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;\n            case REACT_SUSPENSE_LIST_TYPE:\n                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;\n            case REACT_OFFSCREEN_TYPE:\n                return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n            default:\n                if (\"object\" === typeof type && null !== type) switch(type.$$typeof){\n                    case REACT_PROVIDER_TYPE:\n                    case REACT_CONTEXT_TYPE:\n                        fiberTag = 10;\n                        break a;\n                    case REACT_CONSUMER_TYPE:\n                        fiberTag = 9;\n                        break a;\n                    case REACT_FORWARD_REF_TYPE:\n                        fiberTag = 11;\n                        resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                        break a;\n                    case REACT_MEMO_TYPE:\n                        fiberTag = 14;\n                        break a;\n                    case REACT_LAZY_TYPE:\n                        fiberTag = 16;\n                        resolvedType = null;\n                        break a;\n                }\n                resolvedType = \"\";\n                if (void 0 === type || \"object\" === typeof type && null !== type && 0 === Object.keys(type).length) resolvedType += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n                null === type ? pendingProps = \"null\" : isArrayImpl(type) ? pendingProps = \"array\" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\", resolvedType = \" Did you accidentally export a JSX literal instead of a component?\") : pendingProps = typeof type;\n                fiberTag = owner ? \"number\" === typeof owner.tag ? getComponentNameFromFiber(owner) : \"string\" === typeof owner.name ? owner.name : null : null;\n                fiberTag && (resolvedType += \"\\n\\nCheck the render method of `\" + fiberTag + \"`.\");\n                fiberTag = 29;\n                pendingProps = Error(\"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" + (pendingProps + \".\" + resolvedType));\n                resolvedType = null;\n        }\n        key = createFiber(fiberTag, pendingProps, key, mode);\n        key.elementType = type;\n        key.type = resolvedType;\n        key.lanes = lanes;\n        key._debugOwner = owner;\n        return key;\n    }\n    function createFiberFromElement(element, mode, lanes) {\n        mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);\n        mode._debugOwner = element._owner;\n        return mode;\n    }\n    function createFiberFromFragment(elements, mode, lanes, key) {\n        elements = createFiber(7, elements, key, mode);\n        elements.lanes = lanes;\n        return elements;\n    }\n    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n        pendingProps = createFiber(22, pendingProps, key, mode);\n        pendingProps.elementType = REACT_OFFSCREEN_TYPE;\n        pendingProps.lanes = lanes;\n        var primaryChildInstance = {\n            _visibility: 1,\n            _pendingVisibility: 1,\n            _pendingMarkers: null,\n            _retryCache: null,\n            _transitions: null,\n            _current: null,\n            detach: function() {\n                var instance = primaryChildInstance, fiber = instance._current;\n                if (null === fiber) throw Error(\"Calling Offscreen.detach before instance handle has been set.\");\n                if (0 === (instance._pendingVisibility & 2)) {\n                    var root = enqueueConcurrentRenderForLane(fiber, 2);\n                    null !== root && (instance._pendingVisibility |= 2, scheduleUpdateOnFiber(root, fiber, 2));\n                }\n            },\n            attach: function() {\n                var instance = primaryChildInstance, fiber = instance._current;\n                if (null === fiber) throw Error(\"Calling Offscreen.detach before instance handle has been set.\");\n                if (0 !== (instance._pendingVisibility & 2)) {\n                    var root = enqueueConcurrentRenderForLane(fiber, 2);\n                    null !== root && (instance._pendingVisibility &= -3, scheduleUpdateOnFiber(root, fiber, 2));\n                }\n            }\n        };\n        pendingProps.stateNode = primaryChildInstance;\n        return pendingProps;\n    }\n    function createFiberFromText(content, mode, lanes) {\n        content = createFiber(6, content, null, mode);\n        content.lanes = lanes;\n        return content;\n    }\n    function createFiberFromPortal(portal, mode, lanes) {\n        mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);\n        mode.lanes = lanes;\n        mode.stateNode = {\n            containerInfo: portal.containerInfo,\n            pendingChildren: null,\n            implementation: portal.implementation\n        };\n        return mode;\n    }\n    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {\n        this.tag = 1;\n        this.containerInfo = containerInfo;\n        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;\n        this.timeoutHandle = noTimeout;\n        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;\n        this.callbackPriority = 0;\n        this.expirationTimes = createLaneMap(-1);\n        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;\n        this.entanglements = createLaneMap(0);\n        this.hiddenUpdates = createLaneMap(null);\n        this.identifierPrefix = identifierPrefix;\n        this.onUncaughtError = onUncaughtError;\n        this.onCaughtError = onCaughtError;\n        this.onRecoverableError = onRecoverableError;\n        this.pooledCache = null;\n        this.pooledCacheLanes = 0;\n        this.formState = formState;\n        this.incompleteTransitions = new Map();\n        this.passiveEffectDuration = this.effectDuration = -0;\n        this.memoizedUpdaters = new Set();\n        containerInfo = this.pendingUpdatersLaneMap = [];\n        for(tag = 0; 31 > tag; tag++)containerInfo.push(new Set());\n        this._debugRootType = hydrate ? \"hydrateRoot()\" : \"createRoot()\";\n    }\n    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);\n        tag = 1;\n        !0 === isStrictMode && (tag |= 24);\n        isDevToolsPresent && (tag |= 2);\n        isStrictMode = createFiber(3, null, null, tag);\n        containerInfo.current = isStrictMode;\n        isStrictMode.stateNode = containerInfo;\n        tag = createCache();\n        retainCache(tag);\n        containerInfo.pooledCache = tag;\n        retainCache(tag);\n        isStrictMode.memoizedState = {\n            element: initialChildren,\n            isDehydrated: hydrate,\n            cache: tag\n        };\n        initializeUpdateQueue(isStrictMode);\n        return containerInfo;\n    }\n    function testStringCoercion(value) {\n        return \"\" + value;\n    }\n    function getContextForSubtree(parentComponent) {\n        if (!parentComponent) return emptyContextObject;\n        parentComponent = emptyContextObject;\n        return parentComponent;\n    }\n    function updateContainerSync(element, container, parentComponent, callback) {\n        0 === container.tag && flushPassiveEffects();\n        updateContainerImpl(container.current, 2, element, container, parentComponent, callback);\n        return 2;\n    }\n    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {\n        if (injectedHook && \"function\" === typeof injectedHook.onScheduleFiberRoot) try {\n            injectedHook.onScheduleFiberRoot(rendererID, container, element);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);\n        parentComponent = getContextForSubtree(parentComponent);\n        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;\n        isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, console.error(\"Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\\n\\nCheck the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\"));\n        container = createUpdate(lane);\n        container.payload = {\n            element: element\n        };\n        callback = void 0 === callback ? null : callback;\n        null !== callback && (\"function\" !== typeof callback && console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback), container.callback = callback);\n        element = enqueueUpdate(rootFiber, container, lane);\n        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));\n    }\n    function markRetryLaneImpl(fiber, retryLane) {\n        fiber = fiber.memoizedState;\n        if (null !== fiber && null !== fiber.dehydrated) {\n            var a = fiber.retryLane;\n            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;\n        }\n    }\n    function markRetryLaneIfNotHydrated(fiber, retryLane) {\n        markRetryLaneImpl(fiber, retryLane);\n        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);\n    }\n    function getCurrentFiberForDevTools() {\n        return current;\n    }\n    function getLaneLabelMap() {\n        for(var map = new Map(), lane = 1, index = 0; 31 > index; index++){\n            var label = getLabelForLane(lane);\n            map.set(lane, label);\n            lane *= 2;\n        }\n        return map;\n    }\n    var exports = {};\n    \"use strict\";\n    var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"), Scheduler = __webpack_require__(/*! scheduler */ \"(app-pages-browser)/./node_modules/scheduler/index.js\"), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"), REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"), REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"), REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n    Symbol.for(\"react.scope\");\n    Symbol.for(\"react.debug_trace_mode\");\n    var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n    Symbol.for(\"react.legacy_hidden\");\n    Symbol.for(\"react.tracing_marker\");\n    var REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix, suffix, reentry = !1;\n    var componentFrameCache = new (\"function\" === typeof WeakMap ? WeakMap : Map)();\n    var current = null, isRendering = !1, isArrayImpl = Array.isArray, rendererVersion = $$$config.rendererVersion, rendererPackageName = $$$config.rendererPackageName, extraDevToolsConfig = $$$config.extraDevToolsConfig, getPublicInstance = $$$config.getPublicInstance, getRootHostContext = $$$config.getRootHostContext, getChildHostContext = $$$config.getChildHostContext, prepareForCommit = $$$config.prepareForCommit, resetAfterCommit = $$$config.resetAfterCommit, createInstance = $$$config.createInstance, appendInitialChild = $$$config.appendInitialChild, finalizeInitialChildren = $$$config.finalizeInitialChildren, shouldSetTextContent = $$$config.shouldSetTextContent, createTextInstance = $$$config.createTextInstance, scheduleTimeout = $$$config.scheduleTimeout, cancelTimeout = $$$config.cancelTimeout, noTimeout = $$$config.noTimeout, isPrimaryRenderer = $$$config.isPrimaryRenderer;\n    $$$config.warnsIfNotActing;\n    var supportsMutation = $$$config.supportsMutation, supportsPersistence = $$$config.supportsPersistence, supportsHydration = $$$config.supportsHydration, getInstanceFromNode = $$$config.getInstanceFromNode;\n    $$$config.beforeActiveInstanceBlur;\n    $$$config.afterActiveInstanceBlur;\n    var preparePortalMount = $$$config.preparePortalMount;\n    $$$config.prepareScopeUpdate;\n    $$$config.getInstanceFromScope;\n    var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority, getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority, resolveUpdatePriority = $$$config.resolveUpdatePriority;\n    $$$config.resolveEventType;\n    $$$config.resolveEventTimeStamp;\n    var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition, detachDeletedInstance = $$$config.detachDeletedInstance;\n    $$$config.requestPostPaintCallback;\n    var maySuspendCommit = $$$config.maySuspendCommit, preloadInstance = $$$config.preloadInstance, startSuspendingCommit = $$$config.startSuspendingCommit, suspendInstance = $$$config.suspendInstance, waitForCommitToBeReady = $$$config.waitForCommitToBeReady, NotPendingTransition = $$$config.NotPendingTransition, HostTransitionContext = $$$config.HostTransitionContext, resetFormInstance = $$$config.resetFormInstance, bindToConsole = $$$config.bindToConsole, supportsMicrotasks = $$$config.supportsMicrotasks, scheduleMicrotask = $$$config.scheduleMicrotask, supportsTestSelectors = $$$config.supportsTestSelectors, findFiberRoot = $$$config.findFiberRoot, getBoundingRect = $$$config.getBoundingRect, getTextContent = $$$config.getTextContent, isHiddenSubtree = $$$config.isHiddenSubtree, matchAccessibilityRole = $$$config.matchAccessibilityRole, setFocusIfFocusable = $$$config.setFocusIfFocusable, setupIntersectionObserver = $$$config.setupIntersectionObserver, appendChild = $$$config.appendChild, appendChildToContainer = $$$config.appendChildToContainer, commitTextUpdate = $$$config.commitTextUpdate, commitMount = $$$config.commitMount, commitUpdate = $$$config.commitUpdate, insertBefore = $$$config.insertBefore, insertInContainerBefore = $$$config.insertInContainerBefore, removeChild = $$$config.removeChild, removeChildFromContainer = $$$config.removeChildFromContainer, resetTextContent = $$$config.resetTextContent, hideInstance = $$$config.hideInstance, hideTextInstance = $$$config.hideTextInstance, unhideInstance = $$$config.unhideInstance, unhideTextInstance = $$$config.unhideTextInstance, clearContainer = $$$config.clearContainer, cloneInstance = $$$config.cloneInstance, createContainerChildSet = $$$config.createContainerChildSet, appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet, finalizeContainerChildren = $$$config.finalizeContainerChildren, replaceContainerChildren = $$$config.replaceContainerChildren, cloneHiddenInstance = $$$config.cloneHiddenInstance, cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance, isSuspenseInstancePending = $$$config.isSuspenseInstancePending, isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry, canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker, isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching, getNextHydratableSibling = $$$config.getNextHydratableSibling, getFirstHydratableChild = $$$config.getFirstHydratableChild, getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance, canHydrateInstance = $$$config.canHydrateInstance, canHydrateTextInstance = $$$config.canHydrateTextInstance, canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance, hydrateInstance = $$$config.hydrateInstance, hydrateTextInstance = $$$config.hydrateTextInstance, hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance, commitHydratedContainer = $$$config.commitHydratedContainer, commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance, clearSuspenseBoundary = $$$config.clearSuspenseBoundary, clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer, shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances, diffHydratedPropsForDevWarnings = $$$config.diffHydratedPropsForDevWarnings, diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings, describeHydratableInstanceForDevWarnings = $$$config.describeHydratableInstanceForDevWarnings, validateHydratableInstance = $$$config.validateHydratableInstance, validateHydratableTextInstance = $$$config.validateHydratableTextInstance, supportsResources = $$$config.supportsResources, isHostHoistableType = $$$config.isHostHoistableType, getHoistableRoot = $$$config.getHoistableRoot, getResource = $$$config.getResource, acquireResource = $$$config.acquireResource, releaseResource = $$$config.releaseResource, hydrateHoistable = $$$config.hydrateHoistable, mountHoistable = $$$config.mountHoistable, unmountHoistable = $$$config.unmountHoistable, createHoistableInstance = $$$config.createHoistableInstance, prepareToCommitHoistables = $$$config.prepareToCommitHoistables, mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit, preloadResource = $$$config.preloadResource, suspendResource = $$$config.suspendResource, supportsSingletons = $$$config.supportsSingletons, resolveSingletonInstance = $$$config.resolveSingletonInstance, clearSingleton = $$$config.clearSingleton, acquireSingletonInstance = $$$config.acquireSingletonInstance, releaseSingletonInstance = $$$config.releaseSingletonInstance, isHostSingletonType = $$$config.isHostSingletonType, valueStack = [];\n    var fiberStack = [];\n    var index$jscomp$0 = -1, emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$1 = Math.log, LN2 = Math.LN2, nextTransitionLane = 128, nextRetryLane = 4194304, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, log = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = !1, isDevToolsPresent = \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, objectIs = \"function\" === typeof Object.is ? Object.is : is, CapturedStacks = new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = \"\", contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), needsEscaping = /[\"'&<>\\n\\t]|^\\s|\\s$/, hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = !1, HydrationMismatchException = Error(\"Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), NoMode = 0, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, now = Scheduler.unstable_now, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = !1, nestedUpdateScheduled = !1, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = !1, didScheduleMicrotask_act = !1, mightHavePendingSyncWork = !1, isFlushingWork = !1, currentEventTransitionLane = 0, fakeActCallbackNode$1 = {}, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = !1;\n    var didWarnUpdateInsideUpdate = !1;\n    var currentlyProcessingQueue = null;\n    var didReadFromEntangledAsyncAction = !1, hasOwnProperty = Object.prototype.hasOwnProperty, ReactStrictModeWarnings = {\n        recordUnsafeLifecycleWarnings: function() {},\n        flushPendingUnsafeLifecycleWarnings: function() {},\n        recordLegacyContextWarning: function() {},\n        flushLegacyContextWarning: function() {},\n        discardPendingWarnings: function() {}\n    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set();\n    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n        didWarnAboutUnsafeLifecycles.has(fiber.type) || (\"function\" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), \"function\" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), \"function\" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));\n    };\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n        var componentWillMountUniqueNames = new Set();\n        0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {\n            componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillMountWarnings = []);\n        var UNSAFE_componentWillMountUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillMountWarnings = []);\n        var componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillReceivePropsWarnings = []);\n        var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);\n        var componentWillUpdateUniqueNames = new Set();\n        0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n            componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillUpdateWarnings = []);\n        var UNSAFE_componentWillUpdateUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillUpdateWarnings = []);\n        if (0 < UNSAFE_componentWillMountUniqueNames.size) {\n            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n            console.error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\\nPlease update the following components: %s\", sortedNames);\n        }\n        0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(\"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(\"componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n    };\n    var pendingLegacyContextWarning = new Map(), didWarnAboutLegacyContext = new Set();\n    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n        var strictRoot = null;\n        for(var node = fiber; null !== node;)node.mode & 8 && (strictRoot = node), node = node.return;\n        null === strictRoot ? console.error(\"Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.\") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && \"function\" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));\n    };\n    ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n        pendingLegacyContextWarning.forEach(function(fiberArray) {\n            if (0 !== fiberArray.length) {\n                var firstFiber = fiberArray[0], uniqueNames = new Set();\n                fiberArray.forEach(function(fiber) {\n                    uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                    didWarnAboutLegacyContext.add(fiber.type);\n                });\n                var sortedNames = setToSortedString(uniqueNames);\n                runWithFiberInDEV(firstFiber, function() {\n                    console.error(\"Legacy context API has been detected within a strict-mode tree.\\n\\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\\n\\nPlease update the following components: %s\\n\\nLearn more about this warning here: https://react.dev/link/legacy-context\", sortedNames);\n                });\n            }\n        });\n    };\n    ReactStrictModeWarnings.discardPendingWarnings = function() {\n        pendingComponentWillMountWarnings = [];\n        pendingUNSAFE_ComponentWillMountWarnings = [];\n        pendingComponentWillReceivePropsWarnings = [];\n        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n        pendingComponentWillUpdateWarnings = [];\n        pendingUNSAFE_ComponentWillUpdateWarnings = [];\n        pendingLegacyContextWarning = new Map();\n    };\n    var SuspenseException = Error(\"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`\"), SuspenseyCommitException = Error(\"Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), noopSuspenseyCommitThenable = {\n        then: function() {\n            console.error('Internal React error: A listener was unexpectedly attached to a \"noop\" thenable. This is a bug in React. Please file an issue.');\n        }\n    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = !1, callComponent = {\n        \"react-stack-bottom-frame\": function(Component, props, secondArg) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return Component(props, secondArg);\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callComponentInDEV = callComponent[\"react-stack-bottom-frame\"].bind(callComponent), callRender = {\n        \"react-stack-bottom-frame\": function(instance) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return instance.render();\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender), callComponentDidMount = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance) {\n            try {\n                instance.componentDidMount();\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidMountInDEV = callComponentDidMount[\"react-stack-bottom-frame\"].bind(callComponentDidMount), callComponentDidUpdate = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance, prevProps, prevState, snapshot) {\n            try {\n                instance.componentDidUpdate(prevProps, prevState, snapshot);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidUpdateInDEV = callComponentDidUpdate[\"react-stack-bottom-frame\"].bind(callComponentDidUpdate), callComponentDidCatch = {\n        \"react-stack-bottom-frame\": function(instance, errorInfo) {\n            var stack = errorInfo.stack;\n            instance.componentDidCatch(errorInfo.value, {\n                componentStack: null !== stack ? stack : \"\"\n            });\n        }\n    }, callComponentDidCatchInDEV = callComponentDidCatch[\"react-stack-bottom-frame\"].bind(callComponentDidCatch), callComponentWillUnmount = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, instance) {\n            try {\n                instance.componentWillUnmount();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callComponentWillUnmountInDEV = callComponentWillUnmount[\"react-stack-bottom-frame\"].bind(callComponentWillUnmount), callCreate = {\n        \"react-stack-bottom-frame\": function(effect) {\n            var create = effect.create;\n            effect = effect.inst;\n            create = create();\n            return effect.destroy = create;\n        }\n    }, callCreateInDEV = callCreate[\"react-stack-bottom-frame\"].bind(callCreate), callDestroy = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callDestroyInDEV = callDestroy[\"react-stack-bottom-frame\"].bind(callDestroy), callLazyInit = {\n        \"react-stack-bottom-frame\": function(lazy) {\n            var init = lazy._init;\n            return init(lazy._payload);\n        }\n    }, callLazyInitInDEV = callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit), thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;\n    var didWarnAboutGenerators = didWarnAboutMaps = !1;\n    var ownerHasKeyUseWarning = {};\n    var ownerHasFunctionTypeWarning = {};\n    var ownerHasSymbolTypeWarning = {};\n    warnForMissingKey = function(returnFiber, workInProgress, child) {\n        if (null !== child && \"object\" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {\n            if (\"object\" !== typeof child._store) throw Error(\"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\");\n            child._store.validated = 1;\n            var componentName = getComponentNameFromFiber(returnFiber), componentKey = componentName || \"null\";\n            if (!ownerHasKeyUseWarning[componentKey]) {\n                ownerHasKeyUseWarning[componentKey] = !0;\n                child = child._owner;\n                returnFiber = returnFiber._debugOwner;\n                var currentComponentErrorInfo = \"\";\n                returnFiber && \"number\" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = \"\\n\\nCheck the render method of `\" + componentKey + \"`.\");\n                currentComponentErrorInfo || componentName && (currentComponentErrorInfo = \"\\n\\nCheck the top-level render call using <\" + componentName + \">.\");\n                var childOwnerAppendix = \"\";\n                null != child && returnFiber !== child && (componentName = null, \"number\" === typeof child.tag ? componentName = getComponentNameFromFiber(child) : \"string\" === typeof child.name && (componentName = child.name), componentName && (childOwnerAppendix = \" It was passed a child from \" + componentName + \".\"));\n                runWithFiberInDEV(workInProgress, function() {\n                    console.error('Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);\n                });\n            }\n        }\n    };\n    var reconcileChildFibers = createChildReconciler(!0), mountChildFibers = createChildReconciler(!1), currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;\n    var didWarnAboutMismatchedHooksForComponent = new Set();\n    var didWarnAboutUseWrappedInTryCatch = new Set();\n    var didWarnAboutAsyncClientComponent = new Set();\n    var didWarnAboutUseFormState = new Set();\n    var renderLanes = 0, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, shouldDoubleInvokeUserFnsInHooksDEV = !1, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = !1;\n    var createFunctionComponentUpdateQueue = function() {\n        return {\n            lastEffect: null,\n            events: null,\n            stores: null,\n            memoCache: null\n        };\n    };\n    var ContextOnlyDispatcher = {\n        readContext: readContext,\n        use: use,\n        useCallback: throwInvalidHookError,\n        useContext: throwInvalidHookError,\n        useEffect: throwInvalidHookError,\n        useImperativeHandle: throwInvalidHookError,\n        useLayoutEffect: throwInvalidHookError,\n        useInsertionEffect: throwInvalidHookError,\n        useMemo: throwInvalidHookError,\n        useReducer: throwInvalidHookError,\n        useRef: throwInvalidHookError,\n        useState: throwInvalidHookError,\n        useDebugValue: throwInvalidHookError,\n        useDeferredValue: throwInvalidHookError,\n        useTransition: throwInvalidHookError,\n        useSyncExternalStore: throwInvalidHookError,\n        useId: throwInvalidHookError\n    };\n    ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n    ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\n    ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;\n    ContextOnlyDispatcher.useFormState = throwInvalidHookError;\n    ContextOnlyDispatcher.useActionState = throwInvalidHookError;\n    ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;\n    var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n    HooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            mountHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        mountHookTypesDev();\n        warnOnUseFormStateInDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        mountHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    HooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnUpdateInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return updateActionState(action);\n    };\n    HooksDispatcherOnUpdateInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    HooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return updateOptimistic(passthrough, reducer);\n    };\n    HooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnRerenderInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return rerenderActionState(action);\n    };\n    HooksDispatcherOnRerenderInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    HooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return rerenderOptimistic(passthrough, reducer);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        },\n        useMemoCache: _s4(function(size) {\n            _s4();\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }, \"BJQGJJUCbd3saIVlp1AxjdYhExU=\", false, function() {\n            return [\n                useMemoCache\n            ];\n        })\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useMemoCache: _s5(function(size) {\n            _s5();\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }, \"BJQGJJUCbd3saIVlp1AxjdYhExU=\", false, function() {\n            return [\n                useMemoCache\n            ];\n        })\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateOptimistic(passthrough, reducer);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useMemoCache: _s6(function(size) {\n            _s6();\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }, \"BJQGJJUCbd3saIVlp1AxjdYhExU=\", false, function() {\n            return [\n                useMemoCache\n            ];\n        })\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderOptimistic(passthrough, reducer);\n    };\n    var fakeInternalInstance = {};\n    var didWarnAboutStateAssignmentForComponent = new Set();\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    Object.freeze(fakeInternalInstance);\n    var classComponentUpdater = {\n        isMounted: function(component) {\n            var owner = current;\n            if (null !== owner && isRendering && 1 === owner.tag) {\n                var instance = owner.stateNode;\n                instance._warnedAboutRefsInRender || console.error(\"%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.\", getComponentNameFromFiber(owner) || \"A component\");\n                instance._warnedAboutRefsInRender = !0;\n            }\n            return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : !1;\n        },\n        enqueueSetState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueReplaceState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ReplaceState;\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueForceUpdate: function(inst, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ForceUpdate;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            callback = enqueueUpdate(inst, update, lane);\n            null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));\n            null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);\n        }\n    }, reportGlobalError = \"function\" === typeof reportError ? reportError : function(error) {\n        if (\"object\" === typeof window && \"function\" === typeof window.ErrorEvent) {\n            var event = new window.ErrorEvent(\"error\", {\n                bubbles: !0,\n                cancelable: !0,\n                message: \"object\" === typeof error && null !== error && \"string\" === typeof error.message ? String(error.message) : String(error),\n                error: error\n            });\n            if (!window.dispatchEvent(event)) return;\n        } else if (\"object\" === typeof process && \"function\" === typeof process.emit) {\n            process.emit(\"uncaughtException\", error);\n            return;\n        }\n        console.error(error);\n    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(\"This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue.\"), didReceiveUpdate = !1;\n    var didWarnAboutBadClass = {};\n    var didWarnAboutContextTypeOnFunctionComponent = {};\n    var didWarnAboutContextTypes = {};\n    var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n    var didWarnAboutReassigningProps = !1;\n    var didWarnAboutRevealOrder = {};\n    var didWarnAboutTailOptions = {};\n    var SUSPENDED_MARKER = {\n        dehydrated: null,\n        treeContext: null,\n        retryLane: 0\n    }, hasWarnedAboutUsingNoValuePropOnContextProvider = !1, valueCursor = createCursor(null);\n    var rendererCursorDEV = createCursor(null);\n    var renderer2CursorDEV = createCursor(null);\n    var rendererSigil = {};\n    var currentlyRenderingFiber = null, lastContextDependency = null, isDisallowedContextReadInDEV = !1, AbortControllerLocal = \"undefined\" !== typeof AbortController ? AbortController : function() {\n        var listeners = [], signal = this.signal = {\n            aborted: !1,\n            addEventListener: function(type, listener) {\n                listeners.push(listener);\n            }\n        };\n        this.abort = function() {\n            signal.aborted = !0;\n            listeners.forEach(function(listener) {\n                return listener();\n            });\n        };\n    }, scheduleCallback$1 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        Consumer: null,\n        Provider: null,\n        _currentValue: null,\n        _currentValue2: null,\n        _threadCount: 0,\n        _currentRenderer: null,\n        _currentRenderer2: null\n    }, prevOnStartTransitionFinish = ReactSharedInternals.S;\n    ReactSharedInternals.S = function(transition, returnValue) {\n        \"object\" === typeof returnValue && null !== returnValue && \"function\" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);\n        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);\n    };\n    var resumedCache = createCursor(null), didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n    var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, needsFormReset = !1, PossiblyWeakSet = \"function\" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, shouldFireAfterActiveInstanceBlur = !1, hostParent = null, hostParentIsContainer = !1, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {\n        getCacheForType: function(resourceType) {\n            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);\n            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));\n            return cacheForType;\n        },\n        getOwner: function() {\n            return current;\n        }\n    }, COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;\n    if (\"function\" === typeof Symbol && Symbol.for) {\n        var symbolFor = Symbol.for;\n        COMPONENT_TYPE = symbolFor(\"selector.component\");\n        HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n        ROLE_TYPE = symbolFor(\"selector.role\");\n        TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n        TEXT_TYPE = symbolFor(\"selector.text\");\n    }\n    var commitHooks = [], PossiblyWeakMap = \"function\" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootCompleted = 5, RootDidNotComplete = 6, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = !1, workInProgressRootDidAttachPingListener = !1, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = 0, pendingPassiveEffectsRemainingLanes = 0, pendingPassiveTransitions = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = !1, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = !1;\n    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n    var fakeActCallbackNode = {}, resolveFamily = null, failedBoundaries = null;\n    var hasBadMapPolyfill = !1;\n    try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        new Map([\n            [\n                nonExtensibleObject,\n                null\n            ]\n        ]);\n        new Set([\n            nonExtensibleObject\n        ]);\n    } catch (e) {\n        hasBadMapPolyfill = !0;\n    }\n    var didWarnAboutNestedUpdates = !1;\n    var didWarnAboutFindNodeInStrictMode = {};\n    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;\n    overrideHookState = function(fiber, id, path, value) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateDeletePath = function(fiber, id, path) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n        id = findHook(fiber, id);\n        null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));\n    };\n    overrideProps = function(fiber, path, value) {\n        fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsDeletePath = function(fiber, path) {\n        fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsRenamePath = function(fiber, oldPath, newPath) {\n        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        oldPath = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);\n    };\n    scheduleUpdate = function(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    };\n    setErrorHandler = function(newShouldErrorImpl) {\n        shouldErrorImpl = newShouldErrorImpl;\n    };\n    setSuspenseHandler = function(newShouldSuspendImpl) {\n        shouldSuspendImpl = newShouldSuspendImpl;\n    };\n    exports.attemptContinuousHydration = function(fiber) {\n        if (13 === fiber.tag) {\n            var root = enqueueConcurrentRenderForLane(fiber, 67108864);\n            null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);\n            markRetryLaneIfNotHydrated(fiber, 67108864);\n        }\n    };\n    exports.attemptHydrationAtCurrentPriority = function(fiber) {\n        if (13 === fiber.tag) {\n            var lane = requestUpdateLane(fiber), root = enqueueConcurrentRenderForLane(fiber, lane);\n            null !== root && scheduleUpdateOnFiber(root, fiber, lane);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n    };\n    exports.attemptSynchronousHydration = function(fiber) {\n        switch(fiber.tag){\n            case 3:\n                fiber = fiber.stateNode;\n                if (fiber.current.memoizedState.isDehydrated) {\n                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);\n                    if (0 !== lanes) {\n                        fiber.pendingLanes |= 2;\n                        for(fiber.entangledLanes |= 2; lanes;){\n                            var lane = 1 << 31 - clz32(lanes);\n                            fiber.entanglements[1] |= lane;\n                            lanes &= ~lane;\n                        }\n                        ensureRootIsScheduled(fiber);\n                        (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, !1));\n                    }\n                }\n                break;\n            case 13:\n                lanes = enqueueConcurrentRenderForLane(fiber, 2), null !== lanes && scheduleUpdateOnFiber(lanes, fiber, 2), flushSyncWork(), markRetryLaneIfNotHydrated(fiber, 2);\n        }\n    };\n    exports.batchedUpdates = function(fn, a) {\n        return fn(a);\n    };\n    exports.createComponentSelector = function(component) {\n        return {\n            $$typeof: COMPONENT_TYPE,\n            value: component\n        };\n    };\n    exports.createContainer = function(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {\n        return createFiberRoot(containerInfo, tag, !1, null, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);\n    };\n    exports.createHasPseudoClassSelector = function(selectors) {\n        return {\n            $$typeof: HAS_PSEUDO_CLASS_TYPE,\n            value: selectors\n        };\n    };\n    exports.createHydrationContainer = function(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        initialChildren = createFiberRoot(containerInfo, tag, !0, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);\n        initialChildren.context = getContextForSubtree(null);\n        containerInfo = initialChildren.current;\n        tag = requestUpdateLane(containerInfo);\n        hydrationCallbacks = createUpdate(tag);\n        hydrationCallbacks.callback = void 0 !== callback && null !== callback ? callback : null;\n        enqueueUpdate(containerInfo, hydrationCallbacks, tag);\n        initialChildren.current.lanes = tag;\n        markRootUpdated$1(initialChildren, tag);\n        ensureRootIsScheduled(initialChildren);\n        return initialChildren;\n    };\n    exports.createPortal = function(children, containerInfo, implementation) {\n        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n        try {\n            testStringCoercion(key);\n            var JSCompiler_inline_result = !1;\n        } catch (e$6) {\n            JSCompiler_inline_result = !0;\n        }\n        JSCompiler_inline_result && (console.error(\"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\", \"function\" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || \"Object\"), testStringCoercion(key));\n        return {\n            $$typeof: REACT_PORTAL_TYPE,\n            key: null == key ? null : \"\" + key,\n            children: children,\n            containerInfo: containerInfo,\n            implementation: implementation\n        };\n    };\n    exports.createRoleSelector = function(role) {\n        return {\n            $$typeof: ROLE_TYPE,\n            value: role\n        };\n    };\n    exports.createTestNameSelector = function(id) {\n        return {\n            $$typeof: TEST_NAME_TYPE,\n            value: id\n        };\n    };\n    exports.createTextSelector = function(text) {\n        return {\n            $$typeof: TEXT_TYPE,\n            value: text\n        };\n    };\n    exports.defaultOnCaughtError = function(error, errorInfo) {\n        var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component.\" : \"The above error occurred in one of your React components.\", recreateMessage = \"React will try to recreate this component tree from scratch using the error boundary you provided, \" + ((errorBoundaryName || \"Anonymous\") + \".\"), prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : \"\";\n        ReactSharedInternals.getCurrentStack = function() {\n            return componentStack;\n        };\n        try {\n            \"object\" === typeof error && null !== error && \"string\" === typeof error.environmentName ? bindToConsole(\"error\", [\n                \"%o\\n\\n%s\\n\\n%s\\n\",\n                error,\n                componentNameMessage,\n                recreateMessage\n            ], error.environmentName)() : console.error(\"%o\\n\\n%s\\n\\n%s\\n\", error, componentNameMessage, recreateMessage);\n        } finally{\n            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n        }\n    };\n    exports.defaultOnRecoverableError = function(error) {\n        reportGlobalError(error);\n    };\n    exports.defaultOnUncaughtError = function(error, errorInfo) {\n        reportGlobalError(error);\n        error = componentName ? \"An error occurred in the <\" + componentName + \"> component.\" : \"An error occurred in one of your React components.\";\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : \"\";\n        ReactSharedInternals.getCurrentStack = function() {\n            return componentStack;\n        };\n        try {\n            console.warn(\"%s\\n\\n%s\\n\", error, \"Consider adding an error boundary to your tree to customize error handling behavior.\\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.\");\n        } finally{\n            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n        }\n    };\n    exports.deferredUpdates = function(fn) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(32), ReactSharedInternals.T = null, fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition;\n        }\n    };\n    exports.discreteUpdates = function(fn, a, b, c, d) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn(a, b, c, d);\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS);\n        }\n    };\n    exports.findAllNodes = findAllNodes;\n    exports.findBoundingRects = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        selectors = findAllNodes(hostRoot, selectors);\n        hostRoot = [];\n        for(var i = 0; i < selectors.length; i++)hostRoot.push(getBoundingRect(selectors[i]));\n        for(selectors = hostRoot.length - 1; 0 < selectors; selectors--){\n            i = hostRoot[selectors];\n            for(var targetLeft = i.x, targetRight = targetLeft + i.width, targetTop = i.y, targetBottom = targetTop + i.height, j = selectors - 1; 0 <= j; j--)if (selectors !== j) {\n                var otherRect = hostRoot[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;\n                if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetLeft !== otherLeft || i.width !== otherRect.width || otherBottom < targetTop || otherTop > targetBottom)) {\n                    otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop);\n                    otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetTop !== otherTop || i.height !== otherRect.height || otherRight < targetLeft || otherLeft > targetRight)) {\n                    otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft);\n                    otherRight < targetRight && (otherRect.width = targetRight - otherLeft);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                }\n            }\n        }\n        return hostRoot;\n    };\n    exports.findHostInstance = function(component) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        return null === component ? null : getPublicInstance(component.stateNode);\n    };\n    exports.findHostInstanceWithNoPortals = function(fiber) {\n        fiber = findCurrentFiberUsingSlowPath(fiber);\n        fiber = null !== fiber ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;\n        return null === fiber ? null : getPublicInstance(fiber.stateNode);\n    };\n    exports.findHostInstanceWithWarning = function(component, methodName) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        if (null === component) return null;\n        if (component.mode & 8) {\n            var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n            didWarnAboutFindNodeInStrictMode[componentName] || (didWarnAboutFindNodeInStrictMode[componentName] = !0, runWithFiberInDEV(component, function() {\n                fiber.mode & 8 ? console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName) : console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName);\n            }));\n        }\n        return getPublicInstance(component.stateNode);\n    };\n    exports.flushPassiveEffects = flushPassiveEffects;\n    exports.flushSyncFromReconciler = function(fn) {\n        var prevExecutionContext = executionContext;\n        executionContext |= 1;\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            if (setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn) return fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext = prevExecutionContext, (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncWorkAcrossRoots_impl(0, !1);\n        }\n    };\n    exports.flushSyncWork = flushSyncWork;\n    exports.focusWithin = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        selectors = findPaths(hostRoot, selectors);\n        selectors = Array.from(selectors);\n        for(hostRoot = 0; hostRoot < selectors.length;){\n            var fiber = selectors[hostRoot++], tag = fiber.tag;\n            if (!isHiddenSubtree(fiber)) {\n                if ((5 === tag || 26 === tag || 27 === tag) && setFocusIfFocusable(fiber.stateNode)) return !0;\n                for(fiber = fiber.child; null !== fiber;)selectors.push(fiber), fiber = fiber.sibling;\n            }\n        }\n        return !1;\n    };\n    exports.getFindAllNodesFailureDescription = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var maxSelectorIndex = 0, matchedNames = [];\n        hostRoot = [\n            findFiberRootForHostRoot(hostRoot),\n            0\n        ];\n        for(var index = 0; index < hostRoot.length;){\n            var fiber = hostRoot[index++], tag = fiber.tag, selectorIndex = hostRoot[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                if (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length) for(fiber = fiber.child; null !== fiber;)hostRoot.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        if (maxSelectorIndex < selectors.length) {\n            for(hostRoot = []; maxSelectorIndex < selectors.length; maxSelectorIndex++)hostRoot.push(selectorToString(selectors[maxSelectorIndex]));\n            return \"findAllNodes was able to match part of the selector:\\n  \" + (matchedNames.join(\" > \") + \"\\n\\nNo matching component was found for:\\n  \") + hostRoot.join(\" > \");\n        }\n        return null;\n    };\n    exports.getPublicRootInstance = function(container) {\n        container = container.current;\n        if (!container.child) return null;\n        switch(container.child.tag){\n            case 27:\n            case 5:\n                return getPublicInstance(container.child.stateNode);\n            default:\n                return container.child.stateNode;\n        }\n    };\n    exports.injectIntoDevTools = function() {\n        var internals = {\n            bundleType: 1,\n            version: rendererVersion,\n            rendererPackageName: rendererPackageName,\n            currentDispatcherRef: ReactSharedInternals,\n            findFiberByHostInstance: getInstanceFromNode,\n            reconcilerVersion: \"19.0.0\"\n        };\n        null !== extraDevToolsConfig && (internals.rendererConfig = extraDevToolsConfig);\n        internals.overrideHookState = overrideHookState;\n        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;\n        internals.overrideProps = overrideProps;\n        internals.overridePropsDeletePath = overridePropsDeletePath;\n        internals.overridePropsRenamePath = overridePropsRenamePath;\n        internals.scheduleUpdate = scheduleUpdate;\n        internals.setErrorHandler = setErrorHandler;\n        internals.setSuspenseHandler = setSuspenseHandler;\n        internals.scheduleRefresh = scheduleRefresh;\n        internals.scheduleRoot = scheduleRoot;\n        internals.setRefreshHandler = setRefreshHandler;\n        internals.getCurrentFiber = getCurrentFiberForDevTools;\n        internals.getLaneLabelMap = getLaneLabelMap;\n        internals.injectProfilingHooks = injectProfilingHooks;\n        return injectInternals(internals);\n    };\n    exports.isAlreadyRendering = function() {\n        return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n    };\n    exports.observeVisibleRects = function(hostRoot, selectors, callback, options) {\n        function commitHook() {\n            var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n            instanceRoots.forEach(function(target) {\n                0 > nextInstanceRoots.indexOf(target) && unobserve(target);\n            });\n            nextInstanceRoots.forEach(function(target) {\n                0 > instanceRoots.indexOf(target) && observe(target);\n            });\n        }\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var instanceRoots = findAllNodes(hostRoot, selectors);\n        callback = setupIntersectionObserver(instanceRoots, callback, options);\n        var disconnect = callback.disconnect, observe = callback.observe, unobserve = callback.unobserve;\n        commitHooks.push(commitHook);\n        return {\n            disconnect: function() {\n                var index = commitHooks.indexOf(commitHook);\n                0 <= index && commitHooks.splice(index, 1);\n                disconnect();\n            }\n        };\n    };\n    exports.shouldError = function(fiber) {\n        return shouldErrorImpl(fiber);\n    };\n    exports.shouldSuspend = function(fiber) {\n        return shouldSuspendImpl(fiber);\n    };\n    exports.startHostTransition = function(formFiber, pendingState, action, formData) {\n        if (5 !== formFiber.tag) throw Error(\"Expected the form instance to be a HostComponent. This is a bug in React.\");\n        var queue = ensureFormComponentIsStateful(formFiber).queue;\n        startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop : function() {\n            null === ReactSharedInternals.T && console.error(\"requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.\");\n            var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\n            dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane(formFiber));\n            return action(formData);\n        });\n    };\n    exports.updateContainer = function(element, container, parentComponent, callback) {\n        var current = container.current, lane = requestUpdateLane(current);\n        updateContainerImpl(current, lane, element, container, parentComponent, callback);\n        return lane;\n    };\n    exports.updateContainerSync = updateContainerSync;\n    return exports;\n}, module.exports[\"default\"] = module.exports, Object.defineProperty(module.exports, \"__esModule\", {\n    value: !0\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Q0FRQyxHQUVZO0FBQ2IsS0FnQjJELElBZnhELFFBQVFDLE9BQU8sR0FBRyxTQUFVQyxTQUFTOztJQUNwQyxTQUFTQyxTQUFTQyxLQUFLLEVBQUVDLEVBQUU7UUFDekIsSUFBS0QsUUFBUUEsTUFBTUUsYUFBYSxFQUFFLFNBQVNGLFNBQVMsSUFBSUMsSUFDdEQsUUFBU0QsTUFBTUcsSUFBSSxFQUFHRjtRQUN4QixPQUFPRDtJQUNUO0lBQ0EsU0FBU0ksZ0JBQWdCQyxHQUFHLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxLQUFLO1FBQzlDLElBQUlELFNBQVNELEtBQUtHLE1BQU0sRUFBRSxPQUFPRDtRQUNqQyxJQUFJRSxNQUFNSixJQUFJLENBQUNDLE1BQU0sRUFDbkJJLFVBQVVDLFlBQVlQLE9BQU9BLElBQUlRLEtBQUssS0FBS0MsT0FBTyxDQUFDLEdBQUdUO1FBQ3hETSxPQUFPLENBQUNELElBQUksR0FBR04sZ0JBQWdCQyxHQUFHLENBQUNLLElBQUksRUFBRUosTUFBTUMsUUFBUSxHQUFHQztRQUMxRCxPQUFPRztJQUNUO0lBQ0EsU0FBU0ksZUFBZVYsR0FBRyxFQUFFVyxPQUFPLEVBQUVDLE9BQU87UUFDM0MsSUFBSUQsUUFBUVAsTUFBTSxLQUFLUSxRQUFRUixNQUFNLEVBQ25DUyxRQUFRQyxJQUFJLENBQUM7YUFDVjtZQUNILElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxRQUFRUixNQUFNLEdBQUcsR0FBR1csSUFDdEMsSUFBSUosT0FBTyxDQUFDSSxFQUFFLEtBQUtILE9BQU8sQ0FBQ0csRUFBRSxFQUFFO2dCQUM3QkYsUUFBUUMsSUFBSSxDQUNWO2dCQUVGO1lBQ0Y7WUFDRixPQUFPRSxtQkFBbUJoQixLQUFLVyxTQUFTQyxTQUFTO1FB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OTdDO1FBRUYsT0FBT3dDO0lBQ1Q7SUFDQWhOLFFBQVF3QyxtQkFBbUIsR0FBR0E7SUFDOUIsT0FBT3hDO0FBQ1QsR0FDQ0QseUJBQXNCLEdBQUdBLE9BQU9DLE9BQU8sRUFDeENnSCxPQUFPeUIsY0FBYyxDQUFDMUksT0FBT0MsT0FBTyxFQUFFLGNBQWM7SUFBRVcsT0FBTyxDQUFDO0FBQUUsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKChtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkJCRjb25maWcpIHtcbiAgICBmdW5jdGlvbiBmaW5kSG9vayhmaWJlciwgaWQpIHtcbiAgICAgIGZvciAoZmliZXIgPSBmaWJlci5tZW1vaXplZFN0YXRlOyBudWxsICE9PSBmaWJlciAmJiAwIDwgaWQ7IClcbiAgICAgICAgKGZpYmVyID0gZmliZXIubmV4dCksIGlkLS07XG4gICAgICByZXR1cm4gZmliZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKGluZGV4ID49IHBhdGgubGVuZ3RoKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpbmRleF0sXG4gICAgICAgIHVwZGF0ZWQgPSBpc0FycmF5SW1wbChvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG4gICAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aFNldEltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoUmVuYW1lKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgaWYgKG9sZFBhdGgubGVuZ3RoICE9PSBuZXdQYXRoLmxlbmd0aClcbiAgICAgICAgY29uc29sZS53YXJuKFwiY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIG9mIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BhdGgubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoUmVuYW1lSW1wbChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4KSB7XG4gICAgICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF0sXG4gICAgICAgIHVwZGF0ZWQgPSBpc0FycmF5SW1wbChvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG4gICAgICBpbmRleCArIDEgPT09IG9sZFBhdGgubGVuZ3RoXG4gICAgICAgID8gKCh1cGRhdGVkW25ld1BhdGhbaW5kZXhdXSA9IHVwZGF0ZWRbb2xkS2V5XSksXG4gICAgICAgICAgaXNBcnJheUltcGwodXBkYXRlZClcbiAgICAgICAgICAgID8gdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKVxuICAgICAgICAgICAgOiBkZWxldGUgdXBkYXRlZFtvbGRLZXldKVxuICAgICAgICA6ICh1cGRhdGVkW29sZEtleV0gPSBjb3B5V2l0aFJlbmFtZUltcGwoXG4gICAgICAgICAgICBvYmpbb2xkS2V5XSxcbiAgICAgICAgICAgIG9sZFBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoLFxuICAgICAgICAgICAgaW5kZXggKyAxXG4gICAgICAgICAgKSk7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVdpdGhEZWxldGVJbXBsKG9iaiwgcGF0aCwgaW5kZXgpIHtcbiAgICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XSxcbiAgICAgICAgdXBkYXRlZCA9IGlzQXJyYXlJbXBsKG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTtcbiAgICAgIGlmIChpbmRleCArIDEgPT09IHBhdGgubGVuZ3RoKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGlzQXJyYXlJbXBsKHVwZGF0ZWQpID8gdXBkYXRlZC5zcGxpY2Uoa2V5LCAxKSA6IGRlbGV0ZSB1cGRhdGVkW2tleV0sXG4gICAgICAgICAgdXBkYXRlZFxuICAgICAgICApO1xuICAgICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhEZWxldGVJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFN1c3BlbmRJbXBsKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRFcnJvckltcGwoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXIodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAgICAgcmV0dXJuIG5ldyBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUm9vdChyb290LCBlbGVtZW50KSB7XG4gICAgICByb290LmNvbnRleHQgPT09IGVtcHR5Q29udGV4dE9iamVjdCAmJlxuICAgICAgICAodXBkYXRlQ29udGFpbmVyU3luYyhlbGVtZW50LCByb290LCBudWxsLCBudWxsKSwgZmx1c2hTeW5jV29yaygpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZWZyZXNoKHJvb3QsIHVwZGF0ZSkge1xuICAgICAgaWYgKG51bGwgIT09IHJlc29sdmVGYW1pbHkpIHtcbiAgICAgICAgdmFyIHN0YWxlRmFtaWxpZXMgPSB1cGRhdGUuc3RhbGVGYW1pbGllcztcbiAgICAgICAgdXBkYXRlID0gdXBkYXRlLnVwZGF0ZWRGYW1pbGllcztcbiAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgICAgIHJvb3QuY3VycmVudCxcbiAgICAgICAgICB1cGRhdGUsXG4gICAgICAgICAgc3RhbGVGYW1pbGllc1xuICAgICAgICApO1xuICAgICAgICBmbHVzaFN5bmNXb3JrKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFJlZnJlc2hIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgIHJlc29sdmVGYW1pbHkgPSBoYW5kbGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIkRvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcnVsZXMtb2YtaG9va3NcIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiBJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gICAgZnVuY3Rpb24gd2FybkZvck1pc3NpbmdLZXkoKSB7fVxuICAgIGZ1bmN0aW9uIHNldFRvU29ydGVkU3RyaW5nKHNldCkge1xuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhcnJheS5zb3J0KCkuam9pbihcIiwgXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICAgIGlmIChudWxsID09PSBtYXliZUl0ZXJhYmxlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIG1heWJlSXRlcmFibGUgPVxuICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgbWF5YmVJdGVyYWJsZVtcIkBAaXRlcmF0b3JcIl07XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSA/IG1heWJlSXRlcmFibGUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikge1xuICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gXCJDYWNoZVwiO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgcmV0dXJuIFwiRGVoeWRyYXRlZEZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaWJlciA9IHR5cGUucmVuZGVyKSxcbiAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lIHx8XG4gICAgICAgICAgICAgIChcIlwiICE9PSBmaWJlciA/IFwiRm9yd2FyZFJlZihcIiArIGZpYmVyICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gXCJSb290XCI7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gXCJUZXh0XCI7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID8gXCJTdHJpY3RNb2RlXCIgOiBcIk1vZGVcIjtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZXR1cm4gXCJPZmZzY3JlZW5cIjtcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIHJldHVybiBcIlNjb3BlXCI7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICByZXR1cm4gXCJUcmFjaW5nTWFya2VyXCI7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICB0eXBlID0gZmliZXIuX2RlYnVnSW5mbztcbiAgICAgICAgICBpZiAobnVsbCAhPSB0eXBlKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHR5cGUubGVuZ3RoIC0gMTsgMCA8PSBpOyBpLS0pXG4gICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZVtpXS5uYW1lKSByZXR1cm4gdHlwZVtpXS5uYW1lO1xuICAgICAgICAgIGlmIChudWxsICE9PSBmaWJlci5yZXR1cm4pXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlci5yZXR1cm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cbiAgICBmdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc2FibGVkRGVwdGgrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICAgICAgZGlzYWJsZWREZXB0aC0tO1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgdmFyIHByb3BzID0geyBjb25maWd1cmFibGU6ICEwLCBlbnVtZXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZMb2cgfSksXG4gICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkluZm8gfSksXG4gICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldldhcm4gfSksXG4gICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZFcnJvciB9KSxcbiAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwIH0pLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWQgfSksXG4gICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cEVuZCB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIDAgPiBkaXNhYmxlZERlcHRoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgIHByZWZpeCA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgXCJcIjtcbiAgICAgICAgICBzdWZmaXggPVxuICAgICAgICAgICAgLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJcXG4gICAgYXRcIilcbiAgICAgICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgICAgICA/IFwiQHVua25vd246MDowXCJcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlxcblwiICsgcHJlZml4ICsgbmFtZSArIHN1ZmZpeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gICAgICBpZiAoIWZuIHx8IHJlZW50cnkpIHJldHVybiBcIlwiO1xuICAgICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICAgIHJlZW50cnkgPSAhMDtcbiAgICAgIGZyYW1lID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBudWxsO1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICAgICAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0geDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQxKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sID0geCQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoRmFrZSA9IGZuKCkpICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBGYWtlLmNhdGNoICYmXG4gICAgICAgICAgICAgICAgICBGYWtlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2FtcGxlLnN0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPVxuICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCI7XG4gICAgICAgIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICBcIm5hbWVcIlxuICAgICAgICApO1xuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICB7IHZhbHVlOiBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiIH1cbiAgICAgICAgICApO1xuICAgICAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID1cbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcbiAgICAgICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBuYW1lUHJvcERlc2NyaXB0b3IgPSAwO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvcisrO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPCBjb250cm9sTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIrKztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID09PSBjb250cm9sTGluZXMubGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgJiZcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXTtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXI7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3ItLSwgX1J1bkluUm9vdEZyYW1lJERldGVyLS1cbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IG5hbWVQcm9wRGVzY3JpcHRvciB8fCAxICE9PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpIHtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAobmFtZVByb3BEZXNjcmlwdG9yLS0sXG4gICAgICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tLFxuICAgICAgICAgICAgICAgICAgICAwID4gX1J1bkluUm9vdEZyYW1lJERldGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0ucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IG5ldyBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IFwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZm4uZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChfZnJhbWUgPSBfZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKHJlZW50cnkgPSAhMSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2aW91c0Rpc3BhdGNoZXIpLFxuICAgICAgICAgIHJlZW5hYmxlTG9ncygpLFxuICAgICAgICAgIChFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZyYW1lKTtcbiAgICAgIH1cbiAgICAgIHNhbXBsZUxpbmVzID0gKHNhbXBsZUxpbmVzID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIilcbiAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShzYW1wbGVMaW5lcylcbiAgICAgICAgOiBcIlwiO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiYgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHNhbXBsZUxpbmVzKTtcbiAgICAgIHJldHVybiBzYW1wbGVMaW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJMYXp5XCIpO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJldHVybiAoZmliZXIgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUsICExKSksIGZpYmVyO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZmliZXIgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyLCAhMSkpLCBmaWJlclxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLCAhMCkpLCBmaWJlcjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBkZWJ1Z0luZm8gPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJbmZvO1xuICAgICAgICAgIGlmIChkZWJ1Z0luZm8pXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGVidWdJbmZvLmxlbmd0aCAtIDE7IDAgPD0gaTsgaS0tKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IGRlYnVnSW5mb1tpXTtcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBlbnRyeS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IGluZm8sXG4gICAgICAgICAgICAgICAgICBlbnYgPSBlbnRyeS5lbnY7XG4gICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgICAgICAgICAgZW50cnkubmFtZSArIChlbnYgPyBcIiBbXCIgKyBlbnYgKyBcIl1cIiA6IFwiXCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpbmZvID0gSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIlxcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6IFwiICsgeC5tZXNzYWdlICsgXCJcXG5cIiArIHguc3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKSB7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gY3VycmVudCA/IFwiXCIgOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoY3VycmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBjYWxsYmFjaywgYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID1cbiAgICAgICAgbnVsbCA9PT0gZmliZXIgPyBudWxsIDogZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldjtcbiAgICAgIGlzUmVuZGVyaW5nID0gITE7XG4gICAgICBjdXJyZW50ID0gZmliZXI7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50ID0gcHJldmlvdXNGaWJlcjtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcInJ1bldpdGhGaWJlckluREVWIHNob3VsZCBuZXZlciBiZSBjYWxsZWQgaW4gcHJvZHVjdGlvbi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikge1xuICAgICAgdmFyIG5vZGUgPSBmaWJlcixcbiAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBmaWJlcjtcbiAgICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIGZvciAoOyBub2RlLnJldHVybjsgKSBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmliZXIgPSBub2RlO1xuICAgICAgICBkb1xuICAgICAgICAgIChub2RlID0gZmliZXIpLFxuICAgICAgICAgICAgMCAhPT0gKG5vZGUuZmxhZ3MgJiA0MDk4KSAmJiAobmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybiksXG4gICAgICAgICAgICAoZmliZXIgPSBub2RlLnJldHVybik7XG4gICAgICAgIHdoaWxlIChmaWJlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gMyA9PT0gbm9kZS50YWcgPyBuZWFyZXN0TW91bnRlZCA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAgICAgaWYgKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpICE9PSBmaWJlcilcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgICAgIGFsdGVybmF0ZSA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpO1xuICAgICAgICBpZiAobnVsbCA9PT0gYWx0ZXJuYXRlKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgcmV0dXJuIGFsdGVybmF0ZSAhPT0gZmliZXIgPyBudWxsIDogZmliZXI7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBhID0gZmliZXIsIGIgPSBhbHRlcm5hdGU7IDsgKSB7XG4gICAgICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG4gICAgICAgIGlmIChudWxsID09PSBwYXJlbnRBKSBicmVhaztcbiAgICAgICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKG51bGwgPT09IHBhcmVudEIpIHtcbiAgICAgICAgICBiID0gcGFyZW50QS5yZXR1cm47XG4gICAgICAgICAgaWYgKG51bGwgIT09IGIpIHtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICAgICAgZm9yIChwYXJlbnRCID0gcGFyZW50QS5jaGlsZDsgcGFyZW50QjsgKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50QiA9PT0gYSkgcmV0dXJuIGFzc2VydElzTW91bnRlZChwYXJlbnRBKSwgZmliZXI7XG4gICAgICAgICAgICBpZiAocGFyZW50QiA9PT0gYikgcmV0dXJuIGFzc2VydElzTW91bnRlZChwYXJlbnRBKSwgYWx0ZXJuYXRlO1xuICAgICAgICAgICAgcGFyZW50QiA9IHBhcmVudEIuc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIChhID0gcGFyZW50QSksIChiID0gcGFyZW50Qik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGRpZEZpbmRDaGlsZCA9ICExLCBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkOyBfY2hpbGQ7ICkge1xuICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICAgIGZvciAoX2NoaWxkID0gcGFyZW50Qi5jaGlsZDsgX2NoaWxkOyApIHtcbiAgICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGlkRmluZENoaWxkKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5hbHRlcm5hdGUgIT09IGIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoMyAhPT0gYS50YWcpXG4gICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgIHJldHVybiBhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhID8gZmliZXIgOiBhbHRlcm5hdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgICAgIHJldHVybiBudWxsICE9PSBwYXJlbnQgPyBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwocGFyZW50KSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChub2RlKSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZyB8fCA2ID09PSB0YWcpIHJldHVybiBub2RlO1xuICAgICAgZm9yIChub2RlID0gbm9kZS5jaGlsZDsgbnVsbCAhPT0gbm9kZTsgKSB7XG4gICAgICAgIHRhZyA9IGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChub2RlKTtcbiAgICAgICAgaWYgKG51bGwgIT09IHRhZykgcmV0dXJuIHRhZztcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpIHtcbiAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgIGlmICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnIHx8IDYgPT09IHRhZykgcmV0dXJuIG5vZGU7XG4gICAgICBmb3IgKG5vZGUgPSBub2RlLmNoaWxkOyBudWxsICE9PSBub2RlOyApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDQgIT09IG5vZGUudGFnICYmXG4gICAgICAgICAgKCh0YWcgPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpKSwgbnVsbCAhPT0gdGFnKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4geyBjdXJyZW50OiBkZWZhdWx0VmFsdWUgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgICAgIDAgPiBpbmRleCRqc2NvbXAkMFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIHBvcC5cIilcbiAgICAgICAgOiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXgkanNjb21wJDBdICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuXCIpLFxuICAgICAgICAgIChjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXgkanNjb21wJDBdKSxcbiAgICAgICAgICAodmFsdWVTdGFja1tpbmRleCRqc2NvbXAkMF0gPSBudWxsKSxcbiAgICAgICAgICAoZmliZXJTdGFja1tpbmRleCRqc2NvbXAkMF0gPSBudWxsKSxcbiAgICAgICAgICBpbmRleCRqc2NvbXAkMC0tKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICAgICAgaW5kZXgkanNjb21wJDArKztcbiAgICAgIHZhbHVlU3RhY2tbaW5kZXgkanNjb21wJDBdID0gY3Vyc29yLmN1cnJlbnQ7XG4gICAgICBmaWJlclN0YWNrW2luZGV4JGpzY29tcCQwXSA9IGZpYmVyO1xuICAgICAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2x6MzJGYWxsYmFjayh4KSB7XG4gICAgICB4ID4+Pj0gMDtcbiAgICAgIHJldHVybiAwID09PSB4ID8gMzIgOiAoMzEgLSAoKGxvZyQxKHgpIC8gTE4yKSB8IDApKSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExhYmVsRm9yTGFuZShsYW5lKSB7XG4gICAgICBpZiAobGFuZSAmIDEpIHJldHVybiBcIlN5bmNIeWRyYXRpb25MYW5lXCI7XG4gICAgICBpZiAobGFuZSAmIDIpIHJldHVybiBcIlN5bmNcIjtcbiAgICAgIGlmIChsYW5lICYgNCkgcmV0dXJuIFwiSW5wdXRDb250aW51b3VzSHlkcmF0aW9uXCI7XG4gICAgICBpZiAobGFuZSAmIDgpIHJldHVybiBcIklucHV0Q29udGludW91c1wiO1xuICAgICAgaWYgKGxhbmUgJiAxNikgcmV0dXJuIFwiRGVmYXVsdEh5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiAzMikgcmV0dXJuIFwiRGVmYXVsdFwiO1xuICAgICAgaWYgKGxhbmUgJiA2NCkgcmV0dXJuIFwiVHJhbnNpdGlvbkh5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiA0MTk0MTc2KSByZXR1cm4gXCJUcmFuc2l0aW9uXCI7XG4gICAgICBpZiAobGFuZSAmIDYyOTE0NTYwKSByZXR1cm4gXCJSZXRyeVwiO1xuICAgICAgaWYgKGxhbmUgJiA2NzEwODg2NCkgcmV0dXJuIFwiU2VsZWN0aXZlSHlkcmF0aW9uXCI7XG4gICAgICBpZiAobGFuZSAmIDEzNDIxNzcyOCkgcmV0dXJuIFwiSWRsZUh5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiAyNjg0MzU0NTYpIHJldHVybiBcIklkbGVcIjtcbiAgICAgIGlmIChsYW5lICYgNTM2ODcwOTEyKSByZXR1cm4gXCJPZmZzY3JlZW5cIjtcbiAgICAgIGlmIChsYW5lICYgMTA3Mzc0MTgyNCkgcmV0dXJuIFwiRGVmZXJyZWRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobGFuZXMpIHtcbiAgICAgIHZhciBwZW5kaW5nU3luY0xhbmVzID0gbGFuZXMgJiA0MjtcbiAgICAgIGlmICgwICE9PSBwZW5kaW5nU3luY0xhbmVzKSByZXR1cm4gcGVuZGluZ1N5bmNMYW5lcztcbiAgICAgIHN3aXRjaCAobGFuZXMgJiAtbGFuZXMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJldHVybiAxNjtcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgcmV0dXJuIDY0O1xuICAgICAgICBjYXNlIDEyODpcbiAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgIGNhc2UgNTEyOlxuICAgICAgICBjYXNlIDEwMjQ6XG4gICAgICAgIGNhc2UgMjA0ODpcbiAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICBjYXNlIDgxOTI6XG4gICAgICAgIGNhc2UgMTYzODQ6XG4gICAgICAgIGNhc2UgMzI3Njg6XG4gICAgICAgIGNhc2UgNjU1MzY6XG4gICAgICAgIGNhc2UgMTMxMDcyOlxuICAgICAgICBjYXNlIDI2MjE0NDpcbiAgICAgICAgY2FzZSA1MjQyODg6XG4gICAgICAgIGNhc2UgMTA0ODU3NjpcbiAgICAgICAgY2FzZSAyMDk3MTUyOlxuICAgICAgICAgIHJldHVybiBsYW5lcyAmIDQxOTQxNzY7XG4gICAgICAgIGNhc2UgNDE5NDMwNDpcbiAgICAgICAgY2FzZSA4Mzg4NjA4OlxuICAgICAgICBjYXNlIDE2Nzc3MjE2OlxuICAgICAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgICAgIHJldHVybiBsYW5lcyAmIDYyOTE0NTYwO1xuICAgICAgICBjYXNlIDY3MTA4ODY0OlxuICAgICAgICAgIHJldHVybiA2NzEwODg2NDtcbiAgICAgICAgY2FzZSAxMzQyMTc3Mjg6XG4gICAgICAgICAgcmV0dXJuIDEzNDIxNzcyODtcbiAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgICAgcmV0dXJuIDI2ODQzNTQ1NjtcbiAgICAgICAgY2FzZSA1MzY4NzA5MTI6XG4gICAgICAgICAgcmV0dXJuIDUzNjg3MDkxMjtcbiAgICAgICAgY2FzZSAxMDczNzQxODI0OlxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlNob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcbiAgICAgIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIGlmICgwID09PSBwZW5kaW5nTGFuZXMpIHJldHVybiAwO1xuICAgICAgdmFyIG5leHRMYW5lcyA9IDAsXG4gICAgICAgIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcyxcbiAgICAgICAgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzLFxuICAgICAgICB3YXJtTGFuZXMgPSByb290Lndhcm1MYW5lcztcbiAgICAgIHJvb3QgPSAwICE9PSByb290LmZpbmlzaGVkTGFuZXM7XG4gICAgICB2YXIgbm9uSWRsZVBlbmRpbmdMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIDEzNDIxNzcyNztcbiAgICAgIDAgIT09IG5vbklkbGVQZW5kaW5nTGFuZXNcbiAgICAgICAgPyAoKHBlbmRpbmdMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXMpLFxuICAgICAgICAgIDAgIT09IHBlbmRpbmdMYW5lc1xuICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGVuZGluZ0xhbmVzKSlcbiAgICAgICAgICAgIDogKChwaW5nZWRMYW5lcyAmPSBub25JZGxlUGVuZGluZ0xhbmVzKSxcbiAgICAgICAgICAgICAgMCAhPT0gcGluZ2VkTGFuZXNcbiAgICAgICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhwaW5nZWRMYW5lcykpXG4gICAgICAgICAgICAgICAgOiByb290IHx8XG4gICAgICAgICAgICAgICAgICAoKHdhcm1MYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiB+d2FybUxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIDAgIT09IHdhcm1MYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMod2FybUxhbmVzKSkpKSlcbiAgICAgICAgOiAoKG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXMpLFxuICAgICAgICAgIDAgIT09IG5vbklkbGVQZW5kaW5nTGFuZXNcbiAgICAgICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVQZW5kaW5nTGFuZXMpKVxuICAgICAgICAgICAgOiAwICE9PSBwaW5nZWRMYW5lc1xuICAgICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhwaW5nZWRMYW5lcykpXG4gICAgICAgICAgICAgIDogcm9vdCB8fFxuICAgICAgICAgICAgICAgICgod2FybUxhbmVzID0gcGVuZGluZ0xhbmVzICYgfndhcm1MYW5lcyksXG4gICAgICAgICAgICAgICAgMCAhPT0gd2FybUxhbmVzICYmXG4gICAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMod2FybUxhbmVzKSkpKTtcbiAgICAgIHJldHVybiAwID09PSBuZXh0TGFuZXNcbiAgICAgICAgPyAwXG4gICAgICAgIDogMCAhPT0gd2lwTGFuZXMgJiZcbiAgICAgICAgICAgIHdpcExhbmVzICE9PSBuZXh0TGFuZXMgJiZcbiAgICAgICAgICAgIDAgPT09ICh3aXBMYW5lcyAmIHN1c3BlbmRlZExhbmVzKSAmJlxuICAgICAgICAgICAgKChzdXNwZW5kZWRMYW5lcyA9IG5leHRMYW5lcyAmIC1uZXh0TGFuZXMpLFxuICAgICAgICAgICAgKHdhcm1MYW5lcyA9IHdpcExhbmVzICYgLXdpcExhbmVzKSxcbiAgICAgICAgICAgIHN1c3BlbmRlZExhbmVzID49IHdhcm1MYW5lcyB8fFxuICAgICAgICAgICAgICAoMzIgPT09IHN1c3BlbmRlZExhbmVzICYmIDAgIT09ICh3YXJtTGFuZXMgJiA0MTk0MTc2KSkpXG4gICAgICAgICAgPyB3aXBMYW5lc1xuICAgICAgICAgIDogbmV4dExhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIHJlbmRlckxhbmVzKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAwID09PVxuICAgICAgICAocm9vdC5wZW5kaW5nTGFuZXMgJlxuICAgICAgICAgIH4ocm9vdC5zdXNwZW5kZWRMYW5lcyAmIH5yb290LnBpbmdlZExhbmVzKSAmXG4gICAgICAgICAgcmVuZGVyTGFuZXMpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpIHtcbiAgICAgIHN3aXRjaCAobGFuZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgMjUwO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDMyOlxuICAgICAgICBjYXNlIDY0OlxuICAgICAgICBjYXNlIDEyODpcbiAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgIGNhc2UgNTEyOlxuICAgICAgICBjYXNlIDEwMjQ6XG4gICAgICAgIGNhc2UgMjA0ODpcbiAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICBjYXNlIDgxOTI6XG4gICAgICAgIGNhc2UgMTYzODQ6XG4gICAgICAgIGNhc2UgMzI3Njg6XG4gICAgICAgIGNhc2UgNjU1MzY6XG4gICAgICAgIGNhc2UgMTMxMDcyOlxuICAgICAgICBjYXNlIDI2MjE0NDpcbiAgICAgICAgY2FzZSA1MjQyODg6XG4gICAgICAgIGNhc2UgMTA0ODU3NjpcbiAgICAgICAgY2FzZSAyMDk3MTUyOlxuICAgICAgICAgIHJldHVybiBjdXJyZW50VGltZSArIDVlMztcbiAgICAgICAgY2FzZSA0MTk0MzA0OlxuICAgICAgICBjYXNlIDgzODg2MDg6XG4gICAgICAgIGNhc2UgMTY3NzcyMTY6XG4gICAgICAgIGNhc2UgMzM1NTQ0MzI6XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBjYXNlIDY3MTA4ODY0OlxuICAgICAgICBjYXNlIDEzNDIxNzcyODpcbiAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgIGNhc2UgNTM2ODcwOTEyOlxuICAgICAgICBjYXNlIDEwNzM3NDE4MjQ6XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlNob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLTFcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpIHtcbiAgICAgIHZhciBsYW5lID0gbmV4dFRyYW5zaXRpb25MYW5lO1xuICAgICAgbmV4dFRyYW5zaXRpb25MYW5lIDw8PSAxO1xuICAgICAgMCA9PT0gKG5leHRUcmFuc2l0aW9uTGFuZSAmIDQxOTQxNzYpICYmIChuZXh0VHJhbnNpdGlvbkxhbmUgPSAxMjgpO1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsYWltTmV4dFJldHJ5TGFuZSgpIHtcbiAgICAgIHZhciBsYW5lID0gbmV4dFJldHJ5TGFuZTtcbiAgICAgIG5leHRSZXRyeUxhbmUgPDw9IDE7XG4gICAgICAwID09PSAobmV4dFJldHJ5TGFuZSAmIDYyOTE0NTYwKSAmJiAobmV4dFJldHJ5TGFuZSA9IDQxOTQzMDQpO1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxhbmVNYXAoaW5pdGlhbCkge1xuICAgICAgZm9yICh2YXIgbGFuZU1hcCA9IFtdLCBpID0gMDsgMzEgPiBpOyBpKyspIGxhbmVNYXAucHVzaChpbml0aWFsKTtcbiAgICAgIHJldHVybiBsYW5lTWFwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdFVwZGF0ZWQkMShyb290LCB1cGRhdGVMYW5lKSB7XG4gICAgICByb290LnBlbmRpbmdMYW5lcyB8PSB1cGRhdGVMYW5lO1xuICAgICAgMjY4NDM1NDU2ICE9PSB1cGRhdGVMYW5lICYmXG4gICAgICAgICgocm9vdC5zdXNwZW5kZWRMYW5lcyA9IDApLFxuICAgICAgICAocm9vdC5waW5nZWRMYW5lcyA9IDApLFxuICAgICAgICAocm9vdC53YXJtTGFuZXMgPSAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSb290RmluaXNoZWQoXG4gICAgICByb290LFxuICAgICAgZmluaXNoZWRMYW5lcyxcbiAgICAgIHJlbWFpbmluZ0xhbmVzLFxuICAgICAgc3Bhd25lZExhbmUsXG4gICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4gICAgKSB7XG4gICAgICB2YXIgcHJldmlvdXNseVBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgcm9vdC5wZW5kaW5nTGFuZXMgPSByZW1haW5pbmdMYW5lcztcbiAgICAgIHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwO1xuICAgICAgcm9vdC5waW5nZWRMYW5lcyA9IDA7XG4gICAgICByb290Lndhcm1MYW5lcyA9IDA7XG4gICAgICByb290LmV4cGlyZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgICAgIHJvb3QuZW50YW5nbGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICAgICAgcm9vdC5zaGVsbFN1c3BlbmRDb3VudGVyID0gMDtcbiAgICAgIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzLFxuICAgICAgICBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lcyxcbiAgICAgICAgaGlkZGVuVXBkYXRlcyA9IHJvb3QuaGlkZGVuVXBkYXRlcztcbiAgICAgIGZvciAoXG4gICAgICAgIHJlbWFpbmluZ0xhbmVzID0gcHJldmlvdXNseVBlbmRpbmdMYW5lcyAmIH5yZW1haW5pbmdMYW5lcztcbiAgICAgICAgMCA8IHJlbWFpbmluZ0xhbmVzO1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihyZW1haW5pbmdMYW5lcyksXG4gICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdID0gMDtcbiAgICAgICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IC0xO1xuICAgICAgICB2YXIgaGlkZGVuVXBkYXRlc0ZvckxhbmUgPSBoaWRkZW5VcGRhdGVzW2luZGV4XTtcbiAgICAgICAgaWYgKG51bGwgIT09IGhpZGRlblVwZGF0ZXNGb3JMYW5lKVxuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBoaWRkZW5VcGRhdGVzW2luZGV4XSA9IG51bGwsIGluZGV4ID0gMDtcbiAgICAgICAgICAgIGluZGV4IDwgaGlkZGVuVXBkYXRlc0ZvckxhbmUubGVuZ3RoO1xuICAgICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGhpZGRlblVwZGF0ZXNGb3JMYW5lW2luZGV4XTtcbiAgICAgICAgICAgIG51bGwgIT09IHVwZGF0ZSAmJiAodXBkYXRlLmxhbmUgJj0gLTUzNjg3MDkxMyk7XG4gICAgICAgICAgfVxuICAgICAgICByZW1haW5pbmdMYW5lcyAmPSB+bGFuZTtcbiAgICAgIH1cbiAgICAgIDAgIT09IHNwYXduZWRMYW5lICYmIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCAwKTtcbiAgICAgIDAgIT09IHN1c3BlbmRlZFJldHJ5TGFuZXMgJiZcbiAgICAgICAgMCA9PT0gdXBkYXRlZExhbmVzICYmXG4gICAgICAgIDAgIT09IHJvb3QudGFnICYmXG4gICAgICAgIChyb290LnN1c3BlbmRlZExhbmVzIHw9XG4gICAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyAmIH4ocHJldmlvdXNseVBlbmRpbmdMYW5lcyAmIH5maW5pc2hlZExhbmVzKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCBlbnRhbmdsZWRMYW5lcykge1xuICAgICAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gc3Bhd25lZExhbmU7XG4gICAgICByb290LnN1c3BlbmRlZExhbmVzICY9IH5zcGF3bmVkTGFuZTtcbiAgICAgIHZhciBzcGF3bmVkTGFuZUluZGV4ID0gMzEgLSBjbHozMihzcGF3bmVkTGFuZSk7XG4gICAgICByb290LmVudGFuZ2xlZExhbmVzIHw9IHNwYXduZWRMYW5lO1xuICAgICAgcm9vdC5lbnRhbmdsZW1lbnRzW3NwYXduZWRMYW5lSW5kZXhdID1cbiAgICAgICAgcm9vdC5lbnRhbmdsZW1lbnRzW3NwYXduZWRMYW5lSW5kZXhdIHxcbiAgICAgICAgMTA3Mzc0MTgyNCB8XG4gICAgICAgIChlbnRhbmdsZWRMYW5lcyAmIDQxOTQyMTgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBlbnRhbmdsZWRMYW5lcykge1xuICAgICAgdmFyIHJvb3RFbnRhbmdsZWRMYW5lcyA9IChyb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzKTtcbiAgICAgIGZvciAocm9vdCA9IHJvb3QuZW50YW5nbGVtZW50czsgcm9vdEVudGFuZ2xlZExhbmVzOyApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihyb290RW50YW5nbGVkTGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICAobGFuZSAmIGVudGFuZ2xlZExhbmVzKSB8IChyb290W2luZGV4XSAmIGVudGFuZ2xlZExhbmVzKSAmJlxuICAgICAgICAgIChyb290W2luZGV4XSB8PSBlbnRhbmdsZWRMYW5lcyk7XG4gICAgICAgIHJvb3RFbnRhbmdsZWRMYW5lcyAmPSB+bGFuZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIGZpYmVyLCBsYW5lcykge1xuICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KVxuICAgICAgICBmb3IgKHJvb3QgPSByb290LnBlbmRpbmdVcGRhdGVyc0xhbmVNYXA7IDAgPCBsYW5lczsgKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihsYW5lcyksXG4gICAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgICByb290W2luZGV4XS5hZGQoZmliZXIpO1xuICAgICAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcykge1xuICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwLFxuICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcbiAgICAgICAgICAwIDwgbGFuZXM7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihsYW5lcyk7XG4gICAgICAgICAgcm9vdCA9IDEgPDwgaW5kZXg7XG4gICAgICAgICAgaW5kZXggPSBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwW2luZGV4XTtcbiAgICAgICAgICAwIDwgaW5kZXguc2l6ZSAmJlxuICAgICAgICAgICAgKGluZGV4LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgICAgICAgIChudWxsICE9PSBhbHRlcm5hdGUgJiYgbWVtb2l6ZWRVcGRhdGVycy5oYXMoYWx0ZXJuYXRlKSkgfHxcbiAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmFkZChmaWJlcik7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZGV4LmNsZWFyKCkpO1xuICAgICAgICAgIGxhbmVzICY9IH5yb290O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhbmVzVG9FdmVudFByaW9yaXR5KGxhbmVzKSB7XG4gICAgICBsYW5lcyAmPSAtbGFuZXM7XG4gICAgICByZXR1cm4gMiA8IGxhbmVzXG4gICAgICAgID8gOCA8IGxhbmVzXG4gICAgICAgICAgPyAwICE9PSAobGFuZXMgJiAxMzQyMTc3MjcpXG4gICAgICAgICAgICA/IDMyXG4gICAgICAgICAgICA6IDI2ODQzNTQ1NlxuICAgICAgICAgIDogOFxuICAgICAgICA6IDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKSByZXR1cm4gITE7XG4gICAgICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgICAgIGlmIChob29rLmlzRGlzYWJsZWQpIHJldHVybiAhMDtcbiAgICAgIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrIHdpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9yZWFjdC1kZXZ0b29sc1wiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAhMFxuICAgICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgKHJlbmRlcmVySUQgPSBob29rLmluamVjdChpbnRlcm5hbHMpKSwgKGluamVjdGVkSG9vayA9IGhvb2spO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLlwiLCBlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhvb2suY2hlY2tEQ0UgPyAhMCA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkNvbW1pdFJvb3QkMShyb290LCBldmVudFByaW9yaXR5KSB7XG4gICAgICBpZiAoaW5qZWN0ZWRIb29rICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgZGlkRXJyb3IgPSAxMjggPT09IChyb290LmN1cnJlbnQuZmxhZ3MgJiAxMjgpO1xuICAgICAgICAgIHN3aXRjaCAoZXZlbnRQcmlvcml0eSkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChcbiAgICAgICAgICAgIHJlbmRlcmVySUQsXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHksXG4gICAgICAgICAgICBkaWRFcnJvclxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMobmV3SXNTdHJpY3RNb2RlKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsb2cgJiZcbiAgICAgICAgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUobmV3SXNTdHJpY3RNb2RlKTtcbiAgICAgIGlmIChpbmplY3RlZEhvb2sgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUocmVuZGVyZXJJRCwgbmV3SXNTdHJpY3RNb2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXNcIixcbiAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbmplY3RQcm9maWxpbmdIb29rcyhwcm9maWxpbmdIb29rcykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcyA9IHByb2ZpbGluZ0hvb2tzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrQ29tbWl0U3RvcHBlZCgpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RvcHBlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKGZpYmVyKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0YXJ0ZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZW5kZXJTdG9wcGVkKCkge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0b3BwZWQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgICAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlKSB7XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmIG51bGwgIT09IHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IENhcHR1cmVkU3RhY2tzLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmICh2b2lkIDAgIT09IGV4aXN0aW5nKSByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpXG4gICAgICAgIH07XG4gICAgICAgIENhcHR1cmVkU3RhY2tzLnNldCh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuKSB7XG4gICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgICAgIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrQ291bnQ7XG4gICAgICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXgrK10gPSB0cmVlRm9ya1Byb3ZpZGVyO1xuICAgICAgdHJlZUZvcmtQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgdHJlZUZvcmtDb3VudCA9IHRvdGFsQ2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KSB7XG4gICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgICAgIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcbiAgICAgIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgICAgIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlcjtcbiAgICAgIHRyZWVDb250ZXh0UHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHZhciBiYXNlSWRXaXRoTGVhZGluZ0JpdCA9IHRyZWVDb250ZXh0SWQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gICAgICB2YXIgYmFzZUxlbmd0aCA9IDMyIC0gY2x6MzIoYmFzZUlkV2l0aExlYWRpbmdCaXQpIC0gMTtcbiAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ICY9IH4oMSA8PCBiYXNlTGVuZ3RoKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICB2YXIgbGVuZ3RoID0gMzIgLSBjbHozMih0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGg7XG4gICAgICBpZiAoMzAgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIG51bWJlck9mT3ZlcmZsb3dCaXRzID0gYmFzZUxlbmd0aCAtIChiYXNlTGVuZ3RoICUgNSk7XG4gICAgICAgIGxlbmd0aCA9IChcbiAgICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmXG4gICAgICAgICAgKCgxIDw8IG51bWJlck9mT3ZlcmZsb3dCaXRzKSAtIDEpXG4gICAgICAgICkudG9TdHJpbmcoMzIpO1xuICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCA+Pj0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgICAgIGJhc2VMZW5ndGggLT0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgICAgIHRyZWVDb250ZXh0SWQgPVxuICAgICAgICAgICgxIDw8ICgzMiAtIGNsejMyKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aCkpIHxcbiAgICAgICAgICAoaW5kZXggPDwgYmFzZUxlbmd0aCkgfFxuICAgICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0O1xuICAgICAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gbGVuZ3RoICsgd29ya0luUHJvZ3Jlc3M7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKHRyZWVDb250ZXh0SWQgPVxuICAgICAgICAgICgxIDw8IGxlbmd0aCkgfCAoaW5kZXggPDwgYmFzZUxlbmd0aCkgfCBiYXNlSWRXaXRoTGVhZGluZ0JpdCksXG4gICAgICAgICAgKHRyZWVDb250ZXh0T3ZlcmZsb3cgPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MucmV0dXJuICYmXG4gICAgICAgIChwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIDEpLCBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCAxLCAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBmb3IgKDsgd29ya0luUHJvZ3Jlc3MgPT09IHRyZWVGb3JrUHJvdmlkZXI7IClcbiAgICAgICAgKHRyZWVGb3JrUHJvdmlkZXIgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbCksXG4gICAgICAgICAgKHRyZWVGb3JrQ291bnQgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbCk7XG4gICAgICBmb3IgKDsgd29ya0luUHJvZ3Jlc3MgPT09IHRyZWVDb250ZXh0UHJvdmlkZXI7IClcbiAgICAgICAgKHRyZWVDb250ZXh0UHJvdmlkZXIgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XSksXG4gICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGwpLFxuICAgICAgICAgICh0cmVlQ29udGV4dE92ZXJmbG93ID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsKSxcbiAgICAgICAgICAodHJlZUNvbnRleHRJZCA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JZk5vdEh5ZHJhdGluZygpIHtcbiAgICAgIGlzSHlkcmF0aW5nIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB0byBiZSBoeWRyYXRpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gICAgICBudWxsID09PSBjICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgICAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuICAgICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBudWxsLCBmaWJlcik7XG4gICAgICBuZXh0Um9vdEluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuICAgICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuICAgICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgICBudWxsICE9PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgIHB1c2goaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICAgIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUpO1xuICAgICAgY29udGV4dCAhPT0gbmV4dENvbnRleHQgJiZcbiAgICAgICAgKHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlciksXG4gICAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAgIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGZpYmVyICYmXG4gICAgICAgIChwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlciksIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpKTtcbiAgICAgIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IuY3VycmVudCA9PT0gZmliZXIgJiZcbiAgICAgICAgKHBvcChob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLCBmaWJlciksXG4gICAgICAgIGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgICAgPyAoSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUgPSBOb3RQZW5kaW5nVHJhbnNpdGlvbilcbiAgICAgICAgICA6IChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBOb3RQZW5kaW5nVHJhbnNpdGlvbikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kTm90YWJsZU5vZGUobm9kZSwgaW5kZW50KSB7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBub2RlLnNlcnZlclByb3BzICYmXG4gICAgICAgIDAgPT09IG5vZGUuc2VydmVyVGFpbC5sZW5ndGggJiZcbiAgICAgICAgMSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgMyA8IG5vZGUuZGlzdGFuY2VGcm9tTGVhZiAmJlxuICAgICAgICBub2RlLmRpc3RhbmNlRnJvbUxlYWYgPiAxNSAtIGluZGVudFxuICAgICAgICA/IGZpbmROb3RhYmxlTm9kZShub2RlLmNoaWxkcmVuWzBdLCBpbmRlbnQpXG4gICAgICAgIDogbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5kZW50YXRpb24oaW5kZW50KSB7XG4gICAgICByZXR1cm4gXCIgIFwiICsgXCIgIFwiLnJlcGVhdChpbmRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRlZChpbmRlbnQpIHtcbiAgICAgIHJldHVybiBcIisgXCIgKyBcIiAgXCIucmVwZWF0KGluZGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZWQoaW5kZW50KSB7XG4gICAgICByZXR1cm4gXCItIFwiICsgXCIgIFwiLnJlcGVhdChpbmRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUZpYmVyVHlwZShmaWJlcikge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBmaWJlci50eXBlO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJldHVybiBcIkxhenlcIjtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmV0dXJuIChmaWJlciA9IGZpYmVyLnR5cGUpLCBmaWJlci5kaXNwbGF5TmFtZSB8fCBmaWJlci5uYW1lIHx8IG51bGw7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLnR5cGUucmVuZGVyKSwgZmliZXIuZGlzcGxheU5hbWUgfHwgZmliZXIubmFtZSB8fCBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAoZmliZXIgPSBmaWJlci50eXBlKSwgZmliZXIuZGlzcGxheU5hbWUgfHwgZmliZXIubmFtZSB8fCBudWxsO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVRleHROb2RlKGNvbnRlbnQsIG1heExlbmd0aCkge1xuICAgICAgcmV0dXJuIG5lZWRzRXNjYXBpbmcudGVzdChjb250ZW50KVxuICAgICAgICA/ICgoY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpKSxcbiAgICAgICAgICBjb250ZW50Lmxlbmd0aCA+IG1heExlbmd0aCAtIDJcbiAgICAgICAgICAgID8gOCA+IG1heExlbmd0aFxuICAgICAgICAgICAgICA/ICd7XCIuLi5cIn0nXG4gICAgICAgICAgICAgIDogXCJ7XCIgKyBjb250ZW50LnNsaWNlKDAsIG1heExlbmd0aCAtIDcpICsgJy4uLlwifSdcbiAgICAgICAgICAgIDogXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCIpXG4gICAgICAgIDogY29udGVudC5sZW5ndGggPiBtYXhMZW5ndGhcbiAgICAgICAgICA/IDUgPiBtYXhMZW5ndGhcbiAgICAgICAgICAgID8gJ3tcIi4uLlwifSdcbiAgICAgICAgICAgIDogY29udGVudC5zbGljZSgwLCBtYXhMZW5ndGggLSAzKSArIFwiLi4uXCJcbiAgICAgICAgICA6IGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVGV4dERpZmYoY2xpZW50VGV4dCwgc2VydmVyUHJvcHMsIGluZGVudCkge1xuICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiBpbmRlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gc2VydmVyUHJvcHMpXG4gICAgICAgIHJldHVybiBhZGRlZChpbmRlbnQpICsgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICsgXCJcXG5cIjtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2Ygc2VydmVyUHJvcHMpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgZmlyc3REaWZmID0gMDtcbiAgICAgICAgICBmaXJzdERpZmYgPCBzZXJ2ZXJQcm9wcy5sZW5ndGggJiZcbiAgICAgICAgICBmaXJzdERpZmYgPCBjbGllbnRUZXh0Lmxlbmd0aCAmJlxuICAgICAgICAgIHNlcnZlclByb3BzLmNoYXJDb2RlQXQoZmlyc3REaWZmKSA9PT1cbiAgICAgICAgICAgIGNsaWVudFRleHQuY2hhckNvZGVBdChmaXJzdERpZmYpO1xuICAgICAgICAgIGZpcnN0RGlmZisrXG4gICAgICAgICk7XG4gICAgICAgIGZpcnN0RGlmZiA+IG1heExlbmd0aCAtIDggJiZcbiAgICAgICAgICAxMCA8IGZpcnN0RGlmZiAmJlxuICAgICAgICAgICgoY2xpZW50VGV4dCA9IFwiLi4uXCIgKyBjbGllbnRUZXh0LnNsaWNlKGZpcnN0RGlmZiAtIDgpKSxcbiAgICAgICAgICAoc2VydmVyUHJvcHMgPSBcIi4uLlwiICsgc2VydmVyUHJvcHMuc2xpY2UoZmlyc3REaWZmIC0gOCkpKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBhZGRlZChpbmRlbnQpICtcbiAgICAgICAgICBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgK1xuICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgIHJlbW92ZWQoaW5kZW50KSArXG4gICAgICAgICAgZGVzY3JpYmVUZXh0Tm9kZShzZXJ2ZXJQcm9wcywgbWF4TGVuZ3RoKSArXG4gICAgICAgICAgXCJcXG5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArIFwiXFxuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9iamVjdE5hbWUob2JqZWN0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAgICAuY2FsbChvYmplY3QpXG4gICAgICAgIC5yZXBsYWNlKC9eXFxbb2JqZWN0ICguKilcXF0kLywgZnVuY3Rpb24gKG0sIHAwKSB7XG4gICAgICAgICAgcmV0dXJuIHAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKSksXG4gICAgICAgICAgICB2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGhcbiAgICAgICAgICAgICAgPyA1ID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICAgICAgPyAnXCIuLi5cIidcbiAgICAgICAgICAgICAgICA6IHZhbHVlLnNsaWNlKDAsIG1heExlbmd0aCAtIDQpICsgJy4uLlwiJ1xuICAgICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGlmIChudWxsID09PSB2YWx1ZSkgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIGlmIChpc0FycmF5SW1wbCh2YWx1ZSkpIHJldHVybiBcIlsuLi5dXCI7XG4gICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gKG1heExlbmd0aCA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh2YWx1ZS50eXBlKSlcbiAgICAgICAgICAgICAgPyBcIjxcIiArIG1heExlbmd0aCArIFwiPlwiXG4gICAgICAgICAgICAgIDogXCI8Li4uPlwiO1xuICAgICAgICAgIHZhciBuYW1lID0gb2JqZWN0TmFtZSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKFwiT2JqZWN0XCIgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgbWF4TGVuZ3RoIC09IDI7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB2YWx1ZSlcbiAgICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBqc29uUHJvcE5hbWUgPSBKU09OLnN0cmluZ2lmeShwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAganNvblByb3BOYW1lICE9PSAnXCInICsgcHJvcE5hbWUgKyAnXCInICYmXG4gICAgICAgICAgICAgICAgICAocHJvcE5hbWUgPSBqc29uUHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIG1heExlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgIGpzb25Qcm9wTmFtZSA9IGRlc2NyaWJlVmFsdWUoXG4gICAgICAgICAgICAgICAgICB2YWx1ZVtwcm9wTmFtZV0sXG4gICAgICAgICAgICAgICAgICAxNSA+IG1heExlbmd0aCA/IG1heExlbmd0aCA6IDE1XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGggLT0ganNvblByb3BOYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoMCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgbmFtZSArPSBcIlwiID09PSBuYW1lID8gXCIuLi5cIiA6IFwiLCAuLi5cIjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lICs9XG4gICAgICAgICAgICAgICAgICAoXCJcIiA9PT0gbmFtZSA/IFwiXCIgOiBcIixcIikgKyBwcm9wTmFtZSArIFwiOlwiICsganNvblByb3BOYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJ7XCIgKyBuYW1lICsgXCJ9XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gKG1heExlbmd0aCA9IHZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm5hbWUpXG4gICAgICAgICAgICA/IFwiZnVuY3Rpb24gXCIgKyBtYXhMZW5ndGhcbiAgICAgICAgICAgIDogXCJmdW5jdGlvblwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVByb3BWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoKSB7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHZhbHVlIHx8IG5lZWRzRXNjYXBpbmcudGVzdCh2YWx1ZSlcbiAgICAgICAgPyBcIntcIiArIGRlc2NyaWJlVmFsdWUodmFsdWUsIG1heExlbmd0aCAtIDIpICsgXCJ9XCJcbiAgICAgICAgOiB2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGggLSAyXG4gICAgICAgICAgPyA1ID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICA/ICdcIi4uLlwiJ1xuICAgICAgICAgICAgOiAnXCInICsgdmFsdWUuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gNSkgKyAnLi4uXCInXG4gICAgICAgICAgOiAnXCInICsgdmFsdWUgKyAnXCInO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUV4cGFuZGVkRWxlbWVudCh0eXBlLCBwcm9wcywgcm93UHJlZml4KSB7XG4gICAgICB2YXIgcmVtYWluaW5nUm93TGVuZ3RoID0gMTIwIC0gcm93UHJlZml4Lmxlbmd0aCAtIHR5cGUubGVuZ3RoLFxuICAgICAgICBwcm9wZXJ0aWVzID0gW10sXG4gICAgICAgIHByb3BOYW1lO1xuICAgICAgZm9yIChwcm9wTmFtZSBpbiBwcm9wcylcbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiBcImNoaWxkcmVuXCIgIT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKFxuICAgICAgICAgICAgcHJvcHNbcHJvcE5hbWVdLFxuICAgICAgICAgICAgMTIwIC0gcm93UHJlZml4Lmxlbmd0aCAtIHByb3BOYW1lLmxlbmd0aCAtIDFcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlbWFpbmluZ1Jvd0xlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggKyBwcm9wVmFsdWUubGVuZ3RoICsgMjtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcE5hbWUgKyBcIj1cIiArIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiAwID09PSBwcm9wZXJ0aWVzLmxlbmd0aFxuICAgICAgICA/IHJvd1ByZWZpeCArIFwiPFwiICsgdHlwZSArIFwiPlxcblwiXG4gICAgICAgIDogMCA8IHJlbWFpbmluZ1Jvd0xlbmd0aFxuICAgICAgICAgID8gcm93UHJlZml4ICsgXCI8XCIgKyB0eXBlICsgXCIgXCIgKyBwcm9wZXJ0aWVzLmpvaW4oXCIgXCIpICsgXCI+XFxuXCJcbiAgICAgICAgICA6IHJvd1ByZWZpeCArXG4gICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICB0eXBlICtcbiAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgcm93UHJlZml4ICtcbiAgICAgICAgICAgIFwiICBcIiArXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmpvaW4oXCJcXG5cIiArIHJvd1ByZWZpeCArIFwiICBcIikgK1xuICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICByb3dQcmVmaXggK1xuICAgICAgICAgICAgXCI+XFxuXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlUHJvcGVydGllc0RpZmYoY2xpZW50T2JqZWN0LCBzZXJ2ZXJPYmplY3QsIGluZGVudCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBcIlwiLFxuICAgICAgICByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzID0gYXNzaWduKHt9LCBzZXJ2ZXJPYmplY3QpLFxuICAgICAgICBwcm9wTmFtZTtcbiAgICAgIGZvciAocHJvcE5hbWUgaW4gY2xpZW50T2JqZWN0KVxuICAgICAgICBpZiAoY2xpZW50T2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgIGRlbGV0ZSByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gMTIwIC0gMiAqIGluZGVudCAtIHByb3BOYW1lLmxlbmd0aCAtIDIsXG4gICAgICAgICAgICBjbGllbnRQcm9wVmFsdWUgPSBkZXNjcmliZVZhbHVlKGNsaWVudE9iamVjdFtwcm9wTmFtZV0sIG1heExlbmd0aCk7XG4gICAgICAgICAgc2VydmVyT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BOYW1lKVxuICAgICAgICAgICAgPyAoKG1heExlbmd0aCA9IGRlc2NyaWJlVmFsdWUoc2VydmVyT2JqZWN0W3Byb3BOYW1lXSwgbWF4TGVuZ3RoKSksXG4gICAgICAgICAgICAgIChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50KSArIHByb3BOYW1lICsgXCI6IFwiICsgY2xpZW50UHJvcFZhbHVlICsgXCJcXG5cIiksXG4gICAgICAgICAgICAgIChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQpICsgcHJvcE5hbWUgKyBcIjogXCIgKyBtYXhMZW5ndGggKyBcIlxcblwiKSlcbiAgICAgICAgICAgIDogKHByb3BlcnRpZXMgKz1cbiAgICAgICAgICAgICAgICBhZGRlZChpbmRlbnQpICsgcHJvcE5hbWUgKyBcIjogXCIgKyBjbGllbnRQcm9wVmFsdWUgKyBcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMpXG4gICAgICAgIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lKSAmJlxuICAgICAgICAgICgoY2xpZW50T2JqZWN0ID0gZGVzY3JpYmVWYWx1ZShcbiAgICAgICAgICAgIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXNbX3Byb3BOYW1lXSxcbiAgICAgICAgICAgIDEyMCAtIDIgKiBpbmRlbnQgLSBfcHJvcE5hbWUubGVuZ3RoIC0gMlxuICAgICAgICAgICkpLFxuICAgICAgICAgIChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICByZW1vdmVkKGluZGVudCkgKyBfcHJvcE5hbWUgKyBcIjogXCIgKyBjbGllbnRPYmplY3QgKyBcIlxcblwiKSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVFbGVtZW50RGlmZih0eXBlLCBjbGllbnRQcm9wcywgc2VydmVyUHJvcHMsIGluZGVudCkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiLFxuICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKHByb3BOYW1lJGpzY29tcCQwIGluIHNlcnZlclByb3BzKVxuICAgICAgICBzZXJ2ZXJQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSRqc2NvbXAkMCkgJiZcbiAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMuc2V0KFxuICAgICAgICAgICAgcHJvcE5hbWUkanNjb21wJDAudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwXG4gICAgICAgICAgKTtcbiAgICAgIGlmICgxID09PSBzZXJ2ZXJQcm9wTmFtZXMuc2l6ZSAmJiBzZXJ2ZXJQcm9wTmFtZXMuaGFzKFwiY2hpbGRyZW5cIikpXG4gICAgICAgIGNvbnRlbnQgKz0gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBjbGllbnRQcm9wcyxcbiAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpXG4gICAgICAgICk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX3Byb3BOYW1lMiBpbiBjbGllbnRQcm9wcylcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjbGllbnRQcm9wcy5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUyKSAmJlxuICAgICAgICAgICAgXCJjaGlsZHJlblwiICE9PSBfcHJvcE5hbWUyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgbWF4TGVuZ3RoJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAxMjAgLSAyICogKGluZGVudCArIDEpIC0gX3Byb3BOYW1lMi5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSA9IHNlcnZlclByb3BOYW1lcy5nZXQoX3Byb3BOYW1lMi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHNlcnZlclByb3BOYW1lKSB7XG4gICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lcy5kZWxldGUoX3Byb3BOYW1lMi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgdmFyIHByb3BOYW1lJGpzY29tcCQwID0gY2xpZW50UHJvcHNbX3Byb3BOYW1lMl07XG4gICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lID0gc2VydmVyUHJvcHNbc2VydmVyUHJvcE5hbWVdO1xuICAgICAgICAgICAgICB2YXIgY2xpZW50UHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoJGpzY29tcCQwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMCA9IGRlc2NyaWJlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lLFxuICAgICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvcE5hbWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcHJvcE5hbWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHNlcnZlclByb3BOYW1lICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHNlcnZlclByb3BOYW1lICYmXG4gICAgICAgICAgICAgIFwiT2JqZWN0XCIgPT09IG9iamVjdE5hbWUocHJvcE5hbWUkanNjb21wJDApICYmXG4gICAgICAgICAgICAgIFwiT2JqZWN0XCIgPT09IG9iamVjdE5hbWUoc2VydmVyUHJvcE5hbWUpICYmXG4gICAgICAgICAgICAgICgyIDwgT2JqZWN0LmtleXMocHJvcE5hbWUkanNjb21wJDApLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIDIgPCBPYmplY3Qua2V5cyhzZXJ2ZXJQcm9wTmFtZSkubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgLTEgPCBjbGllbnRQcm9wVmFsdWUuaW5kZXhPZihcIi4uLlwiKSB8fFxuICAgICAgICAgICAgICAgIC0xIDwgbWF4TGVuZ3RoJGpzY29tcCQwLmluZGV4T2YoXCIuLi5cIikpXG4gICAgICAgICAgICAgICAgPyAoY29udGVudCArPVxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wTmFtZTIgK1xuICAgICAgICAgICAgICAgICAgICBcIj17e1xcblwiICtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZihcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKyAyXG4gICAgICAgICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIFwifX1cXG5cIilcbiAgICAgICAgICAgICAgICA6ICgoY29udGVudCArPVxuICAgICAgICAgICAgICAgICAgICBhZGRlZChpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wTmFtZTIgK1xuICAgICAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFByb3BWYWx1ZSArXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuXCIpLFxuICAgICAgICAgICAgICAgICAgKGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wTmFtZTIgK1xuICAgICAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMCArXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb250ZW50ICs9XG4gICAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgIF9wcm9wTmFtZTIgK1xuICAgICAgICAgICAgICAgIFwiPVwiICtcbiAgICAgICAgICAgICAgICBkZXNjcmliZVByb3BWYWx1ZShjbGllbnRQcm9wc1tfcHJvcE5hbWUyXSwgbWF4TGVuZ3RoJGpzY29tcCQwKSArXG4gICAgICAgICAgICAgICAgXCJcXG5cIjtcbiAgICAgICAgICB9XG4gICAgICAgIHNlcnZlclByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgIGlmIChcImNoaWxkcmVuXCIgIT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gMTIwIC0gMiAqIChpbmRlbnQgKyAxKSAtIHByb3BOYW1lLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb250ZW50ICs9XG4gICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICBwcm9wTmFtZSArXG4gICAgICAgICAgICAgIFwiPVwiICtcbiAgICAgICAgICAgICAgZGVzY3JpYmVQcm9wVmFsdWUoc2VydmVyUHJvcHNbcHJvcE5hbWVdLCBtYXhMZW5ndGgpICtcbiAgICAgICAgICAgICAgXCJcXG5cIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZW50ID1cbiAgICAgICAgICBcIlwiID09PSBjb250ZW50XG4gICAgICAgICAgICA/IGluZGVudGF0aW9uKGluZGVudCkgKyBcIjxcIiArIHR5cGUgKyBcIj5cXG5cIlxuICAgICAgICAgICAgOiBpbmRlbnRhdGlvbihpbmRlbnQpICtcbiAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICB0eXBlICtcbiAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgIGNvbnRlbnQgK1xuICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpICtcbiAgICAgICAgICAgICAgXCI+XFxuXCI7XG4gICAgICB9XG4gICAgICB0eXBlID0gc2VydmVyUHJvcHMuY2hpbGRyZW47XG4gICAgICBjbGllbnRQcm9wcyA9IGNsaWVudFByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgKSB7XG4gICAgICAgIHNlcnZlclByb3BOYW1lcyA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2xpZW50UHJvcHMgfHxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2xpZW50UHJvcHMgfHxcbiAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgY2xpZW50UHJvcHNcbiAgICAgICAgKVxuICAgICAgICAgIHNlcnZlclByb3BOYW1lcyA9IFwiXCIgKyBjbGllbnRQcm9wcztcbiAgICAgICAgY29udGVudCArPSBkZXNjcmliZVRleHREaWZmKHNlcnZlclByb3BOYW1lcywgXCJcIiArIHR5cGUsIGluZGVudCArIDEpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjbGllbnRQcm9wcyB8fFxuICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgY2xpZW50UHJvcHNcbiAgICAgIClcbiAgICAgICAgY29udGVudCA9XG4gICAgICAgICAgbnVsbCA9PSB0eXBlXG4gICAgICAgICAgICA/IGNvbnRlbnQgKyBkZXNjcmliZVRleHREaWZmKFwiXCIgKyBjbGllbnRQcm9wcywgbnVsbCwgaW5kZW50ICsgMSlcbiAgICAgICAgICAgIDogY29udGVudCArIGRlc2NyaWJlVGV4dERpZmYoXCJcIiArIGNsaWVudFByb3BzLCB2b2lkIDAsIGluZGVudCArIDEpO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlU2libGluZ0ZpYmVyKGZpYmVyLCBpbmRlbnQpIHtcbiAgICAgIHZhciB0eXBlID0gZGVzY3JpYmVGaWJlclR5cGUoZmliZXIpO1xuICAgICAgaWYgKG51bGwgPT09IHR5cGUpIHtcbiAgICAgICAgdHlwZSA9IFwiXCI7XG4gICAgICAgIGZvciAoZmliZXIgPSBmaWJlci5jaGlsZDsgZmliZXI7IClcbiAgICAgICAgICAodHlwZSArPSBkZXNjcmliZVNpYmxpbmdGaWJlcihmaWJlciwgaW5kZW50KSksXG4gICAgICAgICAgICAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZW50YXRpb24oaW5kZW50KSArIFwiPFwiICsgdHlwZSArIFwiPlxcblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU5vZGUobm9kZSwgaW5kZW50KSB7XG4gICAgICB2YXIgc2tpcFRvTm9kZSA9IGZpbmROb3RhYmxlTm9kZShub2RlLCBpbmRlbnQpO1xuICAgICAgaWYgKFxuICAgICAgICBza2lwVG9Ob2RlICE9PSBub2RlICYmXG4gICAgICAgICgxICE9PSBub2RlLmNoaWxkcmVuLmxlbmd0aCB8fCBub2RlLmNoaWxkcmVuWzBdICE9PSBza2lwVG9Ob2RlKVxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCkgKyBcIi4uLlxcblwiICsgZGVzY3JpYmVOb2RlKHNraXBUb05vZGUsIGluZGVudCArIDEpXG4gICAgICAgICk7XG4gICAgICBza2lwVG9Ob2RlID0gXCJcIjtcbiAgICAgIHZhciBkZWJ1Z0luZm8gPSBub2RlLmZpYmVyLl9kZWJ1Z0luZm87XG4gICAgICBpZiAoZGVidWdJbmZvKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlYnVnSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzZXJ2ZXJDb21wb25lbnROYW1lID0gZGVidWdJbmZvW2ldLm5hbWU7XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNlcnZlckNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgICAgICgoc2tpcFRvTm9kZSArPVxuICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCI8XCIgKyBzZXJ2ZXJDb21wb25lbnROYW1lICsgXCI+XFxuXCIpLFxuICAgICAgICAgICAgaW5kZW50KyspO1xuICAgICAgICB9XG4gICAgICBkZWJ1Z0luZm8gPSBcIlwiO1xuICAgICAgaSA9IG5vZGUuZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgaWYgKDYgPT09IG5vZGUuZmliZXIudGFnKVxuICAgICAgICAoZGVidWdJbmZvID0gZGVzY3JpYmVUZXh0RGlmZihpLCBub2RlLnNlcnZlclByb3BzLCBpbmRlbnQpKSwgaW5kZW50Kys7XG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgKChzZXJ2ZXJDb21wb25lbnROYW1lID0gZGVzY3JpYmVGaWJlclR5cGUobm9kZS5maWJlcikpLFxuICAgICAgICBudWxsICE9PSBzZXJ2ZXJDb21wb25lbnROYW1lKVxuICAgICAgKVxuICAgICAgICBpZiAodm9pZCAwID09PSBub2RlLnNlcnZlclByb3BzKSB7XG4gICAgICAgICAgZGVidWdJbmZvID0gaW5kZW50O1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSAxMjAgLSAyICogZGVidWdJbmZvIC0gc2VydmVyQ29tcG9uZW50TmFtZS5sZW5ndGggLSAyLFxuICAgICAgICAgICAgY29udGVudCA9IFwiXCI7XG4gICAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBpKVxuICAgICAgICAgICAgaWYgKGkuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmIFwiY2hpbGRyZW5cIiAhPT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKGlbcHJvcE5hbWVdLCAxNSk7XG4gICAgICAgICAgICAgIG1heExlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggKyBwcm9wVmFsdWUubGVuZ3RoICsgMjtcbiAgICAgICAgICAgICAgaWYgKDAgPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IFwiIC4uLlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRlbnQgKz0gXCIgXCIgKyBwcm9wTmFtZSArIFwiPVwiICsgcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlYnVnSW5mbyA9XG4gICAgICAgICAgICBpbmRlbnRhdGlvbihkZWJ1Z0luZm8pICtcbiAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUgK1xuICAgICAgICAgICAgY29udGVudCArXG4gICAgICAgICAgICBcIj5cXG5cIjtcbiAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbnVsbCA9PT0gbm9kZS5zZXJ2ZXJQcm9wc1xuICAgICAgICAgICAgPyAoKGRlYnVnSW5mbyA9IGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KFxuICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBhZGRlZChpbmRlbnQpXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBpbmRlbnQrKylcbiAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5vZGUuc2VydmVyUHJvcHNcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJTaG91bGQgbm90IGhhdmUgbWF0Y2hlZCBhIG5vbiBIb3N0VGV4dCBmaWJlciB0byBhIFRleHQgbm9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiAoKGRlYnVnSW5mbyA9IGRlc2NyaWJlRWxlbWVudERpZmYoXG4gICAgICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgIG5vZGUuc2VydmVyUHJvcHMsXG4gICAgICAgICAgICAgICAgICBpbmRlbnRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBpbmRlbnQrKyk7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBcIlwiO1xuICAgICAgaSA9IG5vZGUuZmliZXIuY2hpbGQ7XG4gICAgICBmb3IgKFxuICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lID0gMDtcbiAgICAgICAgaSAmJiBzZXJ2ZXJDb21wb25lbnROYW1lIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgIClcbiAgICAgICAgKG1heExlbmd0aCA9IG5vZGUuY2hpbGRyZW5bc2VydmVyQ29tcG9uZW50TmFtZV0pLFxuICAgICAgICAgIG1heExlbmd0aC5maWJlciA9PT0gaVxuICAgICAgICAgICAgPyAoKHByb3BOYW1lICs9IGRlc2NyaWJlTm9kZShtYXhMZW5ndGgsIGluZGVudCkpLFxuICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lKyspXG4gICAgICAgICAgICA6IChwcm9wTmFtZSArPSBkZXNjcmliZVNpYmxpbmdGaWJlcihpLCBpbmRlbnQpKSxcbiAgICAgICAgICAoaSA9IGkuc2libGluZyk7XG4gICAgICBpICYmXG4gICAgICAgIDAgPCBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJlxuICAgICAgICAocHJvcE5hbWUgKz0gaW5kZW50YXRpb24oaW5kZW50KSArIFwiLi4uXFxuXCIpO1xuICAgICAgaSA9IG5vZGUuc2VydmVyVGFpbDtcbiAgICAgIG51bGwgPT09IG5vZGUuc2VydmVyUHJvcHMgJiYgaW5kZW50LS07XG4gICAgICBmb3IgKG5vZGUgPSAwOyBub2RlIDwgaS5sZW5ndGg7IG5vZGUrKylcbiAgICAgICAgKHNlcnZlckNvbXBvbmVudE5hbWUgPSBpW25vZGVdKSxcbiAgICAgICAgICAocHJvcE5hbWUgPVxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNlcnZlckNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgPyBwcm9wTmFtZSArXG4gICAgICAgICAgICAgICAgKHJlbW92ZWQoaW5kZW50KSArXG4gICAgICAgICAgICAgICAgICBkZXNjcmliZVRleHROb2RlKHNlcnZlckNvbXBvbmVudE5hbWUsIDEyMCAtIDIgKiBpbmRlbnQpICtcbiAgICAgICAgICAgICAgICAgIFwiXFxuXCIpXG4gICAgICAgICAgICAgIDogcHJvcE5hbWUgK1xuICAgICAgICAgICAgICAgIGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZS50eXBlLFxuICAgICAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZS5wcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50KVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgcmV0dXJuIHNraXBUb05vZGUgKyBkZWJ1Z0luZm8gKyBwcm9wTmFtZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVEaWZmKHJvb3ROb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gXCJcXG5cXG5cIiArIGRlc2NyaWJlTm9kZShyb290Tm9kZSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCBkaXN0YW5jZUZyb21MZWFmKSB7XG4gICAgICBpZiAobnVsbCA9PT0gZmliZXIucmV0dXJuKSB7XG4gICAgICAgIGlmIChudWxsID09PSBoeWRyYXRpb25EaWZmUm9vdERFVilcbiAgICAgICAgICBoeWRyYXRpb25EaWZmUm9vdERFViA9IHtcbiAgICAgICAgICAgIGZpYmVyOiBmaWJlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIHNlcnZlclByb3BzOiB2b2lkIDAsXG4gICAgICAgICAgICBzZXJ2ZXJUYWlsOiBbXSxcbiAgICAgICAgICAgIGRpc3RhbmNlRnJvbUxlYWY6IGRpc3RhbmNlRnJvbUxlYWZcbiAgICAgICAgICB9O1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaHlkcmF0aW9uRGlmZlJvb3RERVYuZmliZXIgIT09IGZpYmVyKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiU2F3IG11bHRpcGxlIGh5ZHJhdGlvbiBkaWZmIHJvb3RzIGluIGEgcGFzcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBoeWRyYXRpb25EaWZmUm9vdERFVi5kaXN0YW5jZUZyb21MZWFmID4gZGlzdGFuY2VGcm9tTGVhZiAmJlxuICAgICAgICAgICAgKGh5ZHJhdGlvbkRpZmZSb290REVWLmRpc3RhbmNlRnJvbUxlYWYgPSBkaXN0YW5jZUZyb21MZWFmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHlkcmF0aW9uRGlmZlJvb3RERVY7XG4gICAgICB9XG4gICAgICB2YXIgc2libGluZ3MgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKFxuICAgICAgICBmaWJlci5yZXR1cm4sXG4gICAgICAgIGRpc3RhbmNlRnJvbUxlYWYgKyAxXG4gICAgICApLmNoaWxkcmVuO1xuICAgICAgaWYgKDAgPCBzaWJsaW5ncy5sZW5ndGggJiYgc2libGluZ3Nbc2libGluZ3MubGVuZ3RoIC0gMV0uZmliZXIgPT09IGZpYmVyKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChzaWJsaW5ncyA9IHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdKSxcbiAgICAgICAgICBzaWJsaW5ncy5kaXN0YW5jZUZyb21MZWFmID4gZGlzdGFuY2VGcm9tTGVhZiAmJlxuICAgICAgICAgICAgKHNpYmxpbmdzLmRpc3RhbmNlRnJvbUxlYWYgPSBkaXN0YW5jZUZyb21MZWFmKSxcbiAgICAgICAgICBzaWJsaW5nc1xuICAgICAgICApO1xuICAgICAgZGlzdGFuY2VGcm9tTGVhZiA9IHtcbiAgICAgICAgZmliZXI6IGZpYmVyLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIHNlcnZlclByb3BzOiB2b2lkIDAsXG4gICAgICAgIHNlcnZlclRhaWw6IFtdLFxuICAgICAgICBkaXN0YW5jZUZyb21MZWFmOiBkaXN0YW5jZUZyb21MZWFmXG4gICAgICB9O1xuICAgICAgc2libGluZ3MucHVzaChkaXN0YW5jZUZyb21MZWFmKTtcbiAgICAgIHJldHVybiBkaXN0YW5jZUZyb21MZWFmO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZShmaWJlciwgcmVqZWN0ZWRDYW5kaWRhdGUpIHtcbiAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWIHx8XG4gICAgICAgICgoZmliZXIgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCAwKSksXG4gICAgICAgIChmaWJlci5zZXJ2ZXJQcm9wcyA9IG51bGwpLFxuICAgICAgICBudWxsICE9PSByZWplY3RlZENhbmRpZGF0ZSAmJlxuICAgICAgICAgICgocmVqZWN0ZWRDYW5kaWRhdGUgPVxuICAgICAgICAgICAgZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyhyZWplY3RlZENhbmRpZGF0ZSkpLFxuICAgICAgICAgIGZpYmVyLnNlcnZlclRhaWwucHVzaChyZWplY3RlZENhbmRpZGF0ZSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKSB7XG4gICAgICB2YXIgZGlmZiA9IFwiXCIsXG4gICAgICAgIGRpZmZSb290ID0gaHlkcmF0aW9uRGlmZlJvb3RERVY7XG4gICAgICBudWxsICE9PSBkaWZmUm9vdCAmJlxuICAgICAgICAoKGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbCksIChkaWZmID0gZGVzY3JpYmVEaWZmKGRpZmZSb290KSkpO1xuICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihcbiAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICBcIkh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgc2VydmVyIHJlbmRlcmVkIEhUTUwgZGlkbid0IG1hdGNoIHRoZSBjbGllbnQuIEFzIGEgcmVzdWx0IHRoaXMgdHJlZSB3aWxsIGJlIHJlZ2VuZXJhdGVkIG9uIHRoZSBjbGllbnQuIFRoaXMgY2FuIGhhcHBlbiBpZiBhIFNTUi1lZCBDbGllbnQgQ29tcG9uZW50IHVzZWQ6XFxuXFxuLSBBIHNlcnZlci9jbGllbnQgYnJhbmNoIGBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpYC5cXG4tIFZhcmlhYmxlIGlucHV0IHN1Y2ggYXMgYERhdGUubm93KClgIG9yIGBNYXRoLnJhbmRvbSgpYCB3aGljaCBjaGFuZ2VzIGVhY2ggdGltZSBpdCdzIGNhbGxlZC5cXG4tIERhdGUgZm9ybWF0dGluZyBpbiBhIHVzZXIncyBsb2NhbGUgd2hpY2ggZG9lc24ndCBtYXRjaCB0aGUgc2VydmVyLlxcbi0gRXh0ZXJuYWwgY2hhbmdpbmcgZGF0YSB3aXRob3V0IHNlbmRpbmcgYSBzbmFwc2hvdCBvZiBpdCBhbG9uZyB3aXRoIHRoZSBIVE1MLlxcbi0gSW52YWxpZCBIVE1MIHRhZyBuZXN0aW5nLlxcblxcbkl0IGNhbiBhbHNvIGhhcHBlbiBpZiB0aGUgY2xpZW50IGhhcyBhIGJyb3dzZXIgZXh0ZW5zaW9uIGluc3RhbGxlZCB3aGljaCBtZXNzZXMgd2l0aCB0aGUgSFRNTCBiZWZvcmUgUmVhY3QgbG9hZGVkLlxcblxcbmh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaHlkcmF0aW9uLW1pc21hdGNoXCIgK1xuICAgICAgICAgICAgICBkaWZmXG4gICAgICAgICAgKSxcbiAgICAgICAgICBmaWJlclxuICAgICAgICApXG4gICAgICApO1xuICAgICAgdGhyb3cgSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIGhvc3RDb250ZXh0KSB7XG4gICAgICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICAgIGh5ZHJhdGVJbnN0YW5jZShcbiAgICAgICAgZmliZXIuc3RhdGVOb2RlLFxuICAgICAgICBmaWJlci50eXBlLFxuICAgICAgICBmaWJlci5tZW1vaXplZFByb3BzLFxuICAgICAgICBob3N0Q29udGV4dCxcbiAgICAgICAgZmliZXJcbiAgICAgICkgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgICAgZm9yIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyLnJldHVybjsgaHlkcmF0aW9uUGFyZW50RmliZXI7IClcbiAgICAgICAgc3dpdGNoIChoeWRyYXRpb25QYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlci5yZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgICAgIGlmICghc3VwcG9ydHNIeWRyYXRpb24gfHwgZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSByZXR1cm4gITE7XG4gICAgICBpZiAoIWlzSHlkcmF0aW5nKVxuICAgICAgICByZXR1cm4gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlciksIChpc0h5ZHJhdGluZyA9ICEwKSwgITE7XG4gICAgICB2YXIgc2hvdWxkQ2xlYXIgPSAhMTtcbiAgICAgIHN1cHBvcnRzU2luZ2xldG9uc1xuICAgICAgICA/IDMgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgIDI3ICE9PSBmaWJlci50YWcgJiZcbiAgICAgICAgICAoNSAhPT0gZmliZXIudGFnIHx8XG4gICAgICAgICAgICAoc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMoZmliZXIudHlwZSkgJiZcbiAgICAgICAgICAgICAgIXNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSkgJiZcbiAgICAgICAgICAoc2hvdWxkQ2xlYXIgPSAhMClcbiAgICAgICAgOiAzICE9PSBmaWJlci50YWcgJiZcbiAgICAgICAgICAoNSAhPT0gZmliZXIudGFnIHx8XG4gICAgICAgICAgICAoc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMoZmliZXIudHlwZSkgJiZcbiAgICAgICAgICAgICAgIXNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSkgJiZcbiAgICAgICAgICAoc2hvdWxkQ2xlYXIgPSAhMCk7XG4gICAgICBpZiAoc2hvdWxkQ2xlYXIgJiYgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSkge1xuICAgICAgICBmb3IgKHNob3VsZENsZWFyID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTsgc2hvdWxkQ2xlYXI7ICkge1xuICAgICAgICAgIHZhciBkaWZmTm9kZSA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzKHNob3VsZENsZWFyKTtcbiAgICAgICAgICBkaWZmTm9kZS5zZXJ2ZXJUYWlsLnB1c2goZGVzY3JpcHRpb24pO1xuICAgICAgICAgIHNob3VsZENsZWFyID1cbiAgICAgICAgICAgIFwiU3VzcGVuc2VcIiA9PT0gZGVzY3JpcHRpb24udHlwZVxuICAgICAgICAgICAgICA/IGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc2hvdWxkQ2xlYXIpXG4gICAgICAgICAgICAgIDogZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKHNob3VsZENsZWFyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICAgICAgfVxuICAgICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgICBpZiAoMTMgPT09IGZpYmVyLnRhZykge1xuICAgICAgICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgZmliZXIgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICBmaWJlciA9IG51bGwgIT09IGZpYmVyID8gZmliZXIuZGVoeWRyYXRlZCA6IG51bGw7XG4gICAgICAgIGlmICghZmliZXIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UoZmliZXIpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlclxuICAgICAgICAgID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAoKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGwpLFxuICAgICAgICAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBpc0h5ZHJhdGluZyA9ICExKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF1ZXVlSHlkcmF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICAgIG51bGwgPT09IGh5ZHJhdGlvbkVycm9yc1xuICAgICAgICA/IChoeWRyYXRpb25FcnJvcnMgPSBbZXJyb3JdKVxuICAgICAgICA6IGh5ZHJhdGlvbkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncygpIHtcbiAgICAgIHZhciBkaWZmUm9vdCA9IGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICAgICAgbnVsbCAhPT0gZGlmZlJvb3QgJiZcbiAgICAgICAgKChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLFxuICAgICAgICAoZGlmZlJvb3QgPSBkZXNjcmliZURpZmYoZGlmZlJvb3QpKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkEgdHJlZSBoeWRyYXRlZCBidXQgc29tZSBhdHRyaWJ1dGVzIG9mIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgSFRNTCBkaWRuJ3QgbWF0Y2ggdGhlIGNsaWVudCBwcm9wZXJ0aWVzLiBUaGlzIHdvbid0IGJlIHBhdGNoZWQgdXAuIFRoaXMgY2FuIGhhcHBlbiBpZiBhIFNTUi1lZCBDbGllbnQgQ29tcG9uZW50IHVzZWQ6XFxuXFxuLSBBIHNlcnZlci9jbGllbnQgYnJhbmNoIGBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpYC5cXG4tIFZhcmlhYmxlIGlucHV0IHN1Y2ggYXMgYERhdGUubm93KClgIG9yIGBNYXRoLnJhbmRvbSgpYCB3aGljaCBjaGFuZ2VzIGVhY2ggdGltZSBpdCdzIGNhbGxlZC5cXG4tIERhdGUgZm9ybWF0dGluZyBpbiBhIHVzZXIncyBsb2NhbGUgd2hpY2ggZG9lc24ndCBtYXRjaCB0aGUgc2VydmVyLlxcbi0gRXh0ZXJuYWwgY2hhbmdpbmcgZGF0YSB3aXRob3V0IHNlbmRpbmcgYSBzbmFwc2hvdCBvZiBpdCBhbG9uZyB3aXRoIHRoZSBIVE1MLlxcbi0gSW52YWxpZCBIVE1MIHRhZyBuZXN0aW5nLlxcblxcbkl0IGNhbiBhbHNvIGhhcHBlbiBpZiB0aGUgY2xpZW50IGhhcyBhIGJyb3dzZXIgZXh0ZW5zaW9uIGluc3RhbGxlZCB3aGljaCBtZXNzZXMgd2l0aCB0aGUgSFRNTCBiZWZvcmUgUmVhY3QgbG9hZGVkLlxcblxcbiVzJXNcIixcbiAgICAgICAgICBcImh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaHlkcmF0aW9uLW1pc21hdGNoXCIsXG4gICAgICAgICAgZGlmZlJvb3RcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgZW5kSW5kZXggPSBjb25jdXJyZW50UXVldWVzSW5kZXgsXG4gICAgICAgICAgaSA9IChjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSBjb25jdXJyZW50UXVldWVzSW5kZXggPSAwKTtcbiAgICAgICAgaSA8IGVuZEluZGV4O1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgdmFyIHF1ZXVlID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIHZhciBsYW5lID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IHF1ZXVlICYmIG51bGwgIT09IHVwZGF0ZSkge1xuICAgICAgICAgIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcbiAgICAgICAgICBudWxsID09PSBwZW5kaW5nXG4gICAgICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgICAgIDogKCh1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dCksIChwZW5kaW5nLm5leHQgPSB1cGRhdGUpKTtcbiAgICAgICAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIDAgIT09IGxhbmUgJiYgbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBmaWJlcjtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gcXVldWU7XG4gICAgICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IHVwZGF0ZTtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gbGFuZTtcbiAgICAgIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyB8PSBsYW5lO1xuICAgICAgZmliZXIubGFuZXMgfD0gbGFuZTtcbiAgICAgIGZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gZmliZXIgJiYgKGZpYmVyLmxhbmVzIHw9IGxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSkge1xuICAgICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBudWxsLCBudWxsLCBsYW5lKTtcbiAgICAgIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qoc291cmNlRmliZXIsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgc291cmNlRmliZXIubGFuZXMgfD0gbGFuZTtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgKGFsdGVybmF0ZS5sYW5lcyB8PSBsYW5lKTtcbiAgICAgIGZvciAodmFyIGlzSGlkZGVuID0gITEsIHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgICAgIChwYXJlbnQuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAoYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAyMiA9PT0gcGFyZW50LnRhZyAmJlxuICAgICAgICAgICAgKChzb3VyY2VGaWJlciA9IHBhcmVudC5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXIgfHxcbiAgICAgICAgICAgICAgc291cmNlRmliZXIuX3Zpc2liaWxpdHkgJiAxIHx8XG4gICAgICAgICAgICAgIChpc0hpZGRlbiA9ICEwKSksXG4gICAgICAgICAgKHNvdXJjZUZpYmVyID0gcGFyZW50KSxcbiAgICAgICAgICAocGFyZW50ID0gcGFyZW50LnJldHVybik7XG4gICAgICBpc0hpZGRlbiAmJlxuICAgICAgICBudWxsICE9PSB1cGRhdGUgJiZcbiAgICAgICAgMyA9PT0gc291cmNlRmliZXIudGFnICYmXG4gICAgICAgICgocGFyZW50ID0gc291cmNlRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgKGlzSGlkZGVuID0gMzEgLSBjbHozMihsYW5lKSksXG4gICAgICAgIChwYXJlbnQgPSBwYXJlbnQuaGlkZGVuVXBkYXRlcyksXG4gICAgICAgIChzb3VyY2VGaWJlciA9IHBhcmVudFtpc0hpZGRlbl0pLFxuICAgICAgICBudWxsID09PSBzb3VyY2VGaWJlclxuICAgICAgICAgID8gKHBhcmVudFtpc0hpZGRlbl0gPSBbdXBkYXRlXSlcbiAgICAgICAgICA6IHNvdXJjZUZpYmVyLnB1c2godXBkYXRlKSxcbiAgICAgICAgKHVwZGF0ZS5sYW5lID0gbGFuZSB8IDUzNjg3MDkxMikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKHNvdXJjZUZpYmVyKSB7XG4gICAgICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKVxuICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgKChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSBuZXN0ZWRVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAgIChyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbCksXG4gICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICBcIk1heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCByZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yIGNvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cIlxuICAgICAgICAgICkpXG4gICAgICAgICk7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPiBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQgJiZcbiAgICAgICAgKChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwKSxcbiAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIk1heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgdXNlRWZmZWN0LCBidXQgdXNlRWZmZWN0IGVpdGhlciBkb2Vzbid0IGhhdmUgYSBkZXBlbmRlbmN5IGFycmF5LCBvciBvbmUgb2YgdGhlIGRlcGVuZGVuY2llcyBjaGFuZ2VzIG9uIGV2ZXJ5IHJlbmRlci5cIlxuICAgICAgICApKTtcbiAgICAgIG51bGwgPT09IHNvdXJjZUZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAwICE9PSAoc291cmNlRmliZXIuZmxhZ3MgJiA0MDk4KSAmJlxuICAgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICAgIGZvciAodmFyIG5vZGUgPSBzb3VyY2VGaWJlciwgcGFyZW50ID0gbm9kZS5yZXR1cm47IG51bGwgIT09IHBhcmVudDsgKVxuICAgICAgICBudWxsID09PSBub2RlLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIDAgIT09IChub2RlLmZsYWdzICYgNDA5OCkgJiZcbiAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKSxcbiAgICAgICAgICAobm9kZSA9IHBhcmVudCksXG4gICAgICAgICAgKHBhcmVudCA9IG5vZGUucmV0dXJuKTtcbiAgICAgIHJldHVybiAzID09PSBub2RlLnRhZyA/IG5vZGUuc3RhdGVOb2RlIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpIHtcbiAgICAgIHZhciBwcmV2RWZmZWN0RHVyYXRpb24gPSBwcm9maWxlckVmZmVjdER1cmF0aW9uO1xuICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICByZXR1cm4gcHJldkVmZmVjdER1cmF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKSB7XG4gICAgICB2YXIgZWxhcHNlZFRpbWUgPSBwcm9maWxlckVmZmVjdER1cmF0aW9uO1xuICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICAgIHJldHVybiBlbGFwc2VkVGltZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbikge1xuICAgICAgdmFyIGVsYXBzZWRUaW1lID0gcHJvZmlsZXJFZmZlY3REdXJhdGlvbjtcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gKz0gcHJldkVmZmVjdER1cmF0aW9uO1xuICAgICAgcmV0dXJuIGVsYXBzZWRUaW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFByb2ZpbGVyVGltZXIoZmliZXIpIHtcbiAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93KCk7XG4gICAgICAwID4gZmliZXIuYWN0dWFsU3RhcnRUaW1lICYmIChmaWJlci5hY3R1YWxTdGFydFRpbWUgPSBwcm9maWxlclN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24oZmliZXIpIHtcbiAgICAgIGlmICgwIDw9IHByb2ZpbGVyU3RhcnRUaW1lKSB7XG4gICAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdygpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uKGZpYmVyKSB7XG4gICAgICBpZiAoMCA8PSBwcm9maWxlclN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgICAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb3JkRWZmZWN0RHVyYXRpb24oKSB7XG4gICAgICBpZiAoMCA8PSBwcm9maWxlclN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydEVmZmVjdFRpbWVyKCkge1xuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3coKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNmZXJBY3R1YWxEdXJhdGlvbihmaWJlcikge1xuICAgICAgZm9yICh2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDsgY2hpbGQ7IClcbiAgICAgICAgKGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uKSwgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KSB7XG4gICAgICByb290ICE9PSBsYXN0U2NoZWR1bGVkUm9vdCAmJlxuICAgICAgICBudWxsID09PSByb290Lm5leHQgJiZcbiAgICAgICAgKG51bGwgPT09IGxhc3RTY2hlZHVsZWRSb290XG4gICAgICAgICAgPyAoZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290KVxuICAgICAgICAgIDogKGxhc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QubmV4dCA9IHJvb3QpKTtcbiAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICEwO1xuICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWVcbiAgICAgICAgPyBkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgfHxcbiAgICAgICAgICAoKGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9ICEwKSxcbiAgICAgICAgICBzY2hlZHVsZUltbWVkaWF0ZVRhc2socHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKSlcbiAgICAgICAgOiBkaWRTY2hlZHVsZU1pY3JvdGFzayB8fFxuICAgICAgICAgICgoZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSAhMCksXG4gICAgICAgICAgc2NoZWR1bGVJbW1lZGlhdGVUYXNrKHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbChzeW5jVHJhbnNpdGlvbkxhbmVzLCBvbmx5TGVnYWN5KSB7XG4gICAgICBpZiAoIWlzRmx1c2hpbmdXb3JrICYmIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yaykge1xuICAgICAgICBpc0ZsdXNoaW5nV29yayA9ICEwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIGRpZFBlcmZvcm1Tb21lV29yayA9ICExO1xuICAgICAgICAgIGZvciAodmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7IG51bGwgIT09IHJvb3Q7ICkge1xuICAgICAgICAgICAgaWYgKCFvbmx5TGVnYWN5KVxuICAgICAgICAgICAgICBpZiAoMCAhPT0gc3luY1RyYW5zaXRpb25MYW5lcykge1xuICAgICAgICAgICAgICAgIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gcGVuZGluZ0xhbmVzKSB2YXIgbmV4dExhbmVzID0gMDtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcztcbiAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyA9XG4gICAgICAgICAgICAgICAgICAgICgxIDw8ICgzMSAtIGNsejMyKDQyIHwgc3luY1RyYW5zaXRpb25MYW5lcykgKyAxKSkgLSAxO1xuICAgICAgICAgICAgICAgICAgbmV4dExhbmVzICY9IHBlbmRpbmdMYW5lcyAmIH4oc3VzcGVuZGVkTGFuZXMgJiB+cGluZ2VkTGFuZXMpO1xuICAgICAgICAgICAgICAgICAgbmV4dExhbmVzID1cbiAgICAgICAgICAgICAgICAgICAgbmV4dExhbmVzICYgMjAxMzI2Njc3XG4gICAgICAgICAgICAgICAgICAgICAgPyAobmV4dExhbmVzICYgMjAxMzI2Njc3KSB8IDFcbiAgICAgICAgICAgICAgICAgICAgICA6IG5leHRMYW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXh0TGFuZXMgfCAyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDAgIT09IG5leHRMYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgKChkaWRQZXJmb3JtU29tZVdvcmsgPSAhMCksXG4gICAgICAgICAgICAgICAgICBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCwgbmV4dExhbmVzKSk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIChuZXh0TGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gZ2V0TmV4dExhbmVzKFxuICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyBuZXh0TGFuZXMgOiAwXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgIDAgPT09IChuZXh0TGFuZXMgJiAzKSB8fFxuICAgICAgICAgICAgICAgICAgICBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIG5leHRMYW5lcykgfHxcbiAgICAgICAgICAgICAgICAgICAgKChkaWRQZXJmb3JtU29tZVdvcmsgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBuZXh0TGFuZXMpKTtcbiAgICAgICAgICAgIHJvb3QgPSByb290Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaWRQZXJmb3JtU29tZVdvcmspO1xuICAgICAgICBpc0ZsdXNoaW5nV29yayA9ICExO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2soKSB7XG4gICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPVxuICAgICAgICBkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgPVxuICAgICAgICBkaWRTY2hlZHVsZU1pY3JvdGFzayA9XG4gICAgICAgICAgITE7XG4gICAgICB2YXIgc3luY1RyYW5zaXRpb25MYW5lcyA9IDA7XG4gICAgICAwICE9PSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSAmJlxuICAgICAgICAoc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbigpICYmXG4gICAgICAgICAgKHN5bmNUcmFuc2l0aW9uTGFuZXMgPSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSksXG4gICAgICAgIChjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IDApKTtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IG5vdyQxKCksIHByZXYgPSBudWxsLCByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgICBudWxsICE9PSByb290O1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIG5leHQgPSByb290Lm5leHQsXG4gICAgICAgICAgbmV4dExhbmVzID0gc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBjdXJyZW50VGltZSk7XG4gICAgICAgIGlmICgwID09PSBuZXh0TGFuZXMpXG4gICAgICAgICAgKHJvb3QubmV4dCA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCA9PT0gcHJldiA/IChmaXJzdFNjaGVkdWxlZFJvb3QgPSBuZXh0KSA6IChwcmV2Lm5leHQgPSBuZXh0KSxcbiAgICAgICAgICAgIG51bGwgPT09IG5leHQgJiYgKGxhc3RTY2hlZHVsZWRSb290ID0gcHJldik7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICgocHJldiA9IHJvb3QpLCAwICE9PSBzeW5jVHJhbnNpdGlvbkxhbmVzIHx8IDAgIT09IChuZXh0TGFuZXMgJiAzKSlcbiAgICAgICAgKVxuICAgICAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICEwO1xuICAgICAgICByb290ID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKHN5bmNUcmFuc2l0aW9uTGFuZXMsICExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBjdXJyZW50VGltZSkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcyxcbiAgICAgICAgICBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXMsXG4gICAgICAgICAgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXMsXG4gICAgICAgICAgbGFuZXMgPSByb290LnBlbmRpbmdMYW5lcyAmIC02MjkxNDU2MTtcbiAgICAgICAgMCA8IGxhbmVzO1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihsYW5lcyksXG4gICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXgsXG4gICAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZXNbaW5kZXhdO1xuICAgICAgICBpZiAoLTEgPT09IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgaWYgKDAgPT09IChsYW5lICYgc3VzcGVuZGVkTGFuZXMpIHx8IDAgIT09IChsYW5lICYgcGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSk7XG4gICAgICAgIH0gZWxzZSBleHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZSAmJiAocm9vdC5leHBpcmVkTGFuZXMgfD0gbGFuZSk7XG4gICAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgICAgfVxuICAgICAgY3VycmVudFRpbWUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICBzdXNwZW5kZWRMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xuICAgICAgc3VzcGVuZGVkTGFuZXMgPSBnZXROZXh0TGFuZXMoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJvb3QgPT09IGN1cnJlbnRUaW1lID8gc3VzcGVuZGVkTGFuZXMgOiAwXG4gICAgICApO1xuICAgICAgcGluZ2VkTGFuZXMgPSByb290LmNhbGxiYWNrTm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gc3VzcGVuZGVkTGFuZXMgfHxcbiAgICAgICAgKHJvb3QgPT09IGN1cnJlbnRUaW1lICYmXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSkgfHxcbiAgICAgICAgbnVsbCAhPT0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0XG4gICAgICApXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbnVsbCAhPT0gcGluZ2VkTGFuZXMgJiYgY2FuY2VsQ2FsbGJhY2socGluZ2VkTGFuZXMpLFxuICAgICAgICAgIChyb290LmNhbGxiYWNrTm9kZSA9IG51bGwpLFxuICAgICAgICAgIChyb290LmNhbGxiYWNrUHJpb3JpdHkgPSAwKVxuICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICAwID09PSAoc3VzcGVuZGVkTGFuZXMgJiAzKSB8fFxuICAgICAgICBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIHN1c3BlbmRlZExhbmVzKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRUaW1lID0gc3VzcGVuZGVkTGFuZXMgJiAtc3VzcGVuZGVkTGFuZXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjdXJyZW50VGltZSAhPT0gcm9vdC5jYWxsYmFja1ByaW9yaXR5IHx8XG4gICAgICAgICAgKG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgICAgICBwaW5nZWRMYW5lcyAhPT0gZmFrZUFjdENhbGxiYWNrTm9kZSQxKVxuICAgICAgICApXG4gICAgICAgICAgY2FuY2VsQ2FsbGJhY2socGluZ2VkTGFuZXMpO1xuICAgICAgICBlbHNlIHJldHVybiBjdXJyZW50VGltZTtcbiAgICAgICAgc3dpdGNoIChsYW5lc1RvRXZlbnRQcmlvcml0eShzdXNwZW5kZWRMYW5lcykpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgICAgIHN1c3BlbmRlZExhbmVzID0gSWRsZVByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN1c3BlbmRlZExhbmVzID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgfVxuICAgICAgICBwaW5nZWRMYW5lcyA9IHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzay5iaW5kKG51bGwsIHJvb3QpO1xuICAgICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZVxuICAgICAgICAgID8gKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlLnB1c2gocGluZ2VkTGFuZXMpLFxuICAgICAgICAgICAgKHN1c3BlbmRlZExhbmVzID0gZmFrZUFjdENhbGxiYWNrTm9kZSQxKSlcbiAgICAgICAgICA6IChzdXNwZW5kZWRMYW5lcyA9IHNjaGVkdWxlQ2FsbGJhY2skMyhzdXNwZW5kZWRMYW5lcywgcGluZ2VkTGFuZXMpKTtcbiAgICAgICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gY3VycmVudFRpbWU7XG4gICAgICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gc3VzcGVuZGVkTGFuZXM7XG4gICAgICAgIHJldHVybiBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IHBpbmdlZExhbmVzICYmIGNhbmNlbENhbGxiYWNrKHBpbmdlZExhbmVzKTtcbiAgICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDI7XG4gICAgICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrKHJvb3QsIGRpZFRpbWVvdXQpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9IGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9ICExO1xuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7XG4gICAgICBpZiAoZmx1c2hQYXNzaXZlRWZmZWN0cygpICYmIHJvb3QuY2FsbGJhY2tOb2RlICE9PSBvcmlnaW5hbENhbGxiYWNrTm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwID0gZ2V0TmV4dExhbmVzKFxuICAgICAgICByb290LFxuICAgICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCA6IDBcbiAgICAgICk7XG4gICAgICBpZiAoMCA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDApIHJldHVybiBudWxsO1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3QoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwLFxuICAgICAgICBkaWRUaW1lb3V0XG4gICAgICApO1xuICAgICAgc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBub3ckMSgpKTtcbiAgICAgIHJldHVybiBudWxsICE9IHJvb3QuY2FsbGJhY2tOb2RlICYmXG4gICAgICAgIHJvb3QuY2FsbGJhY2tOb2RlID09PSBvcmlnaW5hbENhbGxiYWNrTm9kZVxuICAgICAgICA/IHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzay5iaW5kKG51bGwsIHJvb3QpXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIGxhbmVzKSB7XG4gICAgICBpZiAoZmx1c2hQYXNzaXZlRWZmZWN0cygpKSByZXR1cm4gbnVsbDtcbiAgICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9IG5lc3RlZFVwZGF0ZVNjaGVkdWxlZDtcbiAgICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9ICExO1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgbGFuZXMsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKSB7XG4gICAgICBjYWxsYmFja05vZGUgIT09IGZha2VBY3RDYWxsYmFja05vZGUkMSAmJlxuICAgICAgICBudWxsICE9PSBjYWxsYmFja05vZGUgJiZcbiAgICAgICAgY2FuY2VsQ2FsbGJhY2skMShjYWxsYmFja05vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUltbWVkaWF0ZVRhc2soY2IpIHtcbiAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgc3VwcG9ydHNNaWNyb3Rhc2tzXG4gICAgICAgID8gc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0XG4gICAgICAgICAgICAgID8gc2NoZWR1bGVDYWxsYmFjayQzKEltbWVkaWF0ZVByaW9yaXR5LCBjYilcbiAgICAgICAgICAgICAgOiBjYigpO1xuICAgICAgICAgIH0pXG4gICAgICAgIDogc2NoZWR1bGVDYWxsYmFjayQzKEltbWVkaWF0ZVByaW9yaXR5LCBjYik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpIHtcbiAgICAgIDAgPT09IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lICYmXG4gICAgICAgIChjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCkpO1xuICAgICAgcmV0dXJuIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnRhbmdsZUFzeW5jQWN0aW9uKHRyYW5zaXRpb24sIHRoZW5hYmxlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVycykge1xuICAgICAgICB2YXIgZW50YW5nbGVkTGlzdGVuZXJzID0gKGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBbXSk7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQgPSAwO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkTGFuZSA9IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSB7XG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBlbnRhbmdsZWRMaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50Kys7XG4gICAgICB0aGVuYWJsZS50aGVuKHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUsIHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUpO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKCkge1xuICAgICAgaWYgKFxuICAgICAgICAwID09PSAtLWN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVyc1xuICAgICAgKSB7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSAmJlxuICAgICAgICAgIChjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIik7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSAwO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykgKDAsIGxpc3RlbmVyc1tpXSkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hhaW5UaGVuYWJsZVZhbHVlKHRoZW5hYmxlLCByZXN1bHQpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXSxcbiAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUgPSB7XG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHJlc29sdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIHRoZW5hYmxlLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSAoMCwgbGlzdGVuZXJzW2ldKShyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgZm9yIChlcnJvciA9IDA7IGVycm9yIDwgbGlzdGVuZXJzLmxlbmd0aDsgZXJyb3IrKylcbiAgICAgICAgICAgICgwLCBsaXN0ZW5lcnNbZXJyb3JdKSh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlV2l0aE92ZXJyaWRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplVXBkYXRlUXVldWUoZmliZXIpIHtcbiAgICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0ge1xuICAgICAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICAgICAgbGFzdEJhc2VVcGRhdGU6IG51bGwsXG4gICAgICAgIHNoYXJlZDogeyBwZW5kaW5nOiBudWxsLCBsYW5lczogMCwgaGlkZGVuQ2FsbGJhY2tzOiBudWxsIH0sXG4gICAgICAgIGNhbGxiYWNrczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9PT0gY3VycmVudCAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50LmJhc2VTdGF0ZSxcbiAgICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IGN1cnJlbnQuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgICAgIGxhc3RCYXNlVXBkYXRlOiBjdXJyZW50Lmxhc3RCYXNlVXBkYXRlLFxuICAgICAgICAgIHNoYXJlZDogY3VycmVudC5zaGFyZWQsXG4gICAgICAgICAgY2FsbGJhY2tzOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVVcGRhdGUobGFuZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFuZTogbGFuZSxcbiAgICAgICAgdGFnOiBVcGRhdGVTdGF0ZSxcbiAgICAgICAgcGF5bG9hZDogbnVsbCxcbiAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG4gICAgICBpZiAobnVsbCA9PT0gdXBkYXRlUXVldWUpIHJldHVybiBudWxsO1xuICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG4gICAgICBpZiAoXG4gICAgICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gdXBkYXRlUXVldWUgJiZcbiAgICAgICAgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGVcbiAgICAgICkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsIHdpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhIGNhbGxiYWNrLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnQ6ICVzXCIsXG4gICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICApO1xuICAgICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChjb21wb25lbnROYW1lID0gdXBkYXRlUXVldWUucGVuZGluZyksXG4gICAgICAgICAgbnVsbCA9PT0gY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgPyAodXBkYXRlLm5leHQgPSB1cGRhdGUpXG4gICAgICAgICAgICA6ICgodXBkYXRlLm5leHQgPSBjb21wb25lbnROYW1lLm5leHQpLFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZS5uZXh0ID0gdXBkYXRlKSksXG4gICAgICAgICAgKHVwZGF0ZVF1ZXVlLnBlbmRpbmcgPSB1cGRhdGUpLFxuICAgICAgICAgICh1cGRhdGUgPSBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKSksXG4gICAgICAgICAgbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIG51bGwsIGxhbmUpLFxuICAgICAgICAgIHVwZGF0ZVxuICAgICAgICApO1xuICAgICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCB1cGRhdGVRdWV1ZSwgdXBkYXRlLCBsYW5lKTtcbiAgICAgIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSkge1xuICAgICAgZmliZXIgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSBmaWJlciAmJiAoKGZpYmVyID0gZmliZXIuc2hhcmVkKSwgMCAhPT0gKGxhbmUgJiA0MTk0MTc2KSkpIHtcbiAgICAgICAgdmFyIHF1ZXVlTGFuZXMgPSBmaWJlci5sYW5lcztcbiAgICAgICAgcXVldWVMYW5lcyAmPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgICAgbGFuZSB8PSBxdWV1ZUxhbmVzO1xuICAgICAgICBmaWJlci5sYW5lcyA9IGxhbmU7XG4gICAgICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGxhbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNhcHR1cmVkVXBkYXRlKSB7XG4gICAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSxcbiAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSwgcXVldWUgPT09IGN1cnJlbnQpXG4gICAgICApIHtcbiAgICAgICAgdmFyIG5ld0ZpcnN0ID0gbnVsbCxcbiAgICAgICAgICBuZXdMYXN0ID0gbnVsbDtcbiAgICAgICAgcXVldWUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG4gICAgICAgIGlmIChudWxsICE9PSBxdWV1ZSkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICAgICAgbGFuZTogcXVldWUubGFuZSxcbiAgICAgICAgICAgICAgdGFnOiBxdWV1ZS50YWcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHF1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbnVsbCA9PT0gbmV3TGFzdFxuICAgICAgICAgICAgICA/IChuZXdGaXJzdCA9IG5ld0xhc3QgPSBjbG9uZSlcbiAgICAgICAgICAgICAgOiAobmV3TGFzdCA9IG5ld0xhc3QubmV4dCA9IGNsb25lKTtcbiAgICAgICAgICAgIHF1ZXVlID0gcXVldWUubmV4dDtcbiAgICAgICAgICB9IHdoaWxlIChudWxsICE9PSBxdWV1ZSk7XG4gICAgICAgICAgbnVsbCA9PT0gbmV3TGFzdFxuICAgICAgICAgICAgPyAobmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGUpXG4gICAgICAgICAgICA6IChuZXdMYXN0ID0gbmV3TGFzdC5uZXh0ID0gY2FwdHVyZWRVcGRhdGUpO1xuICAgICAgICB9IGVsc2UgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIHF1ZXVlID0ge1xuICAgICAgICAgIGJhc2VTdGF0ZTogY3VycmVudC5iYXNlU3RhdGUsXG4gICAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBuZXdGaXJzdCxcbiAgICAgICAgICBsYXN0QmFzZVVwZGF0ZTogbmV3TGFzdCxcbiAgICAgICAgICBzaGFyZWQ6IGN1cnJlbnQuc2hhcmVkLFxuICAgICAgICAgIGNhbGxiYWNrczogY3VycmVudC5jYWxsYmFja3NcbiAgICAgICAgfTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgID8gKHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlKVxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5uZXh0ID0gY2FwdHVyZWRVcGRhdGUpO1xuICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpIHtcbiAgICAgIGlmIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKSB7XG4gICAgICAgIHZhciBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICAgICAgaWYgKG51bGwgIT09IGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlKSB0aHJvdyBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBwcm9wcyxcbiAgICAgIGluc3RhbmNlJGpzY29tcCQwLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMTtcbiAgICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZDtcbiAgICAgIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGUsXG4gICAgICAgIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGUsXG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuICAgICAgaWYgKG51bGwgIT09IHBlbmRpbmdRdWV1ZSkge1xuICAgICAgICBxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHBlbmRpbmdRdWV1ZSxcbiAgICAgICAgICBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgICAgICBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgbnVsbCA9PT0gbGFzdEJhc2VVcGRhdGVcbiAgICAgICAgICA/IChmaXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGUpXG4gICAgICAgICAgOiAobGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSk7XG4gICAgICAgIGxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgKHBlbmRpbmdRdWV1ZSA9IGN1cnJlbnQubGFzdEJhc2VVcGRhdGUpLFxuICAgICAgICAgIHBlbmRpbmdRdWV1ZSAhPT0gbGFzdEJhc2VVcGRhdGUgJiZcbiAgICAgICAgICAgIChudWxsID09PSBwZW5kaW5nUXVldWVcbiAgICAgICAgICAgICAgPyAoY3VycmVudC5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGUpXG4gICAgICAgICAgICAgIDogKHBlbmRpbmdRdWV1ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlKSxcbiAgICAgICAgICAgIChjdXJyZW50Lmxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUpKSk7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gZmlyc3RCYXNlVXBkYXRlKSB7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgICAgICAgbGFzdEJhc2VVcGRhdGUgPSAwO1xuICAgICAgICBjdXJyZW50ID0gZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUgPSBudWxsO1xuICAgICAgICBwZW5kaW5nUXVldWUgPSBmaXJzdEJhc2VVcGRhdGU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgdXBkYXRlTGFuZSA9IHBlbmRpbmdRdWV1ZS5sYW5lICYgLTUzNjg3MDkxMyxcbiAgICAgICAgICAgIGlzSGlkZGVuVXBkYXRlID0gdXBkYXRlTGFuZSAhPT0gcGVuZGluZ1F1ZXVlLmxhbmU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaXNIaWRkZW5VcGRhdGVcbiAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgICAgICA6IChyZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAwICE9PSB1cGRhdGVMYW5lICYmXG4gICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITApO1xuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQubmV4dCA9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgICAgICAgIHRhZzogcGVuZGluZ1F1ZXVlLnRhZyxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBlbmRpbmdRdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgICAgICAgICAgdmFyIG5leHRQcm9wcyA9IHByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2UkanNjb21wJDA7XG4gICAgICAgICAgICAgIHN3aXRjaCAocGFydGlhbFN0YXRlLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgUmVwbGFjZVN0YXRlOlxuICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlID0gcGFydGlhbFN0YXRlLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGFydGlhbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHBhcnRpYWxTdGF0ZS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlTGFuZS5tb2RlICYgOCkge1xuICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlLmNhbGwoaW5zdGFuY2UsIG5ld1N0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHBhcnRpYWxTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAgICAgICAgICAgICAgdXBkYXRlTGFuZS5mbGFncyA9ICh1cGRhdGVMYW5lLmZsYWdzICYgLTY1NTM3KSB8IDEyODtcbiAgICAgICAgICAgICAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gcGFydGlhbFN0YXRlLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV4dFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlID0gbmV4dFN0YXRlLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVMYW5lLm1vZGUgJiA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbChpbnN0YW5jZSwgbmV3U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICExO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHBhcnRpYWxTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBwYXJ0aWFsU3RhdGUgfHwgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGUpIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IGFzc2lnbih7fSwgbmV3U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgRm9yY2VVcGRhdGU6XG4gICAgICAgICAgICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9ICEwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVMYW5lID0gcGVuZGluZ1F1ZXVlLmNhbGxiYWNrO1xuICAgICAgICAgICAgbnVsbCAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY0KSxcbiAgICAgICAgICAgICAgaXNIaWRkZW5VcGRhdGUgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpLFxuICAgICAgICAgICAgICAoaXNIaWRkZW5VcGRhdGUgPSBxdWV1ZS5jYWxsYmFja3MpLFxuICAgICAgICAgICAgICBudWxsID09PSBpc0hpZGRlblVwZGF0ZVxuICAgICAgICAgICAgICAgID8gKHF1ZXVlLmNhbGxiYWNrcyA9IFt1cGRhdGVMYW5lXSlcbiAgICAgICAgICAgICAgICA6IGlzSGlkZGVuVXBkYXRlLnB1c2godXBkYXRlTGFuZSkpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0ge1xuICAgICAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgICAgICB0YWc6IHBlbmRpbmdRdWV1ZS50YWcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHBlbmRpbmdRdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgICAgICBjYWxsYmFjazogcGVuZGluZ1F1ZXVlLmNhbGxiYWNrLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICAgID8gKChmaXJzdFBlbmRpbmdVcGRhdGUgPSBjdXJyZW50ID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgICAgICAgKGxhc3RQZW5kaW5nVXBkYXRlID0gbmV3U3RhdGUpKVxuICAgICAgICAgICAgICAgIDogKGN1cnJlbnQgPSBjdXJyZW50Lm5leHQgPSBpc0hpZGRlblVwZGF0ZSksXG4gICAgICAgICAgICAgIChsYXN0QmFzZVVwZGF0ZSB8PSB1cGRhdGVMYW5lKTtcbiAgICAgICAgICBwZW5kaW5nUXVldWUgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcGVuZGluZ1F1ZXVlKVxuICAgICAgICAgICAgaWYgKCgocGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmcpLCBudWxsID09PSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0gcGVuZGluZ1F1ZXVlKSxcbiAgICAgICAgICAgICAgICAocGVuZGluZ1F1ZXVlID0gaXNIaWRkZW5VcGRhdGUubmV4dCksXG4gICAgICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlLm5leHQgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAocXVldWUubGFzdEJhc2VVcGRhdGUgPSBpc0hpZGRlblVwZGF0ZSksXG4gICAgICAgICAgICAgICAgKHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbCk7XG4gICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICBudWxsID09PSBjdXJyZW50ICYmIChsYXN0UGVuZGluZ1VwZGF0ZSA9IG5ld1N0YXRlKTtcbiAgICAgICAgcXVldWUuYmFzZVN0YXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjdXJyZW50O1xuICAgICAgICBudWxsID09PSBmaXJzdEJhc2VVcGRhdGUgJiYgKHF1ZXVlLnNoYXJlZC5sYW5lcyA9IDApO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gbGFzdEJhc2VVcGRhdGU7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbGFzdEJhc2VVcGRhdGU7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiBcIiArXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICApO1xuICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SGlkZGVuQ2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaGlkZGVuQ2FsbGJhY2tzID0gdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcztcbiAgICAgIGlmIChudWxsICE9PSBoaWRkZW5DYWxsYmFja3MpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9IG51bGwsIHVwZGF0ZVF1ZXVlID0gMDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA8IGhpZGRlbkNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgdXBkYXRlUXVldWUrK1xuICAgICAgICApXG4gICAgICAgICAgY2FsbENhbGxiYWNrKGhpZGRlbkNhbGxiYWNrc1t1cGRhdGVRdWV1ZV0sIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBjYWxsYmFja3MgPSB1cGRhdGVRdWV1ZS5jYWxsYmFja3M7XG4gICAgICBpZiAobnVsbCAhPT0gY2FsbGJhY2tzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcyA9IG51bGwsIHVwZGF0ZVF1ZXVlID0gMDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA8IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgdXBkYXRlUXVldWUrK1xuICAgICAgICApXG4gICAgICAgICAgY2FsbENhbGxiYWNrKGNhbGxiYWNrc1t1cGRhdGVRdWV1ZV0sIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICAgICAgaWYgKG9iamVjdElzKG9iakEsIG9iakIpKSByZXR1cm4gITA7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmpBIHx8XG4gICAgICAgIG51bGwgPT09IG9iakEgfHxcbiAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9iakIgfHxcbiAgICAgICAgbnVsbCA9PT0gb2JqQlxuICAgICAgKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKSxcbiAgICAgICAga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgZm9yIChrZXlzQiA9IDA7IGtleXNCIDwga2V5c0EubGVuZ3RoOyBrZXlzQisrKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5c0Fba2V5c0JdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwgY3VycmVudEtleSkgfHxcbiAgICAgICAgICAhb2JqZWN0SXMob2JqQVtjdXJyZW50S2V5XSwgb2JqQltjdXJyZW50S2V5XSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVGhlbmFibGVTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7IGRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZTogITEsIHRoZW5hYmxlczogW10gfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNUaGVuYWJsZVJlc29sdmVkKHRoZW5hYmxlKSB7XG4gICAgICB0aGVuYWJsZSA9IHRoZW5hYmxlLnN0YXR1cztcbiAgICAgIHJldHVybiBcImZ1bGZpbGxlZFwiID09PSB0aGVuYWJsZSB8fCBcInJlamVjdGVkXCIgPT09IHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDEoKSB7fVxuICAgIGZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmRpZFVzZVByb21pc2UgPSAhMCk7XG4gICAgICB2YXIgdHJhY2tlZFRoZW5hYmxlcyA9IHRoZW5hYmxlU3RhdGUudGhlbmFibGVzO1xuICAgICAgaW5kZXggPSB0cmFja2VkVGhlbmFibGVzW2luZGV4XTtcbiAgICAgIHZvaWQgMCA9PT0gaW5kZXhcbiAgICAgICAgPyB0cmFja2VkVGhlbmFibGVzLnB1c2godGhlbmFibGUpXG4gICAgICAgIDogaW5kZXggIT09IHRoZW5hYmxlICYmXG4gICAgICAgICAgKHRoZW5hYmxlU3RhdGUuZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlIHx8XG4gICAgICAgICAgICAoKHRoZW5hYmxlU3RhdGUuZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudCB3YXMgc3VzcGVuZGVkIGJ5IGFuIHVuY2FjaGVkIHByb21pc2UuIENyZWF0aW5nIHByb21pc2VzIGluc2lkZSBhIENsaWVudCBDb21wb25lbnQgb3IgaG9vayBpcyBub3QgeWV0IHN1cHBvcnRlZCwgZXhjZXB0IHZpYSBhIFN1c3BlbnNlLWNvbXBhdGlibGUgbGlicmFyeSBvciBmcmFtZXdvcmsuXCJcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgIHRoZW5hYmxlLnRoZW4obm9vcCQxLCBub29wJDEpLFxuICAgICAgICAgICh0aGVuYWJsZSA9IGluZGV4KSk7XG4gICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAoKHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZS5yZWFzb24pLFxuICAgICAgICAgICAgY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2godGhlbmFibGVTdGF0ZSksXG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGVuYWJsZS5zdGF0dXMpXG4gICAgICAgICAgICB0aGVuYWJsZS50aGVuKG5vb3AkMSwgbm9vcCQxKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG51bGwgIT09IHRoZW5hYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICAgMTAwIDwgdGhlbmFibGVTdGF0ZS5zaGVsbFN1c3BlbmRDb3VudGVyXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiYXN5bmMvYXdhaXQgaXMgbm90IHlldCBzdXBwb3J0ZWQgaW4gQ2xpZW50IENvbXBvbmVudHMsIG9ubHkgU2VydmVyIENvbXBvbmVudHMuIFRoaXMgZXJyb3IgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGFjY2lkZW50YWxseSBhZGRpbmcgYCd1c2UgY2xpZW50J2AgdG8gYSBtb2R1bGUgdGhhdCB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGZvciB0aGUgc2VydmVyLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlID0gdGhlbmFibGU7XG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZS50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAoKHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZS5yZWFzb24pLFxuICAgICAgICAgICAgICAgIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKHRoZW5hYmxlU3RhdGUpLFxuICAgICAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSAhMDtcbiAgICAgICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gICAgICBpZiAobnVsbCA9PT0gc3VzcGVuZGVkVGhlbmFibGUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgYSBzdXNwZW5kZWQgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgdGhlbmFibGUgPSBzdXNwZW5kZWRUaGVuYWJsZTtcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbiAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gITE7XG4gICAgICByZXR1cm4gdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKHJlamVjdGVkUmVhc29uKSB7XG4gICAgICBpZiAocmVqZWN0ZWRSZWFzb24gPT09IFN1c3BlbnNlRXhjZXB0aW9uKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkhvb2tzIGFyZSBub3Qgc3VwcG9ydGVkIGluc2lkZSBhbiBhc3luYyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGFjY2lkZW50YWxseSBhZGRpbmcgYCd1c2UgY2xpZW50J2AgdG8gYSBtb2R1bGUgdGhhdCB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGZvciB0aGUgc2VydmVyLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hEZWJ1Z0luZm8oZGVidWdJbmZvKSB7XG4gICAgICB2YXIgcHJldmlvdXNEZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgbnVsbCAhPSBkZWJ1Z0luZm8gJiZcbiAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPVxuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzRGVidWdJbmZvXG4gICAgICAgICAgICA/IGRlYnVnSW5mb1xuICAgICAgICAgICAgOiBwcmV2aW91c0RlYnVnSW5mby5jb25jYXQoZGVidWdJbmZvKSk7XG4gICAgICByZXR1cm4gcHJldmlvdXNEZWJ1Z0luZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50LCBmaWJlciwgcmV0dXJuRmliZXIpIHtcbiAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50LnByb3BzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoXCJjaGlsZHJlblwiICE9PSBrZXkgJiYgXCJrZXlcIiAhPT0ga2V5KSB7XG4gICAgICAgICAgbnVsbCA9PT0gZmliZXIgJiZcbiAgICAgICAgICAgICgoZmliZXIgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIDApKSxcbiAgICAgICAgICAgIChmaWJlci5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAoZmliZXIucmV0dXJuID0gcmV0dXJuRmliZXIpKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yZWRLZXkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsXG4gICAgICAgICAgICAgICAgZXJyb3JlZEtleVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW53cmFwVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyJDE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxICs9IDE7XG4gICAgICBudWxsID09PSB0aGVuYWJsZVN0YXRlJDEgJiYgKHRoZW5hYmxlU3RhdGUkMSA9IGNyZWF0ZVRoZW5hYmxlU3RhdGUoKSk7XG4gICAgICByZXR1cm4gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSQxLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2VyY2VSZWYod29ya0luUHJvZ3Jlc3MsIGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnByb3BzLnJlZjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnJlZiA9IHZvaWQgMCAhPT0gZWxlbWVudCA/IGVsZW1lbnQgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdBIFJlYWN0IEVsZW1lbnQgZnJvbSBhbiBvbGRlciB2ZXJzaW9uIG9mIFJlYWN0IHdhcyByZW5kZXJlZC4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJdCBjYW4gaGFwcGVuIGlmOlxcbi0gTXVsdGlwbGUgY29waWVzIG9mIHRoZSBcInJlYWN0XCIgcGFja2FnZSBpcyB1c2VkLlxcbi0gQSBsaWJyYXJ5IHByZS1idW5kbGVkIGFuIG9sZCBjb3B5IG9mIFwicmVhY3RcIiBvciBcInJlYWN0L2pzeC1ydW50aW1lXCIuXFxuLSBBIGNvbXBpbGVyIHRyaWVzIHRvIFwiaW5saW5lXCIgSlNYIGluc3RlYWQgb2YgdXNpbmcgdGhlIHJ1bnRpbWUuJ1xuICAgICAgICApO1xuICAgICAgcmV0dXJuRmliZXIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpO1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArXG4gICAgICAgICAgKFwiW29iamVjdCBPYmplY3RdXCIgPT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgIDogcmV0dXJuRmliZXIpICtcbiAgICAgICAgICBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBpbnZhbGlkQ2hpbGQpIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1twYXJlbnROYW1lXSB8fFxuICAgICAgICAoKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1twYXJlbnROYW1lXSA9ICEwKSxcbiAgICAgICAgKGludmFsaWRDaGlsZCA9XG4gICAgICAgICAgaW52YWxpZENoaWxkLmRpc3BsYXlOYW1lIHx8IGludmFsaWRDaGlsZC5uYW1lIHx8IFwiQ29tcG9uZW50XCIpLFxuICAgICAgICAzID09PSByZXR1cm5GaWJlci50YWdcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmIHlvdSByZXR1cm4gJXMgaW5zdGVhZCBvZiA8JXMgLz4gZnJvbSByZW5kZXIuIE9yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlxcbiAgcm9vdC5yZW5kZXIoJXMpXCIsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGRcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmIHlvdSByZXR1cm4gJXMgaW5zdGVhZCBvZiA8JXMgLz4gZnJvbSByZW5kZXIuIE9yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlxcbiAgPCVzPnslc308LyVzPlwiLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgcGFyZW50TmFtZSxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBwYXJlbnROYW1lXG4gICAgICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgaW52YWxpZENoaWxkKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICBvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nW3BhcmVudE5hbWVdIHx8XG4gICAgICAgICgob3duZXJIYXNTeW1ib2xUeXBlV2FybmluZ1twYXJlbnROYW1lXSA9ICEwKSxcbiAgICAgICAgKGludmFsaWRDaGlsZCA9IFN0cmluZyhpbnZhbGlkQ2hpbGQpKSxcbiAgICAgICAgMyA9PT0gcmV0dXJuRmliZXIudGFnXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlN5bWJvbHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLlxcbiAgcm9vdC5yZW5kZXIoJXMpXCIsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4gIDwlcz4lczwvJXM+XCIsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWUsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgcGFyZW50TmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIHZhciBkZWxldGlvbnMgPSByZXR1cm5GaWJlci5kZWxldGlvbnM7XG4gICAgICAgICAgbnVsbCA9PT0gZGVsZXRpb25zXG4gICAgICAgICAgICA/ICgocmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2NoaWxkVG9EZWxldGVdKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyLmZsYWdzIHw9IDE2KSlcbiAgICAgICAgICAgIDogZGVsZXRpb25zLnB1c2goY2hpbGRUb0RlbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgICAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDsgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpLFxuICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4oY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZm9yICh2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG5ldyBNYXAoKTsgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZC5rZXlcbiAgICAgICAgICAgID8gZXhpc3RpbmdDaGlsZHJlbi5zZXQoY3VycmVudEZpcnN0Q2hpbGQua2V5LCBjdXJyZW50Rmlyc3RDaGlsZClcbiAgICAgICAgICAgIDogZXhpc3RpbmdDaGlsZHJlbi5zZXQoY3VycmVudEZpcnN0Q2hpbGQuaW5kZXgsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMpIHtcbiAgICAgICAgZmliZXIgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzKTtcbiAgICAgICAgZmliZXIuaW5kZXggPSAwO1xuICAgICAgICBmaWJlci5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgICAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgICAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpXG4gICAgICAgICAgcmV0dXJuIChuZXdGaWJlci5mbGFncyB8PSAxMDQ4NTc2KSwgbGFzdFBsYWNlZEluZGV4O1xuICAgICAgICBuZXdJbmRleCA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IG5ld0luZGV4KVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobmV3SW5kZXggPSBuZXdJbmRleC5pbmRleCksXG4gICAgICAgICAgICBuZXdJbmRleCA8IGxhc3RQbGFjZWRJbmRleFxuICAgICAgICAgICAgICA/ICgobmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQpLCBsYXN0UGxhY2VkSW5kZXgpXG4gICAgICAgICAgICAgIDogbmV3SW5kZXhcbiAgICAgICAgICApO1xuICAgICAgICBuZXdGaWJlci5mbGFncyB8PSAzMzU1NDQzNDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgIG51bGwgPT09IG5ld0ZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIChuZXdGaWJlci5mbGFncyB8PSAzMzU1NDQzNCk7XG4gICAgICAgIHJldHVybiBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgNiAhPT0gY3VycmVudC50YWcpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgICAgICAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCk7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICBlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgZWxlbWVudC5rZXlcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQsIGN1cnJlbnQsIHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIChjdXJyZW50LmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fFxuICAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGN1cnJlbnQsIGVsZW1lbnQpIHx8XG4gICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVsZW1lbnRUeXBlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGVsZW1lbnRUeXBlICYmXG4gICAgICAgICAgICAgIGVsZW1lbnRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgY2FsbExhenlJbml0SW5ERVYoZWxlbWVudFR5cGUpID09PSBjdXJyZW50LnR5cGUpKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcykpLFxuICAgICAgICAgICAgY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpLFxuICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgICBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgNCAhPT0gY3VycmVudC50YWcgfHxcbiAgICAgICAgICBjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvICE9PSBwb3J0YWwuY29udGFpbmVySW5mbyB8fFxuICAgICAgICAgIGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKSksXG4gICAgICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBsYW5lcywga2V5KSB7XG4gICAgICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IDcgIT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICBmcmFnbWVudCxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQpO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICBjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG5ld0NoaWxkID0gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgICAgICAgICAgICAgXCJcIiArIG5ld0NoaWxkLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAobmV3Q2hpbGQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIG5ld0NoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBfcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm87XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZC50aGVuKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKF9wcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGNyZWF0ZUNoaWxkKFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBfcHJldkRlYnVnSW5mbyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAgICAgdmFyIGtleSA9IG51bGwgIT09IG9sZEZpYmVyID8gb2xkRmliZXIua2V5IDogbnVsbDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gbnVsbCAhPT0ga2V5XG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBcIlwiICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQua2V5ID09PSBrZXlcbiAgICAgICAgICAgICAgICA/ICgoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcilcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQua2V5ID09PSBrZXlcbiAgICAgICAgICAgICAgICA/IHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVTbG90KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGtleSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBrZXkgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSB1cGRhdGVGcmFnbWVudChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0ga2V5O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0ga2V5KSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG5ld0lkeCxcbiAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGwpLFxuICAgICAgICAgICAgdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGV4aXN0aW5nQ2hpbGRyZW4sIFwiXCIgKyBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChuZXdJZHggPVxuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5nZXQoXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5ld0NoaWxkLmtleSA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICAgICAgKSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGV4aXN0aW5nQ2hpbGRyZW4pLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID1cbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICkgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIF9wcmV2RGVidWdJbmZvNyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IF9wcmV2RGVidWdJbmZvNztcbiAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKG5ld0lkeCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbCksXG4gICAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGV4aXN0aW5nQ2hpbGRyZW4pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChfcHJldkRlYnVnSW5mbzcgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm83KSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCwga25vd25LZXlzKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgY2hpbGQgfHwgbnVsbCA9PT0gY2hpbGQpIHJldHVybiBrbm93bktleXM7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBrZXkpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGtub3duS2V5cykge1xuICAgICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYod29ya0luUHJvZ3Jlc3MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSBhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSBkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIFxcdTIwMTQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCBjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIixcbiAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAoY2hpbGQgPSBjYWxsTGF6eUluaXRJbkRFVihjaGlsZCkpLFxuICAgICAgICAgICAgICB3YXJuT25JbnZhbGlkS2V5KHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtub3duS2V5cztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGRyZW4sXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbCxcbiAgICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG51bGwsXG4gICAgICAgICAgICBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgICAgICBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBuZXdJZHgrK1xuICAgICAgICApIHtcbiAgICAgICAgICBvbGRGaWJlci5pbmRleCA+IG5ld0lkeFxuICAgICAgICAgICAgPyAoKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyKSwgKG9sZEZpYmVyID0gbnVsbCkpXG4gICAgICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5ld0ZpYmVyKSB7XG4gICAgICAgICAgICBudWxsID09PSBvbGRGaWJlciAmJiAob2xkRmliZXIgPSBuZXh0T2xkRmliZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIG5ld0ZpYmVyLFxuICAgICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICk7XG4gICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgb2xkRmliZXIgJiZcbiAgICAgICAgICAgIG51bGwgPT09IG5ld0ZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdJZHgpO1xuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcilcbiAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyKTtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpLFxuICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpLFxuICAgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSBvbGRGaWJlcikge1xuICAgICAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKVxuICAgICAgICAgICAgKG9sZEZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBvbGRGaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG9sZEZpYmVyKSk7XG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgb2xkRmliZXIgPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7XG4gICAgICAgICAgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIG5ld0lkeCsrXG4gICAgICAgIClcbiAgICAgICAgICAobmV4dE9sZEZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApKSxcbiAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlciAmJlxuICAgICAgICAgICAgICAoKGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dE9sZEZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAgIG9sZEZpYmVyLmRlbGV0ZShcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5leHRPbGRGaWJlci5rZXkgPyBuZXdJZHggOiBuZXh0T2xkRmliZXIua2V5XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgICBuZXh0T2xkRmliZXIsXG4gICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgbmV3SWR4XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5leHRPbGRGaWJlcilcbiAgICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXh0T2xkRmliZXIpLFxuICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG5leHRPbGRGaWJlcikpO1xuICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgb2xkRmliZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCk7XG4gICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZHJlbixcbiAgICAgICAgbGFuZXNcbiAgICAgICkge1xuICAgICAgICBpZiAobnVsbCA9PSBuZXdDaGlsZHJlbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkFuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci5cIik7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG51bGwsXG4gICAgICAgICAgICBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgICAgICBuZXh0T2xkRmliZXIgPSBudWxsLFxuICAgICAgICAgICAga25vd25LZXlzID0gbnVsbCxcbiAgICAgICAgICAgIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgICAgbnVsbCAhPT0gb2xkRmliZXIgJiYgIXN0ZXAuZG9uZTtcbiAgICAgICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgICAgICApIHtcbiAgICAgICAgICBvbGRGaWJlci5pbmRleCA+IG5ld0lkeFxuICAgICAgICAgICAgPyAoKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyKSwgKG9sZEZpYmVyID0gbnVsbCkpXG4gICAgICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXdGaWJlcikge1xuICAgICAgICAgICAgbnVsbCA9PT0gb2xkRmliZXIgJiYgKG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdGaWJlcixcbiAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgIG9sZEZpYmVyICYmXG4gICAgICAgICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KTtcbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXIpXG4gICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcik7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGVwLmRvbmUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlciksXG4gICAgICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCksXG4gICAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IG9sZEZpYmVyKSB7XG4gICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKVxuICAgICAgICAgICAgKG9sZEZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBvbGRGaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG9sZEZpYmVyKSk7XG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgb2xkRmliZXIgPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7XG4gICAgICAgICAgIXN0ZXAuZG9uZTtcbiAgICAgICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgICAgICApXG4gICAgICAgICAgKG5leHRPbGRGaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIgJiZcbiAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5leHRPbGRGaWJlcixcbiAgICAgICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICBvbGRGaWJlci5kZWxldGUoXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBuZXh0T2xkRmliZXIua2V5ID8gbmV3SWR4IDogbmV4dE9sZEZpYmVyLmtleVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXh0T2xkRmliZXIpXG4gICAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV4dE9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBuZXh0T2xkRmliZXIpKTtcbiAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgIG9sZEZpYmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgbGFuZXNcbiAgICAgICkge1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICBudWxsICE9PSBuZXdDaGlsZCAmJlxuICAgICAgICAgIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiZcbiAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgJiZcbiAgICAgICAgICAodmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBudWxsLCByZXR1cm5GaWJlciksXG4gICAgICAgICAgKG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4pKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICB2YXIgcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgPSBuZXdDaGlsZC5rZXk7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBuZXdDaGlsZC50eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKDcgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdPd25lciA9IG5ld0NoaWxkLl9vd25lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBsYW5lcywgcmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLmVsZW1lbnRUeXBlID09PSBrZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkXG4gICAgICAgICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2Yga2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBrZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsTGF6eUluaXRJbkRFVihrZXkpID09PSBjdXJyZW50Rmlyc3RDaGlsZC50eXBlKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z093bmVyID0gbmV3Q2hpbGQuX293bmVyO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFXG4gICAgICAgICAgICAgICAgICA/ICgobGFuZXMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMobmV3Q2hpbGQsIGxhbmVzLCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSlcbiAgICAgICAgICAgICAgICAgIDogKChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgY29lcmNlUmVmKGxhbmVzLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBwbGFjZVNpbmdsZUNoaWxkKHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm87XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gcHJldkRlYnVnSW5mby5rZXk7XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkLmtleSA9PT0gbmV3Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICA0ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWcgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uY29udGFpbmVySW5mbyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uY2hpbGRyZW4gfHwgW11cbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbmVzID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKFxuICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcik7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZHJlbkFycmF5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAga2V5ID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCk7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2Yga2V5KVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkFuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IGtleS5jYWxsKG5ld0NoaWxkKTtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZHJlbiA9PT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDAgIT09IHJldHVybkZpYmVyLnRhZyB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiAhPT1cbiAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXR1cm5GaWJlci50eXBlKSB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JdXCIgIT09XG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGRyZW4pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIHx8XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlVzaW5nIEl0ZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgdW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gWW91IG1heSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb20oKWAgb3IgdGhlIGBbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gWW91IGNhbiBhbHNvIHVzZSBhbiBJdGVyYWJsZSB0aGF0IGNhbiBpdGVyYXRlIG11bHRpcGxlIHRpbWVzIG92ZXIgdGhlIHNhbWUgaXRlbXMuXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9ICEwKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBuZXdDaGlsZC5lbnRyaWVzICE9PSBrZXkgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzIHx8XG4gICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgPSAhMCkpO1xuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgIG5ld0NoaWxkcmVuLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChwcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChwcmV2RGVidWdJbmZvID0gXCJcIiArIG5ld0NoaWxkKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkICYmIDYgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZ1xuICAgICAgICAgICAgICA/IChkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGxhbmVzID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHByZXZEZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSlcbiAgICAgICAgICAgICAgOiAoZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgICAgICAobGFuZXMgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbGFuZXMpKSxcbiAgICAgICAgICAgIHBsYWNlU2luZ2xlQ2hpbGQocmV0dXJuRmliZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgICAgIHZhciBwcmV2RGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG4gICAgICAgICAgdmFyIGZpcnN0Q2hpbGRGaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBmaXJzdENoaWxkRmliZXI7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBpZiAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24pIHRocm93IHg7XG4gICAgICAgICAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoMjksIHgsIG51bGwsIHJldHVybkZpYmVyLm1vZGUpO1xuICAgICAgICAgIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gICAgICAgICAgZmliZXIucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgdmFyIGRlYnVnSW5mbyA9IChmaWJlci5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyk7XG4gICAgICAgICAgZmliZXIuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlci5fZGVidWdPd25lcjtcbiAgICAgICAgICBpZiAobnVsbCAhPSBkZWJ1Z0luZm8pXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGVidWdJbmZvLmxlbmd0aCAtIDE7IDAgPD0gaTsgaS0tKVxuICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGRlYnVnSW5mb1tpXS5zdGFjaykge1xuICAgICAgICAgICAgICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZGVidWdJbmZvW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoSGlkZGVuQ29udGV4dChmaWJlciwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyA9IGVudGFuZ2xlZFJlbmRlckxhbmVzO1xuICAgICAgcHVzaChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcywgZmliZXIpO1xuICAgICAgcHVzaChjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyB8IGNvbnRleHQuYmFzZUxhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKGZpYmVyKSB7XG4gICAgICBwdXNoKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZW50YW5nbGVkUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgICAgIHB1c2goXG4gICAgICAgIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsXG4gICAgICAgIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudCxcbiAgICAgICAgZmliZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEhpZGRlbkNvbnRleHQoZmliZXIpIHtcbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICBwb3AoY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcG9wKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBoYW5kbGVyLmFsdGVybmF0ZTtcbiAgICAgIHB1c2goXG4gICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IsXG4gICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrLFxuICAgICAgICBoYW5kbGVyXG4gICAgICApO1xuICAgICAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgaGFuZGxlciwgaGFuZGxlcik7XG4gICAgICBudWxsID09PSBzaGVsbEJvdW5kYXJ5ICYmXG4gICAgICAgIChudWxsID09PSBjdXJyZW50IHx8IG51bGwgIT09IGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgID8gKHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyKVxuICAgICAgICAgIDogbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmIChzaGVsbEJvdW5kYXJ5ID0gaGFuZGxlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gICAgICBpZiAoMjIgPT09IGZpYmVyLnRhZykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBmaWJlciksXG4gICAgICAgICAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKSxcbiAgICAgICAgICBudWxsID09PSBzaGVsbEJvdW5kYXJ5KVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIChzaGVsbEJvdW5kYXJ5ID0gZmliZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKGZpYmVyKSB7XG4gICAgICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgZmliZXIpO1xuICAgICAgcHVzaChcbiAgICAgICAgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsXG4gICAgICAgIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQsXG4gICAgICAgIGZpYmVyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BTdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgICAgIHBvcChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgc2hlbGxCb3VuZGFyeSA9PT0gZmliZXIgJiYgKHNoZWxsQm91bmRhcnkgPSBudWxsKTtcbiAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpIHtcbiAgICAgIGZvciAodmFyIG5vZGUgPSByb3c7IG51bGwgIT09IG5vZGU7ICkge1xuICAgICAgICBpZiAoMTMgPT09IG5vZGUudGFnKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgIT09IHN0YXRlICYmXG4gICAgICAgICAgICAoKHN0YXRlID0gc3RhdGUuZGVoeWRyYXRlZCksXG4gICAgICAgICAgICBudWxsID09PSBzdGF0ZSB8fFxuICAgICAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKHN0YXRlKSB8fFxuICAgICAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdGF0ZSkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgMTkgPT09IG5vZGUudGFnICYmXG4gICAgICAgICAgdm9pZCAwICE9PSBub2RlLm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXJcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKDAgIT09IChub2RlLmZsYWdzICYgMTI4KSkgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAobnVsbCAhPT0gbm9kZS5jaGlsZCkge1xuICAgICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gcm93KSBicmVhaztcbiAgICAgICAgZm9yICg7IG51bGwgPT09IG5vZGUuc2libGluZzsgKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSByb3cpIHJldHVybiBudWxsO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKSB7XG4gICAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcbiAgICAgIG51bGwgPT09IGhvb2tUeXBlc0RldlxuICAgICAgICA/IChob29rVHlwZXNEZXYgPSBbaG9va05hbWVdKVxuICAgICAgICA6IGhvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCkge1xuICAgICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IGhvb2tUeXBlc0RldiAmJlxuICAgICAgICAoaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYrKyxcbiAgICAgICAgaG9va1R5cGVzRGV2W2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2XSAhPT0gaG9va05hbWUpXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKFxuICAgICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDFcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSksXG4gICAgICAgICAgbnVsbCAhPT0gaG9va1R5cGVzRGV2KVxuICAgICAgICApIHtcbiAgICAgICAgICBmb3IgKHZhciB0YWJsZSA9IFwiXCIsIGkgPSAwOyBpIDw9IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvbGRIb29rTmFtZSA9IGhvb2tUeXBlc0RldltpXSxcbiAgICAgICAgICAgICAgbmV3SG9va05hbWUgPVxuICAgICAgICAgICAgICAgIGkgPT09IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID8gaG9va05hbWUgOiBvbGRIb29rTmFtZTtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG9sZEhvb2tOYW1lID0gaSArIDEgKyBcIi4gXCIgKyBvbGRIb29rTmFtZTtcbiAgICAgICAgICAgICAgMzAgPiBvbGRIb29rTmFtZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgb2xkSG9va05hbWUgKz0gXCIgXCI7XG4gICAgICAgICAgICBvbGRIb29rTmFtZSArPSBuZXdIb29rTmFtZSArIFwiXFxuXCI7XG4gICAgICAgICAgICB0YWJsZSArPSBvbGRIb29rTmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgaGFzIGRldGVjdGVkIGEgY2hhbmdlIGluIHRoZSBvcmRlciBvZiBIb29rcyBjYWxsZWQgYnkgJXMuIFRoaXMgd2lsbCBsZWFkIHRvIGJ1Z3MgYW5kIGVycm9ycyBpZiBub3QgZml4ZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZSBSdWxlcyBvZiBIb29rczogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rc1xcblxcbiAgIFByZXZpb3VzIHJlbmRlciAgICAgICAgICAgIE5leHQgcmVuZGVyXFxuICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuJXMgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cXG5cIixcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICB0YWJsZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcykge1xuICAgICAgdm9pZCAwID09PSBkZXBzIHx8XG4gICAgICAgIG51bGwgPT09IGRlcHMgfHxcbiAgICAgICAgaXNBcnJheUltcGwoZGVwcykgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIiVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgdGhhdCBpcyBub3QgYW4gYXJyYXkgKGluc3RlYWQsIHJlY2VpdmVkIGAlc2ApLiBXaGVuIHNwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuXCIsXG4gICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYsXG4gICAgICAgICAgdHlwZW9mIGRlcHNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7XG4gICAgICBkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpIHx8XG4gICAgICAgIChkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3RET00udXNlRm9ybVN0YXRlIGhhcyBiZWVuIHJlbmFtZWQgdG8gUmVhY3QudXNlQWN0aW9uU3RhdGUuIFBsZWFzZSB1cGRhdGUgJXMgdG8gdXNlIFJlYWN0LnVzZUFjdGlvblN0YXRlLlwiLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SW52YWxpZEhvb2tFcnJvcigpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICAgICAgaWYgKGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKSByZXR1cm4gITE7XG4gICAgICBpZiAobnVsbCA9PT0gcHJldkRlcHMpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuXCIsXG4gICAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldlxuICAgICAgICAgICksXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgIG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSBvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcblByZXZpb3VzOiAlc1xcbkluY29taW5nOiAlc1wiLFxuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2LFxuICAgICAgICAgIFwiW1wiICsgcHJldkRlcHMuam9pbihcIiwgXCIpICsgXCJdXCIsXG4gICAgICAgICAgXCJbXCIgKyBuZXh0RGVwcy5qb2luKFwiLCBcIikgKyBcIl1cIlxuICAgICAgICApO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIW9iamVjdElzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHJldHVybiAhMTtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcHJvcHMsXG4gICAgICBzZWNvbmRBcmcsXG4gICAgICBuZXh0UmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHJlbmRlckxhbmVzID0gbmV4dFJlbmRlckxhbmVzO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgaG9va1R5cGVzRGV2ID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzIDogbnVsbDtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgY3VycmVudC50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgaWYgKFxuICAgICAgICBcIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIiA9PT1cbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQ29tcG9uZW50KSB8fFxuICAgICAgICBcIltvYmplY3QgQXN5bmNHZW5lcmF0b3JGdW5jdGlvbl1cIiA9PT1cbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQ29tcG9uZW50KVxuICAgICAgKVxuICAgICAgICAobmV4dFJlbmRlckxhbmVzID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihcbiAgICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxXG4gICAgICAgICkpLFxuICAgICAgICAgIGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50LmhhcyhuZXh0UmVuZGVyTGFuZXMpIHx8XG4gICAgICAgICAgICAoZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQuYWRkKG5leHRSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImFzeW5jL2F3YWl0IGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGluIENsaWVudCBDb21wb25lbnRzLCBvbmx5IFNlcnZlciBDb21wb25lbnRzLiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBmb3IgdGhlIHNlcnZlci5cIlxuICAgICAgICAgICAgKSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gMDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPVxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgID8gSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVlxuICAgICAgICAgIDogbnVsbCAhPT0gaG9va1R5cGVzRGV2XG4gICAgICAgICAgICA/IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVZcbiAgICAgICAgICAgIDogSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSBuZXh0UmVuZGVyTGFuZXMgPVxuICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpICE9PSBOb01vZGU7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjYWxsQ29tcG9uZW50SW5ERVYoQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gITE7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgJiZcbiAgICAgICAgKGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4oXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIHNlY29uZEFyZ1xuICAgICAgICApKTtcbiAgICAgIGlmIChuZXh0UmVuZGVyTGFuZXMpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4oXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgc2Vjb25kQXJnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGhvb2tUeXBlc0RldjtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llc1xuICAgICAgICA/IG51bGwgIT09IHRoZW5hYmxlU3RhdGUgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgICAgICBmaXJzdENvbnRleHQ6IG51bGwsXG4gICAgICAgICAgICBfZGVidWdUaGVuYWJsZVN0YXRlOiB0aGVuYWJsZVN0YXRlXG4gICAgICAgICAgfSlcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzLl9kZWJ1Z1RoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZVN0YXRlKTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gICAgICB2YXIgZGlkUmVuZGVyVG9vRmV3SG9va3MgPVxuICAgICAgICBudWxsICE9PSBjdXJyZW50SG9vayAmJiBudWxsICE9PSBjdXJyZW50SG9vay5uZXh0O1xuICAgICAgcmVuZGVyTGFuZXMgPSAwO1xuICAgICAgaG9va1R5cGVzRGV2ID1cbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICBjdXJyZW50SG9vayA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPVxuICAgICAgICAgIG51bGw7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAoY3VycmVudC5mbGFncyAmIDMxNDU3MjgwKSAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMzE0NTcyODApICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJJbnRlcm5hbCBSZWFjdCBlcnJvcjogRXhwZWN0ZWQgc3RhdGljIGZsYWcgd2FzIG1pc3NpbmcuIFBsZWFzZSBub3RpZnkgdGhlIFJlYWN0IHRlYW0uXCJcbiAgICAgICAgKTtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMTtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgICAgaWYgKGRpZFJlbmRlclRvb0Zld0hvb2tzKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlJlbmRlcmVkIGZld2VyIGhvb2tzIHRoYW4gZXhwZWN0ZWQuIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsIGVhcmx5IHJldHVybiBzdGF0ZW1lbnQuXCJcbiAgICAgICAgKTtcbiAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSB8fFxuICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LmRlcGVuZGVuY2llcyksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCkgJiZcbiAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSk7XG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFVlxuICAgICAgICA/ICgobmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSAhMSksIChjdXJyZW50ID0gITApKVxuICAgICAgICA6IChjdXJyZW50ID0gITEpO1xuICAgICAgY3VycmVudCAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcIlVua25vd25cIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoLmhhcyh3b3JrSW5Qcm9ncmVzcykgfHxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5oYXMod29ya0luUHJvZ3Jlc3MpIHx8XG4gICAgICAgICAgKGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoLmFkZCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiYHVzZWAgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIHRyeS9jYXRjaCBibG9jay4gVGhpcyBpcyBub3QgYWxsb3dlZCBhbmQgY2FuIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci4gVG8gaGFuZGxlIGVycm9ycyB0cmlnZ2VyZWQgYnkgYHVzZWAsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYSBlcnJvciBib3VuZGFyeS5cIlxuICAgICAgICAgICkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzQWdhaW4od29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgdmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzICYmICh0aGVuYWJsZVN0YXRlID0gbnVsbCk7XG4gICAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gITE7XG4gICAgICAgIGlmIChudW1iZXJPZlJlUmVuZGVycyA+PSBSRV9SRU5ERVJfTElNSVQpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTtcbiAgICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSAhMTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudEhvb2sgPSBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGNoaWxkcmVuLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICAgIGNoaWxkcmVuLmV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgY2hpbGRyZW4uc3RvcmVzID0gbnVsbDtcbiAgICAgICAgICBudWxsICE9IGNoaWxkcmVuLm1lbW9DYWNoZSAmJiAoY2hpbGRyZW4ubWVtb0NhY2hlLmluZGV4ID0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgY2hpbGRyZW4gPSBjYWxsQ29tcG9uZW50SW5ERVYoQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgsXG4gICAgICAgIG1heWJlVGhlbmFibGUgPSBkaXNwYXRjaGVyLnVzZVN0YXRlKClbMF07XG4gICAgICBtYXliZVRoZW5hYmxlID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVUaGVuYWJsZS50aGVuXG4gICAgICAgICAgPyB1c2VUaGVuYWJsZShtYXliZVRoZW5hYmxlKVxuICAgICAgICAgIDogbWF5YmVUaGVuYWJsZTtcbiAgICAgIGRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyLnVzZVN0YXRlKClbMF07XG4gICAgICAobnVsbCAhPT0gY3VycmVudEhvb2sgPyBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlIDogbnVsbCkgIT09XG4gICAgICAgIGRpc3BhdGNoZXIgJiYgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gMTAyNCk7XG4gICAgICByZXR1cm4gbWF5YmVUaGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKSB7XG4gICAgICB2YXIgZGlkUmVuZGVySWRIb29rID0gMCAhPT0gbG9jYWxJZENvdW50ZXI7XG4gICAgICBsb2NhbElkQ291bnRlciA9IDA7XG4gICAgICByZXR1cm4gZGlkUmVuZGVySWRIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMTYpICE9PSBOb01vZGVcbiAgICAgICAgICA/IHdvcmtJblByb2dyZXNzLmZsYWdzICYgLTIwMTMyODY0NVxuICAgICAgICAgIDogd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAtMjA1MztcbiAgICAgIGN1cnJlbnQubGFuZXMgJj0gfmxhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldEhvb2tzT25VbndpbmQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnF1ZXVlO1xuICAgICAgICAgIG51bGwgIT09IHF1ZXVlICYmIChxdWV1ZS5wZW5kaW5nID0gbnVsbCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMTtcbiAgICAgIH1cbiAgICAgIHJlbmRlckxhbmVzID0gMDtcbiAgICAgIGhvb2tUeXBlc0RldiA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9XG4gICAgICAgIGN1cnJlbnRIb29rID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSAhMTtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICAgICAgdmFyIGhvb2sgPSB7XG4gICAgICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICAgICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgICAgICBxdWV1ZTogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICA/IChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBob29rKVxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGhvb2spO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRIb29rKSB7XG4gICAgICAgIHZhciBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcbiAgICAgICAgbmV4dEN1cnJlbnRIb29rID1cbiAgICAgICAgICBudWxsICE9PSBuZXh0Q3VycmVudEhvb2sgPyBuZXh0Q3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG4gICAgICB9IGVsc2UgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgICAgIHZhciBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgICAgPyBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgICAgaWYgKG51bGwgIT09IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2spXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rKSxcbiAgICAgICAgICAoY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2spO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChudWxsID09PSBuZXh0Q3VycmVudEhvb2spIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJVcGRhdGUgaG9vayBjYWxsZWQgb24gaW5pdGlhbCByZW5kZXIuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG4gICAgICAgIG5leHRDdXJyZW50SG9vayA9IHtcbiAgICAgICAgICBtZW1vaXplZFN0YXRlOiBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgIGJhc2VTdGF0ZTogY3VycmVudEhvb2suYmFzZVN0YXRlLFxuICAgICAgICAgIGJhc2VRdWV1ZTogY3VycmVudEhvb2suYmFzZVF1ZXVlLFxuICAgICAgICAgIHF1ZXVlOiBjdXJyZW50SG9vay5xdWV1ZSxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vayA9XG4gICAgICAgICAgICAgIG5leHRDdXJyZW50SG9vaylcbiAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IG5leHRDdXJyZW50SG9vayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciArPSAxO1xuICAgICAgbnVsbCA9PT0gdGhlbmFibGVTdGF0ZSAmJiAodGhlbmFibGVTdGF0ZSA9IGNyZWF0ZVRoZW5hYmxlU3RhdGUoKSk7XG4gICAgICB0aGVuYWJsZSA9IHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCk7XG4gICAgICBpbmRleCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gICAgICBudWxsID09PVxuICAgICAgICAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgICAgPyBpbmRleC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCkgJiZcbiAgICAgICAgKChpbmRleCA9IGluZGV4LmFsdGVybmF0ZSksXG4gICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID1cbiAgICAgICAgICBudWxsICE9PSBpbmRleCAmJiBudWxsICE9PSBpbmRleC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICA/IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVZcbiAgICAgICAgICAgIDogSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWKSk7XG4gICAgICByZXR1cm4gdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZSh1c2FibGUpIHtcbiAgICAgIGlmIChudWxsICE9PSB1c2FibGUgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVzYWJsZSkge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdXNhYmxlLnRoZW4pIHJldHVybiB1c2VUaGVuYWJsZSh1c2FibGUpO1xuICAgICAgICBpZiAodXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpIHJldHVybiByZWFkQ29udGV4dCh1c2FibGUpO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXCJBbiB1bnN1cHBvcnRlZCB0eXBlIHdhcyBwYXNzZWQgdG8gdXNlKCk6IFwiICsgU3RyaW5nKHVzYWJsZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VNZW1vQ2FjaGUoc2l6ZSkge1xuICAgICAgdmFyIG1lbW9DYWNoZSA9IG51bGwsXG4gICAgICAgIHVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcbiAgICAgIG51bGwgIT09IHVwZGF0ZVF1ZXVlICYmIChtZW1vQ2FjaGUgPSB1cGRhdGVRdWV1ZS5tZW1vQ2FjaGUpO1xuICAgICAgaWYgKG51bGwgPT0gbWVtb0NhY2hlKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50Lm1lbW9DYWNoZSksXG4gICAgICAgICAgICBudWxsICE9IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgKG1lbW9DYWNoZSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdXJyZW50LmRhdGEubWFwKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIG51bGwgPT0gbWVtb0NhY2hlICYmIChtZW1vQ2FjaGUgPSB7IGRhdGE6IFtdLCBpbmRleDogMCB9KTtcbiAgICAgIG51bGwgPT09IHVwZGF0ZVF1ZXVlICYmXG4gICAgICAgICgodXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlKSk7XG4gICAgICB1cGRhdGVRdWV1ZS5tZW1vQ2FjaGUgPSBtZW1vQ2FjaGU7XG4gICAgICB1cGRhdGVRdWV1ZSA9IG1lbW9DYWNoZS5kYXRhW21lbW9DYWNoZS5pbmRleF07XG4gICAgICBpZiAodm9pZCAwID09PSB1cGRhdGVRdWV1ZSB8fCBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA9IG1lbW9DYWNoZS5kYXRhW21lbW9DYWNoZS5pbmRleF0gPSBBcnJheShzaXplKSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgICAgIGN1cnJlbnQgPCBzaXplO1xuICAgICAgICAgIGN1cnJlbnQrK1xuICAgICAgICApXG4gICAgICAgICAgdXBkYXRlUXVldWVbY3VycmVudF0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICAgICAgZWxzZVxuICAgICAgICB1cGRhdGVRdWV1ZS5sZW5ndGggIT09IHNpemUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCBhIGNvbnN0YW50IHNpemUgYXJndW1lbnQgZm9yIGVhY2ggaW52b2NhdGlvbiBvZiB1c2VNZW1vQ2FjaGUuIFRoZSBwcmV2aW91cyBjYWNoZSB3YXMgYWxsb2NhdGVkIHdpdGggc2l6ZSAlcyBidXQgc2l6ZSAlcyB3YXMgcmVxdWVzdGVkLlwiLFxuICAgICAgICAgICAgdXBkYXRlUXVldWUubGVuZ3RoLFxuICAgICAgICAgICAgc2l6ZVxuICAgICAgICAgICk7XG4gICAgICBtZW1vQ2FjaGUuaW5kZXgrKztcbiAgICAgIHJldHVybiB1cGRhdGVRdWV1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvbiA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAodm9pZCAwICE9PSBpbml0KSB7XG4gICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbml0KGluaXRpYWxBcmcpO1xuICAgICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluaXQoaW5pdGlhbEFyZyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICByZWR1Y2VyID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IHJlZHVjZXIsXG4gICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgICAgIH07XG4gICAgICBob29rLnF1ZXVlID0gcmVkdWNlcjtcbiAgICAgIHJlZHVjZXIgPSByZWR1Y2VyLmRpc3BhdGNoID0gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgcmVkdWNlcl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXIocmVkdWNlcikge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VySW1wbChob29rLCBjdXJyZW50SG9vaywgcmVkdWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXJJbXBsKGhvb2ssIGN1cnJlbnQsIHJlZHVjZXIpIHtcbiAgICAgIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG4gICAgICBpZiAobnVsbCA9PT0gcXVldWUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gWW91IGFyZSBsaWtlbHkgY2FsbGluZyBIb29rcyBjb25kaXRpb25hbGx5LCB3aGljaCBpcyBub3QgYWxsb3dlZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwpXCJcbiAgICAgICAgKTtcbiAgICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyO1xuICAgICAgdmFyIGJhc2VRdWV1ZSA9IGhvb2suYmFzZVF1ZXVlLFxuICAgICAgICBwZW5kaW5nUXVldWUgPSBxdWV1ZS5wZW5kaW5nO1xuICAgICAgaWYgKG51bGwgIT09IHBlbmRpbmdRdWV1ZSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gYmFzZVF1ZXVlKSB7XG4gICAgICAgICAgdmFyIGJhc2VGaXJzdCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgICAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ1F1ZXVlLm5leHQ7XG4gICAgICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC5iYXNlUXVldWUgIT09IGJhc2VRdWV1ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50LmJhc2VRdWV1ZSA9IGJhc2VRdWV1ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgICBwZW5kaW5nUXVldWUgPSBob29rLmJhc2VTdGF0ZTtcbiAgICAgIGlmIChudWxsID09PSBiYXNlUXVldWUpIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjdXJyZW50ID0gYmFzZVF1ZXVlLm5leHQ7XG4gICAgICAgIHZhciBuZXdCYXNlUXVldWVGaXJzdCA9IChiYXNlRmlyc3QgPSBudWxsKSxcbiAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbCxcbiAgICAgICAgICB1cGRhdGUgPSBjdXJyZW50LFxuICAgICAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciB1cGRhdGVMYW5lID0gdXBkYXRlLmxhbmUgJiAtNTM2ODcwOTEzO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHVwZGF0ZUxhbmUgIT09IHVwZGF0ZS5sYW5lXG4gICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICAgICAgOiAocmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHJldmVydExhbmUgPSB1cGRhdGUucmV2ZXJ0TGFuZTtcbiAgICAgICAgICAgIGlmICgwID09PSByZXZlcnRMYW5lKVxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdCYXNlUXVldWVMYXN0ICYmXG4gICAgICAgICAgICAgICAgKG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPVxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsYW5lOiAwLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnRMYW5lOiAwLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdXBkYXRlTGFuZSA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITApO1xuICAgICAgICAgICAgZWxzZSBpZiAoKHJlbmRlckxhbmVzICYgcmV2ZXJ0TGFuZSkgPT09IHJldmVydExhbmUpIHtcbiAgICAgICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgICAgICAgIHJldmVydExhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgICAgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICh1cGRhdGVMYW5lID0ge1xuICAgICAgICAgICAgICAgIGxhbmU6IDAsXG4gICAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogdXBkYXRlLnJldmVydExhbmUsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3QmFzZVF1ZXVlTGFzdFxuICAgICAgICAgICAgICAgICAgPyAoKG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IHVwZGF0ZUxhbmUpLFxuICAgICAgICAgICAgICAgICAgICAoYmFzZUZpcnN0ID0gcGVuZGluZ1F1ZXVlKSlcbiAgICAgICAgICAgICAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSB1cGRhdGVMYW5lKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSByZXZlcnRMYW5lKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IHJldmVydExhbmUpO1xuICAgICAgICAgICAgdXBkYXRlTGFuZSA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICAgICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViAmJlxuICAgICAgICAgICAgICByZWR1Y2VyKHBlbmRpbmdRdWV1ZSwgdXBkYXRlTGFuZSk7XG4gICAgICAgICAgICBwZW5kaW5nUXVldWUgPSB1cGRhdGUuaGFzRWFnZXJTdGF0ZVxuICAgICAgICAgICAgICA/IHVwZGF0ZS5lYWdlclN0YXRlXG4gICAgICAgICAgICAgIDogcmVkdWNlcihwZW5kaW5nUXVldWUsIHVwZGF0ZUxhbmUpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgKHJldmVydExhbmUgPSB7XG4gICAgICAgICAgICAgIGxhbmU6IHVwZGF0ZUxhbmUsXG4gICAgICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgICAgICAgICAgICA/ICgobmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gcmV2ZXJ0TGFuZSksXG4gICAgICAgICAgICAgICAgICAoYmFzZUZpcnN0ID0gcGVuZGluZ1F1ZXVlKSlcbiAgICAgICAgICAgICAgICA6IChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gcmV2ZXJ0TGFuZSksXG4gICAgICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzIHw9IHVwZGF0ZUxhbmUpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IHVwZGF0ZUxhbmUpO1xuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChudWxsICE9PSB1cGRhdGUgJiYgdXBkYXRlICE9PSBjdXJyZW50KTtcbiAgICAgICAgbnVsbCA9PT0gbmV3QmFzZVF1ZXVlTGFzdFxuICAgICAgICAgID8gKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSlcbiAgICAgICAgICA6IChuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBuZXdCYXNlUXVldWVGaXJzdCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhb2JqZWN0SXMocGVuZGluZ1F1ZXVlLCBob29rLm1lbW9pemVkU3RhdGUpICYmXG4gICAgICAgICAgKChkaWRSZWNlaXZlVXBkYXRlID0gITApLFxuICAgICAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gJiZcbiAgICAgICAgICAgICgocmVkdWNlciA9IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSksIG51bGwgIT09IHJlZHVjZXIpKVxuICAgICAgICApXG4gICAgICAgICAgdGhyb3cgcmVkdWNlcjtcbiAgICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgICBob29rLmJhc2VTdGF0ZSA9IGJhc2VGaXJzdDtcbiAgICAgICAgaG9vay5iYXNlUXVldWUgPSBuZXdCYXNlUXVldWVMYXN0O1xuICAgICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgIH1cbiAgICAgIG51bGwgPT09IGJhc2VRdWV1ZSAmJiAocXVldWUubGFuZXMgPSAwKTtcbiAgICAgIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBxdWV1ZS5kaXNwYXRjaF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBxdWV1ZSA9IGhvb2sucXVldWU7XG4gICAgICBpZiAobnVsbCA9PT0gcXVldWUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gWW91IGFyZSBsaWtlbHkgY2FsbGluZyBIb29rcyBjb25kaXRpb25hbGx5LCB3aGljaCBpcyBub3QgYWxsb3dlZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwpXCJcbiAgICAgICAgKTtcbiAgICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyO1xuICAgICAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2gsXG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHF1ZXVlLnBlbmRpbmcsXG4gICAgICAgIG5ld1N0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IChsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCk7XG4gICAgICAgIGRvXG4gICAgICAgICAgKG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgdXBkYXRlLmFjdGlvbikpLCAodXBkYXRlID0gdXBkYXRlLm5leHQpO1xuICAgICAgICB3aGlsZSAodXBkYXRlICE9PSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUpO1xuICAgICAgICBvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSB8fCAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKTtcbiAgICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIG51bGwgPT09IGhvb2suYmFzZVF1ZXVlICYmIChob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlKTtcbiAgICAgICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIk1pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciBzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHZhciBuZXh0U25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCB8fFxuICAgICAgICAgIG5leHRTbmFwc2hvdCA9PT0gZ2V0U2VydmVyU25hcHNob3QoKSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcmVzdWx0IG9mIGdldFNlcnZlclNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSAhMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcbiAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgfHxcbiAgICAgICAgICAoKGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U25hcHNob3QoKSksXG4gICAgICAgICAgb2JqZWN0SXMobmV4dFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkgfHxcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSAhMCkpKTtcbiAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgMCAhPT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNjApIHx8XG4gICAgICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXh0U25hcHNob3Q7XG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCA9IHsgdmFsdWU6IG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90IH07XG4gICAgICBob29rLnF1ZXVlID0gZ2V0U2VydmVyU25hcHNob3Q7XG4gICAgICBtb3VudEVmZmVjdChcbiAgICAgICAgc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc3Vic2NyaWJlKSxcbiAgICAgICAgW3N1YnNjcmliZV1cbiAgICAgICk7XG4gICAgICBmaWJlci5mbGFncyB8PSAyMDQ4O1xuICAgICAgcHVzaEVmZmVjdChcbiAgICAgICAgSGFzRWZmZWN0IHwgUGFzc2l2ZSxcbiAgICAgICAgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgZmliZXIsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICAgICAgbmV4dFNuYXBzaG90LFxuICAgICAgICAgIGdldFNuYXBzaG90XG4gICAgICAgICksXG4gICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV4dFNuYXBzaG90O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGdldFNuYXBzaG90LFxuICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICApIHtcbiAgICAgIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgaXNIeWRyYXRpbmckanNjb21wJDAgPSBpc0h5ZHJhdGluZztcbiAgICAgIGlmIChpc0h5ZHJhdGluZyRqc2NvbXAkMCkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBnZXRTZXJ2ZXJTbmFwc2hvdClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHNlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKChnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNuYXBzaG90KCkpLCAhZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNhY2hlZFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcbiAgICAgICAgb2JqZWN0SXMoZ2V0U2VydmVyU25hcHNob3QsIGNhY2hlZFNuYXBzaG90KSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSAhMCkpO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAoY2FjaGVkU25hcHNob3QgPSAhb2JqZWN0SXMoXG4gICAgICAgICAgKGN1cnJlbnRIb29rIHx8IGhvb2spLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKSlcbiAgICAgIClcbiAgICAgICAgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGdldFNlcnZlclNuYXBzaG90KSwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCk7XG4gICAgICBob29rID0gaG9vay5xdWV1ZTtcbiAgICAgIHZhciBjcmVhdGUgPSBzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGhvb2ssIHN1YnNjcmliZSk7XG4gICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgW3N1YnNjcmliZV0pO1xuICAgICAgaWYgKFxuICAgICAgICBob29rLmdldFNuYXBzaG90ICE9PSBnZXRTbmFwc2hvdCB8fFxuICAgICAgICBjYWNoZWRTbmFwc2hvdCB8fFxuICAgICAgICAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NIb29rICYmXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUudGFnICYgSGFzRWZmZWN0KVxuICAgICAgKSB7XG4gICAgICAgIGZpYmVyLmZsYWdzIHw9IDIwNDg7XG4gICAgICAgIHB1c2hFZmZlY3QoXG4gICAgICAgICAgSGFzRWZmZWN0IHwgUGFzc2l2ZSxcbiAgICAgICAgICB1cGRhdGVTdG9yZUluc3RhbmNlLmJpbmQoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBob29rLFxuICAgICAgICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICAgICAgICBnZXRTbmFwc2hvdFxuICAgICAgICAgICksXG4gICAgICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgICAgICBudWxsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGlzSHlkcmF0aW5nJGpzY29tcCQwIHx8XG4gICAgICAgICAgMCAhPT0gKHJlbmRlckxhbmVzICYgNjApIHx8XG4gICAgICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIHJlbmRlcmVkU25hcHNob3QpIHtcbiAgICAgIGZpYmVyLmZsYWdzIHw9IDE2Mzg0O1xuICAgICAgZmliZXIgPSB7IGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCwgdmFsdWU6IHJlbmRlcmVkU25hcHNob3QgfTtcbiAgICAgIGdldFNuYXBzaG90ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcbiAgICAgIG51bGwgPT09IGdldFNuYXBzaG90XG4gICAgICAgID8gKChnZXRTbmFwc2hvdCA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBnZXRTbmFwc2hvdCksXG4gICAgICAgICAgKGdldFNuYXBzaG90LnN0b3JlcyA9IFtmaWJlcl0pKVxuICAgICAgICA6ICgocmVuZGVyZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90LnN0b3JlcyksXG4gICAgICAgICAgbnVsbCA9PT0gcmVuZGVyZWRTbmFwc2hvdFxuICAgICAgICAgICAgPyAoZ2V0U25hcHNob3Quc3RvcmVzID0gW2ZpYmVyXSlcbiAgICAgICAgICAgIDogcmVuZGVyZWRTbmFwc2hvdC5wdXNoKGZpYmVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0b3JlSW5zdGFuY2UoZmliZXIsIGluc3QsIG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3QpIHtcbiAgICAgIGluc3QudmFsdWUgPSBuZXh0U25hcHNob3Q7XG4gICAgICBpbnN0LmdldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7XG4gICAgICBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpICYmIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZVRvU3RvcmUoZmliZXIsIGluc3QsIHN1YnNjcmliZSkge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgICAgIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG4gICAgICBpbnN0ID0gaW5zdC52YWx1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBsYXRlc3RHZXRTbmFwc2hvdCgpO1xuICAgICAgICByZXR1cm4gIW9iamVjdElzKGluc3QsIG5leHRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcikge1xuICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN0YXRlSW1wbChpbml0aWFsU3RhdGUpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgdmFyIGluaXRpYWxTdGF0ZUluaXRpYWxpemVyID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGVJbml0aWFsaXplcigpO1xuICAgICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZUluaXRpYWxpemVyKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgaG9vay5xdWV1ZSA9IHtcbiAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBob29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICAgICAgaW5pdGlhbFN0YXRlID0gbW91bnRTdGF0ZUltcGwoaW5pdGlhbFN0YXRlKTtcbiAgICAgIHZhciBxdWV1ZSA9IGluaXRpYWxTdGF0ZS5xdWV1ZSxcbiAgICAgICAgZGlzcGF0Y2ggPSBkaXNwYXRjaFNldFN0YXRlLmJpbmQoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICAgIHF1ZXVlXG4gICAgICAgICk7XG4gICAgICBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgICAgcmV0dXJuIFtpbml0aWFsU3RhdGUubWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gICAgICB2YXIgcXVldWUgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IG51bGxcbiAgICAgIH07XG4gICAgICBob29rLnF1ZXVlID0gcXVldWU7XG4gICAgICBob29rID0gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgITAsXG4gICAgICAgIHF1ZXVlXG4gICAgICApO1xuICAgICAgcXVldWUuZGlzcGF0Y2ggPSBob29rO1xuICAgICAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgaG9va107XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudEhvb2ssIHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudCwgcGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gICAgICByZXR1cm4gdXBkYXRlUmVkdWNlckltcGwoXG4gICAgICAgIGhvb2ssXG4gICAgICAgIGN1cnJlbnRIb29rLFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWR1Y2VyID8gcmVkdWNlciA6IGJhc2ljU3RhdGVSZWR1Y2VyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudEhvb2spXG4gICAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50SG9vaywgcGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgICAgIHJldHVybiBbcGFzc3Rocm91Z2gsIGhvb2sucXVldWUuZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEFjdGlvblN0YXRlKFxuICAgICAgZmliZXIsXG4gICAgICBhY3Rpb25RdWV1ZSxcbiAgICAgIHNldFBlbmRpbmdTdGF0ZSxcbiAgICAgIHNldFN0YXRlLFxuICAgICAgcGF5bG9hZFxuICAgICkge1xuICAgICAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKVxuICAgICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgZm9ybSBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgICAgZmliZXIgPSBhY3Rpb25RdWV1ZS5hY3Rpb247XG4gICAgICBpZiAobnVsbCAhPT0gZmliZXIpIHtcbiAgICAgICAgdmFyIGFjdGlvbk5vZGUgPSB7XG4gICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICBhY3Rpb246IGZpYmVyLFxuICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgaXNUcmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgICAgICBsaXN0ZW5lcnM6IFtdLFxuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgYWN0aW9uTm9kZS5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5UXG4gICAgICAgICAgPyBzZXRQZW5kaW5nU3RhdGUoITApXG4gICAgICAgICAgOiAoYWN0aW9uTm9kZS5pc1RyYW5zaXRpb24gPSAhMSk7XG4gICAgICAgIHNldFN0YXRlKGFjdGlvbk5vZGUpO1xuICAgICAgICBzZXRQZW5kaW5nU3RhdGUgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuICAgICAgICBudWxsID09PSBzZXRQZW5kaW5nU3RhdGVcbiAgICAgICAgICA/ICgoYWN0aW9uTm9kZS5uZXh0ID0gYWN0aW9uUXVldWUucGVuZGluZyA9IGFjdGlvbk5vZGUpLFxuICAgICAgICAgICAgcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIGFjdGlvbk5vZGUpKVxuICAgICAgICAgIDogKChhY3Rpb25Ob2RlLm5leHQgPSBzZXRQZW5kaW5nU3RhdGUubmV4dCksXG4gICAgICAgICAgICAoYWN0aW9uUXVldWUucGVuZGluZyA9IHNldFBlbmRpbmdTdGF0ZS5uZXh0ID0gYWN0aW9uTm9kZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgbm9kZSkge1xuICAgICAgdmFyIGFjdGlvbiA9IG5vZGUuYWN0aW9uLFxuICAgICAgICBwYXlsb2FkID0gbm9kZS5wYXlsb2FkLFxuICAgICAgICBwcmV2U3RhdGUgPSBhY3Rpb25RdWV1ZS5zdGF0ZTtcbiAgICAgIGlmIChub2RlLmlzVHJhbnNpdGlvbikge1xuICAgICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uID0ge307XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBjdXJyZW50VHJhbnNpdGlvbjtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVC5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBhY3Rpb24ocHJldlN0YXRlLCBwYXlsb2FkKSxcbiAgICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICAgICAgICBudWxsICE9PSBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgICAgICBoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZShhY3Rpb25RdWV1ZSwgbm9kZSwgcmV0dXJuVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIG5vZGUsIGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKSxcbiAgICAgICAgICAgIG51bGwgPT09IHByZXZUcmFuc2l0aW9uICYmXG4gICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzICYmXG4gICAgICAgICAgICAgICgoYWN0aW9uUXVldWUgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplKSxcbiAgICAgICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKSxcbiAgICAgICAgICAgICAgMTAgPCBhY3Rpb25RdWV1ZSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiBJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiBPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgKGN1cnJlbnRUcmFuc2l0aW9uID0gYWN0aW9uKHByZXZTdGF0ZSwgcGF5bG9hZCkpLFxuICAgICAgICAgICAgaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIGN1cnJlbnRUcmFuc2l0aW9uKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IkMikge1xuICAgICAgICAgIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIG5vZGUsIGVycm9yJDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCByZXR1cm5WYWx1ZSkge1xuICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlblxuICAgICAgICA/IChyZXR1cm5WYWx1ZS50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24gKG5leHRTdGF0ZSkge1xuICAgICAgICAgICAgICBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIG5vZGUsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBub2RlLmlzVHJhbnNpdGlvbiB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJBbiBhc3luYyBmdW5jdGlvbiB3YXMgcGFzc2VkIHRvIHVzZUFjdGlvblN0YXRlLCBidXQgaXQgd2FzIGRpc3BhdGNoZWQgb3V0c2lkZSBvZiBhbiBhY3Rpb24gY29udGV4dC4gVGhpcyBpcyBsaWtlbHkgbm90IHdoYXQgeW91IGludGVuZGVkLiBFaXRoZXIgcGFzcyB0aGUgZGlzcGF0Y2ggZnVuY3Rpb24gdG8gYW4gYGFjdGlvbmAgcHJvcCwgb3IgZGlzcGF0Y2ggbWFudWFsbHkgaW5zaWRlIGBzdGFydFRyYW5zaXRpb25gXCJcbiAgICAgICAgICAgICkpXG4gICAgICAgIDogb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBub2RlLCByZXR1cm5WYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSwgbmV4dFN0YXRlKSB7XG4gICAgICBhY3Rpb25Ob2RlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICBhY3Rpb25Ob2RlLnZhbHVlID0gbmV4dFN0YXRlO1xuICAgICAgbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpO1xuICAgICAgYWN0aW9uUXVldWUuc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBhY3Rpb25Ob2RlID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgICAgIG51bGwgIT09IGFjdGlvbk5vZGUgJiZcbiAgICAgICAgKChuZXh0U3RhdGUgPSBhY3Rpb25Ob2RlLm5leHQpLFxuICAgICAgICBuZXh0U3RhdGUgPT09IGFjdGlvbk5vZGVcbiAgICAgICAgICA/IChhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbnVsbClcbiAgICAgICAgICA6ICgobmV4dFN0YXRlID0gbmV4dFN0YXRlLm5leHQpLFxuICAgICAgICAgICAgKGFjdGlvbk5vZGUubmV4dCA9IG5leHRTdGF0ZSksXG4gICAgICAgICAgICBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgbmV4dFN0YXRlKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlLCBlcnJvcikge1xuICAgICAgdmFyIGxhc3QgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuICAgICAgYWN0aW9uUXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgICBpZiAobnVsbCAhPT0gbGFzdCkge1xuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgICAgICBkb1xuICAgICAgICAgIChhY3Rpb25Ob2RlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiksXG4gICAgICAgICAgICAoYWN0aW9uTm9kZS5yZWFzb24gPSBlcnJvciksXG4gICAgICAgICAgICBub3RpZnlBY3Rpb25MaXN0ZW5lcnMoYWN0aW9uTm9kZSksXG4gICAgICAgICAgICAoYWN0aW9uTm9kZSA9IGFjdGlvbk5vZGUubmV4dCk7XG4gICAgICAgIHdoaWxlIChhY3Rpb25Ob2RlICE9PSBsYXN0KTtcbiAgICAgIH1cbiAgICAgIGFjdGlvblF1ZXVlLmFjdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKSB7XG4gICAgICBhY3Rpb25Ob2RlID0gYWN0aW9uTm9kZS5saXN0ZW5lcnM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGlvbk5vZGUubGVuZ3RoOyBpKyspICgwLCBhY3Rpb25Ob2RlW2ldKSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhY3Rpb25TdGF0ZVJlZHVjZXIob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGVQcm9wKSB7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgdmFyIHNzckZvcm1TdGF0ZSA9IHdvcmtJblByb2dyZXNzUm9vdC5mb3JtU3RhdGU7XG4gICAgICAgIGlmIChudWxsICE9PSBzc3JGb3JtU3RhdGUpIHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICB2YXIgaXNNYXRjaGluZyA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gICAgICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICAgICAgaWYgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VySW5zdGFuY2UgPSBjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyKFxuICAgICAgICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZyhtYXJrZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICBpc01hdGNoaW5nID0gaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyhtYXJrZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goaXNNYXRjaGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc01hdGNoaW5nID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzTWF0Y2hpbmcgJiYgKGluaXRpYWxTdGF0ZVByb3AgPSBzc3JGb3JtU3RhdGVbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzc3JGb3JtU3RhdGUgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgc3NyRm9ybVN0YXRlLm1lbW9pemVkU3RhdGUgPSBzc3JGb3JtU3RhdGUuYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlUHJvcDtcbiAgICAgIGlzTWF0Y2hpbmcgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYWN0aW9uU3RhdGVSZWR1Y2VyLFxuICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlUHJvcFxuICAgICAgfTtcbiAgICAgIHNzckZvcm1TdGF0ZS5xdWV1ZSA9IGlzTWF0Y2hpbmc7XG4gICAgICBzc3JGb3JtU3RhdGUgPSBkaXNwYXRjaFNldFN0YXRlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIGlzTWF0Y2hpbmdcbiAgICAgICk7XG4gICAgICBpc01hdGNoaW5nLmRpc3BhdGNoID0gc3NyRm9ybVN0YXRlO1xuICAgICAgaXNNYXRjaGluZyA9IG1vdW50U3RhdGVJbXBsKCExKTtcbiAgICAgIHZhciBzZXRQZW5kaW5nU3RhdGUgPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICAhMSxcbiAgICAgICAgaXNNYXRjaGluZy5xdWV1ZVxuICAgICAgKTtcbiAgICAgIGlzTWF0Y2hpbmcgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgbWFya2VySW5zdGFuY2UgPSB7XG4gICAgICAgIHN0YXRlOiBpbml0aWFsU3RhdGVQcm9wLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIHBlbmRpbmc6IG51bGxcbiAgICAgIH07XG4gICAgICBpc01hdGNoaW5nLnF1ZXVlID0gbWFya2VySW5zdGFuY2U7XG4gICAgICBzc3JGb3JtU3RhdGUgPSBkaXNwYXRjaEFjdGlvblN0YXRlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIG1hcmtlckluc3RhbmNlLFxuICAgICAgICBzZXRQZW5kaW5nU3RhdGUsXG4gICAgICAgIHNzckZvcm1TdGF0ZVxuICAgICAgKTtcbiAgICAgIG1hcmtlckluc3RhbmNlLmRpc3BhdGNoID0gc3NyRm9ybVN0YXRlO1xuICAgICAgaXNNYXRjaGluZy5tZW1vaXplZFN0YXRlID0gYWN0aW9uO1xuICAgICAgcmV0dXJuIFtpbml0aWFsU3RhdGVQcm9wLCBzc3JGb3JtU3RhdGUsICExXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKSB7XG4gICAgICB2YXIgc3RhdGVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGVJbXBsKHN0YXRlSG9vaywgY3VycmVudEhvb2ssIGFjdGlvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbikge1xuICAgICAgY3VycmVudFN0YXRlSG9vayA9IHVwZGF0ZVJlZHVjZXJJbXBsKFxuICAgICAgICBzdGF0ZUhvb2ssXG4gICAgICAgIGN1cnJlbnRTdGF0ZUhvb2ssXG4gICAgICAgIGFjdGlvblN0YXRlUmVkdWNlclxuICAgICAgKVswXTtcbiAgICAgIHN0YXRlSG9vayA9IHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdO1xuICAgICAgY3VycmVudFN0YXRlSG9vayA9XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjdXJyZW50U3RhdGVIb29rICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRTdGF0ZUhvb2sgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudFN0YXRlSG9vay50aGVuXG4gICAgICAgICAgPyB1c2VUaGVuYWJsZShjdXJyZW50U3RhdGVIb29rKVxuICAgICAgICAgIDogY3VycmVudFN0YXRlSG9vaztcbiAgICAgIHZhciBhY3Rpb25RdWV1ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgYWN0aW9uUXVldWUgPSBhY3Rpb25RdWV1ZUhvb2sucXVldWUsXG4gICAgICAgIGRpc3BhdGNoID0gYWN0aW9uUXVldWUuZGlzcGF0Y2g7XG4gICAgICBhY3Rpb24gIT09IGFjdGlvblF1ZXVlSG9vay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICgoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgcHVzaEVmZmVjdChcbiAgICAgICAgICBIYXNFZmZlY3QgfCBQYXNzaXZlLFxuICAgICAgICAgIGFjdGlvblN0YXRlQWN0aW9uRWZmZWN0LmJpbmQobnVsbCwgYWN0aW9uUXVldWUsIGFjdGlvbiksXG4gICAgICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgICAgICBudWxsXG4gICAgICAgICkpO1xuICAgICAgcmV0dXJuIFtjdXJyZW50U3RhdGVIb29rLCBkaXNwYXRjaCwgc3RhdGVIb29rXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWN0aW9uU3RhdGVBY3Rpb25FZmZlY3QoYWN0aW9uUXVldWUsIGFjdGlvbikge1xuICAgICAgYWN0aW9uUXVldWUuYWN0aW9uID0gYWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbikge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBjdXJyZW50U3RhdGVIb29rID0gY3VycmVudEhvb2s7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudFN0YXRlSG9vaylcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbik7XG4gICAgICB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHN0YXRlSG9vayA9IHN0YXRlSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgY3VycmVudFN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgdmFyIGRpc3BhdGNoID0gY3VycmVudFN0YXRlSG9vay5xdWV1ZS5kaXNwYXRjaDtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjtcbiAgICAgIHJldHVybiBbc3RhdGVIb29rLCBkaXNwYXRjaCwgITFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRWZmZWN0KHRhZywgY3JlYXRlLCBpbnN0LCBkZXBzKSB7XG4gICAgICB0YWcgPSB7IHRhZzogdGFnLCBjcmVhdGU6IGNyZWF0ZSwgaW5zdDogaW5zdCwgZGVwczogZGVwcywgbmV4dDogbnVsbCB9O1xuICAgICAgY3JlYXRlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcbiAgICAgIG51bGwgPT09IGNyZWF0ZSAmJlxuICAgICAgICAoKGNyZWF0ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gY3JlYXRlKSk7XG4gICAgICBpbnN0ID0gY3JlYXRlLmxhc3RFZmZlY3Q7XG4gICAgICBudWxsID09PSBpbnN0XG4gICAgICAgID8gKGNyZWF0ZS5sYXN0RWZmZWN0ID0gdGFnLm5leHQgPSB0YWcpXG4gICAgICAgIDogKChkZXBzID0gaW5zdC5uZXh0KSxcbiAgICAgICAgICAoaW5zdC5uZXh0ID0gdGFnKSxcbiAgICAgICAgICAodGFnLm5leHQgPSBkZXBzKSxcbiAgICAgICAgICAoY3JlYXRlLmxhc3RFZmZlY3QgPSB0YWcpKTtcbiAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50UmVmKGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaW5pdGlhbFZhbHVlID0geyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfTtcbiAgICAgIHJldHVybiAoaG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KFxuICAgICAgICBIYXNFZmZlY3QgfCBob29rRmxhZ3MsXG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgICAgdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBkZXBzID0gdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHM7XG4gICAgICB2YXIgaW5zdCA9IGhvb2subWVtb2l6ZWRTdGF0ZS5pbnN0O1xuICAgICAgbnVsbCAhPT0gY3VycmVudEhvb2sgJiZcbiAgICAgIG51bGwgIT09IGRlcHMgJiZcbiAgICAgIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLmRlcHMpXG4gICAgICAgID8gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoaG9va0ZsYWdzLCBjcmVhdGUsIGluc3QsIGRlcHMpKVxuICAgICAgICA6ICgoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzKSxcbiAgICAgICAgICAoaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChcbiAgICAgICAgICAgIEhhc0VmZmVjdCB8IGhvb2tGbGFncyxcbiAgICAgICAgICAgIGNyZWF0ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBkZXBzXG4gICAgICAgICAgKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIDY0KSA9PT0gTm9Nb2RlXG4gICAgICAgID8gbW91bnRFZmZlY3RJbXBsKDE0MjYwODM4NCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKVxuICAgICAgICA6IG1vdW50RWZmZWN0SW1wbCg4MzkwNjU2LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBmaWJlckZsYWdzID0gNDE5NDMwODtcbiAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAoZmliZXJGbGFncyB8PSA2NzEwODg2NCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdChjcmVhdGUsIHJlZikge1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZikge1xuICAgICAgICBjcmVhdGUgPSBjcmVhdGUoKTtcbiAgICAgICAgdmFyIHJlZkNsZWFudXAgPSByZWYoY3JlYXRlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWZDbGVhbnVwID8gcmVmQ2xlYW51cCgpIDogcmVmKG51bGwpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgIT09IHJlZiAmJiB2b2lkIDAgIT09IHJlZilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICByZWYuaGFzT3duUHJvcGVydHkoXCJjdXJyZW50XCIpIHx8XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkV4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBmaXJzdCBhcmd1bWVudCB0byBlaXRoZXIgYmUgYSByZWYgY2FsbGJhY2sgb3IgUmVhY3QuY3JlYXRlUmVmKCkgb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgICAgXCJhbiBvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKHJlZikuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKGNyZWF0ZSA9IGNyZWF0ZSgpKSxcbiAgICAgICAgICAocmVmLmN1cnJlbnQgPSBjcmVhdGUpLFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY3JlYXRlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICBudWxsICE9PSBjcmVhdGUgPyB0eXBlb2YgY3JlYXRlIDogXCJudWxsXCJcbiAgICAgICAgKTtcbiAgICAgIGRlcHMgPSBudWxsICE9PSBkZXBzICYmIHZvaWQgMCAhPT0gZGVwcyA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gICAgICB2YXIgZmliZXJGbGFncyA9IDQxOTQzMDg7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgKGZpYmVyRmxhZ3MgfD0gNjcxMDg4NjQpO1xuICAgICAgbW91bnRFZmZlY3RJbXBsKFxuICAgICAgICBmaWJlckZsYWdzLFxuICAgICAgICBMYXlvdXQsXG4gICAgICAgIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksXG4gICAgICAgIGRlcHNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNyZWF0ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgbnVsbCAhPT0gY3JlYXRlID8gdHlwZW9mIGNyZWF0ZSA6IFwibnVsbFwiXG4gICAgICAgICk7XG4gICAgICBkZXBzID0gbnVsbCAhPT0gZGVwcyAmJiB2b2lkIDAgIT09IGRlcHMgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICAgICAgdXBkYXRlRWZmZWN0SW1wbChcbiAgICAgICAgNCxcbiAgICAgICAgTGF5b3V0LFxuICAgICAgICBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLFxuICAgICAgICBkZXBzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGUgPSBbXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwc1xuICAgICAgXTtcbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBkZXBzID0gdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHM7XG4gICAgICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGRlcHMgJiYgYXJlSG9va0lucHV0c0VxdWFsKGRlcHMsIHByZXZTdGF0ZVsxXSkpXG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIGRlcHNdO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudE1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV4dENyZWF0ZSgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgZGVwc107XG4gICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBkZXBzID0gdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHM7XG4gICAgICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGRlcHMgJiYgYXJlSG9va0lucHV0c0VxdWFsKGRlcHMsIHByZXZTdGF0ZVsxXSkpXG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICBwcmV2U3RhdGUgPSBuZXh0Q3JlYXRlKCk7XG4gICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5leHRDcmVhdGUoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtwcmV2U3RhdGUsIGRlcHNdO1xuICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoXG4gICAgICAgIGhvb2ssXG4gICAgICAgIGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpbml0aWFsVmFsdWVcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGN1cnJlbnRIb29rXG4gICAgICAgID8gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKVxuICAgICAgICA6IHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKFxuICAgICAgICAgICAgaG9vayxcbiAgICAgICAgICAgIGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gaW5pdGlhbFZhbHVlIHx8IDAgIT09IChyZW5kZXJMYW5lcyAmIDEwNzM3NDE4MjQpKVxuICAgICAgICByZXR1cm4gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgIGhvb2sgPSByZXF1ZXN0RGVmZXJyZWRMYW5lKCk7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzIHw9IGhvb2s7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gaG9vaztcbiAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHByZXZWYWx1ZSwgdmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgaWYgKG9iamVjdElzKHZhbHVlLCBwcmV2VmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50KVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChob29rID0gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSksXG4gICAgICAgICAgb2JqZWN0SXMoaG9vaywgcHJldlZhbHVlKSB8fCAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSxcbiAgICAgICAgICBob29rXG4gICAgICAgICk7XG4gICAgICBpZiAoMCA9PT0gKHJlbmRlckxhbmVzICYgNDIpKVxuICAgICAgICByZXR1cm4gKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksIChob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZSk7XG4gICAgICBob29rID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSBob29rO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGhvb2s7XG4gICAgICByZXR1cm4gcHJldlZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oXG4gICAgICBmaWJlcixcbiAgICAgIHF1ZXVlLFxuICAgICAgcGVuZGluZ1N0YXRlLFxuICAgICAgZmluaXNoZWRTdGF0ZSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KFxuICAgICAgICAwICE9PSBwcmV2aW91c1ByaW9yaXR5ICYmIDggPiBwcmV2aW91c1ByaW9yaXR5ID8gcHJldmlvdXNQcmlvcml0eSA6IDhcbiAgICAgICk7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgICAgZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUoZmliZXIsICExLCBxdWV1ZSwgcGVuZGluZ1N0YXRlKTtcbiAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gY2FsbGJhY2soKSxcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgICAgIG51bGwgIT09IG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICYmXG4gICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgdGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlID0gY2hhaW5UaGVuYWJsZVZhbHVlKFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICAgICAgICBmaW5pc2hlZFN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgdGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlLFxuICAgICAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICAgIGZpbmlzaGVkU3RhdGUsXG4gICAgICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcilcbiAgICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgIHsgdGhlbjogZnVuY3Rpb24gKCkge30sIHN0YXR1czogXCJyZWplY3RlZFwiLCByZWFzb246IGVycm9yIH0sXG4gICAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgbnVsbCA9PT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzICYmXG4gICAgICAgICAgICAoKGZpYmVyID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZSksXG4gICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpLFxuICAgICAgICAgICAgMTAgPCBmaWJlciAmJlxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uIElmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuIE90aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS5cIlxuICAgICAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKSB7XG4gICAgICB2YXIgZXhpc3RpbmdTdGF0ZUhvb2sgPSBmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBleGlzdGluZ1N0YXRlSG9vaykgcmV0dXJuIGV4aXN0aW5nU3RhdGVIb29rO1xuICAgICAgZXhpc3RpbmdTdGF0ZUhvb2sgPSB7XG4gICAgICAgIG1lbW9pemVkU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgICAgICBiYXNlU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgICAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgICAgIHF1ZXVlOiB7XG4gICAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogTm90UGVuZGluZ1RyYW5zaXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIHZhciBpbml0aWFsUmVzZXRTdGF0ZSA9IHt9O1xuICAgICAgZXhpc3RpbmdTdGF0ZUhvb2submV4dCA9IHtcbiAgICAgICAgbWVtb2l6ZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGUsXG4gICAgICAgIGJhc2VTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGUsXG4gICAgICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICAgICAgcXVldWU6IHtcbiAgICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICAgIGxhbmVzOiAwLFxuICAgICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsUmVzZXRTdGF0ZVxuICAgICAgICB9LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgZm9ybUZpYmVyLm1lbW9pemVkU3RhdGUgPSBleGlzdGluZ1N0YXRlSG9vaztcbiAgICAgIGZvcm1GaWJlciA9IGZvcm1GaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBmb3JtRmliZXIgJiYgKGZvcm1GaWJlci5tZW1vaXplZFN0YXRlID0gZXhpc3RpbmdTdGF0ZUhvb2spO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nU3RhdGVIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFRyYW5zaXRpb24oKSB7XG4gICAgICB2YXIgc3RhdGVIb29rID0gbW91bnRTdGF0ZUltcGwoITEpO1xuICAgICAgc3RhdGVIb29rID0gc3RhcnRUcmFuc2l0aW9uLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIHN0YXRlSG9vay5xdWV1ZSxcbiAgICAgICAgITAsXG4gICAgICAgICExXG4gICAgICApO1xuICAgICAgbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlID0gc3RhdGVIb29rO1xuICAgICAgcmV0dXJuIFshMSwgc3RhdGVIb29rXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciBib29sZWFuT3JUaGVuYWJsZSA9IHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdLFxuICAgICAgICBzdGFydCA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgICAgPyBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICAgIDogdXNlVGhlbmFibGUoYm9vbGVhbk9yVGhlbmFibGUpLFxuICAgICAgICBzdGFydFxuICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIGJvb2xlYW5PclRoZW5hYmxlID0gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXSxcbiAgICAgICAgc3RhcnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICAgID8gYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA6IHVzZVRoZW5hYmxlKGJvb2xlYW5PclRoZW5hYmxlKSxcbiAgICAgICAgc3RhcnRcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzKCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KEhvc3RUcmFuc2l0aW9uQ29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SWQoKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggPSB3b3JrSW5Qcm9ncmVzc1Jvb3QuaWRlbnRpZmllclByZWZpeDtcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICB2YXIgdHJlZUlkID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgICAgICAgdmFyIGlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICAgICAgICB0cmVlSWQgPVxuICAgICAgICAgIChcbiAgICAgICAgICAgIGlkV2l0aExlYWRpbmdCaXQgJiB+KDEgPDwgKDMyIC0gY2x6MzIoaWRXaXRoTGVhZGluZ0JpdCkgLSAxKSlcbiAgICAgICAgICApLnRvU3RyaW5nKDMyKSArIHRyZWVJZDtcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCA9IFwiOlwiICsgaWRlbnRpZmllclByZWZpeCArIFwiUlwiICsgdHJlZUlkO1xuICAgICAgICB0cmVlSWQgPSBsb2NhbElkQ291bnRlcisrO1xuICAgICAgICAwIDwgdHJlZUlkICYmIChpZGVudGlmaWVyUHJlZml4ICs9IFwiSFwiICsgdHJlZUlkLnRvU3RyaW5nKDMyKSk7XG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggKz0gXCI6XCI7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKHRyZWVJZCA9IGdsb2JhbENsaWVudElkQ291bnRlcisrKSxcbiAgICAgICAgICAoaWRlbnRpZmllclByZWZpeCA9XG4gICAgICAgICAgICBcIjpcIiArIGlkZW50aWZpZXJQcmVmaXggKyBcInJcIiArIHRyZWVJZC50b1N0cmluZygzMikgKyBcIjpcIik7XG4gICAgICByZXR1cm4gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGlkZW50aWZpZXJQcmVmaXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFJlZnJlc2goKSB7XG4gICAgICByZXR1cm4gKG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZSA9IHJlZnJlc2hDYWNoZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxXG4gICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVmcmVzaENhY2hlKGZpYmVyLCBzZWVkS2V5KSB7XG4gICAgICBmb3IgKHZhciBwcm92aWRlciA9IGZpYmVyLnJldHVybjsgbnVsbCAhPT0gcHJvdmlkZXI7ICkge1xuICAgICAgICBzd2l0Y2ggKHByb3ZpZGVyLnRhZykge1xuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShwcm92aWRlcik7XG4gICAgICAgICAgICBmaWJlciA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgICAgICAgIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShwcm92aWRlciwgZmliZXIsIGxhbmUpO1xuICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIHByb3ZpZGVyLCBsYW5lKSxcbiAgICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBwcm92aWRlciwgbGFuZSkpO1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBjcmVhdGVDYWNoZSgpO1xuICAgICAgICAgICAgbnVsbCAhPT0gc2VlZEtleSAmJlxuICAgICAgICAgICAgICB2b2lkIDAgIT09IHNlZWRLZXkgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhlIHNlZWQgYXJndW1lbnQgaXMgbm90IGVuYWJsZWQgb3V0c2lkZSBleHBlcmltZW50YWwgY2hhbm5lbHMuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpYmVyLnBheWxvYWQgPSB7IGNhY2hlOiBwcm92aWRlciB9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb3ZpZGVyID0gcHJvdmlkZXIucmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaFJlZHVjZXJBY3Rpb24oXG4gICAgICBmaWJlcixcbiAgICAgIHF1ZXVlLFxuICAgICAgYWN0aW9uLFxuICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwXG4gICAgKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDAgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIHNlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS5cIlxuICAgICAgICApO1xuICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgICAgYWN0aW9uID0ge1xuICAgICAgICBsYW5lOiBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDAsXG4gICAgICAgIHJldmVydExhbmU6IDAsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBoYXNFYWdlclN0YXRlOiAhMSxcbiAgICAgICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpXG4gICAgICAgID8gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCBhY3Rpb24pXG4gICAgICAgIDogKChhY3Rpb24gPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwXG4gICAgICAgICAgKSksXG4gICAgICAgICAgbnVsbCAhPT0gYWN0aW9uICYmXG4gICAgICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKFxuICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDBcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUoXG4gICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgcXVldWUsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMFxuICAgICAgICAgICAgKSkpO1xuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlKFxuICAgICAgZmliZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIGFjdGlvbixcbiAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMVxuICAgICkge1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AxICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuXCJcbiAgICAgICAgKTtcbiAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgICAgZmliZXIsXG4gICAgICAgIHF1ZXVlLFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMVxuICAgICAgKTtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKGZpYmVyLCBxdWV1ZSwgYWN0aW9uLCBsYW5lKSB7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBsYW5lOiBsYW5lLFxuICAgICAgICByZXZlcnRMYW5lOiAwLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgMCA9PT0gZmliZXIubGFuZXMgJiZcbiAgICAgICAgICAobnVsbCA9PT0gYWx0ZXJuYXRlIHx8IDAgPT09IGFsdGVybmF0ZS5sYW5lcykgJiZcbiAgICAgICAgICAoKGFsdGVybmF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIpLCBudWxsICE9PSBhbHRlcm5hdGUpXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gcXVldWUubGFzdFJlbmRlcmVkU3RhdGUsXG4gICAgICAgICAgICAgIGVhZ2VyU3RhdGUgPSBhbHRlcm5hdGUoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgdXBkYXRlLmhhc0VhZ2VyU3RhdGUgPSAhMDtcbiAgICAgICAgICAgIHVwZGF0ZS5lYWdlclN0YXRlID0gZWFnZXJTdGF0ZTtcbiAgICAgICAgICAgIGlmIChvYmplY3RJcyhlYWdlclN0YXRlLCBjdXJyZW50U3RhdGUpKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgMCksXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmXG4gICAgICAgICAgICAgICAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCksXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjdGlvbiA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgIGlmIChudWxsICE9PSBhY3Rpb24pXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihhY3Rpb24sIGZpYmVyLCBsYW5lKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShhY3Rpb24sIHF1ZXVlLCBsYW5lKSxcbiAgICAgICAgICAgICEwXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUoXG4gICAgICBmaWJlcixcbiAgICAgIHRocm93SWZEdXJpbmdSZW5kZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIGFjdGlvblxuICAgICkge1xuICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCAmJlxuICAgICAgICAwID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQW4gb3B0aW1pc3RpYyBzdGF0ZSB1cGRhdGUgb2NjdXJyZWQgb3V0c2lkZSBhIHRyYW5zaXRpb24gb3IgYWN0aW9uLiBUbyBmaXgsIG1vdmUgdGhlIHVwZGF0ZSB0byBhbiBhY3Rpb24sIG9yIHdyYXAgd2l0aCBzdGFydFRyYW5zaXRpb24uXCJcbiAgICAgICAgKTtcbiAgICAgIGFjdGlvbiA9IHtcbiAgICAgICAgbGFuZTogMixcbiAgICAgICAgcmV2ZXJ0TGFuZTogcmVxdWVzdFRyYW5zaXRpb25MYW5lKCksXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBoYXNFYWdlclN0YXRlOiAhMSxcbiAgICAgICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkge1xuICAgICAgICBpZiAodGhyb3dJZkR1cmluZ1JlbmRlcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgb3B0aW1pc3RpYyBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2Fubm90IGNhbGwgc3RhcnRUcmFuc2l0aW9uIHdoaWxlIHJlbmRlcmluZy5cIik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKHRocm93SWZEdXJpbmdSZW5kZXIgPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoXG4gICAgICAgICAgZmliZXIsXG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIDJcbiAgICAgICAgKSksXG4gICAgICAgICAgbnVsbCAhPT0gdGhyb3dJZkR1cmluZ1JlbmRlciAmJlxuICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHRocm93SWZEdXJpbmdSZW5kZXIsIGZpYmVyLCAyKTtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgMik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBmaWJlciA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSB8fFxuICAgICAgICAobnVsbCAhPT0gYWx0ZXJuYXRlICYmIGFsdGVybmF0ZSA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSlcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKSB7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPVxuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITA7XG4gICAgICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG4gICAgICBudWxsID09PSBwZW5kaW5nXG4gICAgICAgID8gKHVwZGF0ZS5uZXh0ID0gdXBkYXRlKVxuICAgICAgICA6ICgodXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQpLCAocGVuZGluZy5uZXh0ID0gdXBkYXRlKSk7XG4gICAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpIHtcbiAgICAgIGlmICgwICE9PSAobGFuZSAmIDQxOTQxNzYpKSB7XG4gICAgICAgIHZhciBxdWV1ZUxhbmVzID0gcXVldWUubGFuZXM7XG4gICAgICAgIHF1ZXVlTGFuZXMgJj0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICAgIGxhbmUgfD0gcXVldWVMYW5lcztcbiAgICAgICAgcXVldWUubGFuZXMgPSBsYW5lO1xuICAgICAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBsYW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY2FsbGJhY2sgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGtleSA9IFN0cmluZyhjYWxsYmFjayk7XG4gICAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSB8fFxuICAgICAgICAgIChkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLFxuICAgICAgbmV4dFByb3BzXG4gICAgKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZvaWQgMCA9PT0gcGFydGlhbFN0YXRlICYmXG4gICAgICAgICgoY3RvciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjdG9yKSB8fFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGN0b3IpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLlwiLFxuICAgICAgICAgICAgY3RvclxuICAgICAgICAgICkpKTtcbiAgICAgIHByZXZTdGF0ZSA9XG4gICAgICAgIG51bGwgPT09IHBhcnRpYWxTdGF0ZSB8fCB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZVxuICAgICAgICAgID8gcHJldlN0YXRlXG4gICAgICAgICAgOiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBwcmV2U3RhdGU7XG4gICAgICAwID09PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcyAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuYmFzZVN0YXRlID0gcHJldlN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGN0b3IsXG4gICAgICBvbGRQcm9wcyxcbiAgICAgIG5ld1Byb3BzLFxuICAgICAgb2xkU3RhdGUsXG4gICAgICBuZXdTdGF0ZSxcbiAgICAgIG5leHRDb250ZXh0XG4gICAgKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgIG9sZFByb3BzID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgIG5leHRDb250ZXh0XG4gICAgICAgICk7XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2xkUHJvcHMgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgbmV4dENvbnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdm9pZCAwID09PSBvbGRQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhIGJvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG9sZFByb3BzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50XG4gICAgICAgID8gIXNoYWxsb3dFcXVhbChvbGRQcm9wcywgbmV3UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwob2xkU3RhdGUsIG5ld1N0YXRlKVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG5leHRDb250ZXh0XG4gICAgKSB7XG4gICAgICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyh3b3JrSW5Qcm9ncmVzcykgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50LmFkZCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKSksXG4gICAgICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIGluc3RhbmNlLnN0YXRlLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gICAgICB2YXIgbmV3UHJvcHMgPSBiYXNlUHJvcHM7XG4gICAgICBpZiAoXCJyZWZcIiBpbiBiYXNlUHJvcHMpIHtcbiAgICAgICAgbmV3UHJvcHMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gYmFzZVByb3BzKVxuICAgICAgICAgIFwicmVmXCIgIT09IHByb3BOYW1lICYmIChuZXdQcm9wc1twcm9wTmFtZV0gPSBiYXNlUHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIGlmICgoQ29tcG9uZW50ID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcykpIHtcbiAgICAgICAgbmV3UHJvcHMgPT09IGJhc2VQcm9wcyAmJiAobmV3UHJvcHMgPSBhc3NpZ24oe30sIG5ld1Byb3BzKSk7XG4gICAgICAgIGZvciAodmFyIF9wcm9wTmFtZSBpbiBDb21wb25lbnQpXG4gICAgICAgICAgdm9pZCAwID09PSBuZXdQcm9wc1tfcHJvcE5hbWVdICYmXG4gICAgICAgICAgICAobmV3UHJvcHNbX3Byb3BOYW1lXSA9IENvbXBvbmVudFtfcHJvcE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdQcm9wcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nVW5jYXVnaHRFcnJvcihyb290LCBlcnJvckluZm8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbXBvbmVudE5hbWUgPSBlcnJvckluZm8uc291cmNlXG4gICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGVycm9ySW5mby5zb3VyY2UpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGw7XG4gICAgICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlKVxuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG9uVW5jYXVnaHRFcnJvciA9IHJvb3Qub25VbmNhdWdodEVycm9yO1xuICAgICAgICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvciwgeyBjb21wb25lbnRTdGFjazogZXJyb3JJbmZvLnN0YWNrIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dDYXVnaHRFcnJvcihyb290LCBib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb21wb25lbnROYW1lID0gZXJyb3JJbmZvLnNvdXJjZVxuICAgICAgICAgID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihlcnJvckluZm8uc291cmNlKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGJvdW5kYXJ5KTtcbiAgICAgICAgdmFyIG9uQ2F1Z2h0RXJyb3IgPSByb290Lm9uQ2F1Z2h0RXJyb3I7XG4gICAgICAgIG9uQ2F1Z2h0RXJyb3IoZXJyb3JJbmZvLnZhbHVlLCB7XG4gICAgICAgICAgY29tcG9uZW50U3RhY2s6IGVycm9ySW5mby5zdGFjayxcbiAgICAgICAgICBlcnJvckJvdW5kYXJ5OiAxID09PSBib3VuZGFyeS50YWcgPyBib3VuZGFyeS5zdGF0ZU5vZGUgOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3QsIGVycm9ySW5mbywgbGFuZSkge1xuICAgICAgbGFuZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgIGxhbmUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgICAgIGxhbmUucGF5bG9hZCA9IHsgZWxlbWVudDogbnVsbCB9O1xuICAgICAgbGFuZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZXJyb3JJbmZvLnNvdXJjZSwgbG9nVW5jYXVnaHRFcnJvciwgcm9vdCwgZXJyb3JJbmZvKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShsYW5lKSB7XG4gICAgICBsYW5lID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgbGFuZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKHVwZGF0ZSwgcm9vdCwgZmliZXIsIGVycm9ySW5mbykge1xuICAgICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcikge1xuICAgICAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gICAgICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZXJyb3JJbmZvLnNvdXJjZSxcbiAgICAgICAgICAgIGxvZ0NhdWdodEVycm9yLFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgZXJyb3JJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBpbnN0ID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgbnVsbCAhPT0gaW5zdCAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoICYmXG4gICAgICAgICh1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZXJyb3JJbmZvLnNvdXJjZSxcbiAgICAgICAgICAgIGxvZ0NhdWdodEVycm9yLFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgZXJyb3JJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgJiZcbiAgICAgICAgICAgIChudWxsID09PSBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZFxuICAgICAgICAgICAgICA/IChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW3RoaXNdKSlcbiAgICAgICAgICAgICAgOiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5hZGQodGhpcykpO1xuICAgICAgICAgIGNhbGxDb21wb25lbnREaWRDYXRjaEluREVWKHRoaXMsIGVycm9ySW5mbyk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgICAoMCA9PT0gKGZpYmVyLmxhbmVzICYgMikgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuIEluIHRoYXQgbWV0aG9kLCByZXR1cm4gYSBzdGF0ZSB1cGRhdGUgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIG9yIGZhbGxiYWNrIFVJLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24oXG4gICAgICByb290LFxuICAgICAgcmV0dXJuRmliZXIsXG4gICAgICBzb3VyY2VGaWJlcixcbiAgICAgIHZhbHVlLFxuICAgICAgcm9vdFJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBzb3VyY2VGaWJlci5mbGFncyB8PSAzMjc2ODtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gdmFsdWUgJiZcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlLnRoZW5cbiAgICAgICkge1xuICAgICAgICByZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgc291cmNlRmliZXIsXG4gICAgICAgICAgICByb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICAgIGlzSHlkcmF0aW5nICYmIChkaWRTdXNwZW5kT3JFcnJvckRFViA9ICEwKTtcbiAgICAgICAgc291cmNlRmliZXIgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgICBpZiAobnVsbCAhPT0gc291cmNlRmliZXIpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNvdXJjZUZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBudWxsID09PSBzaGVsbEJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgICA/IHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKVxuICAgICAgICAgICAgICAgICAgOiBudWxsID09PSBzb3VyY2VGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgJj0gLTI1NyksXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIubGFuZXMgPSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgIHZhbHVlID09PSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGVcbiAgICAgICAgICAgICAgICAgID8gKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDE2Mzg0KVxuICAgICAgICAgICAgICAgICAgOiAoKHJldHVybkZpYmVyID0gc291cmNlRmliZXIudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICAgID8gKHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gbmV3IFNldChbdmFsdWVdKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHJldHVybkZpYmVyLmFkZCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlXG4gICAgICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci5mbGFncyB8PSAxNjM4NClcbiAgICAgICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICA/ICgocmV0dXJuRmliZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5UXVldWU6IG5ldyBTZXQoW3ZhbHVlXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gcmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICAgICAgICAgIDogKChzb3VyY2VGaWJlciA9IHJldHVybkZpYmVyLnJldHJ5UXVldWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAocmV0dXJuRmliZXIucmV0cnlRdWV1ZSA9IG5ldyBTZXQoW3ZhbHVlXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogc291cmNlRmliZXIuYWRkKHZhbHVlKSksXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgU3VzcGVuc2UgaGFuZGxlciB0YWcgKFwiICtcbiAgICAgICAgICAgICAgc291cmNlRmliZXIudGFnICtcbiAgICAgICAgICAgICAgXCIpLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgaWYgKGlzSHlkcmF0aW5nKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChkaWRTdXNwZW5kT3JFcnJvckRFViA9ICEwKSxcbiAgICAgICAgICAocmV0dXJuRmliZXIgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgPyAoMCA9PT0gKHJldHVybkZpYmVyLmZsYWdzICYgNjU1MzYpICYmIChyZXR1cm5GaWJlci5mbGFncyB8PSAyNTYpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIubGFuZXMgPSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICB2YWx1ZSAhPT0gSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gJiZcbiAgICAgICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGh5ZHJhdGluZyBidXQgUmVhY3Qgd2FzIGFibGUgdG8gcmVjb3ZlciBieSBpbnN0ZWFkIGNsaWVudCByZW5kZXJpbmcgZnJvbSB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeS5cIixcbiAgICAgICAgICAgICAgICAgICAgICB7IGNhdXNlOiB2YWx1ZSB9XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIDogKHZhbHVlICE9PSBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiAmJlxuICAgICAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5IGluc3RlYWQgY2xpZW50IHJlbmRlcmluZyB0aGUgZW50aXJlIHJvb3QuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgeyBjYXVzZTogdmFsdWUgfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChyb290ID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgICAgIChyb290LmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyAmPSAtcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHJvb3QubGFuZXMgfD0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZUZpYmVyKSksXG4gICAgICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgcm9vdC5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUocm9vdCwgcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQpKSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgdmFyIGVycm9yID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgIEVycm9yKFxuICAgICAgICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIGR1cmluZyBjb25jdXJyZW50IHJlbmRlcmluZyBidXQgUmVhY3Qgd2FzIGFibGUgdG8gcmVjb3ZlciBieSBpbnN0ZWFkIHN5bmNocm9ub3VzbHkgcmVuZGVyaW5nIHRoZSBlbnRpcmUgcm9vdC5cIixcbiAgICAgICAgICB7IGNhdXNlOiB2YWx1ZSB9XG4gICAgICAgICksXG4gICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICApO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9yc1xuICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gW2Vycm9yXSlcbiAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RFcnJvcmVkKTtcbiAgICAgIGlmIChudWxsID09PSByZXR1cm5GaWJlcikgcmV0dXJuICEwO1xuICAgICAgdmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlRmliZXIpO1xuICAgICAgc291cmNlRmliZXIgPSByZXR1cm5GaWJlcjtcbiAgICAgIGRvIHtcbiAgICAgICAgc3dpdGNoIChzb3VyY2VGaWJlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAocm9vdCA9IHJvb3RSZW5kZXJMYW5lcyAmIC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAoc291cmNlRmliZXIubGFuZXMgfD0gcm9vdCksXG4gICAgICAgICAgICAgIChyb290ID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKFxuICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyLnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICByb290XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUoc291cmNlRmliZXIsIHJvb3QpLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgocmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci50eXBlKSxcbiAgICAgICAgICAgICAgKGVycm9yID0gc291cmNlRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgMCA9PT0gKHNvdXJjZUZpYmVyLmZsYWdzICYgMTI4KSAmJlxuICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5GaWJlci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgfHxcbiAgICAgICAgICAgICAgICAgIChudWxsICE9PSBlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlcnJvci5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAhbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGVycm9yKSkpKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgJj0gLXJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmxhbmVzIHw9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUocm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgICByb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgc291cmNlRmliZXIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHNvdXJjZUZpYmVyLCByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlRmliZXIgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gICAgICB9IHdoaWxlIChudWxsICE9PSBzb3VyY2VGaWJlcik7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID1cbiAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgID8gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcylcbiAgICAgICAgICA6IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgY3VycmVudC5jaGlsZCxcbiAgICAgICAgICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRm9yd2FyZFJlZihcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBDb21wb25lbnQgPSBDb21wb25lbnQucmVuZGVyO1xuICAgICAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgIGlmIChcInJlZlwiIGluIG5leHRQcm9wcykge1xuICAgICAgICB2YXIgcHJvcHNXaXRob3V0UmVmID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBuZXh0UHJvcHMpXG4gICAgICAgICAgXCJyZWZcIiAhPT0ga2V5ICYmIChwcm9wc1dpdGhvdXRSZWZba2V5XSA9IG5leHRQcm9wc1trZXldKTtcbiAgICAgIH0gZWxzZSBwcm9wc1dpdGhvdXRSZWYgPSBuZXh0UHJvcHM7XG4gICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBuZXh0UHJvcHMgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHByb3BzV2l0aG91dFJlZixcbiAgICAgICAgcmVmLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICAgIGtleSA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgIWRpZFJlY2VpdmVVcGRhdGUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICk7XG4gICAgICBpc0h5ZHJhdGluZyAmJiBrZXkgJiYgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgIHZhciB0eXBlID0gQ29tcG9uZW50LnR5cGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgIXNob3VsZENvbnN0cnVjdCh0eXBlKSAmJlxuICAgICAgICAgIHZvaWQgMCA9PT0gdHlwZS5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICBudWxsID09PSBDb21wb25lbnQuY29tcGFyZVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChDb21wb25lbnQgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRhZyA9IDE1KSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50KSxcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSksXG4gICAgICAgICAgICB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgICAgICBDb21wb25lbnQudHlwZSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudCk7XG4gICAgICB9XG4gICAgICB0eXBlID0gY3VycmVudC5jaGlsZDtcbiAgICAgIGlmICghY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIHZhciBwcmV2UHJvcHMgPSB0eXBlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgIENvbXBvbmVudCA9IENvbXBvbmVudC5jb21wYXJlO1xuICAgICAgICBDb21wb25lbnQgPSBudWxsICE9PSBDb21wb25lbnQgPyBDb21wb25lbnQgOiBzaGFsbG93RXF1YWw7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBDb21wb25lbnQocHJldlByb3BzLCBuZXh0UHJvcHMpICYmXG4gICAgICAgICAgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZlxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgY3VycmVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHR5cGUsIG5leHRQcm9wcyk7XG4gICAgICBjdXJyZW50LnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgIGN1cnJlbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykgJiZcbiAgICAgICAgICBjdXJyZW50LnJlZiA9PT0gd29ya0luUHJvZ3Jlc3MucmVmICYmXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gY3VycmVudC50eXBlXG4gICAgICAgIClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoKGRpZFJlY2VpdmVVcGRhdGUgPSAhMSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gbmV4dFByb3BzID0gcHJldlByb3BzKSxcbiAgICAgICAgICAgIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzMTA3MikgJiYgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcyksXG4gICAgICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuLFxuICAgICAgICBuZXh0SXNEZXRhY2hlZCA9XG4gICAgICAgICAgMCAhPT0gKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5fcGVuZGluZ1Zpc2liaWxpdHkgJiAyKSxcbiAgICAgICAgcHJldlN0YXRlID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG4gICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmIChcImhpZGRlblwiID09PSBuZXh0UHJvcHMubW9kZSB8fCBuZXh0SXNEZXRhY2hlZCkge1xuICAgICAgICBpZiAoMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSkge1xuICAgICAgICAgIG5leHRQcm9wcyA9XG4gICAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICAgICAgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIHwgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgOiByZW5kZXJMYW5lcztcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgICAgICAgZm9yIChuZXh0SXNEZXRhY2hlZCA9IDA7IG51bGwgIT09IG5leHRDaGlsZHJlbjsgKVxuICAgICAgICAgICAgICAobmV4dElzRGV0YWNoZWQgPVxuICAgICAgICAgICAgICAgIG5leHRJc0RldGFjaGVkIHwgbmV4dENoaWxkcmVuLmxhbmVzIHwgbmV4dENoaWxkcmVuLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgICAgIChuZXh0Q2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW4uc2libGluZyk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gbmV4dElzRGV0YWNoZWQgJiB+bmV4dFByb3BzO1xuICAgICAgICAgIH0gZWxzZSAod29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IDApLCAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsKTtcbiAgICAgICAgICByZXR1cm4gZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgIT09IChyZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikpXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7IGJhc2VMYW5lczogMCwgY2FjaGVQb29sOiBudWxsIH0pLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBwdXNoVHJhbnNpdGlvbihcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGUgPyBwcmV2U3RhdGUuY2FjaGVQb29sIDogbnVsbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgICAgID8gcHVzaEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZSlcbiAgICAgICAgICAgICAgOiByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSA1MzY4NzA5MTIpLFxuICAgICAgICAgICAgZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICAgICAgICA/IHByZXZTdGF0ZS5iYXNlTGFuZXMgfCByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgIDogcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICA/IChwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlLmNhY2hlUG9vbCksXG4gICAgICAgICAgICBwdXNoSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlKSxcbiAgICAgICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGwpKVxuICAgICAgICAgIDogKG51bGwgIT09IGN1cnJlbnQgJiYgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIG51bGwpLFxuICAgICAgICAgICAgcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0QmFzZUxhbmVzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBwZWVrQ2FjaGVGcm9tUG9vbCgpO1xuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICAgICAgbnVsbCA9PT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIHBhcmVudDogaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgICA/IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlXG4gICAgICAgICAgICAgICAgOiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsXG4gICAgICAgICAgICAgIHBvb2w6IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgIGJhc2VMYW5lczogbmV4dEJhc2VMYW5lcyxcbiAgICAgICAgY2FjaGVQb29sOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgIH07XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICAgIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgITApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgICBpZiAobnVsbCA9PT0gcmVmKVxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5yZWYgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA5NzY2NCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHJlZiAmJiBcIm9iamVjdFwiICE9PSB0eXBlb2YgcmVmKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiwgYW4gb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZVJlZigpLCBvciB1bmRlZmluZWQvbnVsbC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA5NzY2NDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCAmJlxuICAgICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBudWxsXG4gICAgICAgICk7XG4gICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICh2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICBDb21wb25lbnQuY29udGV4dFR5cGVzICYmXG4gICAgICAgICAgKChjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlc1tjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXNbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggUmVhY3QudXNlQ29udGV4dCgpIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApKSkpO1xuICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgQ29tcG9uZW50ID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgICBuZXh0UHJvcHMgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICApO1xuICAgICAgaXNIeWRyYXRpbmcgJiYgbmV4dFByb3BzICYmIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBzZWNvbmRBcmcsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBjdXJyZW50LnR5cGUgIT09IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICBuZXh0UHJvcHMgPSByZW5kZXJXaXRoSG9va3NBZ2FpbihcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICBzZWNvbmRBcmdcbiAgICAgICk7XG4gICAgICBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBDb21wb25lbnQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICApO1xuICAgICAgaXNIeWRyYXRpbmcgJiYgQ29tcG9uZW50ICYmIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICBjdXJyZW50JGpzY29tcCQwLFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgc3dpdGNoIChzaG91bGRFcnJvckltcGwod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgIGNhc2UgITE6XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSxcbiAgICAgICAgICAgIHN0YXRlID0gbmV3IHdvcmtJblByb2dyZXNzLnR5cGUoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgIF9pbnN0YW5jZS5jb250ZXh0XG4gICAgICAgICAgICApLnN0YXRlO1xuICAgICAgICAgIF9pbnN0YW5jZS51cGRhdGVyLmVucXVldWVTZXRTdGF0ZShfaW5zdGFuY2UsIHN0YXRlLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAhMDpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjg7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjU1MzY7XG4gICAgICAgICAgX2luc3RhbmNlID0gRXJyb3IoXCJTaW11bGF0ZWQgZXJyb3IgY29taW5nIGZyb20gRGV2VG9vbHNcIik7XG4gICAgICAgICAgdmFyIGxhbmUgPSByZW5kZXJMYW5lcyAmIC1yZW5kZXJMYW5lcztcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyB8PSBsYW5lO1xuICAgICAgICAgIHN0YXRlID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICAgICAgICAgIGlmIChudWxsID09PSBzdGF0ZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkV4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsYW5lID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShsYW5lKTtcbiAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZShcbiAgICAgICAgICAgIGxhbmUsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoX2luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICApO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgbGFuZSk7XG4gICAgICB9XG4gICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKSB7XG4gICAgICAgIHN0YXRlID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICBfaW5zdGFuY2UgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgICAgIFwiY29udGV4dFR5cGVcIiBpbiBDb21wb25lbnQgJiZcbiAgICAgICAgICBudWxsICE9PSBfaW5zdGFuY2UgJiZcbiAgICAgICAgICAodm9pZCAwID09PSBfaW5zdGFuY2UgfHwgX2luc3RhbmNlLiQkdHlwZW9mICE9PSBSRUFDVF9DT05URVhUX1RZUEUpICYmXG4gICAgICAgICAgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoQ29tcG9uZW50KSAmJlxuICAgICAgICAgIChkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKENvbXBvbmVudCksXG4gICAgICAgICAgKGxhbmUgPVxuICAgICAgICAgICAgdm9pZCAwID09PSBfaW5zdGFuY2VcbiAgICAgICAgICAgICAgPyBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiBUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiBUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyB0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuXCJcbiAgICAgICAgICAgICAgOiBcIm9iamVjdFwiICE9PSB0eXBlb2YgX2luc3RhbmNlXG4gICAgICAgICAgICAgICAgPyBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSBcIiArIHR5cGVvZiBfaW5zdGFuY2UgKyBcIi5cIlxuICAgICAgICAgICAgICAgIDogX2luc3RhbmNlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFXG4gICAgICAgICAgICAgICAgICA/IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD9cIlxuICAgICAgICAgICAgICAgICAgOiBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7XCIgK1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfaW5zdGFuY2UpLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwifS5cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiBjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lc1wiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIixcbiAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICApKTtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIF9pbnN0YW5jZSAmJlxuICAgICAgICAgIG51bGwgIT09IF9pbnN0YW5jZSAmJlxuICAgICAgICAgIChzdGF0ZSA9IHJlYWRDb250ZXh0KF9pbnN0YW5jZSkpO1xuICAgICAgICBfaW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50KG5leHRQcm9wcywgc3RhdGUpO1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9pbnN0YW5jZSA9IG5ldyBDb21wb25lbnQobmV4dFByb3BzLCBzdGF0ZSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICBudWxsICE9PSBfaW5zdGFuY2Uuc3RhdGUgJiYgdm9pZCAwICE9PSBfaW5zdGFuY2Uuc3RhdGVcbiAgICAgICAgICAgID8gX2luc3RhbmNlLnN0YXRlXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIF9pbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBfaW5zdGFuY2U7XG4gICAgICAgIF9pbnN0YW5jZS5fcmVhY3RJbnRlcm5hbHMgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgX2luc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgIG51bGwgPT09IHN0YXRlICYmXG4gICAgICAgICAgKChzdGF0ZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCIpLFxuICAgICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoc3RhdGUpIHx8XG4gICAgICAgICAgICAoZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChzdGF0ZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImAlc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuIFRoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS5cIixcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIG51bGwgPT09IF9pbnN0YW5jZS5zdGF0ZSA/IFwibnVsbFwiIDogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICkpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAobGFuZSA9IHN0YXRlID0gbnVsbCk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICEwICE9PSBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgID8gKHN0YXRlID0gXCJjb21wb25lbnRXaWxsTW91bnRcIilcbiAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgKHN0YXRlID0gXCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50XCIpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgITAgIT09XG4gICAgICAgICAgICBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICA/IChsYW5lID0gXCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIpXG4gICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICAgIChsYW5lID0gXCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICEwICE9PSBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICA/IChmb3VuZFdpbGxVcGRhdGVOYW1lID0gXCJjb21wb25lbnRXaWxsVXBkYXRlXCIpXG4gICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAoZm91bmRXaWxsVXBkYXRlTmFtZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVcIik7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlIHx8IG51bGwgIT09IGxhbmUgfHwgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZSkge1xuICAgICAgICAgICAgX2luc3RhbmNlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICAgIHZhciBuZXdBcGlOYW1lID1cbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1xuICAgICAgICAgICAgICAgID8gXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKVwiXG4gICAgICAgICAgICAgICAgOiBcImdldFNuYXBzaG90QmVmb3JlVXBkYXRlKClcIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9pbnN0YW5jZSkgfHxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9pbnN0YW5jZSksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4lcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXNcIixcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgbmV3QXBpTmFtZSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBzdGF0ZSA/IFwiXFxuICBcIiArIHN0YXRlIDogXCJcIixcbiAgICAgICAgICAgICAgICBudWxsICE9PSBsYW5lID8gXCJcXG4gIFwiICsgbGFuZSA6IFwiXCIsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZSA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiBcIlwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHN0YXRlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgX2luc3RhbmNlLnJlbmRlciB8fFxuICAgICAgICAgIChDb21wb25lbnQucHJvdG90eXBlICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJcbiAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIk5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/XCIsXG4gICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyBpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuXCIsXG4gICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICFfaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8XG4gICAgICAgICAgX2luc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fFxuICAgICAgICAgIF9pbnN0YW5jZS5zdGF0ZSB8fFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImdldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuIERpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkP1wiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgIV9pbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2UuY29udGV4dFR5cGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAhZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMuaGFzKENvbXBvbmVudCkgJiZcbiAgICAgICAgICAoZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMuYWRkKENvbXBvbmVudCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNoaWxkQ29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKSk7XG4gICAgICAgIENvbXBvbmVudC5jb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEuaGFzKENvbXBvbmVudCkgJiZcbiAgICAgICAgICAoZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEuYWRkKENvbXBvbmVudCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBzdGF0aWMgY29udGV4dFR5cGUgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICkpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyBUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUgJiZcbiAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmXG4gICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiBzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuIFBsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJBIHB1cmUgY29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT9cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuIElmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCB1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciBydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT9cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT9cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgbGFuZSA9IF9pbnN0YW5jZS5wcm9wcyAhPT0gbmV4dFByb3BzO1xuICAgICAgICB2b2lkIDAgIT09IF9pbnN0YW5jZS5wcm9wcyAmJlxuICAgICAgICAgIGxhbmUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyB1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLmRlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlNldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy5cIixcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlIHx8XG4gICAgICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhDb21wb25lbnQpIHx8XG4gICAgICAgICAgKGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQoQ29tcG9uZW50KSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiBUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpXG4gICAgICAgICAgKSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICAobGFuZSA9IF9pbnN0YW5jZS5zdGF0ZSkgJiZcbiAgICAgICAgICAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGxhbmUgfHwgaXNBcnJheUltcGwobGFuZSkpICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIiVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbFwiLCBzdGF0ZSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgJiZcbiAgICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgX2luc3RhbmNlLnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBfaW5zdGFuY2UucmVmcyA9IHt9O1xuICAgICAgICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBzdGF0ZSA9IENvbXBvbmVudC5jb250ZXh0VHlwZTtcbiAgICAgICAgX2luc3RhbmNlLmNvbnRleHQgPVxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBzdGF0ZSAmJiBudWxsICE9PSBzdGF0ZVxuICAgICAgICAgICAgPyByZWFkQ29udGV4dChzdGF0ZSlcbiAgICAgICAgICAgIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPT09IG5leHRQcm9wcyAmJlxuICAgICAgICAgICgoc3RhdGUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoc3RhdGUpIHx8XG4gICAgICAgICAgICAoZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKHN0YXRlKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS5cIixcbiAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICkpKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSAmIDggJiZcbiAgICAgICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyhcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgX2luc3RhbmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgX2luc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHN0YXRlID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygc3RhdGUgJiZcbiAgICAgICAgICAoYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoX2luc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KSB8fFxuICAgICAgICAgICgoc3RhdGUgPSBfaW5zdGFuY2Uuc3RhdGUpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSxcbiAgICAgICAgICBzdGF0ZSAhPT0gX2luc3RhbmNlLnN0YXRlICYmXG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShcbiAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICBfaW5zdGFuY2Uuc3RhdGUsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBfaW5zdGFuY2UsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCksXG4gICAgICAgICAgKF9pbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpO1xuICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY3MTA4ODY0KTtcbiAgICAgICAgX2luc3RhbmNlID0gITA7XG4gICAgICB9IGVsc2UgaWYgKG51bGwgPT09IGN1cnJlbnQkanNjb21wJDApIHtcbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgbGFuZSA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKENvbXBvbmVudCwgdW5yZXNvbHZlZE9sZFByb3BzKTtcbiAgICAgICAgX2luc3RhbmNlLnByb3BzID0gbGFuZTtcbiAgICAgICAgdmFyIG9sZENvbnRleHQgPSBfaW5zdGFuY2UuY29udGV4dDtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9IENvbXBvbmVudC5jb250ZXh0VHlwZTtcbiAgICAgICAgc3RhdGUgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBmb3VuZFdpbGxVcGRhdGVOYW1lICYmXG4gICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZSAmJlxuICAgICAgICAgIChzdGF0ZSA9IHJlYWRDb250ZXh0KGZvdW5kV2lsbFVwZGF0ZU5hbWUpKTtcbiAgICAgICAgbmV3QXBpTmFtZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPVxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0FwaU5hbWUgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU7XG4gICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyAhPT0gdW5yZXNvbHZlZE9sZFByb3BzO1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lIHx8XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHx8XG4gICAgICAgICAgKCh1bnJlc29sdmVkT2xkUHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gc3RhdGUpICYmXG4gICAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgX2luc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICAgICAgb2xkQ29udGV4dCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gb2xkQ29udGV4dCB8fCBoYXNGb3JjZVVwZGF0ZVxuICAgICAgICAgID8gKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0FwaU5hbWUgJiZcbiAgICAgICAgICAgICAgKGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBuZXdBcGlOYW1lLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAob2xkQ29udGV4dCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKSxcbiAgICAgICAgICAgIChsYW5lID1cbiAgICAgICAgICAgICAgaGFzRm9yY2VVcGRhdGUgfHxcbiAgICAgICAgICAgICAgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGxhbmUsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIG9sZFN0YXRlLFxuICAgICAgICAgICAgICAgIG9sZENvbnRleHQsXG4gICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgPyAoZm91bmRXaWxsVXBkYXRlTmFtZSB8fFxuICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQpIHx8XG4gICAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCksXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpKSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjcxMDg4NjQpKVxuICAgICAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjcxMDg4NjQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG9sZENvbnRleHQpKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UucHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5zdGF0ZSA9IG9sZENvbnRleHQpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5jb250ZXh0ID0gc3RhdGUpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZSA9IGxhbmUpKVxuICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NzEwODg2NCksXG4gICAgICAgICAgICAoX2luc3RhbmNlID0gITEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50JGpzY29tcCQwLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKENvbXBvbmVudCwgc3RhdGUpO1xuICAgICAgICBfaW5zdGFuY2UucHJvcHMgPSBmb3VuZFdpbGxVcGRhdGVOYW1lO1xuICAgICAgICBuZXdBcGlOYW1lID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICBvbGRTdGF0ZSA9IF9pbnN0YW5jZS5jb250ZXh0O1xuICAgICAgICBvbGRDb250ZXh0ID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBsYW5lID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2xkQ29udGV4dCAmJlxuICAgICAgICAgIG51bGwgIT09IG9sZENvbnRleHQgJiZcbiAgICAgICAgICAobGFuZSA9IHJlYWRDb250ZXh0KG9sZENvbnRleHQpKTtcbiAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICAgICAgKG9sZENvbnRleHQgPVxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVucmVzb2x2ZWRPbGRQcm9wcyB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSkgfHxcbiAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykgfHxcbiAgICAgICAgICAoKHN0YXRlICE9PSBuZXdBcGlOYW1lIHx8IG9sZFN0YXRlICE9PSBsYW5lKSAmJlxuICAgICAgICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgbGFuZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgICAgIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBfaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBzdGF0ZSAhPT0gbmV3QXBpTmFtZSB8fFxuICAgICAgICBvbGRTdGF0ZSAhPT0gbmV3U3RhdGUgfHxcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgfHxcbiAgICAgICAgKG51bGwgIT09IGN1cnJlbnQkanNjb21wJDAgJiZcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50JGpzY29tcCQwLmRlcGVuZGVuY2llcyAmJlxuICAgICAgICAgIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50JGpzY29tcCQwLmRlcGVuZGVuY2llcykpXG4gICAgICAgICAgPyAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdW5yZXNvbHZlZE9sZFByb3BzICYmXG4gICAgICAgICAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAobmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSksXG4gICAgICAgICAgICAoZm91bmRXaWxsVXBkYXRlTmFtZSA9XG4gICAgICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgICAgICAgIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSxcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICBsYW5lXG4gICAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50JGpzY29tcCQwLmRlcGVuZGVuY2llcyAmJlxuICAgICAgICAgICAgICAgIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50JGpzY29tcCQwLmRlcGVuZGVuY2llcykpKVxuICAgICAgICAgICAgICA/IChvbGRDb250ZXh0IHx8XG4gICAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV3U3RhdGUsIGxhbmUpLFxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgbGFuZVxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCkpXG4gICAgICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICAgICAgICAgIChzdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgICAoc3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlKSksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZSksXG4gICAgICAgICAgICAoX2luc3RhbmNlLmNvbnRleHQgPSBsYW5lKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSBmb3VuZFdpbGxVcGRhdGVOYW1lKSlcbiAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlIHx8XG4gICAgICAgICAgICAgIChzdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgICAgIChzdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZSA9ICExKSk7XG4gICAgICB9XG4gICAgICBsYW5lID0gX2luc3RhbmNlO1xuICAgICAgbWFya1JlZihjdXJyZW50JGpzY29tcCQwLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzdGF0ZSA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCk7XG4gICAgICBpZiAobGFuZSB8fCBzdGF0ZSkge1xuICAgICAgICBsYW5lID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPVxuICAgICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzID8gbnVsbCA6IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgICAgIGlzUmVuZGVyaW5nID0gITE7XG4gICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgaWYgKHN0YXRlICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IpXG4gICAgICAgICAgKENvbXBvbmVudCA9IG51bGwpLCAocHJvZmlsZXJTdGFydFRpbWUgPSAtMSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBDb21wb25lbnQgPSBjYWxsUmVuZGVySW5ERVYobGFuZSk7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiA4KSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjYWxsUmVuZGVySW5ERVYobGFuZSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCRqc2NvbXAkMCAmJiBzdGF0ZVxuICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgY3VycmVudCRqc2NvbXAkMC5jaGlsZCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSlcbiAgICAgICAgICA6IHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50JGpzY29tcCQwLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGxhbmUuc3RhdGU7XG4gICAgICAgIGN1cnJlbnQkanNjb21wJDAgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIH0gZWxzZVxuICAgICAgICBjdXJyZW50JGpzY29tcCQwID0gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgICBjdXJyZW50JGpzY29tcCQwLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICk7XG4gICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIF9pbnN0YW5jZSAmJlxuICAgICAgICByZW5kZXJMYW5lcy5wcm9wcyAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgIChkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcImEgY29tcG9uZW50XCJcbiAgICAgICAgICApLFxuICAgICAgICAoZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9ICEwKSk7XG4gICAgICByZXR1cm4gY3VycmVudCRqc2NvbXAkMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjU2O1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCkge1xuICAgICAgQ29tcG9uZW50ICYmXG4gICAgICAgIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuXFxuICAlcy5jaGlsZENvbnRleHRUeXBlcyA9IC4uLlwiLFxuICAgICAgICAgIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICk7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICgod29ya0luUHJvZ3Jlc3MgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIlVua25vd25cIiksXG4gICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbd29ya0luUHJvZ3Jlc3NdIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy5cIixcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFt3b3JrSW5Qcm9ncmVzc10gPVxuICAgICAgICAgICAgITApKSk7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlICYmXG4gICAgICAgIG51bGwgIT09IENvbXBvbmVudC5jb250ZXh0VHlwZSAmJlxuICAgICAgICAoKENvbXBvbmVudCA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W0NvbXBvbmVudF0gfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuXCIsXG4gICAgICAgICAgICBDb21wb25lbnRcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbQ29tcG9uZW50XSA9ICEwKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIHtcbiAgICAgIHJldHVybiB7IGJhc2VMYW5lczogcmVuZGVyTGFuZXMsIGNhY2hlUG9vbDogZ2V0U3VzcGVuZGVkQ2FjaGUoKSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwcmltYXJ5VHJlZURpZERlZmVyLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGN1cnJlbnQgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5jaGlsZExhbmVzICYgfnJlbmRlckxhbmVzIDogMDtcbiAgICAgIHByaW1hcnlUcmVlRGlkRGVmZXIgJiYgKGN1cnJlbnQgfD0gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHNob3VsZFN1c3BlbmRJbXBsKHdvcmtJblByb2dyZXNzKSAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KTtcbiAgICAgIHZhciBzaG93RmFsbGJhY2sgPSAhMSxcbiAgICAgICAgZGlkU3VzcGVuZCA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCksXG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcDtcbiAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSBkaWRTdXNwZW5kKSB8fFxuICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgPT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyAhMVxuICAgICAgICAgICAgOiAwICE9PSAoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICYgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKSk7XG4gICAgICBKU0NvbXBpbGVyX3RlbXAgJiYgKChzaG93RmFsbGJhY2sgPSAhMCksICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTI5KSk7XG4gICAgICBKU0NvbXBpbGVyX3RlbXAgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAzMik7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMzM7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICBzaG93RmFsbGJhY2tcbiAgICAgICAgICAgID8gcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgOiByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMDtcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSAhbmV4dEluc3RhbmNlKSB8fFxuICAgICAgICAgICAgICAoKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgIG5leHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBudWxsICE9PSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDBcbiAgICAgICAgICAgICAgICA/ICh3YXJuSWZOb3RIeWRyYXRpbmcoKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBkZWh5ZHJhdGVkOiBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIHRyZWVDb250ZXh0OlxuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHRyZWVDb250ZXh0UHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBpZDogdHJlZUNvbnRleHRJZCwgb3ZlcmZsb3c6IHRyZWVDb250ZXh0T3ZlcmZsb3cgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXRyeUxhbmU6IDUzNjg3MDkxMlxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAoZGlkU3VzcGVuZCA9IGNyZWF0ZUZpYmVyKDE4LCBudWxsLCBudWxsLCBOb01vZGUpKSxcbiAgICAgICAgICAgICAgICAgIChkaWRTdXNwZW5kLnN0YXRlTm9kZSA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCksXG4gICAgICAgICAgICAgICAgICAoZGlkU3VzcGVuZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBkaWRTdXNwZW5kKSxcbiAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gITApKVxuICAgICAgICAgICAgICAgIDogKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9ICExKSxcbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9ICFKU0NvbXBpbGVyX3RlbXAkanNjb21wJDApKTtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAod2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIG5leHRJbnN0YW5jZSksXG4gICAgICAgICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0SW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgIT09IG5leHRJbnN0YW5jZSAmJlxuICAgICAgICAgICAgKChuZXh0SW5zdGFuY2UgPSBuZXh0SW5zdGFuY2UuZGVoeWRyYXRlZCksIG51bGwgIT09IG5leHRJbnN0YW5jZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhuZXh0SW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSAxNilcbiAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDUzNjg3MDkxMiksXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0SW5zdGFuY2UgPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICAgIG5leHRQcm9wcyA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgICAgaWYgKHNob3dGYWxsYmFjaylcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlKSxcbiAgICAgICAgICAgIChuZXh0SW5zdGFuY2UgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoXG4gICAgICAgICAgICAgIHsgbW9kZTogXCJoaWRkZW5cIiwgY2hpbGRyZW46IG5leHRJbnN0YW5jZSB9LFxuICAgICAgICAgICAgICBzaG93RmFsbGJhY2tcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIHNob3dGYWxsYmFjayxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKG5leHRJbnN0YW5jZS5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAobmV4dFByb3BzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChuZXh0SW5zdGFuY2Uuc2libGluZyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXh0SW5zdGFuY2UpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2subWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgICAgIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjay5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgJiZcbiAgICAgICAgKChuZXh0SW5zdGFuY2UgPSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAuZGVoeWRyYXRlZCksXG4gICAgICAgIG51bGwgIT09IG5leHRJbnN0YW5jZSlcbiAgICAgICkge1xuICAgICAgICBpZiAoZGlkU3VzcGVuZClcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NlxuICAgICAgICAgICAgPyAocHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0yNTcpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgOiBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gKHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbnVsbCkpXG4gICAgICAgICAgICAgIDogKHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IG5leHRQcm9wcy5mYWxsYmFjayksXG4gICAgICAgICAgICAgICAgKG5leHRJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoXG4gICAgICAgICAgICAgICAgICB7IG1vZGU6IFwidmlzaWJsZVwiLCBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuIH0sXG4gICAgICAgICAgICAgICAgICBuZXh0SW5zdGFuY2VcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgICBuZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLmZsYWdzIHw9IDIpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChzaG93RmFsbGJhY2sucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMuc2libGluZyA9IHNob3dGYWxsYmFjayksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudC5jaGlsZCxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgICAgKG5leHRQcm9wcy5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVIpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHNob3dGYWxsYmFjaykpO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAocHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJXZSBzaG91bGQgbm90IGJlIGh5ZHJhdGluZyBoZXJlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhIGJ1Zy5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhuZXh0SW5zdGFuY2UpKVxuICAgICAgICApXG4gICAgICAgICAgKG5leHRJbnN0YW5jZSA9XG4gICAgICAgICAgICBnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMobmV4dEluc3RhbmNlKSksXG4gICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID0gbmV4dEluc3RhbmNlLmRpZ2VzdCksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gbmV4dEluc3RhbmNlLm1lc3NhZ2UpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IG5leHRJbnN0YW5jZS5zdGFjayksXG4gICAgICAgICAgICAobmV4dEluc3RhbmNlID0gbmV4dEluc3RhbmNlLmNvbXBvbmVudFN0YWNrKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSBzaG93RmFsbGJhY2tcbiAgICAgICAgICAgICAgPyBFcnJvcihzaG93RmFsbGJhY2spXG4gICAgICAgICAgICAgIDogRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBzZXJ2ZXIgY291bGQgbm90IGZpbmlzaCB0aGlzIFN1c3BlbnNlIGJvdW5kYXJ5LCBsaWtlbHkgZHVlIHRvIGFuIGVycm9yIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLiBTd2l0Y2hlZCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLnN0YWNrID0gbmV4dFByb3BzIHx8IFwiXCIpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjay5kaWdlc3QgPSBKU0NvbXBpbGVyX3RlbXApLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IHZvaWQgMCA9PT0gbmV4dEluc3RhbmNlID8gbnVsbCA6IG5leHRJbnN0YW5jZSksXG4gICAgICAgICAgICAobmV4dFByb3BzID0ge1xuICAgICAgICAgICAgICB2YWx1ZTogc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgICAgIHN0YWNrOiBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIEpTQ29tcGlsZXJfdGVtcCAmJlxuICAgICAgICAgICAgICBDYXB0dXJlZFN0YWNrcy5zZXQoc2hvd0ZhbGxiYWNrLCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChkaWRSZWNlaXZlVXBkYXRlIHx8XG4gICAgICAgICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID0gMCAhPT0gKHJlbmRlckxhbmVzICYgY3VycmVudC5jaGlsZExhbmVzKSksXG4gICAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSB8fCBKU0NvbXBpbGVyX3RlbXApXG4gICAgICAgICkge1xuICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gSlNDb21waWxlcl90ZW1wKSB7XG4gICAgICAgICAgICBuZXh0UHJvcHMgPSByZW5kZXJMYW5lcyAmIC1yZW5kZXJMYW5lcztcbiAgICAgICAgICAgIGlmICgwICE9PSAobmV4dFByb3BzICYgNDIpKSBuZXh0UHJvcHMgPSAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBzd2l0Y2ggKG5leHRQcm9wcykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyA9IDE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSA0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyA9IDE2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgICAgICAgICAgY2FzZSA1MTI6XG4gICAgICAgICAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICAgICAgICAgIGNhc2UgMjA0ODpcbiAgICAgICAgICAgICAgICBjYXNlIDQwOTY6XG4gICAgICAgICAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICAgICAgICAgIGNhc2UgMTYzODQ6XG4gICAgICAgICAgICAgICAgY2FzZSAzMjc2ODpcbiAgICAgICAgICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICAgICAgICAgIGNhc2UgMTMxMDcyOlxuICAgICAgICAgICAgICAgIGNhc2UgMjYyMTQ0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICAgICAgICAgIGNhc2UgMTA0ODU3NjpcbiAgICAgICAgICAgICAgICBjYXNlIDIwOTcxNTI6XG4gICAgICAgICAgICAgICAgY2FzZSA0MTk0MzA0OlxuICAgICAgICAgICAgICAgIGNhc2UgODM4ODYwODpcbiAgICAgICAgICAgICAgICBjYXNlIDE2Nzc3MjE2OlxuICAgICAgICAgICAgICAgIGNhc2UgMzM1NTQ0MzI6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSA2NDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzID0gMTM0MjE3NzI4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRQcm9wcyA9XG4gICAgICAgICAgICAgIDAgIT09IChuZXh0UHJvcHMgJiAoSlNDb21waWxlcl90ZW1wLnN1c3BlbmRlZExhbmVzIHwgcmVuZGVyTGFuZXMpKVxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogbmV4dFByb3BzO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAwICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgICAgICAgbmV4dFByb3BzICE9PSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAucmV0cnlMYW5lXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAoKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5yZXRyeUxhbmUgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShjdXJyZW50LCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihKU0NvbXBpbGVyX3RlbXAsIGN1cnJlbnQsIG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKG5leHRJbnN0YW5jZSkgfHxcbiAgICAgICAgICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKG5leHRJbnN0YW5jZSlcbiAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeS5iaW5kKFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkobmV4dEluc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpKVxuICAgICAgICAgICAgOiAoKGN1cnJlbnQgPSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAudHJlZUNvbnRleHQpLFxuICAgICAgICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAgICAgICAgICgobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UobmV4dEluc3RhbmNlKSksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChpc0h5ZHJhdGluZyA9ICEwKSxcbiAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKGRpZFN1c3BlbmRPckVycm9yREVWID0gITEpLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITEpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICh3YXJuSWZOb3RIeWRyYXRpbmcoKSxcbiAgICAgICAgICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0SWQpLFxuICAgICAgICAgICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRPdmVyZmxvdyksXG4gICAgICAgICAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dFByb3ZpZGVyKSxcbiAgICAgICAgICAgICAgICAgICh0cmVlQ29udGV4dElkID0gY3VycmVudC5pZCksXG4gICAgICAgICAgICAgICAgICAodHJlZUNvbnRleHRPdmVyZmxvdyA9IGN1cnJlbnQub3ZlcmZsb3cpLFxuICAgICAgICAgICAgICAgICAgKHRyZWVDb250ZXh0UHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcykpKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MDk2KSk7XG4gICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cbiAgICAgIGlmIChzaG93RmFsbGJhY2spXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gbmV4dFByb3BzLmZhbGxiYWNrKSxcbiAgICAgICAgICAobmV4dEluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3MubW9kZSksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgIChkaWRTdXNwZW5kID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnNpYmxpbmcpLFxuICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAsIHtcbiAgICAgICAgICAgIG1vZGU6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIChuZXh0UHJvcHMuc3VidHJlZUZsYWdzID1cbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5zdWJ0cmVlRmxhZ3MgJiAzMTQ1NzI4MCksXG4gICAgICAgICAgbnVsbCAhPT0gZGlkU3VzcGVuZFxuICAgICAgICAgICAgPyAoc2hvd0ZhbGxiYWNrID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZGlkU3VzcGVuZCwgc2hvd0ZhbGxiYWNrKSlcbiAgICAgICAgICAgIDogKChzaG93RmFsbGJhY2sgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChzaG93RmFsbGJhY2suZmxhZ3MgfD0gMikpLFxuICAgICAgICAgIChzaG93RmFsbGJhY2sucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIChuZXh0UHJvcHMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIChuZXh0UHJvcHMuc2libGluZyA9IHNob3dGYWxsYmFjayksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAobmV4dFByb3BzID0gc2hvd0ZhbGxiYWNrKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgIChuZXh0SW5zdGFuY2UgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgIG51bGwgPT09IG5leHRJbnN0YW5jZVxuICAgICAgICAgICAgPyAobmV4dEluc3RhbmNlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSlcbiAgICAgICAgICAgIDogKChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBuZXh0SW5zdGFuY2UuY2FjaGVQb29sKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgPyAoKGRpZFN1c3BlbmQgPSBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICAgICAgICAgICAgICA/IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAucGFyZW50ICE9PSBkaWRTdXNwZW5kXG4gICAgICAgICAgICAgICAgICAgICAgPyB7IHBhcmVudDogZGlkU3VzcGVuZCwgcG9vbDogZGlkU3VzcGVuZCB9XG4gICAgICAgICAgICAgICAgICAgICAgOiBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDApKVxuICAgICAgICAgICAgICAgIDogKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGdldFN1c3BlbmRlZENhY2hlKCkpLFxuICAgICAgICAgICAgICAobmV4dEluc3RhbmNlID0ge1xuICAgICAgICAgICAgICAgIGJhc2VMYW5lczogbmV4dEluc3RhbmNlLmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIGNhY2hlUG9vbDogSlNDb21waWxlcl90ZW1wJGpzY29tcCQwXG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrLm1lbW9pemVkU3RhdGUgPSBuZXh0SW5zdGFuY2UpLFxuICAgICAgICAgIChzaG93RmFsbGJhY2suY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgKTtcbiAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZW5kZXJMYW5lcyA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICBjdXJyZW50ID0gcmVuZGVyTGFuZXMuc2libGluZztcbiAgICAgIHJlbmRlckxhbmVzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MocmVuZGVyTGFuZXMsIHtcbiAgICAgICAgbW9kZTogXCJ2aXNpYmxlXCIsXG4gICAgICAgIGNoaWxkcmVuOiBuZXh0UHJvcHMuY2hpbGRyZW5cbiAgICAgIH0pO1xuICAgICAgcmVuZGVyTGFuZXMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICByZW5kZXJMYW5lcy5zaWJsaW5nID0gbnVsbDtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAgPSB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMpLFxuICAgICAgICBudWxsID09PSBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gW2N1cnJlbnRdKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxNikpXG4gICAgICAgICAgOiBKU0NvbXBpbGVyX3RlbXAucHVzaChjdXJyZW50KSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gcmVuZGVyTGFuZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbikge1xuICAgICAgcHJpbWFyeUNoaWxkcmVuID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKFxuICAgICAgICB7IG1vZGU6IFwidmlzaWJsZVwiLCBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuIH0sXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGVcbiAgICAgICk7XG4gICAgICBwcmltYXJ5Q2hpbGRyZW4ucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkcmVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKG9mZnNjcmVlblByb3BzLCBtb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKG9mZnNjcmVlblByb3BzLCBtb2RlLCAwLCBudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgICAgIGN1cnJlbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuXG4gICAgICApO1xuICAgICAgY3VycmVudC5mbGFncyB8PSAyO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKGZpYmVyLCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KSB7XG4gICAgICBmaWJlci5sYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgKGFsdGVybmF0ZS5sYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgICBmaWJlci5yZXR1cm4sXG4gICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICBwcm9wYWdhdGlvblJvb3RcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRTbG90LCBpbmRleCkge1xuICAgICAgdmFyIGlzQW5BcnJheSA9IGlzQXJyYXlJbXBsKGNoaWxkU2xvdCk7XG4gICAgICBjaGlsZFNsb3QgPSAhaXNBbkFycmF5ICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldEl0ZXJhdG9yRm4oY2hpbGRTbG90KTtcbiAgICAgIHJldHVybiBpc0FuQXJyYXkgfHwgY2hpbGRTbG90XG4gICAgICAgID8gKChpc0FuQXJyYXkgPSBpc0FuQXJyYXkgPyBcImFycmF5XCIgOiBcIml0ZXJhYmxlXCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkEgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluIGFuIGFkZGl0aW9uYWwgU3VzcGVuc2VMaXN0IHRvIGNvbmZpZ3VyZSBpdHMgcmV2ZWFsT3JkZXI6IDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPiAuLi4gPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gPC9TdXNwZW5zZUxpc3Q+XCIsXG4gICAgICAgICAgICBpc0FuQXJyYXksXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGlzQW5BcnJheVxuICAgICAgICAgICksXG4gICAgICAgICAgITEpXG4gICAgICAgIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgaXNCYWNrd2FyZHMsXG4gICAgICB0YWlsLFxuICAgICAgbGFzdENvbnRlbnRSb3csXG4gICAgICB0YWlsTW9kZVxuICAgICkge1xuICAgICAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIG51bGwgPT09IHJlbmRlclN0YXRlXG4gICAgICAgID8gKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICAgICAgICByZW5kZXJpbmc6IG51bGwsXG4gICAgICAgICAgICByZW5kZXJpbmdTdGFydFRpbWU6IDAsXG4gICAgICAgICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgICAgICAgIHRhaWw6IHRhaWwsXG4gICAgICAgICAgICB0YWlsTW9kZTogdGFpbE1vZGVcbiAgICAgICAgICB9KVxuICAgICAgICA6ICgocmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcyksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGwpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSAwKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93KSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUudGFpbCA9IHRhaWwpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS50YWlsTW9kZSA9IHRhaWxNb2RlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgIHJldmVhbE9yZGVyID0gbmV4dFByb3BzLnJldmVhbE9yZGVyLFxuICAgICAgICB0YWlsTW9kZSA9IG5leHRQcm9wcy50YWlsO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKFxuICAgICAgICB2b2lkIDAgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwiZm9yd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgXCJiYWNrd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgXCJ0b2dldGhlclwiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICAhZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdXG4gICAgICApXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKGRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSA9ICEwKSxcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcmV2ZWFsT3JkZXIpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0b2dldGhlclwiOlxuICAgICAgICAgICAgY2FzZSBcImZvcndhcmRzXCI6XG4gICAgICAgICAgICBjYXNlIFwiYmFja3dhcmRzXCI6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gVXNlIGxvd2VyY2FzZSBcIiVzXCIgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZm9yd2FyZFwiOlxuICAgICAgICAgICAgY2FzZSBcImJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gUmVhY3QgdXNlcyB0aGUgLXMgc3VmZml4IGluIHRoZSBzcGVsbGluZy4gVXNlIFwiJXNzXCIgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIERpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsXG4gICAgICAgICAgICAgICAgcmV2ZWFsT3JkZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJyVzIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JyxcbiAgICAgICAgICAgIHJldmVhbE9yZGVyXG4gICAgICAgICAgKTtcbiAgICAgIHZvaWQgMCA9PT0gdGFpbE1vZGUgfHxcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdIHx8XG4gICAgICAgIChcImNvbGxhcHNlZFwiICE9PSB0YWlsTW9kZSAmJiBcImhpZGRlblwiICE9PSB0YWlsTW9kZVxuICAgICAgICAgID8gKChkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgdGFpbCBvbiA8U3VzcGVuc2VMaXN0IC8+LiBEaWQgeW91IG1lYW4gXCJjb2xsYXBzZWRcIiBvciBcImhpZGRlblwiPycsXG4gICAgICAgICAgICAgIHRhaWxNb2RlXG4gICAgICAgICAgICApKVxuICAgICAgICAgIDogXCJmb3J3YXJkc1wiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICAgICAgXCJiYWNrd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgICAgICgoZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJzxTdXNwZW5zZUxpc3QgdGFpbD1cIiVzXCIgLz4gaXMgb25seSB2YWxpZCBpZiByZXZlYWxPcmRlciBpcyBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIi4gRGlkIHlvdSBtZWFuIHRvIHNwZWNpZnkgcmV2ZWFsT3JkZXI9XCJmb3J3YXJkc1wiPycsXG4gICAgICAgICAgICAgIHRhaWxNb2RlXG4gICAgICAgICAgICApKSk7XG4gICAgICBhOiBpZiAoXG4gICAgICAgIChcImZvcndhcmRzXCIgPT09IHJldmVhbE9yZGVyIHx8IFwiYmFja3dhcmRzXCIgPT09IHJldmVhbE9yZGVyKSAmJlxuICAgICAgICB2b2lkIDAgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICBudWxsICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgITEgIT09IG5leHRQcm9wc1xuICAgICAgKVxuICAgICAgICBpZiAoaXNBcnJheUltcGwobmV4dFByb3BzKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKG5leHRQcm9wc1tpXSwgaSkpIGJyZWFrIGE7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKGkgPSBnZXRJdGVyYXRvckZuKG5leHRQcm9wcykpLCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpKSkge1xuICAgICAgICAgIGlmICgoaSA9IGkuY2FsbChuZXh0UHJvcHMpKSlcbiAgICAgICAgICAgIGZvciAodmFyIHN0ZXAgPSBpLm5leHQoKSwgX2kgPSAwOyAhc3RlcC5kb25lOyBzdGVwID0gaS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKHN0ZXAudmFsdWUsIF9pKSkgYnJlYWsgYTtcbiAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHNpbmdsZSByb3cgd2FzIHBhc3NlZCB0byBhIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9XCIlc1wiIC8+LiBUaGlzIGlzIG5vdCB1c2VmdWwgc2luY2UgaXQgbmVlZHMgbXVsdGlwbGUgcm93cy4gRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JyxcbiAgICAgICAgICAgIHJldmVhbE9yZGVyXG4gICAgICAgICAgKTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIG5leHRQcm9wcyA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgIGlmICgwICE9PSAobmV4dFByb3BzICYgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKSlcbiAgICAgICAgKG5leHRQcm9wcyA9XG4gICAgICAgICAgKG5leHRQcm9wcyAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSB8IEZvcmNlU3VzcGVuc2VGYWxsYmFjayksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMjgpKVxuICAgICAgICAgIGE6IGZvciAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBjdXJyZW50OyApIHtcbiAgICAgICAgICAgIGlmICgxMyA9PT0gY3VycmVudC50YWcpXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKDE5ID09PSBjdXJyZW50LnRhZylcbiAgICAgICAgICAgICAgc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKGN1cnJlbnQsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBlbHNlIGlmIChudWxsICE9PSBjdXJyZW50LmNoaWxkKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQucmV0dXJuID0gY3VycmVudDtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHdvcmtJblByb2dyZXNzKSBicmVhayBhO1xuICAgICAgICAgICAgZm9yICg7IG51bGwgPT09IGN1cnJlbnQuc2libGluZzsgKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50LnJldHVybiB8fCBjdXJyZW50LnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudC5zaWJsaW5nLnJldHVybiA9IGN1cnJlbnQucmV0dXJuO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgIG5leHRQcm9wcyAmPSBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaztcbiAgICAgIH1cbiAgICAgIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgbmV4dFByb3BzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzd2l0Y2ggKHJldmVhbE9yZGVyKSB7XG4gICAgICAgIGNhc2UgXCJmb3J3YXJkc1wiOlxuICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgZm9yIChyZXZlYWxPcmRlciA9IG51bGw7IG51bGwgIT09IHJlbmRlckxhbmVzOyApXG4gICAgICAgICAgICAoY3VycmVudCA9IHJlbmRlckxhbmVzLmFsdGVybmF0ZSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICBudWxsID09PSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCkgJiZcbiAgICAgICAgICAgICAgICAocmV2ZWFsT3JkZXIgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcpO1xuICAgICAgICAgIHJlbmRlckxhbmVzID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgICAgbnVsbCA9PT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICAgID8gKChyZXZlYWxPcmRlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbCkpXG4gICAgICAgICAgICA6ICgocmV2ZWFsT3JkZXIgPSByZW5kZXJMYW5lcy5zaWJsaW5nKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsKSk7XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAhMSxcbiAgICAgICAgICAgIHJldmVhbE9yZGVyLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJiYWNrd2FyZHNcIjpcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IG51bGw7XG4gICAgICAgICAgcmV2ZWFsT3JkZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICBmb3IgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDsgbnVsbCAhPT0gcmV2ZWFsT3JkZXI7ICkge1xuICAgICAgICAgICAgY3VycmVudCA9IHJldmVhbE9yZGVyLmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgPT09IGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50KSkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJldmVhbE9yZGVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSByZXZlYWxPcmRlci5zaWJsaW5nO1xuICAgICAgICAgICAgcmV2ZWFsT3JkZXIuc2libGluZyA9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSByZXZlYWxPcmRlcjtcbiAgICAgICAgICAgIHJldmVhbE9yZGVyID0gY3VycmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAhMCxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRhaWxNb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvZ2V0aGVyXCI6XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCAhMSwgbnVsbCwgbnVsbCwgdm9pZCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcyk7XG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IHdvcmtJblByb2dyZXNzLmxhbmVzO1xuICAgICAgaWYgKDAgPT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKVxuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIDAgPT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgcmVuZGVyTGFuZXMgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBjdXJyZW50LnBlbmRpbmdQcm9wcyk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyTGFuZXM7XG4gICAgICAgIGZvciAocmVuZGVyTGFuZXMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7IG51bGwgIT09IGN1cnJlbnQuc2libGluZzsgKVxuICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcgPVxuICAgICAgICAgICAgICBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBjdXJyZW50LnBlbmRpbmdQcm9wcykpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVuZGVyTGFuZXMuc2libGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gICAgICBpZiAoMCAhPT0gKGN1cnJlbnQubGFuZXMgJiByZW5kZXJMYW5lcykpIHJldHVybiAhMDtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICAgIHJldHVybiBudWxsICE9PSBjdXJyZW50ICYmIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50KSA/ICEwIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICApO1xuICAgICAgICAgIHB1c2hQcm92aWRlcihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ2FjaGVDb250ZXh0LFxuICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDg7XG4gICAgICAgICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAtMDtcbiAgICAgICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGVOb2RlKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGVOb2RlLmRlaHlkcmF0ZWQpXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGQuY2hpbGRMYW5lcykpXG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgY3VycmVudCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5zaWJsaW5nIDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KTtcbiAgICAgICAgICBzdGF0ZU5vZGUgPSAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKTtcbiAgICAgICAgICBzdGF0ZU5vZGUgfHxcbiAgICAgICAgICAgIChwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChzdGF0ZU5vZGUgPSAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSkpO1xuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGVOb2RlKVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlkU3VzcGVuZEJlZm9yZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgbnVsbCAhPT0gZGlkU3VzcGVuZEJlZm9yZSAmJlxuICAgICAgICAgICAgKChkaWRTdXNwZW5kQmVmb3JlLnJlbmRlcmluZyA9IG51bGwpLFxuICAgICAgICAgICAgKGRpZFN1c3BlbmRCZWZvcmUudGFpbCA9IG51bGwpLFxuICAgICAgICAgICAgKGRpZFN1c3BlbmRCZWZvcmUubGFzdEVmZmVjdCA9IG51bGwpKTtcbiAgICAgICAgICBwdXNoKFxuICAgICAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvcixcbiAgICAgICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoc3RhdGVOb2RlKSBicmVhaztcbiAgICAgICAgICBlbHNlIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwKSxcbiAgICAgICAgICAgIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENhY2hlQ29udGV4dCxcbiAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmVuZGVyTGFuZXMgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5rZXksXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyIHx8IG51bGwsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lc1xuICAgICAgICApO1xuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIGlmIChudWxsID09PSByZXR1cm5GaWJlcikgdGhyb3cgRXJyb3IoXCJDYW5ub3Qgc3dhcCB0aGUgcm9vdCBmaWJlci5cIik7XG4gICAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgICAgcmVuZGVyTGFuZXMuaW5kZXggPSB3b3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICAgICAgcmVuZGVyTGFuZXMuc2libGluZyA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG4gICAgICAgIHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICAgICAgcmVuZGVyTGFuZXMucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgICByZW5kZXJMYW5lcy5fZGVidWdJbmZvID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbztcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzID09PSByZXR1cm5GaWJlci5jaGlsZClcbiAgICAgICAgICByZXR1cm5GaWJlci5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldlNpYmxpbmcgPSByZXR1cm5GaWJlci5jaGlsZDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcHJldlNpYmxpbmcpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGVkIHBhcmVudCB0byBoYXZlIGEgY2hpbGQuXCIpO1xuICAgICAgICAgIGZvciAoOyBwcmV2U2libGluZy5zaWJsaW5nICE9PSB3b3JrSW5Qcm9ncmVzczsgKVxuICAgICAgICAgICAgaWYgKCgocHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5zaWJsaW5nKSwgbnVsbCA9PT0gcHJldlNpYmxpbmcpKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuXCIpO1xuICAgICAgICAgIHByZXZTaWJsaW5nLnNpYmxpbmcgPSByZW5kZXJMYW5lcztcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcbiAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICA/ICgocmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2N1cnJlbnRdKSwgKHJldHVybkZpYmVyLmZsYWdzIHw9IDE2KSlcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzLnB1c2goY3VycmVudCk7XG4gICAgICAgIHJlbmRlckxhbmVzLmZsYWdzIHw9IDI7XG4gICAgICAgIHJldHVybiByZW5kZXJMYW5lcztcbiAgICAgIH1cbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KVxuICAgICAgICBpZiAoXG4gICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzICE9PSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgfHxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGVcbiAgICAgICAgKVxuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAhMDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSAmJlxuICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChkaWRSZWNlaXZlVXBkYXRlID0gITEpLFxuICAgICAgICAgICAgICBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IDAgIT09IChjdXJyZW50LmZsYWdzICYgMTMxMDcyKSA/ICEwIDogITE7XG4gICAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gITE7XG4gICAgICAgIGlmICgocmV0dXJuRmliZXIgPSBpc0h5ZHJhdGluZykpXG4gICAgICAgICAgd2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMDQ4NTc2KSk7XG4gICAgICAgIHJldHVybkZpYmVyICYmXG4gICAgICAgICAgKChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLmluZGV4KSxcbiAgICAgICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKSxcbiAgICAgICAgICBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0cmVlRm9ya0NvdW50LCByZXR1cm5GaWJlcikpO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwO1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBhOiBpZiAoXG4gICAgICAgICAgICAoKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIChjdXJyZW50ID0gY2FsbExhenlJbml0SW5ERVYod29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudCksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjdXJyZW50KVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHNob3VsZENvbnN0cnVjdChjdXJyZW50KVxuICAgICAgICAgICAgICA/ICgocmV0dXJuRmliZXIgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50YWcgPSAxKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQpKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzcy50YWcgPSAwKSxcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudCkpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApKSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gY3VycmVudC4kJHR5cGVvZiksXG4gICAgICAgICAgICAgICAgcHJldlNpYmxpbmcgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IDExO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50ID1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gdXBkYXRlRm9yd2FyZFJlZihcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZTaWJsaW5nID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSAxNDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBcIlwiO1xuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY3VycmVudCAmJlxuICAgICAgICAgICAgICBjdXJyZW50LiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICAgICAgICBcIiBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlP1wiKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3VycmVudCkgfHwgY3VycmVudDtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogXCIgK1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgK1xuICAgICAgICAgICAgICAgIFwiLiBMYXp5IGVsZW1lbnQgdHlwZSBtdXN0IHJlc29sdmUgdG8gYSBjbGFzcyBvciBmdW5jdGlvbi5cIiArXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlNob3VsZCBoYXZlIGEgY3VycmVudCBmaWJlci4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgIHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gcHJldlNpYmxpbmcuZWxlbWVudDtcbiAgICAgICAgICAgIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgbmV4dFByb3BzID0gbmV4dFN0YXRlLmNhY2hlO1xuICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICBuZXh0UHJvcHMgIT09IHByZXZTaWJsaW5nLmNhY2hlICYmXG4gICAgICAgICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIFtDYWNoZUNvbnRleHRdLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgICAgICAgICBuZXh0UHJvcHMgPSBuZXh0U3RhdGUuZWxlbWVudDtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c0h5ZHJhdGlvbiAmJiBwcmV2U2libGluZy5pc0RlaHlkcmF0ZWQpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0ge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgaXNEZWh5ZHJhdGVkOiAhMSxcbiAgICAgICAgICAgICAgICAgIGNhY2hlOiBuZXh0U3RhdGUuY2FjaGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuYmFzZVN0YXRlID0gcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dFByb3BzICE9PSByZXR1cm5GaWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJUaGlzIHJvb3QgcmVjZWl2ZWQgYW4gZWFybHkgdXBkYXRlLCBiZWZvcmUgYW55dGhpbmcgd2FzIGFibGUgaHlkcmF0ZS4gU3dpdGNoZWQgdGhlIGVudGlyZSByb290IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihyZXR1cm5GaWJlcik7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgKChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICAgICAgICAgICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgKGlzSHlkcmF0aW5nID0gITApLFxuICAgICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIChkaWRTdXNwZW5kT3JFcnJvckRFViA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITApKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG1vdW50Q2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgY3VycmVudDtcblxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIChjdXJyZW50LmZsYWdzID0gKGN1cnJlbnQuZmxhZ3MgJiAtMykgfCA0MDk2KSxcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmcpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgICAgICAgaWYgKG5leHRQcm9wcyA9PT0gcmV0dXJuRmliZXIpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcylcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgPyAoY3VycmVudCA9IGdldFJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudClcbiAgICAgICAgICAgICAgICAgIDogaXNIeWRyYXRpbmcgfHxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBnZXRSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucylcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICBzdXBwb3J0c1NpbmdsZXRvbnMgJiZcbiAgICAgICAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgICAgICgocHJldlNpYmxpbmcgPSByZXF1aXJlZENvbnRleHQoXG4gICAgICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViB8fFxuICAgICAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IGRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MoXG4gICAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKHdvcmtJblByb2dyZXNzLCAwKS5zZXJ2ZXJQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIpKSxcbiAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMCksXG4gICAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQocHJldlNpYmxpbmcpKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbiksXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgfHwgaXNIeWRyYXRpbmdcbiAgICAgICAgICAgICAgICA/IHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIGlzSHlkcmF0aW5nICYmXG4gICAgICAgICAgICAgICgobmV4dFByb3BzID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSksXG4gICAgICAgICAgICAgIChuZXh0U3RhdGUgPSAhcHJldlNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICAgKChuZXh0U3RhdGUgPSBjYW5IeWRyYXRlSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFN0YXRlXG4gICAgICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbmV4dFN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgfHxcbiAgICAgICAgICAgICAgICAgICAgICAoKG5leHRQcm9wcyA9IGRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZSh3b3JrSW5Qcm9ncmVzcywgMCkuc2VydmVyUHJvcHMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMpKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQobmV4dFN0YXRlKSksXG4gICAgICAgICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITEpLFxuICAgICAgICAgICAgICAgICAgICAobmV4dFByb3BzID0gITApKVxuICAgICAgICAgICAgICAgICAgOiAobmV4dFByb3BzID0gITEpLFxuICAgICAgICAgICAgICAgIChuZXh0U3RhdGUgPSAhbmV4dFByb3BzKSksXG4gICAgICAgICAgICAgIG5leHRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgICAgICAgd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpKSksXG4gICAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgICAgICAobmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIChuZXh0U3RhdGUgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbnVsbCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSBuZXh0UHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICAgICAgc2hvdWxkU2V0VGV4dENvbnRlbnQocHJldlNpYmxpbmcsIG5leHRQcm9wcylcbiAgICAgICAgICAgICAgPyAocmV0dXJuRmliZXIgPSBudWxsKVxuICAgICAgICAgICAgICA6IG51bGwgIT09IG5leHRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIHNob3VsZFNldFRleHRDb250ZW50KHByZXZTaWJsaW5nLCBuZXh0U3RhdGUpICYmXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDMyKSxcbiAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIFRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICAgICAgICAgID8gKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlID0gcHJldlNpYmxpbmcpXG4gICAgICAgICAgICAgICAgOiAoSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUyID0gcHJldlNpYmxpbmcpKSxcbiAgICAgICAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgICAoKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSB2YWxpZGF0ZUh5ZHJhdGFibGVUZXh0SW5zdGFuY2UoY3VycmVudCwgcmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9ICFyZW5kZXJMYW5lcykgfHxcbiAgICAgICAgICAgICAgICAoKHJldHVybkZpYmVyID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9ICEwKSlcbiAgICAgICAgICAgICAgICAgIDogKHJldHVybkZpYmVyID0gITEpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9ICFyZXR1cm5GaWJlcikpLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgICAgIChjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICB3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCh3b3JrSW5Qcm9ncmVzcykpKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgIDogcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlci5lZmZlY3REdXJhdGlvbiA9IC0wKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlci5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAtMCksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSBwcmV2U2libGluZy52YWx1ZSksXG4gICAgICAgICAgICBcInZhbHVlXCIgaW4gcHJldlNpYmxpbmcgfHxcbiAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgfHxcbiAgICAgICAgICAgICAgKChoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9ICEwKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZSBgdmFsdWVgIHByb3AgaXMgcmVxdWlyZWQgZm9yIHRoZSBgPENvbnRleHQuUHJvdmlkZXI+YC4gRGlkIHlvdSBtaXNzcGVsbCBpdCBvciBmb3JnZXQgdG8gcGFzcyBpdD9cIlxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgcmV0dXJuRmliZXIsIG5leHRQcm9wcyksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHByZXZTaWJsaW5nLmNoaWxkcmVuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLl9jb250ZXh0KSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbiksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkIHRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgdGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlIGlzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuXCJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHJlYWRDb250ZXh0KHByZXZTaWJsaW5nKSksXG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSBjYWxsQ29tcG9uZW50SW5ERVYoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgdm9pZCAwXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMSksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZWFkQ29udGV4dChDYWNoZUNvbnRleHQpKSxcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAoKHByZXZTaWJsaW5nID0gcGVla0NhY2hlRnJvbVBvb2woKSksXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gcHJldlNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICAgICgocHJldlNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QpLFxuICAgICAgICAgICAgICAgICAgKG5leHRQcm9wcyA9IGNyZWF0ZUNhY2hlKCkpLFxuICAgICAgICAgICAgICAgICAgKHByZXZTaWJsaW5nLnBvb2xlZENhY2hlID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICAgIHJldGFpbkNhY2hlKG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKHByZXZTaWJsaW5nLnBvb2xlZENhY2hlTGFuZXMgfD0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gbmV4dFByb3BzKSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnQ6IHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgY2FjaGU6IHByZXZTaWJsaW5nXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgcHJldlNpYmxpbmcpKVxuICAgICAgICAgICAgICA6ICgwICE9PSAoY3VycmVudC5sYW5lcyAmIHJlbmRlckxhbmVzKSAmJlxuICAgICAgICAgICAgICAgICAgKGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBudWxsLCBudWxsLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCkpLFxuICAgICAgICAgICAgICAgIChwcmV2U2libGluZyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nLnBhcmVudCAhPT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgID8gKChwcmV2U2libGluZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBwcmV2U2libGluZyksXG4gICAgICAgICAgICAgICAgICAgIDAgPT09IHdvcmtJblByb2dyZXNzLmxhbmVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuYmFzZVN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgcmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICAgICAgOiAoKHJldHVybkZpYmVyID0gbmV4dFByb3BzLmNhY2hlKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgIT09IHByZXZTaWJsaW5nLmNhY2hlICYmXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDYWNoZUNvbnRleHRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICAgICAgICAgICkpKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICB0aHJvdyB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgK1xuICAgICAgICAgIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCkge1xuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgY29udGV4dCwgbmV4dFZhbHVlKSB7XG4gICAgICBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICA/IChwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0VmFsdWUpLFxuICAgICAgICAgIHB1c2gocmVuZGVyZXJDdXJzb3JERVYsIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgdm9pZCAwICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAmJlxuICAgICAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsKSlcbiAgICAgICAgOiAocHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlMiwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBuZXh0VmFsdWUpLFxuICAgICAgICAgIHB1c2gocmVuZGVyZXIyQ3Vyc29yREVWLCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyLCBwcm92aWRlckZpYmVyKSxcbiAgICAgICAgICB2b2lkIDAgIT09IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgJiZcbiAgICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHJlbmRlcmVyU2lnaWwgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlIHNhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSByZW5kZXJlclNpZ2lsKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFByb3ZpZGVyKGNvbnRleHQsIHByb3ZpZGVyRmliZXIpIHtcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSB2YWx1ZUN1cnNvci5jdXJyZW50O1xuICAgICAgaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgPyAoKGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZSksXG4gICAgICAgICAgKGN1cnJlbnRWYWx1ZSA9IHJlbmRlcmVyQ3Vyc29yREVWLmN1cnJlbnQpLFxuICAgICAgICAgIHBvcChyZW5kZXJlckN1cnNvckRFViwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IGN1cnJlbnRWYWx1ZSkpXG4gICAgICAgIDogKChjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gY3VycmVudFZhbHVlKSxcbiAgICAgICAgICAoY3VycmVudFZhbHVlID0gcmVuZGVyZXIyQ3Vyc29yREVWLmN1cnJlbnQpLFxuICAgICAgICAgIHBvcChyZW5kZXJlcjJDdXJzb3JERVYsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gY3VycmVudFZhbHVlKSk7XG4gICAgICBwb3AodmFsdWVDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgcGFyZW50LFxuICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICBwcm9wYWdhdGlvblJvb3RcbiAgICApIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSBwYXJlbnQ7ICkge1xuICAgICAgICB2YXIgYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgKHBhcmVudC5jaGlsZExhbmVzICYgcmVuZGVyTGFuZXMpICE9PSByZW5kZXJMYW5lc1xuICAgICAgICAgID8gKChwYXJlbnQuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgKGFsdGVybmF0ZS5jaGlsZExhbmVzIHw9IHJlbmRlckxhbmVzKSlcbiAgICAgICAgICA6IG51bGwgIT09IGFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgKGFsdGVybmF0ZS5jaGlsZExhbmVzICYgcmVuZGVyTGFuZXMpICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKGFsdGVybmF0ZS5jaGlsZExhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gcHJvcGFnYXRpb25Sb290KSBicmVhaztcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhcmVudCAhPT0gcHJvcGFnYXRpb25Sb290ICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIHRoZSBwcm9wYWdhdGlvbiByb290IHdoZW4gc2NoZWR1bGluZyBjb250ZXh0IHdvcmsuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGNvbnRleHRzLFxuICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWVcbiAgICApIHtcbiAgICAgIHZhciBmaWJlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgbnVsbCAhPT0gZmliZXIgJiYgKGZpYmVyLnJldHVybiA9IHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGZvciAoOyBudWxsICE9PSBmaWJlcjsgKSB7XG4gICAgICAgIHZhciBsaXN0ID0gZmliZXIuZGVwZW5kZW5jaWVzO1xuICAgICAgICBpZiAobnVsbCAhPT0gbGlzdCkge1xuICAgICAgICAgIHZhciBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgICBsaXN0ID0gbGlzdC5maXJzdENvbnRleHQ7XG4gICAgICAgICAgYTogZm9yICg7IG51bGwgIT09IGxpc3Q7ICkge1xuICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBsaXN0O1xuICAgICAgICAgICAgbGlzdCA9IGZpYmVyO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZXh0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kuY29udGV4dCA9PT0gY29udGV4dHNbaV0pIHtcbiAgICAgICAgICAgICAgICBsaXN0LmxhbmVzIHw9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSBsaXN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgICAgICBudWxsICE9PSBkZXBlbmRlbmN5ICYmIChkZXBlbmRlbmN5LmxhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgICAgICAgICAgICAgbGlzdC5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWUgfHwgKG5leHRGaWJlciA9IG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKDE4ID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgICBuZXh0RmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5leHRGaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIldlIGp1c3QgY2FtZSBmcm9tIGEgcGFyZW50IHNvIHdlIG11c3QgaGF2ZSBoYWQgYSBwYXJlbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbmV4dEZpYmVyLmxhbmVzIHw9IHJlbmRlckxhbmVzO1xuICAgICAgICAgIGxpc3QgPSBuZXh0RmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIG51bGwgIT09IGxpc3QgJiYgKGxpc3QubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoXG4gICAgICAgICAgICBuZXh0RmliZXIsXG4gICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICB9IGVsc2UgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgIGlmIChudWxsICE9PSBuZXh0RmliZXIpIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAobmV4dEZpYmVyID0gZmliZXI7IG51bGwgIT09IG5leHRGaWJlcjsgKSB7XG4gICAgICAgICAgICBpZiAobmV4dEZpYmVyID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpYmVyID0gbmV4dEZpYmVyLnNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gZmliZXIpIHtcbiAgICAgICAgICAgICAgZmliZXIucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICAgICAgbmV4dEZpYmVyID0gZmliZXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dEZpYmVyID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIGZpYmVyID0gbmV4dEZpYmVyO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlXG4gICAgKSB7XG4gICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBwYXJlbnQgPSB3b3JrSW5Qcm9ncmVzcywgaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQgPSAhMTtcbiAgICAgICAgbnVsbCAhPT0gcGFyZW50O1xuXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dClcbiAgICAgICAgICBpZiAoMCAhPT0gKHBhcmVudC5mbGFncyAmIDUyNDI4OCkpIGlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0ID0gITA7XG4gICAgICAgICAgZWxzZSBpZiAoMCAhPT0gKHBhcmVudC5mbGFncyAmIDI2MjE0NCkpIGJyZWFrO1xuICAgICAgICBpZiAoMTAgPT09IHBhcmVudC50YWcpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFBhcmVudCA9IHBhcmVudC5hbHRlcm5hdGU7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRQYXJlbnQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNob3VsZCBoYXZlIGEgY3VycmVudCBmaWJlci4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBwYXJlbnQudHlwZTtcbiAgICAgICAgICAgIG9iamVjdElzKHBhcmVudC5wZW5kaW5nUHJvcHMudmFsdWUsIGN1cnJlbnRQYXJlbnQudmFsdWUpIHx8XG4gICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgPyBjdXJyZW50LnB1c2goY29udGV4dClcbiAgICAgICAgICAgICAgICA6IChjdXJyZW50ID0gW2NvbnRleHRdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCA9PT0gaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvci5jdXJyZW50KSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5hbHRlcm5hdGU7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRQYXJlbnQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNob3VsZCBoYXZlIGEgY3VycmVudCBmaWJlci4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5tZW1vaXplZFN0YXRlLm1lbW9pemVkU3RhdGUgIT09XG4gICAgICAgICAgICBwYXJlbnQubWVtb2l6ZWRTdGF0ZS5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgICAgICA/IGN1cnJlbnQucHVzaChIb3N0VHJhbnNpdGlvbkNvbnRleHQpXG4gICAgICAgICAgICAgIDogKGN1cnJlbnQgPSBbSG9zdFRyYW5zaXRpb25Db250ZXh0XSkpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlXG4gICAgICAgICk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyNjIxNDQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50RGVwZW5kZW5jaWVzKSB7XG4gICAgICBmb3IgKFxuICAgICAgICBjdXJyZW50RGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcy5maXJzdENvbnRleHQ7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnREZXBlbmRlbmNpZXM7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgY29udGV4dCA9IGN1cnJlbnREZXBlbmRlbmNpZXMuY29udGV4dDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFvYmplY3RJcyhcbiAgICAgICAgICAgIGlzUHJpbWFyeVJlbmRlcmVyID8gY29udGV4dC5fY3VycmVudFZhbHVlIDogY29udGV4dC5fY3VycmVudFZhbHVlMixcbiAgICAgICAgICAgIGN1cnJlbnREZXBlbmRlbmNpZXMubWVtb2l6ZWRWYWx1ZVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7XG4gICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcyAmJiAod29ya0luUHJvZ3Jlc3MuZmlyc3RDb250ZXh0ID0gbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkNvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuIEluIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIEluIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCBpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHRGb3JDb25zdW1lcihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciwgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24oY29uc3VtZXIsIGNvbnRleHQpIHtcbiAgICAgIG51bGwgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyICYmIHByZXBhcmVUb1JlYWRDb250ZXh0KGNvbnN1bWVyKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGNvbnN1bWVyLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvbnRleHRGb3JDb25zdW1lcihjb25zdW1lciwgY29udGV4dCkge1xuICAgICAgdmFyIHZhbHVlID0gaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgPyBjb250ZXh0Ll9jdXJyZW50VmFsdWVcbiAgICAgICAgOiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgY29udGV4dCA9IHsgY29udGV4dDogY29udGV4dCwgbWVtb2l6ZWRWYWx1ZTogdmFsdWUsIG5leHQ6IG51bGwgfTtcbiAgICAgIGlmIChudWxsID09PSBsYXN0Q29udGV4dERlcGVuZGVuY3kpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGNvbnN1bWVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiBJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN1bWVyLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICBmaXJzdENvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBjb25zdW1lci5mbGFncyB8PSA1MjQyODg7XG4gICAgICB9IGVsc2UgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0O1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXJMb2NhbCgpLFxuICAgICAgICBkYXRhOiBuZXcgTWFwKCksXG4gICAgICAgIHJlZkNvdW50OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRhaW5DYWNoZShjYWNoZSkge1xuICAgICAgY2FjaGUuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJBIGNhY2hlIGluc3RhbmNlIHdhcyByZXRhaW5lZCBhZnRlciBpdCB3YXMgYWxyZWFkeSBmcmVlZC4gVGhpcyBsaWtlbHkgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICBjYWNoZS5yZWZDb3VudCsrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxlYXNlQ2FjaGUoY2FjaGUpIHtcbiAgICAgIGNhY2hlLnJlZkNvdW50LS07XG4gICAgICAwID4gY2FjaGUucmVmQ291bnQgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiQSBjYWNoZSBpbnN0YW5jZSB3YXMgcmVsZWFzZWQgYWZ0ZXIgaXQgd2FzIGFscmVhZHkgZnJlZWQuIFRoaXMgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgMCA9PT0gY2FjaGUucmVmQ291bnQgJiZcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayQxKE5vcm1hbFByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FjaGUuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVla0NhY2hlRnJvbVBvb2woKSB7XG4gICAgICB2YXIgY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyID0gcmVzdW1lZENhY2hlLmN1cnJlbnQ7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyXG4gICAgICAgID8gY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyXG4gICAgICAgIDogd29ya0luUHJvZ3Jlc3NSb290LnBvb2xlZENhY2hlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJhbnNpdGlvbihvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcywgcHJldkNhY2hlUG9vbCkge1xuICAgICAgbnVsbCA9PT0gcHJldkNhY2hlUG9vbFxuICAgICAgICA/IHB1c2gocmVzdW1lZENhY2hlLCByZXN1bWVkQ2FjaGUuY3VycmVudCwgb2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MpXG4gICAgICAgIDogcHVzaChyZXN1bWVkQ2FjaGUsIHByZXZDYWNoZVBvb2wucG9vbCwgb2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXNwZW5kZWRDYWNoZSgpIHtcbiAgICAgIHZhciBjYWNoZUZyb21Qb29sID0gcGVla0NhY2hlRnJvbVBvb2woKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjYWNoZUZyb21Qb29sXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHBhcmVudDogaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMixcbiAgICAgICAgICAgIHBvb2w6IGNhY2hlRnJvbVBvb2xcbiAgICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkb2VzUmVxdWlyZUNsb25lKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmspIHtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgPT09IGNvbXBsZXRlZFdvcmsuY2hpbGQpIHJldHVybiAhMTtcbiAgICAgIGlmICgwICE9PSAoY29tcGxldGVkV29yay5mbGFncyAmIDE2KSkgcmV0dXJuICEwO1xuICAgICAgZm9yIChjdXJyZW50ID0gY29tcGxldGVkV29yay5jaGlsZDsgbnVsbCAhPT0gY3VycmVudDsgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzODc4KSB8fFxuICAgICAgICAgIDAgIT09IChjdXJyZW50LnN1YnRyZWVGbGFncyAmIDEzODc4KVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlbihcbiAgICAgIHBhcmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLFxuICAgICAgaXNIaWRkZW5cbiAgICApIHtcbiAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIG51bGwgIT09IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZTtcblxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICA1ID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUudGFnIHx8XG4gICAgICAgICAgICA2ID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUudGFnXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICA0ID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUudGFnIHx8XG4gICAgICAgICAgICAgIChzdXBwb3J0c1NpbmdsZXRvbnMgJiYgMjcgPT09IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS50YWcpXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICBudWxsICE9PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuY2hpbGRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5jaGlsZC5yZXR1cm4gPSBuZWVkc1Zpc2liaWxpdHlUb2dnbGU7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuY2hpbGQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuc2libGluZzsgKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG51bGwgPT09IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm4gfHxcbiAgICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnNpYmxpbmcucmV0dXJuID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnJldHVybjtcbiAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuc2libGluZztcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSlcbiAgICAgICAgZm9yICh2YXIgX25vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gX25vZGU7ICkge1xuICAgICAgICAgIGlmICg1ID09PSBfbm9kZS50YWcpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IF9ub2RlLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJlxuICAgICAgICAgICAgICBpc0hpZGRlbiAmJlxuICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBjbG9uZUhpZGRlbkluc3RhbmNlKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIF9ub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgX25vZGUubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKDYgPT09IF9ub2RlLnRhZylcbiAgICAgICAgICAgIChpbnN0YW5jZSA9IF9ub2RlLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJlxuICAgICAgICAgICAgICAgIGlzSGlkZGVuICYmXG4gICAgICAgICAgICAgICAgKGluc3RhbmNlID0gY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIF9ub2RlLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgICAgICAgIGVsc2UgaWYgKDQgIT09IF9ub2RlLnRhZylcbiAgICAgICAgICAgIGlmICgyMiA9PT0gX25vZGUudGFnICYmIG51bGwgIT09IF9ub2RlLm1lbW9pemVkU3RhdGUpXG4gICAgICAgICAgICAgIChpbnN0YW5jZSA9IF9ub2RlLmNoaWxkKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBpbnN0YW5jZSAmJiAoaW5zdGFuY2UucmV0dXJuID0gX25vZGUpLFxuICAgICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKHBhcmVudCwgX25vZGUsICEwLCAhMCk7XG4gICAgICAgICAgICBlbHNlIGlmIChudWxsICE9PSBfbm9kZS5jaGlsZCkge1xuICAgICAgICAgICAgICBfbm9kZS5jaGlsZC5yZXR1cm4gPSBfbm9kZTtcbiAgICAgICAgICAgICAgX25vZGUgPSBfbm9kZS5jaGlsZDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9ub2RlID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWs7XG4gICAgICAgICAgZm9yICg7IG51bGwgPT09IF9ub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IF9ub2RlLnJldHVybiB8fCBfbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBfbm9kZSA9IF9ub2RlLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgX25vZGUuc2libGluZy5yZXR1cm4gPSBfbm9kZS5yZXR1cm47XG4gICAgICAgICAgX25vZGUgPSBfbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIoXG4gICAgICBjb250YWluZXJDaGlsZFNldCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLFxuICAgICAgaXNIaWRkZW5cbiAgICApIHtcbiAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKVxuICAgICAgICBmb3IgKHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IG5vZGU7ICkge1xuICAgICAgICAgIGlmICg1ID09PSBub2RlLnRhZykge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiZcbiAgICAgICAgICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgICAgICAgKGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgbm9kZS5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBpbnN0YW5jZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICg2ID09PSBub2RlLnRhZylcbiAgICAgICAgICAgIChpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmXG4gICAgICAgICAgICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBjbG9uZUhpZGRlblRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgbm9kZS5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgaW5zdGFuY2UpO1xuICAgICAgICAgIGVsc2UgaWYgKDQgIT09IG5vZGUudGFnKVxuICAgICAgICAgICAgaWYgKDIyID09PSBub2RlLnRhZyAmJiBudWxsICE9PSBub2RlLm1lbW9pemVkU3RhdGUpXG4gICAgICAgICAgICAgIChpbnN0YW5jZSA9IG5vZGUuY2hpbGQpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGluc3RhbmNlICYmIChpbnN0YW5jZS5yZXR1cm4gPSBub2RlKSxcbiAgICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKFxuICAgICAgICAgICAgICAgICAgY29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbm9kZS5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIFwibWFudWFsXCIgPT09IG5vZGUubWVtb2l6ZWRQcm9wcy5tb2RlXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gbm9kZS5jaGlsZCkge1xuICAgICAgICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSBub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IG5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykgcmV0dXJuO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSAmJiBkb2VzUmVxdWlyZUNsb25lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gY3VycmVudC5jb250YWluZXJJbmZvLFxuICAgICAgICAgIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoKTtcbiAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MsICExLCAhMSk7XG4gICAgICAgIGN1cnJlbnQucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lciwgbmV3Q2hpbGRTZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcykge1xuICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pXG4gICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBlbHNlIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZSxcbiAgICAgICAgICBfb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoY3VycmVudCA9IGRvZXNSZXF1aXJlQ2xvbmUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpKSB8fFxuICAgICAgICAgIF9vbGRQcm9wcyAhPT0gbmV3UHJvcHNcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgX29sZFByb3BzID0gY2xvbmVJbnN0YW5jZShcbiAgICAgICAgICAgIGN1cnJlbnRJbnN0YW5jZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBfb2xkUHJvcHMsXG4gICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICFjdXJyZW50LFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgICAgX29sZFByb3BzID09PSBjdXJyZW50SW5zdGFuY2VcbiAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZSlcbiAgICAgICAgICAgIDogKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKFxuICAgICAgICAgICAgICAgIF9vbGRQcm9wcyxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRIb3N0Q29udGV4dFxuICAgICAgICAgICAgICApICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX29sZFByb3BzKSxcbiAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgICAgID8gYXBwZW5kQWxsQ2hpbGRyZW4oX29sZFByb3BzLCB3b3JrSW5Qcm9ncmVzcywgITEsICExKVxuICAgICAgICAgICAgICAgIDogbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICB9IGVsc2Ugd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAobWF5U3VzcGVuZENvbW1pdCh0eXBlLCBwcm9wcykpIHtcbiAgICAgICAgaWYgKCgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTY3NzcyMTYpLCAhcHJlbG9hZEluc3RhbmNlKHR5cGUsIHByb3BzKSkpXG4gICAgICAgICAgaWYgKHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSkgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MjtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICgoc3VzcGVuZGVkVGhlbmFibGUgPSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUpLFxuICAgICAgICAgICAgICBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24pXG4gICAgICAgICAgICApO1xuICAgICAgfSBlbHNlIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCByZXNvdXJjZSkge1xuICAgICAgaWYgKG1heVJlc291cmNlU3VzcGVuZENvbW1pdChyZXNvdXJjZSkpIHtcbiAgICAgICAgaWYgKCgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTY3NzcyMTYpLCAhcHJlbG9hZFJlc291cmNlKHJlc291cmNlKSkpXG4gICAgICAgICAgaWYgKHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSkgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MjtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICgoc3VzcGVuZGVkVGhlbmFibGUgPSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUpLFxuICAgICAgICAgICAgICBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24pXG4gICAgICAgICAgICApO1xuICAgICAgfSBlbHNlIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmV0cnlRdWV1ZSkge1xuICAgICAgbnVsbCAhPT0gcmV0cnlRdWV1ZSAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDE2Mzg0ICYmXG4gICAgICAgICgocmV0cnlRdWV1ZSA9XG4gICAgICAgICAgMjIgIT09IHdvcmtJblByb2dyZXNzLnRhZyA/IGNsYWltTmV4dFJldHJ5TGFuZSgpIDogNTM2ODcwOTEyKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzIHw9IHJldHJ5UXVldWUpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzIHw9IHJldHJ5UXVldWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spIHtcbiAgICAgIGlmICghaXNIeWRyYXRpbmcpXG4gICAgICAgIHN3aXRjaCAocmVuZGVyU3RhdGUudGFpbE1vZGUpIHtcbiAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgICBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICAgICAgZm9yICh2YXIgbGFzdFRhaWxOb2RlID0gbnVsbDsgbnVsbCAhPT0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrOyApXG4gICAgICAgICAgICAgIG51bGwgIT09IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAobGFzdFRhaWxOb2RlID0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSxcbiAgICAgICAgICAgICAgICAoaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrID0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrLnNpYmxpbmcpO1xuICAgICAgICAgICAgbnVsbCA9PT0gbGFzdFRhaWxOb2RlXG4gICAgICAgICAgICAgID8gKHJlbmRlclN0YXRlLnRhaWwgPSBudWxsKVxuICAgICAgICAgICAgICA6IChsYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNvbGxhcHNlZFwiOlxuICAgICAgICAgICAgbGFzdFRhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgICAgIGZvciAodmFyIF9sYXN0VGFpbE5vZGUgPSBudWxsOyBudWxsICE9PSBsYXN0VGFpbE5vZGU7IClcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbGFzdFRhaWxOb2RlLmFsdGVybmF0ZSAmJiAoX2xhc3RUYWlsTm9kZSA9IGxhc3RUYWlsTm9kZSksXG4gICAgICAgICAgICAgICAgKGxhc3RUYWlsTm9kZSA9IGxhc3RUYWlsTm9kZS5zaWJsaW5nKTtcbiAgICAgICAgICAgIG51bGwgPT09IF9sYXN0VGFpbE5vZGVcbiAgICAgICAgICAgICAgPyBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgfHwgbnVsbCA9PT0gcmVuZGVyU3RhdGUudGFpbFxuICAgICAgICAgICAgICAgID8gKHJlbmRlclN0YXRlLnRhaWwgPSBudWxsKVxuICAgICAgICAgICAgICAgIDogKHJlbmRlclN0YXRlLnRhaWwuc2libGluZyA9IG51bGwpXG4gICAgICAgICAgICAgIDogKF9sYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1YmJsZVByb3BlcnRpZXMoY29tcGxldGVkV29yaykge1xuICAgICAgdmFyIGRpZEJhaWxvdXQgPVxuICAgICAgICAgIG51bGwgIT09IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgY29tcGxldGVkV29yay5hbHRlcm5hdGUuY2hpbGQgPT09IGNvbXBsZXRlZFdvcmsuY2hpbGQsXG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSAwLFxuICAgICAgICBzdWJ0cmVlRmxhZ3MgPSAwO1xuICAgICAgaWYgKGRpZEJhaWxvdXQpXG4gICAgICAgIGlmICgoY29tcGxldGVkV29yay5tb2RlICYgMikgIT09IE5vTW9kZSkge1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLnNlbGZCYXNlRHVyYXRpb24sXG4gICAgICAgICAgICAgIF9jaGlsZDIgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICAgICAgICAgICAgbnVsbCAhPT0gX2NoaWxkMjtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIChuZXdDaGlsZExhbmVzIHw9IF9jaGlsZDIubGFuZXMgfCBfY2hpbGQyLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF9jaGlsZDIuc3VidHJlZUZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF9jaGlsZDIuZmxhZ3MgJiAzMTQ1NzI4MCksXG4gICAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiArPSBfY2hpbGQyLnRyZWVCYXNlRHVyYXRpb24pLFxuICAgICAgICAgICAgICAoX2NoaWxkMiA9IF9jaGlsZDIuc2libGluZyk7XG4gICAgICAgICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gX3RyZWVCYXNlRHVyYXRpb247XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG4gICAgICAgICAgICBudWxsICE9PSBfdHJlZUJhc2VEdXJhdGlvbjtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIChuZXdDaGlsZExhbmVzIHw9XG4gICAgICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uLmxhbmVzIHwgX3RyZWVCYXNlRHVyYXRpb24uY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX3RyZWVCYXNlRHVyYXRpb24uc3VidHJlZUZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLmZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24ucmV0dXJuID0gY29tcGxldGVkV29yayksXG4gICAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uLnNpYmxpbmcpO1xuICAgICAgZWxzZSBpZiAoKGNvbXBsZXRlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUpIHtcbiAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICBfY2hpbGQyID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgICBmb3IgKHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7IG51bGwgIT09IGNoaWxkOyApXG4gICAgICAgICAgKG5ld0NoaWxkTGFuZXMgfD0gY2hpbGQubGFuZXMgfCBjaGlsZC5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuc3VidHJlZUZsYWdzKSxcbiAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuZmxhZ3MpLFxuICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uKSxcbiAgICAgICAgICAgIChfY2hpbGQyICs9IGNoaWxkLnRyZWVCYXNlRHVyYXRpb24pLFxuICAgICAgICAgICAgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gICAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gX2NoaWxkMjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5jaGlsZDtcbiAgICAgICAgICBudWxsICE9PSBfdHJlZUJhc2VEdXJhdGlvbjtcblxuICAgICAgICApXG4gICAgICAgICAgKG5ld0NoaWxkTGFuZXMgfD1cbiAgICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uLmxhbmVzIHwgX3RyZWVCYXNlRHVyYXRpb24uY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLnN1YnRyZWVGbGFncyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLmZsYWdzKSxcbiAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbi5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrKSxcbiAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uLnNpYmxpbmcpO1xuICAgICAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICAgICAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbiAgICAgIHJldHVybiBkaWRCYWlsb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgbmV3UHJvcHMgPSBudWxsO1xuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgKG5ld1Byb3BzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpO1xuICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJlbmRlckxhbmVzLnBlbmRpbmdDb250ZXh0ICYmXG4gICAgICAgICAgICAoKHJlbmRlckxhbmVzLmNvbnRleHQgPSByZW5kZXJMYW5lcy5wZW5kaW5nQ29udGV4dCksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQgPSBudWxsKSk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgbnVsbCA9PT0gY3VycmVudC5jaGlsZClcbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA/IChlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCksIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKVxuICAgICAgICAgICAgICA6IG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgICAoY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCAmJlxuICAgICAgICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KSkgfHxcbiAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGh5ZHJhdGlvbkVycm9ycyAmJlxuICAgICAgICAgICAgICAgICAgKHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKSxcbiAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25FcnJvcnMgPSBudWxsKSkpO1xuICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgICAgdmFyIG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRSZXNvdXJjZVxuICAgICAgICAgICAgICAgICAgPyAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZChcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgIDogKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICAgIDogbmV4dFJlc291cmNlXG4gICAgICAgICAgICAgICAgPyBuZXh0UmVzb3VyY2UgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICAgICAgPyAobWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA6IChidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNykpXG4gICAgICAgICAgICAgICAgOiAoc3VwcG9ydHNNdXRhdGlvblxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICA6IHVwZGF0ZUhvc3RDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICByZW5kZXJMYW5lcyA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgc3VwcG9ydHNNdXRhdGlvblxuICAgICAgICAgICAgICAgID8gY3VycmVudC5tZW1vaXplZFByb3BzICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgICA6IHVwZGF0ZUhvc3RDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgPyBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdXJyZW50KVxuICAgICAgICAgICAgICAgIDogKChjdXJyZW50ID0gcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsIG5ld1Byb3BzKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgID8gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3VycmVudClcbiAgICAgICAgICAgICAgOiAoKG5leHRSZXNvdXJjZSA9IHJlcXVpcmVkQ29udGV4dChcbiAgICAgICAgICAgICAgICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAobmV4dFJlc291cmNlID0gY3JlYXRlSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4obmV4dFJlc291cmNlLCB3b3JrSW5Qcm9ncmVzcywgITEsICExKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbmV4dFJlc291cmNlKSxcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgICAgICAgKSAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZChcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgICAgICA/IHJlbmRlckxhbmVzICE9PSBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgIDogc3VwcG9ydHNQZXJzaXN0ZW5jZSAmJlxuICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzICE9PSBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICA/ICgoY3VycmVudCA9IHJlcXVpcmVkQ29udGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKVxuICAgICAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZSkpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY3VycmVudCA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICAgICAgICAgIHJlbmRlckxhbmVzID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9ICFkaWRTdXNwZW5kT3JFcnJvckRFVjtcbiAgICAgICAgICAgICAgbmV3UHJvcHMgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHJldHVybkZpYmVyKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICgobmV4dFJlc291cmNlID0gZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKHdvcmtJblByb2dyZXNzLCAwKS5zZXJ2ZXJQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChuZXh0UmVzb3VyY2UgPSBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICApLnNlcnZlclByb3BzID0gbmV4dFJlc291cmNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoeWRyYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgKSB8fCB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5kZWh5ZHJhdGVkKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbmV4dFJlc291cmNlID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IG5ld1Byb3BzICYmIG51bGwgIT09IG5ld1Byb3BzLmRlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHRSZXNvdXJjZSlcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkEgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQgd2FzIGNvbXBsZXRlZCB3aXRob3V0IGEgaHlkcmF0ZWQgbm9kZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgICAgbmV4dFJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRSZXNvdXJjZSA/IG5leHRSZXNvdXJjZS5kZWh5ZHJhdGVkIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHRSZXNvdXJjZSlcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShuZXh0UmVzb3VyY2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgICAgICAoKG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRSZXNvdXJjZSAmJlxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPVxuICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZS50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKSxcbiAgICAgICAgICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSxcbiAgICAgICAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgICAgICAgICgobmV4dFJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLnRyZWVCYXNlRHVyYXRpb24pKTtcbiAgICAgICAgICAgICAgbmV4dFJlc291cmNlID0gITE7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaHlkcmF0aW9uRXJyb3JzICYmXG4gICAgICAgICAgICAgICAgKHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKSxcbiAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCkpLFxuICAgICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UgPSAhMCk7XG4gICAgICAgICAgICBpZiAoIW5leHRSZXNvdXJjZSkge1xuICAgICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksIHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAoMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJlbmRlckxhbmVzID0gbnVsbCAhPT0gbmV3UHJvcHM7XG4gICAgICAgICAgY3VycmVudCA9IG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAoKG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgKG5leHRSZXNvdXJjZSA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAobmV4dFJlc291cmNlID0gbmV3UHJvcHMuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IG5ld1Byb3BzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIgIT09IG5leHRSZXNvdXJjZSAmJiAobmV3UHJvcHMuZmxhZ3MgfD0gMjA0OCkpO1xuICAgICAgICAgIHJlbmRlckxhbmVzICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkLmZsYWdzIHw9IDgxOTIpO1xuICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlKTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgIHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAoKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbikpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIHByZXBhcmVQb3J0YWxNb3VudCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgbmV4dFJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbmV4dFJlc291cmNlKVxuICAgICAgICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICAgIG5ld1Byb3BzID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KTtcbiAgICAgICAgICByZXR1cm5GaWJlciA9IG5leHRSZXNvdXJjZS5yZW5kZXJpbmc7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHJldHVybkZpYmVyKVxuICAgICAgICAgICAgaWYgKG5ld1Byb3BzKSBjdXRPZmZUYWlsSWZOZWVkZWQobmV4dFJlc291cmNlLCAhMSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RJblByb2dyZXNzIHx8XG4gICAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiYgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMjgpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZm9yIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IGN1cnJlbnQ7ICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gcmV0dXJuRmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4O1xuICAgICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQobmV4dFJlc291cmNlLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSByZXR1cm5GaWJlci51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVuZGVyTGFuZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3MocmVuZGVyTGFuZXMsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXMuc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvcixcbiAgICAgICAgICAgICAgICAgICAgICAoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICZcbiAgICAgICAgICAgICAgICAgICAgICAgIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICBGb3JjZVN1c3BlbnNlRmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG51bGwgIT09IG5leHRSZXNvdXJjZS50YWlsICYmXG4gICAgICAgICAgICAgICAgbm93JDEoKSA+IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgJiZcbiAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgKG5ld1Byb3BzID0gITApLFxuICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChuZXh0UmVzb3VyY2UsICExKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA0MTk0MzA0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChjdXJyZW50ID0gZmluZEZpcnN0U3VzcGVuZGVkKHJldHVybkZpYmVyKSksIG51bGwgIT09IGN1cnJlbnQpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKG5leHRSZXNvdXJjZSwgITApLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV4dFJlc291cmNlLnRhaWwgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJoaWRkZW5cIiA9PT0gbmV4dFJlc291cmNlLnRhaWxNb2RlICYmXG4gICAgICAgICAgICAgICAgICAgICFyZXR1cm5GaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzSHlkcmF0aW5nKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgMiAqIG5vdyQxKCkgLSBuZXh0UmVzb3VyY2UucmVuZGVyaW5nU3RhcnRUaW1lID5cbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgIDUzNjg3MDkxMiAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChuZXh0UmVzb3VyY2UsICExKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDQxOTQzMDQpKTtcbiAgICAgICAgICAgIG5leHRSZXNvdXJjZS5pc0JhY2t3YXJkc1xuICAgICAgICAgICAgICA/ICgocmV0dXJuRmliZXIuc2libGluZyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgIDogKChjdXJyZW50ID0gbmV4dFJlc291cmNlLmxhc3QpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgID8gKGN1cnJlbnQuc2libGluZyA9IHJldHVybkZpYmVyKVxuICAgICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKG5leHRSZXNvdXJjZS5sYXN0ID0gcmV0dXJuRmliZXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG51bGwgIT09IG5leHRSZXNvdXJjZS50YWlsKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSBuZXh0UmVzb3VyY2UudGFpbCksXG4gICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UucmVuZGVyaW5nID0gY3VycmVudCksXG4gICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UudGFpbCA9IGN1cnJlbnQuc2libGluZyksXG4gICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UucmVuZGVyaW5nU3RhcnRUaW1lID0gbm93JDEoKSksXG4gICAgICAgICAgICAgIChjdXJyZW50LnNpYmxpbmcgPSBudWxsKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbmV3UHJvcHNcbiAgICAgICAgICAgICAgICA/IChyZW5kZXJMYW5lcyAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSB8XG4gICAgICAgICAgICAgICAgICBGb3JjZVN1c3BlbnNlRmFsbGJhY2tcbiAgICAgICAgICAgICAgICA6IHJlbmRlckxhbmVzICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2spLFxuICAgICAgICAgICAgICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwb3BIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChuZXdQcm9wcyA9IG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgICAgICA/IChudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKVxuICAgICAgICAgICAgICA6IG5ld1Byb3BzICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKSxcbiAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgID8gMCAhPT0gKHJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSAmJlxuICAgICAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzICYgNiAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpKVxuICAgICAgICAgICAgICA6IGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMucmV0cnlRdWV1ZSksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIChuZXdQcm9wcyA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAobmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIG5ld1Byb3BzICE9PSByZW5kZXJMYW5lcyAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIHBvcChyZXN1bWVkQ2FjaGUsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgKHJlbmRlckxhbmVzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGUgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgK1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyArXG4gICAgICAgICAgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bndpbmRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MpLFxuICAgICAgICAgICAgY3VycmVudCAmIDY1NTM2XG4gICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IChjdXJyZW50ICYgLTY1NTM3KSB8IDEyOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgICAgICAwICE9PSAoY3VycmVudCAmIDY1NTM2KSAmJiAwID09PSAoY3VycmVudCAmIDEyOClcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50LmRlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhyZXcgaW4gbmV3bHkgbW91bnRlZCBkZWh5ZHJhdGVkIGNvbXBvbmVudC4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcbiAgICAgICAgICByZXR1cm4gY3VycmVudCAmIDY1NTM2XG4gICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0dXJuIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHBvcEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwb3AocmVzdW1lZENhY2hlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmV0dXJuIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgaW50ZXJydXB0ZWRXb3JrKSB7XG4gICAgICBwb3BUcmVlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBwb3BQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmsudHlwZSwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBwb3BIaWRkZW5Db250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwb3AocmVzdW1lZENhY2hlLCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkUHJvZmlsZShjdXJyZW50KSB7XG4gICAgICByZXR1cm4gKGN1cnJlbnQubW9kZSAmIDIpICE9PSBOb01vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgaG9va0ZsYWdzKSB7XG4gICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBob29rRmxhZ3NcbiAgICApIHtcbiAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgaG9va0ZsYWdzLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICBob29rRmxhZ3MsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChmbGFncywgZmluaXNoZWRXb3JrKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUsXG4gICAgICAgICAgbGFzdEVmZmVjdCA9IG51bGwgIT09IHVwZGF0ZVF1ZXVlID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9PSBsYXN0RWZmZWN0KSB7XG4gICAgICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAodXBkYXRlUXVldWUudGFnICYgZmxhZ3MpID09PSBmbGFncyAmJlxuICAgICAgICAgICAgICAoKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3NcbiAgICAgICAgICAgICAgICA/IG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGxhc3RFZmZlY3QgPSB2b2lkIDApLFxuICAgICAgICAgICAgICAoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICEwKSxcbiAgICAgICAgICAgICAgKGxhc3RFZmZlY3QgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY2FsbENyZWF0ZUluREVWLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVF1ZXVlXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExKSxcbiAgICAgICAgICAgICAgKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3NcbiAgICAgICAgICAgICAgICA/IG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKVxuICAgICAgICAgICAgICAgIDogKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkICYmXG4gICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQoKSxcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBsYXN0RWZmZWN0ICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGxhc3RFZmZlY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIGhvb2tOYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICBob29rTmFtZSA9XG4gICAgICAgICAgICAgICAgMCAhPT0gKHVwZGF0ZVF1ZXVlLnRhZyAmIExheW91dClcbiAgICAgICAgICAgICAgICAgID8gXCJ1c2VMYXlvdXRFZmZlY3RcIlxuICAgICAgICAgICAgICAgICAgOiAwICE9PSAodXBkYXRlUXVldWUudGFnICYgSW5zZXJ0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgOiBcInVzZUVmZmVjdFwiO1xuICAgICAgICAgICAgICB2YXIgYWRkZW5kdW0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID1cbiAgICAgICAgICAgICAgICBudWxsID09PSBsYXN0RWZmZWN0XG4gICAgICAgICAgICAgICAgICA/IFwiIFlvdSByZXR1cm5lZCBudWxsLiBJZiB5b3VyIGVmZmVjdCBkb2VzIG5vdCByZXF1aXJlIGNsZWFuIHVwLCByZXR1cm4gdW5kZWZpbmVkIChvciBub3RoaW5nKS5cIlxuICAgICAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsYXN0RWZmZWN0LnRoZW5cbiAgICAgICAgICAgICAgICAgICAgPyBcIlxcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBob29rTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgXCIoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuIEluc3RlYWQsIHdyaXRlIHRoZSBhc3luYyBmdW5jdGlvbiBpbnNpZGUgeW91ciBlZmZlY3QgYW5kIGNhbGwgaXQgaW1tZWRpYXRlbHk6XFxuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIGhvb2tOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICBcIigoKSA9PiB7XFxuICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XFxuICAgIC8vIFlvdSBjYW4gYXdhaXQgaGVyZVxcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IE15QVBJLmdldERhdGEoc29tZUlkKTtcXG4gICAgLy8gLi4uXFxuICB9XFxuICBmZXRjaERhdGEoKTtcXG59LCBbc29tZUlkXSk7IC8vIE9yIFtdIGlmIGVmZmVjdCBkb2Vzbid0IG5lZWQgcHJvcHMgb3Igc3RhdGVcXG5cXG5MZWFybiBtb3JlIGFib3V0IGRhdGEgZmV0Y2hpbmcgd2l0aCBIb29rczogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ob29rcy1kYXRhLWZldGNoaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIiBZb3UgcmV0dXJuZWQ6IFwiICsgbGFzdEVmZmVjdDtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChuLCBhKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIiVzIG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBiZXNpZGVzIGEgZnVuY3Rpb24sIHdoaWNoIGlzIHVzZWQgZm9yIGNsZWFuLXVwLiVzXCIsXG4gICAgICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgICAgIGFcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBob29rTmFtZSxcbiAgICAgICAgICAgICAgICBhZGRlbmR1bVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5uZXh0O1xuICAgICAgICAgIH0gd2hpbGUgKHVwZGF0ZVF1ZXVlICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICBmbGFncyxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSxcbiAgICAgICAgICBsYXN0RWZmZWN0ID0gbnVsbCAhPT0gdXBkYXRlUXVldWUgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IGxhc3RFZmZlY3QpIHtcbiAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgdXBkYXRlUXVldWUgPSBmaXJzdEVmZmVjdDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoKHVwZGF0ZVF1ZXVlLnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAgICAgICAgdmFyIGluc3QgPSB1cGRhdGVRdWV1ZS5pbnN0LFxuICAgICAgICAgICAgICAgIGRlc3Ryb3kgPSBpbnN0LmRlc3Ryb3k7XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gZGVzdHJveSAmJlxuICAgICAgICAgICAgICAgICgoaW5zdC5kZXN0cm95ID0gdm9pZCAwKSxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFnc1xuICAgICAgICAgICAgICAgICAgPyBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiAoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITApLFxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY2FsbERlc3Ryb3lJbkRFVixcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICBkZXN0cm95XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITEpLFxuICAgICAgICAgICAgICAgIChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzXG4gICAgICAgICAgICAgICAgICA/IG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKClcbiAgICAgICAgICAgICAgICAgIDogKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlLm5leHQ7XG4gICAgICAgICAgfSB3aGlsZSAodXBkYXRlUXVldWUgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgaG9va0ZsYWdzKSB7XG4gICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgaG9va0ZsYWdzXG4gICAgKSB7XG4gICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgaG9va0ZsYWdzLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKG51bGwgIT09IHVwZGF0ZVF1ZXVlKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICAgIFwicmVmXCIgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MsXG4gICAgICAgICAgICB1cGRhdGVRdWV1ZSxcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsR2V0U25hcHNob3RCZWZvcmVVcGRhdGVzKGluc3RhbmNlLCBwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Q2xhc3NTbmFwc2hvdChmaW5pc2hlZFdvcmssIGN1cnJlbnQpIHtcbiAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMsXG4gICAgICAgIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgIFwicmVmXCIgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAoY3VycmVudC5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICApLFxuICAgICAgICBjdXJyZW50LnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc29sdmVkUHJldlByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgIGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSA9PT0gZmluaXNoZWRXb3JrLnR5cGVcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHNuYXBzaG90ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNhbGxHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXMsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICByZXNvbHZlZFByZXZQcm9wcyxcbiAgICAgICAgICBwcmV2U3RhdGVcbiAgICAgICAgKTtcbiAgICAgICAgcHJldlByb3BzID0gZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU7XG4gICAgICAgIHZvaWQgMCAhPT0gc25hcHNob3QgfHxcbiAgICAgICAgICBwcmV2UHJvcHMuaGFzKGZpbmlzaGVkV29yay50eXBlKSB8fFxuICAgICAgICAgIChwcmV2UHJvcHMuYWRkKGZpbmlzaGVkV29yay50eXBlKSxcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaW5pc2hlZFdvcmssIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKTogQSBzbmFwc2hvdCB2YWx1ZSAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICBjdXJyZW50Ll9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlID0gc25hcHNob3Q7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBpbnN0YW5jZVxuICAgICkge1xuICAgICAgaW5zdGFuY2UucHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgY3VycmVudC50eXBlLFxuICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHNcbiAgICAgICk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHNob3VsZFByb2ZpbGUoY3VycmVudClcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudEluREVWLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFVixcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcbiAgICAgIGlmIChudWxsICE9PSByZWYpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGluc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpXG4gICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0YXJ0RWZmZWN0VGltZXIoKSwgKGZpbmlzaGVkV29yay5yZWZDbGVhbnVwID0gcmVmKGluc3RhbmNlKSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgZmluaXNoZWRXb3JrLnJlZkNsZWFudXAgPSByZWYoaW5zdGFuY2UpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJlZlxuICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFwiU3RyaW5nIHJlZnMgYXJlIG5vIGxvbmdlciBzdXBwb3J0ZWQuXCIpXG4gICAgICAgICAgICA6IHJlZi5oYXNPd25Qcm9wZXJ0eShcImN1cnJlbnRcIikgfHxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgcmVmIG9iamVjdCBwcm92aWRlZCBmb3IgJXMuIFVzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKHJlZi5jdXJyZW50ID0gaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlbHlBdHRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgY29tbWl0QXR0YWNoUmVmLCBjdXJyZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgICAgIHZhciByZWYgPSBjdXJyZW50LnJlZixcbiAgICAgICAgcmVmQ2xlYW51cCA9IGN1cnJlbnQucmVmQ2xlYW51cDtcbiAgICAgIGlmIChudWxsICE9PSByZWYpXG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWZDbGVhbnVwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShjdXJyZW50KSlcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGFydEVmZmVjdFRpbWVyKCksIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIHJlZkNsZWFudXApO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIHJlZkNsZWFudXApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIChjdXJyZW50LnJlZkNsZWFudXAgPSBudWxsKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgICAgIG51bGwgIT0gY3VycmVudCAmJiAoY3VycmVudC5yZWZDbGVhbnVwID0gbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRQcm9maWxlKGN1cnJlbnQpKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RWZmZWN0VGltZXIoKSwgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgcmVmLCBudWxsKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCByZWYsIG51bGwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yJDMpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yJDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFByb2ZpbGVyKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY3VycmVudCxcbiAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgIGVmZmVjdER1cmF0aW9uXG4gICAgKSB7XG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgIGlkID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLmlkLFxuICAgICAgICBvbkNvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5vbkNvbW1pdDtcbiAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZSA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5vblJlbmRlcjtcbiAgICAgIGN1cnJlbnQgPSBudWxsID09PSBjdXJyZW50ID8gXCJtb3VudFwiIDogXCJ1cGRhdGVcIjtcbiAgICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCAmJiAoY3VycmVudCA9IFwibmVzdGVkLXVwZGF0ZVwiKTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9maW5pc2hlZFdvcmskbWVtb2l6ZSAmJlxuICAgICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUoXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sXG4gICAgICAgICAgZmluaXNoZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24sXG4gICAgICAgICAgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSxcbiAgICAgICAgICBjb21taXRTdGFydFRpbWVcbiAgICAgICAgKTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9uQ29tbWl0ICYmXG4gICAgICAgIG9uQ29tbWl0KFxuICAgICAgICAgIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgZWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgY29tbWl0U3RhcnRUaW1lXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFByb2ZpbGVyUG9zdENvbW1pdEltcGwoXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBjdXJyZW50LFxuICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uXG4gICAgKSB7XG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgZmluaXNoZWRXb3JrID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5pZDtcbiAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLm9uUG9zdENvbW1pdDtcbiAgICAgIGN1cnJlbnQgPSBudWxsID09PSBjdXJyZW50ID8gXCJtb3VudFwiIDogXCJ1cGRhdGVcIjtcbiAgICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCAmJiAoY3VycmVudCA9IFwibmVzdGVkLXVwZGF0ZVwiKTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgJiZcbiAgICAgICAgX2ZpbmlzaGVkV29yayRtZW1vaXplMihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgY29tbWl0U3RhcnRUaW1lXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvc3RNb3VudChmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjb21taXRNb3VudCxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvc3RVcGRhdGUoZmluaXNoZWRXb3JrLCBuZXdQcm9wcywgb2xkUHJvcHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjb21taXRVcGRhdGUsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICBvbGRQcm9wcyxcbiAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDUgPT09IGZpYmVyLnRhZyB8fFxuICAgICAgICAzID09PSBmaWJlci50YWcgfHxcbiAgICAgICAgKHN1cHBvcnRzUmVzb3VyY2VzID8gMjYgPT09IGZpYmVyLnRhZyA6ICExKSB8fFxuICAgICAgICAoc3VwcG9ydHNTaW5nbGV0b25zID8gMjcgPT09IGZpYmVyLnRhZyA6ICExKSB8fFxuICAgICAgICA0ID09PSBmaWJlci50YWdcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gICAgICBhOiBmb3IgKDs7KSB7XG4gICAgICAgIGZvciAoOyBudWxsID09PSBmaWJlci5zaWJsaW5nOyApIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gZmliZXIucmV0dXJuIHx8IGlzSG9zdFBhcmVudChmaWJlci5yZXR1cm4pKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmaWJlci5zaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBmaWJlciA9IGZpYmVyLnNpYmxpbmc7XG4gICAgICAgICAgNSAhPT0gZmliZXIudGFnICYmXG4gICAgICAgICAgNiAhPT0gZmliZXIudGFnICYmXG4gICAgICAgICAgKHN1cHBvcnRzU2luZ2xldG9ucyA/IDI3ICE9PSBmaWJlci50YWcgOiAxKSAmJlxuICAgICAgICAgIDE4ICE9PSBmaWJlci50YWc7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGZpYmVyLmZsYWdzICYgMikgY29udGludWUgYTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gZmliZXIuY2hpbGQgfHwgNCA9PT0gZmliZXIudGFnKSBjb250aW51ZSBhO1xuICAgICAgICAgIGVsc2UgKGZpYmVyLmNoaWxkLnJldHVybiA9IGZpYmVyKSwgKGZpYmVyID0gZmliZXIuY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGZpYmVyLmZsYWdzICYgMikpIHJldHVybiBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgIGlmICg1ID09PSB0YWcgfHwgNiA9PT0gdGFnKVxuICAgICAgICAobm9kZSA9IG5vZGUuc3RhdGVOb2RlKSxcbiAgICAgICAgICBiZWZvcmVcbiAgICAgICAgICAgID8gaW5zZXJ0SW5Db250YWluZXJCZWZvcmUocGFyZW50LCBub2RlLCBiZWZvcmUpXG4gICAgICAgICAgICA6IGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBub2RlKTtcbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICAhKDQgPT09IHRhZyB8fCAoc3VwcG9ydHNTaW5nbGV0b25zICYmIDI3ID09PSB0YWcpKSAmJlxuICAgICAgICAoKG5vZGUgPSBub2RlLmNoaWxkKSwgbnVsbCAhPT0gbm9kZSlcbiAgICAgIClcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgICAgbnVsbCAhPT0gbm9kZTtcblxuICAgICAgICApXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICAobm9kZSA9IG5vZGUuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgaWYgKDUgPT09IHRhZyB8fCA2ID09PSB0YWcpXG4gICAgICAgIChub2RlID0gbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAgIGJlZm9yZVxuICAgICAgICAgICAgPyBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLCBiZWZvcmUpXG4gICAgICAgICAgICA6IGFwcGVuZENoaWxkKHBhcmVudCwgbm9kZSk7XG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgISg0ID09PSB0YWcgfHwgKHN1cHBvcnRzU2luZ2xldG9ucyAmJiAyNyA9PT0gdGFnKSkgJiZcbiAgICAgICAgKChub2RlID0gbm9kZS5jaGlsZCksIG51bGwgIT09IG5vZGUpXG4gICAgICApXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgICAgbnVsbCAhPT0gbm9kZTtcblxuICAgICAgICApXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIChub2RlID0gbm9kZS5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICAgICAgaWYgKFxuICAgICAgICBzdXBwb3J0c011dGF0aW9uICYmXG4gICAgICAgICghc3VwcG9ydHNTaW5nbGV0b25zIHx8IDI3ICE9PSBmaW5pc2hlZFdvcmsudGFnKVxuICAgICAgKSB7XG4gICAgICAgIGE6IHtcbiAgICAgICAgICBmb3IgKHZhciBwYXJlbnQgPSBmaW5pc2hlZFdvcmsucmV0dXJuOyBudWxsICE9PSBwYXJlbnQ7ICkge1xuICAgICAgICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRGaWJlciA9IHBhcmVudDtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBwYXJlbnRGaWJlciA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShmaW5pc2hlZFdvcmssIHBhcmVudEZpYmVyLCBwYXJlbnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBwYXJlbnRGaWJlci5mbGFncyAmIDMyICYmXG4gICAgICAgICAgICAgIChyZXNldFRleHRDb250ZW50KHBhcmVudCksIChwYXJlbnRGaWJlci5mbGFncyAmPSAtMzMpKTtcbiAgICAgICAgICAgIHBhcmVudEZpYmVyID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShmaW5pc2hlZFdvcmssIHBhcmVudEZpYmVyLCBwYXJlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgcGFyZW50RmliZXIgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgICAgcGFyZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9zdFBvcnRhbENvbnRhaW5lckNoaWxkcmVuKFxuICAgICAgcG9ydGFsLFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgcGVuZGluZ0NoaWxkcmVuXG4gICAgKSB7XG4gICAgICBwb3J0YWwgPSBwb3J0YWwuY29udGFpbmVySW5mbztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4sXG4gICAgICAgICAgcG9ydGFsLFxuICAgICAgICAgIHBlbmRpbmdDaGlsZHJlblxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaXJzdENoaWxkKSB7XG4gICAgICBwcmVwYXJlRm9yQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICBmb3IgKG5leHRFZmZlY3QgPSBmaXJzdENoaWxkOyBudWxsICE9PSBuZXh0RWZmZWN0OyApXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKHJvb3QgPSBuZXh0RWZmZWN0KSxcbiAgICAgICAgICAoZmlyc3RDaGlsZCA9IHJvb3QuY2hpbGQpLFxuICAgICAgICAgIDAgIT09IChyb290LnN1YnRyZWVGbGFncyAmIDEwMjgpICYmIG51bGwgIT09IGZpcnN0Q2hpbGQpXG4gICAgICAgIClcbiAgICAgICAgICAoZmlyc3RDaGlsZC5yZXR1cm4gPSByb290KSwgKG5leHRFZmZlY3QgPSBmaXJzdENoaWxkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAoOyBudWxsICE9PSBuZXh0RWZmZWN0OyApIHtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGQgPSByb290ID0gbmV4dEVmZmVjdDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZmlyc3RDaGlsZC5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgIGZsYWdzID0gZmlyc3RDaGlsZC5mbGFncztcbiAgICAgICAgICAgIHN3aXRjaCAoZmlyc3RDaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgMCAhPT0gKGZsYWdzICYgMTAyNCkgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgIGNvbW1pdENsYXNzU25hcHNob3QoZmlyc3RDaGlsZCwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAwICE9PSAoZmxhZ3MgJiAxMDI0KSAmJlxuICAgICAgICAgICAgICAgICAgc3VwcG9ydHNNdXRhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgY2xlYXJDb250YWluZXIoZmlyc3RDaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKDAgIT09IChmbGFncyAmIDEwMjQpKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXJzdENoaWxkID0gcm9vdC5zaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgZmlyc3RDaGlsZC5yZXR1cm4gPSByb290LnJldHVybjtcbiAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dEVmZmVjdCA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIHJvb3QgPSBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG4gICAgICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSAhMTtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgTGF5b3V0IHwgSGFzRWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0KVxuICAgICAgICAgICAgaWYgKCgoZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSksIG51bGwgPT09IGN1cnJlbnQpKVxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgfHxcbiAgICAgICAgICAgICAgICBcInJlZlwiIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgICAgICAgIChmaW5pc2hlZFJvb3QucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSBjb21wb25lbnREaWRNb3VudC4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlIGNvbXBvbmVudERpZE1vdW50LiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgICAgICAgICAgXCJyZWZcIiBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRSb290LnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgY29tcG9uZW50RGlkVXBkYXRlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgY29tcG9uZW50RGlkVXBkYXRlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBmbGFncyAmIDY0ICYmIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiYgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjdXJyZW50ID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmbGFncyAmIDY0ICYmXG4gICAgICAgICAgICAoKGZsYWdzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSwgbnVsbCAhPT0gZmxhZ3MpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmV2UHJvcHMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGZpbmlzaGVkV29yay5jaGlsZClcbiAgICAgICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICBwcmV2UHJvcHMgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHByZXZQcm9wcyA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRDYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZmluaXNoZWRSb290LmVmZmVjdER1cmF0aW9uICs9IHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhjdXJyZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiYgZmxhZ3MgJiA0ICYmIGNvbW1pdEhvc3RNb3VudChmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmIChmbGFncyAmIDQpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5lZmZlY3REdXJhdGlvbiArPSBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMoZmxhZ3MpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFByb2ZpbGVyLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuZWZmZWN0RHVyYXRpb25cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHByZXZQcm9wcyA9XG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSB8fCBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPVxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbixcbiAgICAgICAgICAgICAgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gcHJldlByb3BzO1xuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBjdXJyZW50KSAmJlxuICAgICAgICAgICAgIXByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuXG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgODc3MilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgIChcIm1hbnVhbFwiID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5tb2RlXG4gICAgICAgICAgICAgID8gc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybilcbiAgICAgICAgICAgICAgOiBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhmaWJlcikge1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJlxuICAgICAgICAoKGZpYmVyLmFsdGVybmF0ZSA9IG51bGwpLCBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhhbHRlcm5hdGUpKTtcbiAgICAgIGZpYmVyLmNoaWxkID0gbnVsbDtcbiAgICAgIGZpYmVyLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgICBmaWJlci5zaWJsaW5nID0gbnVsbDtcbiAgICAgIDUgPT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAoKGFsdGVybmF0ZSA9IGZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiBkZXRhY2hEZWxldGVkSW5zdGFuY2UoYWx0ZXJuYXRlKSk7XG4gICAgICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsO1xuICAgICAgZmliZXIuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgICAgZmliZXIucmV0dXJuID0gbnVsbDtcbiAgICAgIGZpYmVyLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgICAgIGZpYmVyLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gbnVsbDtcbiAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7XG4gICAgICBmaWJlci51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgcGFyZW50XG4gICAgKSB7XG4gICAgICBmb3IgKHBhcmVudCA9IHBhcmVudC5jaGlsZDsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgcGFyZW50XG4gICAgICAgICksXG4gICAgICAgICAgKHBhcmVudCA9IHBhcmVudC5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBkZWxldGVkRmliZXJcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgaW5qZWN0ZWRIb29rICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudFxuICAgICAgKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBkZWxldGVkRmliZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICBzd2l0Y2ggKGRlbGV0ZWRGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gcmVsZWFzZVJlc291cmNlKGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlKVxuICAgICAgICAgICAgICA6IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgICB1bm1vdW50SG9pc3RhYmxlKGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgICB2YXIgcHJldkhvc3RQYXJlbnQgPSBob3N0UGFyZW50LFxuICAgICAgICAgICAgICBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZShkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudDtcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgocHJldkhvc3RQYXJlbnQgPSBob3N0UGFyZW50KSxcbiAgICAgICAgICAgICAgKHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXIpLFxuICAgICAgICAgICAgICAoaG9zdFBhcmVudCA9IG51bGwpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50KSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXIpLFxuICAgICAgICAgICAgICBudWxsICE9PSBob3N0UGFyZW50KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBpZiAoaG9zdFBhcmVudElzQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgc3VwcG9ydHNNdXRhdGlvbiAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gaG9zdFBhcmVudCAmJlxuICAgICAgICAgICAgKGhvc3RQYXJlbnRJc0NvbnRhaW5lclxuICAgICAgICAgICAgICA/IGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIoXG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50LFxuICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjbGVhclN1c3BlbnNlQm91bmRhcnkoaG9zdFBhcmVudCwgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc3VwcG9ydHNNdXRhdGlvblxuICAgICAgICAgICAgPyAoKHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pLFxuICAgICAgICAgICAgICAoaG9zdFBhcmVudElzQ29udGFpbmVyID0gITApLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50KSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXIpKVxuICAgICAgICAgICAgOiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSAmJlxuICAgICAgICAgICAgICAgIGNvbW1pdEhvc3RQb3J0YWxDb250YWluZXJDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICAgIEluc2VydGlvbixcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBMYXlvdXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgKHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpLFxuICAgICAgICAgICAgKHByZXZIb3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcmV2SG9zdFBhcmVudC5jb21wb25lbnRXaWxsVW5tb3VudCAmJlxuICAgICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoXG4gICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgcHJldkhvc3RQYXJlbnRcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID1cbiAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudCA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHx8XG4gICAgICAgICAgICBudWxsICE9PSBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIGlmIChcbiAgICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlKSxcbiAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRSb290ICYmXG4gICAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRSb290ICYmXG4gICAgICAgICAgICAoKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkUm9vdC5kZWh5ZHJhdGVkKSwgbnVsbCAhPT0gZmluaXNoZWRSb290KSkpXG4gICAgICApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJldHJ5Q2FjaGUoZmluaXNoZWRXb3JrKSB7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICB2YXIgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgbnVsbCA9PT0gcmV0cnlDYWNoZSAmJlxuICAgICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gbmV3IFBvc3NpYmx5V2Vha1NldCgpKTtcbiAgICAgICAgICByZXR1cm4gcmV0cnlDYWNoZTtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuX3JldHJ5Q2FjaGUpLFxuICAgICAgICAgICAgbnVsbCA9PT0gcmV0cnlDYWNoZSAmJlxuICAgICAgICAgICAgICAocmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5fcmV0cnlDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKSksXG4gICAgICAgICAgICByZXRyeUNhY2hlXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVW5leHBlY3RlZCBTdXNwZW5zZSBoYW5kbGVyIHRhZyAoXCIgK1xuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudGFnICtcbiAgICAgICAgICAgICAgXCIpLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIHdha2VhYmxlcykge1xuICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBnZXRSZXRyeUNhY2hlKGZpbmlzaGVkV29yayk7XG4gICAgICB3YWtlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAod2FrZWFibGUpIHtcbiAgICAgICAgdmFyIHJldHJ5ID0gcmVzb2x2ZVJldHJ5V2FrZWFibGUuYmluZChudWxsLCBmaW5pc2hlZFdvcmssIHdha2VhYmxlKTtcbiAgICAgICAgaWYgKCFyZXRyeUNhY2hlLmhhcyh3YWtlYWJsZSkpIHtcbiAgICAgICAgICByZXRyeUNhY2hlLmFkZCh3YWtlYWJsZSk7XG4gICAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KVxuICAgICAgICAgICAgaWYgKG51bGwgIT09IGluUHJvZ3Jlc3NMYW5lcyAmJiBudWxsICE9PSBpblByb2dyZXNzUm9vdClcbiAgICAgICAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhpblByb2dyZXNzUm9vdCwgaW5Qcm9ncmVzc0xhbmVzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCBmaW5pc2hlZCByb290IGFuZCBsYW5lcyB0byBiZSBzZXQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcykge1xuICAgICAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gICAgICBpblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gICAgICBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkV29yaywgcm9vdCk7XG4gICAgICBpblByb2dyZXNzUm9vdCA9IGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCRqc2NvbXAkMCwgcGFyZW50RmliZXIpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gICAgICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByb290ID0gcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gcGFyZW50RmliZXIsXG4gICAgICAgICAgICBkZWxldGVkRmliZXIgPSBkZWxldGlvbnNbaV07XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIGE6IGZvciAoOyBudWxsICE9PSBwYXJlbnQ7ICkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITE7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bGwgPT09IGhvc3RQYXJlbnQpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKHJvb3QsIHJldHVybkZpYmVyLCBkZWxldGVkRmliZXIpO1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMTtcbiAgICAgICAgICB9IGVsc2UgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihyb290LCByZXR1cm5GaWJlciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICByb290ID0gZGVsZXRlZEZpYmVyO1xuICAgICAgICAgIHJldHVybkZpYmVyID0gcm9vdC5hbHRlcm5hdGU7XG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXIgJiYgKHJldHVybkZpYmVyLnJldHVybiA9IG51bGwpO1xuICAgICAgICAgIHJvb3QucmV0dXJuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEzODc4KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihwYXJlbnRGaWJlciwgcm9vdCRqc2NvbXAkMCksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIChjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICAgIEluc2VydGlvbiB8IEhhc0VmZmVjdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChJbnNlcnRpb24gfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICBjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgTGF5b3V0IHwgSGFzRWZmZWN0XG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICBmbGFncyAmIDY0ICYmXG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gJiZcbiAgICAgICAgICAgICgoZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yayAmJlxuICAgICAgICAgICAgICAoKGZsYWdzID0gZmluaXNoZWRXb3JrLmNhbGxiYWNrcyksXG4gICAgICAgICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgICAgICAgKChjdXJyZW50ID0gZmluaXNoZWRXb3JrLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MpLFxuICAgICAgICAgICAgICAgIChmaW5pc2hlZFdvcmsuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9XG4gICAgICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50ID8gZmxhZ3MgOiBjdXJyZW50LmNvbmNhdChmbGFncykpKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgICAgdmFyIGhvaXN0YWJsZVJvb3QgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICAgKChmbGFncyA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsKSxcbiAgICAgICAgICAgICAgKHJvb3QgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/IG51bGwgPT09IHJvb3RcbiAgICAgICAgICAgICAgICAgID8gbnVsbCA9PT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgICA/IChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gaHlkcmF0ZUhvaXN0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgOiBtb3VudEhvaXN0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gYWNxdWlyZVJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIDogZmxhZ3MgIT09IHJvb3RcbiAgICAgICAgICAgICAgICAgID8gKG51bGwgPT09IGZsYWdzXG4gICAgICAgICAgICAgICAgICAgICAgPyBudWxsICE9PSBjdXJyZW50LnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5tb3VudEhvaXN0YWJsZShjdXJyZW50LnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHJlbGVhc2VSZXNvdXJjZShmbGFncyksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICA/IG1vdW50SG9pc3RhYmxlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIDogYWNxdWlyZVJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgIDogbnVsbCA9PT0gcm9vdCAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdEhvc3RVcGRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzdXBwb3J0c1NpbmdsZXRvbnMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNsZWFyU2luZ2xldG9uKGhvaXN0YWJsZVJvb3QpLFxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgMzIpIHtcbiAgICAgICAgICAgICAgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmluaXNoZWRXb3JrLCByZXNldFRleHRDb250ZW50LCByb290KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgICBudWxsICE9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgKChyb290ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICAgICBjb21taXRIb3N0VXBkYXRlKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiByb290XG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgZmxhZ3MgJiAxMDI0ICYmXG4gICAgICAgICAgICAgICgobmVlZHNGb3JtUmVzZXQgPSAhMCksXG4gICAgICAgICAgICAgIFwiZm9ybVwiICE9PSBmaW5pc2hlZFdvcmsudHlwZSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgaG9zdCBjb21wb25lbnQgdHlwZS4gRXhwZWN0ZWQgYSBmb3JtLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGlmIChmbGFncyAmIDQgJiYgc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogZmxhZ3M7XG4gICAgICAgICAgICByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRUZXh0VXBkYXRlLFxuICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBmbGFnc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICBzdXBwb3J0c1Jlc291cmNlc1xuICAgICAgICAgICAgPyAocHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcygpLFxuICAgICAgICAgICAgICAocHJvcHMgPSBjdXJyZW50SG9pc3RhYmxlUm9vdCksXG4gICAgICAgICAgICAgIChjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3Qocm9vdC5jb250YWluZXJJbmZvKSksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRIb2lzdGFibGVSb290ID0gcHJvcHMpKVxuICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKGZsYWdzICYgNCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzdXBwb3J0c011dGF0aW9uICYmXG4gICAgICAgICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgICByb290LmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgICAgZmxhZ3MgPSByb290LmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSByb290LnBlbmRpbmdDaGlsZHJlbjtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lZWRzRm9ybVJlc2V0ICYmXG4gICAgICAgICAgICAoKG5lZWRzRm9ybVJlc2V0ID0gITEpLCByZWN1cnNpdmVseVJlc2V0Rm9ybXMoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgcm9vdC5lZmZlY3REdXJhdGlvbiArPSBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMoaG9pc3RhYmxlUm9vdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzdXBwb3J0c1Jlc291cmNlc1xuICAgICAgICAgICAgPyAoKGN1cnJlbnQgPSBjdXJyZW50SG9pc3RhYmxlUm9vdCksXG4gICAgICAgICAgICAgIChjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3QoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICAoY3VycmVudEhvaXN0YWJsZVJvb3QgPSBjdXJyZW50KSlcbiAgICAgICAgICAgIDogKHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgc3VwcG9ydHNQZXJzaXN0ZW5jZSAmJlxuICAgICAgICAgICAgY29tbWl0SG9zdFBvcnRhbENvbnRhaW5lckNoaWxkcmVuKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGVuZGluZ0NoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGZsYWdzID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMoZmxhZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuY2hpbGQuZmxhZ3MgJiA4MTkyICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpICE9PVxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpICYmXG4gICAgICAgICAgICAoZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IG5vdyQxKCkpO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAoKGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgZmxhZ3MpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciB3YXNIaWRkZW4gPSBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4sXG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID1cbiAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gfHwgaG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID1cbiAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8IHdhc0hpZGRlbjtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgcm9vdC5fY3VycmVudCA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgICByb290Ll92aXNpYmlsaXR5ICY9IC0zO1xuICAgICAgICAgIHJvb3QuX3Zpc2liaWxpdHkgfD0gcm9vdC5fcGVuZGluZ1Zpc2liaWxpdHkgJiAyO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZsYWdzICYgODE5MiAmJlxuICAgICAgICAgICAgKChyb290Ll92aXNpYmlsaXR5ID0gaG9pc3RhYmxlUm9vdFxuICAgICAgICAgICAgICA/IHJvb3QuX3Zpc2liaWxpdHkgJiAtMlxuICAgICAgICAgICAgICA6IHJvb3QuX3Zpc2liaWxpdHkgfCAxKSxcbiAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QgJiZcbiAgICAgICAgICAgICAgKChyb290ID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgICAgd2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgICAgcm9vdCB8fFxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaykpLFxuICAgICAgICAgICAgc3VwcG9ydHNNdXRhdGlvbiAmJlxuICAgICAgICAgICAgICAobnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICAgICAgICBcIm1hbnVhbFwiICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5tb2RlKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBhOiBpZiAoKChjdXJyZW50ID0gbnVsbCksIHN1cHBvcnRzTXV0YXRpb24pKVxuICAgICAgICAgICAgICBmb3IgKHJvb3QgPSBmaW5pc2hlZFdvcms7IDsgKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgNSA9PT0gcm9vdC50YWcgfHxcbiAgICAgICAgICAgICAgICAgIChzdXBwb3J0c1Jlc291cmNlcyAmJiAyNiA9PT0gcm9vdC50YWcpIHx8XG4gICAgICAgICAgICAgICAgICAoc3VwcG9ydHNTaW5nbGV0b25zICYmIDI3ID09PSByb290LnRhZylcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbiA9IGN1cnJlbnQgPSByb290O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIChwcm9wcyA9IHdhc0hpZGRlbi5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJ1bldpdGhGaWJlckluREVWKHdhc0hpZGRlbiwgaGlkZUluc3RhbmNlLCBwcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaGlkZUluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDYgPT09IHJvb3QudGFnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4gPSByb290O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdhc0hpZGRlbi5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZVRleHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgKCgyMiAhPT0gcm9vdC50YWcgJiYgMjMgIT09IHJvb3QudGFnKSB8fFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSByb290Lm1lbW9pemVkU3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9PT0gZmluaXNoZWRXb3JrKSAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcm9vdC5jaGlsZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcm9vdC5jaGlsZC5yZXR1cm4gPSByb290O1xuICAgICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QuY2hpbGQ7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QgPT09IGZpbmlzaGVkV29yaykgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gcm9vdC5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSByb290LnJldHVybiB8fCByb290LnJldHVybiA9PT0gZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgY3VycmVudCA9PT0gcm9vdCAmJiAoY3VycmVudCA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID09PSByb290ICYmIChjdXJyZW50ID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgcm9vdC5zaWJsaW5nLnJldHVybiA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgICAgICAgIHJvb3QgPSByb290LnNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChjdXJyZW50ID0gZmxhZ3MucmV0cnlRdWV1ZSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAoKGZsYWdzLnJldHJ5UXVldWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgY3VycmVudCkpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAoKGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgZmxhZ3MpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaW5pc2hlZFdvcmssIGNvbW1pdFBsYWNlbWVudCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gLTM7XG4gICAgICB9XG4gICAgICBmbGFncyAmIDQwOTYgJiYgKGZpbmlzaGVkV29yay5mbGFncyAmPSAtNDA5Nyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhwYXJlbnRGaWJlcikge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjQpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgICAgICAgIHZhciBmaWJlciA9IHBhcmVudEZpYmVyO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhmaWJlcik7XG4gICAgICAgICAgNSA9PT0gZmliZXIudGFnICYmXG4gICAgICAgICAgICBmaWJlci5mbGFncyAmIDEwMjQgJiZcbiAgICAgICAgICAgIHJlc2V0Rm9ybUluc3RhbmNlKGZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCByb290LCBjb21taXR0ZWRMYW5lcykge1xuICAgICAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gICAgICBpblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gICAgICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICBpblByb2dyZXNzUm9vdCA9IGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKHJvb3QsIHBhcmVudEZpYmVyKSB7XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgODc3MilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIocm9vdCwgcGFyZW50RmliZXIuYWx0ZXJuYXRlLCBwYXJlbnRGaWJlciksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgIExheW91dFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgJiZcbiAgICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBudWxsID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKHBhcmVudEZpYmVyKSxcbiAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgY3VycmVudCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICApIHtcbiAgICAgIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgTGF5b3V0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjdXJyZW50LmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkTW91bnRJbkRFVixcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0SGlkZGVuQ2FsbGJhY2tzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdEhvc3RNb3VudChmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGZsYWdzICYgNCkge1xuICAgICAgICAgICAgZmxhZ3MgPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cy5lZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgICBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMoZmxhZ3MpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFByb2ZpbGVyLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzLmVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBudWxsID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgcGFyZW50RmliZXIsXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID1cbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiAwICE9PSAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgODc3Mik7XG4gICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgcGFyZW50RmliZXIuYWx0ZXJuYXRlLFxuICAgICAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgKSxcbiAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciBwcmV2aW91c0NhY2hlID0gbnVsbDtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgKHByZXZpb3VzQ2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpO1xuICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCk7XG4gICAgICBjdXJyZW50ICE9PSBwcmV2aW91c0NhY2hlICYmXG4gICAgICAgIChudWxsICE9IGN1cnJlbnQgJiYgcmV0YWluQ2FjaGUoY3VycmVudCksXG4gICAgICAgIG51bGwgIT0gcHJldmlvdXNDYWNoZSAmJiByZWxlYXNlQ2FjaGUocHJldmlvdXNDYWNoZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgICAoY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgICBmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICAgIGZpbmlzaGVkV29yayAhPT0gY3VycmVudCAmJlxuICAgICAgICAocmV0YWluQ2FjaGUoZmluaXNoZWRXb3JrKSwgbnVsbCAhPSBjdXJyZW50ICYmIHJlbGVhc2VDYWNoZShjdXJyZW50KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICkge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIFBhc3NpdmUgfCBIYXNFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdmFyIHByZXZFZmZlY3REdXJhdGlvbiA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgKChjb21taXR0ZWRMYW5lcyA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAoY29tbWl0dGVkTGFuZXMgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGUpLFxuICAgICAgICAgICAgKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayAhPT0gY29tbWl0dGVkTGFuZXMgJiZcbiAgICAgICAgICAgICAgKHJldGFpbkNhY2hlKGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICAgIG51bGwgIT0gY29tbWl0dGVkTGFuZXMgJiYgcmVsZWFzZUNhY2hlKGNvbW1pdHRlZExhbmVzKSkpO1xuICAgICAgICAgIGZpbmlzaGVkUm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgIHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmIChmbGFncyAmIDIwNDgpIHtcbiAgICAgICAgICAgIHByZXZFZmZlY3REdXJhdGlvbiA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0UHJvZmlsZXJQb3N0Q29tbWl0SW1wbCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LnBhc3NpdmVFZmZlY3REdXJhdGlvblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICA/IHByZXZFZmZlY3REdXJhdGlvbi5fdmlzaWJpbGl0eSAmIDRcbiAgICAgICAgICAgICAgPyByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJiA0XG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6ICgocHJldkVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5IHw9IDQpLFxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICApIHtcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPVxuICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgIDAgIT09IChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1Nik7XG4gICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgIHJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICApIHtcbiAgICAgIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgUGFzc2l2ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICA/IF9pbnN0YW5jZTIuX3Zpc2liaWxpdHkgJiA0XG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiAoKF9pbnN0YW5jZTIuX3Zpc2liaWxpdHkgfD0gNCksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoZmluaXNoZWRXb3JrLmFsdGVybmF0ZSwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgICAgIHBhcmVudEZpYmVyXG4gICAgKSB7XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNTYpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgICAgICAgIHZhciBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsgPSBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChwYXJlbnRGaWJlcikge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgICBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihwYXJlbnRGaWJlciksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIoZmliZXIpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICBmaWJlci5mbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcgJiZcbiAgICAgICAgICAgIChudWxsICE9PSBmaWJlci5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gc3VzcGVuZFJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgICAgICAgZmliZXIubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBzdXNwZW5kSW5zdGFuY2UoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICBmaWJlci5mbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcgJiZcbiAgICAgICAgICAgIHN1c3BlbmRJbnN0YW5jZShmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNIb2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3QoXG4gICAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gcHJldmlvdXNIb2lzdGFibGVSb290O1xuICAgICAgICAgIH0gZWxzZSByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIG51bGwgPT09IGZpYmVyLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICgocHJldmlvdXNIb2lzdGFibGVSb290ID0gZmliZXIuYWx0ZXJuYXRlKSxcbiAgICAgICAgICAgIG51bGwgIT09IHByZXZpb3VzSG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gcHJldmlvdXNIb2lzdGFibGVSb290Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgPyAoKHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IHN1c3BlbnNleUNvbW1pdEZsYWcpLFxuICAgICAgICAgICAgICAgIChzdXNwZW5zZXlDb21taXRGbGFnID0gMTY3NzcyMTYpLFxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlciksXG4gICAgICAgICAgICAgICAgKHN1c3BlbnNleUNvbW1pdEZsYWcgPSBwcmV2aW91c0hvaXN0YWJsZVJvb3QpKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IHBhcmVudEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gcHJldmlvdXNGaWJlciAmJlxuICAgICAgICAoKHBhcmVudEZpYmVyID0gcHJldmlvdXNGaWJlci5jaGlsZCksIG51bGwgIT09IHBhcmVudEZpYmVyKVxuICAgICAgKSB7XG4gICAgICAgIHByZXZpb3VzRmliZXIuY2hpbGQgPSBudWxsO1xuICAgICAgICBkb1xuICAgICAgICAgIChwcmV2aW91c0ZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyksXG4gICAgICAgICAgICAocGFyZW50RmliZXIuc2libGluZyA9IG51bGwpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcHJldmlvdXNGaWJlcik7XG4gICAgICAgIHdoaWxlIChudWxsICE9PSBwYXJlbnRGaWJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gICAgICBpZiAoMCAhPT0gKHBhcmVudEZpYmVyLmZsYWdzICYgMTYpKSB7XG4gICAgICAgIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldO1xuICAgICAgICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICAgICAgICAgICAgICBjaGlsZFRvRGVsZXRlLFxuICAgICAgICAgICAgICBwYXJlbnRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihwYXJlbnRGaWJlciksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yaykge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICBQYXNzaXZlIHwgSGFzRWZmZWN0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdmFyIHByZXZFZmZlY3REdXJhdGlvbiA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgIHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHByZXZFZmZlY3REdXJhdGlvbiA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHByZXZFZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJiA0ICYmXG4gICAgICAgICAgKG51bGwgPT09IGZpbmlzaGVkV29yay5yZXR1cm4gfHwgMTMgIT09IGZpbmlzaGVkV29yay5yZXR1cm4udGFnKVxuICAgICAgICAgICAgPyAoKHByZXZFZmZlY3REdXJhdGlvbi5fdmlzaWJpbGl0eSAmPSAtNSksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKSlcbiAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICAgICAgdmFyIGRlbGV0aW9ucyA9IHBhcmVudEZpYmVyLmRlbGV0aW9ucztcbiAgICAgIGlmICgwICE9PSAocGFyZW50RmliZXIuZmxhZ3MgJiAxNikpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IGRlbGV0aW9ucylcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oXG4gICAgICAgICAgICAgIGNoaWxkVG9EZWxldGUsXG4gICAgICAgICAgICAgIHBhcmVudEZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MocGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChwYXJlbnRGaWJlciksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0KGZpbmlzaGVkV29yaykge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgIFBhc3NpdmVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIGluc3RhbmNlLl92aXNpYmlsaXR5ICYgNCAmJlxuICAgICAgICAgICAgKChpbnN0YW5jZS5fdmlzaWJpbGl0eSAmPSAtNSksXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihcbiAgICAgIGRlbGV0ZWRTdWJ0cmVlUm9vdCxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICApIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSBuZXh0RWZmZWN0OyApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdCxcbiAgICAgICAgICBjdXJyZW50ID0gZmliZXI7XG4gICAgICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgUGFzc2l2ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICAgIG51bGwgIT0gY3VycmVudCAmJiByZXRhaW5DYWNoZShjdXJyZW50KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgcmVsZWFzZUNhY2hlKGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGZpYmVyLmNoaWxkO1xuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkgKGN1cnJlbnQucmV0dXJuID0gZmliZXIpLCAobmV4dEVmZmVjdCA9IGN1cnJlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYTogZm9yIChmaWJlciA9IGRlbGV0ZWRTdWJ0cmVlUm9vdDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dEVmZmVjdDtcbiAgICAgICAgICAgIHZhciBzaWJsaW5nID0gY3VycmVudC5zaWJsaW5nLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGN1cnJlbnQucmV0dXJuO1xuICAgICAgICAgICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gZmliZXIpIHtcbiAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gc2libGluZykge1xuICAgICAgICAgICAgICBzaWJsaW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRFZmZlY3QgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCkge1xuICAgICAgdmFyIG1heWJlRmliZXIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGhvc3RSb290KTtcbiAgICAgIGlmIChudWxsICE9IG1heWJlRmliZXIpIHtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBtYXliZUZpYmVyLm1lbW9pemVkUHJvcHNbXCJkYXRhLXRlc3RuYW1lXCJdKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIGhvc3Qgcm9vdCBzcGVjaWZpZWQuIFNob3VsZCBiZSBlaXRoZXIgYSBSZWFjdCBjb250YWluZXIgb3IgYSBub2RlIHdpdGggYSB0ZXN0bmFtZSBhdHRyaWJ1dGUuXCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gbWF5YmVGaWJlcjtcbiAgICAgIH1cbiAgICAgIGhvc3RSb290ID0gZmluZEZpYmVyUm9vdChob3N0Um9vdCk7XG4gICAgICBpZiAobnVsbCA9PT0gaG9zdFJvb3QpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQ291bGQgbm90IGZpbmQgUmVhY3QgY29udGFpbmVyIHdpdGhpbiBzcGVjaWZpZWQgaG9zdCBzdWJ0cmVlLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gaG9zdFJvb3Quc3RhdGVOb2RlLmN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hdGNoU2VsZWN0b3IoZmliZXIkanNjb21wJDAsIHNlbGVjdG9yKSB7XG4gICAgICB2YXIgdGFnID0gZmliZXIkanNjb21wJDAudGFnO1xuICAgICAgc3dpdGNoIChzZWxlY3Rvci4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIENPTVBPTkVOVF9UWVBFOlxuICAgICAgICAgIGlmIChmaWJlciRqc2NvbXAkMC50eXBlID09PSBzZWxlY3Rvci52YWx1ZSkgcmV0dXJuICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhBU19QU0VVRE9fQ0xBU1NfVFlQRTpcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnZhbHVlO1xuICAgICAgICAgICAgZmliZXIkanNjb21wJDAgPSBbZmliZXIkanNjb21wJDAsIDBdO1xuICAgICAgICAgICAgZm9yICh0YWcgPSAwOyB0YWcgPCBmaWJlciRqc2NvbXAkMC5sZW5ndGg7ICkge1xuICAgICAgICAgICAgICB2YXIgZmliZXIgPSBmaWJlciRqc2NvbXAkMFt0YWcrK10sXG4gICAgICAgICAgICAgICAgdGFnJGpzY29tcCQwID0gZmliZXIudGFnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9ySW5kZXggPSBmaWJlciRqc2NvbXAkMFt0YWcrK10sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IkanNjb21wJDAgPSBzZWxlY3RvcltzZWxlY3RvckluZGV4XTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICg1ICE9PSB0YWckanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgIDI2ICE9PSB0YWckanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgIDI3ICE9PSB0YWckanNjb21wJDApIHx8XG4gICAgICAgICAgICAgICAgIWlzSGlkZGVuU3VidHJlZShmaWJlcilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgIG51bGwgIT0gc2VsZWN0b3IkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yJGpzY29tcCQwKTtcblxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHNlbGVjdG9ySW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgKHNlbGVjdG9yJGpzY29tcCQwID0gc2VsZWN0b3Jbc2VsZWN0b3JJbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvckluZGV4ID09PSBzZWxlY3Rvci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgZm9yIChmaWJlciA9IGZpYmVyLmNoaWxkOyBudWxsICE9PSBmaWJlcjsgKVxuICAgICAgICAgICAgICAgICAgICBmaWJlciRqc2NvbXAkMC5wdXNoKGZpYmVyLCBzZWxlY3RvckluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0b3IgPSAhMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgICBjYXNlIFJPTEVfVFlQRTpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZykgJiZcbiAgICAgICAgICAgIG1hdGNoQWNjZXNzaWJpbGl0eVJvbGUoZmliZXIkanNjb21wJDAuc3RhdGVOb2RlLCBzZWxlY3Rvci52YWx1ZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVEVYVF9UWVBFOlxuICAgICAgICAgIGlmICg1ID09PSB0YWcgfHwgNiA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChmaWJlciRqc2NvbXAkMCA9IGdldFRleHRDb250ZW50KGZpYmVyJGpzY29tcCQwKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGZpYmVyJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgMCA8PSBmaWJlciRqc2NvbXAkMC5pbmRleE9mKHNlbGVjdG9yLnZhbHVlKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRFU1RfTkFNRV9UWVBFOlxuICAgICAgICAgIGlmICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKGZpYmVyJGpzY29tcCQwID0gZmliZXIkanNjb21wJDAubWVtb2l6ZWRQcm9wc1tcImRhdGEtdGVzdG5hbWVcIl0pLFxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZmliZXIkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICBmaWJlciRqc2NvbXAkMC50b0xvd2VyQ2FzZSgpID09PSBzZWxlY3Rvci52YWx1ZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VsZWN0b3JUb1N0cmluZyhzZWxlY3Rvcikge1xuICAgICAgc3dpdGNoIChzZWxlY3Rvci4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIENPTVBPTkVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoc2VsZWN0b3IudmFsdWUpIHx8IFwiVW5rbm93blwiKSArIFwiPlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBIQVNfUFNFVURPX0NMQVNTX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiOmhhcyhcIiArIChzZWxlY3RvclRvU3RyaW5nKHNlbGVjdG9yKSB8fCBcIlwiKSArIFwiKVwiO1xuICAgICAgICBjYXNlIFJPTEVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1tyb2xlPVwiJyArIHNlbGVjdG9yLnZhbHVlICsgJ1wiXSc7XG4gICAgICAgIGNhc2UgVEVYVF9UWVBFOlxuICAgICAgICAgIHJldHVybiAnXCInICsgc2VsZWN0b3IudmFsdWUgKyAnXCInO1xuICAgICAgICBjYXNlIFRFU1RfTkFNRV9UWVBFOlxuICAgICAgICAgIHJldHVybiAnW2RhdGEtdGVzdG5hbWU9XCInICsgc2VsZWN0b3IudmFsdWUgKyAnXCJdJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3IgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICB2YXIgbWF0Y2hpbmdGaWJlcnMgPSBbXTtcbiAgICAgIHJvb3QgPSBbcm9vdCwgMF07XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcm9vdC5sZW5ndGg7ICkge1xuICAgICAgICB2YXIgZmliZXIgPSByb290W2luZGV4KytdLFxuICAgICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgICBzZWxlY3RvckluZGV4ID0gcm9vdFtpbmRleCsrXSxcbiAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICg1ICE9PSB0YWcgJiYgMjYgIT09IHRhZyAmJiAyNyAhPT0gdGFnKSB8fFxuICAgICAgICAgICFpc0hpZGRlblN1YnRyZWUoZmliZXIpXG4gICAgICAgICkge1xuICAgICAgICAgIGZvciAoOyBudWxsICE9IHNlbGVjdG9yICYmIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKTsgKVxuICAgICAgICAgICAgc2VsZWN0b3JJbmRleCsrLCAoc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF0pO1xuICAgICAgICAgIGlmIChzZWxlY3RvckluZGV4ID09PSBzZWxlY3RvcnMubGVuZ3RoKSBtYXRjaGluZ0ZpYmVycy5wdXNoKGZpYmVyKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGZpYmVyOyApXG4gICAgICAgICAgICAgIHJvb3QucHVzaChmaWJlciwgc2VsZWN0b3JJbmRleCksIChmaWJlciA9IGZpYmVyLnNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hpbmdGaWJlcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgaG9zdFJvb3QgPSBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpO1xuICAgICAgaG9zdFJvb3QgPSBmaW5kUGF0aHMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgICBzZWxlY3RvcnMgPSBbXTtcbiAgICAgIGhvc3RSb290ID0gQXJyYXkuZnJvbShob3N0Um9vdCk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaG9zdFJvb3QubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIG5vZGUgPSBob3N0Um9vdFtpbmRleCsrXSxcbiAgICAgICAgICB0YWcgPSBub2RlLnRhZztcbiAgICAgICAgaWYgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcpXG4gICAgICAgICAgaXNIaWRkZW5TdWJ0cmVlKG5vZGUpIHx8IHNlbGVjdG9ycy5wdXNoKG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAobm9kZSA9IG5vZGUuY2hpbGQ7IG51bGwgIT09IG5vZGU7IClcbiAgICAgICAgICAgIGhvc3RSb290LnB1c2gobm9kZSksIChub2RlID0gbm9kZS5zaWJsaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RvcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQ29tbWl0Um9vdCgpIHtcbiAgICAgIHN1cHBvcnRzVGVzdFNlbGVjdG9ycyAmJlxuICAgICAgICBjb21taXRIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21taXRIb29rKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1pdEhvb2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkge1xuICAgICAgdmFyIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCA9XG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlRcbiAgICAgICAgICA/IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVFxuICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsIHx8XG4gICAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUaGUgY3VycmVudCB0ZXN0aW5nIGVudmlyb25tZW50IGlzIG5vdCBjb25maWd1cmVkIHRvIHN1cHBvcnQgYWN0KC4uLilcIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmXG4gICAgICAgIDAgIT09IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICApXG4gICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIC13b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgICAgIHJldHVybiBudWxsICE9PSB0cmFuc2l0aW9uXG4gICAgICAgID8gKHRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgfHwgKHRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCkpLFxuICAgICAgICAgIHRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuYWRkKGZpYmVyKSxcbiAgICAgICAgICAoZmliZXIgPSBjdXJyZW50RW50YW5nbGVkTGFuZSksXG4gICAgICAgICAgMCAhPT0gZmliZXIgPyBmaWJlciA6IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpKVxuICAgICAgICA6IHJlc29sdmVVcGRhdGVQcmlvcml0eSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0RGVmZXJyZWRMYW5lKCkge1xuICAgICAgMCA9PT0gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID1cbiAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpIHx8IGlzSHlkcmF0aW5nXG4gICAgICAgICAgICA/IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKClcbiAgICAgICAgICAgIDogNTM2ODcwOTEyKTtcbiAgICAgIHZhciBzdXNwZW5zZUhhbmRsZXIgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgbnVsbCAhPT0gc3VzcGVuc2VIYW5kbGVyICYmIChzdXNwZW5zZUhhbmRsZXIuZmxhZ3MgfD0gMzIpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFwidXNlSW5zZXJ0aW9uRWZmZWN0IG11c3Qgbm90IHNjaGVkdWxlIHVwZGF0ZXMuXCIpO1xuICAgICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzICYmIChkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gITApO1xuICAgICAgaWYgKFxuICAgICAgICAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSkgfHxcbiAgICAgICAgbnVsbCAhPT0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0XG4gICAgICApXG4gICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIDApLFxuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAhMVxuICAgICAgICAgICk7XG4gICAgICBtYXJrUm9vdFVwZGF0ZWQkMShyb290LCBsYW5lKTtcbiAgICAgIGlmIChcbiAgICAgICAgMCAhPT0gKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAmJlxuICAgICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RcbiAgICAgICkge1xuICAgICAgICBpZiAoaXNSZW5kZXJpbmcpXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICByb290ID1cbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykpIHx8XG4gICAgICAgICAgICAgICAgXCJVbmtub3duXCI7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5oYXMocm9vdCkgfHxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmFkZChyb290KSxcbiAgICAgICAgICAgICAgICAoZmliZXIgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIlVua25vd25cIiksXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHVwZGF0ZSBhIGNvbXBvbmVudCAoYCVzYCkgd2hpbGUgcmVuZGVyaW5nIGEgZGlmZmVyZW50IGNvbXBvbmVudCAoYCVzYCkuIFRvIGxvY2F0ZSB0aGUgYmFkIHNldFN0YXRlKCkgY2FsbCBpbnNpZGUgYCVzYCwgZm9sbG93IHRoZSBzdGFjayB0cmFjZSBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zZXRzdGF0ZS1pbi1yZW5kZXJcIixcbiAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIHJvb3RcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyIHx8XG4gICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgd2l0aGluIGByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9ICEwKSk7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZSksXG4gICAgICAgICAgd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKSxcbiAgICAgICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiZcbiAgICAgICAgICAgICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIHw9IGxhbmUpLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSAmJlxuICAgICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgbGFuZXMsIGZvcmNlU3luYykge1xuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy5cIik7XG4gICAgICB2YXIgc2hvdWxkVGltZVNsaWNlID1cbiAgICAgICAgICAoIWZvcmNlU3luYyAmJlxuICAgICAgICAgICAgMCA9PT0gKGxhbmVzICYgNjApICYmXG4gICAgICAgICAgICAwID09PSAobGFuZXMgJiByb290LmV4cGlyZWRMYW5lcykpIHx8XG4gICAgICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBsYW5lcyksXG4gICAgICAgIGV4aXRTdGF0dXMgPSBzaG91bGRUaW1lU2xpY2VcbiAgICAgICAgICA/IHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKVxuICAgICAgICAgIDogcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMsICEwKSxcbiAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IHNob3VsZFRpbWVTbGljZTtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgJiZcbiAgICAgICAgICAgICFzaG91bGRUaW1lU2xpY2UgJiZcbiAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCAwLCAhMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdERpZE5vdENvbXBsZXRlKVxuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICF3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3JjZVN5bmMgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgJiZcbiAgICAgICAgICAgICFpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZm9yY2VTeW5jKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzLCAhMSk7XG4gICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gITE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gbGFuZXM7XG4gICAgICAgICAgICBpZiAocm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyAmIHJlbmRlcldhc0NvbmN1cnJlbnQpXG4gICAgICAgICAgICAgIHZhciBlcnJvclJldHJ5TGFuZXMgPSAwO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAoZXJyb3JSZXRyeUxhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiAtNTM2ODcwOTEzKSxcbiAgICAgICAgICAgICAgICAoZXJyb3JSZXRyeUxhbmVzID1cbiAgICAgICAgICAgICAgICAgIDAgIT09IGVycm9yUmV0cnlMYW5lc1xuICAgICAgICAgICAgICAgICAgICA/IGVycm9yUmV0cnlMYW5lc1xuICAgICAgICAgICAgICAgICAgICA6IGVycm9yUmV0cnlMYW5lcyAmIDUzNjg3MDkxMlxuICAgICAgICAgICAgICAgICAgICAgID8gNTM2ODcwOTEyXG4gICAgICAgICAgICAgICAgICAgICAgOiAwKTtcbiAgICAgICAgICAgIGlmICgwICE9PSBlcnJvclJldHJ5TGFuZXMpIHtcbiAgICAgICAgICAgICAgbGFuZXMgPSBlcnJvclJldHJ5TGFuZXM7XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBleGl0U3RhdHVzID0gcm9vdDtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM7XG4gICAgICAgICAgICAgICAgdmFyIHdhc1Jvb3REZWh5ZHJhdGVkID1cbiAgICAgICAgICAgICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgICBleGl0U3RhdHVzLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG4gICAgICAgICAgICAgICAgd2FzUm9vdERlaHlkcmF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgIChwcmVwYXJlRnJlc2hTdGFjayhcbiAgICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICApLmZsYWdzIHw9IDI1Nik7XG4gICAgICAgICAgICAgICAgZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwID0gcmVuZGVyUm9vdFN5bmMoXG4gICAgICAgICAgICAgICAgICBleGl0U3RhdHVzLFxuICAgICAgICAgICAgICAgICAgZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvclJldHJ5TGFuZXMkanNjb21wJDAgIT09IFJvb3RFcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciAmJlxuICAgICAgICAgICAgICAgICAgICAhd2FzUm9vdERlaHlkcmF0ZWRcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBleGl0U3RhdHVzLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzIHw9XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgfD1cbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBleGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycztcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZXhpdFN0YXR1cyAmJiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGV4aXRTdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleGl0U3RhdHVzID0gZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSAhMTtcbiAgICAgICAgICAgICAgaWYgKGV4aXRTdGF0dXMgIT09IFJvb3RFcnJvcmVkKSBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICAgICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIDApO1xuICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIDAsICEwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UgPSByb290O1xuICAgICAgICAgICAgc3dpdGNoIChleGl0U3RhdHVzKSB7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdEluUHJvZ3Jlc3M6XG4gICAgICAgICAgICAgIGNhc2UgUm9vdEZhdGFsRXJyb3JlZDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlJvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdFN1c3BlbmRlZFdpdGhEZWxheTpcbiAgICAgICAgICAgICAgICBpZiAoKGxhbmVzICYgNDE5NDE3NikgPT09IGxhbmVzKSB7XG4gICAgICAgICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgICAgICF3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBSb290RXJyb3JlZDpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdFN1c3BlbmRlZDpcbiAgICAgICAgICAgICAgY2FzZSBSb290Q29tcGxldGVkOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biByb290IGV4aXQgc3RhdHVzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZS5maW5pc2hlZFdvcmsgPSBmb3JjZVN5bmM7XG4gICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlKVxuICAgICAgICAgICAgICBjb21taXRSb290KFxuICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgICAgIElNTUVESUFURV9DT01NSVQsXG4gICAgICAgICAgICAgICAgLTAsXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAobGFuZXMgJiA2MjkxNDU2MCkgPT09IGxhbmVzICYmXG4gICAgICAgICAgICAgICAgKChleGl0U3RhdHVzID1cbiAgICAgICAgICAgICAgICAgIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgK1xuICAgICAgICAgICAgICAgICAgRkFMTEJBQ0tfVEhST1RUTEVfTVMgLVxuICAgICAgICAgICAgICAgICAgbm93JDEoKSksXG4gICAgICAgICAgICAgICAgMTAgPCBleGl0U3RhdHVzKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgICAhd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoMCAhPT0gZ2V0TmV4dExhbmVzKHNob3VsZFRpbWVTbGljZSwgMCkpIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLnRpbWVvdXRIYW5kbGUgPSBzY2hlZHVsZVRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICBjb21taXRSb290V2hlblJlYWR5LmJpbmQoXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VTeW5jLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MsXG4gICAgICAgICAgICAgICAgICAgIFRIUk9UVExFRF9DT01NSVQsXG4gICAgICAgICAgICAgICAgICAgIC0wLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1c1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb21taXRSb290V2hlblJlYWR5KFxuICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICBmb3JjZVN5bmMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLFxuICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MsXG4gICAgICAgICAgICAgICAgSU1NRURJQVRFX0NPTU1JVCxcbiAgICAgICAgICAgICAgICAtMCxcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSB3aGlsZSAoMSk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXJyb3JzKSB7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9yc1xuICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9ycylcbiAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycy5wdXNoLmFwcGx5KFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRSb290V2hlblJlYWR5KFxuICAgICAgcm9vdCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICBsYW5lcyxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgIGRpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyxcbiAgICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICApIHtcbiAgICAgIHZhciBzdWJ0cmVlRmxhZ3MgPSBmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzO1xuICAgICAgaWYgKHN1YnRyZWVGbGFncyAmIDgxOTIgfHwgMTY3ODU0MDggPT09IChzdWJ0cmVlRmxhZ3MgJiAxNjc4NTQwOCkpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoc3RhcnRTdXNwZW5kaW5nQ29tbWl0KCksXG4gICAgICAgICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIoZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAoZmluaXNoZWRXb3JrID0gd2FpdEZvckNvbW1pdFRvQmVSZWFkeSgpKSxcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmspXG4gICAgICAgICkge1xuICAgICAgICAgIHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IGZpbmlzaGVkV29yayhcbiAgICAgICAgICAgIGNvbW1pdFJvb3QuYmluZChcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICAgICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICAgICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgIFNVU1BFTkRFRF9DT01NSVQsXG4gICAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgICAgICFkaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY29tbWl0Um9vdChcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSB7XG4gICAgICBmb3IgKHZhciBub2RlID0gZmluaXNoZWRXb3JrOyA7ICkge1xuICAgICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoMCA9PT0gdGFnIHx8IDExID09PSB0YWcgfHwgMTUgPT09IHRhZykgJiZcbiAgICAgICAgICBub2RlLmZsYWdzICYgMTYzODQgJiZcbiAgICAgICAgICAoKHRhZyA9IG5vZGUudXBkYXRlUXVldWUpLFxuICAgICAgICAgIG51bGwgIT09IHRhZyAmJiAoKHRhZyA9IHRhZy5zdG9yZXMpLCBudWxsICE9PSB0YWcpKVxuICAgICAgICApXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGVjayA9IHRhZ1tpXSxcbiAgICAgICAgICAgICAgZ2V0U25hcHNob3QgPSBjaGVjay5nZXRTbmFwc2hvdDtcbiAgICAgICAgICAgIGNoZWNrID0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIW9iamVjdElzKGdldFNuYXBzaG90KCksIGNoZWNrKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgdGFnID0gbm9kZS5jaGlsZDtcbiAgICAgICAgaWYgKG5vZGUuc3VidHJlZUZsYWdzICYgMTYzODQgJiYgbnVsbCAhPT0gdGFnKVxuICAgICAgICAgICh0YWcucmV0dXJuID0gbm9kZSksIChub2RlID0gdGFnKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykgYnJlYWs7XG4gICAgICAgICAgZm9yICg7IG51bGwgPT09IG5vZGUuc2libGluZzsgKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykgcmV0dXJuICEwO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgIHJvb3QsXG4gICAgICBzdXNwZW5kZWRMYW5lcyxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgZGlkQXR0ZW1wdEVudGlyZVRyZWVcbiAgICApIHtcbiAgICAgIHN1c3BlbmRlZExhbmVzICY9IH53b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcztcbiAgICAgIHN1c3BlbmRlZExhbmVzICY9IH53b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcztcbiAgICAgIHJvb3Quc3VzcGVuZGVkTGFuZXMgfD0gc3VzcGVuZGVkTGFuZXM7XG4gICAgICByb290LnBpbmdlZExhbmVzICY9IH5zdXNwZW5kZWRMYW5lcztcbiAgICAgIGRpZEF0dGVtcHRFbnRpcmVUcmVlICYmIChyb290Lndhcm1MYW5lcyB8PSBzdXNwZW5kZWRMYW5lcyk7XG4gICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZSA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuICAgICAgZm9yICh2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lczsgMCA8IGxhbmVzOyApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihsYW5lcyksXG4gICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgIGRpZEF0dGVtcHRFbnRpcmVUcmVlW2luZGV4XSA9IC0xO1xuICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgIH1cbiAgICAgIDAgIT09IHNwYXduZWRMYW5lICYmXG4gICAgICAgIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCBzdXNwZW5kZWRMYW5lcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3luY1dvcmsoKSB7XG4gICAgICByZXR1cm4gKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0XG4gICAgICAgID8gKGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKSwgITEpXG4gICAgICAgIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpIHtcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IE5vdFN1c3BlbmRlZClcbiAgICAgICAgICB2YXIgaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgKGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpLFxuICAgICAgICAgICAgcmVzZXRIb29rc09uVW53aW5kKGludGVycnVwdGVkV29yayksXG4gICAgICAgICAgICAodGhlbmFibGVTdGF0ZSQxID0gbnVsbCksXG4gICAgICAgICAgICAodGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDApLFxuICAgICAgICAgICAgKGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgZm9yICg7IG51bGwgIT09IGludGVycnVwdGVkV29yazsgKVxuICAgICAgICAgIHVud2luZEludGVycnVwdGVkV29yayhpbnRlcnJ1cHRlZFdvcmsuYWx0ZXJuYXRlLCBpbnRlcnJ1cHRlZFdvcmspLFxuICAgICAgICAgICAgKGludGVycnVwdGVkV29yayA9IGludGVycnVwdGVkV29yay5yZXR1cm4pO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKSB7XG4gICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICByb290LmZpbmlzaGVkTGFuZXMgPSAwO1xuICAgICAgdmFyIHRpbWVvdXRIYW5kbGUgPSByb290LnRpbWVvdXRIYW5kbGU7XG4gICAgICB0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQgJiZcbiAgICAgICAgKChyb290LnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQpLCBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpKTtcbiAgICAgIHRpbWVvdXRIYW5kbGUgPSByb290LmNhbmNlbFBlbmRpbmdDb21taXQ7XG4gICAgICBudWxsICE9PSB0aW1lb3V0SGFuZGxlICYmXG4gICAgICAgICgocm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gbnVsbCksIHRpbWVvdXRIYW5kbGUoKSk7XG4gICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHRpbWVvdXRIYW5kbGUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhyb290LmN1cnJlbnQsIG51bGwpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBsYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSAhMTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBsYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSAhMTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290SW5Qcm9ncmVzcztcbiAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9XG4gICAgICAgICAgMDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9XG4gICAgICAgIG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gITE7XG4gICAgICAwICE9PSAobGFuZXMgJiA4KSAmJiAobGFuZXMgfD0gbGFuZXMgJiAzMik7XG4gICAgICB2YXIgYWxsRW50YW5nbGVkTGFuZXMgPSByb290LmVudGFuZ2xlZExhbmVzO1xuICAgICAgaWYgKDAgIT09IGFsbEVudGFuZ2xlZExhbmVzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHJvb3QgPSByb290LmVudGFuZ2xlbWVudHMsIGFsbEVudGFuZ2xlZExhbmVzICY9IGxhbmVzO1xuICAgICAgICAgIDAgPCBhbGxFbnRhbmdsZWRMYW5lcztcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGFsbEVudGFuZ2xlZExhbmVzKSxcbiAgICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICAgIGxhbmVzIHw9IHJvb3RbaW5kZXhdO1xuICAgICAgICAgIGFsbEVudGFuZ2xlZExhbmVzICY9IH5sYW5lO1xuICAgICAgICB9XG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IGxhbmVzO1xuICAgICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpO1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO1xuICAgICAgcmV0dXJuIHRpbWVvdXRIYW5kbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICAgICAgaXNSZW5kZXJpbmcgPSAhMTtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgID8gKCh0aHJvd25WYWx1ZSA9IGdldFN1c3BlbmRlZFRoZW5hYmxlKCkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZE9uSW1tZWRpYXRlKSlcbiAgICAgICAgOiB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uXG4gICAgICAgICAgPyAoKHRocm93blZhbHVlID0gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRPbkluc3RhbmNlKSlcbiAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9XG4gICAgICAgICAgICAgIHRocm93blZhbHVlID09PSBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb25cbiAgICAgICAgICAgICAgICA/IFN1c3BlbmRlZE9uSHlkcmF0aW9uXG4gICAgICAgICAgICAgICAgOiBudWxsICE9PSB0aHJvd25WYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdGhyb3duVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdGhyb3duVmFsdWUudGhlblxuICAgICAgICAgICAgICAgICAgPyBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2VcbiAgICAgICAgICAgICAgICAgIDogU3VzcGVuZGVkT25FcnJvcik7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gdGhyb3duVmFsdWU7XG4gICAgICB2YXIgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIGlmIChudWxsID09PSBlcnJvcmVkV29yaylcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkKSxcbiAgICAgICAgICBsb2dVbmNhdWdodEVycm9yKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpXG4gICAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoZXJyb3JlZFdvcmsubW9kZSAmIDIgJiZcbiAgICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24oZXJyb3JlZFdvcmspLFxuICAgICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCksXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25FcnJvcjpcbiAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkICYmXG4gICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudEVycm9yZWQoXG4gICAgICAgICAgICAgICAgZXJyb3JlZFdvcmssXG4gICAgICAgICAgICAgICAgdGhyb3duVmFsdWUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EYXRhOlxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbW1lZGlhdGU6XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkICYmXG4gICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFN1c3BlbmRlZChcbiAgICAgICAgICAgICAgICBlcnJvcmVkV29yayxcbiAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gaGFuZGxlclxuICAgICAgICA/ICEwXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNDE5NDE3NikgPT09XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgID8gbnVsbCA9PT0gc2hlbGxCb3VuZGFyeVxuICAgICAgICAgICAgPyAhMFxuICAgICAgICAgICAgOiAhMVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNjI5MTQ1NjApID09PVxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIHx8XG4gICAgICAgICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMilcbiAgICAgICAgICAgID8gaGFuZGxlciA9PT0gc2hlbGxCb3VuZGFyeVxuICAgICAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaERpc3BhdGNoZXIoKSB7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgICAgIHJldHVybiBudWxsID09PSBwcmV2RGlzcGF0Y2hlciA/IENvbnRleHRPbmx5RGlzcGF0Y2hlciA6IHByZXZEaXNwYXRjaGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQXN5bmNEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IERlZmF1bHRBc3luY0Rpc3BhdGNoZXI7XG4gICAgICByZXR1cm4gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkV2l0aERlbGF5O1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzIHx8XG4gICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA0MTk0MTc2KSAhPT1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmJlxuICAgICAgICAgIG51bGwgIT09IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpIHx8XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9ICEwKTtcbiAgICAgICgwID09PSAod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzICYgMTM0MjE3NzI3KSAmJlxuICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgJiAxMzQyMTc3MjcpKSB8fFxuICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgfHxcbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzLCBzaG91bGRZaWVsZEZvclByZXJlbmRlcmluZykge1xuICAgICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCksXG4gICAgICAgIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBwdXNoQXN5bmNEaXNwYXRjaGVyKCk7XG4gICAgICBpZiAoXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXNcbiAgICAgICkge1xuICAgICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcbiAgICAgICAgICAwIDwgbWVtb2l6ZWRVcGRhdGVycy5zaXplICYmXG4gICAgICAgICAgICAocmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCkpO1xuICAgICAgICAgIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcyk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGw7XG4gICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgICAgIGxhbmVzID0gITE7XG4gICAgICBtZW1vaXplZFVwZGF0ZXJzID0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgICAgIGE6IGRvXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IE5vdFN1c3BlbmRlZCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB1bml0T2ZXb3JrID0gd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHRocm93blZhbHVlID0gd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pIHtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkh5ZHJhdGlvbjpcbiAgICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gUm9vdERpZE5vdENvbXBsZXRlO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbW1lZGlhdGU6XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EYXRhOlxuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZTpcbiAgICAgICAgICAgICAgICBudWxsID09PSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50ICYmIChsYW5lcyA9ICEwKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVhc29uID0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb247XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCB1bml0T2ZXb3JrLCB0aHJvd25WYWx1ZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBzaG91bGRZaWVsZEZvclByZXJlbmRlcmluZyAmJlxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmdcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMgPSBSb290SW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIChyZWFzb24gPSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtMb29wU3luYygpO1xuICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSQ0KSB7XG4gICAgICAgICAgaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUkNCk7XG4gICAgICAgIH1cbiAgICAgIHdoaWxlICgxKTtcbiAgICAgIGxhbmVzICYmIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlcisrO1xuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzcyAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGwpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwKSxcbiAgICAgICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpKTtcbiAgICAgIHJldHVybiBtZW1vaXplZFVwZGF0ZXJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3b3JrTG9vcFN5bmMoKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3M7ICkgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcykge1xuICAgICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCksXG4gICAgICAgIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBwdXNoQXN5bmNEaXNwYXRjaGVyKCk7XG4gICAgICBpZiAoXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXNcbiAgICAgICkge1xuICAgICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcbiAgICAgICAgICAwIDwgbWVtb2l6ZWRVcGRhdGVycy5zaXplICYmXG4gICAgICAgICAgICAocmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCkpO1xuICAgICAgICAgIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcyk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGw7XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVM7XG4gICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9IGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcoXG4gICAgICAgICAgcm9vdCxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApO1xuICAgICAgbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICAgICAgYTogZG9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiAhPT0gTm90U3VzcGVuZGVkICYmXG4gICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgIClcbiAgICAgICAgICAgIGI6IHN3aXRjaCAoXG4gICAgICAgICAgICAgICgobGFuZXMgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIChtZW1vaXplZFVwZGF0ZXJzID0gd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25FcnJvcjpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyxcbiAgICAgICAgICAgICAgICAgIFN1c3BlbmRlZE9uRXJyb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgICAgICAgICAgICBpZiAoaXNUaGVuYWJsZVJlc29sdmVkKG1lbW9pemVkVXBkYXRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayhsYW5lcyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFuZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhICYmXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9PT0gcm9vdCAmJlxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPVxuICAgICAgICAgICAgICAgICAgICAgIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZSk7XG4gICAgICAgICAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLnRoZW4obGFuZXMsIGxhbmVzKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbnN0YW5jZTpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9XG4gICAgICAgICAgICAgICAgICBTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlOlxuICAgICAgICAgICAgICAgIGlzVGhlbmFibGVSZXNvbHZlZChtZW1vaXplZFVwZGF0ZXJzKVxuICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayhsYW5lcykpXG4gICAgICAgICAgICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQpLFxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyxcbiAgICAgICAgICAgICAgICAgICAgICBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWVcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdEZpYmVyID0gd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGhvc3RGaWJlci50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BzID0gaG9zdEZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcHJlbG9hZEluc3RhbmNlKHR5cGUsIHByb3BzKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc2libGluZyA9IGhvc3RGaWJlci5zaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBzaWJsaW5nKSB3b3JrSW5Qcm9ncmVzcyA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBob3N0RmliZXIucmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlVW5pdE9mV29yayhyZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCB0eXBlIG9mIGZpYmVyIHRyaWdnZXJlZCBhIHN1c3BlbnNleSBjb21taXQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICBTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSHlkcmF0aW9uOlxuICAgICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RGlkTm90Q29tcGxldGU7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBTdXNwZW5kZWRSZWFzb24uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlXG4gICAgICAgICAgICA/IHdvcmtMb29wU3luYygpXG4gICAgICAgICAgICA6IHdvcmtMb29wQ29uY3VycmVudCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSQ1KSB7XG4gICAgICAgICAgaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUkNSk7XG4gICAgICAgIH1cbiAgICAgIHdoaWxlICgxKTtcbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBpZiAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCgpLFxuICAgICAgICAgIFJvb3RJblByb2dyZXNzXG4gICAgICAgICk7XG4gICAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMDtcbiAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3b3JrTG9vcENvbmN1cnJlbnQoKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MgJiYgIXNob3VsZFlpZWxkKCk7IClcbiAgICAgICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHVuaXRPZldvcmsuYWx0ZXJuYXRlO1xuICAgICAgKHVuaXRPZldvcmsubW9kZSAmIDIpICE9PSBOb01vZGVcbiAgICAgICAgPyAoc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspLFxuICAgICAgICAgIChjdXJyZW50ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgYmVnaW5Xb3JrLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24odW5pdE9mV29yaykpXG4gICAgICAgIDogKGN1cnJlbnQgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBiZWdpbldvcmssXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzXG4gICAgICAgICAgKSk7XG4gICAgICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgPyBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaylcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgbmV4dCA9IHJ1bldpdGhGaWJlckluREVWKHVuaXRPZldvcmssIHJlcGxheUJlZ2luV29yaywgdW5pdE9mV29yayk7XG4gICAgICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgICAgIG51bGwgPT09IG5leHQgPyBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykgOiAod29ya0luUHJvZ3Jlc3MgPSBuZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5QmVnaW5Xb3JrKHVuaXRPZldvcmspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGUsXG4gICAgICAgIGlzUHJvZmlsaW5nTW9kZSA9ICh1bml0T2ZXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlO1xuICAgICAgaXNQcm9maWxpbmdNb2RlICYmIHN0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKTtcbiAgICAgIHN3aXRjaCAodW5pdE9mV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGN1cnJlbnQgPSByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgdW5pdE9mV29yay5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnR5cGUsXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY3VycmVudCA9IHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHVuaXRPZldvcmsudHlwZS5yZW5kZXIsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnJlZixcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlc2V0SG9va3NPblVud2luZCh1bml0T2ZXb3JrKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgdW5pdE9mV29yayksXG4gICAgICAgICAgICAodW5pdE9mV29yayA9IHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzcyh1bml0T2ZXb3JrLCBlbnRhbmdsZWRSZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgKGN1cnJlbnQgPSBiZWdpbldvcmsoY3VycmVudCwgdW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpKTtcbiAgICAgIH1cbiAgICAgIGlzUHJvZmlsaW5nTW9kZSAmJlxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uKHVuaXRPZldvcmspO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gICAgICByb290LFxuICAgICAgdW5pdE9mV29yayxcbiAgICAgIHRocm93blZhbHVlLFxuICAgICAgc3VzcGVuZGVkUmVhc29uXG4gICAgKSB7XG4gICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgICAgIHJlc2V0SG9va3NPblVud2luZCh1bml0T2ZXb3JrKTtcbiAgICAgIHRoZW5hYmxlU3RhdGUkMSA9IG51bGw7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcbiAgICAgIHZhciByZXR1cm5GaWJlciA9IHVuaXRPZldvcmsucmV0dXJuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRocm93RXhjZXB0aW9uKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIHRocm93blZhbHVlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkO1xuICAgICAgICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICAgICAgICApO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChudWxsICE9PSByZXR1cm5GaWJlcikgdGhyb3cgKCh3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyKSwgZXJyb3IpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICAgICAgbG9nVW5jYXVnaHRFcnJvcihcbiAgICAgICAgICByb290LFxuICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpXG4gICAgICAgICk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHVuaXRPZldvcmsuZmxhZ3MgJiAzMjc2OCkge1xuICAgICAgICBpZiAoaXNIeWRyYXRpbmcgfHwgc3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkVycm9yKSByb290ID0gITA7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nIHx8XG4gICAgICAgICAgMCAhPT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNTM2ODcwOTEyKVxuICAgICAgICApXG4gICAgICAgICAgcm9vdCA9ICExO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyA9IHJvb3QgPSAhMCksXG4gICAgICAgICAgc3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEgfHxcbiAgICAgICAgICAgIHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25JbW1lZGlhdGUgfHxcbiAgICAgICAgICAgIHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlKVxuICAgICAgICApXG4gICAgICAgICAgKHN1c3BlbmRlZFJlYXNvbiA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICAgICAgbnVsbCAhPT0gc3VzcGVuZGVkUmVhc29uICYmXG4gICAgICAgICAgICAgIDEzID09PSBzdXNwZW5kZWRSZWFzb24udGFnICYmXG4gICAgICAgICAgICAgIChzdXNwZW5kZWRSZWFzb24uZmxhZ3MgfD0gMTYzODQpO1xuICAgICAgICB1bndpbmRVbml0T2ZXb3JrKHVuaXRPZldvcmssIHJvb3QpO1xuICAgICAgfSBlbHNlIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgICAgIHZhciBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKDAgIT09IChjb21wbGV0ZWRXb3JrLmZsYWdzICYgMzI3NjgpKSB7XG4gICAgICAgICAgdW53aW5kVW5pdE9mV29yayhcbiAgICAgICAgICAgIGNvbXBsZXRlZFdvcmssXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudCA9IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICB1bml0T2ZXb3JrID0gY29tcGxldGVkV29yay5yZXR1cm47XG4gICAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcihjb21wbGV0ZWRXb3JrKTtcbiAgICAgICAgY3VycmVudCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgIGNvbXBsZXRlZFdvcmssXG4gICAgICAgICAgY29tcGxldGVXb3JrLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgY29tcGxldGVkV29yayxcbiAgICAgICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lc1xuICAgICAgICApO1xuICAgICAgICAoY29tcGxldGVkV29yay5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uKGNvbXBsZXRlZFdvcmspO1xuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gY3VycmVudDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29tcGxldGVkV29yayA9IGNvbXBsZXRlZFdvcmsuc2libGluZztcbiAgICAgICAgaWYgKG51bGwgIT09IGNvbXBsZXRlZFdvcmspIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gY29tcGxldGVkV29yayA9IHVuaXRPZldvcms7XG4gICAgICB9IHdoaWxlIChudWxsICE9PSBjb21wbGV0ZWRXb3JrKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdENvbXBsZXRlZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud2luZFVuaXRPZldvcmsodW5pdE9mV29yaywgc2tpcFNpYmxpbmdzKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBuZXh0ID0gdW53aW5kV29yayh1bml0T2ZXb3JrLmFsdGVybmF0ZSwgdW5pdE9mV29yayk7XG4gICAgICAgIGlmIChudWxsICE9PSBuZXh0KSB7XG4gICAgICAgICAgbmV4dC5mbGFncyAmPSAzMjc2NztcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodW5pdE9mV29yay5tb2RlICYgMikgIT09IE5vTW9kZSkge1xuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uKHVuaXRPZldvcmspO1xuICAgICAgICAgIG5leHQgPSB1bml0T2ZXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgIGZvciAodmFyIGNoaWxkID0gdW5pdE9mV29yay5jaGlsZDsgbnVsbCAhPT0gY2hpbGQ7IClcbiAgICAgICAgICAgIChuZXh0ICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uKSwgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdW5pdE9mV29yay5hY3R1YWxEdXJhdGlvbiA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCA9IHVuaXRPZldvcmsucmV0dXJuO1xuICAgICAgICBudWxsICE9PSBuZXh0ICYmXG4gICAgICAgICAgKChuZXh0LmZsYWdzIHw9IDMyNzY4KSxcbiAgICAgICAgICAobmV4dC5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAobmV4dC5kZWxldGlvbnMgPSBudWxsKSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhc2tpcFNpYmxpbmdzICYmXG4gICAgICAgICAgKCh1bml0T2ZXb3JrID0gdW5pdE9mV29yay5zaWJsaW5nKSwgbnVsbCAhPT0gdW5pdE9mV29yaylcbiAgICAgICAgKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1bml0T2ZXb3JrO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVuaXRPZldvcmsgPSBuZXh0O1xuICAgICAgfSB3aGlsZSAobnVsbCAhPT0gdW5pdE9mV29yayk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdERpZE5vdENvbXBsZXRlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRSb290KFxuICAgICAgcm9vdCxcbiAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KDIpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksXG4gICAgICAgICAgY29tbWl0Um9vdEltcGwoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgICAgICAgIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5LFxuICAgICAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKSxcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRSb290SW1wbChcbiAgICAgIHJvb3QsXG4gICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbCxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICkge1xuICAgICAgZG8gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgd2hpbGUgKG51bGwgIT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKTtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcoKTtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk7XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KVxuICAgICAgICB0aHJvdyBFcnJvcihcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiKTtcbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHJvb3QuZmluaXNoZWRMYW5lcztcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdGFydGVkKGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSk7XG4gICAgICBpZiAobnVsbCA9PT0gZmluaXNoZWRXb3JrKSByZXR1cm4gbWFya0NvbW1pdFN0b3BwZWQoKSwgbnVsbDtcbiAgICAgIDAgPT09IGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwicm9vdC5maW5pc2hlZExhbmVzIHNob3VsZCBub3QgYmUgZW1wdHkgZHVyaW5nIGEgY29tbWl0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICByb290LmZpbmlzaGVkTGFuZXMgPSAwO1xuICAgICAgaWYgKGZpbmlzaGVkV29yayA9PT0gcm9vdC5jdXJyZW50KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCBjb21taXQgdGhlIHNhbWUgdHJlZSBhcyBiZWZvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDA7XG4gICAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsO1xuICAgICAgdmFyIHJlbWFpbmluZ0xhbmVzID0gZmluaXNoZWRXb3JrLmxhbmVzIHwgZmluaXNoZWRXb3JrLmNoaWxkTGFuZXM7XG4gICAgICByZW1haW5pbmdMYW5lcyB8PSBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXM7XG4gICAgICBtYXJrUm9vdEZpbmlzaGVkKFxuICAgICAgICByb290LFxuICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICAgIHJlbWFpbmluZ0xhbmVzLFxuICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4gICAgICApO1xuICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmXG4gICAgICAgICgod29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCkpO1xuICAgICAgKDAgPT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTAyNTYpICYmXG4gICAgICAgIDAgPT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxMDI1NikpIHx8XG4gICAgICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzIHx8XG4gICAgICAgICgocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSAhMCksXG4gICAgICAgIChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzKSxcbiAgICAgICAgKHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucyksXG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2soTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoITApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KSk7XG4gICAgICBjb21taXRTdGFydFRpbWUgPSBub3coKTtcbiAgICAgIHRyYW5zaXRpb25zID0gMCAhPT0gKGZpbmlzaGVkV29yay5mbGFncyAmIDE1OTkwKTtcbiAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTU5OTApIHx8IHRyYW5zaXRpb25zXG4gICAgICAgID8gKCh0cmFuc2l0aW9ucyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksXG4gICAgICAgICAgKHNwYXduZWRMYW5lID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCkpLFxuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgyKSxcbiAgICAgICAgICAodXBkYXRlZExhbmVzID0gZXhlY3V0aW9uQ29udGV4dCksXG4gICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dCksXG4gICAgICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZVxuICAgICAgICAgICksXG4gICAgICAgICAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pLFxuICAgICAgICAgIChyb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdGFydGVkICYmXG4gICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChcbiAgICAgICAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGNvbW1pdExheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCByb290LCBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUpLFxuICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkICYmXG4gICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpLFxuICAgICAgICAgIHJlcXVlc3RQYWludCgpLFxuICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ID0gdXBkYXRlZExhbmVzKSxcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoc3Bhd25lZExhbmUpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gdHJhbnNpdGlvbnMpKVxuICAgICAgICA6IChyb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcmspO1xuICAgICAgKHRyYW5zaXRpb25zID0gcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpXG4gICAgICAgID8gKChyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9ICExKSxcbiAgICAgICAgICAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSByb290KSxcbiAgICAgICAgICAocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUpKVxuICAgICAgICA6IChyZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKSxcbiAgICAgICAgICAobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsKSk7XG4gICAgICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgMCA9PT0gcmVtYWluaW5nTGFuZXMgJiYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbCk7XG4gICAgICB0cmFuc2l0aW9ucyB8fCBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCk7XG4gICAgICBvbkNvbW1pdFJvb3QkMShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLCByZW5kZXJQcmlvcml0eUxldmVsKTtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuICAgICAgb25Db21taXRSb290KCk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgICBpZiAobnVsbCAhPT0gcmVjb3ZlcmFibGVFcnJvcnMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbCA9IHJvb3Qub25SZWNvdmVyYWJsZUVycm9yLCBmaW5pc2hlZFdvcmsgPSAwO1xuICAgICAgICAgIGZpbmlzaGVkV29yayA8IHJlY292ZXJhYmxlRXJyb3JzLmxlbmd0aDtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsrK1xuICAgICAgICApXG4gICAgICAgICAgKHJlbWFpbmluZ0xhbmVzID0gcmVjb3ZlcmFibGVFcnJvcnNbZmluaXNoZWRXb3JrXSksXG4gICAgICAgICAgICAodHJhbnNpdGlvbnMgPSBtYWtlRXJyb3JJbmZvKHJlbWFpbmluZ0xhbmVzLnN0YWNrKSksXG4gICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgcmVtYWluaW5nTGFuZXMuc291cmNlLFxuICAgICAgICAgICAgICByZW5kZXJQcmlvcml0eUxldmVsLFxuICAgICAgICAgICAgICByZW1haW5pbmdMYW5lcy52YWx1ZSxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAwICE9PSAocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgJiAzKSAmJiBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgMCAhPT0gKGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSAmIDQxOTQyMTgpICYmXG4gICAgICAwICE9PSAocmVtYWluaW5nTGFuZXMgJiA0MilcbiAgICAgICAgPyAoKG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9ICEwKSxcbiAgICAgICAgICByb290ID09PSByb290V2l0aE5lc3RlZFVwZGF0ZXNcbiAgICAgICAgICAgID8gbmVzdGVkVXBkYXRlQ291bnQrK1xuICAgICAgICAgICAgOiAoKG5lc3RlZFVwZGF0ZUNvdW50ID0gMCksIChyb290V2l0aE5lc3RlZFVwZGF0ZXMgPSByb290KSkpXG4gICAgICAgIDogKG5lc3RlZFVwZGF0ZUNvdW50ID0gMCk7XG4gICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gICAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VFcnJvckluZm8oY29tcG9uZW50U3RhY2spIHtcbiAgICAgIGNvbXBvbmVudFN0YWNrID0geyBjb21wb25lbnRTdGFjazogY29tcG9uZW50U3RhY2sgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21wb25lbnRTdGFjaywgXCJkaWdlc3RcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ1lvdSBhcmUgYWNjZXNzaW5nIFwiZGlnZXN0XCIgZnJvbSB0aGUgZXJyb3JJbmZvIG9iamVjdCBwYXNzZWQgdG8gb25SZWNvdmVyYWJsZUVycm9yLiBUaGlzIHByb3BlcnR5IGlzIG5vIGxvbmdlciBwcm92aWRlZCBhcyBwYXJ0IG9mIGVycm9ySW5mbyBidXQgY2FuIGJlIGFjY2Vzc2VkIGFzIGEgcHJvcGVydHkgb2YgdGhlIEVycm9yIGluc3RhbmNlIGl0c2VsZi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcG9uZW50U3RhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpIHtcbiAgICAgIDAgPT09IChyb290LnBvb2xlZENhY2hlTGFuZXMgJj0gcmVtYWluaW5nTGFuZXMpICYmXG4gICAgICAgICgocmVtYWluaW5nTGFuZXMgPSByb290LnBvb2xlZENhY2hlKSxcbiAgICAgICAgbnVsbCAhPSByZW1haW5pbmdMYW5lcyAmJlxuICAgICAgICAgICgocm9vdC5wb29sZWRDYWNoZSA9IG51bGwpLCByZWxlYXNlQ2FjaGUocmVtYWluaW5nTGFuZXMpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSB7XG4gICAgICBpZiAobnVsbCAhPT0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyxcbiAgICAgICAgICByZW1haW5pbmdMYW5lcyA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzO1xuICAgICAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IDA7XG4gICAgICAgIHZhciByZW5kZXJQcmlvcml0eSA9IGxhbmVzVG9FdmVudFByaW9yaXR5KHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzKSxcbiAgICAgICAgICBwcmlvcml0eSA9IDMyID4gcmVuZGVyUHJpb3JpdHkgPyAzMiA6IHJlbmRlclByaW9yaXR5O1xuICAgICAgICByZW5kZXJQcmlvcml0eSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByaW9yaXR5KTtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMpXG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmlvcml0eSA9IHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnM7XG4gICAgICAgICAgICBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIHZhciByb290JGpzY29tcCQwID0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMsXG4gICAgICAgICAgICAgIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gICAgICAgICAgICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGw7XG4gICAgICAgICAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IDA7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09XG4gICAgICAgICAgICAgIE5vQ29udGV4dFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNhbm5vdCBmbHVzaCBwYXNzaXZlIGVmZmVjdHMgd2hpbGUgYWxyZWFkeSByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9ICEwO1xuICAgICAgICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9ICExO1xuICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCAmJlxuICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICAgICAgICAgICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDtcbiAgICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihyb290JGpzY29tcCQwLmN1cnJlbnQpO1xuICAgICAgICAgICAgY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihcbiAgICAgICAgICAgICAgcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcm9vdCRqc2NvbXAkMC5jdXJyZW50LFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgcHJpb3JpdHlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkICYmXG4gICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCgpO1xuICAgICAgICAgICAgY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QkanNjb21wJDApO1xuICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICAgICAgICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpO1xuICAgICAgICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0c1xuICAgICAgICAgICAgICA/IHJvb3QkanNjb21wJDAgPT09IHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXNcbiAgICAgICAgICAgICAgICA/IG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCsrXG4gICAgICAgICAgICAgICAgOiAoKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAgICAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSByb290JGpzY29tcCQwKSlcbiAgICAgICAgICAgICAgOiAobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCk7XG4gICAgICAgICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID1cbiAgICAgICAgICAgICAgITE7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGluamVjdGVkSG9vayAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290XG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXNcIixcbiAgICAgICAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXRlTm9kZSA9IHJvb3QkanNjb21wJDAuY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHJlbmRlclByaW9yaXR5KSxcbiAgICAgICAgICAgIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHJvb3RGaWJlciwgc291cmNlRmliZXIsIGVycm9yKSB7XG4gICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290RmliZXIuc3RhdGVOb2RlLCBzb3VyY2VGaWJlciwgMik7XG4gICAgICByb290RmliZXIgPSBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgc291cmNlRmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcm9vdEZpYmVyICYmXG4gICAgICAgIChtYXJrUm9vdFVwZGF0ZWQkMShyb290RmliZXIsIDIpLCBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdEZpYmVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgc291cmNlRmliZXIsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgZXJyb3JcbiAgICApIHtcbiAgICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExO1xuICAgICAgaWYgKDMgPT09IHNvdXJjZUZpYmVyLnRhZylcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qoc291cmNlRmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICg7IG51bGwgIT09IG5lYXJlc3RNb3VudGVkQW5jZXN0b3I7ICkge1xuICAgICAgICAgIGlmICgzID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnRhZykge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKDEgPT09IG5lYXJlc3RNb3VudGVkQW5jZXN0b3IudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAgICAgICAgIChudWxsID09PSBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCB8fFxuICAgICAgICAgICAgICAgICAgIWxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSkpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgICAgICAgZXJyb3IgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKDIpO1xuICAgICAgICAgICAgICBpbnN0YW5jZSA9IGVucXVldWVVcGRhdGUobmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IsIDIpO1xuICAgICAgICAgICAgICBudWxsICE9PSBpbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgIChpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICAgc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG1hcmtSb290VXBkYXRlZCQxKGluc3RhbmNlLCAyKSxcbiAgICAgICAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yID0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkludGVybmFsIFJlYWN0IGVycm9yOiBBdHRlbXB0ZWQgdG8gY2FwdHVyZSBhIGNvbW1pdCBwaGFzZSBlcnJvciBpbnNpZGUgYSBkZXRhY2hlZCB0cmVlLiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC4gUG90ZW50aWFsIGNhdXNlcyBpbmNsdWRlIGRlbGV0aW5nIHRoZSBzYW1lIGZpYmVyIG1vcmUgdGhhbiBvbmNlLCBjb21taXR0aW5nIGFuIGFscmVhZHktZmluaXNoZWQgdHJlZSwgb3IgYW4gaW5jb25zaXN0ZW50IHJldHVybiBwb2ludGVyLlxcblxcbkVycm9yIG1lc3NhZ2U6XFxuXFxuJXNcIixcbiAgICAgICAgICBlcnJvclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIGxhbmVzKSB7XG4gICAgICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gICAgICBpZiAobnVsbCA9PT0gcGluZ0NhY2hlKSB7XG4gICAgICAgIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xuICAgICAgICB2YXIgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgICAgICBwaW5nQ2FjaGUuc2V0KHdha2VhYmxlLCB0aHJlYWRJRHMpO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHdha2VhYmxlKSksXG4gICAgICAgICAgdm9pZCAwID09PSB0aHJlYWRJRHMgJiZcbiAgICAgICAgICAgICgodGhyZWFkSURzID0gbmV3IFNldCgpKSwgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKSk7XG4gICAgICB0aHJlYWRJRHMuaGFzKGxhbmVzKSB8fFxuICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICEwKSxcbiAgICAgICAgdGhyZWFkSURzLmFkZChsYW5lcyksXG4gICAgICAgIChwaW5nQ2FjaGUgPSBwaW5nU3VzcGVuZGVkUm9vdC5iaW5kKG51bGwsIHJvb3QsIHdha2VhYmxlLCBsYW5lcykpLFxuICAgICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIGxhbmVzKSxcbiAgICAgICAgd2FrZWFibGUudGhlbihwaW5nQ2FjaGUsIHBpbmdDYWNoZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaW5nU3VzcGVuZGVkUm9vdChyb290LCB3YWtlYWJsZSwgcGluZ2VkTGFuZXMpIHtcbiAgICAgIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcbiAgICAgIG51bGwgIT09IHBpbmdDYWNoZSAmJiBwaW5nQ2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgICAgIHJvb3QucGluZ2VkTGFuZXMgfD0gcm9vdC5zdXNwZW5kZWRMYW5lcyAmIHBpbmdlZExhbmVzO1xuICAgICAgcm9vdC53YXJtTGFuZXMgJj0gfnBpbmdlZExhbmVzO1xuICAgICAgaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSAmJlxuICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBzdXNwZW5kZWQgcmVzb3VyY2UgZmluaXNoZWQgbG9hZGluZyBpbnNpZGUgYSB0ZXN0LCBidXQgdGhlIGV2ZW50IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG5XaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCByZXNvbHZlcyBzdXNwZW5kZWQgZGF0YSBzaG91bGQgYmUgd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbmFjdCgoKSA9PiB7XFxuICAvKiBmaW5pc2ggbG9hZGluZyBzdXNwZW5kZWQgZGF0YSAqL1xcbn0pO1xcbi8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBpbiB0aGUgYnJvd3Nlci4gTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0LmRldi9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3RcIlxuICAgICAgICApO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHBpbmdlZExhbmVzKSA9PT0gcGluZ2VkTGFuZXMgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgfHxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA2MjkxNDU2MCkgPT09XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmJlxuICAgICAgICAgIG5vdyQxKCkgLSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIDwgRkFMTEJBQ0tfVEhST1RUTEVfTVMpXG4gICAgICAgICAgPyAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIDApXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgfD0gcGluZ2VkTGFuZXMpLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9IDApKTtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSkge1xuICAgICAgMCA9PT0gcmV0cnlMYW5lICYmIChyZXRyeUxhbmUgPSBjbGFpbU5leHRSZXRyeUxhbmUoKSk7XG4gICAgICBib3VuZGFyeUZpYmVyID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gICAgICBudWxsICE9PSBib3VuZGFyeUZpYmVyICYmXG4gICAgICAgIChtYXJrUm9vdFVwZGF0ZWQkMShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpLFxuICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoYm91bmRhcnlGaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcbiAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICByZXRyeUxhbmUgPSAwO1xuICAgICAgbnVsbCAhPT0gc3VzcGVuc2VTdGF0ZSAmJiAocmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUpO1xuICAgICAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVSZXRyeVdha2VhYmxlKGJvdW5kYXJ5RmliZXIsIHdha2VhYmxlKSB7XG4gICAgICB2YXIgcmV0cnlMYW5lID0gMDtcbiAgICAgIHN3aXRjaCAoYm91bmRhcnlGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICB2YXIgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIG51bGwgIT09IHN1c3BlbnNlU3RhdGUgJiYgKHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlLl9yZXRyeUNhY2hlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJQaW5nZWQgdW5rbm93biBzdXNwZW5zZSBib3VuZGFyeSB0eXBlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IHJldHJ5Q2FjaGUgJiYgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICAgICAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYoXG4gICAgICByb290JGpzY29tcCQwLFxuICAgICAgcGFyZW50RmliZXIsXG4gICAgICBpc0luU3RyaWN0TW9kZVxuICAgICkge1xuICAgICAgaWYgKDAgIT09IChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAzMzU2MjYyNCkpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgICAgICAgIHZhciByb290ID0gcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGZpYmVyID0gcGFyZW50RmliZXIsXG4gICAgICAgICAgICBpc1N0cmljdE1vZGVGaWJlciA9IGZpYmVyLnR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG4gICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXIgPSBpc0luU3RyaWN0TW9kZSB8fCBpc1N0cmljdE1vZGVGaWJlcjtcbiAgICAgICAgICAyMiAhPT0gZmliZXIudGFnXG4gICAgICAgICAgICA/IGZpYmVyLmZsYWdzICYgMzM1NTQ0MzJcbiAgICAgICAgICAgICAgPyBpc1N0cmljdE1vZGVGaWJlciAmJlxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICBkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgIChmaWJlci5tb2RlICYgNjQpID09PSBOb01vZGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgIGlzU3RyaWN0TW9kZUZpYmVyXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBudWxsID09PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIChpc1N0cmljdE1vZGVGaWJlciAmJiBmaWJlci5mbGFncyAmIDgxOTJcbiAgICAgICAgICAgICAgICA/IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgICAgZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGZpYmVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBmaWJlci5zdWJ0cmVlRmxhZ3MgJiAzMzU1NDQzMiAmJlxuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWLFxuICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXJcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlcihyb290LCBmaWJlcikge1xuICAgICAgdmFyIHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzID1cbiAgICAgICAgMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiAhMDtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHMoZmliZXIpLFxuICAgICAgICAgIHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzICYmIGRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0KGZpYmVyKSxcbiAgICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHMocm9vdCwgZmliZXIuYWx0ZXJuYXRlLCBmaWJlciwgITEpLFxuICAgICAgICAgIHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzICYmXG4gICAgICAgICAgICByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhyb290LCBmaWJlciwgMCwgbnVsbCwgITEpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCkge1xuICAgICAgdmFyIGRvdWJsZUludm9rZUVmZmVjdHMgPSAhMDtcbiAgICAgIHJvb3QuY3VycmVudC5tb2RlICYgMjQgfHwgKGRvdWJsZUludm9rZUVmZmVjdHMgPSAhMSk7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKFxuICAgICAgICByb290LFxuICAgICAgICByb290LmN1cnJlbnQsXG4gICAgICAgIGRvdWJsZUludm9rZUVmZmVjdHNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoZmliZXIpIHtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDMgPT09IHRhZyB8fFxuICAgICAgICAgIDEgPT09IHRhZyB8fFxuICAgICAgICAgIDAgPT09IHRhZyB8fFxuICAgICAgICAgIDExID09PSB0YWcgfHxcbiAgICAgICAgICAxNCA9PT0gdGFnIHx8XG4gICAgICAgICAgMTUgPT09IHRhZ1xuICAgICAgICApIHtcbiAgICAgICAgICB0YWcgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIlJlYWN0Q29tcG9uZW50XCI7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50Lmhhcyh0YWcpKSByZXR1cm47XG4gICAgICAgICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50LmFkZCh0YWcpO1xuICAgICAgICAgIH0gZWxzZSBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ID0gbmV3IFNldChbdGFnXSk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmliZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgYXN5bmNocm9ub3VzbHkgbGF0ZXIgY2FsbHMgdHJpZXMgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQuIE1vdmUgdGhpcyB3b3JrIHRvIHVzZUVmZmVjdCBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpIHtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmXG4gICAgICAgIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsaW5nRmliZXIpIHtcbiAgICAgICAgICBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgc2NoZWR1bGluZ0ZpYmVyLCBsYW5lcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgYWN0UXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZTtcbiAgICAgIHJldHVybiBudWxsICE9PSBhY3RRdWV1ZVxuICAgICAgICA/IChhY3RRdWV1ZS5wdXNoKGNhbGxiYWNrKSwgZmFrZUFjdENhbGxiYWNrTm9kZSlcbiAgICAgICAgOiBzY2hlZHVsZUNhbGxiYWNrJDMocHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpIHtcbiAgICAgIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiZcbiAgICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmliZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgY2F1c2VzIFJlYWN0IHN0YXRlIHVwZGF0ZXMgc2hvdWxkIGJlIHdyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG5hY3QoKCkgPT4ge1xcbiAgLyogZmlyZSBldmVudHMgdGhhdCB1cGRhdGUgc3RhdGUgKi9cXG59KTtcXG4vKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcblRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgaW4gdGhlIGJyb3dzZXIuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0XCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpIHJldHVybiB0eXBlO1xuICAgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBmYW1pbHkgPyB0eXBlIDogZmFtaWx5LmN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KSByZXR1cm4gdHlwZTtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZmFtaWx5XG4gICAgICAgID8gbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUucmVuZGVyICYmXG4gICAgICAgICAgKChmYW1pbHkgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZS5yZW5kZXIpKSxcbiAgICAgICAgICB0eXBlLnJlbmRlciAhPT0gZmFtaWx5KVxuICAgICAgICAgID8gKChmYW1pbHkgPSB7ICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLCByZW5kZXI6IGZhbWlseSB9KSxcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZS5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAoZmFtaWx5LmRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSksXG4gICAgICAgICAgICBmYW1pbHkpXG4gICAgICAgICAgOiB0eXBlXG4gICAgICAgIDogZmFtaWx5LmN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhmaWJlciwgZWxlbWVudCkge1xuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpIHJldHVybiAhMTtcbiAgICAgIHZhciBwcmV2VHlwZSA9IGZpYmVyLmVsZW1lbnRUeXBlO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQudHlwZTtcbiAgICAgIHZhciBuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICExLFxuICAgICAgICAkJHR5cGVvZk5leHRUeXBlID1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZWxlbWVudCAmJiBudWxsICE9PSBlbGVtZW50XG4gICAgICAgICAgICA/IGVsZW1lbnQuJCR0eXBlb2ZcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlbGVtZW50ICYmIChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGVsZW1lbnRcbiAgICAgICAgICAgID8gKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApXG4gICAgICAgICAgICA6ICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRVxuICAgICAgICAgICAgPyAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMClcbiAgICAgICAgICAgIDogJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgIChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9NRU1PX1RZUEVcbiAgICAgICAgICAgID8gKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApXG4gICAgICAgICAgICA6ICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5lZWRzQ29tcGFyZUZhbWlsaWVzICYmXG4gICAgICAgICgoZmliZXIgPSByZXNvbHZlRmFtaWx5KHByZXZUeXBlKSksXG4gICAgICAgIHZvaWQgMCAhPT0gZmliZXIgJiYgZmliZXIgPT09IHJlc29sdmVGYW1pbHkoZWxlbWVudCkpXG4gICAgICAgID8gITBcbiAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpIHtcbiAgICAgIG51bGwgIT09IHJlc29sdmVGYW1pbHkgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha1NldCAmJlxuICAgICAgICAobnVsbCA9PT0gZmFpbGVkQm91bmRhcmllcyAmJiAoZmFpbGVkQm91bmRhcmllcyA9IG5ldyBXZWFrU2V0KCkpLFxuICAgICAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChmaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgZmliZXIsXG4gICAgICB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICBzdGFsZUZhbWlsaWVzXG4gICAgKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlLFxuICAgICAgICBjaGlsZCA9IGZpYmVyLmNoaWxkLFxuICAgICAgICBzaWJsaW5nID0gZmliZXIuc2libGluZyxcbiAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZSxcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IG51bGw7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCA9PT0gcmVzb2x2ZUZhbWlseSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC5cIik7XG4gICAgICB2YXIgbmVlZHNSZW5kZXIgPSAhMTtcbiAgICAgIHR5cGUgPSAhMTtcbiAgICAgIG51bGwgIT09IGNhbmRpZGF0ZVR5cGUgJiZcbiAgICAgICAgKChjYW5kaWRhdGVUeXBlID0gcmVzb2x2ZUZhbWlseShjYW5kaWRhdGVUeXBlKSksXG4gICAgICAgIHZvaWQgMCAhPT0gY2FuZGlkYXRlVHlwZSAmJlxuICAgICAgICAgIChzdGFsZUZhbWlsaWVzLmhhcyhjYW5kaWRhdGVUeXBlKVxuICAgICAgICAgICAgPyAodHlwZSA9ICEwKVxuICAgICAgICAgICAgOiB1cGRhdGVkRmFtaWxpZXMuaGFzKGNhbmRpZGF0ZVR5cGUpICYmXG4gICAgICAgICAgICAgICgxID09PSB0YWcgPyAodHlwZSA9ICEwKSA6IChuZWVkc1JlbmRlciA9ICEwKSkpKTtcbiAgICAgIG51bGwgIT09IGZhaWxlZEJvdW5kYXJpZXMgJiZcbiAgICAgICAgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fFxuICAgICAgICAgIChudWxsICE9PSBhbHRlcm5hdGUgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoYWx0ZXJuYXRlKSkpICYmXG4gICAgICAgICh0eXBlID0gITApO1xuICAgICAgdHlwZSAmJiAoZmliZXIuX2RlYnVnTmVlZHNSZW1vdW50ID0gITApO1xuICAgICAgaWYgKHR5cGUgfHwgbmVlZHNSZW5kZXIpXG4gICAgICAgIChhbHRlcm5hdGUgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGFsdGVybmF0ZSwgZmliZXIsIDIpO1xuICAgICAgbnVsbCA9PT0gY2hpbGQgfHxcbiAgICAgICAgdHlwZSB8fFxuICAgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIHVwZGF0ZWRGYW1pbGllcyxcbiAgICAgICAgICBzdGFsZUZhbWlsaWVzXG4gICAgICAgICk7XG4gICAgICBudWxsICE9PSBzaWJsaW5nICYmXG4gICAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoXG4gICAgICAgICAgc2libGluZyxcbiAgICAgICAgICB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICAgICAgc3RhbGVGYW1pbGllc1xuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuc2libGluZyA9XG4gICAgICAgIHRoaXMuY2hpbGQgPVxuICAgICAgICB0aGlzLnJldHVybiA9XG4gICAgICAgIHRoaXMuc3RhdGVOb2RlID1cbiAgICAgICAgdGhpcy50eXBlID1cbiAgICAgICAgdGhpcy5lbGVtZW50VHlwZSA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgdGhpcy5yZWZDbGVhbnVwID0gdGhpcy5yZWYgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcyA9XG4gICAgICAgIHRoaXMubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgIHRoaXMudXBkYXRlUXVldWUgPVxuICAgICAgICB0aGlzLm1lbW9pemVkUHJvcHMgPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5zdWJ0cmVlRmxhZ3MgPSB0aGlzLmZsYWdzID0gMDtcbiAgICAgIHRoaXMuZGVsZXRpb25zID0gbnVsbDtcbiAgICAgIHRoaXMuY2hpbGRMYW5lcyA9IHRoaXMubGFuZXMgPSAwO1xuICAgICAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IC0wO1xuICAgICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMS4xO1xuICAgICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gLTA7XG4gICAgICB0aGlzLl9kZWJ1Z093bmVyID0gdGhpcy5fZGVidWdJbmZvID0gbnVsbDtcbiAgICAgIHRoaXMuX2RlYnVnTmVlZHNSZW1vdW50ID0gITE7XG4gICAgICB0aGlzLl9kZWJ1Z0hvb2tUeXBlcyA9IG51bGw7XG4gICAgICBoYXNCYWRNYXBQb2x5ZmlsbCB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgfHxcbiAgICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gICAgICBDb21wb25lbnQgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEoIUNvbXBvbmVudCB8fCAhQ29tcG9uZW50LmlzUmVhY3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBwZW5kaW5nUHJvcHMpIHtcbiAgICAgIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoXG4gICAgICAgICAgICBjdXJyZW50LnRhZyxcbiAgICAgICAgICAgIHBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIGN1cnJlbnQua2V5LFxuICAgICAgICAgICAgY3VycmVudC5tb2RlXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lciksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudCksXG4gICAgICAgICAgKGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3MpKVxuICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSAtMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmFjdHVhbFN0YXJ0VGltZSA9IC0xLjEpKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gY3VycmVudC5mbGFncyAmIDMxNDU3MjgwO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgcGVuZGluZ1Byb3BzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPVxuICAgICAgICBudWxsID09PSBwZW5kaW5nUHJvcHNcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgbGFuZXM6IHBlbmRpbmdQcm9wcy5sYW5lcyxcbiAgICAgICAgICAgICAgZmlyc3RDb250ZXh0OiBwZW5kaW5nUHJvcHMuZmlyc3RDb250ZXh0LFxuICAgICAgICAgICAgICBfZGVidWdUaGVuYWJsZVN0YXRlOiBwZW5kaW5nUHJvcHMuX2RlYnVnVGhlbmFibGVTdGF0ZVxuICAgICAgICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnJlZkNsZWFudXAgPSBjdXJyZW50LnJlZkNsZWFudXA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm8gPSBjdXJyZW50Ll9kZWJ1Z0luZm87XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgPSBjdXJyZW50Ll9kZWJ1Z05lZWRzUmVtb3VudDtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3Mod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAzMTQ1NzI4MjtcbiAgICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IDApKVxuICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlKSxcbiAgICAgICAgICAocmVuZGVyTGFuZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9XG4gICAgICAgICAgICBudWxsID09PSByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICBsYW5lczogcmVuZGVyTGFuZXMubGFuZXMsXG4gICAgICAgICAgICAgICAgICBmaXJzdENvbnRleHQ6IHJlbmRlckxhbmVzLmZpcnN0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAgIF9kZWJ1Z1RoZW5hYmxlU3RhdGU6IHJlbmRlckxhbmVzLl9kZWJ1Z1RoZW5hYmxlU3RhdGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbiksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb24pKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgdHlwZSxcbiAgICAgIGtleSxcbiAgICAgIHBlbmRpbmdQcm9wcyxcbiAgICAgIG93bmVyLFxuICAgICAgbW9kZSxcbiAgICAgIGxhbmVzXG4gICAgKSB7XG4gICAgICB2YXIgZmliZXJUYWcgPSAwLFxuICAgICAgICByZXNvbHZlZFR5cGUgPSB0eXBlO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHNob3VsZENvbnN0cnVjdCh0eXBlKSAmJiAoZmliZXJUYWcgPSAxKSxcbiAgICAgICAgICAocmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSkpO1xuICAgICAgZWxzZSBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN1cHBvcnRzUmVzb3VyY2VzICYmIHN1cHBvcnRzU2luZ2xldG9uc1xuICAgICAgICAgID8gKChmaWJlclRhZyA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgKGZpYmVyVGFnID0gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwZW5kaW5nUHJvcHMsIGZpYmVyVGFnKVxuICAgICAgICAgICAgICA/IDI2XG4gICAgICAgICAgICAgIDogaXNIb3N0U2luZ2xldG9uVHlwZSh0eXBlKVxuICAgICAgICAgICAgICAgID8gMjdcbiAgICAgICAgICAgICAgICA6IDUpKVxuICAgICAgICAgIDogc3VwcG9ydHNSZXNvdXJjZXNcbiAgICAgICAgICAgID8gKChmaWJlclRhZyA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAoZmliZXJUYWcgPSBpc0hvc3RIb2lzdGFibGVUeXBlKHR5cGUsIHBlbmRpbmdQcm9wcywgZmliZXJUYWcpXG4gICAgICAgICAgICAgICAgPyAyNlxuICAgICAgICAgICAgICAgIDogNSkpXG4gICAgICAgICAgICA6IChmaWJlclRhZyA9IHN1cHBvcnRzU2luZ2xldG9uc1xuICAgICAgICAgICAgICAgID8gaXNIb3N0U2luZ2xldG9uVHlwZSh0eXBlKVxuICAgICAgICAgICAgICAgICAgPyAyN1xuICAgICAgICAgICAgICAgICAgOiA1XG4gICAgICAgICAgICAgICAgOiA1KTtcbiAgICAgIGVsc2VcbiAgICAgICAgYTogc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICBwZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgICAgZmliZXJUYWcgPSA4O1xuICAgICAgICAgICAgbW9kZSB8PSAyNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh0eXBlID0gcGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgICAgKG93bmVyID0gbW9kZSksXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiB0eXBlLmlkICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdQcm9maWxlciBtdXN0IHNwZWNpZnkgYW4gXCJpZFwiIG9mIHR5cGUgYHN0cmluZ2AgYXMgYSBwcm9wLiBSZWNlaXZlZCB0aGUgdHlwZSBgJXNgIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiB0eXBlLmlkXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGtleSA9IGNyZWF0ZUZpYmVyKDEyLCB0eXBlLCBrZXksIG93bmVyIHwgMikpLFxuICAgICAgICAgICAgICAoa2V5LmVsZW1lbnRUeXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRSksXG4gICAgICAgICAgICAgIChrZXkubGFuZXMgPSBsYW5lcyksXG4gICAgICAgICAgICAgIChrZXkuc3RhdGVOb2RlID0geyBlZmZlY3REdXJhdGlvbjogMCwgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiAwIH0pLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGtleSA9IGNyZWF0ZUZpYmVyKDEzLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkpLFxuICAgICAgICAgICAgICAoa2V5LmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRSksXG4gICAgICAgICAgICAgIChrZXkubGFuZXMgPSBsYW5lcyksXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBjcmVhdGVGaWJlcigxOSwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpKSxcbiAgICAgICAgICAgICAgKGtleS5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSksXG4gICAgICAgICAgICAgIChrZXkubGFuZXMgPSBsYW5lcyksXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX09GRlNDUkVFTl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiYgbnVsbCAhPT0gdHlwZSlcbiAgICAgICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSA5O1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDExO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDE0O1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gMTY7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdm9pZCAwID09PSB0eXBlIHx8XG4gICAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICAwID09PSBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGgpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJlc29sdmVkVHlwZSArPVxuICAgICAgICAgICAgICAgIFwiIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICAgICAgPyAocGVuZGluZ1Byb3BzID0gXCJudWxsXCIpXG4gICAgICAgICAgICAgIDogaXNBcnJheUltcGwodHlwZSlcbiAgICAgICAgICAgICAgICA/IChwZW5kaW5nUHJvcHMgPSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgOiB2b2lkIDAgIT09IHR5cGUgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG4gICAgICAgICAgICAgICAgICA/ICgocGVuZGluZ1Byb3BzID1cbiAgICAgICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAgICAgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiVW5rbm93blwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgXCIgLz5cIiksXG4gICAgICAgICAgICAgICAgICAgIChyZXNvbHZlZFR5cGUgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpKVxuICAgICAgICAgICAgICAgICAgOiAocGVuZGluZ1Byb3BzID0gdHlwZW9mIHR5cGUpO1xuICAgICAgICAgICAgZmliZXJUYWcgPSBvd25lclxuICAgICAgICAgICAgICA/IFwibnVtYmVyXCIgPT09IHR5cGVvZiBvd25lci50YWdcbiAgICAgICAgICAgICAgICA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpXG4gICAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3duZXIubmFtZVxuICAgICAgICAgICAgICAgICAgPyBvd25lci5uYW1lXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgZmliZXJUYWcgJiZcbiAgICAgICAgICAgICAgKHJlc29sdmVkVHlwZSArPVxuICAgICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYFwiICsgZmliZXJUYWcgKyBcImAuXCIpO1xuICAgICAgICAgICAgZmliZXJUYWcgPSAyOTtcbiAgICAgICAgICAgIHBlbmRpbmdQcm9wcyA9IEVycm9yKFxuICAgICAgICAgICAgICBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogXCIgK1xuICAgICAgICAgICAgICAgIChwZW5kaW5nUHJvcHMgKyBcIi5cIiArIHJlc29sdmVkVHlwZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICBrZXkgPSBjcmVhdGVGaWJlcihmaWJlclRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICAgICAga2V5LmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgICAgIGtleS50eXBlID0gcmVzb2x2ZWRUeXBlO1xuICAgICAga2V5LmxhbmVzID0gbGFuZXM7XG4gICAgICBrZXkuX2RlYnVnT3duZXIgPSBvd25lcjtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgbGFuZXMpIHtcbiAgICAgIG1vZGUgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICAgIGVsZW1lbnQudHlwZSxcbiAgICAgICAgZWxlbWVudC5rZXksXG4gICAgICAgIGVsZW1lbnQucHJvcHMsXG4gICAgICAgIGVsZW1lbnQuX293bmVyLFxuICAgICAgICBtb2RlLFxuICAgICAgICBsYW5lc1xuICAgICAgKTtcbiAgICAgIG1vZGUuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHJldHVybiBtb2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICAgICAgZWxlbWVudHMgPSBjcmVhdGVGaWJlcig3LCBlbGVtZW50cywga2V5LCBtb2RlKTtcbiAgICAgIGVsZW1lbnRzLmxhbmVzID0gbGFuZXM7XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgICAgIHBlbmRpbmdQcm9wcyA9IGNyZWF0ZUZpYmVyKDIyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gICAgICBwZW5kaW5nUHJvcHMuZWxlbWVudFR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcbiAgICAgIHBlbmRpbmdQcm9wcy5sYW5lcyA9IGxhbmVzO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZEluc3RhbmNlID0ge1xuICAgICAgICBfdmlzaWJpbGl0eTogMSxcbiAgICAgICAgX3BlbmRpbmdWaXNpYmlsaXR5OiAxLFxuICAgICAgICBfcGVuZGluZ01hcmtlcnM6IG51bGwsXG4gICAgICAgIF9yZXRyeUNhY2hlOiBudWxsLFxuICAgICAgICBfdHJhbnNpdGlvbnM6IG51bGwsXG4gICAgICAgIF9jdXJyZW50OiBudWxsLFxuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZSxcbiAgICAgICAgICAgIGZpYmVyID0gaW5zdGFuY2UuX2N1cnJlbnQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FsbGluZyBPZmZzY3JlZW4uZGV0YWNoIGJlZm9yZSBpbnN0YW5jZSBoYW5kbGUgaGFzIGJlZW4gc2V0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmICgwID09PSAoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMikpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgKChpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgfD0gMiksXG4gICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXR0YWNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gcHJpbWFyeUNoaWxkSW5zdGFuY2UsXG4gICAgICAgICAgICBmaWJlciA9IGluc3RhbmNlLl9jdXJyZW50O1xuICAgICAgICAgIGlmIChudWxsID09PSBmaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkNhbGxpbmcgT2Zmc2NyZWVuLmRldGFjaCBiZWZvcmUgaW5zdGFuY2UgaGFuZGxlIGhhcyBiZWVuIHNldC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoMCAhPT0gKGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIDIpKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICAgICAgICBudWxsICE9PSByb290ICYmXG4gICAgICAgICAgICAgICgoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICY9IC0zKSxcbiAgICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcGVuZGluZ1Byb3BzLnN0YXRlTm9kZSA9IHByaW1hcnlDaGlsZEluc3RhbmNlO1xuICAgICAgcmV0dXJuIHBlbmRpbmdQcm9wcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBsYW5lcykge1xuICAgICAgY29udGVudCA9IGNyZWF0ZUZpYmVyKDYsIGNvbnRlbnQsIG51bGwsIG1vZGUpO1xuICAgICAgY29udGVudC5sYW5lcyA9IGxhbmVzO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIG1vZGUsIGxhbmVzKSB7XG4gICAgICBtb2RlID0gY3JlYXRlRmliZXIoXG4gICAgICAgIDQsXG4gICAgICAgIG51bGwgIT09IHBvcnRhbC5jaGlsZHJlbiA/IHBvcnRhbC5jaGlsZHJlbiA6IFtdLFxuICAgICAgICBwb3J0YWwua2V5LFxuICAgICAgICBtb2RlXG4gICAgICApO1xuICAgICAgbW9kZS5sYW5lcyA9IGxhbmVzO1xuICAgICAgbW9kZS5zdGF0ZU5vZGUgPSB7XG4gICAgICAgIGNvbnRhaW5lckluZm86IHBvcnRhbC5jb250YWluZXJJbmZvLFxuICAgICAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgICAgIH07XG4gICAgICByZXR1cm4gbW9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRmliZXJSb290Tm9kZShcbiAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICB0YWcsXG4gICAgICBoeWRyYXRlLFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIHRoaXMudGFnID0gMTtcbiAgICAgIHRoaXMuY29udGFpbmVySW5mbyA9IGNvbnRhaW5lckluZm87XG4gICAgICB0aGlzLmZpbmlzaGVkV29yayA9XG4gICAgICAgIHRoaXMucGluZ0NhY2hlID1cbiAgICAgICAgdGhpcy5jdXJyZW50ID1cbiAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGRyZW4gPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7XG4gICAgICB0aGlzLmNhbGxiYWNrTm9kZSA9XG4gICAgICAgIHRoaXMubmV4dCA9XG4gICAgICAgIHRoaXMucGVuZGluZ0NvbnRleHQgPVxuICAgICAgICB0aGlzLmNvbnRleHQgPVxuICAgICAgICB0aGlzLmNhbmNlbFBlbmRpbmdDb21taXQgPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSAwO1xuICAgICAgdGhpcy5leHBpcmF0aW9uVGltZXMgPSBjcmVhdGVMYW5lTWFwKC0xKTtcbiAgICAgIHRoaXMuZW50YW5nbGVkTGFuZXMgPVxuICAgICAgICB0aGlzLnNoZWxsU3VzcGVuZENvdW50ZXIgPVxuICAgICAgICB0aGlzLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzID1cbiAgICAgICAgdGhpcy5maW5pc2hlZExhbmVzID1cbiAgICAgICAgdGhpcy5leHBpcmVkTGFuZXMgPVxuICAgICAgICB0aGlzLndhcm1MYW5lcyA9XG4gICAgICAgIHRoaXMucGluZ2VkTGFuZXMgPVxuICAgICAgICB0aGlzLnN1c3BlbmRlZExhbmVzID1cbiAgICAgICAgdGhpcy5wZW5kaW5nTGFuZXMgPVxuICAgICAgICAgIDA7XG4gICAgICB0aGlzLmVudGFuZ2xlbWVudHMgPSBjcmVhdGVMYW5lTWFwKDApO1xuICAgICAgdGhpcy5oaWRkZW5VcGRhdGVzID0gY3JlYXRlTGFuZU1hcChudWxsKTtcbiAgICAgIHRoaXMuaWRlbnRpZmllclByZWZpeCA9IGlkZW50aWZpZXJQcmVmaXg7XG4gICAgICB0aGlzLm9uVW5jYXVnaHRFcnJvciA9IG9uVW5jYXVnaHRFcnJvcjtcbiAgICAgIHRoaXMub25DYXVnaHRFcnJvciA9IG9uQ2F1Z2h0RXJyb3I7XG4gICAgICB0aGlzLm9uUmVjb3ZlcmFibGVFcnJvciA9IG9uUmVjb3ZlcmFibGVFcnJvcjtcbiAgICAgIHRoaXMucG9vbGVkQ2FjaGUgPSBudWxsO1xuICAgICAgdGhpcy5wb29sZWRDYWNoZUxhbmVzID0gMDtcbiAgICAgIHRoaXMuZm9ybVN0YXRlID0gZm9ybVN0YXRlO1xuICAgICAgdGhpcy5pbmNvbXBsZXRlVHJhbnNpdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IHRoaXMuZWZmZWN0RHVyYXRpb24gPSAtMDtcbiAgICAgIHRoaXMubWVtb2l6ZWRVcGRhdGVycyA9IG5ldyBTZXQoKTtcbiAgICAgIGNvbnRhaW5lckluZm8gPSB0aGlzLnBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSBbXTtcbiAgICAgIGZvciAodGFnID0gMDsgMzEgPiB0YWc7IHRhZysrKSBjb250YWluZXJJbmZvLnB1c2gobmV3IFNldCgpKTtcbiAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSBoeWRyYXRlID8gXCJoeWRyYXRlUm9vdCgpXCIgOiBcImNyZWF0ZVJvb3QoKVwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoXG4gICAgICBjb250YWluZXJJbmZvLFxuICAgICAgdGFnLFxuICAgICAgaHlkcmF0ZSxcbiAgICAgIGluaXRpYWxDaGlsZHJlbixcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcyxcbiAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgdHJhbnNpdGlvbkNhbGxiYWNrcyxcbiAgICAgIGZvcm1TdGF0ZVxuICAgICkge1xuICAgICAgY29udGFpbmVySW5mbyA9IG5ldyBGaWJlclJvb3ROb2RlKFxuICAgICAgICBjb250YWluZXJJbmZvLFxuICAgICAgICB0YWcsXG4gICAgICAgIGh5ZHJhdGUsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICBmb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICB0YWcgPSAxO1xuICAgICAgITAgPT09IGlzU3RyaWN0TW9kZSAmJiAodGFnIHw9IDI0KTtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmICh0YWcgfD0gMik7XG4gICAgICBpc1N0cmljdE1vZGUgPSBjcmVhdGVGaWJlcigzLCBudWxsLCBudWxsLCB0YWcpO1xuICAgICAgY29udGFpbmVySW5mby5jdXJyZW50ID0gaXNTdHJpY3RNb2RlO1xuICAgICAgaXNTdHJpY3RNb2RlLnN0YXRlTm9kZSA9IGNvbnRhaW5lckluZm87XG4gICAgICB0YWcgPSBjcmVhdGVDYWNoZSgpO1xuICAgICAgcmV0YWluQ2FjaGUodGFnKTtcbiAgICAgIGNvbnRhaW5lckluZm8ucG9vbGVkQ2FjaGUgPSB0YWc7XG4gICAgICByZXRhaW5DYWNoZSh0YWcpO1xuICAgICAgaXNTdHJpY3RNb2RlLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgIGVsZW1lbnQ6IGluaXRpYWxDaGlsZHJlbixcbiAgICAgICAgaXNEZWh5ZHJhdGVkOiBoeWRyYXRlLFxuICAgICAgICBjYWNoZTogdGFnXG4gICAgICB9O1xuICAgICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGlzU3RyaWN0TW9kZSk7XG4gICAgICByZXR1cm4gY29udGFpbmVySW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIGlmICghcGFyZW50Q29tcG9uZW50KSByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgcGFyZW50Q29tcG9uZW50ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgcmV0dXJuIHBhcmVudENvbXBvbmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyU3luYyhcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgMCA9PT0gY29udGFpbmVyLnRhZyAmJiBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICB1cGRhdGVDb250YWluZXJJbXBsKFxuICAgICAgICBjb250YWluZXIuY3VycmVudCxcbiAgICAgICAgMixcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lckltcGwoXG4gICAgICByb290RmliZXIsXG4gICAgICBsYW5lLFxuICAgICAgZWxlbWVudCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGluamVjdGVkSG9vayAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdFxuICAgICAgKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290KHJlbmRlcmVySUQsIGNvbnRhaW5lciwgZWxlbWVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU2NoZWR1bGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTtcbiAgICAgIHBhcmVudENvbXBvbmVudCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgICBudWxsID09PSBjb250YWluZXIuY29udGV4dFxuICAgICAgICA/IChjb250YWluZXIuY29udGV4dCA9IHBhcmVudENvbXBvbmVudClcbiAgICAgICAgOiAoY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gcGFyZW50Q29tcG9uZW50KTtcbiAgICAgIGlzUmVuZGVyaW5nICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgJiZcbiAgICAgICAgKChkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gITApLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLlwiLFxuICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudCkgfHwgXCJVbmtub3duXCJcbiAgICAgICAgKSk7XG4gICAgICBjb250YWluZXIgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICBjb250YWluZXIucGF5bG9hZCA9IHsgZWxlbWVudDogZWxlbWVudCB9O1xuICAgICAgY2FsbGJhY2sgPSB2b2lkIDAgPT09IGNhbGxiYWNrID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKSxcbiAgICAgICAgKGNvbnRhaW5lci5jYWxsYmFjayA9IGNhbGxiYWNrKSk7XG4gICAgICBlbGVtZW50ID0gZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIGNvbnRhaW5lciwgbGFuZSk7XG4gICAgICBudWxsICE9PSBlbGVtZW50ICYmXG4gICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZWxlbWVudCwgcm9vdEZpYmVyLCBsYW5lKSxcbiAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhlbGVtZW50LCByb290RmliZXIsIGxhbmUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSkge1xuICAgICAgZmliZXIgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGZpYmVyICYmIG51bGwgIT09IGZpYmVyLmRlaHlkcmF0ZWQpIHtcbiAgICAgICAgdmFyIGEgPSBmaWJlci5yZXRyeUxhbmU7XG4gICAgICAgIGZpYmVyLnJldHJ5TGFuZSA9IDAgIT09IGEgJiYgYSA8IHJldHJ5TGFuZSA/IGEgOiByZXRyeUxhbmU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgICAgIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpO1xuICAgICAgKGZpYmVyID0gZmliZXIuYWx0ZXJuYXRlKSAmJiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMoKSB7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TGFuZUxhYmVsTWFwKCkge1xuICAgICAgZm9yICh2YXIgbWFwID0gbmV3IE1hcCgpLCBsYW5lID0gMSwgaW5kZXggPSAwOyAzMSA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGdldExhYmVsRm9yTGFuZShsYW5lKTtcbiAgICAgICAgbWFwLnNldChsYW5lLCBsYWJlbCk7XG4gICAgICAgIGxhbmUgKj0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHZhciBleHBvcnRzID0ge307XG4gICAgKFwidXNlIHN0cmljdFwiKTtcbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIiksXG4gICAgICBTY2hlZHVsZXIgPSByZXF1aXJlKFwic2NoZWR1bGVyXCIpLFxuICAgICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbixcbiAgICAgIFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksXG4gICAgICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LmRlYnVnX3RyYWNlX21vZGVcIik7XG4gICAgdmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QubGVnYWN5X2hpZGRlblwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QudHJhY2luZ19tYXJrZXJcIik7XG4gICAgdmFyIFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSxcbiAgICAgIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcixcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgZGlzYWJsZWREZXB0aCA9IDAsXG4gICAgICBwcmV2TG9nLFxuICAgICAgcHJldkluZm8sXG4gICAgICBwcmV2V2FybixcbiAgICAgIHByZXZFcnJvcixcbiAgICAgIHByZXZHcm91cCxcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCxcbiAgICAgIHByZXZHcm91cEVuZDtcbiAgICBkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICB2YXIgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgcmVlbnRyeSA9ICExO1xuICAgIHZhciBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IChcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwXG4gICAgKSgpO1xuICAgIHZhciBjdXJyZW50ID0gbnVsbCxcbiAgICAgIGlzUmVuZGVyaW5nID0gITEsXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICByZW5kZXJlclZlcnNpb24gPSAkJCRjb25maWcucmVuZGVyZXJWZXJzaW9uLFxuICAgICAgcmVuZGVyZXJQYWNrYWdlTmFtZSA9ICQkJGNvbmZpZy5yZW5kZXJlclBhY2thZ2VOYW1lLFxuICAgICAgZXh0cmFEZXZUb29sc0NvbmZpZyA9ICQkJGNvbmZpZy5leHRyYURldlRvb2xzQ29uZmlnLFxuICAgICAgZ2V0UHVibGljSW5zdGFuY2UgPSAkJCRjb25maWcuZ2V0UHVibGljSW5zdGFuY2UsXG4gICAgICBnZXRSb290SG9zdENvbnRleHQgPSAkJCRjb25maWcuZ2V0Um9vdEhvc3RDb250ZXh0LFxuICAgICAgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9ICQkJGNvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0LFxuICAgICAgcHJlcGFyZUZvckNvbW1pdCA9ICQkJGNvbmZpZy5wcmVwYXJlRm9yQ29tbWl0LFxuICAgICAgcmVzZXRBZnRlckNvbW1pdCA9ICQkJGNvbmZpZy5yZXNldEFmdGVyQ29tbWl0LFxuICAgICAgY3JlYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlSW5zdGFuY2UsXG4gICAgICBhcHBlbmRJbml0aWFsQ2hpbGQgPSAkJCRjb25maWcuYXBwZW5kSW5pdGlhbENoaWxkLFxuICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4gPSAkJCRjb25maWcuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4sXG4gICAgICBzaG91bGRTZXRUZXh0Q29udGVudCA9ICQkJGNvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudCxcbiAgICAgIGNyZWF0ZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5jcmVhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBzY2hlZHVsZVRpbWVvdXQgPSAkJCRjb25maWcuc2NoZWR1bGVUaW1lb3V0LFxuICAgICAgY2FuY2VsVGltZW91dCA9ICQkJGNvbmZpZy5jYW5jZWxUaW1lb3V0LFxuICAgICAgbm9UaW1lb3V0ID0gJCQkY29uZmlnLm5vVGltZW91dCxcbiAgICAgIGlzUHJpbWFyeVJlbmRlcmVyID0gJCQkY29uZmlnLmlzUHJpbWFyeVJlbmRlcmVyO1xuICAgICQkJGNvbmZpZy53YXJuc0lmTm90QWN0aW5nO1xuICAgIHZhciBzdXBwb3J0c011dGF0aW9uID0gJCQkY29uZmlnLnN1cHBvcnRzTXV0YXRpb24sXG4gICAgICBzdXBwb3J0c1BlcnNpc3RlbmNlID0gJCQkY29uZmlnLnN1cHBvcnRzUGVyc2lzdGVuY2UsXG4gICAgICBzdXBwb3J0c0h5ZHJhdGlvbiA9ICQkJGNvbmZpZy5zdXBwb3J0c0h5ZHJhdGlvbixcbiAgICAgIGdldEluc3RhbmNlRnJvbU5vZGUgPSAkJCRjb25maWcuZ2V0SW5zdGFuY2VGcm9tTm9kZTtcbiAgICAkJCRjb25maWcuYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyO1xuICAgICQkJGNvbmZpZy5hZnRlckFjdGl2ZUluc3RhbmNlQmx1cjtcbiAgICB2YXIgcHJlcGFyZVBvcnRhbE1vdW50ID0gJCQkY29uZmlnLnByZXBhcmVQb3J0YWxNb3VudDtcbiAgICAkJCRjb25maWcucHJlcGFyZVNjb3BlVXBkYXRlO1xuICAgICQkJGNvbmZpZy5nZXRJbnN0YW5jZUZyb21TY29wZTtcbiAgICB2YXIgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5ID0gJCQkY29uZmlnLnNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSxcbiAgICAgIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSA9ICQkJGNvbmZpZy5nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHksXG4gICAgICByZXNvbHZlVXBkYXRlUHJpb3JpdHkgPSAkJCRjb25maWcucmVzb2x2ZVVwZGF0ZVByaW9yaXR5O1xuICAgICQkJGNvbmZpZy5yZXNvbHZlRXZlbnRUeXBlO1xuICAgICQkJGNvbmZpZy5yZXNvbHZlRXZlbnRUaW1lU3RhbXA7XG4gICAgdmFyIHNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24gPSAkJCRjb25maWcuc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbixcbiAgICAgIGRldGFjaERlbGV0ZWRJbnN0YW5jZSA9ICQkJGNvbmZpZy5kZXRhY2hEZWxldGVkSW5zdGFuY2U7XG4gICAgJCQkY29uZmlnLnJlcXVlc3RQb3N0UGFpbnRDYWxsYmFjaztcbiAgICB2YXIgbWF5U3VzcGVuZENvbW1pdCA9ICQkJGNvbmZpZy5tYXlTdXNwZW5kQ29tbWl0LFxuICAgICAgcHJlbG9hZEluc3RhbmNlID0gJCQkY29uZmlnLnByZWxvYWRJbnN0YW5jZSxcbiAgICAgIHN0YXJ0U3VzcGVuZGluZ0NvbW1pdCA9ICQkJGNvbmZpZy5zdGFydFN1c3BlbmRpbmdDb21taXQsXG4gICAgICBzdXNwZW5kSW5zdGFuY2UgPSAkJCRjb25maWcuc3VzcGVuZEluc3RhbmNlLFxuICAgICAgd2FpdEZvckNvbW1pdFRvQmVSZWFkeSA9ICQkJGNvbmZpZy53YWl0Rm9yQ29tbWl0VG9CZVJlYWR5LFxuICAgICAgTm90UGVuZGluZ1RyYW5zaXRpb24gPSAkJCRjb25maWcuTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgICBIb3N0VHJhbnNpdGlvbkNvbnRleHQgPSAkJCRjb25maWcuSG9zdFRyYW5zaXRpb25Db250ZXh0LFxuICAgICAgcmVzZXRGb3JtSW5zdGFuY2UgPSAkJCRjb25maWcucmVzZXRGb3JtSW5zdGFuY2UsXG4gICAgICBiaW5kVG9Db25zb2xlID0gJCQkY29uZmlnLmJpbmRUb0NvbnNvbGUsXG4gICAgICBzdXBwb3J0c01pY3JvdGFza3MgPSAkJCRjb25maWcuc3VwcG9ydHNNaWNyb3Rhc2tzLFxuICAgICAgc2NoZWR1bGVNaWNyb3Rhc2sgPSAkJCRjb25maWcuc2NoZWR1bGVNaWNyb3Rhc2ssXG4gICAgICBzdXBwb3J0c1Rlc3RTZWxlY3RvcnMgPSAkJCRjb25maWcuc3VwcG9ydHNUZXN0U2VsZWN0b3JzLFxuICAgICAgZmluZEZpYmVyUm9vdCA9ICQkJGNvbmZpZy5maW5kRmliZXJSb290LFxuICAgICAgZ2V0Qm91bmRpbmdSZWN0ID0gJCQkY29uZmlnLmdldEJvdW5kaW5nUmVjdCxcbiAgICAgIGdldFRleHRDb250ZW50ID0gJCQkY29uZmlnLmdldFRleHRDb250ZW50LFxuICAgICAgaXNIaWRkZW5TdWJ0cmVlID0gJCQkY29uZmlnLmlzSGlkZGVuU3VidHJlZSxcbiAgICAgIG1hdGNoQWNjZXNzaWJpbGl0eVJvbGUgPSAkJCRjb25maWcubWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSxcbiAgICAgIHNldEZvY3VzSWZGb2N1c2FibGUgPSAkJCRjb25maWcuc2V0Rm9jdXNJZkZvY3VzYWJsZSxcbiAgICAgIHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAkJCRjb25maWcuc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlcixcbiAgICAgIGFwcGVuZENoaWxkID0gJCQkY29uZmlnLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9ICQkJGNvbmZpZy5hcHBlbmRDaGlsZFRvQ29udGFpbmVyLFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9ICQkJGNvbmZpZy5jb21taXRUZXh0VXBkYXRlLFxuICAgICAgY29tbWl0TW91bnQgPSAkJCRjb25maWcuY29tbWl0TW91bnQsXG4gICAgICBjb21taXRVcGRhdGUgPSAkJCRjb25maWcuY29tbWl0VXBkYXRlLFxuICAgICAgaW5zZXJ0QmVmb3JlID0gJCQkY29uZmlnLmluc2VydEJlZm9yZSxcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlID0gJCQkY29uZmlnLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSAkJCRjb25maWcucmVtb3ZlQ2hpbGQsXG4gICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIgPSAkJCRjb25maWcucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyLFxuICAgICAgcmVzZXRUZXh0Q29udGVudCA9ICQkJGNvbmZpZy5yZXNldFRleHRDb250ZW50LFxuICAgICAgaGlkZUluc3RhbmNlID0gJCQkY29uZmlnLmhpZGVJbnN0YW5jZSxcbiAgICAgIGhpZGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuaGlkZVRleHRJbnN0YW5jZSxcbiAgICAgIHVuaGlkZUluc3RhbmNlID0gJCQkY29uZmlnLnVuaGlkZUluc3RhbmNlLFxuICAgICAgdW5oaWRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLnVuaGlkZVRleHRJbnN0YW5jZSxcbiAgICAgIGNsZWFyQ29udGFpbmVyID0gJCQkY29uZmlnLmNsZWFyQ29udGFpbmVyLFxuICAgICAgY2xvbmVJbnN0YW5jZSA9ICQkJGNvbmZpZy5jbG9uZUluc3RhbmNlLFxuICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSAkJCRjb25maWcuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSAkJCRjb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9ICQkJGNvbmZpZy5maW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gJCQkY29uZmlnLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgIGNsb25lSGlkZGVuSW5zdGFuY2UgPSAkJCRjb25maWcuY2xvbmVIaWRkZW5JbnN0YW5jZSxcbiAgICAgIGNsb25lSGlkZGVuVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmNsb25lSGlkZGVuVGV4dEluc3RhbmNlLFxuICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyA9ICQkJGNvbmZpZy5pc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nLFxuICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2sgPSAkJCRjb25maWcuaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2ssXG4gICAgICBnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMgPVxuICAgICAgICAkJCRjb25maWcuZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzLFxuICAgICAgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkgPSAkJCRjb25maWcucmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnksXG4gICAgICBjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVGb3JtU3RhdGVNYXJrZXIsXG4gICAgICBpc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nID0gJCQkY29uZmlnLmlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmcsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSAkJCRjb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lciA9XG4gICAgICAgICQkJGNvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcixcbiAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZSA9XG4gICAgICAgICQkJGNvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuY2FuSHlkcmF0ZUluc3RhbmNlLFxuICAgICAgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBoeWRyYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5oeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlID1cbiAgICAgICAgJCQkY29uZmlnLmdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBjb21taXRIeWRyYXRlZENvbnRhaW5lciA9ICQkJGNvbmZpZy5jb21taXRIeWRyYXRlZENvbnRhaW5lcixcbiAgICAgIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGNvbmZpZy5jb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBjbGVhclN1c3BlbnNlQm91bmRhcnkgPSAkJCRjb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5LFxuICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lciA9XG4gICAgICAgICQkJGNvbmZpZy5jbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyLFxuICAgICAgc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMgPVxuICAgICAgICAkJCRjb25maWcuc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMsXG4gICAgICBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzID1cbiAgICAgICAgJCQkY29uZmlnLmRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MsXG4gICAgICBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MgPSAkJCRjb25maWcuZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzLFxuICAgICAgZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyA9XG4gICAgICAgICQkJGNvbmZpZy5kZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzLFxuICAgICAgdmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2UgPSAkJCRjb25maWcudmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgICB2YWxpZGF0ZUh5ZHJhdGFibGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcudmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlLFxuICAgICAgc3VwcG9ydHNSZXNvdXJjZXMgPSAkJCRjb25maWcuc3VwcG9ydHNSZXNvdXJjZXMsXG4gICAgICBpc0hvc3RIb2lzdGFibGVUeXBlID0gJCQkY29uZmlnLmlzSG9zdEhvaXN0YWJsZVR5cGUsXG4gICAgICBnZXRIb2lzdGFibGVSb290ID0gJCQkY29uZmlnLmdldEhvaXN0YWJsZVJvb3QsXG4gICAgICBnZXRSZXNvdXJjZSA9ICQkJGNvbmZpZy5nZXRSZXNvdXJjZSxcbiAgICAgIGFjcXVpcmVSZXNvdXJjZSA9ICQkJGNvbmZpZy5hY3F1aXJlUmVzb3VyY2UsXG4gICAgICByZWxlYXNlUmVzb3VyY2UgPSAkJCRjb25maWcucmVsZWFzZVJlc291cmNlLFxuICAgICAgaHlkcmF0ZUhvaXN0YWJsZSA9ICQkJGNvbmZpZy5oeWRyYXRlSG9pc3RhYmxlLFxuICAgICAgbW91bnRIb2lzdGFibGUgPSAkJCRjb25maWcubW91bnRIb2lzdGFibGUsXG4gICAgICB1bm1vdW50SG9pc3RhYmxlID0gJCQkY29uZmlnLnVubW91bnRIb2lzdGFibGUsXG4gICAgICBjcmVhdGVIb2lzdGFibGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5jcmVhdGVIb2lzdGFibGVJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMgPSAkJCRjb25maWcucHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcyxcbiAgICAgIG1heVJlc291cmNlU3VzcGVuZENvbW1pdCA9ICQkJGNvbmZpZy5tYXlSZXNvdXJjZVN1c3BlbmRDb21taXQsXG4gICAgICBwcmVsb2FkUmVzb3VyY2UgPSAkJCRjb25maWcucHJlbG9hZFJlc291cmNlLFxuICAgICAgc3VzcGVuZFJlc291cmNlID0gJCQkY29uZmlnLnN1c3BlbmRSZXNvdXJjZSxcbiAgICAgIHN1cHBvcnRzU2luZ2xldG9ucyA9ICQkJGNvbmZpZy5zdXBwb3J0c1NpbmdsZXRvbnMsXG4gICAgICByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UgPSAkJCRjb25maWcucmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlLFxuICAgICAgY2xlYXJTaW5nbGV0b24gPSAkJCRjb25maWcuY2xlYXJTaW5nbGV0b24sXG4gICAgICBhY3F1aXJlU2luZ2xldG9uSW5zdGFuY2UgPSAkJCRjb25maWcuYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlLFxuICAgICAgcmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLnJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZSxcbiAgICAgIGlzSG9zdFNpbmdsZXRvblR5cGUgPSAkJCRjb25maWcuaXNIb3N0U2luZ2xldG9uVHlwZSxcbiAgICAgIHZhbHVlU3RhY2sgPSBbXTtcbiAgICB2YXIgZmliZXJTdGFjayA9IFtdO1xuICAgIHZhciBpbmRleCRqc2NvbXAkMCA9IC0xLFxuICAgICAgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG4gICAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xuICAgIHZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjayxcbiAgICAgIGxvZyQxID0gTWF0aC5sb2csXG4gICAgICBMTjIgPSBNYXRoLkxOMixcbiAgICAgIG5leHRUcmFuc2l0aW9uTGFuZSA9IDEyOCxcbiAgICAgIG5leHRSZXRyeUxhbmUgPSA0MTk0MzA0LFxuICAgICAgc2NoZWR1bGVDYWxsYmFjayQzID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gICAgICBjYW5jZWxDYWxsYmFjayQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrLFxuICAgICAgc2hvdWxkWWllbGQgPSBTY2hlZHVsZXIudW5zdGFibGVfc2hvdWxkWWllbGQsXG4gICAgICByZXF1ZXN0UGFpbnQgPSBTY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50LFxuICAgICAgbm93JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93LFxuICAgICAgSW1tZWRpYXRlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHksXG4gICAgICBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxcbiAgICAgIE5vcm1hbFByaW9yaXR5JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gICAgICBJZGxlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5LFxuICAgICAgbG9nID0gU2NoZWR1bGVyLmxvZyxcbiAgICAgIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlLFxuICAgICAgcmVuZGVyZXJJRCA9IG51bGwsXG4gICAgICBpbmplY3RlZEhvb2sgPSBudWxsLFxuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcyA9IG51bGwsXG4gICAgICBoYXNMb2dnZWRFcnJvciA9ICExLFxuICAgICAgaXNEZXZUb29sc1ByZXNlbnQgPSBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLFxuICAgICAgb2JqZWN0SXMgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBpcyxcbiAgICAgIENhcHR1cmVkU3RhY2tzID0gbmV3IFdlYWtNYXAoKSxcbiAgICAgIGZvcmtTdGFjayA9IFtdLFxuICAgICAgZm9ya1N0YWNrSW5kZXggPSAwLFxuICAgICAgdHJlZUZvcmtQcm92aWRlciA9IG51bGwsXG4gICAgICB0cmVlRm9ya0NvdW50ID0gMCxcbiAgICAgIGlkU3RhY2sgPSBbXSxcbiAgICAgIGlkU3RhY2tJbmRleCA9IDAsXG4gICAgICB0cmVlQ29udGV4dFByb3ZpZGVyID0gbnVsbCxcbiAgICAgIHRyZWVDb250ZXh0SWQgPSAxLFxuICAgICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IFwiXCIsXG4gICAgICBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIG5lZWRzRXNjYXBpbmcgPSAvW1wiJyY8PlxcblxcdF18Xlxcc3xcXHMkLyxcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbCxcbiAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsLFxuICAgICAgaXNIeWRyYXRpbmcgPSAhMSxcbiAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWID0gITEsXG4gICAgICBoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwsXG4gICAgICBoeWRyYXRpb25FcnJvcnMgPSBudWxsLFxuICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExLFxuICAgICAgSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJIeWRyYXRpb24gTWlzbWF0Y2ggRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IsIGFuZCBzaG91bGQgbm90IGxlYWsgaW50byB1c2Vyc3BhY2UuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgaXQncyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICksXG4gICAgICBOb01vZGUgPSAwLFxuICAgICAgY29uY3VycmVudFF1ZXVlcyA9IFtdLFxuICAgICAgY29uY3VycmVudFF1ZXVlc0luZGV4ID0gMCxcbiAgICAgIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyA9IDAsXG4gICAgICBub3cgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93LFxuICAgICAgY29tbWl0U3RhcnRUaW1lID0gLTAsXG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xLjEsXG4gICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uID0gLTAsXG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSAhMSxcbiAgICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9ICExLFxuICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbnVsbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbCxcbiAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrID0gITEsXG4gICAgICBkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgPSAhMSxcbiAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICExLFxuICAgICAgaXNGbHVzaGluZ1dvcmsgPSAhMSxcbiAgICAgIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gMCxcbiAgICAgIGZha2VBY3RDYWxsYmFja05vZGUkMSA9IHt9LFxuICAgICAgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGwsXG4gICAgICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ID0gMCxcbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gMCxcbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IG51bGwsXG4gICAgICBVcGRhdGVTdGF0ZSA9IDAsXG4gICAgICBSZXBsYWNlU3RhdGUgPSAxLFxuICAgICAgRm9yY2VVcGRhdGUgPSAyLFxuICAgICAgQ2FwdHVyZVVwZGF0ZSA9IDMsXG4gICAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgIHZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gITE7XG4gICAgdmFyIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gICAgdmFyIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICAgICAgICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbiAgICAgIH0sXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdLFxuICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChcbiAgICAgIGZpYmVyLFxuICAgICAgaW5zdGFuY2VcbiAgICApIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpIHx8XG4gICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgJiZcbiAgICAgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIGZpYmVyLm1vZGUgJiA4ICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAhMCAhPT1cbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAmJlxuICAgICAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIGZpYmVyLm1vZGUgJiA4ICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICEwICE9PSBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgJiZcbiAgICAgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBmaWJlci5tb2RlICYgOCAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcikpO1xuICAgIH07XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKFxuICAgICAgICAgIGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXSkpO1xuICAgICAgaWYgKDAgPCBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSkge1xuICAgICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgMCA8IFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lc1xuICAgICAgICApKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgcmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kZXJpdmVkLXN0YXRlXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgICAwIDwgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzXG4gICAgICAgICkpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgICAwIDwgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpKSxcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbiogUmVuYW1lIGNvbXBvbmVudFdpbGxNb3VudCB0byBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IHRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuIFRvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgICAwIDwgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFxuICAgICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lc1xuICAgICAgICApKSxcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0LmRldi9saW5rL2Rlcml2ZWQtc3RhdGVcXG4qIFJlbmFtZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuIFRvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgICAwIDwgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcykpLFxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJjb21wb25lbnRXaWxsVXBkYXRlIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4qIFJlbmFtZSBjb21wb25lbnRXaWxsVXBkYXRlIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIHRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuIFRvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgfTtcbiAgICB2YXIgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpLFxuICAgICAgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCA9IG5ldyBTZXQoKTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIChcbiAgICAgIGZpYmVyLFxuICAgICAgaW5zdGFuY2VcbiAgICApIHtcbiAgICAgIHZhciBzdHJpY3RSb290ID0gbnVsbDtcbiAgICAgIGZvciAodmFyIG5vZGUgPSBmaWJlcjsgbnVsbCAhPT0gbm9kZTsgKVxuICAgICAgICBub2RlLm1vZGUgJiA4ICYmIChzdHJpY3RSb290ID0gbm9kZSksIChub2RlID0gbm9kZS5yZXR1cm4pO1xuICAgICAgbnVsbCA9PT0gc3RyaWN0Um9vdFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApXG4gICAgICAgIDogIWRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuaGFzKGZpYmVyLnR5cGUpICYmXG4gICAgICAgICAgKChub2RlID0gcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmdldChzdHJpY3RSb290KSksXG4gICAgICAgICAgbnVsbCAhPSBmaWJlci50eXBlLmNvbnRleHRUeXBlcyB8fFxuICAgICAgICAgICAgbnVsbCAhPSBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzIHx8XG4gICAgICAgICAgICAobnVsbCAhPT0gaW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KSkgJiZcbiAgICAgICAgICAodm9pZCAwID09PSBub2RlICYmXG4gICAgICAgICAgICAoKG5vZGUgPSBbXSksIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5zZXQoc3RyaWN0Um9vdCwgbm9kZSkpLFxuICAgICAgICAgIG5vZGUucHVzaChmaWJlcikpO1xuICAgIH07XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlckFycmF5KSB7XG4gICAgICAgIGlmICgwICE9PSBmaWJlckFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIHZhciBmaXJzdEZpYmVyID0gZmliZXJBcnJheVswXSxcbiAgICAgICAgICAgIHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGZpYmVyQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKHVuaXF1ZU5hbWVzKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaXJzdEZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkxlZ2FjeSBjb250ZXh0IEFQSSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlLlxcblxcblRoZSBvbGQgQVBJIHdpbGwgYmUgc3VwcG9ydGVkIGluIGFsbCAxNi54IHJlbGVhc2VzLCBidXQgYXBwbGljYXRpb25zIHVzaW5nIGl0IHNob3VsZCBtaWdyYXRlIHRvIHRoZSBuZXcgdmVyc2lvbi5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOiBodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0XCIsXG4gICAgICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuICAgIH07XG4gICAgdmFyIFN1c3BlbnNlRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciByZXRocm93IGl0IGltbWVkaWF0ZWx5LCBvciBtb3ZlIHRoZSBgdXNlYCBjYWxsIG91dHNpZGUgb2YgdGhlIGB0cnkvY2F0Y2hgIGJsb2NrLiBDYXB0dXJpbmcgd2l0aG91dCByZXRocm93aW5nIHdpbGwgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcblRvIGhhbmRsZSBhc3luYyBlcnJvcnMsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYW4gZXJyb3IgYm91bmRhcnksIG9yIGNhbGwgdGhlIHByb21pc2UncyBgLmNhdGNoYCBtZXRob2QgYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBgdXNlYFwiXG4gICAgICApLFxuICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IsIGFuZCBzaG91bGQgbm90IGxlYWsgaW50byB1c2Vyc3BhY2UuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgaXQncyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICksXG4gICAgICBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUgPSB7XG4gICAgICAgIHRoZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0ludGVybmFsIFJlYWN0IGVycm9yOiBBIGxpc3RlbmVyIHdhcyB1bmV4cGVjdGVkbHkgYXR0YWNoZWQgdG8gYSBcIm5vb3BcIiB0aGVuYWJsZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGwsXG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICExLFxuICAgICAgY2FsbENvbXBvbmVudCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAgICAgICAgIHZhciB3YXNSZW5kZXJpbmcgPSBpc1JlbmRlcmluZztcbiAgICAgICAgICBpc1JlbmRlcmluZyA9ICEwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpc1JlbmRlcmluZyA9IHdhc1JlbmRlcmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50SW5ERVYgPVxuICAgICAgICBjYWxsQ29tcG9uZW50W1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbENvbXBvbmVudCksXG4gICAgICBjYWxsUmVuZGVyID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICB2YXIgd2FzUmVuZGVyaW5nID0gaXNSZW5kZXJpbmc7XG4gICAgICAgICAgaXNSZW5kZXJpbmcgPSAhMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpc1JlbmRlcmluZyA9IHdhc1JlbmRlcmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsUmVuZGVySW5ERVYgPSBjYWxsUmVuZGVyW1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbFJlbmRlciksXG4gICAgICBjYWxsQ29tcG9uZW50RGlkTW91bnQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmssIGluc3RhbmNlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWID0gY2FsbENvbXBvbmVudERpZE1vdW50W1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgICBdLmJpbmQoY2FsbENvbXBvbmVudERpZE1vdW50KSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRVcGRhdGUgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgIHByZXZTdGF0ZSxcbiAgICAgICAgICBzbmFwc2hvdFxuICAgICAgICApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBzbmFwc2hvdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRVcGRhdGVJbkRFViA9IGNhbGxDb21wb25lbnREaWRVcGRhdGVbXG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJcbiAgICAgIF0uYmluZChjYWxsQ29tcG9uZW50RGlkVXBkYXRlKSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRDYXRjaCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGluc3RhbmNlLCBlcnJvckluZm8pIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3JJbmZvLnZhbHVlLCB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFjazogbnVsbCAhPT0gc3RhY2sgPyBzdGFjayA6IFwiXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRDYXRjaEluREVWID0gY2FsbENvbXBvbmVudERpZENhdGNoW1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgICBdLmJpbmQoY2FsbENvbXBvbmVudERpZENhdGNoKSxcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudEluREVWID0gY2FsbENvbXBvbmVudFdpbGxVbm1vdW50W1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgICBdLmJpbmQoY2FsbENvbXBvbmVudFdpbGxVbm1vdW50KSxcbiAgICAgIGNhbGxDcmVhdGUgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChlZmZlY3QpIHtcbiAgICAgICAgICB2YXIgY3JlYXRlID0gZWZmZWN0LmNyZWF0ZTtcbiAgICAgICAgICBlZmZlY3QgPSBlZmZlY3QuaW5zdDtcbiAgICAgICAgICBjcmVhdGUgPSBjcmVhdGUoKTtcbiAgICAgICAgICByZXR1cm4gKGVmZmVjdC5kZXN0cm95ID0gY3JlYXRlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDcmVhdGVJbkRFViA9IGNhbGxDcmVhdGVbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsQ3JlYXRlKSxcbiAgICAgIGNhbGxEZXN0cm95ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgIGRlc3Ryb3lcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxEZXN0cm95SW5ERVYgPVxuICAgICAgICBjYWxsRGVzdHJveVtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxEZXN0cm95KSxcbiAgICAgIGNhbGxMYXp5SW5pdCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGxhenkpIHtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenkuX2luaXQ7XG4gICAgICAgICAgcmV0dXJuIGluaXQobGF6eS5fcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsTGF6eUluaXRJbkRFViA9XG4gICAgICAgIGNhbGxMYXp5SW5pdFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxMYXp5SW5pdCksXG4gICAgICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsLFxuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDAsXG4gICAgICBjdXJyZW50RGVidWdJbmZvID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dE1hcHM7XG4gICAgdmFyIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSAoZGlkV2FybkFib3V0TWFwcyA9ICExKTtcbiAgICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gICAgdmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuICAgIHZhciBvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nID0ge307XG4gICAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCkge1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBjaGlsZCAmJlxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY2hpbGQgJiZcbiAgICAgICAgY2hpbGQuX3N0b3JlICYmXG4gICAgICAgICgoIWNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgJiYgbnVsbCA9PSBjaGlsZC5rZXkpIHx8XG4gICAgICAgICAgMiA9PT0gY2hpbGQuX3N0b3JlLnZhbGlkYXRlZClcbiAgICAgICkge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGNoaWxkLl9zdG9yZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IDE7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlciksXG4gICAgICAgICAgY29tcG9uZW50S2V5ID0gY29tcG9uZW50TmFtZSB8fCBcIm51bGxcIjtcbiAgICAgICAgaWYgKCFvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50S2V5XSkge1xuICAgICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnRLZXldID0gITA7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5fb3duZXI7XG4gICAgICAgICAgcmV0dXJuRmliZXIgPSByZXR1cm5GaWJlci5fZGVidWdPd25lcjtcbiAgICAgICAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IFwiXCI7XG4gICAgICAgICAgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiByZXR1cm5GaWJlci50YWcgJiZcbiAgICAgICAgICAgIChjb21wb25lbnRLZXkgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSkgJiZcbiAgICAgICAgICAgIChjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID1cbiAgICAgICAgICAgICAgXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBjb21wb25lbnRLZXkgKyBcImAuXCIpO1xuICAgICAgICAgIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gfHxcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAgIChjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID1cbiAgICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICtcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lICtcbiAgICAgICAgICAgICAgICBcIj4uXCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRPd25lckFwcGVuZGl4ID0gXCJcIjtcbiAgICAgICAgICBudWxsICE9IGNoaWxkICYmXG4gICAgICAgICAgICByZXR1cm5GaWJlciAhPT0gY2hpbGQgJiZcbiAgICAgICAgICAgICgoY29tcG9uZW50TmFtZSA9IG51bGwpLFxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNoaWxkLnRhZ1xuICAgICAgICAgICAgICA/IChjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjaGlsZCkpXG4gICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkLm5hbWUgJiYgKGNvbXBvbmVudE5hbWUgPSBjaGlsZC5uYW1lKSxcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgKGNoaWxkT3duZXJBcHBlbmRpeCA9XG4gICAgICAgICAgICAgICAgXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjb21wb25lbnROYW1lICsgXCIuXCIpKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVih3b3JrSW5Qcm9ncmVzcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4lcyVzIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLFxuICAgICAgICAgICAgICBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLFxuICAgICAgICAgICAgICBjaGlsZE93bmVyQXBwZW5kaXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWNvbmNpbGVDaGlsZEZpYmVycyA9IGNyZWF0ZUNoaWxkUmVjb25jaWxlcighMCksXG4gICAgICBtb3VudENoaWxkRmliZXJzID0gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKCExKSxcbiAgICAgIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IgPSBjcmVhdGVDdXJzb3IoMCksXG4gICAgICBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIHNoZWxsQm91bmRhcnkgPSBudWxsLFxuICAgICAgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgPSAxLFxuICAgICAgRm9yY2VTdXNwZW5zZUZhbGxiYWNrID0gMixcbiAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoMCksXG4gICAgICBOb0ZsYWdzID0gMCxcbiAgICAgIEhhc0VmZmVjdCA9IDEsXG4gICAgICBJbnNlcnRpb24gPSAyLFxuICAgICAgTGF5b3V0ID0gNCxcbiAgICAgIFBhc3NpdmUgPSA4LFxuICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3Q7XG4gICAgdmFyIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2ggPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50ID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHJlbmRlckxhbmVzID0gMCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsLFxuICAgICAgY3VycmVudEhvb2sgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbCxcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExLFxuICAgICAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSAhMSxcbiAgICAgIGxvY2FsSWRDb3VudGVyID0gMCxcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMCxcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsLFxuICAgICAgZ2xvYmFsQ2xpZW50SWRDb3VudGVyID0gMCxcbiAgICAgIFJFX1JFTkRFUl9MSU1JVCA9IDI1LFxuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsLFxuICAgICAgaG9va1R5cGVzRGV2ID0gbnVsbCxcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTEsXG4gICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9ICExO1xuICAgIHZhciBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgbGFzdEVmZmVjdDogbnVsbCwgZXZlbnRzOiBudWxsLCBzdG9yZXM6IG51bGwsIG1lbW9DYWNoZTogbnVsbCB9O1xuICAgIH07XG4gICAgdmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlciA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUNvbnRleHQ6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZU1lbW86IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZVJlZHVjZXI6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZVJlZjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlU3RhdGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZURlYnVnVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZVRyYW5zaXRpb246IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VJZDogdGhyb3dJbnZhbGlkSG9va0Vycm9yXG4gICAgfTtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlQ2FjaGVSZWZyZXNoID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VNZW1vQ2FjaGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG4gICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VGb3JtU3RhdGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG4gICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUFjdGlvblN0YXRlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VPcHRpbWlzdGljID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIHZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsLFxuICAgICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IG51bGwsXG4gICAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbCxcbiAgICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGwsXG4gICAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbCxcbiAgICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbCxcbiAgICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgbW91bnRFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKHBhc3N0aHJvdWdoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIG1vdW50RWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaFxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50T3B0aW1pc3RpYyhwYXNzdGhyb3VnaCk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaCxcbiAgICAgIHJlZHVjZXJcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChcbiAgICAgIHBhc3N0aHJvdWdoLFxuICAgICAgcmVkdWNlclxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBtb3VudEVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vQ2FjaGU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlTWVtb0NhY2hlKHNpemUpO1xuICAgICAgfVxuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvbixcbiAgICAgIGluaXRpYWxTdGF0ZVxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvbixcbiAgICAgIGluaXRpYWxTdGF0ZVxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaFxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2UodXNhYmxlKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlTWVtb0NhY2hlOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaCxcbiAgICAgIHJlZHVjZXJcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb25cbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaCxcbiAgICAgIHJlZHVjZXJcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgICB2YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcbiAgICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbiAgICB2YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICAgICAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSBjdXJyZW50O1xuICAgICAgICAgIGlmIChudWxsICE9PSBvd25lciAmJiBpc1JlbmRlcmluZyAmJiAxID09PSBvd25lci50YWcpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG93bmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciB8fFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiByZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkIG5ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzIHJlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kIGNvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpIHx8IFwiQSBjb21wb25lbnRcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoY29tcG9uZW50ID0gY29tcG9uZW50Ll9yZWFjdEludGVybmFscylcbiAgICAgICAgICAgID8gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihjb21wb25lbnQpID09PSBjb21wb25lbnRcbiAgICAgICAgICAgIDogITE7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAod2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSwgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKSk7XG4gICAgICAgICAgcGF5bG9hZCA9IGVucXVldWVVcGRhdGUoaW5zdCwgdXBkYXRlLCBsYW5lKTtcbiAgICAgICAgICBudWxsICE9PSBwYXlsb2FkICYmXG4gICAgICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBheWxvYWQsIGluc3QsIGxhbmUpLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhwYXlsb2FkLCBpbnN0LCBsYW5lKSk7XG4gICAgICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGluc3QsIGxhbmUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShpbnN0KSxcbiAgICAgICAgICAgIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgICAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgICAgICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgKHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayksICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgICAgIHBheWxvYWQgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gcGF5bG9hZCAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXlsb2FkLCBpbnN0LCBsYW5lKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocGF5bG9hZCwgaW5zdCwgbGFuZSkpO1xuICAgICAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChpbnN0LCBsYW5lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShpbnN0KSxcbiAgICAgICAgICAgIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgICAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG4gICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICh3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spLCAodXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2spKTtcbiAgICAgICAgICBjYWxsYmFjayA9IGVucXVldWVVcGRhdGUoaW5zdCwgdXBkYXRlLCBsYW5lKTtcbiAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihjYWxsYmFjaywgaW5zdCwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKGNhbGxiYWNrLCBpbnN0LCBsYW5lKSk7XG4gICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQgJiZcbiAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkKGluc3QsIGxhbmUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVwb3J0R2xvYmFsRXJyb3IgPVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXBvcnRFcnJvclxuICAgICAgICAgID8gcmVwb3J0RXJyb3JcbiAgICAgICAgICA6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHdpbmRvdyAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHdpbmRvdy5FcnJvckV2ZW50XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyB3aW5kb3cuRXJyb3JFdmVudChcImVycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyhlcnJvci5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpKSByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHByb2Nlc3MgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcm9jZXNzLmVtaXRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KFwidW5jYXVnaHRFeGNlcHRpb25cIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICBjb21wb25lbnROYW1lID0gbnVsbCxcbiAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gbnVsbCxcbiAgICAgIFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlRoaXMgaXMgbm90IGEgcmVhbCBlcnJvci4gSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgUmVhY3QncyBzZWxlY3RpdmUgaHlkcmF0aW9uIGZlYXR1cmUuIElmIHRoaXMgbGVha3MgaW50byB1c2Vyc3BhY2UsIGl0J3MgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApLFxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9ICExO1xuICAgIHZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9ICExO1xuICAgIHZhciBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlciA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucyA9IHt9O1xuICAgIHZhciBTVVNQRU5ERURfTUFSS0VSID0ge1xuICAgICAgICBkZWh5ZHJhdGVkOiBudWxsLFxuICAgICAgICB0cmVlQ29udGV4dDogbnVsbCxcbiAgICAgICAgcmV0cnlMYW5lOiAwXG4gICAgICB9LFxuICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSAhMSxcbiAgICAgIHZhbHVlQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xuICAgIHZhciByZW5kZXJlckN1cnNvckRFViA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgICB2YXIgcmVuZGVyZXIyQ3Vyc29yREVWID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xuICAgIHZhciByZW5kZXJlclNpZ2lsID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbCxcbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGwsXG4gICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITEsXG4gICAgICBBYm9ydENvbnRyb2xsZXJMb2NhbCA9XG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgICA/IEFib3J0Q29udHJvbGxlclxuICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gW10sXG4gICAgICAgICAgICAgICAgc2lnbmFsID0gKHRoaXMuc2lnbmFsID0ge1xuICAgICAgICAgICAgICAgICAgYWJvcnRlZDogITEsXG4gICAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNpZ25hbC5hYm9ydGVkID0gITA7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDEgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxcbiAgICAgIE5vcm1hbFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgICAgQ2FjaGVDb250ZXh0ID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgICBDb25zdW1lcjogbnVsbCxcbiAgICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICAgIF9jdXJyZW50VmFsdWU6IG51bGwsXG4gICAgICAgIF9jdXJyZW50VmFsdWUyOiBudWxsLFxuICAgICAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgICAgIF9jdXJyZW50UmVuZGVyZXI6IG51bGwsXG4gICAgICAgIF9jdXJyZW50UmVuZGVyZXIyOiBudWxsXG4gICAgICB9LFxuICAgICAgcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5TID0gZnVuY3Rpb24gKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiAmJlxuICAgICAgICBlbnRhbmdsZUFzeW5jQWN0aW9uKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgIG51bGwgIT09IHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgICBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2godHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgIH07XG4gICAgdmFyIHJlc3VtZWRDYWNoZSA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbnVsbDtcbiAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gITEsXG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gITEsXG4gICAgICBuZWVkc0Zvcm1SZXNldCA9ICExLFxuICAgICAgUG9zc2libHlXZWFrU2V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha1NldCA/IFdlYWtTZXQgOiBTZXQsXG4gICAgICBuZXh0RWZmZWN0ID0gbnVsbCxcbiAgICAgIGluUHJvZ3Jlc3NMYW5lcyA9IG51bGwsXG4gICAgICBpblByb2dyZXNzUm9vdCA9IG51bGwsXG4gICAgICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSAhMSxcbiAgICAgIGhvc3RQYXJlbnQgPSBudWxsLFxuICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITEsXG4gICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IG51bGwsXG4gICAgICBzdXNwZW5zZXlDb21taXRGbGFnID0gODE5MixcbiAgICAgIERlZmF1bHRBc3luY0Rpc3BhdGNoZXIgPSB7XG4gICAgICAgIGdldENhY2hlRm9yVHlwZTogZnVuY3Rpb24gKHJlc291cmNlVHlwZSkge1xuICAgICAgICAgIHZhciBjYWNoZSA9IHJlYWRDb250ZXh0KENhY2hlQ29udGV4dCksXG4gICAgICAgICAgICBjYWNoZUZvclR5cGUgPSBjYWNoZS5kYXRhLmdldChyZXNvdXJjZVR5cGUpO1xuICAgICAgICAgIHZvaWQgMCA9PT0gY2FjaGVGb3JUeXBlICYmXG4gICAgICAgICAgICAoKGNhY2hlRm9yVHlwZSA9IHJlc291cmNlVHlwZSgpKSxcbiAgICAgICAgICAgIGNhY2hlLmRhdGEuc2V0KHJlc291cmNlVHlwZSwgY2FjaGVGb3JUeXBlKSk7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlRm9yVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T3duZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENPTVBPTkVOVF9UWVBFID0gMCxcbiAgICAgIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IDEsXG4gICAgICBST0xFX1RZUEUgPSAyLFxuICAgICAgVEVTVF9OQU1FX1RZUEUgPSAzLFxuICAgICAgVEVYVF9UWVBFID0gNDtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC5mb3IpIHtcbiAgICAgIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICAgICAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IoXCJzZWxlY3Rvci5jb21wb25lbnRcIik7XG4gICAgICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IoXCJzZWxlY3Rvci5oYXNfcHNldWRvX2NsYXNzXCIpO1xuICAgICAgUk9MRV9UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3Iucm9sZVwiKTtcbiAgICAgIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3IudGVzdF9pZFwiKTtcbiAgICAgIFRFWFRfVFlQRSA9IHN5bWJvbEZvcihcInNlbGVjdG9yLnRleHRcIik7XG4gICAgfVxuICAgIHZhciBjb21taXRIb29rcyA9IFtdLFxuICAgICAgUG9zc2libHlXZWFrTWFwID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXAsXG4gICAgICBOb0NvbnRleHQgPSAwLFxuICAgICAgUmVuZGVyQ29udGV4dCA9IDIsXG4gICAgICBDb21taXRDb250ZXh0ID0gNCxcbiAgICAgIFJvb3RJblByb2dyZXNzID0gMCxcbiAgICAgIFJvb3RGYXRhbEVycm9yZWQgPSAxLFxuICAgICAgUm9vdEVycm9yZWQgPSAyLFxuICAgICAgUm9vdFN1c3BlbmRlZCA9IDMsXG4gICAgICBSb290U3VzcGVuZGVkV2l0aERlbGF5ID0gNCxcbiAgICAgIFJvb3RDb21wbGV0ZWQgPSA1LFxuICAgICAgUm9vdERpZE5vdENvbXBsZXRlID0gNixcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBOb0NvbnRleHQsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwLFxuICAgICAgTm90U3VzcGVuZGVkID0gMCxcbiAgICAgIFN1c3BlbmRlZE9uRXJyb3IgPSAxLFxuICAgICAgU3VzcGVuZGVkT25EYXRhID0gMixcbiAgICAgIFN1c3BlbmRlZE9uSW1tZWRpYXRlID0gMyxcbiAgICAgIFN1c3BlbmRlZE9uSW5zdGFuY2UgPSA0LFxuICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZSA9IDUsXG4gICAgICBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2UgPSA2LFxuICAgICAgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlID0gNyxcbiAgICAgIFN1c3BlbmRlZE9uSHlkcmF0aW9uID0gOCxcbiAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkLFxuICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSAhMSxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gITEsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSAhMSxcbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290SW5Qcm9ncmVzcyxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gITEsXG4gICAgICBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gMCxcbiAgICAgIEZBTExCQUNLX1RIUk9UVExFX01TID0gMzAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IEluZmluaXR5LFxuICAgICAgUkVOREVSX1RJTUVPVVRfTVMgPSA1MDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gbnVsbCxcbiAgICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbCxcbiAgICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gITEsXG4gICAgICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGwsXG4gICAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IDAsXG4gICAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IDAsXG4gICAgICBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gbnVsbCxcbiAgICAgIE5FU1RFRF9VUERBVEVfTElNSVQgPSA1MCxcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMCxcbiAgICAgIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGwsXG4gICAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMSxcbiAgICAgIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwLFxuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCxcbiAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsLFxuICAgICAgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITEsXG4gICAgICBJTU1FRElBVEVfQ09NTUlUID0gMCxcbiAgICAgIFNVU1BFTkRFRF9DT01NSVQgPSAxLFxuICAgICAgVEhST1RUTEVEX0NPTU1JVCA9IDIsXG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gITE7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZmFrZUFjdENhbGxiYWNrTm9kZSA9IHt9LFxuICAgICAgcmVzb2x2ZUZhbWlseSA9IG51bGwsXG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbiAgICB2YXIgaGFzQmFkTWFwUG9seWZpbGwgPSAhMTtcbiAgICB0cnkge1xuICAgICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgICAgbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgICBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFzQmFkTWFwUG9seWZpbGwgPSAhMDtcbiAgICB9XG4gICAgdmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUgPSB7fTtcbiAgICB2YXIgb3ZlcnJpZGVIb29rU3RhdGUgPSBudWxsLFxuICAgICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IG51bGwsXG4gICAgICBvdmVycmlkZVByb3BzID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gbnVsbCxcbiAgICAgIHNjaGVkdWxlVXBkYXRlID0gbnVsbCxcbiAgICAgIHNldEVycm9ySGFuZGxlciA9IG51bGwsXG4gICAgICBzZXRTdXNwZW5zZUhhbmRsZXIgPSBudWxsO1xuICAgIG92ZXJyaWRlSG9va1N0YXRlID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIGlkID0gZmluZEhvb2soZmliZXIsIGlkKTtcbiAgICAgIG51bGwgIT09IGlkICYmXG4gICAgICAgICgocGF0aCA9IGNvcHlXaXRoU2V0SW1wbChpZC5tZW1vaXplZFN0YXRlLCBwYXRoLCAwLCB2YWx1ZSkpLFxuICAgICAgICAoaWQubWVtb2l6ZWRTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoaWQuYmFzZVN0YXRlID0gcGF0aCksXG4gICAgICAgIChmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKSksXG4gICAgICAgIChwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKSk7XG4gICAgfTtcbiAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoKSB7XG4gICAgICBpZCA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG4gICAgICBudWxsICE9PSBpZCAmJlxuICAgICAgICAoKHBhdGggPSBjb3B5V2l0aERlbGV0ZUltcGwoaWQubWVtb2l6ZWRTdGF0ZSwgcGF0aCwgMCkpLFxuICAgICAgICAoaWQubWVtb2l6ZWRTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoaWQuYmFzZVN0YXRlID0gcGF0aCksXG4gICAgICAgIChmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKSksXG4gICAgICAgIChwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKSk7XG4gICAgfTtcbiAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgICBpZCA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG4gICAgICBudWxsICE9PSBpZCAmJlxuICAgICAgICAoKG9sZFBhdGggPSBjb3B5V2l0aFJlbmFtZShpZC5tZW1vaXplZFN0YXRlLCBvbGRQYXRoLCBuZXdQYXRoKSksXG4gICAgICAgIChpZC5tZW1vaXplZFN0YXRlID0gb2xkUGF0aCksXG4gICAgICAgIChpZC5iYXNlU3RhdGUgPSBvbGRQYXRoKSxcbiAgICAgICAgKGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpKSxcbiAgICAgICAgKG9sZFBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgbnVsbCAhPT0gb2xkUGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIob2xkUGF0aCwgZmliZXIsIDIpKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlUHJvcHMgPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgsIHZhbHVlKSB7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFNldEltcGwoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgMCwgdmFsdWUpO1xuICAgICAgZmliZXIuYWx0ZXJuYXRlICYmIChmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzKTtcbiAgICAgIHBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF0aCwgZmliZXIsIDIpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgpIHtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoRGVsZXRlSW1wbChmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoLCAwKTtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZSAmJiAoZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcyk7XG4gICAgICBwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShcbiAgICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgb2xkUGF0aCxcbiAgICAgICAgbmV3UGF0aFxuICAgICAgKTtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZSAmJiAoZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcyk7XG4gICAgICBvbGRQYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IG9sZFBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKG9sZFBhdGgsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIHNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMik7XG4gICAgfTtcbiAgICBzZXRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkRXJyb3JJbXBsKSB7XG4gICAgICBzaG91bGRFcnJvckltcGwgPSBuZXdTaG91bGRFcnJvckltcGw7XG4gICAgfTtcbiAgICBzZXRTdXNwZW5zZUhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkU3VzcGVuZEltcGwpIHtcbiAgICAgIHNob3VsZFN1c3BlbmRJbXBsID0gbmV3U2hvdWxkU3VzcGVuZEltcGw7XG4gICAgfTtcbiAgICBleHBvcnRzLmF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBpZiAoMTMgPT09IGZpYmVyLnRhZykge1xuICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgNjcxMDg4NjQpO1xuICAgICAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgNjcxMDg4NjQpO1xuICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgNjcxMDg4NjQpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5hdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIGlmICgxMyA9PT0gZmliZXIudGFnKSB7XG4gICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpLFxuICAgICAgICAgIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIGxhbmUpO1xuICAgICAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSk7XG4gICAgICAgIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZmliZXIgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpYmVyLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIHZhciBsYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGZpYmVyLnBlbmRpbmdMYW5lcyk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gbGFuZXMpIHtcbiAgICAgICAgICAgICAgZmliZXIucGVuZGluZ0xhbmVzIHw9IDI7XG4gICAgICAgICAgICAgIGZvciAoZmliZXIuZW50YW5nbGVkTGFuZXMgfD0gMjsgbGFuZXM7ICkge1xuICAgICAgICAgICAgICAgIHZhciBsYW5lID0gMSA8PCAoMzEgLSBjbHozMihsYW5lcykpO1xuICAgICAgICAgICAgICAgIGZpYmVyLmVudGFuZ2xlbWVudHNbMV0gfD0gbGFuZTtcbiAgICAgICAgICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoZmliZXIpO1xuICAgICAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PVxuICAgICAgICAgICAgICAgIE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9XG4gICAgICAgICAgICAgICAgICBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVMpLFxuICAgICAgICAgICAgICAgIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIChsYW5lcyA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbGFuZXMgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGxhbmVzLCBmaWJlciwgMiksXG4gICAgICAgICAgICBmbHVzaFN5bmNXb3JrKCksXG4gICAgICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBhKSB7XG4gICAgICByZXR1cm4gZm4oYSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IENPTVBPTkVOVF9UWVBFLCB2YWx1ZTogY29tcG9uZW50IH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChcbiAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICB0YWcsXG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICBpc1N0cmljdE1vZGUsXG4gICAgICBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzXG4gICAgKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJSb290KFxuICAgICAgICBjb250YWluZXJJbmZvLFxuICAgICAgICB0YWcsXG4gICAgICAgICExLFxuICAgICAgICBudWxsLFxuICAgICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3JzKSB7XG4gICAgICByZXR1cm4geyAkJHR5cGVvZjogSEFTX1BTRVVET19DTEFTU19UWVBFLCB2YWx1ZTogc2VsZWN0b3JzIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lciA9IGZ1bmN0aW9uIChcbiAgICAgIGluaXRpYWxDaGlsZHJlbixcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgIHRhZyxcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcyxcbiAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIGluaXRpYWxDaGlsZHJlbiA9IGNyZWF0ZUZpYmVyUm9vdChcbiAgICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgICAgdGFnLFxuICAgICAgICAhMCxcbiAgICAgICAgaW5pdGlhbENoaWxkcmVuLFxuICAgICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gICAgICAgIGZvcm1TdGF0ZVxuICAgICAgKTtcbiAgICAgIGluaXRpYWxDaGlsZHJlbi5jb250ZXh0ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUobnVsbCk7XG4gICAgICBjb250YWluZXJJbmZvID0gaW5pdGlhbENoaWxkcmVuLmN1cnJlbnQ7XG4gICAgICB0YWcgPSByZXF1ZXN0VXBkYXRlTGFuZShjb250YWluZXJJbmZvKTtcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcyA9IGNyZWF0ZVVwZGF0ZSh0YWcpO1xuICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLmNhbGxiYWNrID1cbiAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJiBudWxsICE9PSBjYWxsYmFjayA/IGNhbGxiYWNrIDogbnVsbDtcbiAgICAgIGVucXVldWVVcGRhdGUoY29udGFpbmVySW5mbywgaHlkcmF0aW9uQ2FsbGJhY2tzLCB0YWcpO1xuICAgICAgaW5pdGlhbENoaWxkcmVuLmN1cnJlbnQubGFuZXMgPSB0YWc7XG4gICAgICBtYXJrUm9vdFVwZGF0ZWQkMShpbml0aWFsQ2hpbGRyZW4sIHRhZyk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoaW5pdGlhbENoaWxkcmVuKTtcbiAgICAgIHJldHVybiBpbml0aWFsQ2hpbGRyZW47XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVBvcnRhbCA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgY29udGFpbmVySW5mbywgaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIHZhciBrZXkgPVxuICAgICAgICAzIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1szXSA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24oa2V5KTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSQ2KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYmXG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIGtleVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgICAga2V5LmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICAgIFwiT2JqZWN0XCJcbiAgICAgICAgKSxcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKGtleSkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgICAgICBrZXk6IG51bGwgPT0ga2V5ID8gbnVsbCA6IFwiXCIgKyBrZXksXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gICAgICB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVSb2xlU2VsZWN0b3IgPSBmdW5jdGlvbiAocm9sZSkge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IFJPTEVfVFlQRSwgdmFsdWU6IHJvbGUgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlVGVzdE5hbWVTZWxlY3RvciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IFRFU1RfTkFNRV9UWVBFLCB2YWx1ZTogaWQgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlVGV4dFNlbGVjdG9yID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBURVhUX1RZUEUsIHZhbHVlOiB0ZXh0IH07XG4gICAgfTtcbiAgICBleHBvcnRzLmRlZmF1bHRPbkNhdWdodEVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWVcbiAgICAgICAgICA/IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudC5cIlxuICAgICAgICAgIDogXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50cy5cIixcbiAgICAgICAgcmVjcmVhdGVNZXNzYWdlID1cbiAgICAgICAgICBcIlJlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoIHVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICtcbiAgICAgICAgICAoKGVycm9yQm91bmRhcnlOYW1lIHx8IFwiQW5vbnltb3VzXCIpICsgXCIuXCIpLFxuICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9XG4gICAgICAgICAgbnVsbCAhPSBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgPyBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgOiBcIlwiO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50U3RhY2s7XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5lbnZpcm9ubWVudE5hbWVcbiAgICAgICAgICA/IGJpbmRUb0NvbnNvbGUoXG4gICAgICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiJW9cXG5cXG4lc1xcblxcbiVzXFxuXCIsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgcmVjcmVhdGVNZXNzYWdlXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGVycm9yLmVudmlyb25tZW50TmFtZVxuICAgICAgICAgICAgKSgpXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVvXFxuXFxuJXNcXG5cXG4lc1xcblwiLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZU1lc3NhZ2UsXG4gICAgICAgICAgICAgIHJlY3JlYXRlTWVzc2FnZVxuICAgICAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2s7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZGVmYXVsdE9uVW5jYXVnaHRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgICBlcnJvciA9IGNvbXBvbmVudE5hbWVcbiAgICAgICAgPyBcIkFuIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudC5cIlxuICAgICAgICA6IFwiQW4gZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50cy5cIjtcbiAgICAgIHZhciBwcmV2R2V0Q3VycmVudFN0YWNrID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9XG4gICAgICAgICAgbnVsbCAhPSBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgPyBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgOiBcIlwiO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50U3RhY2s7XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiJXNcXG5cXG4lc1xcblwiLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIFwiQ29uc2lkZXIgYWRkaW5nIGFuIGVycm9yIGJvdW5kYXJ5IHRvIHlvdXIgdHJlZSB0byBjdXN0b21pemUgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IuXFxuVmlzaXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy5cIlxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuZGVmZXJyZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgzMiksIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksIGZuKClcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuZGlzY3JldGVVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBhLCBiLCBjLCBkKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgyKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLFxuICAgICAgICAgIGZuKGEsIGIsIGMsIGQpXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IG5vdyQxKCkgKyBSRU5ERVJfVElNRU9VVF9NUyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmZpbmRBbGxOb2RlcyA9IGZpbmRBbGxOb2RlcztcbiAgICBleHBvcnRzLmZpbmRCb3VuZGluZ1JlY3RzID0gZnVuY3Rpb24gKGhvc3RSb290LCBzZWxlY3RvcnMpIHtcbiAgICAgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci5cIik7XG4gICAgICBzZWxlY3RvcnMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgICBob3N0Um9vdCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIGhvc3RSb290LnB1c2goZ2V0Qm91bmRpbmdSZWN0KHNlbGVjdG9yc1tpXSkpO1xuICAgICAgZm9yIChzZWxlY3RvcnMgPSBob3N0Um9vdC5sZW5ndGggLSAxOyAwIDwgc2VsZWN0b3JzOyBzZWxlY3RvcnMtLSkge1xuICAgICAgICBpID0gaG9zdFJvb3Rbc2VsZWN0b3JzXTtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgdGFyZ2V0TGVmdCA9IGkueCxcbiAgICAgICAgICAgIHRhcmdldFJpZ2h0ID0gdGFyZ2V0TGVmdCArIGkud2lkdGgsXG4gICAgICAgICAgICB0YXJnZXRUb3AgPSBpLnksXG4gICAgICAgICAgICB0YXJnZXRCb3R0b20gPSB0YXJnZXRUb3AgKyBpLmhlaWdodCxcbiAgICAgICAgICAgIGogPSBzZWxlY3RvcnMgLSAxO1xuICAgICAgICAgIDAgPD0gajtcbiAgICAgICAgICBqLS1cbiAgICAgICAgKVxuICAgICAgICAgIGlmIChzZWxlY3RvcnMgIT09IGopIHtcbiAgICAgICAgICAgIHZhciBvdGhlclJlY3QgPSBob3N0Um9vdFtqXSxcbiAgICAgICAgICAgICAgb3RoZXJMZWZ0ID0gb3RoZXJSZWN0LngsXG4gICAgICAgICAgICAgIG90aGVyUmlnaHQgPSBvdGhlckxlZnQgKyBvdGhlclJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgIG90aGVyVG9wID0gb3RoZXJSZWN0LnksXG4gICAgICAgICAgICAgIG90aGVyQm90dG9tID0gb3RoZXJUb3AgKyBvdGhlclJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID49IG90aGVyTGVmdCAmJlxuICAgICAgICAgICAgICB0YXJnZXRUb3AgPj0gb3RoZXJUb3AgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0UmlnaHQgPD0gb3RoZXJSaWdodCAmJlxuICAgICAgICAgICAgICB0YXJnZXRCb3R0b20gPD0gb3RoZXJCb3R0b21cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBob3N0Um9vdC5zcGxpY2Uoc2VsZWN0b3JzLCAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIHRhcmdldExlZnQgIT09IG90aGVyTGVmdCB8fFxuICAgICAgICAgICAgICAgIGkud2lkdGggIT09IG90aGVyUmVjdC53aWR0aCB8fFxuICAgICAgICAgICAgICAgIG90aGVyQm90dG9tIDwgdGFyZ2V0VG9wIHx8XG4gICAgICAgICAgICAgICAgb3RoZXJUb3AgPiB0YXJnZXRCb3R0b21cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIG90aGVyVG9wID4gdGFyZ2V0VG9wICYmXG4gICAgICAgICAgICAgICAgKChvdGhlclJlY3QuaGVpZ2h0ICs9IG90aGVyVG9wIC0gdGFyZ2V0VG9wKSxcbiAgICAgICAgICAgICAgICAob3RoZXJSZWN0LnkgPSB0YXJnZXRUb3ApKTtcbiAgICAgICAgICAgICAgb3RoZXJCb3R0b20gPCB0YXJnZXRCb3R0b20gJiZcbiAgICAgICAgICAgICAgICAob3RoZXJSZWN0LmhlaWdodCA9IHRhcmdldEJvdHRvbSAtIG90aGVyVG9wKTtcbiAgICAgICAgICAgICAgaG9zdFJvb3Quc3BsaWNlKHNlbGVjdG9ycywgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICB0YXJnZXRUb3AgIT09IG90aGVyVG9wIHx8XG4gICAgICAgICAgICAgICAgaS5oZWlnaHQgIT09IG90aGVyUmVjdC5oZWlnaHQgfHxcbiAgICAgICAgICAgICAgICBvdGhlclJpZ2h0IDwgdGFyZ2V0TGVmdCB8fFxuICAgICAgICAgICAgICAgIG90aGVyTGVmdCA+IHRhcmdldFJpZ2h0XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvdGhlckxlZnQgPiB0YXJnZXRMZWZ0ICYmXG4gICAgICAgICAgICAgICAgKChvdGhlclJlY3Qud2lkdGggKz0gb3RoZXJMZWZ0IC0gdGFyZ2V0TGVmdCksXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC54ID0gdGFyZ2V0TGVmdCkpO1xuICAgICAgICAgICAgICBvdGhlclJpZ2h0IDwgdGFyZ2V0UmlnaHQgJiZcbiAgICAgICAgICAgICAgICAob3RoZXJSZWN0LndpZHRoID0gdGFyZ2V0UmlnaHQgLSBvdGhlckxlZnQpO1xuICAgICAgICAgICAgICBob3N0Um9vdC5zcGxpY2Uoc2VsZWN0b3JzLCAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhvc3RSb290O1xuICAgIH07XG4gICAgZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgdmFyIGZpYmVyID0gY29tcG9uZW50Ll9yZWFjdEludGVybmFscztcbiAgICAgIGlmICh2b2lkIDAgPT09IGZpYmVyKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb21wb25lbnQucmVuZGVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgY29tcG9uZW50ID0gT2JqZWN0LmtleXMoY29tcG9uZW50KS5qb2luKFwiLFwiKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIGNvbXBvbmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29tcG9uZW50ID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGNvbXBvbmVudCA/IG51bGwgOiBnZXRQdWJsaWNJbnN0YW5jZShjb21wb25lbnQuc3RhdGVOb2RlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpO1xuICAgICAgZmliZXIgPVxuICAgICAgICBudWxsICE9PSBmaWJlciA/IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwoZmliZXIpIDogbnVsbDtcbiAgICAgIHJldHVybiBudWxsID09PSBmaWJlciA/IG51bGwgOiBnZXRQdWJsaWNJbnN0YW5jZShmaWJlci5zdGF0ZU5vZGUpO1xuICAgIH07XG4gICAgZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmcgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZmliZXIgPSBjb21wb25lbnQuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZmliZXIpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbXBvbmVudC5yZW5kZXIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgICAgICBjb21wb25lbnQgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oXCIsXCIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkFyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6IFwiICsgY29tcG9uZW50XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb21wb25lbnQgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgICBpZiAobnVsbCA9PT0gY29tcG9uZW50KSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChjb21wb25lbnQubW9kZSAmIDgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAgICgoZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoY29tcG9uZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmaWJlci5tb2RlICYgOFxuICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIiVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4gJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCBpcyBpbnNpZGUgU3RyaWN0TW9kZS4gSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0LmRldi9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZVwiLFxuICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIiVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4gJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCByZW5kZXJzIFN0cmljdE1vZGUgY2hpbGRyZW4uIEluc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGVcIixcbiAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbXBvbmVudC5zdGF0ZU5vZGUpO1xuICAgIH07XG4gICAgZXhwb3J0cy5mbHVzaFBhc3NpdmVFZmZlY3RzID0gZmx1c2hQYXNzaXZlRWZmZWN0cztcbiAgICBleHBvcnRzLmZsdXNoU3luY0Zyb21SZWNvbmNpbGVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSAxO1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKChzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMiksIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksIGZuKSlcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKSxcbiAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0KSxcbiAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuZmx1c2hTeW5jV29yayA9IGZsdXNoU3luY1dvcms7XG4gICAgZXhwb3J0cy5mb2N1c1dpdGhpbiA9IGZ1bmN0aW9uIChob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgaG9zdFJvb3QgPSBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpO1xuICAgICAgc2VsZWN0b3JzID0gZmluZFBhdGhzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgc2VsZWN0b3JzID0gQXJyYXkuZnJvbShzZWxlY3RvcnMpO1xuICAgICAgZm9yIChob3N0Um9vdCA9IDA7IGhvc3RSb290IDwgc2VsZWN0b3JzLmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IHNlbGVjdG9yc1tob3N0Um9vdCsrXSxcbiAgICAgICAgICB0YWcgPSBmaWJlci50YWc7XG4gICAgICAgIGlmICghaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnKSAmJlxuICAgICAgICAgICAgc2V0Rm9jdXNJZkZvY3VzYWJsZShmaWJlci5zdGF0ZU5vZGUpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIGZvciAoZmliZXIgPSBmaWJlci5jaGlsZDsgbnVsbCAhPT0gZmliZXI7IClcbiAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKGZpYmVyKSwgKGZpYmVyID0gZmliZXIuc2libGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGhvc3RSb290LCBzZWxlY3RvcnMpIHtcbiAgICAgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci5cIik7XG4gICAgICB2YXIgbWF4U2VsZWN0b3JJbmRleCA9IDAsXG4gICAgICAgIG1hdGNoZWROYW1lcyA9IFtdO1xuICAgICAgaG9zdFJvb3QgPSBbZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KSwgMF07XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaG9zdFJvb3QubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gaG9zdFJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICAgIHNlbGVjdG9ySW5kZXggPSBob3N0Um9vdFtpbmRleCsrXSxcbiAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcbiAgICAgICAgaWYgKCg1ICE9PSB0YWcgJiYgMjYgIT09IHRhZyAmJiAyNyAhPT0gdGFnKSB8fCAhaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAobWF0Y2hTZWxlY3RvcihmaWJlciwgc2VsZWN0b3IpICYmXG4gICAgICAgICAgICAgIChtYXRjaGVkTmFtZXMucHVzaChzZWxlY3RvclRvU3RyaW5nKHNlbGVjdG9yKSksXG4gICAgICAgICAgICAgIHNlbGVjdG9ySW5kZXgrKyxcbiAgICAgICAgICAgICAgc2VsZWN0b3JJbmRleCA+IG1heFNlbGVjdG9ySW5kZXggJiZcbiAgICAgICAgICAgICAgICAobWF4U2VsZWN0b3JJbmRleCA9IHNlbGVjdG9ySW5kZXgpKSxcbiAgICAgICAgICAgIHNlbGVjdG9ySW5kZXggPCBzZWxlY3RvcnMubGVuZ3RoKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoZmliZXIgPSBmaWJlci5jaGlsZDsgbnVsbCAhPT0gZmliZXI7IClcbiAgICAgICAgICAgICAgaG9zdFJvb3QucHVzaChmaWJlciwgc2VsZWN0b3JJbmRleCksIChmaWJlciA9IGZpYmVyLnNpYmxpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKG1heFNlbGVjdG9ySW5kZXggPCBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgaG9zdFJvb3QgPSBbXTtcbiAgICAgICAgICBtYXhTZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aDtcbiAgICAgICAgICBtYXhTZWxlY3RvckluZGV4KytcbiAgICAgICAgKVxuICAgICAgICAgIGhvc3RSb290LnB1c2goc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcnNbbWF4U2VsZWN0b3JJbmRleF0pKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBcImZpbmRBbGxOb2RlcyB3YXMgYWJsZSB0byBtYXRjaCBwYXJ0IG9mIHRoZSBzZWxlY3RvcjpcXG4gIFwiICtcbiAgICAgICAgICAobWF0Y2hlZE5hbWVzLmpvaW4oXCIgPiBcIikgK1xuICAgICAgICAgICAgXCJcXG5cXG5ObyBtYXRjaGluZyBjb21wb25lbnQgd2FzIGZvdW5kIGZvcjpcXG4gIFwiKSArXG4gICAgICAgICAgaG9zdFJvb3Quam9pbihcIiA+IFwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBleHBvcnRzLmdldFB1YmxpY1Jvb3RJbnN0YW5jZSA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXIuY2hpbGQpIHJldHVybiBudWxsO1xuICAgICAgc3dpdGNoIChjb250YWluZXIuY2hpbGQudGFnKSB7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmluamVjdEludG9EZXZUb29scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbnRlcm5hbHMgPSB7XG4gICAgICAgIGJ1bmRsZVR5cGU6IDEsXG4gICAgICAgIHZlcnNpb246IHJlbmRlcmVyVmVyc2lvbixcbiAgICAgICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogcmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICAgICAgY3VycmVudERpc3BhdGNoZXJSZWY6IFJlYWN0U2hhcmVkSW50ZXJuYWxzLFxuICAgICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSxcbiAgICAgICAgcmVjb25jaWxlclZlcnNpb246IFwiMTkuMC4wXCJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSBleHRyYURldlRvb2xzQ29uZmlnICYmXG4gICAgICAgIChpbnRlcm5hbHMucmVuZGVyZXJDb25maWcgPSBleHRyYURldlRvb2xzQ29uZmlnKTtcbiAgICAgIGludGVybmFscy5vdmVycmlkZUhvb2tTdGF0ZSA9IG92ZXJyaWRlSG9va1N0YXRlO1xuICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDtcbiAgICAgIGludGVybmFscy5vdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVQcm9wcyA9IG92ZXJyaWRlUHJvcHM7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBvdmVycmlkZVByb3BzRGVsZXRlUGF0aDtcbiAgICAgIGludGVybmFscy5vdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoO1xuICAgICAgaW50ZXJuYWxzLnNjaGVkdWxlVXBkYXRlID0gc2NoZWR1bGVVcGRhdGU7XG4gICAgICBpbnRlcm5hbHMuc2V0RXJyb3JIYW5kbGVyID0gc2V0RXJyb3JIYW5kbGVyO1xuICAgICAgaW50ZXJuYWxzLnNldFN1c3BlbnNlSGFuZGxlciA9IHNldFN1c3BlbnNlSGFuZGxlcjtcbiAgICAgIGludGVybmFscy5zY2hlZHVsZVJlZnJlc2ggPSBzY2hlZHVsZVJlZnJlc2g7XG4gICAgICBpbnRlcm5hbHMuc2NoZWR1bGVSb290ID0gc2NoZWR1bGVSb290O1xuICAgICAgaW50ZXJuYWxzLnNldFJlZnJlc2hIYW5kbGVyID0gc2V0UmVmcmVzaEhhbmRsZXI7XG4gICAgICBpbnRlcm5hbHMuZ2V0Q3VycmVudEZpYmVyID0gZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHM7XG4gICAgICBpbnRlcm5hbHMuZ2V0TGFuZUxhYmVsTWFwID0gZ2V0TGFuZUxhYmVsTWFwO1xuICAgICAgaW50ZXJuYWxzLmluamVjdFByb2ZpbGluZ0hvb2tzID0gaW5qZWN0UHJvZmlsaW5nSG9va3M7XG4gICAgICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmlzQWxyZWFkeVJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQ7XG4gICAgfTtcbiAgICBleHBvcnRzLm9ic2VydmVWaXNpYmxlUmVjdHMgPSBmdW5jdGlvbiAoXG4gICAgICBob3N0Um9vdCxcbiAgICAgIHNlbGVjdG9ycyxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgZnVuY3Rpb24gY29tbWl0SG9vaygpIHtcbiAgICAgICAgdmFyIG5leHRJbnN0YW5jZVJvb3RzID0gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgICBpbnN0YW5jZVJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgIDAgPiBuZXh0SW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgJiYgdW5vYnNlcnZlKHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICBuZXh0SW5zdGFuY2VSb290cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAwID4gaW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgJiYgb2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci5cIik7XG4gICAgICB2YXIgaW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgIGNhbGxiYWNrID0gc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlcihpbnN0YW5jZVJvb3RzLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgICB2YXIgZGlzY29ubmVjdCA9IGNhbGxiYWNrLmRpc2Nvbm5lY3QsXG4gICAgICAgIG9ic2VydmUgPSBjYWxsYmFjay5vYnNlcnZlLFxuICAgICAgICB1bm9ic2VydmUgPSBjYWxsYmFjay51bm9ic2VydmU7XG4gICAgICBjb21taXRIb29rcy5wdXNoKGNvbW1pdEhvb2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzY29ubmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGNvbW1pdEhvb2tzLmluZGV4T2YoY29tbWl0SG9vayk7XG4gICAgICAgICAgMCA8PSBpbmRleCAmJiBjb21taXRIb29rcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc2hvdWxkRXJyb3IgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHJldHVybiBzaG91bGRFcnJvckltcGwoZmliZXIpO1xuICAgIH07XG4gICAgZXhwb3J0cy5zaG91bGRTdXNwZW5kID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gc2hvdWxkU3VzcGVuZEltcGwoZmliZXIpO1xuICAgIH07XG4gICAgZXhwb3J0cy5zdGFydEhvc3RUcmFuc2l0aW9uID0gZnVuY3Rpb24gKFxuICAgICAgZm9ybUZpYmVyLFxuICAgICAgcGVuZGluZ1N0YXRlLFxuICAgICAgYWN0aW9uLFxuICAgICAgZm9ybURhdGFcbiAgICApIHtcbiAgICAgIGlmICg1ICE9PSBmb3JtRmliZXIudGFnKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBmb3JtIGluc3RhbmNlIHRvIGJlIGEgSG9zdENvbXBvbmVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHF1ZXVlID0gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKS5xdWV1ZTtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbihcbiAgICAgICAgZm9ybUZpYmVyLFxuICAgICAgICBxdWV1ZSxcbiAgICAgICAgcGVuZGluZ1N0YXRlLFxuICAgICAgICBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgICAgbnVsbCA9PT0gYWN0aW9uXG4gICAgICAgICAgPyBub29wXG4gICAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJyZXF1ZXN0Rm9ybVJlc2V0IHdhcyBjYWxsZWQgb3V0c2lkZSBhIHRyYW5zaXRpb24gb3IgYWN0aW9uLiBUbyBmaXgsIG1vdmUgdG8gYW4gYWN0aW9uLCBvciB3cmFwIHdpdGggc3RhcnRUcmFuc2l0aW9uLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdmFyIHJlc2V0U3RhdGVRdWV1ZSA9XG4gICAgICAgICAgICAgICAgZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKS5uZXh0LnF1ZXVlO1xuICAgICAgICAgICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgICAgICAgICAgZm9ybUZpYmVyLFxuICAgICAgICAgICAgICAgIHJlc2V0U3RhdGVRdWV1ZSxcbiAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmb3JtRmliZXIpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBhY3Rpb24oZm9ybURhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXBkYXRlQ29udGFpbmVyID0gZnVuY3Rpb24gKFxuICAgICAgZWxlbWVudCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50LFxuICAgICAgICBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoY3VycmVudCk7XG4gICAgICB1cGRhdGVDb250YWluZXJJbXBsKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBsYW5lLFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgICByZXR1cm4gbGFuZTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXBkYXRlQ29udGFpbmVyU3luYyA9IHVwZGF0ZUNvbnRhaW5lclN5bmM7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH0pLFxuICAobW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzKSxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSkpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCIkJCRjb25maWciLCJmaW5kSG9vayIsImZpYmVyIiwiaWQiLCJtZW1vaXplZFN0YXRlIiwibmV4dCIsImNvcHlXaXRoU2V0SW1wbCIsIm9iaiIsInBhdGgiLCJpbmRleCIsInZhbHVlIiwibGVuZ3RoIiwia2V5IiwidXBkYXRlZCIsImlzQXJyYXlJbXBsIiwic2xpY2UiLCJhc3NpZ24iLCJjb3B5V2l0aFJlbmFtZSIsIm9sZFBhdGgiLCJuZXdQYXRoIiwiY29uc29sZSIsIndhcm4iLCJpIiwiY29weVdpdGhSZW5hbWVJbXBsIiwib2xkS2V5Iiwic3BsaWNlIiwiY29weVdpdGhEZWxldGVJbXBsIiwic2hvdWxkU3VzcGVuZEltcGwiLCJzaG91bGRFcnJvckltcGwiLCJjcmVhdGVGaWJlciIsInRhZyIsInBlbmRpbmdQcm9wcyIsIm1vZGUiLCJGaWJlck5vZGUiLCJzY2hlZHVsZVJvb3QiLCJyb290IiwiZWxlbWVudCIsImNvbnRleHQiLCJlbXB0eUNvbnRleHRPYmplY3QiLCJ1cGRhdGVDb250YWluZXJTeW5jIiwiZmx1c2hTeW5jV29yayIsInNjaGVkdWxlUmVmcmVzaCIsInVwZGF0ZSIsInJlc29sdmVGYW1pbHkiLCJzdGFsZUZhbWlsaWVzIiwidXBkYXRlZEZhbWlsaWVzIiwiZmx1c2hQYXNzaXZlRWZmZWN0cyIsInNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkiLCJjdXJyZW50Iiwic2V0UmVmcmVzaEhhbmRsZXIiLCJoYW5kbGVyIiwid2FybkludmFsaWRIb29rQWNjZXNzIiwiZXJyb3IiLCJ3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MiLCJub29wIiwid2FybkZvck1pc3NpbmdLZXkiLCJzZXRUb1NvcnRlZFN0cmluZyIsInNldCIsImFycmF5IiwiZm9yRWFjaCIsInB1c2giLCJzb3J0Iiwiam9pbiIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlIiwidHlwZSIsIiQkdHlwZW9mIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSIsImRpc3BsYXlOYW1lIiwibmFtZSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0NPTlNVTUVSX1RZUEUiLCJfY29udGV4dCIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJpbm5lclR5cGUiLCJyZW5kZXIiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJfcGF5bG9hZCIsIl9pbml0IiwieCIsImdldENvbXBvbmVudE5hbWVGcm9tRmliZXIiLCJfZGVidWdJbmZvIiwicmV0dXJuIiwiZGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwibG9nIiwicHJldkluZm8iLCJpbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJncm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsImdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJyZWVuYWJsZUxvZ3MiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInByZWZpeCIsIkVycm9yIiwibWF0Y2giLCJzdGFjayIsInRyaW0iLCJzdWZmaXgiLCJpbmRleE9mIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImZuIiwiY29uc3RydWN0IiwicmVlbnRyeSIsImZyYW1lIiwiY29tcG9uZW50RnJhbWVDYWNoZSIsImdldCIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJIIiwiUnVuSW5Sb290RnJhbWUiLCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJwcm90b3R5cGUiLCJSZWZsZWN0IiwiY29udHJvbCIsImNhbGwiLCJ4JDAiLCJ4JDEiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsImluY2x1ZGVzIiwiX2ZyYW1lIiwicmVwbGFjZSIsImRlc2NyaWJlRmliZXIiLCJnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QiLCJ3b3JrSW5Qcm9ncmVzcyIsImRlYnVnSW5mbyIsImVudHJ5IiwiSlNDb21waWxlcl90ZW1wX2NvbnN0IiwiZW52IiwiSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0IiwibWVzc2FnZSIsImdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYiLCJydW5XaXRoRmliZXJJbkRFViIsImNhbGxiYWNrIiwiYXJnMCIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFyZzQiLCJwcmV2aW91c0ZpYmVyIiwiZ2V0Q3VycmVudFN0YWNrIiwiaXNSZW5kZXJpbmciLCJnZXROZWFyZXN0TW91bnRlZEZpYmVyIiwibm9kZSIsIm5lYXJlc3RNb3VudGVkIiwiYWx0ZXJuYXRlIiwiZmxhZ3MiLCJhc3NlcnRJc01vdW50ZWQiLCJmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCIsImEiLCJiIiwicGFyZW50QSIsInBhcmVudEIiLCJjaGlsZCIsInNpYmxpbmciLCJkaWRGaW5kQ2hpbGQiLCJfY2hpbGQiLCJzdGF0ZU5vZGUiLCJmaW5kQ3VycmVudEhvc3RGaWJlciIsInBhcmVudCIsImZpbmRDdXJyZW50SG9zdEZpYmVySW1wbCIsImZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwiLCJjcmVhdGVDdXJzb3IiLCJkZWZhdWx0VmFsdWUiLCJwb3AiLCJjdXJzb3IiLCJpbmRleCRqc2NvbXAkMCIsImZpYmVyU3RhY2siLCJ2YWx1ZVN0YWNrIiwiY2x6MzJGYWxsYmFjayIsImxvZyQxIiwiTE4yIiwiZ2V0TGFiZWxGb3JMYW5lIiwibGFuZSIsImdldEhpZ2hlc3RQcmlvcml0eUxhbmVzIiwibGFuZXMiLCJwZW5kaW5nU3luY0xhbmVzIiwiZ2V0TmV4dExhbmVzIiwid2lwTGFuZXMiLCJwZW5kaW5nTGFuZXMiLCJuZXh0TGFuZXMiLCJzdXNwZW5kZWRMYW5lcyIsInBpbmdlZExhbmVzIiwid2FybUxhbmVzIiwiZmluaXNoZWRMYW5lcyIsIm5vbklkbGVQZW5kaW5nTGFuZXMiLCJjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nIiwicmVuZGVyTGFuZXMiLCJjb21wdXRlRXhwaXJhdGlvblRpbWUiLCJjdXJyZW50VGltZSIsImNsYWltTmV4dFRyYW5zaXRpb25MYW5lIiwibmV4dFRyYW5zaXRpb25MYW5lIiwiY2xhaW1OZXh0UmV0cnlMYW5lIiwibmV4dFJldHJ5TGFuZSIsImNyZWF0ZUxhbmVNYXAiLCJpbml0aWFsIiwibGFuZU1hcCIsIm1hcmtSb290VXBkYXRlZCQxIiwidXBkYXRlTGFuZSIsIm1hcmtSb290RmluaXNoZWQiLCJyZW1haW5pbmdMYW5lcyIsInNwYXduZWRMYW5lIiwidXBkYXRlZExhbmVzIiwic3VzcGVuZGVkUmV0cnlMYW5lcyIsInByZXZpb3VzbHlQZW5kaW5nTGFuZXMiLCJleHBpcmVkTGFuZXMiLCJlbnRhbmdsZWRMYW5lcyIsImVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzIiwic2hlbGxTdXNwZW5kQ291bnRlciIsImVudGFuZ2xlbWVudHMiLCJleHBpcmF0aW9uVGltZXMiLCJoaWRkZW5VcGRhdGVzIiwiY2x6MzIiLCJoaWRkZW5VcGRhdGVzRm9yTGFuZSIsIm1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lIiwic3Bhd25lZExhbmVJbmRleCIsIm1hcmtSb290RW50YW5nbGVkIiwicm9vdEVudGFuZ2xlZExhbmVzIiwiYWRkRmliZXJUb0xhbmVzTWFwIiwiaXNEZXZUb29sc1ByZXNlbnQiLCJwZW5kaW5nVXBkYXRlcnNMYW5lTWFwIiwiYWRkIiwibW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkIiwibWVtb2l6ZWRVcGRhdGVycyIsInNpemUiLCJoYXMiLCJjbGVhciIsImxhbmVzVG9FdmVudFByaW9yaXR5IiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaG9vayIsImlzRGlzYWJsZWQiLCJzdXBwb3J0c0ZpYmVyIiwicmVuZGVyZXJJRCIsImluamVjdCIsImluamVjdGVkSG9vayIsImVyciIsImNoZWNrRENFIiwib25Db21taXRSb290JDEiLCJldmVudFByaW9yaXR5Iiwib25Db21taXRGaWJlclJvb3QiLCJkaWRFcnJvciIsInNjaGVkdWxlclByaW9yaXR5IiwiSW1tZWRpYXRlUHJpb3JpdHkiLCJVc2VyQmxvY2tpbmdQcmlvcml0eSIsIk5vcm1hbFByaW9yaXR5JDEiLCJJZGxlUHJpb3JpdHkiLCJoYXNMb2dnZWRFcnJvciIsInNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzIiwibmV3SXNTdHJpY3RNb2RlIiwidW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUiLCJzZXRTdHJpY3RNb2RlIiwiaW5qZWN0UHJvZmlsaW5nSG9va3MiLCJwcm9maWxpbmdIb29rcyIsImluamVjdGVkUHJvZmlsaW5nSG9va3MiLCJtYXJrQ29tbWl0U3RvcHBlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkIiwibWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQiLCJtYXJrUmVuZGVyU3RhcnRlZCIsIm1hcmtSZW5kZXJTdG9wcGVkIiwibWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkIiwiaXMiLCJ5IiwiY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIiLCJzb3VyY2UiLCJleGlzdGluZyIsIkNhcHR1cmVkU3RhY2tzIiwicHVzaFRyZWVGb3JrIiwidG90YWxDaGlsZHJlbiIsIndhcm5JZk5vdEh5ZHJhdGluZyIsImZvcmtTdGFjayIsImZvcmtTdGFja0luZGV4IiwidHJlZUZvcmtDb3VudCIsInRyZWVGb3JrUHJvdmlkZXIiLCJwdXNoVHJlZUlkIiwiaWRTdGFjayIsImlkU3RhY2tJbmRleCIsInRyZWVDb250ZXh0SWQiLCJ0cmVlQ29udGV4dE92ZXJmbG93IiwidHJlZUNvbnRleHRQcm92aWRlciIsImJhc2VJZFdpdGhMZWFkaW5nQml0IiwiYmFzZUxlbmd0aCIsIm51bWJlck9mT3ZlcmZsb3dCaXRzIiwidG9TdHJpbmciLCJwdXNoTWF0ZXJpYWxpemVkVHJlZUlkIiwicG9wVHJlZUNvbnRleHQiLCJpc0h5ZHJhdGluZyIsInJlcXVpcmVkQ29udGV4dCIsImMiLCJwdXNoSG9zdENvbnRhaW5lciIsIm5leHRSb290SW5zdGFuY2UiLCJyb290SW5zdGFuY2VTdGFja0N1cnNvciIsImNvbnRleHRGaWJlclN0YWNrQ3Vyc29yIiwiY29udGV4dFN0YWNrQ3Vyc29yIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsImdldEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250ZXh0IiwiaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciIsIm5leHRDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInBvcEhvc3RDb250ZXh0IiwiaXNQcmltYXJ5UmVuZGVyZXIiLCJIb3N0VHJhbnNpdGlvbkNvbnRleHQiLCJfY3VycmVudFZhbHVlIiwiTm90UGVuZGluZ1RyYW5zaXRpb24iLCJfY3VycmVudFZhbHVlMiIsImZpbmROb3RhYmxlTm9kZSIsImluZGVudCIsInNlcnZlclByb3BzIiwic2VydmVyVGFpbCIsImNoaWxkcmVuIiwiZGlzdGFuY2VGcm9tTGVhZiIsImluZGVudGF0aW9uIiwicmVwZWF0IiwiYWRkZWQiLCJyZW1vdmVkIiwiZGVzY3JpYmVGaWJlclR5cGUiLCJkZXNjcmliZVRleHROb2RlIiwiY29udGVudCIsIm1heExlbmd0aCIsIm5lZWRzRXNjYXBpbmciLCJ0ZXN0IiwiSlNPTiIsInN0cmluZ2lmeSIsImRlc2NyaWJlVGV4dERpZmYiLCJjbGllbnRUZXh0IiwiZmlyc3REaWZmIiwiY2hhckNvZGVBdCIsIm9iamVjdE5hbWUiLCJvYmplY3QiLCJtIiwicDAiLCJkZXNjcmliZVZhbHVlIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwicHJvcE5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsImpzb25Qcm9wTmFtZSIsIlN0cmluZyIsImRlc2NyaWJlUHJvcFZhbHVlIiwiZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQiLCJyb3dQcmVmaXgiLCJyZW1haW5pbmdSb3dMZW5ndGgiLCJwcm9wZXJ0aWVzIiwicHJvcFZhbHVlIiwiZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZiIsImNsaWVudE9iamVjdCIsInNlcnZlck9iamVjdCIsInJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMiLCJjbGllbnRQcm9wVmFsdWUiLCJfcHJvcE5hbWUiLCJkZXNjcmliZUVsZW1lbnREaWZmIiwiY2xpZW50UHJvcHMiLCJzZXJ2ZXJQcm9wTmFtZXMiLCJNYXAiLCJwcm9wTmFtZSRqc2NvbXAkMCIsInRvTG93ZXJDYXNlIiwiX3Byb3BOYW1lMiIsIm1heExlbmd0aCRqc2NvbXAkMCIsInNlcnZlclByb3BOYW1lIiwiZGVsZXRlIiwia2V5cyIsImRlc2NyaWJlU2libGluZ0ZpYmVyIiwiZGVzY3JpYmVOb2RlIiwic2tpcFRvTm9kZSIsInNlcnZlckNvbXBvbmVudE5hbWUiLCJkZXNjcmliZURpZmYiLCJyb290Tm9kZSIsImJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUiLCJoeWRyYXRpb25EaWZmUm9vdERFViIsInNpYmxpbmdzIiwid2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UiLCJyZWplY3RlZENhbmRpZGF0ZSIsImRpZFN1c3BlbmRPckVycm9yREVWIiwiZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyIsInRocm93T25IeWRyYXRpb25NaXNtYXRjaCIsImRpZmYiLCJkaWZmUm9vdCIsInF1ZXVlSHlkcmF0aW9uRXJyb3IiLCJIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiIsInByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UiLCJob3N0Q29udGV4dCIsInN1cHBvcnRzSHlkcmF0aW9uIiwiaHlkcmF0ZUluc3RhbmNlIiwibWVtb2l6ZWRQcm9wcyIsInBvcFRvTmV4dEhvc3RQYXJlbnQiLCJoeWRyYXRpb25QYXJlbnRGaWJlciIsInJvb3RPclNpbmdsZXRvbkNvbnRleHQiLCJwb3BIeWRyYXRpb25TdGF0ZSIsInNob3VsZENsZWFyIiwic3VwcG9ydHNTaW5nbGV0b25zIiwic2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsIm5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJkaWZmTm9kZSIsImRlc2NyaXB0aW9uIiwiZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImRlaHlkcmF0ZWQiLCJyZXNldEh5ZHJhdGlvblN0YXRlIiwiaHlkcmF0aW9uRXJyb3JzIiwiZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncyIsImZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMiLCJlbmRJbmRleCIsImNvbmN1cnJlbnRRdWV1ZXNJbmRleCIsImNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyIsImNvbmN1cnJlbnRRdWV1ZXMiLCJxdWV1ZSIsInBlbmRpbmciLCJtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdCIsImVucXVldWVVcGRhdGUkMSIsImVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZSIsImdldFJvb3RGb3JVcGRhdGVkRmliZXIiLCJlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUiLCJzb3VyY2VGaWJlciIsImlzSGlkZGVuIiwiY2hpbGRMYW5lcyIsIl92aXNpYmlsaXR5IiwibmVzdGVkVXBkYXRlQ291bnQiLCJORVNURURfVVBEQVRFX0xJTUlUIiwibmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50Iiwicm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyIsInJvb3RXaXRoTmVzdGVkVXBkYXRlcyIsIk5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCIsIndhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYiLCJwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zIiwicHJldkVmZmVjdER1cmF0aW9uIiwicHJvZmlsZXJFZmZlY3REdXJhdGlvbiIsInBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyIsImVsYXBzZWRUaW1lIiwiYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zIiwic3RhcnRQcm9maWxlclRpbWVyIiwicHJvZmlsZXJTdGFydFRpbWUiLCJub3ciLCJhY3R1YWxTdGFydFRpbWUiLCJzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uIiwiYWN0dWFsRHVyYXRpb24iLCJzZWxmQmFzZUR1cmF0aW9uIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmRJbmNvbXBsZXRlRHVyYXRpb24iLCJyZWNvcmRFZmZlY3REdXJhdGlvbiIsInN0YXJ0RWZmZWN0VGltZXIiLCJ0cmFuc2ZlckFjdHVhbER1cmF0aW9uIiwiZW5zdXJlUm9vdElzU2NoZWR1bGVkIiwibGFzdFNjaGVkdWxlZFJvb3QiLCJmaXJzdFNjaGVkdWxlZFJvb3QiLCJtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsiLCJhY3RRdWV1ZSIsImRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCIsInNjaGVkdWxlSW1tZWRpYXRlVGFzayIsInByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzayIsImRpZFNjaGVkdWxlTWljcm90YXNrIiwiZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwiLCJzeW5jVHJhbnNpdGlvbkxhbmVzIiwib25seUxlZ2FjeSIsImlzRmx1c2hpbmdXb3JrIiwiZGlkUGVyZm9ybVNvbWVXb3JrIiwicGVyZm9ybVN5bmNXb3JrT25Sb290Iiwid29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3QiLCJjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSIsInNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24iLCJub3ckMSIsInByZXYiLCJzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrIiwiZXhwaXJhdGlvblRpbWUiLCJjYWxsYmFja05vZGUiLCJ3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiIsIlN1c3BlbmRlZE9uRGF0YSIsImNhbmNlbFBlbmRpbmdDb21taXQiLCJjYW5jZWxDYWxsYmFjayIsImNhbGxiYWNrUHJpb3JpdHkiLCJmYWtlQWN0Q2FsbGJhY2tOb2RlJDEiLCJwZXJmb3JtV29ya09uUm9vdFZpYVNjaGVkdWxlclRhc2siLCJiaW5kIiwic2NoZWR1bGVDYWxsYmFjayQzIiwiZGlkVGltZW91dCIsIm5lc3RlZFVwZGF0ZVNjaGVkdWxlZCIsImN1cnJlbnRVcGRhdGVJc05lc3RlZCIsIm9yaWdpbmFsQ2FsbGJhY2tOb2RlIiwid29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAiLCJwZXJmb3JtV29ya09uUm9vdCIsImNhbmNlbENhbGxiYWNrJDEiLCJjYiIsInN1cHBvcnRzTWljcm90YXNrcyIsInNjaGVkdWxlTWljcm90YXNrIiwiZXhlY3V0aW9uQ29udGV4dCIsIlJlbmRlckNvbnRleHQiLCJDb21taXRDb250ZXh0IiwiTm9Db250ZXh0IiwicmVxdWVzdFRyYW5zaXRpb25MYW5lIiwiZW50YW5nbGVBc3luY0FjdGlvbiIsInRyYW5zaXRpb24iLCJ0aGVuYWJsZSIsImN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMiLCJlbnRhbmdsZWRMaXN0ZW5lcnMiLCJjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50IiwiY3VycmVudEVudGFuZ2xlZExhbmUiLCJjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUiLCJzdGF0dXMiLCJ0aGVuIiwicmVzb2x2ZSIsInBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUiLCJsaXN0ZW5lcnMiLCJjaGFpblRoZW5hYmxlVmFsdWUiLCJyZXN1bHQiLCJ0aGVuYWJsZVdpdGhPdmVycmlkZSIsInJlYXNvbiIsImluaXRpYWxpemVVcGRhdGVRdWV1ZSIsInVwZGF0ZVF1ZXVlIiwiYmFzZVN0YXRlIiwiZmlyc3RCYXNlVXBkYXRlIiwibGFzdEJhc2VVcGRhdGUiLCJzaGFyZWQiLCJoaWRkZW5DYWxsYmFja3MiLCJjYWxsYmFja3MiLCJjbG9uZVVwZGF0ZVF1ZXVlIiwiY3JlYXRlVXBkYXRlIiwiVXBkYXRlU3RhdGUiLCJwYXlsb2FkIiwiZW5xdWV1ZVVwZGF0ZSIsImN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSIsImRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUiLCJjb21wb25lbnROYW1lIiwiZW50YW5nbGVUcmFuc2l0aW9ucyIsInF1ZXVlTGFuZXMiLCJlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUiLCJjYXB0dXJlZFVwZGF0ZSIsIm5ld0ZpcnN0IiwibmV3TGFzdCIsImNsb25lIiwic3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiIsImRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24iLCJlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSIsInByb2Nlc3NVcGRhdGVRdWV1ZSIsImluc3RhbmNlJGpzY29tcCQwIiwiaGFzRm9yY2VVcGRhdGUiLCJwZW5kaW5nUXVldWUiLCJsYXN0UGVuZGluZ1VwZGF0ZSIsImZpcnN0UGVuZGluZ1VwZGF0ZSIsIm5ld1N0YXRlIiwiaXNIaWRkZW5VcGRhdGUiLCJwYXJ0aWFsU3RhdGUiLCJuZXh0UHJvcHMiLCJpbnN0YW5jZSIsIlJlcGxhY2VTdGF0ZSIsImlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYiLCJuZXh0U3RhdGUiLCJDYXB0dXJlVXBkYXRlIiwiRm9yY2VVcGRhdGUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMiLCJjYWxsQ2FsbGJhY2siLCJjb21taXRIaWRkZW5DYWxsYmFja3MiLCJjb21taXRDYWxsYmFja3MiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsIm9iamVjdElzIiwia2V5c0EiLCJrZXlzQiIsImN1cnJlbnRLZXkiLCJjcmVhdGVUaGVuYWJsZVN0YXRlIiwiZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlIiwidGhlbmFibGVzIiwiaXNUaGVuYWJsZVJlc29sdmVkIiwibm9vcCQxIiwidHJhY2tVc2VkVGhlbmFibGUiLCJ0aGVuYWJsZVN0YXRlIiwiZGlkVXNlUHJvbWlzZSIsInRyYWNrZWRUaGVuYWJsZXMiLCJjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaCIsImZ1bGZpbGxlZFZhbHVlIiwiZnVsZmlsbGVkVGhlbmFibGUiLCJyZWplY3RlZFRoZW5hYmxlIiwic3VzcGVuZGVkVGhlbmFibGUiLCJuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViIsIlN1c3BlbnNlRXhjZXB0aW9uIiwiZ2V0U3VzcGVuZGVkVGhlbmFibGUiLCJyZWplY3RlZFJlYXNvbiIsInB1c2hEZWJ1Z0luZm8iLCJwcmV2aW91c0RlYnVnSW5mbyIsImN1cnJlbnREZWJ1Z0luZm8iLCJjb25jYXQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJyZXR1cm5GaWJlciIsImNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQiLCJlcnJvcmVkS2V5IiwidW53cmFwVGhlbmFibGUiLCJ0aGVuYWJsZUluZGV4Q291bnRlciQxIiwidGhlbmFibGVTdGF0ZSQxIiwiY29lcmNlUmVmIiwicmVmIiwidGhyb3dPbkludmFsaWRPYmplY3RUeXBlIiwibmV3Q2hpbGQiLCJSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFIiwid2Fybk9uRnVuY3Rpb25UeXBlIiwiaW52YWxpZENoaWxkIiwicGFyZW50TmFtZSIsIm93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyIsIndhcm5PblN5bWJvbFR5cGUiLCJvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nIiwiY3JlYXRlQ2hpbGRSZWNvbmNpbGVyIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiY2hpbGRUb0RlbGV0ZSIsImRlbGV0aW9ucyIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJ1c2VGaWJlciIsImNyZWF0ZVdvcmtJblByb2dyZXNzIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJ0ZXh0Q29udGVudCIsImNyZWF0ZUZpYmVyRnJvbVRleHQiLCJfZGVidWdPd25lciIsInVwZGF0ZUVsZW1lbnQiLCJlbGVtZW50VHlwZSIsInVwZGF0ZUZyYWdtZW50IiwiaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nIiwiY2FsbExhenlJbml0SW5ERVYiLCJfb3duZXIiLCJ1cGRhdGVQb3J0YWwiLCJwb3J0YWwiLCJjb250YWluZXJJbmZvIiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJmcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfcHJldkRlYnVnSW5mbyIsInJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24iLCJ1cGRhdGVTbG90Iiwib2xkRmliZXIiLCJ1cGRhdGVGcm9tTWFwIiwibmV3SWR4IiwiX3ByZXZEZWJ1Z0luZm83Iiwid2Fybk9uSW52YWxpZEtleSIsImtub3duS2V5cyIsIlNldCIsInJlY29uY2lsZUNoaWxkcmVuQXJyYXkiLCJuZXdDaGlsZHJlbiIsInJlc3VsdGluZ0ZpcnN0Q2hpbGQiLCJwcmV2aW91c05ld0ZpYmVyIiwibmV4dE9sZEZpYmVyIiwicmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvciIsInN0ZXAiLCJkb25lIiwicmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsIiwicHJldkRlYnVnSW5mbyIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJlbnRyaWVzIiwiZGlkV2FybkFib3V0TWFwcyIsImZpcnN0Q2hpbGRGaWJlciIsInB1c2hIaWRkZW5Db250ZXh0IiwicHJldkVudGFuZ2xlZFJlbmRlckxhbmVzIiwiZW50YW5nbGVkUmVuZGVyTGFuZXMiLCJwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IiLCJjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yIiwiYmFzZUxhbmVzIiwicmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayIsInBvcEhpZGRlbkNvbnRleHQiLCJwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIiLCJzdXNwZW5zZVN0YWNrQ3Vyc29yIiwiU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2siLCJzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciIsInNoZWxsQm91bmRhcnkiLCJwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyIiwicmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrIiwicG9wU3VzcGVuc2VIYW5kbGVyIiwiZmluZEZpcnN0U3VzcGVuZGVkIiwicm93Iiwic3RhdGUiLCJpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nIiwiaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2siLCJyZXZlYWxPcmRlciIsIm1vdW50SG9va1R5cGVzRGV2IiwiaG9va05hbWUiLCJjdXJyZW50SG9va05hbWVJbkRldiIsImhvb2tUeXBlc0RldiIsInVwZGF0ZUhvb2tUeXBlc0RldiIsImhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2IiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSIsImRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudCIsInRhYmxlIiwib2xkSG9va05hbWUiLCJuZXdIb29rTmFtZSIsImNoZWNrRGVwc0FyZUFycmF5RGV2IiwiZGVwcyIsIndhcm5PblVzZUZvcm1TdGF0ZUluRGV2IiwiZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlIiwidGhyb3dJbnZhbGlkSG9va0Vycm9yIiwiYXJlSG9va0lucHV0c0VxdWFsIiwibmV4dERlcHMiLCJwcmV2RGVwcyIsImlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzIiwicmVuZGVyV2l0aEhvb2tzIiwiQ29tcG9uZW50Iiwic2Vjb25kQXJnIiwibmV4dFJlbmRlckxhbmVzIiwiX2RlYnVnSG9va1R5cGVzIiwiZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQiLCJIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWIiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsInNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWIiwiTm9Nb2RlIiwiY2FsbENvbXBvbmVudEluREVWIiwiZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzIiwicmVuZGVyV2l0aEhvb2tzQWdhaW4iLCJmaW5pc2hSZW5kZXJpbmdIb29rcyIsImRlcGVuZGVuY2llcyIsImZpcnN0Q29udGV4dCIsIl9kZWJ1Z1RoZW5hYmxlU3RhdGUiLCJDb250ZXh0T25seURpc3BhdGNoZXIiLCJkaWRSZW5kZXJUb29GZXdIb29rcyIsImN1cnJlbnRIb29rIiwid29ya0luUHJvZ3Jlc3NIb29rIiwiZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSIsInRoZW5hYmxlSW5kZXhDb3VudGVyIiwiZGlkUmVjZWl2ZVVwZGF0ZSIsImNoZWNrSWZDb250ZXh0Q2hhbmdlZCIsImRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoIiwibnVtYmVyT2ZSZVJlbmRlcnMiLCJSRV9SRU5ERVJfTElNSVQiLCJsYXN0RWZmZWN0IiwiZXZlbnRzIiwic3RvcmVzIiwibWVtb0NhY2hlIiwiSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIiwiVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCIsImRpc3BhdGNoZXIiLCJtYXliZVRoZW5hYmxlIiwidXNlU3RhdGUiLCJ1c2VUaGVuYWJsZSIsImNoZWNrRGlkUmVuZGVySWRIb29rIiwiZGlkUmVuZGVySWRIb29rIiwibG9jYWxJZENvdW50ZXIiLCJiYWlsb3V0SG9va3MiLCJyZXNldEhvb2tzT25VbndpbmQiLCJtb3VudFdvcmtJblByb2dyZXNzSG9vayIsImJhc2VRdWV1ZSIsInVwZGF0ZVdvcmtJblByb2dyZXNzSG9vayIsIm5leHRDdXJyZW50SG9vayIsIm5leHRXb3JrSW5Qcm9ncmVzc0hvb2siLCJ1c2UiLCJ1c2FibGUiLCJyZWFkQ29udGV4dCIsInVzZU1lbW9DYWNoZSIsImRhdGEiLCJtYXAiLCJjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwiQXJyYXkiLCJSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMIiwiYmFzaWNTdGF0ZVJlZHVjZXIiLCJhY3Rpb24iLCJtb3VudFJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsImluaXQiLCJpbml0aWFsU3RhdGUiLCJkaXNwYXRjaCIsImxhc3RSZW5kZXJlZFJlZHVjZXIiLCJsYXN0UmVuZGVyZWRTdGF0ZSIsImRpc3BhdGNoUmVkdWNlckFjdGlvbiIsInVwZGF0ZVJlZHVjZXIiLCJ1cGRhdGVSZWR1Y2VySW1wbCIsImJhc2VGaXJzdCIsIm5ld0Jhc2VRdWV1ZUZpcnN0IiwibmV3QmFzZVF1ZXVlTGFzdCIsInJldmVydExhbmUiLCJoYXNFYWdlclN0YXRlIiwiZWFnZXJTdGF0ZSIsInJlcmVuZGVyUmVkdWNlciIsImxhc3RSZW5kZXJQaGFzZVVwZGF0ZSIsIm1vdW50U3luY0V4dGVybmFsU3RvcmUiLCJzdWJzY3JpYmUiLCJnZXRTbmFwc2hvdCIsImdldFNlcnZlclNuYXBzaG90IiwibmV4dFNuYXBzaG90IiwiZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QiLCJwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrIiwibW91bnRFZmZlY3QiLCJzdWJzY3JpYmVUb1N0b3JlIiwicHVzaEVmZmVjdCIsIkhhc0VmZmVjdCIsIlBhc3NpdmUiLCJ1cGRhdGVTdG9yZUluc3RhbmNlIiwiZGVzdHJveSIsInVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlIiwiaXNIeWRyYXRpbmckanNjb21wJDAiLCJjYWNoZWRTbmFwc2hvdCIsImNyZWF0ZSIsInVwZGF0ZUVmZmVjdEltcGwiLCJyZW5kZXJlZFNuYXBzaG90IiwiaW5zdCIsImNoZWNrSWZTbmFwc2hvdENoYW5nZWQiLCJmb3JjZVN0b3JlUmVyZW5kZXIiLCJsYXRlc3RHZXRTbmFwc2hvdCIsIm5leHRWYWx1ZSIsInNjaGVkdWxlVXBkYXRlT25GaWJlciIsIm1vdW50U3RhdGVJbXBsIiwiaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIiLCJtb3VudFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZSIsIm1vdW50T3B0aW1pc3RpYyIsInBhc3N0aHJvdWdoIiwiZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUiLCJ1cGRhdGVPcHRpbWlzdGljIiwidXBkYXRlT3B0aW1pc3RpY0ltcGwiLCJyZXJlbmRlck9wdGltaXN0aWMiLCJkaXNwYXRjaEFjdGlvblN0YXRlIiwiYWN0aW9uUXVldWUiLCJzZXRQZW5kaW5nU3RhdGUiLCJzZXRTdGF0ZSIsImlzUmVuZGVyUGhhc2VVcGRhdGUiLCJhY3Rpb25Ob2RlIiwiaXNUcmFuc2l0aW9uIiwibGlzdGVuZXIiLCJUIiwicnVuQWN0aW9uU3RhdGVBY3Rpb24iLCJwcmV2U3RhdGUiLCJwcmV2VHJhbnNpdGlvbiIsImN1cnJlbnRUcmFuc2l0aW9uIiwiX3VwZGF0ZWRGaWJlcnMiLCJyZXR1cm5WYWx1ZSIsIm9uU3RhcnRUcmFuc2l0aW9uRmluaXNoIiwiUyIsImhhbmRsZUFjdGlvblJldHVyblZhbHVlIiwib25BY3Rpb25FcnJvciIsImVycm9yJDIiLCJvbkFjdGlvblN1Y2Nlc3MiLCJub3RpZnlBY3Rpb25MaXN0ZW5lcnMiLCJsYXN0IiwiYWN0aW9uU3RhdGVSZWR1Y2VyIiwib2xkU3RhdGUiLCJtb3VudEFjdGlvblN0YXRlIiwiaW5pdGlhbFN0YXRlUHJvcCIsInNzckZvcm1TdGF0ZSIsImZvcm1TdGF0ZSIsImlzTWF0Y2hpbmciLCJtYXJrZXJJbnN0YW5jZSIsImNhbkh5ZHJhdGVGb3JtU3RhdGVNYXJrZXIiLCJpc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nIiwidXBkYXRlQWN0aW9uU3RhdGUiLCJzdGF0ZUhvb2siLCJ1cGRhdGVBY3Rpb25TdGF0ZUltcGwiLCJjdXJyZW50U3RhdGVIb29rIiwiYWN0aW9uUXVldWVIb29rIiwiYWN0aW9uU3RhdGVBY3Rpb25FZmZlY3QiLCJyZXJlbmRlckFjdGlvblN0YXRlIiwibW91bnRSZWYiLCJpbml0aWFsVmFsdWUiLCJtb3VudEVmZmVjdEltcGwiLCJmaWJlckZsYWdzIiwiaG9va0ZsYWdzIiwibW91bnRMYXlvdXRFZmZlY3QiLCJMYXlvdXQiLCJpbXBlcmF0aXZlSGFuZGxlRWZmZWN0IiwicmVmQ2xlYW51cCIsIm1vdW50SW1wZXJhdGl2ZUhhbmRsZSIsInVwZGF0ZUltcGVyYXRpdmVIYW5kbGUiLCJtb3VudENhbGxiYWNrIiwidXBkYXRlQ2FsbGJhY2siLCJtb3VudE1lbW8iLCJuZXh0Q3JlYXRlIiwidXBkYXRlTWVtbyIsIm1vdW50RGVmZXJyZWRWYWx1ZSIsIm1vdW50RGVmZXJyZWRWYWx1ZUltcGwiLCJ1cGRhdGVEZWZlcnJlZFZhbHVlIiwidXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwiLCJyZXJlbmRlckRlZmVycmVkVmFsdWUiLCJyZXF1ZXN0RGVmZXJyZWRMYW5lIiwicHJldlZhbHVlIiwic3RhcnRUcmFuc2l0aW9uIiwicGVuZGluZ1N0YXRlIiwiZmluaXNoZWRTdGF0ZSIsInByZXZpb3VzUHJpb3JpdHkiLCJnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJ0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUiLCJkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwiLCJyZXF1ZXN0VXBkYXRlTGFuZSIsImVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsIiwiZm9ybUZpYmVyIiwiZXhpc3RpbmdTdGF0ZUhvb2siLCJpbml0aWFsUmVzZXRTdGF0ZSIsIm1vdW50VHJhbnNpdGlvbiIsInVwZGF0ZVRyYW5zaXRpb24iLCJib29sZWFuT3JUaGVuYWJsZSIsInN0YXJ0IiwicmVyZW5kZXJUcmFuc2l0aW9uIiwidXNlSG9zdFRyYW5zaXRpb25TdGF0dXMiLCJtb3VudElkIiwiaWRlbnRpZmllclByZWZpeCIsInRyZWVJZCIsImlkV2l0aExlYWRpbmdCaXQiLCJnbG9iYWxDbGllbnRJZENvdW50ZXIiLCJtb3VudFJlZnJlc2giLCJyZWZyZXNoQ2FjaGUiLCJzZWVkS2V5IiwicHJvdmlkZXIiLCJjcmVhdGVDYWNoZSIsImNhY2hlIiwiSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwIiwiZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlIiwiZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlIiwiSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AxIiwicHJldkRpc3BhdGNoZXIiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsImN1cnJlbnRTdGF0ZSIsInRocm93SWZEdXJpbmdSZW5kZXIiLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2siLCJhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImN0b3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsImNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50IiwiY2xhc3NDb21wb25lbnRVcGRhdGVyIiwiZW5xdWV1ZVJlcGxhY2VTdGF0ZSIsInJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzIiwiYmFzZVByb3BzIiwiZGVmYXVsdFByb3BzIiwibG9nVW5jYXVnaHRFcnJvciIsImVycm9ySW5mbyIsImVycm9yQm91bmRhcnlOYW1lIiwidGhyb3duRXJyb3JzIiwib25VbmNhdWdodEVycm9yIiwiY29tcG9uZW50U3RhY2siLCJlIiwic2V0VGltZW91dCIsImxvZ0NhdWdodEVycm9yIiwiYm91bmRhcnkiLCJvbkNhdWdodEVycm9yIiwiZXJyb3JCb3VuZGFyeSIsImNyZWF0ZVJvb3RFcnJvclVwZGF0ZSIsImNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUiLCJpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsIm1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCIsImNhbGxDb21wb25lbnREaWRDYXRjaEluREVWIiwidGhyb3dFeGNlcHRpb24iLCJyb290UmVuZGVyTGFuZXMiLCJyZXN0b3JlUGVuZGluZ1VwZGF0ZXJzIiwicHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMiLCJyZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlIiwid29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyIsIlJvb3RJblByb2dyZXNzIiwiUm9vdFN1c3BlbmRlZCIsIm5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSIsImF0dGFjaFBpbmdMaXN0ZW5lciIsInRyYW5zaXRpb25zIiwibWFya2VySW5zdGFuY2VzIiwicmV0cnlRdWV1ZSIsImNhdXNlIiwiUm9vdFN1c3BlbmRlZFdpdGhEZWxheSIsIlJvb3RFcnJvcmVkIiwid29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwibW91bnRDaGlsZEZpYmVycyIsInJlY29uY2lsZUNoaWxkRmliZXJzIiwidXBkYXRlRm9yd2FyZFJlZiIsInByb3BzV2l0aG91dFJlZiIsInByZXBhcmVUb1JlYWRDb250ZXh0IiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsInVwZGF0ZU1lbW9Db21wb25lbnQiLCJzaG91bGRDb25zdHJ1Y3QiLCJjb21wYXJlIiwicmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nIiwidmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2IiwidXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudCIsImNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyIsImNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0IiwicHJldlByb3BzIiwidXBkYXRlRnVuY3Rpb25Db21wb25lbnQiLCJ1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQiLCJuZXh0SXNEZXRhY2hlZCIsIl9wZW5kaW5nVmlzaWJpbGl0eSIsIm1hcmtSZWYiLCJkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudCIsImNhY2hlUG9vbCIsInB1c2hUcmFuc2l0aW9uIiwibmV4dEJhc2VMYW5lcyIsInBlZWtDYWNoZUZyb21Qb29sIiwiQ2FjaGVDb250ZXh0IiwicG9vbCIsImRpZFdhcm5BYm91dEJhZENsYXNzIiwiUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MiLCJyZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyIsImNvbnRleHRUeXBlcyIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlcyIsInJlcGxheUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJjdXJyZW50JGpzY29tcCQwIiwiX2luc3RhbmNlIiwidXBkYXRlciIsImVucXVldWVTZXRTdGF0ZSIsImNvbnRleHRUeXBlIiwiZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlIiwiX3JlYWN0SW50ZXJuYWxzIiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiY29tcG9uZW50V2lsbE1vdW50IiwiX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJuZXdBcGlOYW1lIiwiZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSIsImdldEluaXRpYWxTdGF0ZSIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwiZ2V0RGVmYXVsdFByb3BzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcyIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSIsImdldENoaWxkQ29udGV4dCIsInJlZnMiLCJkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSIsInJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwiY29tcG9uZW50RGlkTW91bnQiLCJ1bnJlc29sdmVkT2xkUHJvcHMiLCJvbGRDb250ZXh0IiwiY2FsbFJlbmRlckluREVWIiwiZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyIsIm1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nIiwiZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCIsIm1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZSIsImdldFN1c3BlbmRlZENhY2hlIiwiZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUiLCJwcmltYXJ5VHJlZURpZERlZmVyIiwid29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUiLCJ1cGRhdGVTdXNwZW5zZUNvbXBvbmVudCIsInNob3dGYWxsYmFjayIsImRpZFN1c3BlbmQiLCJKU0NvbXBpbGVyX3RlbXAiLCJGb3JjZVN1c3BlbnNlRmFsbGJhY2siLCJuZXh0SW5zdGFuY2UiLCJKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAiLCJjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSIsInRyZWVDb250ZXh0Iiwib3ZlcmZsb3ciLCJyZXRyeUxhbmUiLCJmYWxsYmFjayIsIm1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlciIsIlNVU1BFTkRFRF9NQVJLRVIiLCJtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuIiwicmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmciLCJnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMiLCJkaWdlc3QiLCJTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24iLCJyZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5IiwicmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJzdWJ0cmVlRmxhZ3MiLCJwcmltYXJ5Q2hpbGRyZW4iLCJvZmZzY3JlZW5Qcm9wcyIsImNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbiIsInNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlciIsInByb3BhZ2F0aW9uUm9vdCIsInNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgiLCJ2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkIiwiY2hpbGRTbG90IiwiaXNBbkFycmF5IiwiaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlIiwiaXNCYWNrd2FyZHMiLCJ0YWlsIiwibGFzdENvbnRlbnRSb3ciLCJ0YWlsTW9kZSIsInJlbmRlclN0YXRlIiwicmVuZGVyaW5nIiwicmVuZGVyaW5nU3RhcnRUaW1lIiwidXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50IiwiZGlkV2FybkFib3V0UmV2ZWFsT3JkZXIiLCJkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucyIsIl9pIiwiYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUiLCJwdXNoUHJvdmlkZXIiLCJlZmZlY3REdXJhdGlvbiIsInBhc3NpdmVFZmZlY3REdXJhdGlvbiIsImRpZFN1c3BlbmRCZWZvcmUiLCJiZWdpbldvcmsiLCJfZGVidWdOZWVkc1JlbW91bnQiLCJwcmV2U2libGluZyIsInJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZXMiLCJpc0RlaHlkcmF0ZWQiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lciIsInN1cHBvcnRzUmVzb3VyY2VzIiwiZ2V0UmVzb3VyY2UiLCJjcmVhdGVIb2lzdGFibGVJbnN0YW5jZSIsInJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSIsImRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCIsInZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlIiwiY2FuSHlkcmF0ZUluc3RhbmNlIiwidmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlIiwiY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSIsImhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyIiwicG9vbGVkQ2FjaGUiLCJyZXRhaW5DYWNoZSIsInBvb2xlZENhY2hlTGFuZXMiLCJyZXNldENvbnRleHREZXBlbmRlbmNpZXMiLCJsYXN0Q29udGV4dERlcGVuZGVuY3kiLCJjdXJyZW50bHlSZW5kZXJpbmdGaWJlciIsInByb3ZpZGVyRmliZXIiLCJ2YWx1ZUN1cnNvciIsInJlbmRlcmVyQ3Vyc29yREVWIiwiX2N1cnJlbnRSZW5kZXJlciIsInJlbmRlcmVyU2lnaWwiLCJyZW5kZXJlcjJDdXJzb3JERVYiLCJfY3VycmVudFJlbmRlcmVyMiIsInBvcFByb3ZpZGVyIiwiY3VycmVudFZhbHVlIiwiY29udGV4dHMiLCJmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWUiLCJsaXN0IiwibmV4dEZpYmVyIiwiZGVwZW5kZW5jeSIsImlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0IiwiY3VycmVudFBhcmVudCIsImN1cnJlbnREZXBlbmRlbmNpZXMiLCJtZW1vaXplZFZhbHVlIiwicmVhZENvbnRleHRGb3JDb25zdW1lciIsImNvbnN1bWVyIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlckxvY2FsIiwicmVmQ291bnQiLCJzaWduYWwiLCJhYm9ydGVkIiwicmVsZWFzZUNhY2hlIiwic2NoZWR1bGVDYWxsYmFjayQxIiwiTm9ybWFsUHJpb3JpdHkiLCJhYm9ydCIsImNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciIsInJlc3VtZWRDYWNoZSIsIm9mZnNjcmVlbldvcmtJblByb2dyZXNzIiwicHJldkNhY2hlUG9vbCIsImNhY2hlRnJvbVBvb2wiLCJtYXJrVXBkYXRlIiwiZG9lc1JlcXVpcmVDbG9uZSIsImNvbXBsZXRlZFdvcmsiLCJhcHBlbmRBbGxDaGlsZHJlbiIsIm5lZWRzVmlzaWJpbGl0eVRvZ2dsZSIsInN1cHBvcnRzTXV0YXRpb24iLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJzdXBwb3J0c1BlcnNpc3RlbmNlIiwiX25vZGUiLCJjbG9uZUhpZGRlbkluc3RhbmNlIiwiY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UiLCJhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyIiwiY29udGFpbmVyQ2hpbGRTZXQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQiLCJ1cGRhdGVIb3N0Q29udGFpbmVyIiwiY29udGFpbmVyIiwibmV3Q2hpbGRTZXQiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsInBlbmRpbmdDaGlsZHJlbiIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJ1cGRhdGVIb3N0Q29tcG9uZW50IiwiY3VycmVudEluc3RhbmNlIiwiX29sZFByb3BzIiwiY3VycmVudEhvc3RDb250ZXh0IiwiY2xvbmVJbnN0YW5jZSIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwicHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkIiwibWF5U3VzcGVuZENvbW1pdCIsInByZWxvYWRJbnN0YW5jZSIsInNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4iLCJTdXNwZW5zZXlDb21taXRFeGNlcHRpb24iLCJwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQiLCJyZXNvdXJjZSIsIm1heVJlc291cmNlU3VzcGVuZENvbW1pdCIsInByZWxvYWRSZXNvdXJjZSIsInNjaGVkdWxlUmV0cnlFZmZlY3QiLCJ3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMiLCJjdXRPZmZUYWlsSWZOZWVkZWQiLCJoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2siLCJsYXN0VGFpbE5vZGUiLCJfbGFzdFRhaWxOb2RlIiwiYnViYmxlUHJvcGVydGllcyIsImRpZEJhaWxvdXQiLCJuZXdDaGlsZExhbmVzIiwiX3RyZWVCYXNlRHVyYXRpb24iLCJfY2hpbGQyIiwidHJlZUJhc2VEdXJhdGlvbiIsImNvbXBsZXRlV29yayIsInBlbmRpbmdDb250ZXh0IiwicXVldWVSZWNvdmVyYWJsZUVycm9ycyIsIm5leHRSZXNvdXJjZSIsImNyZWF0ZUluc3RhbmNlIiwiY3JlYXRlVGV4dEluc3RhbmNlIiwiZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzIiwiaHlkcmF0ZVRleHRJbnN0YW5jZSIsImh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlIiwicHJlcGFyZVBvcnRhbE1vdW50IiwicmVzZXRXb3JrSW5Qcm9ncmVzcyIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUiLCJ1bndpbmRXb3JrIiwidW53aW5kSW50ZXJydXB0ZWRXb3JrIiwiaW50ZXJydXB0ZWRXb3JrIiwic2hvdWxkUHJvZmlsZSIsImNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzIiwiZmluaXNoZWRXb3JrIiwiY29tbWl0SG9va0VmZmVjdExpc3RNb3VudCIsImNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyIsIm5lYXJlc3RNb3VudGVkQW5jZXN0b3IiLCJjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQiLCJmaXJzdEVmZmVjdCIsIk5vRmxhZ3MiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQiLCJJbnNlcnRpb24iLCJpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QiLCJjYWxsQ3JlYXRlSW5ERVYiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQiLCJhZGRlbmR1bSIsIm4iLCJjYXB0dXJlQ29tbWl0UGhhc2VFcnJvciIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJjYWxsRGVzdHJveUluREVWIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCIsImNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyIsImNvbW1pdENsYXNzQ2FsbGJhY2tzIiwiY2FsbEdldFNuYXBzaG90QmVmb3JlVXBkYXRlcyIsImNvbW1pdENsYXNzU25hcHNob3QiLCJyZXNvbHZlZFByZXZQcm9wcyIsInNuYXBzaG90IiwiZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUiLCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsInNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudEluREVWIiwiY29tbWl0QXR0YWNoUmVmIiwiZ2V0UHVibGljSW5zdGFuY2UiLCJzYWZlbHlBdHRhY2hSZWYiLCJzYWZlbHlEZXRhY2hSZWYiLCJlcnJvciQzIiwiY29tbWl0UHJvZmlsZXIiLCJjb21taXRTdGFydFRpbWUiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUiLCJvbkNvbW1pdCIsIm9uUmVuZGVyIiwiY29tbWl0UHJvZmlsZXJQb3N0Q29tbWl0SW1wbCIsIl9maW5pc2hlZFdvcmskbWVtb2l6ZTIiLCJvblBvc3RDb21taXQiLCJjb21taXRIb3N0TW91bnQiLCJjb21taXRNb3VudCIsImNvbW1pdEhvc3RVcGRhdGUiLCJjb21taXRVcGRhdGUiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIiLCJiZWZvcmUiLCJpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSIsImFwcGVuZENoaWxkVG9Db250YWluZXIiLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsImNvbW1pdFBsYWNlbWVudCIsInBhcmVudEZpYmVyIiwicmVzZXRUZXh0Q29udGVudCIsImNvbW1pdEhvc3RQb3J0YWxDb250YWluZXJDaGlsZHJlbiIsInJlcGxhY2VDb250YWluZXJDaGlsZHJlbiIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyIsImZpcnN0Q2hpbGQiLCJwcmVwYXJlRm9yQ29tbWl0IiwibmV4dEVmZmVjdCIsImNsZWFyQ29udGFpbmVyIiwic2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwiY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlciIsImZpbmlzaGVkUm9vdCIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzIiwiY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYiLCJjYWxsQ29tcG9uZW50RGlkVXBkYXRlSW5ERVYiLCJjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyIsIm9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsIm9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwicHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJyZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzIiwiZGV0YWNoRmliZXJBZnRlckVmZmVjdHMiLCJkZXRhY2hEZWxldGVkSW5zdGFuY2UiLCJyZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzIiwiY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlciIsImRlbGV0ZWRGaWJlciIsIm9uQ29tbWl0RmliZXJVbm1vdW50IiwicmVsZWFzZVJlc291cmNlIiwidW5tb3VudEhvaXN0YWJsZSIsInByZXZIb3N0UGFyZW50IiwiaG9zdFBhcmVudCIsInByZXZIb3N0UGFyZW50SXNDb250YWluZXIiLCJob3N0UGFyZW50SXNDb250YWluZXIiLCJyZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJyZW1vdmVDaGlsZCIsImNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIiLCJjbGVhclN1c3BlbnNlQm91bmRhcnkiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSIsImdldFJldHJ5Q2FjaGUiLCJyZXRyeUNhY2hlIiwiUG9zc2libHlXZWFrU2V0IiwiX3JldHJ5Q2FjaGUiLCJhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzIiwid2FrZWFibGVzIiwid2FrZWFibGUiLCJyZXRyeSIsInJlc29sdmVSZXRyeVdha2VhYmxlIiwiaW5Qcm9ncmVzc0xhbmVzIiwiaW5Qcm9ncmVzc1Jvb3QiLCJjb21taXRNdXRhdGlvbkVmZmVjdHMiLCJjb21taXR0ZWRMYW5lcyIsImNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzIiwicm9vdCRqc2NvbXAkMCIsImNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyIsImhvaXN0YWJsZVJvb3QiLCJjdXJyZW50SG9pc3RhYmxlUm9vdCIsImh5ZHJhdGVIb2lzdGFibGUiLCJtb3VudEhvaXN0YWJsZSIsImFjcXVpcmVSZXNvdXJjZSIsImNsZWFyU2luZ2xldG9uIiwiYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlIiwibmVlZHNGb3JtUmVzZXQiLCJjb21taXRUZXh0VXBkYXRlIiwicHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcyIsImdldEhvaXN0YWJsZVJvb3QiLCJjb21taXRIeWRyYXRlZENvbnRhaW5lciIsInJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyIsImdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUiLCJ3YXNIaWRkZW4iLCJfY3VycmVudCIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzIiwiaGlkZUluc3RhbmNlIiwidW5oaWRlSW5zdGFuY2UiLCJoaWRlVGV4dEluc3RhbmNlIiwidW5oaWRlVGV4dEluc3RhbmNlIiwicmVzZXRGb3JtSW5zdGFuY2UiLCJjb21taXRMYXlvdXRFZmZlY3RzIiwiZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyIsInJlYXBwZWFyTGF5b3V0RWZmZWN0cyIsImluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMiLCJjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzIiwicHJldmlvdXNDYWNoZSIsImNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0IiwicmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMiLCJjb21taXR0ZWRUcmFuc2l0aW9ucyIsImNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIiLCJyZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMiLCJyZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJyZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyIsIl9pbnN0YW5jZTIiLCJmaW5pc2hlZFJvb3QkanNjb21wJDAiLCJyZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQiLCJzdXNwZW5zZXlDb21taXRGbGFnIiwiYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIiLCJzdXNwZW5kUmVzb3VyY2UiLCJzdXNwZW5kSW5zdGFuY2UiLCJwcmV2aW91c0hvaXN0YWJsZVJvb3QiLCJkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMiLCJjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luIiwiY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyIsImRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0IiwiZGVsZXRlZFN1YnRyZWVSb290IiwiZmluZEZpYmVyUm9vdEZvckhvc3RSb290IiwiaG9zdFJvb3QiLCJtYXliZUZpYmVyIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImZpbmRGaWJlclJvb3QiLCJtYXRjaFNlbGVjdG9yIiwiZmliZXIkanNjb21wJDAiLCJzZWxlY3RvciIsIkNPTVBPTkVOVF9UWVBFIiwiSEFTX1BTRVVET19DTEFTU19UWVBFIiwidGFnJGpzY29tcCQwIiwic2VsZWN0b3JJbmRleCIsInNlbGVjdG9yJGpzY29tcCQwIiwiaXNIaWRkZW5TdWJ0cmVlIiwiUk9MRV9UWVBFIiwibWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSIsIlRFWFRfVFlQRSIsImdldFRleHRDb250ZW50IiwiVEVTVF9OQU1FX1RZUEUiLCJzZWxlY3RvclRvU3RyaW5nIiwiZmluZFBhdGhzIiwic2VsZWN0b3JzIiwibWF0Y2hpbmdGaWJlcnMiLCJmaW5kQWxsTm9kZXMiLCJzdXBwb3J0c1Rlc3RTZWxlY3RvcnMiLCJmcm9tIiwib25Db21taXRSb290IiwiY29tbWl0SG9va3MiLCJjb21taXRIb29rIiwiaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQiLCJpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwiLCJJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQiLCJyZXNvbHZlVXBkYXRlUHJpb3JpdHkiLCJzdXNwZW5zZUhhbmRsZXIiLCJpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMiLCJkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzIiwicHJlcGFyZUZyZXNoU3RhY2siLCJtYXJrUm9vdFN1c3BlbmRlZCIsImRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCIsImRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyIiwid2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWIiwid29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMiLCJmb3JjZVN5bmMiLCJzaG91bGRUaW1lU2xpY2UiLCJleGl0U3RhdHVzIiwicmVuZGVyUm9vdENvbmN1cnJlbnQiLCJyZW5kZXJSb290U3luYyIsInJlbmRlcldhc0NvbmN1cnJlbnQiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyIsIlJvb3REaWROb3RDb21wbGV0ZSIsIndvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyIsImlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyIsImVycm9yUmV0cnlMYW5lcyIsImVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCIsIndhc1Jvb3REZWh5ZHJhdGVkIiwid29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyIiwid29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMiLCJSb290RmF0YWxFcnJvcmVkIiwiUm9vdENvbXBsZXRlZCIsImNvbW1pdFJvb3QiLCJ3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zIiwid29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSIsIklNTUVESUFURV9DT01NSVQiLCJGQUxMQkFDS19USFJPVFRMRV9NUyIsInRpbWVvdXRIYW5kbGUiLCJzY2hlZHVsZVRpbWVvdXQiLCJjb21taXRSb290V2hlblJlYWR5IiwiVEhST1RUTEVEX0NPTU1JVCIsImVycm9ycyIsImFwcGx5IiwicmVjb3ZlcmFibGVFcnJvcnMiLCJkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUiLCJkaWRTa2lwU3VzcGVuZGVkU2libGluZ3MiLCJzdXNwZW5kZWRDb21taXRSZWFzb24iLCJjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUiLCJjb21wbGV0ZWRSZW5kZXJFbmRUaW1lIiwic3RhcnRTdXNwZW5kaW5nQ29tbWl0Iiwid2FpdEZvckNvbW1pdFRvQmVSZWFkeSIsIlNVU1BFTkRFRF9DT01NSVQiLCJjaGVjayIsImRpZEF0dGVtcHRFbnRpcmVUcmVlIiwid29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMiLCJyZXNldFdvcmtJblByb2dyZXNzU3RhY2siLCJOb3RTdXNwZW5kZWQiLCJub1RpbWVvdXQiLCJjYW5jZWxUaW1lb3V0Iiwid29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSIsImFsbEVudGFuZ2xlZExhbmVzIiwiZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyIsImhhbmRsZVRocm93IiwidGhyb3duVmFsdWUiLCJTdXNwZW5kZWRPbkltbWVkaWF0ZSIsIlN1c3BlbmRlZE9uSW5zdGFuY2UiLCJTdXNwZW5kZWRPbkh5ZHJhdGlvbiIsIlN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSIsIlN1c3BlbmRlZE9uRXJyb3IiLCJlcnJvcmVkV29yayIsIm1hcmtDb21wb25lbnRFcnJvcmVkIiwiU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlIiwibWFya0NvbXBvbmVudFN1c3BlbmRlZCIsInB1c2hEaXNwYXRjaGVyIiwicHVzaEFzeW5jRGlzcGF0Y2hlciIsInByZXZBc3luY0Rpc3BhdGNoZXIiLCJBIiwiRGVmYXVsdEFzeW5jRGlzcGF0Y2hlciIsInNob3VsZFlpZWxkRm9yUHJlcmVuZGVyaW5nIiwicHJldkV4ZWN1dGlvbkNvbnRleHQiLCJ1bml0T2ZXb3JrIiwidGhyb3dBbmRVbndpbmRXb3JrTG9vcCIsIndvcmtMb29wU3luYyIsInRocm93blZhbHVlJDQiLCJwZXJmb3JtVW5pdE9mV29yayIsIlJFTkRFUl9USU1FT1VUX01TIiwicmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayIsIlN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWUiLCJob3N0RmliZXIiLCJjb21wbGV0ZVVuaXRPZldvcmsiLCJ3b3JrTG9vcENvbmN1cnJlbnQiLCJ0aHJvd25WYWx1ZSQ1IiwibWFya1JlbmRlcllpZWxkZWQiLCJzaG91bGRZaWVsZCIsInJlcGxheUJlZ2luV29yayIsImlzUHJvZmlsaW5nTW9kZSIsInN1c3BlbmRlZFJlYXNvbiIsInVud2luZFVuaXRPZldvcmsiLCJza2lwU2libGluZ3MiLCJwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSIsImNvbW1pdFJvb3RJbXBsIiwicmVuZGVyUHJpb3JpdHlMZXZlbCIsInJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzIiwiZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyIsImZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwibWFya0NvbW1pdFN0YXJ0ZWQiLCJyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyIsInBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzIiwicGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyIsInNjaGVkdWxlQ2FsbGJhY2siLCJyZXNldEFmdGVyQ29tbWl0IiwibWFya0xheW91dEVmZmVjdHNTdGFydGVkIiwibWFya0xheW91dEVmZmVjdHNTdG9wcGVkIiwicmVxdWVzdFBhaW50IiwicGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMiLCJyZWxlYXNlUm9vdFBvb2xlZENhY2hlIiwiY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwib25SZWNvdmVyYWJsZUVycm9yIiwibWFrZUVycm9ySW5mbyIsInJlbmRlclByaW9yaXR5IiwicHJpb3JpdHkiLCJtYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkIiwibWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCIsIm9uUG9zdENvbW1pdEZpYmVyUm9vdCIsImNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290Iiwicm9vdEZpYmVyIiwicGluZ0NhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwidGhyZWFkSURzIiwicGluZ1N1c3BlbmRlZFJvb3QiLCJyZXRyeVRpbWVkT3V0Qm91bmRhcnkiLCJib3VuZGFyeUZpYmVyIiwic3VzcGVuc2VTdGF0ZSIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYiLCJpc0luU3RyaWN0TW9kZSIsImlzU3RyaWN0TW9kZUZpYmVyIiwiZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIiLCJzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyIsImFyZ3VtZW50cyIsImRvdWJsZUludm9rZUVmZmVjdHMiLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50Iiwic2NoZWR1bGluZ0ZpYmVyIiwicHJpb3JpdHlMZXZlbCIsImZha2VBY3RDYWxsYmFja05vZGUiLCJmYW1pbHkiLCJwcmV2VHlwZSIsIm5lZWRzQ29tcGFyZUZhbWlsaWVzIiwiJCR0eXBlb2ZOZXh0VHlwZSIsIldlYWtTZXQiLCJmYWlsZWRCb3VuZGFyaWVzIiwiY2FuZGlkYXRlVHlwZSIsIm5lZWRzUmVuZGVyIiwiaGFzQmFkTWFwUG9seWZpbGwiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsImlzUmVhY3RDb21wb25lbnQiLCJvd25lciIsImZpYmVyVGFnIiwicmVzb2x2ZWRUeXBlIiwiaXNIb3N0SG9pc3RhYmxlVHlwZSIsImlzSG9zdFNpbmdsZXRvblR5cGUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJlbGVtZW50cyIsInByaW1hcnlDaGlsZEluc3RhbmNlIiwiX3BlbmRpbmdNYXJrZXJzIiwiX3RyYW5zaXRpb25zIiwiZGV0YWNoIiwiYXR0YWNoIiwiRmliZXJSb290Tm9kZSIsImh5ZHJhdGUiLCJpbmNvbXBsZXRlVHJhbnNpdGlvbnMiLCJfZGVidWdSb290VHlwZSIsImNyZWF0ZUZpYmVyUm9vdCIsImluaXRpYWxDaGlsZHJlbiIsImh5ZHJhdGlvbkNhbGxiYWNrcyIsImlzU3RyaWN0TW9kZSIsInRyYW5zaXRpb25DYWxsYmFja3MiLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsInVwZGF0ZUNvbnRhaW5lckltcGwiLCJvblNjaGVkdWxlRmliZXJSb290IiwibWFya1JlbmRlclNjaGVkdWxlZCIsImRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMiLCJtYXJrUmV0cnlMYW5lSW1wbCIsIm1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkIiwiZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMiLCJnZXRMYW5lTGFiZWxNYXAiLCJsYWJlbCIsIlJlYWN0IiwicmVxdWlyZSIsIlNjaGVkdWxlciIsIlN5bWJvbCIsImZvciIsIml0ZXJhdG9yIiwiX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFIiwiX19yZWFjdERpc2FibGVkTG9nIiwiV2Vha01hcCIsImlzQXJyYXkiLCJyZW5kZXJlclZlcnNpb24iLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwiZXh0cmFEZXZUb29sc0NvbmZpZyIsIndhcm5zSWZOb3RBY3RpbmciLCJiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIiLCJhZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsInByZXBhcmVTY29wZVVwZGF0ZSIsImdldEluc3RhbmNlRnJvbVNjb3BlIiwicmVzb2x2ZUV2ZW50VHlwZSIsInJlc29sdmVFdmVudFRpbWVTdGFtcCIsInJlcXVlc3RQb3N0UGFpbnRDYWxsYmFjayIsImJpbmRUb0NvbnNvbGUiLCJnZXRCb3VuZGluZ1JlY3QiLCJzZXRGb2N1c0lmRm9jdXNhYmxlIiwic2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlciIsImZyZWV6ZSIsIk1hdGgiLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwidW5zdGFibGVfY2FuY2VsQ2FsbGJhY2siLCJ1bnN0YWJsZV9zaG91bGRZaWVsZCIsInVuc3RhYmxlX3JlcXVlc3RQYWludCIsInVuc3RhYmxlX25vdyIsInVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5IiwidW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkiLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MiLCJwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MiLCJkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzIiwiY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsInNvcnRlZE5hbWVzIiwicGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCIsInN0cmljdFJvb3QiLCJmaWJlckFycmF5IiwiZmlyc3RGaWJlciIsInVuaXF1ZU5hbWVzIiwiY2FsbENvbXBvbmVudCIsIndhc1JlbmRlcmluZyIsImNhbGxSZW5kZXIiLCJjYWxsQ29tcG9uZW50RGlkTW91bnQiLCJjYWxsQ29tcG9uZW50RGlkVXBkYXRlIiwiY2FsbENvbXBvbmVudERpZENhdGNoIiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50IiwiY2FsbENyZWF0ZSIsImVmZmVjdCIsImNhbGxEZXN0cm95IiwiY2FsbExhenlJbml0IiwibGF6eSIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsIl9zdG9yZSIsInZhbGlkYXRlZCIsImNvbXBvbmVudEtleSIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyQXBwZW5kaXgiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZHVjZXIiLCJ1c2VSZWYiLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlRGVmZXJyZWRWYWx1ZSIsInVzZVRyYW5zaXRpb24iLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZUlkIiwidXNlQ2FjaGVSZWZyZXNoIiwidXNlRm9ybVN0YXRlIiwidXNlQWN0aW9uU3RhdGUiLCJ1c2VPcHRpbWlzdGljIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJpc01vdW50ZWQiLCJjb21wb25lbnQiLCJfd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJtYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQiLCJyZXBvcnRHbG9iYWxFcnJvciIsInJlcG9ydEVycm9yIiwid2luZG93IiwiRXJyb3JFdmVudCIsImV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJkaXNwYXRjaEV2ZW50IiwicHJvY2VzcyIsImVtaXQiLCJBYm9ydENvbnRyb2xsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiQ29uc3VtZXIiLCJQcm92aWRlciIsIl90aHJlYWRDb3VudCIsInByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCIsImdldENhY2hlRm9yVHlwZSIsInJlc291cmNlVHlwZSIsImNhY2hlRm9yVHlwZSIsImdldE93bmVyIiwic3ltYm9sRm9yIiwiSW5maW5pdHkiLCJub25FeHRlbnNpYmxlT2JqZWN0IiwiZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUiLCJvdmVycmlkZUhvb2tTdGF0ZSIsIm92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCIsIm92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCIsIm92ZXJyaWRlUHJvcHMiLCJvdmVycmlkZVByb3BzRGVsZXRlUGF0aCIsIm92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoIiwic2NoZWR1bGVVcGRhdGUiLCJzZXRFcnJvckhhbmRsZXIiLCJzZXRTdXNwZW5zZUhhbmRsZXIiLCJuZXdTaG91bGRFcnJvckltcGwiLCJuZXdTaG91bGRTdXNwZW5kSW1wbCIsImF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uIiwiYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5IiwiYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uIiwiYmF0Y2hlZFVwZGF0ZXMiLCJjcmVhdGVDb21wb25lbnRTZWxlY3RvciIsImNyZWF0ZUNvbnRhaW5lciIsImNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUiLCJjcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yIiwiY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyIiwiY3JlYXRlUG9ydGFsIiwiZSQ2IiwidG9TdHJpbmdUYWciLCJjcmVhdGVSb2xlU2VsZWN0b3IiLCJyb2xlIiwiY3JlYXRlVGVzdE5hbWVTZWxlY3RvciIsImNyZWF0ZVRleHRTZWxlY3RvciIsInRleHQiLCJkZWZhdWx0T25DYXVnaHRFcnJvciIsImNvbXBvbmVudE5hbWVNZXNzYWdlIiwicmVjcmVhdGVNZXNzYWdlIiwicHJldkdldEN1cnJlbnRTdGFjayIsImVudmlyb25tZW50TmFtZSIsImRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IiLCJkZWZhdWx0T25VbmNhdWdodEVycm9yIiwiZGVmZXJyZWRVcGRhdGVzIiwiZGlzY3JldGVVcGRhdGVzIiwiZCIsImZpbmRCb3VuZGluZ1JlY3RzIiwidGFyZ2V0TGVmdCIsInRhcmdldFJpZ2h0Iiwid2lkdGgiLCJ0YXJnZXRUb3AiLCJ0YXJnZXRCb3R0b20iLCJoZWlnaHQiLCJqIiwib3RoZXJSZWN0Iiwib3RoZXJMZWZ0Iiwib3RoZXJSaWdodCIsIm90aGVyVG9wIiwib3RoZXJCb3R0b20iLCJmaW5kSG9zdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMiLCJmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmciLCJtZXRob2ROYW1lIiwiZmx1c2hTeW5jRnJvbVJlY29uY2lsZXIiLCJmb2N1c1dpdGhpbiIsImdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiIsIm1heFNlbGVjdG9ySW5kZXgiLCJtYXRjaGVkTmFtZXMiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJpbmplY3RJbnRvRGV2VG9vbHMiLCJidW5kbGVUeXBlIiwidmVyc2lvbiIsImN1cnJlbnREaXNwYXRjaGVyUmVmIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJyZWNvbmNpbGVyVmVyc2lvbiIsInJlbmRlcmVyQ29uZmlnIiwiZ2V0Q3VycmVudEZpYmVyIiwiaXNBbHJlYWR5UmVuZGVyaW5nIiwib2JzZXJ2ZVZpc2libGVSZWN0cyIsIm9wdGlvbnMiLCJuZXh0SW5zdGFuY2VSb290cyIsImluc3RhbmNlUm9vdHMiLCJ0YXJnZXQiLCJ1bm9ic2VydmUiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsInNob3VsZEVycm9yIiwic2hvdWxkU3VzcGVuZCIsInN0YXJ0SG9zdFRyYW5zaXRpb24iLCJmb3JtRGF0YSIsInJlc2V0U3RhdGVRdWV1ZSIsInVwZGF0ZUNvbnRhaW5lciIsImRlZmF1bHQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-reconciler/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/react-reconciler/constants.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(app-pages-browser)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsZ01BQTJFO0FBQzdFIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-reconciler/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-reconciler/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-reconciler/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(app-pages-browser)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw0S0FBaUU7QUFDbkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-reconciler/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-use-measure/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/react-use-measure/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ j)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction g(n,t){let o;return(...i)=>{window.clearTimeout(o),o=window.setTimeout(()=>n(...i),t)}}function j({debounce:n,scroll:t,polyfill:o,offsetSize:i}={debounce:0,scroll:!1,offsetSize:!1}){const a=o||(typeof window==\"undefined\"?class{}:window.ResizeObserver);if(!a)throw new Error(\"This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills\");const[c,h]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),e=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({element:null,scrollContainers:null,resizeObserver:null,lastBounds:c,orientationHandler:null}),d=n?typeof n==\"number\"?n:n.scroll:null,f=n?typeof n==\"number\"?n:n.resize:null,w=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1);(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>(w.current=!0,()=>void(w.current=!1)));const[z,m,s]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{const r=()=>{if(!e.current.element)return;const{left:y,top:C,width:H,height:O,bottom:S,right:x,x:B,y:R}=e.current.element.getBoundingClientRect(),l={left:y,top:C,width:H,height:O,bottom:S,right:x,x:B,y:R};e.current.element instanceof HTMLElement&&i&&(l.height=e.current.element.offsetHeight,l.width=e.current.element.offsetWidth),Object.freeze(l),w.current&&!D(e.current.lastBounds,l)&&h(e.current.lastBounds=l)};return[r,f?g(r,f):r,d?g(r,d):r]},[h,i,d,f]);function v(){e.current.scrollContainers&&(e.current.scrollContainers.forEach(r=>r.removeEventListener(\"scroll\",s,!0)),e.current.scrollContainers=null),e.current.resizeObserver&&(e.current.resizeObserver.disconnect(),e.current.resizeObserver=null),e.current.orientationHandler&&(\"orientation\"in screen&&\"removeEventListener\"in screen.orientation?screen.orientation.removeEventListener(\"change\",e.current.orientationHandler):\"onorientationchange\"in window&&window.removeEventListener(\"orientationchange\",e.current.orientationHandler))}function b(){e.current.element&&(e.current.resizeObserver=new a(s),e.current.resizeObserver.observe(e.current.element),t&&e.current.scrollContainers&&e.current.scrollContainers.forEach(r=>r.addEventListener(\"scroll\",s,{capture:!0,passive:!0})),e.current.orientationHandler=()=>{s()},\"orientation\"in screen&&\"addEventListener\"in screen.orientation?screen.orientation.addEventListener(\"change\",e.current.orientationHandler):\"onorientationchange\"in window&&window.addEventListener(\"orientationchange\",e.current.orientationHandler))}const L=r=>{!r||r===e.current.element||(v(),e.current.element=r,e.current.scrollContainers=E(r),b())};return X(s,!!t),W(m),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{v(),b()},[t,s,m]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>v,[]),[L,c,z]}function W(n){(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{const t=n;return window.addEventListener(\"resize\",t),()=>void window.removeEventListener(\"resize\",t)},[n])}function X(n,t){(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{if(t){const o=n;return window.addEventListener(\"scroll\",o,{capture:!0,passive:!0}),()=>void window.removeEventListener(\"scroll\",o,!0)}},[n,t])}function E(n){const t=[];if(!n||n===document.body)return t;const{overflow:o,overflowX:i,overflowY:a}=window.getComputedStyle(n);return[o,i,a].some(c=>c===\"auto\"||c===\"scroll\")&&t.push(n),[...t,...E(n.parentElement)]}const k=[\"x\",\"y\",\"top\",\"bottom\",\"left\",\"right\",\"width\",\"height\"],D=(n,t)=>k.every(o=>n[o]===t[o]);\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC11c2UtbWVhc3VyZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlFLGdCQUFnQixNQUFNLGVBQWUsMkRBQTJELFlBQVksNENBQTRDLEVBQUUsbUNBQW1DLEVBQUUsOENBQThDLHdCQUF3Qix3S0FBd0ssV0FBVywrQ0FBQyxFQUFFLHVEQUF1RCxJQUFJLDZDQUFDLEVBQUUsNEZBQTRGLGtGQUFrRiw2Q0FBQyxLQUFLLGdEQUFDLDRDQUE0QyxhQUFhLDhDQUFDLE1BQU0sYUFBYSw2QkFBNkIsTUFBTSx1REFBdUQsOENBQThDLHdEQUF3RCxnTkFBZ04sZ0NBQWdDLFlBQVksYUFBYSx3Z0JBQXdnQixhQUFhLDhNQUE4TSxzQkFBc0IscUNBQXFDLElBQUksdVBBQXVQLFlBQVksMEZBQTBGLHFCQUFxQixnREFBQyxNQUFNLFFBQVEsVUFBVSxnREFBQyxtQkFBbUIsY0FBYyxnREFBQyxNQUFNLFVBQVUsMkZBQTJGLE1BQU0sZ0JBQWdCLGdEQUFDLE1BQU0sTUFBTSxVQUFVLDJDQUEyQyxzQkFBc0Isc0RBQXNELFFBQVEsY0FBYyxXQUFXLGtDQUFrQyxNQUFNLG1DQUFtQyw0QkFBNEIsd0ZBQXdGLGtHQUF1SDtBQUNua0ciLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9yZWFjdC11c2UtbWVhc3VyZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHt1c2VTdGF0ZSBhcyBULHVzZVJlZiBhcyBwLHVzZUVmZmVjdCBhcyB1LHVzZU1lbW8gYXMgTX1mcm9tXCJyZWFjdFwiO2Z1bmN0aW9uIGcobix0KXtsZXQgbztyZXR1cm4oLi4uaSk9Pnt3aW5kb3cuY2xlYXJUaW1lb3V0KG8pLG89d2luZG93LnNldFRpbWVvdXQoKCk9Pm4oLi4uaSksdCl9fWZ1bmN0aW9uIGooe2RlYm91bmNlOm4sc2Nyb2xsOnQscG9seWZpbGw6byxvZmZzZXRTaXplOml9PXtkZWJvdW5jZTowLHNjcm9sbDohMSxvZmZzZXRTaXplOiExfSl7Y29uc3QgYT1vfHwodHlwZW9mIHdpbmRvdz09XCJ1bmRlZmluZWRcIj9jbGFzc3t9OndpbmRvdy5SZXNpemVPYnNlcnZlcik7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgUmVzaXplT2JzZXJ2ZXIgb3V0IG9mIHRoZSBib3guIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LXNwcmluZy9yZWFjdC11c2UtbWVhc3VyZS8jcmVzaXplLW9ic2VydmVyLXBvbHlmaWxsc1wiKTtjb25zdFtjLGhdPVQoe2xlZnQ6MCx0b3A6MCx3aWR0aDowLGhlaWdodDowLGJvdHRvbTowLHJpZ2h0OjAseDowLHk6MH0pLGU9cCh7ZWxlbWVudDpudWxsLHNjcm9sbENvbnRhaW5lcnM6bnVsbCxyZXNpemVPYnNlcnZlcjpudWxsLGxhc3RCb3VuZHM6YyxvcmllbnRhdGlvbkhhbmRsZXI6bnVsbH0pLGQ9bj90eXBlb2Ygbj09XCJudW1iZXJcIj9uOm4uc2Nyb2xsOm51bGwsZj1uP3R5cGVvZiBuPT1cIm51bWJlclwiP246bi5yZXNpemU6bnVsbCx3PXAoITEpO3UoKCk9Pih3LmN1cnJlbnQ9ITAsKCk9PnZvaWQody5jdXJyZW50PSExKSkpO2NvbnN0W3osbSxzXT1NKCgpPT57Y29uc3Qgcj0oKT0+e2lmKCFlLmN1cnJlbnQuZWxlbWVudClyZXR1cm47Y29uc3R7bGVmdDp5LHRvcDpDLHdpZHRoOkgsaGVpZ2h0Ok8sYm90dG9tOlMscmlnaHQ6eCx4OkIseTpSfT1lLmN1cnJlbnQuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxsPXtsZWZ0OnksdG9wOkMsd2lkdGg6SCxoZWlnaHQ6Tyxib3R0b206UyxyaWdodDp4LHg6Qix5OlJ9O2UuY3VycmVudC5lbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJmkmJihsLmhlaWdodD1lLmN1cnJlbnQuZWxlbWVudC5vZmZzZXRIZWlnaHQsbC53aWR0aD1lLmN1cnJlbnQuZWxlbWVudC5vZmZzZXRXaWR0aCksT2JqZWN0LmZyZWV6ZShsKSx3LmN1cnJlbnQmJiFEKGUuY3VycmVudC5sYXN0Qm91bmRzLGwpJiZoKGUuY3VycmVudC5sYXN0Qm91bmRzPWwpfTtyZXR1cm5bcixmP2cocixmKTpyLGQ/ZyhyLGQpOnJdfSxbaCxpLGQsZl0pO2Z1bmN0aW9uIHYoKXtlLmN1cnJlbnQuc2Nyb2xsQ29udGFpbmVycyYmKGUuY3VycmVudC5zY3JvbGxDb250YWluZXJzLmZvckVhY2gocj0+ci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIscywhMCkpLGUuY3VycmVudC5zY3JvbGxDb250YWluZXJzPW51bGwpLGUuY3VycmVudC5yZXNpemVPYnNlcnZlciYmKGUuY3VycmVudC5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCksZS5jdXJyZW50LnJlc2l6ZU9ic2VydmVyPW51bGwpLGUuY3VycmVudC5vcmllbnRhdGlvbkhhbmRsZXImJihcIm9yaWVudGF0aW9uXCJpbiBzY3JlZW4mJlwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiaW4gc2NyZWVuLm9yaWVudGF0aW9uP3NjcmVlbi5vcmllbnRhdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZS5jdXJyZW50Lm9yaWVudGF0aW9uSGFuZGxlcik6XCJvbm9yaWVudGF0aW9uY2hhbmdlXCJpbiB3aW5kb3cmJndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIixlLmN1cnJlbnQub3JpZW50YXRpb25IYW5kbGVyKSl9ZnVuY3Rpb24gYigpe2UuY3VycmVudC5lbGVtZW50JiYoZS5jdXJyZW50LnJlc2l6ZU9ic2VydmVyPW5ldyBhKHMpLGUuY3VycmVudC5yZXNpemVPYnNlcnZlci5vYnNlcnZlKGUuY3VycmVudC5lbGVtZW50KSx0JiZlLmN1cnJlbnQuc2Nyb2xsQ29udGFpbmVycyYmZS5jdXJyZW50LnNjcm9sbENvbnRhaW5lcnMuZm9yRWFjaChyPT5yLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixzLHtjYXB0dXJlOiEwLHBhc3NpdmU6ITB9KSksZS5jdXJyZW50Lm9yaWVudGF0aW9uSGFuZGxlcj0oKT0+e3MoKX0sXCJvcmllbnRhdGlvblwiaW4gc2NyZWVuJiZcImFkZEV2ZW50TGlzdGVuZXJcImluIHNjcmVlbi5vcmllbnRhdGlvbj9zY3JlZW4ub3JpZW50YXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUuY3VycmVudC5vcmllbnRhdGlvbkhhbmRsZXIpOlwib25vcmllbnRhdGlvbmNoYW5nZVwiaW4gd2luZG93JiZ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsZS5jdXJyZW50Lm9yaWVudGF0aW9uSGFuZGxlcikpfWNvbnN0IEw9cj0+eyFyfHxyPT09ZS5jdXJyZW50LmVsZW1lbnR8fCh2KCksZS5jdXJyZW50LmVsZW1lbnQ9cixlLmN1cnJlbnQuc2Nyb2xsQ29udGFpbmVycz1FKHIpLGIoKSl9O3JldHVybiBYKHMsISF0KSxXKG0pLHUoKCk9Pnt2KCksYigpfSxbdCxzLG1dKSx1KCgpPT52LFtdKSxbTCxjLHpdfWZ1bmN0aW9uIFcobil7dSgoKT0+e2NvbnN0IHQ9bjtyZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0KSwoKT0+dm9pZCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHQpfSxbbl0pfWZ1bmN0aW9uIFgobix0KXt1KCgpPT57aWYodCl7Y29uc3Qgbz1uO3JldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLG8se2NhcHR1cmU6ITAscGFzc2l2ZTohMH0pLCgpPT52b2lkIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsbywhMCl9fSxbbix0XSl9ZnVuY3Rpb24gRShuKXtjb25zdCB0PVtdO2lmKCFufHxuPT09ZG9jdW1lbnQuYm9keSlyZXR1cm4gdDtjb25zdHtvdmVyZmxvdzpvLG92ZXJmbG93WDppLG92ZXJmbG93WTphfT13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuKTtyZXR1cm5bbyxpLGFdLnNvbWUoYz0+Yz09PVwiYXV0b1wifHxjPT09XCJzY3JvbGxcIikmJnQucHVzaChuKSxbLi4udCwuLi5FKG4ucGFyZW50RWxlbWVudCldfWNvbnN0IGs9W1wieFwiLFwieVwiLFwidG9wXCIsXCJib3R0b21cIixcImxlZnRcIixcInJpZ2h0XCIsXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdLEQ9KG4sdCk9PmsuZXZlcnkobz0+bltvXT09PXRbb10pO2V4cG9ydHtqIGFzIGRlZmF1bHR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-use-measure/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function performWorkUntilDeadline() {\n      if (isMessageLoopRunning) {\n        var currentTime = exports.unstable_now();\n        startTime = currentTime;\n        var hasMoreWork = !0;\n        try {\n          a: {\n            isHostCallbackScheduled = !1;\n            isHostTimeoutScheduled &&\n              ((isHostTimeoutScheduled = !1),\n              localClearTimeout(taskTimeoutID),\n              (taskTimeoutID = -1));\n            isPerformingWork = !0;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n              b: {\n                advanceTimers(currentTime);\n                for (\n                  currentTask = peek(taskQueue);\n                  null !== currentTask &&\n                  !(\n                    currentTask.expirationTime > currentTime &&\n                    shouldYieldToHost()\n                  );\n\n                ) {\n                  var callback = currentTask.callback;\n                  if (\"function\" === typeof callback) {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var continuationCallback = callback(\n                      currentTask.expirationTime <= currentTime\n                    );\n                    currentTime = exports.unstable_now();\n                    if (\"function\" === typeof continuationCallback) {\n                      currentTask.callback = continuationCallback;\n                      advanceTimers(currentTime);\n                      hasMoreWork = !0;\n                      break b;\n                    }\n                    currentTask === peek(taskQueue) && pop(taskQueue);\n                    advanceTimers(currentTime);\n                  } else pop(taskQueue);\n                  currentTask = peek(taskQueue);\n                }\n                if (null !== currentTask) hasMoreWork = !0;\n                else {\n                  var firstTimer = peek(timerQueue);\n                  null !== firstTimer &&\n                    requestHostTimeout(\n                      handleTimeout,\n                      firstTimer.startTime - currentTime\n                    );\n                  hasMoreWork = !1;\n                }\n              }\n              break a;\n            } finally {\n              (currentTask = null),\n                (currentPriorityLevel = previousPriorityLevel),\n                (isPerformingWork = !1);\n            }\n            hasMoreWork = void 0;\n          }\n        } finally {\n          hasMoreWork\n            ? schedulePerformWorkUntilDeadline()\n            : (isMessageLoopRunning = !1);\n        }\n      }\n    }\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      a: for (; 0 < index; ) {\n        var parentIndex = (index - 1) >>> 1,\n          parent = heap[parentIndex];\n        if (0 < compare(parent, node))\n          (heap[parentIndex] = node),\n            (heap[index] = parent),\n            (index = parentIndex);\n        else break a;\n      }\n    }\n    function peek(heap) {\n      return 0 === heap.length ? null : heap[0];\n    }\n    function pop(heap) {\n      if (0 === heap.length) return null;\n      var first = heap[0],\n        last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        a: for (\n          var index = 0, length = heap.length, halfLength = length >>> 1;\n          index < halfLength;\n\n        ) {\n          var leftIndex = 2 * (index + 1) - 1,\n            left = heap[leftIndex],\n            rightIndex = leftIndex + 1,\n            right = heap[rightIndex];\n          if (0 > compare(left, last))\n            rightIndex < length && 0 > compare(right, left)\n              ? ((heap[index] = right),\n                (heap[rightIndex] = last),\n                (index = rightIndex))\n              : ((heap[index] = left),\n                (heap[leftIndex] = last),\n                (index = leftIndex));\n          else if (rightIndex < length && 0 > compare(right, last))\n            (heap[index] = right),\n              (heap[rightIndex] = last),\n              (index = rightIndex);\n          else break a;\n        }\n      }\n      return first;\n    }\n    function compare(a, b) {\n      var diff = a.sortIndex - b.sortIndex;\n      return 0 !== diff ? diff : a.id - b.id;\n    }\n    function advanceTimers(currentTime) {\n      for (var timer = peek(timerQueue); null !== timer; ) {\n        if (null === timer.callback) pop(timerQueue);\n        else if (timer.startTime <= currentTime)\n          pop(timerQueue),\n            (timer.sortIndex = timer.expirationTime),\n            push(taskQueue, timer);\n        else break;\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = !1;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled)\n        if (null !== peek(taskQueue))\n          (isHostCallbackScheduled = !0), requestHostCallback();\n        else {\n          var firstTimer = peek(timerQueue);\n          null !== firstTimer &&\n            requestHostTimeout(\n              handleTimeout,\n              firstTimer.startTime - currentTime\n            );\n        }\n    }\n    function shouldYieldToHost() {\n      return exports.unstable_now() - startTime < frameInterval ? !1 : !0;\n    }\n    function requestHostCallback() {\n      isMessageLoopRunning ||\n        ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    exports.unstable_now = void 0;\n    if (\n      \"object\" === typeof performance &&\n      \"function\" === typeof performance.now\n    ) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date,\n        initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    }\n    var taskQueue = [],\n      timerQueue = [],\n      taskIdCounter = 1,\n      currentTask = null,\n      currentPriorityLevel = 3,\n      isPerformingWork = !1,\n      isHostCallbackScheduled = !1,\n      isHostTimeoutScheduled = !1,\n      localSetTimeout = \"function\" === typeof setTimeout ? setTimeout : null,\n      localClearTimeout =\n        \"function\" === typeof clearTimeout ? clearTimeout : null,\n      localSetImmediate =\n        \"undefined\" !== typeof setImmediate ? setImmediate : null,\n      isMessageLoopRunning = !1,\n      taskTimeoutID = -1,\n      frameInterval = 5,\n      startTime = -1;\n    if (\"function\" === typeof localSetImmediate)\n      var schedulePerformWorkUntilDeadline = function () {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    else if (\"undefined\" !== typeof MessageChannel) {\n      var channel = new MessageChannel(),\n        port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function () {\n        port.postMessage(null);\n      };\n    } else\n      schedulePerformWorkUntilDeadline = function () {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    exports.unstable_IdlePriority = 5;\n    exports.unstable_ImmediatePriority = 1;\n    exports.unstable_LowPriority = 4;\n    exports.unstable_NormalPriority = 3;\n    exports.unstable_Profiling = null;\n    exports.unstable_UserBlockingPriority = 2;\n    exports.unstable_cancelCallback = function (task) {\n      task.callback = null;\n    };\n    exports.unstable_continueExecution = function () {\n      isHostCallbackScheduled ||\n        isPerformingWork ||\n        ((isHostCallbackScheduled = !0), requestHostCallback());\n    };\n    exports.unstable_forceFrameRate = function (fps) {\n      0 > fps || 125 < fps\n        ? console.error(\n            \"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"\n          )\n        : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);\n    };\n    exports.unstable_getCurrentPriorityLevel = function () {\n      return currentPriorityLevel;\n    };\n    exports.unstable_getFirstCallbackNode = function () {\n      return peek(taskQueue);\n    };\n    exports.unstable_next = function (eventHandler) {\n      switch (currentPriorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n          var priorityLevel = 3;\n          break;\n        default:\n          priorityLevel = currentPriorityLevel;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_pauseExecution = function () {};\n    exports.unstable_requestPaint = function () {};\n    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          break;\n        default:\n          priorityLevel = 3;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_scheduleCallback = function (\n      priorityLevel,\n      callback,\n      options\n    ) {\n      var currentTime = exports.unstable_now();\n      \"object\" === typeof options && null !== options\n        ? ((options = options.delay),\n          (options =\n            \"number\" === typeof options && 0 < options\n              ? currentTime + options\n              : currentTime))\n        : (options = currentTime);\n      switch (priorityLevel) {\n        case 1:\n          var timeout = -1;\n          break;\n        case 2:\n          timeout = 250;\n          break;\n        case 5:\n          timeout = 1073741823;\n          break;\n        case 4:\n          timeout = 1e4;\n          break;\n        default:\n          timeout = 5e3;\n      }\n      timeout = options + timeout;\n      priorityLevel = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: options,\n        expirationTime: timeout,\n        sortIndex: -1\n      };\n      options > currentTime\n        ? ((priorityLevel.sortIndex = options),\n          push(timerQueue, priorityLevel),\n          null === peek(taskQueue) &&\n            priorityLevel === peek(timerQueue) &&\n            (isHostTimeoutScheduled\n              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n              : (isHostTimeoutScheduled = !0),\n            requestHostTimeout(handleTimeout, options - currentTime)))\n        : ((priorityLevel.sortIndex = timeout),\n          push(taskQueue, priorityLevel),\n          isHostCallbackScheduled ||\n            isPerformingWork ||\n            ((isHostCallbackScheduled = !0), requestHostCallback()));\n      return priorityLevel;\n    };\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = function (callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSSw2QkFBNkI7QUFDakMsSUFBSSxrQ0FBa0M7QUFDdEMsSUFBSSw0QkFBNEI7QUFDaEMsSUFBSSwrQkFBK0I7QUFDbkMsSUFBSSwwQkFBMEI7QUFDOUIsSUFBSSxxQ0FBcUM7QUFDekMsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBLElBQUksa0NBQWtDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3Q0FBd0M7QUFDNUM7QUFDQTtBQUNBLElBQUkscUNBQXFDO0FBQ3pDO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtCQUErQjtBQUNuQyxJQUFJLDZCQUE2QjtBQUNqQyxJQUFJLGdDQUFnQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUksaUNBQWlDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQyxJQUFJLDZCQUE2QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCkge1xuICAgICAgaWYgKGlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgaGFzTW9yZVdvcmsgPSAhMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICExO1xuICAgICAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCAmJlxuICAgICAgICAgICAgICAoKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSksXG4gICAgICAgICAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpLFxuICAgICAgICAgICAgICAodGFza1RpbWVvdXRJRCA9IC0xKSk7XG4gICAgICAgICAgICBpc1BlcmZvcm1pbmdXb3JrID0gITA7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBiOiB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudFRhc2sgJiZcbiAgICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkWWllbGRUb0hvc3QoKVxuICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gY3VycmVudFRhc2suY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRUYXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2sgPT09IHBlZWsodGFza1F1ZXVlKSAmJiBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnRUYXNrKSBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZmlyc3RUaW1lciAmJlxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgKGN1cnJlbnRUYXNrID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsKSxcbiAgICAgICAgICAgICAgICAoaXNQZXJmb3JtaW5nV29yayA9ICExKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc01vcmVXb3JrID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBoYXNNb3JlV29ya1xuICAgICAgICAgICAgPyBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpXG4gICAgICAgICAgICA6IChpc01lc3NhZ2VMb29wUnVubmluZyA9ICExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgICAgIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICAgICAgaGVhcC5wdXNoKG5vZGUpO1xuICAgICAgYTogZm9yICg7IDAgPCBpbmRleDsgKSB7XG4gICAgICAgIHZhciBwYXJlbnRJbmRleCA9IChpbmRleCAtIDEpID4+PiAxLFxuICAgICAgICAgIHBhcmVudCA9IGhlYXBbcGFyZW50SW5kZXhdO1xuICAgICAgICBpZiAoMCA8IGNvbXBhcmUocGFyZW50LCBub2RlKSlcbiAgICAgICAgICAoaGVhcFtwYXJlbnRJbmRleF0gPSBub2RlKSxcbiAgICAgICAgICAgIChoZWFwW2luZGV4XSA9IHBhcmVudCksXG4gICAgICAgICAgICAoaW5kZXggPSBwYXJlbnRJbmRleCk7XG4gICAgICAgIGVsc2UgYnJlYWsgYTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGVlayhoZWFwKSB7XG4gICAgICByZXR1cm4gMCA9PT0gaGVhcC5sZW5ndGggPyBudWxsIDogaGVhcFswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wKGhlYXApIHtcbiAgICAgIGlmICgwID09PSBoZWFwLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZmlyc3QgPSBoZWFwWzBdLFxuICAgICAgICBsYXN0ID0gaGVhcC5wb3AoKTtcbiAgICAgIGlmIChsYXN0ICE9PSBmaXJzdCkge1xuICAgICAgICBoZWFwWzBdID0gbGFzdDtcbiAgICAgICAgYTogZm9yIChcbiAgICAgICAgICB2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBoZWFwLmxlbmd0aCwgaGFsZkxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgICAgICAgICBpbmRleCA8IGhhbGZMZW5ndGg7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGxlZnRJbmRleCA9IDIgKiAoaW5kZXggKyAxKSAtIDEsXG4gICAgICAgICAgICBsZWZ0ID0gaGVhcFtsZWZ0SW5kZXhdLFxuICAgICAgICAgICAgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDEsXG4gICAgICAgICAgICByaWdodCA9IGhlYXBbcmlnaHRJbmRleF07XG4gICAgICAgICAgaWYgKDAgPiBjb21wYXJlKGxlZnQsIGxhc3QpKVxuICAgICAgICAgICAgcmlnaHRJbmRleCA8IGxlbmd0aCAmJiAwID4gY29tcGFyZShyaWdodCwgbGVmdClcbiAgICAgICAgICAgICAgPyAoKGhlYXBbaW5kZXhdID0gcmlnaHQpLFxuICAgICAgICAgICAgICAgIChoZWFwW3JpZ2h0SW5kZXhdID0gbGFzdCksXG4gICAgICAgICAgICAgICAgKGluZGV4ID0gcmlnaHRJbmRleCkpXG4gICAgICAgICAgICAgIDogKChoZWFwW2luZGV4XSA9IGxlZnQpLFxuICAgICAgICAgICAgICAgIChoZWFwW2xlZnRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgICAgICAoaW5kZXggPSBsZWZ0SW5kZXgpKTtcbiAgICAgICAgICBlbHNlIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIDAgPiBjb21wYXJlKHJpZ2h0LCBsYXN0KSlcbiAgICAgICAgICAgIChoZWFwW2luZGV4XSA9IHJpZ2h0KSxcbiAgICAgICAgICAgICAgKGhlYXBbcmlnaHRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgICAgKGluZGV4ID0gcmlnaHRJbmRleCk7XG4gICAgICAgICAgZWxzZSBicmVhayBhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuICAgICAgcmV0dXJuIDAgIT09IGRpZmYgPyBkaWZmIDogYS5pZCAtIGIuaWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpIHtcbiAgICAgIGZvciAodmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTsgbnVsbCAhPT0gdGltZXI7ICkge1xuICAgICAgICBpZiAobnVsbCA9PT0gdGltZXIuY2FsbGJhY2spIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgICAgZWxzZSBpZiAodGltZXIuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lKVxuICAgICAgICAgIHBvcCh0aW1lclF1ZXVlKSxcbiAgICAgICAgICAgICh0aW1lci5zb3J0SW5kZXggPSB0aW1lci5leHBpcmF0aW9uVGltZSksXG4gICAgICAgICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoY3VycmVudFRpbWUpIHtcbiAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMTtcbiAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZClcbiAgICAgICAgaWYgKG51bGwgIT09IHBlZWsodGFza1F1ZXVlKSlcbiAgICAgICAgICAoaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMCksIHJlcXVlc3RIb3N0Q2FsbGJhY2soKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICAgIG51bGwgIT09IGZpcnN0VGltZXIgJiZcbiAgICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChcbiAgICAgICAgICAgICAgaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLnVuc3RhYmxlX25vdygpIC0gc3RhcnRUaW1lIDwgZnJhbWVJbnRlcnZhbCA/ICExIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RIb3N0Q2FsbGJhY2soKSB7XG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyB8fFxuICAgICAgICAoKGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gITApLCBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuICAgICAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICAgICAgfSwgbXMpO1xuICAgIH1cbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KEVycm9yKCkpO1xuICAgIGV4cG9ydHMudW5zdGFibGVfbm93ID0gdm9pZCAwO1xuICAgIGlmIChcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwZXJmb3JtYW5jZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2Uubm93XG4gICAgKSB7XG4gICAgICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2FsRGF0ZSA9IERhdGUsXG4gICAgICAgIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuICAgICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciB0YXNrUXVldWUgPSBbXSxcbiAgICAgIHRpbWVyUXVldWUgPSBbXSxcbiAgICAgIHRhc2tJZENvdW50ZXIgPSAxLFxuICAgICAgY3VycmVudFRhc2sgPSBudWxsLFxuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSAzLFxuICAgICAgaXNQZXJmb3JtaW5nV29yayA9ICExLFxuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSxcbiAgICAgIGxvY2FsU2V0VGltZW91dCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHNldFRpbWVvdXQgPyBzZXRUaW1lb3V0IDogbnVsbCxcbiAgICAgIGxvY2FsQ2xlYXJUaW1lb3V0ID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2xlYXJUaW1lb3V0ID8gY2xlYXJUaW1lb3V0IDogbnVsbCxcbiAgICAgIGxvY2FsU2V0SW1tZWRpYXRlID1cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHNldEltbWVkaWF0ZSA/IHNldEltbWVkaWF0ZSA6IG51bGwsXG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9ICExLFxuICAgICAgdGFza1RpbWVvdXRJRCA9IC0xLFxuICAgICAgZnJhbWVJbnRlcnZhbCA9IDUsXG4gICAgICBzdGFydFRpbWUgPSAtMTtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbG9jYWxTZXRJbW1lZGlhdGUpXG4gICAgICB2YXIgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsU2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XG4gICAgICB9O1xuICAgIGVsc2UgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSxcbiAgICAgICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcbiAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgfTtcbiAgICB9IGVsc2VcbiAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2NhbFNldFRpbWVvdXQocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lLCAwKTtcbiAgICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9JZGxlUHJpb3JpdHkgPSA1O1xuICAgIGV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xuICAgIGV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSA0O1xuICAgIGV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSAzO1xuICAgIGV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gbnVsbDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgIHRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIHx8XG4gICAgICAgIGlzUGVyZm9ybWluZ1dvcmsgfHxcbiAgICAgICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoZnBzKSB7XG4gICAgICAwID4gZnBzIHx8IDEyNSA8IGZwc1xuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCBmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZFwiXG4gICAgICAgICAgKVxuICAgICAgICA6IChmcmFtZUludGVydmFsID0gMCA8IGZwcyA/IE1hdGguZmxvb3IoMWUzIC8gZnBzKSA6IDUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gZnVuY3Rpb24gKGV2ZW50SGFuZGxlcikge1xuICAgICAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhciBwcmlvcml0eUxldmVsID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3JlcXVlc3RQYWludCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5TGV2ZWwsIGV2ZW50SGFuZGxlcikge1xuICAgICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPSAzO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoXG4gICAgICBwcmlvcml0eUxldmVsLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgbnVsbCAhPT0gb3B0aW9uc1xuICAgICAgICA/ICgob3B0aW9ucyA9IG9wdGlvbnMuZGVsYXkpLFxuICAgICAgICAgIChvcHRpb25zID1cbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBvcHRpb25zICYmIDAgPCBvcHRpb25zXG4gICAgICAgICAgICAgID8gY3VycmVudFRpbWUgKyBvcHRpb25zXG4gICAgICAgICAgICAgIDogY3VycmVudFRpbWUpKVxuICAgICAgICA6IChvcHRpb25zID0gY3VycmVudFRpbWUpO1xuICAgICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB2YXIgdGltZW91dCA9IC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGltZW91dCA9IDI1MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHRpbWVvdXQgPSAxMDczNzQxODIzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdGltZW91dCA9IDFlNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aW1lb3V0ID0gNWUzO1xuICAgICAgfVxuICAgICAgdGltZW91dCA9IG9wdGlvbnMgKyB0aW1lb3V0O1xuICAgICAgcHJpb3JpdHlMZXZlbCA9IHtcbiAgICAgICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgICAgICBzdGFydFRpbWU6IG9wdGlvbnMsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiB0aW1lb3V0LFxuICAgICAgICBzb3J0SW5kZXg6IC0xXG4gICAgICB9O1xuICAgICAgb3B0aW9ucyA+IGN1cnJlbnRUaW1lXG4gICAgICAgID8gKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IG9wdGlvbnMpLFxuICAgICAgICAgIHB1c2godGltZXJRdWV1ZSwgcHJpb3JpdHlMZXZlbCksXG4gICAgICAgICAgbnVsbCA9PT0gcGVlayh0YXNrUXVldWUpICYmXG4gICAgICAgICAgICBwcmlvcml0eUxldmVsID09PSBwZWVrKHRpbWVyUXVldWUpICYmXG4gICAgICAgICAgICAoaXNIb3N0VGltZW91dFNjaGVkdWxlZFxuICAgICAgICAgICAgICA/IChsb2NhbENsZWFyVGltZW91dCh0YXNrVGltZW91dElEKSwgKHRhc2tUaW1lb3V0SUQgPSAtMSkpXG4gICAgICAgICAgICAgIDogKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgb3B0aW9ucyAtIGN1cnJlbnRUaW1lKSkpXG4gICAgICAgIDogKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IHRpbWVvdXQpLFxuICAgICAgICAgIHB1c2godGFza1F1ZXVlLCBwcmlvcml0eUxldmVsKSxcbiAgICAgICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCB8fFxuICAgICAgICAgICAgaXNQZXJmb3JtaW5nV29yayB8fFxuICAgICAgICAgICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpKSk7XG4gICAgICByZXR1cm4gcHJpb3JpdHlMZXZlbDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBzaG91bGRZaWVsZFRvSG9zdDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoRXJyb3IoKSk7XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/scheduler/cjs/scheduler.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(app-pages-browser)/./node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHVKQUEwRDtBQUM1RCIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/scheduler/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/styled-jsx/dist/index/index.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n__webpack_require__(/*! client-only */ \"(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js\");\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === 'object' && 'default' in e ? e : {\n        'default': e\n    };\n}\nvar React__default = /*#__PURE__*/ _interopDefaultLegacy(React);\n_c = React__default;\n/*\nBased on Glamor's sheet\nhttps://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js\n*/ function _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nvar isProd = typeof process !== \"undefined\" && process.env && \"development\" === \"production\";\nvar isString = function(o) {\n    return Object.prototype.toString.call(o) === \"[object String]\";\n};\nvar StyleSheet = /*#__PURE__*/ function() {\n    function StyleSheet(param) {\n        var ref = param === void 0 ? {} : param, _name = ref.name, name = _name === void 0 ? \"stylesheet\" : _name, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? isProd : _optimizeForSpeed;\n        invariant$1(isString(name), \"`name` must be a string\");\n        this._name = name;\n        this._deletedRulePlaceholder = \"#\" + name + \"-deleted-rule____{}\";\n        invariant$1(typeof optimizeForSpeed === \"boolean\", \"`optimizeForSpeed` must be a boolean\");\n        this._optimizeForSpeed = optimizeForSpeed;\n        this._serverSheet = undefined;\n        this._tags = [];\n        this._injected = false;\n        this._rulesCount = 0;\n        var node = typeof window !== \"undefined\" && document.querySelector('meta[property=\"csp-nonce\"]');\n        this._nonce = node ? node.getAttribute(\"content\") : null;\n    }\n    var _proto = StyleSheet.prototype;\n    _proto.setOptimizeForSpeed = function setOptimizeForSpeed(bool) {\n        invariant$1(typeof bool === \"boolean\", \"`setOptimizeForSpeed` accepts a boolean\");\n        invariant$1(this._rulesCount === 0, \"optimizeForSpeed cannot be when rules have already been inserted\");\n        this.flush();\n        this._optimizeForSpeed = bool;\n        this.inject();\n    };\n    _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {\n        return this._optimizeForSpeed;\n    };\n    _proto.inject = function inject() {\n        var _this = this;\n        invariant$1(!this._injected, \"sheet already injected\");\n        this._injected = true;\n        if (typeof window !== \"undefined\" && this._optimizeForSpeed) {\n            this._tags[0] = this.makeStyleTag(this._name);\n            this._optimizeForSpeed = \"insertRule\" in this.getSheet();\n            if (!this._optimizeForSpeed) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.\");\n                }\n                this.flush();\n                this._injected = true;\n            }\n            return;\n        }\n        this._serverSheet = {\n            cssRules: [],\n            insertRule: function(rule, index) {\n                if (typeof index === \"number\") {\n                    _this._serverSheet.cssRules[index] = {\n                        cssText: rule\n                    };\n                } else {\n                    _this._serverSheet.cssRules.push({\n                        cssText: rule\n                    });\n                }\n                return index;\n            },\n            deleteRule: function(index) {\n                _this._serverSheet.cssRules[index] = null;\n            }\n        };\n    };\n    _proto.getSheetForTag = function getSheetForTag(tag) {\n        if (tag.sheet) {\n            return tag.sheet;\n        }\n        // this weirdness brought to you by firefox\n        for(var i = 0; i < document.styleSheets.length; i++){\n            if (document.styleSheets[i].ownerNode === tag) {\n                return document.styleSheets[i];\n            }\n        }\n    };\n    _proto.getSheet = function getSheet() {\n        return this.getSheetForTag(this._tags[this._tags.length - 1]);\n    };\n    _proto.insertRule = function insertRule(rule, index) {\n        invariant$1(isString(rule), \"`insertRule` accepts only strings\");\n        if (typeof window === \"undefined\") {\n            if (typeof index !== \"number\") {\n                index = this._serverSheet.cssRules.length;\n            }\n            this._serverSheet.insertRule(rule, index);\n            return this._rulesCount++;\n        }\n        if (this._optimizeForSpeed) {\n            var sheet = this.getSheet();\n            if (typeof index !== \"number\") {\n                index = sheet.cssRules.length;\n            }\n            // this weirdness for perf, and chrome's weird bug\n            // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                return -1;\n            }\n        } else {\n            var insertionPoint = this._tags[index];\n            this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));\n        }\n        return this._rulesCount++;\n    };\n    _proto.replaceRule = function replaceRule(index, rule) {\n        if (this._optimizeForSpeed || typeof window === \"undefined\") {\n            var sheet = typeof window !== \"undefined\" ? this.getSheet() : this._serverSheet;\n            if (!rule.trim()) {\n                rule = this._deletedRulePlaceholder;\n            }\n            if (!sheet.cssRules[index]) {\n                // @TBD Should we throw an error?\n                return index;\n            }\n            sheet.deleteRule(index);\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                // In order to preserve the indices we insert a deleteRulePlaceholder\n                sheet.insertRule(this._deletedRulePlaceholder, index);\n            }\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"old rule at index `\" + index + \"` not found\");\n            tag.textContent = rule;\n        }\n        return index;\n    };\n    _proto.deleteRule = function deleteRule(index) {\n        if (typeof window === \"undefined\") {\n            this._serverSheet.deleteRule(index);\n            return;\n        }\n        if (this._optimizeForSpeed) {\n            this.replaceRule(index, \"\");\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"rule at index `\" + index + \"` not found\");\n            tag.parentNode.removeChild(tag);\n            this._tags[index] = null;\n        }\n    };\n    _proto.flush = function flush() {\n        this._injected = false;\n        this._rulesCount = 0;\n        if (typeof window !== \"undefined\") {\n            this._tags.forEach(function(tag) {\n                return tag && tag.parentNode.removeChild(tag);\n            });\n            this._tags = [];\n        } else {\n            // simpler on server\n            this._serverSheet.cssRules = [];\n        }\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        if (typeof window === \"undefined\") {\n            return this._serverSheet.cssRules;\n        }\n        return this._tags.reduce(function(rules, tag) {\n            if (tag) {\n                rules = rules.concat(Array.prototype.map.call(_this.getSheetForTag(tag).cssRules, function(rule) {\n                    return rule.cssText === _this._deletedRulePlaceholder ? null : rule;\n                }));\n            } else {\n                rules.push(null);\n            }\n            return rules;\n        }, []);\n    };\n    _proto.makeStyleTag = function makeStyleTag(name, cssString, relativeToTag) {\n        if (cssString) {\n            invariant$1(isString(cssString), \"makeStyleTag accepts only strings as second parameter\");\n        }\n        var tag = document.createElement(\"style\");\n        if (this._nonce) tag.setAttribute(\"nonce\", this._nonce);\n        tag.type = \"text/css\";\n        tag.setAttribute(\"data-\" + name, \"\");\n        if (cssString) {\n            tag.appendChild(document.createTextNode(cssString));\n        }\n        var head = document.head || document.getElementsByTagName(\"head\")[0];\n        if (relativeToTag) {\n            head.insertBefore(tag, relativeToTag);\n        } else {\n            head.appendChild(tag);\n        }\n        return tag;\n    };\n    _createClass(StyleSheet, [\n        {\n            key: \"length\",\n            get: function get() {\n                return this._rulesCount;\n            }\n        }\n    ]);\n    return StyleSheet;\n}();\nfunction invariant$1(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheet: \" + message + \".\");\n    }\n}\nfunction hash(str) {\n    var _$hash = 5381, i = str.length;\n    while(i){\n        _$hash = _$hash * 33 ^ str.charCodeAt(--i);\n    }\n    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */ return _$hash >>> 0;\n}\nvar stringHash = hash;\nvar sanitize = function(rule) {\n    return rule.replace(/\\/style/gi, \"\\\\/style\");\n};\nvar cache = {};\n/**\n * computeId\n *\n * Compute and memoize a jsx id from a basedId and optionally props.\n */ function computeId(baseId, props) {\n    if (!props) {\n        return \"jsx-\" + baseId;\n    }\n    var propsToString = String(props);\n    var key = baseId + propsToString;\n    if (!cache[key]) {\n        cache[key] = \"jsx-\" + stringHash(baseId + \"-\" + propsToString);\n    }\n    return cache[key];\n}\n/**\n * computeSelector\n *\n * Compute and memoize dynamic selectors.\n */ function computeSelector(id, css) {\n    var selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g;\n    // Sanitize SSR-ed CSS.\n    // Client side code doesn't need to be sanitized since we use\n    // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).\n    if (typeof window === \"undefined\") {\n        css = sanitize(css);\n    }\n    var idcss = id + css;\n    if (!cache[idcss]) {\n        cache[idcss] = css.replace(selectoPlaceholderRegexp, id);\n    }\n    return cache[idcss];\n}\nfunction mapRulesToStyle(cssRules, options) {\n    if (options === void 0) options = {};\n    return cssRules.map(function(args) {\n        var id = args[0];\n        var css = args[1];\n        return /*#__PURE__*/ React__default[\"default\"].createElement(\"style\", {\n            id: \"__\" + id,\n            // Avoid warnings upon render with a key\n            key: \"__\" + id,\n            nonce: options.nonce ? options.nonce : undefined,\n            dangerouslySetInnerHTML: {\n                __html: css\n            }\n        });\n    });\n}\nvar StyleSheetRegistry = /*#__PURE__*/ function() {\n    function StyleSheetRegistry(param) {\n        var ref = param === void 0 ? {} : param, _styleSheet = ref.styleSheet, styleSheet = _styleSheet === void 0 ? null : _styleSheet, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? false : _optimizeForSpeed;\n        this._sheet = styleSheet || new StyleSheet({\n            name: \"styled-jsx\",\n            optimizeForSpeed: optimizeForSpeed\n        });\n        this._sheet.inject();\n        if (styleSheet && typeof optimizeForSpeed === \"boolean\") {\n            this._sheet.setOptimizeForSpeed(optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    }\n    var _proto = StyleSheetRegistry.prototype;\n    _proto.add = function add(props) {\n        var _this = this;\n        if (undefined === this._optimizeForSpeed) {\n            this._optimizeForSpeed = Array.isArray(props.children);\n            this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        if (typeof window !== \"undefined\" && !this._fromServer) {\n            this._fromServer = this.selectFromServer();\n            this._instancesCounts = Object.keys(this._fromServer).reduce(function(acc, tagName) {\n                acc[tagName] = 0;\n                return acc;\n            }, {});\n        }\n        var ref = this.getIdAndRules(props), styleId = ref.styleId, rules = ref.rules;\n        // Deduping: just increase the instances count.\n        if (styleId in this._instancesCounts) {\n            this._instancesCounts[styleId] += 1;\n            return;\n        }\n        var indices = rules.map(function(rule) {\n            return _this._sheet.insertRule(rule);\n        }) // Filter out invalid rules\n        .filter(function(index) {\n            return index !== -1;\n        });\n        this._indices[styleId] = indices;\n        this._instancesCounts[styleId] = 1;\n    };\n    _proto.remove = function remove(props) {\n        var _this = this;\n        var styleId = this.getIdAndRules(props).styleId;\n        invariant(styleId in this._instancesCounts, \"styleId: `\" + styleId + \"` not found\");\n        this._instancesCounts[styleId] -= 1;\n        if (this._instancesCounts[styleId] < 1) {\n            var tagFromServer = this._fromServer && this._fromServer[styleId];\n            if (tagFromServer) {\n                tagFromServer.parentNode.removeChild(tagFromServer);\n                delete this._fromServer[styleId];\n            } else {\n                this._indices[styleId].forEach(function(index) {\n                    return _this._sheet.deleteRule(index);\n                });\n                delete this._indices[styleId];\n            }\n            delete this._instancesCounts[styleId];\n        }\n    };\n    _proto.update = function update(props, nextProps) {\n        this.add(nextProps);\n        this.remove(props);\n    };\n    _proto.flush = function flush() {\n        this._sheet.flush();\n        this._sheet.inject();\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        var fromServer = this._fromServer ? Object.keys(this._fromServer).map(function(styleId) {\n            return [\n                styleId,\n                _this._fromServer[styleId]\n            ];\n        }) : [];\n        var cssRules = this._sheet.cssRules();\n        return fromServer.concat(Object.keys(this._indices).map(function(styleId) {\n            return [\n                styleId,\n                _this._indices[styleId].map(function(index) {\n                    return cssRules[index].cssText;\n                }).join(_this._optimizeForSpeed ? \"\" : \"\\n\")\n            ];\n        }) // filter out empty rules\n        .filter(function(rule) {\n            return Boolean(rule[1]);\n        }));\n    };\n    _proto.styles = function styles(options) {\n        return mapRulesToStyle(this.cssRules(), options);\n    };\n    _proto.getIdAndRules = function getIdAndRules(props) {\n        var css = props.children, dynamic = props.dynamic, id = props.id;\n        if (dynamic) {\n            var styleId = computeId(id, dynamic);\n            return {\n                styleId: styleId,\n                rules: Array.isArray(css) ? css.map(function(rule) {\n                    return computeSelector(styleId, rule);\n                }) : [\n                    computeSelector(styleId, css)\n                ]\n            };\n        }\n        return {\n            styleId: computeId(id),\n            rules: Array.isArray(css) ? css : [\n                css\n            ]\n        };\n    };\n    /**\n   * selectFromServer\n   *\n   * Collects style tags from the document with id __jsx-XXX\n   */ _proto.selectFromServer = function selectFromServer() {\n        var elements = Array.prototype.slice.call(document.querySelectorAll('[id^=\"__jsx-\"]'));\n        return elements.reduce(function(acc, element) {\n            var id = element.id.slice(2);\n            acc[id] = element;\n            return acc;\n        }, {});\n    };\n    return StyleSheetRegistry;\n}();\nfunction invariant(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheetRegistry: \" + message + \".\");\n    }\n}\nvar StyleSheetContext = /*#__PURE__*/ React.createContext(null);\nStyleSheetContext.displayName = \"StyleSheetContext\";\nfunction createStyleRegistry() {\n    return new StyleSheetRegistry();\n}\nfunction StyleRegistry(param) {\n    _s();\n    var configuredRegistry = param.registry, children = param.children;\n    var rootRegistry = React.useContext(StyleSheetContext);\n    var ref = React.useState({\n        \"StyleRegistry.useState[ref]\": function() {\n            return rootRegistry || configuredRegistry || createStyleRegistry();\n        }\n    }[\"StyleRegistry.useState[ref]\"]), registry = ref[0];\n    return /*#__PURE__*/ React__default[\"default\"].createElement(StyleSheetContext.Provider, {\n        value: registry\n    }, children);\n}\n_s(StyleRegistry, \"F6PIZFsaWgcE6rBNmd+Zkq3zRoY=\");\n_c1 = StyleRegistry;\nfunction useStyleRegistry() {\n    _s1();\n    return React.useContext(StyleSheetContext);\n}\n_s1(useStyleRegistry, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n// Opt-into the new `useInsertionEffect` API in React 18, fallback to `useLayoutEffect`.\n// https://github.com/reactwg/react-18/discussions/110\nvar useInsertionEffect = React__default[\"default\"].useInsertionEffect || React__default[\"default\"].useLayoutEffect;\nvar defaultRegistry = typeof window !== \"undefined\" ? createStyleRegistry() : undefined;\nfunction JSXStyle(props) {\n    _s2();\n    var registry = defaultRegistry ? defaultRegistry : useStyleRegistry();\n    // If `registry` does not exist, we do nothing here.\n    if (!registry) {\n        return null;\n    }\n    if (typeof window === \"undefined\") {\n        registry.add(props);\n        return null;\n    }\n    useInsertionEffect({\n        \"JSXStyle.useInsertionEffect\": function() {\n            registry.add(props);\n            return ({\n                \"JSXStyle.useInsertionEffect\": function() {\n                    registry.remove(props);\n                }\n            })[\"JSXStyle.useInsertionEffect\"];\n        // props.children can be string[], will be striped since id is identical\n        }\n    }[\"JSXStyle.useInsertionEffect\"], [\n        props.id,\n        String(props.dynamic)\n    ]);\n    return null;\n}\n_s2(JSXStyle, \"48Sqj1BUqkshsPdz6NEWXDn8pF4=\", false, function() {\n    return [\n        useStyleRegistry,\n        useInsertionEffect\n    ];\n});\n_c2 = JSXStyle;\nJSXStyle.dynamic = function(info) {\n    return info.map(function(tagInfo) {\n        var baseId = tagInfo[0];\n        var props = tagInfo[1];\n        return computeId(baseId, props);\n    }).join(\" \");\n};\nexports.StyleRegistry = StyleRegistry;\nexports.createStyleRegistry = createStyleRegistry;\nexports.style = JSXStyle;\nexports.useStyleRegistry = useStyleRegistry;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"React__default\");\n$RefreshReg$(_c1, \"StyleRegistry\");\n$RefreshReg$(_c2, \"JSXStyle\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L2Rpc3QvaW5kZXgvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUFBLG1CQUFPQSxDQUFDLCtGQUFhO0FBQ3JCLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLG1GQUFPO0FBRTNCLFNBQVNFLHNCQUF1QkMsQ0FBQztJQUFJLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRSxXQUFXQTtJQUFFO0FBQUc7QUFFakgsSUFBSUMsaUJBQWlCLFdBQVcsR0FBRUYsc0JBQXNCRDs7QUFFeEQ7OztBQUdBLEdBQUcsU0FBU0ksa0JBQWtCQyxNQUFNLEVBQUVDLEtBQUs7SUFDdkMsSUFBSSxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSTtRQUNqQyxJQUFJRSxhQUFhSCxLQUFLLENBQUNDLEVBQUU7UUFDekJFLFdBQVdDLFVBQVUsR0FBR0QsV0FBV0MsVUFBVSxJQUFJO1FBQ2pERCxXQUFXRSxZQUFZLEdBQUc7UUFDMUIsSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUc7UUFDakRDLE9BQU9DLGNBQWMsQ0FBQ1QsUUFBUUksV0FBV00sR0FBRyxFQUFFTjtJQUNsRDtBQUNKO0FBQ0EsU0FBU08sYUFBYUMsV0FBVyxFQUFFQyxVQUFVLEVBQUVDLFdBQVc7SUFDdEQsSUFBSUQsWUFBWWQsa0JBQWtCYSxZQUFZRyxTQUFTLEVBQUVGO0lBQ3pELElBQUlDLGFBQWFmLGtCQUFrQmEsYUFBYUU7SUFDaEQsT0FBT0Y7QUFDWDtBQUNBLElBQUlJLFNBQVMsT0FBT0MsT0FBT0EsS0FBSyxlQUFlQSxPQUFPQSxDQUFDQyxHQUFHLElBQUlELGtCQUF5QjtBQUN2RixJQUFJRSxXQUFXLFNBQVNDLENBQUM7SUFDckIsT0FBT1osT0FBT08sU0FBUyxDQUFDTSxRQUFRLENBQUNDLElBQUksQ0FBQ0YsT0FBTztBQUNqRDtBQUNBLElBQUlHLGFBQWEsV0FBVyxHQUFHO0lBQzNCLFNBQVNBLFdBQVdDLEtBQUs7UUFDckIsSUFBSUMsTUFBTUQsVUFBVSxLQUFLLElBQUksQ0FBQyxJQUFJQSxPQUFPRSxRQUFRRCxJQUFJRSxJQUFJLEVBQUVBLE9BQU9ELFVBQVUsS0FBSyxJQUFJLGVBQWVBLE9BQU9FLG9CQUFvQkgsSUFBSUksZ0JBQWdCLEVBQUVBLG1CQUFtQkQsc0JBQXNCLEtBQUssSUFBSVosU0FBU1k7UUFDaE5FLFlBQVlYLFNBQVNRLE9BQU87UUFDNUIsSUFBSSxDQUFDRCxLQUFLLEdBQUdDO1FBQ2IsSUFBSSxDQUFDSSx1QkFBdUIsR0FBRyxNQUFNSixPQUFPO1FBQzVDRyxZQUFZLE9BQU9ELHFCQUFxQixXQUFXO1FBQ25ELElBQUksQ0FBQ0QsaUJBQWlCLEdBQUdDO1FBQ3pCLElBQUksQ0FBQ0csWUFBWSxHQUFHQztRQUNwQixJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSUMsT0FBTyxPQUFPQyxXQUFXLGVBQWVDLFNBQVNDLGFBQWEsQ0FBQztRQUNuRSxJQUFJLENBQUNDLE1BQU0sR0FBR0osT0FBT0EsS0FBS0ssWUFBWSxDQUFDLGFBQWE7SUFDeEQ7SUFDQSxJQUFJQyxTQUFTcEIsV0FBV1IsU0FBUztJQUNqQzRCLE9BQU9DLG1CQUFtQixHQUFHLFNBQVNBLG9CQUFvQkMsSUFBSTtRQUMxRGYsWUFBWSxPQUFPZSxTQUFTLFdBQVc7UUFDdkNmLFlBQVksSUFBSSxDQUFDTSxXQUFXLEtBQUssR0FBRztRQUNwQyxJQUFJLENBQUNVLEtBQUs7UUFDVixJQUFJLENBQUNsQixpQkFBaUIsR0FBR2lCO1FBQ3pCLElBQUksQ0FBQ0UsTUFBTTtJQUNmO0lBQ0FKLE9BQU9LLGtCQUFrQixHQUFHLFNBQVNBO1FBQ2pDLE9BQU8sSUFBSSxDQUFDcEIsaUJBQWlCO0lBQ2pDO0lBQ0FlLE9BQU9JLE1BQU0sR0FBRyxTQUFTQTtRQUNyQixJQUFJRSxRQUFRLElBQUk7UUFDaEJuQixZQUFZLENBQUMsSUFBSSxDQUFDSyxTQUFTLEVBQUU7UUFDN0IsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxPQUFPRyxXQUFXLGVBQWUsSUFBSSxDQUFDVixpQkFBaUIsRUFBRTtZQUN6RCxJQUFJLENBQUNNLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDZ0IsWUFBWSxDQUFDLElBQUksQ0FBQ3hCLEtBQUs7WUFDNUMsSUFBSSxDQUFDRSxpQkFBaUIsR0FBRyxnQkFBZ0IsSUFBSSxDQUFDdUIsUUFBUTtZQUN0RCxJQUFJLENBQUMsSUFBSSxDQUFDdkIsaUJBQWlCLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQ1osUUFBUTtvQkFDVG9DLFFBQVFDLElBQUksQ0FBQztnQkFDakI7Z0JBQ0EsSUFBSSxDQUFDUCxLQUFLO2dCQUNWLElBQUksQ0FBQ1gsU0FBUyxHQUFHO1lBQ3JCO1lBQ0E7UUFDSjtRQUNBLElBQUksQ0FBQ0gsWUFBWSxHQUFHO1lBQ2hCc0IsVUFBVSxFQUFFO1lBQ1pDLFlBQVksU0FBU0MsSUFBSSxFQUFFQyxLQUFLO2dCQUM1QixJQUFJLE9BQU9BLFVBQVUsVUFBVTtvQkFDM0JSLE1BQU1qQixZQUFZLENBQUNzQixRQUFRLENBQUNHLE1BQU0sR0FBRzt3QkFDakNDLFNBQVNGO29CQUNiO2dCQUNKLE9BQU87b0JBQ0hQLE1BQU1qQixZQUFZLENBQUNzQixRQUFRLENBQUNLLElBQUksQ0FBQzt3QkFDN0JELFNBQVNGO29CQUNiO2dCQUNKO2dCQUNBLE9BQU9DO1lBQ1g7WUFDQUcsWUFBWSxTQUFTSCxLQUFLO2dCQUN0QlIsTUFBTWpCLFlBQVksQ0FBQ3NCLFFBQVEsQ0FBQ0csTUFBTSxHQUFHO1lBQ3pDO1FBQ0o7SUFDSjtJQUNBZCxPQUFPa0IsY0FBYyxHQUFHLFNBQVNBLGVBQWVDLEdBQUc7UUFDL0MsSUFBSUEsSUFBSUMsS0FBSyxFQUFFO1lBQ1gsT0FBT0QsSUFBSUMsS0FBSztRQUNwQjtRQUNBLDJDQUEyQztRQUMzQyxJQUFJLElBQUk3RCxJQUFJLEdBQUdBLElBQUlxQyxTQUFTeUIsV0FBVyxDQUFDN0QsTUFBTSxFQUFFRCxJQUFJO1lBQ2hELElBQUlxQyxTQUFTeUIsV0FBVyxDQUFDOUQsRUFBRSxDQUFDK0QsU0FBUyxLQUFLSCxLQUFLO2dCQUMzQyxPQUFPdkIsU0FBU3lCLFdBQVcsQ0FBQzlELEVBQUU7WUFDbEM7UUFDSjtJQUNKO0lBQ0F5QyxPQUFPUSxRQUFRLEdBQUcsU0FBU0E7UUFDdkIsT0FBTyxJQUFJLENBQUNVLGNBQWMsQ0FBQyxJQUFJLENBQUMzQixLQUFLLENBQUMsSUFBSSxDQUFDQSxLQUFLLENBQUMvQixNQUFNLEdBQUcsRUFBRTtJQUNoRTtJQUNBd0MsT0FBT1ksVUFBVSxHQUFHLFNBQVNBLFdBQVdDLElBQUksRUFBRUMsS0FBSztRQUMvQzNCLFlBQVlYLFNBQVNxQyxPQUFPO1FBQzVCLElBQUksT0FBT2xCLFdBQVcsYUFBYTtZQUMvQixJQUFJLE9BQU9tQixVQUFVLFVBQVU7Z0JBQzNCQSxRQUFRLElBQUksQ0FBQ3pCLFlBQVksQ0FBQ3NCLFFBQVEsQ0FBQ25ELE1BQU07WUFDN0M7WUFDQSxJQUFJLENBQUM2QixZQUFZLENBQUN1QixVQUFVLENBQUNDLE1BQU1DO1lBQ25DLE9BQU8sSUFBSSxDQUFDckIsV0FBVztRQUMzQjtRQUNBLElBQUksSUFBSSxDQUFDUixpQkFBaUIsRUFBRTtZQUN4QixJQUFJbUMsUUFBUSxJQUFJLENBQUNaLFFBQVE7WUFDekIsSUFBSSxPQUFPTSxVQUFVLFVBQVU7Z0JBQzNCQSxRQUFRTSxNQUFNVCxRQUFRLENBQUNuRCxNQUFNO1lBQ2pDO1lBQ0Esa0RBQWtEO1lBQ2xELDRGQUE0RjtZQUM1RixJQUFJO2dCQUNBNEQsTUFBTVIsVUFBVSxDQUFDQyxNQUFNQztZQUMzQixFQUFFLE9BQU9TLE9BQU87Z0JBQ1osSUFBSSxDQUFDbEQsUUFBUTtvQkFDVG9DLFFBQVFDLElBQUksQ0FBQyxtQ0FBbUNHLE9BQU87Z0JBQzNEO2dCQUNBLE9BQU8sQ0FBQztZQUNaO1FBQ0osT0FBTztZQUNILElBQUlXLGlCQUFpQixJQUFJLENBQUNqQyxLQUFLLENBQUN1QixNQUFNO1lBQ3RDLElBQUksQ0FBQ3ZCLEtBQUssQ0FBQ3lCLElBQUksQ0FBQyxJQUFJLENBQUNULFlBQVksQ0FBQyxJQUFJLENBQUN4QixLQUFLLEVBQUU4QixNQUFNVztRQUN4RDtRQUNBLE9BQU8sSUFBSSxDQUFDL0IsV0FBVztJQUMzQjtJQUNBTyxPQUFPeUIsV0FBVyxHQUFHLFNBQVNBLFlBQVlYLEtBQUssRUFBRUQsSUFBSTtRQUNqRCxJQUFJLElBQUksQ0FBQzVCLGlCQUFpQixJQUFJLE9BQU9VLFdBQVcsYUFBYTtZQUN6RCxJQUFJeUIsUUFBUSxPQUFPekIsV0FBVyxjQUFjLElBQUksQ0FBQ2EsUUFBUSxLQUFLLElBQUksQ0FBQ25CLFlBQVk7WUFDL0UsSUFBSSxDQUFDd0IsS0FBS2EsSUFBSSxJQUFJO2dCQUNkYixPQUFPLElBQUksQ0FBQ3pCLHVCQUF1QjtZQUN2QztZQUNBLElBQUksQ0FBQ2dDLE1BQU1ULFFBQVEsQ0FBQ0csTUFBTSxFQUFFO2dCQUN4QixpQ0FBaUM7Z0JBQ2pDLE9BQU9BO1lBQ1g7WUFDQU0sTUFBTUgsVUFBVSxDQUFDSDtZQUNqQixJQUFJO2dCQUNBTSxNQUFNUixVQUFVLENBQUNDLE1BQU1DO1lBQzNCLEVBQUUsT0FBT1MsT0FBTztnQkFDWixJQUFJLENBQUNsRCxRQUFRO29CQUNUb0MsUUFBUUMsSUFBSSxDQUFDLG1DQUFtQ0csT0FBTztnQkFDM0Q7Z0JBQ0EscUVBQXFFO2dCQUNyRU8sTUFBTVIsVUFBVSxDQUFDLElBQUksQ0FBQ3hCLHVCQUF1QixFQUFFMEI7WUFDbkQ7UUFDSixPQUFPO1lBQ0gsSUFBSUssTUFBTSxJQUFJLENBQUM1QixLQUFLLENBQUN1QixNQUFNO1lBQzNCM0IsWUFBWWdDLEtBQUssd0JBQXdCTCxRQUFRO1lBQ2pESyxJQUFJUSxXQUFXLEdBQUdkO1FBQ3RCO1FBQ0EsT0FBT0M7SUFDWDtJQUNBZCxPQUFPaUIsVUFBVSxHQUFHLFNBQVNBLFdBQVdILEtBQUs7UUFDekMsSUFBSSxPQUFPbkIsV0FBVyxhQUFhO1lBQy9CLElBQUksQ0FBQ04sWUFBWSxDQUFDNEIsVUFBVSxDQUFDSDtZQUM3QjtRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUM3QixpQkFBaUIsRUFBRTtZQUN4QixJQUFJLENBQUN3QyxXQUFXLENBQUNYLE9BQU87UUFDNUIsT0FBTztZQUNILElBQUlLLE1BQU0sSUFBSSxDQUFDNUIsS0FBSyxDQUFDdUIsTUFBTTtZQUMzQjNCLFlBQVlnQyxLQUFLLG9CQUFvQkwsUUFBUTtZQUM3Q0ssSUFBSVMsVUFBVSxDQUFDQyxXQUFXLENBQUNWO1lBQzNCLElBQUksQ0FBQzVCLEtBQUssQ0FBQ3VCLE1BQU0sR0FBRztRQUN4QjtJQUNKO0lBQ0FkLE9BQU9HLEtBQUssR0FBRyxTQUFTQTtRQUNwQixJQUFJLENBQUNYLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLE9BQU9FLFdBQVcsYUFBYTtZQUMvQixJQUFJLENBQUNKLEtBQUssQ0FBQ3VDLE9BQU8sQ0FBQyxTQUFTWCxHQUFHO2dCQUMzQixPQUFPQSxPQUFPQSxJQUFJUyxVQUFVLENBQUNDLFdBQVcsQ0FBQ1Y7WUFDN0M7WUFDQSxJQUFJLENBQUM1QixLQUFLLEdBQUcsRUFBRTtRQUNuQixPQUFPO1lBQ0gsb0JBQW9CO1lBQ3BCLElBQUksQ0FBQ0YsWUFBWSxDQUFDc0IsUUFBUSxHQUFHLEVBQUU7UUFDbkM7SUFDSjtJQUNBWCxPQUFPVyxRQUFRLEdBQUcsU0FBU0E7UUFDdkIsSUFBSUwsUUFBUSxJQUFJO1FBQ2hCLElBQUksT0FBT1gsV0FBVyxhQUFhO1lBQy9CLE9BQU8sSUFBSSxDQUFDTixZQUFZLENBQUNzQixRQUFRO1FBQ3JDO1FBQ0EsT0FBTyxJQUFJLENBQUNwQixLQUFLLENBQUN3QyxNQUFNLENBQUMsU0FBU0MsS0FBSyxFQUFFYixHQUFHO1lBQ3hDLElBQUlBLEtBQUs7Z0JBQ0xhLFFBQVFBLE1BQU1DLE1BQU0sQ0FBQ0MsTUFBTTlELFNBQVMsQ0FBQytELEdBQUcsQ0FBQ3hELElBQUksQ0FBQzJCLE1BQU1ZLGNBQWMsQ0FBQ0MsS0FBS1IsUUFBUSxFQUFFLFNBQVNFLElBQUk7b0JBQzNGLE9BQU9BLEtBQUtFLE9BQU8sS0FBS1QsTUFBTWxCLHVCQUF1QixHQUFHLE9BQU95QjtnQkFDbkU7WUFDSixPQUFPO2dCQUNIbUIsTUFBTWhCLElBQUksQ0FBQztZQUNmO1lBQ0EsT0FBT2dCO1FBQ1gsR0FBRyxFQUFFO0lBQ1Q7SUFDQWhDLE9BQU9PLFlBQVksR0FBRyxTQUFTQSxhQUFhdkIsSUFBSSxFQUFFb0QsU0FBUyxFQUFFQyxhQUFhO1FBQ3RFLElBQUlELFdBQVc7WUFDWGpELFlBQVlYLFNBQVM0RCxZQUFZO1FBQ3JDO1FBQ0EsSUFBSWpCLE1BQU12QixTQUFTMEMsYUFBYSxDQUFDO1FBQ2pDLElBQUksSUFBSSxDQUFDeEMsTUFBTSxFQUFFcUIsSUFBSW9CLFlBQVksQ0FBQyxTQUFTLElBQUksQ0FBQ3pDLE1BQU07UUFDdERxQixJQUFJcUIsSUFBSSxHQUFHO1FBQ1hyQixJQUFJb0IsWUFBWSxDQUFDLFVBQVV2RCxNQUFNO1FBQ2pDLElBQUlvRCxXQUFXO1lBQ1hqQixJQUFJc0IsV0FBVyxDQUFDN0MsU0FBUzhDLGNBQWMsQ0FBQ047UUFDNUM7UUFDQSxJQUFJTyxPQUFPL0MsU0FBUytDLElBQUksSUFBSS9DLFNBQVNnRCxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUNwRSxJQUFJUCxlQUFlO1lBQ2ZNLEtBQUtFLFlBQVksQ0FBQzFCLEtBQUtrQjtRQUMzQixPQUFPO1lBQ0hNLEtBQUtGLFdBQVcsQ0FBQ3RCO1FBQ3JCO1FBQ0EsT0FBT0E7SUFDWDtJQUNBbkQsYUFBYVksWUFBWTtRQUNyQjtZQUNJYixLQUFLO1lBQ0wrRSxLQUFLLFNBQVNBO2dCQUNWLE9BQU8sSUFBSSxDQUFDckQsV0FBVztZQUMzQjtRQUNKO0tBQ0g7SUFDRCxPQUFPYjtBQUNYO0FBQ0EsU0FBU08sWUFBWTRELFNBQVMsRUFBRUMsT0FBTztJQUNuQyxJQUFJLENBQUNELFdBQVc7UUFDWixNQUFNLElBQUlFLE1BQU0saUJBQWlCRCxVQUFVO0lBQy9DO0FBQ0o7QUFFQSxTQUFTRSxLQUFLQyxHQUFHO0lBQ2IsSUFBSUMsU0FBUyxNQUFNN0YsSUFBSTRGLElBQUkzRixNQUFNO0lBQ2pDLE1BQU1ELEVBQUU7UUFDSjZGLFNBQVNBLFNBQVMsS0FBS0QsSUFBSUUsVUFBVSxDQUFDLEVBQUU5RjtJQUM1QztJQUNBOzs4REFFMEQsR0FBRyxPQUFPNkYsV0FBVztBQUNuRjtBQUNBLElBQUlFLGFBQWFKO0FBRWpCLElBQUlLLFdBQVcsU0FBUzFDLElBQUk7SUFDeEIsT0FBT0EsS0FBSzJDLE9BQU8sQ0FBQyxhQUFhO0FBQ3JDO0FBQ0EsSUFBSUMsUUFBUSxDQUFDO0FBQ2I7Ozs7Q0FJQyxHQUFHLFNBQVNDLFVBQVVDLE1BQU0sRUFBRXJHLEtBQUs7SUFDaEMsSUFBSSxDQUFDQSxPQUFPO1FBQ1IsT0FBTyxTQUFTcUc7SUFDcEI7SUFDQSxJQUFJQyxnQkFBZ0JDLE9BQU92RztJQUMzQixJQUFJUyxNQUFNNEYsU0FBU0M7SUFDbkIsSUFBSSxDQUFDSCxLQUFLLENBQUMxRixJQUFJLEVBQUU7UUFDYjBGLEtBQUssQ0FBQzFGLElBQUksR0FBRyxTQUFTdUYsV0FBV0ssU0FBUyxNQUFNQztJQUNwRDtJQUNBLE9BQU9ILEtBQUssQ0FBQzFGLElBQUk7QUFDckI7QUFDQTs7OztDQUlDLEdBQUcsU0FBUytGLGdCQUFnQkMsRUFBRSxFQUFFQyxHQUFHO0lBQ2hDLElBQUlDLDJCQUEyQjtJQUMvQix1QkFBdUI7SUFDdkIsNkRBQTZEO0lBQzdELDJFQUEyRTtJQUMzRSxJQUFJLE9BQU90RSxXQUFXLGFBQWE7UUFDL0JxRSxNQUFNVCxTQUFTUztJQUNuQjtJQUNBLElBQUlFLFFBQVFILEtBQUtDO0lBQ2pCLElBQUksQ0FBQ1AsS0FBSyxDQUFDUyxNQUFNLEVBQUU7UUFDZlQsS0FBSyxDQUFDUyxNQUFNLEdBQUdGLElBQUlSLE9BQU8sQ0FBQ1MsMEJBQTBCRjtJQUN6RDtJQUNBLE9BQU9OLEtBQUssQ0FBQ1MsTUFBTTtBQUN2QjtBQUVBLFNBQVNDLGdCQUFnQnhELFFBQVEsRUFBRXlELE9BQU87SUFDdEMsSUFBSUEsWUFBWSxLQUFLLEdBQUdBLFVBQVUsQ0FBQztJQUNuQyxPQUFPekQsU0FBU3dCLEdBQUcsQ0FBQyxTQUFTa0MsSUFBSTtRQUM3QixJQUFJTixLQUFLTSxJQUFJLENBQUMsRUFBRTtRQUNoQixJQUFJTCxNQUFNSyxJQUFJLENBQUMsRUFBRTtRQUNqQixPQUFPLFdBQVcsR0FBR2xILGNBQWMsQ0FBQyxVQUFVLENBQUNtRixhQUFhLENBQUMsU0FBUztZQUNsRXlCLElBQUksT0FBT0E7WUFDWCx3Q0FBd0M7WUFDeENoRyxLQUFLLE9BQU9nRztZQUNaTyxPQUFPRixRQUFRRSxLQUFLLEdBQUdGLFFBQVFFLEtBQUssR0FBR2hGO1lBQ3ZDaUYseUJBQXlCO2dCQUNyQkMsUUFBUVI7WUFDWjtRQUNKO0lBQ0o7QUFDSjtBQUNBLElBQUlTLHFCQUFxQixXQUFXLEdBQUc7SUFDbkMsU0FBU0EsbUJBQW1CNUYsS0FBSztRQUM3QixJQUFJQyxNQUFNRCxVQUFVLEtBQUssSUFBSSxDQUFDLElBQUlBLE9BQU82RixjQUFjNUYsSUFBSTZGLFVBQVUsRUFBRUEsYUFBYUQsZ0JBQWdCLEtBQUssSUFBSSxPQUFPQSxhQUFhekYsb0JBQW9CSCxJQUFJSSxnQkFBZ0IsRUFBRUEsbUJBQW1CRCxzQkFBc0IsS0FBSyxJQUFJLFFBQVFBO1FBQ3JPLElBQUksQ0FBQzJGLE1BQU0sR0FBR0QsY0FBYyxJQUFJL0YsV0FBVztZQUN2Q0ksTUFBTTtZQUNORSxrQkFBa0JBO1FBQ3RCO1FBQ0EsSUFBSSxDQUFDMEYsTUFBTSxDQUFDeEUsTUFBTTtRQUNsQixJQUFJdUUsY0FBYyxPQUFPekYscUJBQXFCLFdBQVc7WUFDckQsSUFBSSxDQUFDMEYsTUFBTSxDQUFDM0UsbUJBQW1CLENBQUNmO1lBQ2hDLElBQUksQ0FBQ0QsaUJBQWlCLEdBQUcsSUFBSSxDQUFDMkYsTUFBTSxDQUFDdkUsa0JBQWtCO1FBQzNEO1FBQ0EsSUFBSSxDQUFDd0UsV0FBVyxHQUFHdkY7UUFDbkIsSUFBSSxDQUFDd0YsUUFBUSxHQUFHLENBQUM7UUFDakIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxDQUFDO0lBQzdCO0lBQ0EsSUFBSS9FLFNBQVN5RSxtQkFBbUJyRyxTQUFTO0lBQ3pDNEIsT0FBT2dGLEdBQUcsR0FBRyxTQUFTQSxJQUFJMUgsS0FBSztRQUMzQixJQUFJZ0QsUUFBUSxJQUFJO1FBQ2hCLElBQUloQixjQUFjLElBQUksQ0FBQ0wsaUJBQWlCLEVBQUU7WUFDdEMsSUFBSSxDQUFDQSxpQkFBaUIsR0FBR2lELE1BQU0rQyxPQUFPLENBQUMzSCxNQUFNNEgsUUFBUTtZQUNyRCxJQUFJLENBQUNOLE1BQU0sQ0FBQzNFLG1CQUFtQixDQUFDLElBQUksQ0FBQ2hCLGlCQUFpQjtZQUN0RCxJQUFJLENBQUNBLGlCQUFpQixHQUFHLElBQUksQ0FBQzJGLE1BQU0sQ0FBQ3ZFLGtCQUFrQjtRQUMzRDtRQUNBLElBQUksT0FBT1YsV0FBVyxlQUFlLENBQUMsSUFBSSxDQUFDa0YsV0FBVyxFQUFFO1lBQ3BELElBQUksQ0FBQ0EsV0FBVyxHQUFHLElBQUksQ0FBQ00sZ0JBQWdCO1lBQ3hDLElBQUksQ0FBQ0osZ0JBQWdCLEdBQUdsSCxPQUFPdUgsSUFBSSxDQUFDLElBQUksQ0FBQ1AsV0FBVyxFQUFFOUMsTUFBTSxDQUFDLFNBQVNzRCxHQUFHLEVBQUVDLE9BQU87Z0JBQzlFRCxHQUFHLENBQUNDLFFBQVEsR0FBRztnQkFDZixPQUFPRDtZQUNYLEdBQUcsQ0FBQztRQUNSO1FBQ0EsSUFBSXZHLE1BQU0sSUFBSSxDQUFDeUcsYUFBYSxDQUFDakksUUFBUWtJLFVBQVUxRyxJQUFJMEcsT0FBTyxFQUFFeEQsUUFBUWxELElBQUlrRCxLQUFLO1FBQzdFLCtDQUErQztRQUMvQyxJQUFJd0QsV0FBVyxJQUFJLENBQUNULGdCQUFnQixFQUFFO1lBQ2xDLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUNTLFFBQVEsSUFBSTtZQUNsQztRQUNKO1FBQ0EsSUFBSUMsVUFBVXpELE1BQU1HLEdBQUcsQ0FBQyxTQUFTdEIsSUFBSTtZQUNqQyxPQUFPUCxNQUFNc0UsTUFBTSxDQUFDaEUsVUFBVSxDQUFDQztRQUNuQyxHQUFFLDJCQUEyQjtTQUM1QjZFLE1BQU0sQ0FBQyxTQUFTNUUsS0FBSztZQUNsQixPQUFPQSxVQUFVLENBQUM7UUFDdEI7UUFDQSxJQUFJLENBQUNnRSxRQUFRLENBQUNVLFFBQVEsR0FBR0M7UUFDekIsSUFBSSxDQUFDVixnQkFBZ0IsQ0FBQ1MsUUFBUSxHQUFHO0lBQ3JDO0lBQ0F4RixPQUFPMkYsTUFBTSxHQUFHLFNBQVNBLE9BQU9ySSxLQUFLO1FBQ2pDLElBQUlnRCxRQUFRLElBQUk7UUFDaEIsSUFBSWtGLFVBQVUsSUFBSSxDQUFDRCxhQUFhLENBQUNqSSxPQUFPa0ksT0FBTztRQUMvQ0ksVUFBVUosV0FBVyxJQUFJLENBQUNULGdCQUFnQixFQUFFLGVBQWVTLFVBQVU7UUFDckUsSUFBSSxDQUFDVCxnQkFBZ0IsQ0FBQ1MsUUFBUSxJQUFJO1FBQ2xDLElBQUksSUFBSSxDQUFDVCxnQkFBZ0IsQ0FBQ1MsUUFBUSxHQUFHLEdBQUc7WUFDcEMsSUFBSUssZ0JBQWdCLElBQUksQ0FBQ2hCLFdBQVcsSUFBSSxJQUFJLENBQUNBLFdBQVcsQ0FBQ1csUUFBUTtZQUNqRSxJQUFJSyxlQUFlO2dCQUNmQSxjQUFjakUsVUFBVSxDQUFDQyxXQUFXLENBQUNnRTtnQkFDckMsT0FBTyxJQUFJLENBQUNoQixXQUFXLENBQUNXLFFBQVE7WUFDcEMsT0FBTztnQkFDSCxJQUFJLENBQUNWLFFBQVEsQ0FBQ1UsUUFBUSxDQUFDMUQsT0FBTyxDQUFDLFNBQVNoQixLQUFLO29CQUN6QyxPQUFPUixNQUFNc0UsTUFBTSxDQUFDM0QsVUFBVSxDQUFDSDtnQkFDbkM7Z0JBQ0EsT0FBTyxJQUFJLENBQUNnRSxRQUFRLENBQUNVLFFBQVE7WUFDakM7WUFDQSxPQUFPLElBQUksQ0FBQ1QsZ0JBQWdCLENBQUNTLFFBQVE7UUFDekM7SUFDSjtJQUNBeEYsT0FBTzhGLE1BQU0sR0FBRyxTQUFTQSxPQUFPeEksS0FBSyxFQUFFeUksU0FBUztRQUM1QyxJQUFJLENBQUNmLEdBQUcsQ0FBQ2U7UUFDVCxJQUFJLENBQUNKLE1BQU0sQ0FBQ3JJO0lBQ2hCO0lBQ0EwQyxPQUFPRyxLQUFLLEdBQUcsU0FBU0E7UUFDcEIsSUFBSSxDQUFDeUUsTUFBTSxDQUFDekUsS0FBSztRQUNqQixJQUFJLENBQUN5RSxNQUFNLENBQUN4RSxNQUFNO1FBQ2xCLElBQUksQ0FBQ3lFLFdBQVcsR0FBR3ZGO1FBQ25CLElBQUksQ0FBQ3dGLFFBQVEsR0FBRyxDQUFDO1FBQ2pCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsQ0FBQztJQUM3QjtJQUNBL0UsT0FBT1csUUFBUSxHQUFHLFNBQVNBO1FBQ3ZCLElBQUlMLFFBQVEsSUFBSTtRQUNoQixJQUFJMEYsYUFBYSxJQUFJLENBQUNuQixXQUFXLEdBQUdoSCxPQUFPdUgsSUFBSSxDQUFDLElBQUksQ0FBQ1AsV0FBVyxFQUFFMUMsR0FBRyxDQUFDLFNBQVNxRCxPQUFPO1lBQ2xGLE9BQU87Z0JBQ0hBO2dCQUNBbEYsTUFBTXVFLFdBQVcsQ0FBQ1csUUFBUTthQUM3QjtRQUNMLEtBQUssRUFBRTtRQUNQLElBQUk3RSxXQUFXLElBQUksQ0FBQ2lFLE1BQU0sQ0FBQ2pFLFFBQVE7UUFDbkMsT0FBT3FGLFdBQVcvRCxNQUFNLENBQUNwRSxPQUFPdUgsSUFBSSxDQUFDLElBQUksQ0FBQ04sUUFBUSxFQUFFM0MsR0FBRyxDQUFDLFNBQVNxRCxPQUFPO1lBQ3BFLE9BQU87Z0JBQ0hBO2dCQUNBbEYsTUFBTXdFLFFBQVEsQ0FBQ1UsUUFBUSxDQUFDckQsR0FBRyxDQUFDLFNBQVNyQixLQUFLO29CQUN0QyxPQUFPSCxRQUFRLENBQUNHLE1BQU0sQ0FBQ0MsT0FBTztnQkFDbEMsR0FBR2tGLElBQUksQ0FBQzNGLE1BQU1yQixpQkFBaUIsR0FBRyxLQUFLO2FBQzFDO1FBQ0wsR0FBRSx5QkFBeUI7U0FDMUJ5RyxNQUFNLENBQUMsU0FBUzdFLElBQUk7WUFDakIsT0FBT3FGLFFBQVFyRixJQUFJLENBQUMsRUFBRTtRQUMxQjtJQUNKO0lBQ0FiLE9BQU9tRyxNQUFNLEdBQUcsU0FBU0EsT0FBTy9CLE9BQU87UUFDbkMsT0FBT0QsZ0JBQWdCLElBQUksQ0FBQ3hELFFBQVEsSUFBSXlEO0lBQzVDO0lBQ0FwRSxPQUFPdUYsYUFBYSxHQUFHLFNBQVNBLGNBQWNqSSxLQUFLO1FBQy9DLElBQUkwRyxNQUFNMUcsTUFBTTRILFFBQVEsRUFBRWtCLFVBQVU5SSxNQUFNOEksT0FBTyxFQUFFckMsS0FBS3pHLE1BQU15RyxFQUFFO1FBQ2hFLElBQUlxQyxTQUFTO1lBQ1QsSUFBSVosVUFBVTlCLFVBQVVLLElBQUlxQztZQUM1QixPQUFPO2dCQUNIWixTQUFTQTtnQkFDVHhELE9BQU9FLE1BQU0rQyxPQUFPLENBQUNqQixPQUFPQSxJQUFJN0IsR0FBRyxDQUFDLFNBQVN0QixJQUFJO29CQUM3QyxPQUFPaUQsZ0JBQWdCMEIsU0FBUzNFO2dCQUNwQyxLQUFLO29CQUNEaUQsZ0JBQWdCMEIsU0FBU3hCO2lCQUM1QjtZQUNMO1FBQ0o7UUFDQSxPQUFPO1lBQ0h3QixTQUFTOUIsVUFBVUs7WUFDbkIvQixPQUFPRSxNQUFNK0MsT0FBTyxDQUFDakIsT0FBT0EsTUFBTTtnQkFDOUJBO2FBQ0g7UUFDTDtJQUNKO0lBQ0E7Ozs7R0FJRCxHQUFHaEUsT0FBT21GLGdCQUFnQixHQUFHLFNBQVNBO1FBQ2pDLElBQUlrQixXQUFXbkUsTUFBTTlELFNBQVMsQ0FBQ2tJLEtBQUssQ0FBQzNILElBQUksQ0FBQ2lCLFNBQVMyRyxnQkFBZ0IsQ0FBQztRQUNwRSxPQUFPRixTQUFTdEUsTUFBTSxDQUFDLFNBQVNzRCxHQUFHLEVBQUVtQixPQUFPO1lBQ3hDLElBQUl6QyxLQUFLeUMsUUFBUXpDLEVBQUUsQ0FBQ3VDLEtBQUssQ0FBQztZQUMxQmpCLEdBQUcsQ0FBQ3RCLEdBQUcsR0FBR3lDO1lBQ1YsT0FBT25CO1FBQ1gsR0FBRyxDQUFDO0lBQ1I7SUFDQSxPQUFPWjtBQUNYO0FBQ0EsU0FBU21CLFVBQVU3QyxTQUFTLEVBQUVDLE9BQU87SUFDakMsSUFBSSxDQUFDRCxXQUFXO1FBQ1osTUFBTSxJQUFJRSxNQUFNLHlCQUF5QkQsVUFBVTtJQUN2RDtBQUNKO0FBQ0EsSUFBSXlELG9CQUFvQixXQUFXLEdBQUd6SixNQUFNMEosYUFBYSxDQUFDO0FBQzFERCxrQkFBa0JFLFdBQVcsR0FBRztBQUNoQyxTQUFTQztJQUNMLE9BQU8sSUFBSW5DO0FBQ2Y7QUFDQSxTQUFTb0MsY0FBY2hJLEtBQUs7O0lBQ3hCLElBQUlpSSxxQkFBcUJqSSxNQUFNa0ksUUFBUSxFQUFFN0IsV0FBV3JHLE1BQU1xRyxRQUFRO0lBQ2xFLElBQUk4QixlQUFlaEssTUFBTWlLLFVBQVUsQ0FBQ1I7SUFDcEMsSUFBSTNILE1BQU05QixNQUFNa0ssUUFBUTt1Q0FBQztZQUNyQixPQUFPRixnQkFBZ0JGLHNCQUFzQkY7UUFDakQ7dUNBQUlHLFdBQVdqSSxHQUFHLENBQUMsRUFBRTtJQUNyQixPQUFPLFdBQVcsR0FBRzNCLGNBQWMsQ0FBQyxVQUFVLENBQUNtRixhQUFhLENBQUNtRSxrQkFBa0JVLFFBQVEsRUFBRTtRQUNyRkMsT0FBT0w7SUFDWCxHQUFHN0I7QUFDUDtHQVRTMkI7TUFBQUE7QUFVVCxTQUFTUTs7SUFDTCxPQUFPckssTUFBTWlLLFVBQVUsQ0FBQ1I7QUFDNUI7SUFGU1k7QUFJVCx3RkFBd0Y7QUFDeEYsc0RBQXNEO0FBQ3RELElBQUlDLHFCQUFxQm5LLGNBQWMsQ0FBQyxVQUFVLENBQUNtSyxrQkFBa0IsSUFBSW5LLGNBQWMsQ0FBQyxVQUFVLENBQUNvSyxlQUFlO0FBQ2xILElBQUlDLGtCQUFrQixPQUFPN0gsV0FBVyxjQUFjaUgsd0JBQXdCdEg7QUFDOUUsU0FBU21JLFNBQVNuSyxLQUFLOztJQUNuQixJQUFJeUosV0FBV1Msa0JBQWtCQSxrQkFBa0JIO0lBQ25ELG9EQUFvRDtJQUNwRCxJQUFJLENBQUNOLFVBQVU7UUFDWCxPQUFPO0lBQ1g7SUFDQSxJQUFJLE9BQU9wSCxXQUFXLGFBQWE7UUFDL0JvSCxTQUFTL0IsR0FBRyxDQUFDMUg7UUFDYixPQUFPO0lBQ1g7SUFDQWdLO3VDQUFtQjtZQUNmUCxTQUFTL0IsR0FBRyxDQUFDMUg7WUFDYjsrQ0FBTztvQkFDSHlKLFNBQVNwQixNQUFNLENBQUNySTtnQkFDcEI7O1FBQ0osd0VBQXdFO1FBQ3hFO3NDQUFHO1FBQ0NBLE1BQU15RyxFQUFFO1FBQ1JGLE9BQU92RyxNQUFNOEksT0FBTztLQUN2QjtJQUNELE9BQU87QUFDWDtJQXJCU3FCOztRQUM4Q0o7UUFTbkRDOzs7TUFWS0c7QUFzQlRBLFNBQVNyQixPQUFPLEdBQUcsU0FBU3NCLElBQUk7SUFDNUIsT0FBT0EsS0FBS3ZGLEdBQUcsQ0FBQyxTQUFTd0YsT0FBTztRQUM1QixJQUFJaEUsU0FBU2dFLE9BQU8sQ0FBQyxFQUFFO1FBQ3ZCLElBQUlySyxRQUFRcUssT0FBTyxDQUFDLEVBQUU7UUFDdEIsT0FBT2pFLFVBQVVDLFFBQVFyRztJQUM3QixHQUFHMkksSUFBSSxDQUFDO0FBQ1o7QUFFQTJCLHFCQUFxQixHQUFHZjtBQUN4QmUsMkJBQTJCLEdBQUdoQjtBQUM5QmdCLGFBQWEsR0FBR0g7QUFDaEJHLHdCQUF3QixHQUFHUCIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL3N0eWxlZC1qc3gvZGlzdC9pbmRleC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCdjbGllbnQtb25seScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koUmVhY3QpO1xuXG4vKlxuQmFzZWQgb24gR2xhbW9yJ3Mgc2hlZXRcbmh0dHBzOi8vZ2l0aHViLmNvbS90aHJlZXBvaW50b25lL2dsYW1vci9ibG9iLzY2N2I0ODBkMzFiMzcyMWE5MDUwMjFiMjZlMTI5MGNlOTJjYTI4Nzkvc3JjL3NoZWV0LmpzXG4qLyBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbnZhciBpc1Byb2QgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbn07XG52YXIgU3R5bGVTaGVldCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVTaGVldChwYXJhbSkge1xuICAgICAgICB2YXIgcmVmID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW0sIF9uYW1lID0gcmVmLm5hbWUsIG5hbWUgPSBfbmFtZSA9PT0gdm9pZCAwID8gXCJzdHlsZXNoZWV0XCIgOiBfbmFtZSwgX29wdGltaXplRm9yU3BlZWQgPSByZWYub3B0aW1pemVGb3JTcGVlZCwgb3B0aW1pemVGb3JTcGVlZCA9IF9vcHRpbWl6ZUZvclNwZWVkID09PSB2b2lkIDAgPyBpc1Byb2QgOiBfb3B0aW1pemVGb3JTcGVlZDtcbiAgICAgICAgaW52YXJpYW50JDEoaXNTdHJpbmcobmFtZSksIFwiYG5hbWVgIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyID0gXCIjXCIgKyBuYW1lICsgXCItZGVsZXRlZC1ydWxlX19fX3t9XCI7XG4gICAgICAgIGludmFyaWFudCQxKHR5cGVvZiBvcHRpbWl6ZUZvclNwZWVkID09PSBcImJvb2xlYW5cIiwgXCJgb3B0aW1pemVGb3JTcGVlZGAgbXVzdCBiZSBhIGJvb2xlYW5cIik7XG4gICAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSBvcHRpbWl6ZUZvclNwZWVkO1xuICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGFncyA9IFtdO1xuICAgICAgICB0aGlzLl9pbmplY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ydWxlc0NvdW50ID0gMDtcbiAgICAgICAgdmFyIG5vZGUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbcHJvcGVydHk9XCJjc3Atbm9uY2VcIl0nKTtcbiAgICAgICAgdGhpcy5fbm9uY2UgPSBub2RlID8gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuICAgIF9wcm90by5zZXRPcHRpbWl6ZUZvclNwZWVkID0gZnVuY3Rpb24gc2V0T3B0aW1pemVGb3JTcGVlZChib29sKSB7XG4gICAgICAgIGludmFyaWFudCQxKHR5cGVvZiBib29sID09PSBcImJvb2xlYW5cIiwgXCJgc2V0T3B0aW1pemVGb3JTcGVlZGAgYWNjZXB0cyBhIGJvb2xlYW5cIik7XG4gICAgICAgIGludmFyaWFudCQxKHRoaXMuX3J1bGVzQ291bnQgPT09IDAsIFwib3B0aW1pemVGb3JTcGVlZCBjYW5ub3QgYmUgd2hlbiBydWxlcyBoYXZlIGFscmVhZHkgYmVlbiBpbnNlcnRlZFwiKTtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gYm9vbDtcbiAgICAgICAgdGhpcy5pbmplY3QoKTtcbiAgICB9O1xuICAgIF9wcm90by5pc09wdGltaXplRm9yU3BlZWQgPSBmdW5jdGlvbiBpc09wdGltaXplRm9yU3BlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkO1xuICAgIH07XG4gICAgX3Byb3RvLmluamVjdCA9IGZ1bmN0aW9uIGluamVjdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaW52YXJpYW50JDEoIXRoaXMuX2luamVjdGVkLCBcInNoZWV0IGFscmVhZHkgaW5qZWN0ZWRcIik7XG4gICAgICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5fdGFnc1swXSA9IHRoaXMubWFrZVN0eWxlVGFnKHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IFwiaW5zZXJ0UnVsZVwiIGluIHRoaXMuZ2V0U2hlZXQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0eWxlU2hlZXQ6IG9wdGltaXplRm9yU3BlZWQgbW9kZSBub3Qgc3VwcG9ydGVkIGZhbGxpbmcgYmFjayB0byBzdGFuZGFyZCBtb2RlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldCA9IHtcbiAgICAgICAgICAgIGNzc1J1bGVzOiBbXSxcbiAgICAgICAgICAgIGluc2VydFJ1bGU6IGZ1bmN0aW9uKHJ1bGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXNbaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dDogcnVsZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHQ6IHJ1bGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVSdWxlOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmdldFNoZWV0Rm9yVGFnID0gZnVuY3Rpb24gZ2V0U2hlZXRGb3JUYWcodGFnKSB7XG4gICAgICAgIGlmICh0YWcuc2hlZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcuc2hlZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyB3ZWlyZG5lc3MgYnJvdWdodCB0byB5b3UgYnkgZmlyZWZveFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldLm93bmVyTm9kZSA9PT0gdGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0U2hlZXQgPSBmdW5jdGlvbiBnZXRTaGVldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hlZXRGb3JUYWcodGhpcy5fdGFnc1t0aGlzLl90YWdzLmxlbmd0aCAtIDFdKTtcbiAgICB9O1xuICAgIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlLCBpbmRleCkge1xuICAgICAgICBpbnZhcmlhbnQkMShpc1N0cmluZyhydWxlKSwgXCJgaW5zZXJ0UnVsZWAgYWNjZXB0cyBvbmx5IHN0cmluZ3NcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQpIHtcbiAgICAgICAgICAgIHZhciBzaGVldCA9IHRoaXMuZ2V0U2hlZXQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgd2VpcmRuZXNzIGZvciBwZXJmLCBhbmQgY2hyb21lJ3Mgd2VpcmQgYnVnXG4gICAgICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDAwNzk5Mi9jaHJvbWUtc3VkZGVubHktc3RvcHBlZC1hY2NlcHRpbmctaW5zZXJ0cnVsZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Byb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3R5bGVTaGVldDogaWxsZWdhbCBydWxlOiBcXG5cXG5cIiArIHJ1bGUgKyBcIlxcblxcblNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMjAwMDc5OTIgZm9yIG1vcmUgaW5mb1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc2VydGlvblBvaW50ID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLl90YWdzLnB1c2godGhpcy5tYWtlU3R5bGVUYWcodGhpcy5fbmFtZSwgcnVsZSwgaW5zZXJ0aW9uUG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcnVsZXNDb3VudCsrO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VSdWxlID0gZnVuY3Rpb24gcmVwbGFjZVJ1bGUoaW5kZXgsIHJ1bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFyIHNoZWV0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMuZ2V0U2hlZXQoKSA6IHRoaXMuX3NlcnZlclNoZWV0O1xuICAgICAgICAgICAgaWYgKCFydWxlLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIHJ1bGUgPSB0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaGVldC5jc3NSdWxlc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvLyBAVEJEIFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0eWxlU2hlZXQ6IGlsbGVnYWwgcnVsZTogXFxuXFxuXCIgKyBydWxlICsgXCJcXG5cXG5TZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzIwMDA3OTkyIGZvciBtb3JlIGluZm9cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSBpbmRpY2VzIHdlIGluc2VydCBhIGRlbGV0ZVJ1bGVQbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUodGhpcy5fZGVsZXRlZFJ1bGVQbGFjZWhvbGRlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHRoaXMuX3RhZ3NbaW5kZXhdO1xuICAgICAgICAgICAgaW52YXJpYW50JDEodGFnLCBcIm9sZCBydWxlIGF0IGluZGV4IGBcIiArIGluZGV4ICsgXCJgIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIHRhZy50ZXh0Q29udGVudCA9IHJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKGluZGV4KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUnVsZShpbmRleCwgXCJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgICAgICBpbnZhcmlhbnQkMSh0YWcsIFwicnVsZSBhdCBpbmRleCBgXCIgKyBpbmRleCArIFwiYCBub3QgZm91bmRcIik7XG4gICAgICAgICAgICB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgICAgICAgICAgdGhpcy5fdGFnc1tpbmRleF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5faW5qZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcnVsZXNDb3VudCA9IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl90YWdzLmZvckVhY2goZnVuY3Rpb24odGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZyAmJiB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl90YWdzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzaW1wbGVyIG9uIHNlcnZlclxuICAgICAgICAgICAgdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNzc1J1bGVzID0gZnVuY3Rpb24gY3NzUnVsZXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ3MucmVkdWNlKGZ1bmN0aW9uKHJ1bGVzLCB0YWcpIHtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICBydWxlcyA9IHJ1bGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoX3RoaXMuZ2V0U2hlZXRGb3JUYWcodGFnKS5jc3NSdWxlcywgZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVsZS5jc3NUZXh0ID09PSBfdGhpcy5fZGVsZXRlZFJ1bGVQbGFjZWhvbGRlciA/IG51bGwgOiBydWxlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVsZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlcztcbiAgICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgX3Byb3RvLm1ha2VTdHlsZVRhZyA9IGZ1bmN0aW9uIG1ha2VTdHlsZVRhZyhuYW1lLCBjc3NTdHJpbmcsIHJlbGF0aXZlVG9UYWcpIHtcbiAgICAgICAgaWYgKGNzc1N0cmluZykge1xuICAgICAgICAgICAgaW52YXJpYW50JDEoaXNTdHJpbmcoY3NzU3RyaW5nKSwgXCJtYWtlU3R5bGVUYWcgYWNjZXB0cyBvbmx5IHN0cmluZ3MgYXMgc2Vjb25kIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBpZiAodGhpcy5fbm9uY2UpIHRhZy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCB0aGlzLl9ub25jZSk7XG4gICAgICAgIHRhZy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgICB0YWcuc2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIG5hbWUsIFwiXCIpO1xuICAgICAgICBpZiAoY3NzU3RyaW5nKSB7XG4gICAgICAgICAgICB0YWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgICAgICAgaWYgKHJlbGF0aXZlVG9UYWcpIHtcbiAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHRhZywgcmVsYXRpdmVUb1RhZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhTdHlsZVNoZWV0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJsZW5ndGhcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5mdW5jdGlvbiBpbnZhcmlhbnQkMShjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZVNoZWV0OiBcIiArIG1lc3NhZ2UgKyBcIi5cIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIHZhciBfJGhhc2ggPSA1MzgxLCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZShpKXtcbiAgICAgICAgXyRoYXNoID0gXyRoYXNoICogMzMgXiBzdHIuY2hhckNvZGVBdCgtLWkpO1xuICAgIH1cbiAgICAvKiBKYXZhU2NyaXB0IGRvZXMgYml0d2lzZSBvcGVyYXRpb25zIChsaWtlIFhPUiwgYWJvdmUpIG9uIDMyLWJpdCBzaWduZWRcbiAgICogaW50ZWdlcnMuIFNpbmNlIHdlIHdhbnQgdGhlIHJlc3VsdHMgdG8gYmUgYWx3YXlzIHBvc2l0aXZlLCBjb252ZXJ0IHRoZVxuICAgKiBzaWduZWQgaW50IHRvIGFuIHVuc2lnbmVkIGJ5IGRvaW5nIGFuIHVuc2lnbmVkIGJpdHNoaWZ0LiAqLyByZXR1cm4gXyRoYXNoID4+PiAwO1xufVxudmFyIHN0cmluZ0hhc2ggPSBoYXNoO1xuXG52YXIgc2FuaXRpemUgPSBmdW5jdGlvbihydWxlKSB7XG4gICAgcmV0dXJuIHJ1bGUucmVwbGFjZSgvXFwvc3R5bGUvZ2ksIFwiXFxcXC9zdHlsZVwiKTtcbn07XG52YXIgY2FjaGUgPSB7fTtcbi8qKlxuICogY29tcHV0ZUlkXG4gKlxuICogQ29tcHV0ZSBhbmQgbWVtb2l6ZSBhIGpzeCBpZCBmcm9tIGEgYmFzZWRJZCBhbmQgb3B0aW9uYWxseSBwcm9wcy5cbiAqLyBmdW5jdGlvbiBjb21wdXRlSWQoYmFzZUlkLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIFwianN4LVwiICsgYmFzZUlkO1xuICAgIH1cbiAgICB2YXIgcHJvcHNUb1N0cmluZyA9IFN0cmluZyhwcm9wcyk7XG4gICAgdmFyIGtleSA9IGJhc2VJZCArIHByb3BzVG9TdHJpbmc7XG4gICAgaWYgKCFjYWNoZVtrZXldKSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSBcImpzeC1cIiArIHN0cmluZ0hhc2goYmFzZUlkICsgXCItXCIgKyBwcm9wc1RvU3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2tleV07XG59XG4vKipcbiAqIGNvbXB1dGVTZWxlY3RvclxuICpcbiAqIENvbXB1dGUgYW5kIG1lbW9pemUgZHluYW1pYyBzZWxlY3RvcnMuXG4gKi8gZnVuY3Rpb24gY29tcHV0ZVNlbGVjdG9yKGlkLCBjc3MpIHtcbiAgICB2YXIgc2VsZWN0b1BsYWNlaG9sZGVyUmVnZXhwID0gL19fanN4LXN0eWxlLWR5bmFtaWMtc2VsZWN0b3IvZztcbiAgICAvLyBTYW5pdGl6ZSBTU1ItZWQgQ1NTLlxuICAgIC8vIENsaWVudCBzaWRlIGNvZGUgZG9lc24ndCBuZWVkIHRvIGJlIHNhbml0aXplZCBzaW5jZSB3ZSB1c2VcbiAgICAvLyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSAoZGV2KSBhbmQgdGhlIENTU09NIGFwaSBzaGVldC5pbnNlcnRSdWxlIChwcm9kKS5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjc3MgPSBzYW5pdGl6ZShjc3MpO1xuICAgIH1cbiAgICB2YXIgaWRjc3MgPSBpZCArIGNzcztcbiAgICBpZiAoIWNhY2hlW2lkY3NzXSkge1xuICAgICAgICBjYWNoZVtpZGNzc10gPSBjc3MucmVwbGFjZShzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAsIGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2lkY3NzXTtcbn1cblxuZnVuY3Rpb24gbWFwUnVsZXNUb1N0eWxlKGNzc1J1bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgIHJldHVybiBjc3NSdWxlcy5tYXAoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaWQgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgY3NzID0gYXJnc1sxXTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7XG4gICAgICAgICAgICBpZDogXCJfX1wiICsgaWQsXG4gICAgICAgICAgICAvLyBBdm9pZCB3YXJuaW5ncyB1cG9uIHJlbmRlciB3aXRoIGEga2V5XG4gICAgICAgICAgICBrZXk6IFwiX19cIiArIGlkLFxuICAgICAgICAgICAgbm9uY2U6IG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgICAgICBfX2h0bWw6IGNzc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbnZhciBTdHlsZVNoZWV0UmVnaXN0cnkgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlU2hlZXRSZWdpc3RyeShwYXJhbSkge1xuICAgICAgICB2YXIgcmVmID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW0sIF9zdHlsZVNoZWV0ID0gcmVmLnN0eWxlU2hlZXQsIHN0eWxlU2hlZXQgPSBfc3R5bGVTaGVldCA9PT0gdm9pZCAwID8gbnVsbCA6IF9zdHlsZVNoZWV0LCBfb3B0aW1pemVGb3JTcGVlZCA9IHJlZi5vcHRpbWl6ZUZvclNwZWVkLCBvcHRpbWl6ZUZvclNwZWVkID0gX29wdGltaXplRm9yU3BlZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGltaXplRm9yU3BlZWQ7XG4gICAgICAgIHRoaXMuX3NoZWV0ID0gc3R5bGVTaGVldCB8fCBuZXcgU3R5bGVTaGVldCh7XG4gICAgICAgICAgICBuYW1lOiBcInN0eWxlZC1qc3hcIixcbiAgICAgICAgICAgIG9wdGltaXplRm9yU3BlZWQ6IG9wdGltaXplRm9yU3BlZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NoZWV0LmluamVjdCgpO1xuICAgICAgICBpZiAoc3R5bGVTaGVldCAmJiB0eXBlb2Ygb3B0aW1pemVGb3JTcGVlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoZWV0LnNldE9wdGltaXplRm9yU3BlZWQob3B0aW1pemVGb3JTcGVlZCk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gdGhpcy5fc2hlZXQuaXNPcHRpbWl6ZUZvclNwZWVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnJvbVNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSB7fTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXRSZWdpc3RyeS5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB0aGlzLl9zaGVldC5zZXRPcHRpbWl6ZUZvclNwZWVkKHRoaXMuX29wdGltaXplRm9yU3BlZWQpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IHRoaXMuX3NoZWV0LmlzT3B0aW1pemVGb3JTcGVlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICF0aGlzLl9mcm9tU2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mcm9tU2VydmVyID0gdGhpcy5zZWxlY3RGcm9tU2VydmVyKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSBPYmplY3Qua2V5cyh0aGlzLl9mcm9tU2VydmVyKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgYWNjW3RhZ05hbWVdID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSB0aGlzLmdldElkQW5kUnVsZXMocHJvcHMpLCBzdHlsZUlkID0gcmVmLnN0eWxlSWQsIHJ1bGVzID0gcmVmLnJ1bGVzO1xuICAgICAgICAvLyBEZWR1cGluZzoganVzdCBpbmNyZWFzZSB0aGUgaW5zdGFuY2VzIGNvdW50LlxuICAgICAgICBpZiAoc3R5bGVJZCBpbiB0aGlzLl9pbnN0YW5jZXNDb3VudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSArPSAxO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRpY2VzID0gcnVsZXMubWFwKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2hlZXQuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgICAgfSkvLyBGaWx0ZXIgb3V0IGludmFsaWQgcnVsZXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4ICE9PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2luZGljZXNbc3R5bGVJZF0gPSBpbmRpY2VzO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gPSAxO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3R5bGVJZCA9IHRoaXMuZ2V0SWRBbmRSdWxlcyhwcm9wcykuc3R5bGVJZDtcbiAgICAgICAgaW52YXJpYW50KHN0eWxlSWQgaW4gdGhpcy5faW5zdGFuY2VzQ291bnRzLCBcInN0eWxlSWQ6IGBcIiArIHN0eWxlSWQgKyBcImAgbm90IGZvdW5kXCIpO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gLT0gMTtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSA8IDEpIHtcbiAgICAgICAgICAgIHZhciB0YWdGcm9tU2VydmVyID0gdGhpcy5fZnJvbVNlcnZlciAmJiB0aGlzLl9mcm9tU2VydmVyW3N0eWxlSWRdO1xuICAgICAgICAgICAgaWYgKHRhZ0Zyb21TZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0YWdGcm9tU2VydmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFnRnJvbVNlcnZlcik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Zyb21TZXJ2ZXJbc3R5bGVJZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGljZXNbc3R5bGVJZF0uZm9yRWFjaChmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3NoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbmRpY2VzW3N0eWxlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShwcm9wcywgbmV4dFByb3BzKSB7XG4gICAgICAgIHRoaXMuYWRkKG5leHRQcm9wcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKHByb3BzKTtcbiAgICB9O1xuICAgIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICB0aGlzLl9zaGVldC5mbHVzaCgpO1xuICAgICAgICB0aGlzLl9zaGVldC5pbmplY3QoKTtcbiAgICAgICAgdGhpcy5fZnJvbVNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSB7fTtcbiAgICB9O1xuICAgIF9wcm90by5jc3NSdWxlcyA9IGZ1bmN0aW9uIGNzc1J1bGVzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZnJvbVNlcnZlciA9IHRoaXMuX2Zyb21TZXJ2ZXIgPyBPYmplY3Qua2V5cyh0aGlzLl9mcm9tU2VydmVyKS5tYXAoZnVuY3Rpb24oc3R5bGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICAgIF90aGlzLl9mcm9tU2VydmVyW3N0eWxlSWRdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSA6IFtdO1xuICAgICAgICB2YXIgY3NzUnVsZXMgPSB0aGlzLl9zaGVldC5jc3NSdWxlcygpO1xuICAgICAgICByZXR1cm4gZnJvbVNlcnZlci5jb25jYXQoT2JqZWN0LmtleXModGhpcy5faW5kaWNlcykubWFwKGZ1bmN0aW9uKHN0eWxlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc3R5bGVJZCxcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5kaWNlc1tzdHlsZUlkXS5tYXAoZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNzc1J1bGVzW2luZGV4XS5jc3NUZXh0O1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oX3RoaXMuX29wdGltaXplRm9yU3BlZWQgPyBcIlwiIDogXCJcXG5cIilcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pLy8gZmlsdGVyIG91dCBlbXB0eSBydWxlc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHJ1bGVbMV0pO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG1hcFJ1bGVzVG9TdHlsZSh0aGlzLmNzc1J1bGVzKCksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldElkQW5kUnVsZXMgPSBmdW5jdGlvbiBnZXRJZEFuZFJ1bGVzKHByb3BzKSB7XG4gICAgICAgIHZhciBjc3MgPSBwcm9wcy5jaGlsZHJlbiwgZHluYW1pYyA9IHByb3BzLmR5bmFtaWMsIGlkID0gcHJvcHMuaWQ7XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVJZCA9IGNvbXB1dGVJZChpZCwgZHluYW1pYyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgcnVsZXM6IEFycmF5LmlzQXJyYXkoY3NzKSA/IGNzcy5tYXAoZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcHV0ZVNlbGVjdG9yKHN0eWxlSWQsIHJ1bGUpO1xuICAgICAgICAgICAgICAgIH0pIDogW1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2VsZWN0b3Ioc3R5bGVJZCwgY3NzKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0eWxlSWQ6IGNvbXB1dGVJZChpZCksXG4gICAgICAgICAgICBydWxlczogQXJyYXkuaXNBcnJheShjc3MpID8gY3NzIDogW1xuICAgICAgICAgICAgICAgIGNzc1xuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAqIHNlbGVjdEZyb21TZXJ2ZXJcbiAgICpcbiAgICogQ29sbGVjdHMgc3R5bGUgdGFncyBmcm9tIHRoZSBkb2N1bWVudCB3aXRoIGlkIF9fanN4LVhYWFxuICAgKi8gX3Byb3RvLnNlbGVjdEZyb21TZXJ2ZXIgPSBmdW5jdGlvbiBzZWxlY3RGcm9tU2VydmVyKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaWRePVwiX19qc3gtXCJdJykpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGlkID0gZWxlbWVudC5pZC5zbGljZSgyKTtcbiAgICAgICAgICAgIGFjY1tpZF0gPSBlbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlU2hlZXRSZWdpc3RyeTtcbn0oKTtcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZVNoZWV0UmVnaXN0cnk6IFwiICsgbWVzc2FnZSArIFwiLlwiKTtcbiAgICB9XG59XG52YXIgU3R5bGVTaGVldENvbnRleHQgPSAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5TdHlsZVNoZWV0Q29udGV4dC5kaXNwbGF5TmFtZSA9IFwiU3R5bGVTaGVldENvbnRleHRcIjtcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlUmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZVNoZWV0UmVnaXN0cnkoKTtcbn1cbmZ1bmN0aW9uIFN0eWxlUmVnaXN0cnkocGFyYW0pIHtcbiAgICB2YXIgY29uZmlndXJlZFJlZ2lzdHJ5ID0gcGFyYW0ucmVnaXN0cnksIGNoaWxkcmVuID0gcGFyYW0uY2hpbGRyZW47XG4gICAgdmFyIHJvb3RSZWdpc3RyeSA9IFJlYWN0LnVzZUNvbnRleHQoU3R5bGVTaGVldENvbnRleHQpO1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RSZWdpc3RyeSB8fCBjb25maWd1cmVkUmVnaXN0cnkgfHwgY3JlYXRlU3R5bGVSZWdpc3RyeSgpO1xuICAgIH0pLCByZWdpc3RyeSA9IHJlZlswXTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChTdHlsZVNoZWV0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcmVnaXN0cnlcbiAgICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiB1c2VTdHlsZVJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFN0eWxlU2hlZXRDb250ZXh0KTtcbn1cblxuLy8gT3B0LWludG8gdGhlIG5ldyBgdXNlSW5zZXJ0aW9uRWZmZWN0YCBBUEkgaW4gUmVhY3QgMTgsIGZhbGxiYWNrIHRvIGB1c2VMYXlvdXRFZmZlY3RgLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvMTEwXG52YXIgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnVzZUluc2VydGlvbkVmZmVjdCB8fCBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlTGF5b3V0RWZmZWN0O1xudmFyIGRlZmF1bHRSZWdpc3RyeSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBjcmVhdGVTdHlsZVJlZ2lzdHJ5KCkgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBKU1hTdHlsZShwcm9wcykge1xuICAgIHZhciByZWdpc3RyeSA9IGRlZmF1bHRSZWdpc3RyeSA/IGRlZmF1bHRSZWdpc3RyeSA6IHVzZVN0eWxlUmVnaXN0cnkoKTtcbiAgICAvLyBJZiBgcmVnaXN0cnlgIGRvZXMgbm90IGV4aXN0LCB3ZSBkbyBub3RoaW5nIGhlcmUuXG4gICAgaWYgKCFyZWdpc3RyeSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmVnaXN0cnkuYWRkKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHVzZUluc2VydGlvbkVmZmVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVnaXN0cnkuYWRkKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVnaXN0cnkucmVtb3ZlKHByb3BzKTtcbiAgICAgICAgfTtcbiAgICAvLyBwcm9wcy5jaGlsZHJlbiBjYW4gYmUgc3RyaW5nW10sIHdpbGwgYmUgc3RyaXBlZCBzaW5jZSBpZCBpcyBpZGVudGljYWxcbiAgICB9LCBbXG4gICAgICAgIHByb3BzLmlkLFxuICAgICAgICBTdHJpbmcocHJvcHMuZHluYW1pYylcbiAgICBdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbkpTWFN0eWxlLmR5bmFtaWMgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8ubWFwKGZ1bmN0aW9uKHRhZ0luZm8pIHtcbiAgICAgICAgdmFyIGJhc2VJZCA9IHRhZ0luZm9bMF07XG4gICAgICAgIHZhciBwcm9wcyA9IHRhZ0luZm9bMV07XG4gICAgICAgIHJldHVybiBjb21wdXRlSWQoYmFzZUlkLCBwcm9wcyk7XG4gICAgfSkuam9pbihcIiBcIik7XG59O1xuXG5leHBvcnRzLlN0eWxlUmVnaXN0cnkgPSBTdHlsZVJlZ2lzdHJ5O1xuZXhwb3J0cy5jcmVhdGVTdHlsZVJlZ2lzdHJ5ID0gY3JlYXRlU3R5bGVSZWdpc3RyeTtcbmV4cG9ydHMuc3R5bGUgPSBKU1hTdHlsZTtcbmV4cG9ydHMudXNlU3R5bGVSZWdpc3RyeSA9IHVzZVN0eWxlUmVnaXN0cnk7XG4iXSwibmFtZXMiOlsicmVxdWlyZSIsIlJlYWN0IiwiX2ludGVyb3BEZWZhdWx0TGVnYWN5IiwiZSIsIlJlYWN0X19kZWZhdWx0IiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsImlzUHJvZCIsInByb2Nlc3MiLCJlbnYiLCJpc1N0cmluZyIsIm8iLCJ0b1N0cmluZyIsImNhbGwiLCJTdHlsZVNoZWV0IiwicGFyYW0iLCJyZWYiLCJfbmFtZSIsIm5hbWUiLCJfb3B0aW1pemVGb3JTcGVlZCIsIm9wdGltaXplRm9yU3BlZWQiLCJpbnZhcmlhbnQkMSIsIl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyIiwiX3NlcnZlclNoZWV0IiwidW5kZWZpbmVkIiwiX3RhZ3MiLCJfaW5qZWN0ZWQiLCJfcnVsZXNDb3VudCIsIm5vZGUiLCJ3aW5kb3ciLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJfbm9uY2UiLCJnZXRBdHRyaWJ1dGUiLCJfcHJvdG8iLCJzZXRPcHRpbWl6ZUZvclNwZWVkIiwiYm9vbCIsImZsdXNoIiwiaW5qZWN0IiwiaXNPcHRpbWl6ZUZvclNwZWVkIiwiX3RoaXMiLCJtYWtlU3R5bGVUYWciLCJnZXRTaGVldCIsImNvbnNvbGUiLCJ3YXJuIiwiY3NzUnVsZXMiLCJpbnNlcnRSdWxlIiwicnVsZSIsImluZGV4IiwiY3NzVGV4dCIsInB1c2giLCJkZWxldGVSdWxlIiwiZ2V0U2hlZXRGb3JUYWciLCJ0YWciLCJzaGVldCIsInN0eWxlU2hlZXRzIiwib3duZXJOb2RlIiwiZXJyb3IiLCJpbnNlcnRpb25Qb2ludCIsInJlcGxhY2VSdWxlIiwidHJpbSIsInRleHRDb250ZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZm9yRWFjaCIsInJlZHVjZSIsInJ1bGVzIiwiY29uY2F0IiwiQXJyYXkiLCJtYXAiLCJjc3NTdHJpbmciLCJyZWxhdGl2ZVRvVGFnIiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInR5cGUiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwiaGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW5zZXJ0QmVmb3JlIiwiZ2V0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsIkVycm9yIiwiaGFzaCIsInN0ciIsIl8kaGFzaCIsImNoYXJDb2RlQXQiLCJzdHJpbmdIYXNoIiwic2FuaXRpemUiLCJyZXBsYWNlIiwiY2FjaGUiLCJjb21wdXRlSWQiLCJiYXNlSWQiLCJwcm9wc1RvU3RyaW5nIiwiU3RyaW5nIiwiY29tcHV0ZVNlbGVjdG9yIiwiaWQiLCJjc3MiLCJzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAiLCJpZGNzcyIsIm1hcFJ1bGVzVG9TdHlsZSIsIm9wdGlvbnMiLCJhcmdzIiwibm9uY2UiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsIlN0eWxlU2hlZXRSZWdpc3RyeSIsIl9zdHlsZVNoZWV0Iiwic3R5bGVTaGVldCIsIl9zaGVldCIsIl9mcm9tU2VydmVyIiwiX2luZGljZXMiLCJfaW5zdGFuY2VzQ291bnRzIiwiYWRkIiwiaXNBcnJheSIsImNoaWxkcmVuIiwic2VsZWN0RnJvbVNlcnZlciIsImtleXMiLCJhY2MiLCJ0YWdOYW1lIiwiZ2V0SWRBbmRSdWxlcyIsInN0eWxlSWQiLCJpbmRpY2VzIiwiZmlsdGVyIiwicmVtb3ZlIiwiaW52YXJpYW50IiwidGFnRnJvbVNlcnZlciIsInVwZGF0ZSIsIm5leHRQcm9wcyIsImZyb21TZXJ2ZXIiLCJqb2luIiwiQm9vbGVhbiIsInN0eWxlcyIsImR5bmFtaWMiLCJlbGVtZW50cyIsInNsaWNlIiwicXVlcnlTZWxlY3RvckFsbCIsImVsZW1lbnQiLCJTdHlsZVNoZWV0Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsImNyZWF0ZVN0eWxlUmVnaXN0cnkiLCJTdHlsZVJlZ2lzdHJ5IiwiY29uZmlndXJlZFJlZ2lzdHJ5IiwicmVnaXN0cnkiLCJyb290UmVnaXN0cnkiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJQcm92aWRlciIsInZhbHVlIiwidXNlU3R5bGVSZWdpc3RyeSIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsImRlZmF1bHRSZWdpc3RyeSIsIkpTWFN0eWxlIiwiaW5mbyIsInRhZ0luZm8iLCJleHBvcnRzIiwic3R5bGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/styled-jsx/style.js":
/*!******************************************!*\
  !*** ./node_modules/styled-jsx/style.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = __webpack_require__(/*! ./dist/index */ \"(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js\").style;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L3N0eWxlLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsbUlBQThDIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9zdHlsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9pbmRleCcpLnN0eWxlXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJzdHlsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/styled-jsx/style.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/suspend-react/index.js":
/*!*********************************************!*\
  !*** ./node_modules/suspend-react/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clear: () => (/* binding */ clear),\n/* harmony export */   peek: () => (/* binding */ peek),\n/* harmony export */   preload: () => (/* binding */ preload),\n/* harmony export */   suspend: () => (/* binding */ suspend)\n/* harmony export */ });\nconst isPromise = promise => typeof promise === 'object' && typeof promise.then === 'function';\n\nconst globalCache = [];\n\nfunction shallowEqualArrays(arrA, arrB, equal = (a, b) => a === b) {\n  if (arrA === arrB) return true;\n  if (!arrA || !arrB) return false;\n  const len = arrA.length;\n  if (arrB.length !== len) return false;\n\n  for (let i = 0; i < len; i++) if (!equal(arrA[i], arrB[i])) return false;\n\n  return true;\n}\n\nfunction query(fn, keys = null, preload = false, config = {}) {\n  // If no keys were given, the function is the key\n  if (keys === null) keys = [fn];\n\n  for (const entry of globalCache) {\n    // Find a match\n    if (shallowEqualArrays(keys, entry.keys, entry.equal)) {\n      // If we're pre-loading and the element is present, just return\n      if (preload) return undefined; // If an error occurred, throw\n\n      if (Object.prototype.hasOwnProperty.call(entry, 'error')) throw entry.error; // If a response was successful, return\n\n      if (Object.prototype.hasOwnProperty.call(entry, 'response')) {\n        if (config.lifespan && config.lifespan > 0) {\n          if (entry.timeout) clearTimeout(entry.timeout);\n          entry.timeout = setTimeout(entry.remove, config.lifespan);\n        }\n\n        return entry.response;\n      } // If the promise is still unresolved, throw\n\n\n      if (!preload) throw entry.promise;\n    }\n  } // The request is new or has changed.\n\n\n  const entry = {\n    keys,\n    equal: config.equal,\n    remove: () => {\n      const index = globalCache.indexOf(entry);\n      if (index !== -1) globalCache.splice(index, 1);\n    },\n    promise: // Execute the promise\n    (isPromise(fn) ? fn : fn(...keys) // When it resolves, store its value\n    ).then(response => {\n      entry.response = response; // Remove the entry in time if a lifespan was given\n\n      if (config.lifespan && config.lifespan > 0) {\n        entry.timeout = setTimeout(entry.remove, config.lifespan);\n      }\n    }) // Store caught errors, they will be thrown in the render-phase to bubble into an error-bound\n    .catch(error => entry.error = error)\n  }; // Register the entry\n\n  globalCache.push(entry); // And throw the promise, this yields control back to React\n\n  if (!preload) throw entry.promise;\n  return undefined;\n}\n\nconst suspend = (fn, keys, config) => query(fn, keys, false, config);\n\nconst preload = (fn, keys, config) => void query(fn, keys, true, config);\n\nconst peek = keys => {\n  var _globalCache$find;\n\n  return (_globalCache$find = globalCache.find(entry => shallowEqualArrays(keys, entry.keys, entry.equal))) == null ? void 0 : _globalCache$find.response;\n};\n\nconst clear = keys => {\n  if (keys === undefined || keys.length === 0) globalCache.splice(0, globalCache.length);else {\n    const entry = globalCache.find(entry => shallowEqualArrays(keys, entry.keys, entry.equal));\n    if (entry) entry.remove();\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdXNwZW5kLXJlYWN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTOztBQUUzQjtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQyxtRkFBbUY7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTCwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7O0FBRXlDIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvc3VzcGVuZC1yZWFjdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpc1Byb21pc2UgPSBwcm9taXNlID0+IHR5cGVvZiBwcm9taXNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nO1xuXG5jb25zdCBnbG9iYWxDYWNoZSA9IFtdO1xuXG5mdW5jdGlvbiBzaGFsbG93RXF1YWxBcnJheXMoYXJyQSwgYXJyQiwgZXF1YWwgPSAoYSwgYikgPT4gYSA9PT0gYikge1xuICBpZiAoYXJyQSA9PT0gYXJyQikgcmV0dXJuIHRydWU7XG4gIGlmICghYXJyQSB8fCAhYXJyQikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBsZW4gPSBhcnJBLmxlbmd0aDtcbiAgaWYgKGFyckIubGVuZ3RoICE9PSBsZW4pIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSBpZiAoIWVxdWFsKGFyckFbaV0sIGFyckJbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5KGZuLCBrZXlzID0gbnVsbCwgcHJlbG9hZCA9IGZhbHNlLCBjb25maWcgPSB7fSkge1xuICAvLyBJZiBubyBrZXlzIHdlcmUgZ2l2ZW4sIHRoZSBmdW5jdGlvbiBpcyB0aGUga2V5XG4gIGlmIChrZXlzID09PSBudWxsKSBrZXlzID0gW2ZuXTtcblxuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGdsb2JhbENhY2hlKSB7XG4gICAgLy8gRmluZCBhIG1hdGNoXG4gICAgaWYgKHNoYWxsb3dFcXVhbEFycmF5cyhrZXlzLCBlbnRyeS5rZXlzLCBlbnRyeS5lcXVhbCkpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHByZS1sb2FkaW5nIGFuZCB0aGUgZWxlbWVudCBpcyBwcmVzZW50LCBqdXN0IHJldHVyblxuICAgICAgaWYgKHByZWxvYWQpIHJldHVybiB1bmRlZmluZWQ7IC8vIElmIGFuIGVycm9yIG9jY3VycmVkLCB0aHJvd1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVudHJ5LCAnZXJyb3InKSkgdGhyb3cgZW50cnkuZXJyb3I7IC8vIElmIGEgcmVzcG9uc2Ugd2FzIHN1Y2Nlc3NmdWwsIHJldHVyblxuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVudHJ5LCAncmVzcG9uc2UnKSkge1xuICAgICAgICBpZiAoY29uZmlnLmxpZmVzcGFuICYmIGNvbmZpZy5saWZlc3BhbiA+IDApIHtcbiAgICAgICAgICBpZiAoZW50cnkudGltZW91dCkgY2xlYXJUaW1lb3V0KGVudHJ5LnRpbWVvdXQpO1xuICAgICAgICAgIGVudHJ5LnRpbWVvdXQgPSBzZXRUaW1lb3V0KGVudHJ5LnJlbW92ZSwgY29uZmlnLmxpZmVzcGFuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbnRyeS5yZXNwb25zZTtcbiAgICAgIH0gLy8gSWYgdGhlIHByb21pc2UgaXMgc3RpbGwgdW5yZXNvbHZlZCwgdGhyb3dcblxuXG4gICAgICBpZiAoIXByZWxvYWQpIHRocm93IGVudHJ5LnByb21pc2U7XG4gICAgfVxuICB9IC8vIFRoZSByZXF1ZXN0IGlzIG5ldyBvciBoYXMgY2hhbmdlZC5cblxuXG4gIGNvbnN0IGVudHJ5ID0ge1xuICAgIGtleXMsXG4gICAgZXF1YWw6IGNvbmZpZy5lcXVhbCxcbiAgICByZW1vdmU6ICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ2xvYmFsQ2FjaGUuaW5kZXhPZihlbnRyeSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSBnbG9iYWxDYWNoZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH0sXG4gICAgcHJvbWlzZTogLy8gRXhlY3V0ZSB0aGUgcHJvbWlzZVxuICAgIChpc1Byb21pc2UoZm4pID8gZm4gOiBmbiguLi5rZXlzKSAvLyBXaGVuIGl0IHJlc29sdmVzLCBzdG9yZSBpdHMgdmFsdWVcbiAgICApLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgZW50cnkucmVzcG9uc2UgPSByZXNwb25zZTsgLy8gUmVtb3ZlIHRoZSBlbnRyeSBpbiB0aW1lIGlmIGEgbGlmZXNwYW4gd2FzIGdpdmVuXG5cbiAgICAgIGlmIChjb25maWcubGlmZXNwYW4gJiYgY29uZmlnLmxpZmVzcGFuID4gMCkge1xuICAgICAgICBlbnRyeS50aW1lb3V0ID0gc2V0VGltZW91dChlbnRyeS5yZW1vdmUsIGNvbmZpZy5saWZlc3Bhbik7XG4gICAgICB9XG4gICAgfSkgLy8gU3RvcmUgY2F1Z2h0IGVycm9ycywgdGhleSB3aWxsIGJlIHRocm93biBpbiB0aGUgcmVuZGVyLXBoYXNlIHRvIGJ1YmJsZSBpbnRvIGFuIGVycm9yLWJvdW5kXG4gICAgLmNhdGNoKGVycm9yID0+IGVudHJ5LmVycm9yID0gZXJyb3IpXG4gIH07IC8vIFJlZ2lzdGVyIHRoZSBlbnRyeVxuXG4gIGdsb2JhbENhY2hlLnB1c2goZW50cnkpOyAvLyBBbmQgdGhyb3cgdGhlIHByb21pc2UsIHRoaXMgeWllbGRzIGNvbnRyb2wgYmFjayB0byBSZWFjdFxuXG4gIGlmICghcHJlbG9hZCkgdGhyb3cgZW50cnkucHJvbWlzZTtcbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuY29uc3Qgc3VzcGVuZCA9IChmbiwga2V5cywgY29uZmlnKSA9PiBxdWVyeShmbiwga2V5cywgZmFsc2UsIGNvbmZpZyk7XG5cbmNvbnN0IHByZWxvYWQgPSAoZm4sIGtleXMsIGNvbmZpZykgPT4gdm9pZCBxdWVyeShmbiwga2V5cywgdHJ1ZSwgY29uZmlnKTtcblxuY29uc3QgcGVlayA9IGtleXMgPT4ge1xuICB2YXIgX2dsb2JhbENhY2hlJGZpbmQ7XG5cbiAgcmV0dXJuIChfZ2xvYmFsQ2FjaGUkZmluZCA9IGdsb2JhbENhY2hlLmZpbmQoZW50cnkgPT4gc2hhbGxvd0VxdWFsQXJyYXlzKGtleXMsIGVudHJ5LmtleXMsIGVudHJ5LmVxdWFsKSkpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsQ2FjaGUkZmluZC5yZXNwb25zZTtcbn07XG5cbmNvbnN0IGNsZWFyID0ga2V5cyA9PiB7XG4gIGlmIChrZXlzID09PSB1bmRlZmluZWQgfHwga2V5cy5sZW5ndGggPT09IDApIGdsb2JhbENhY2hlLnNwbGljZSgwLCBnbG9iYWxDYWNoZS5sZW5ndGgpO2Vsc2Uge1xuICAgIGNvbnN0IGVudHJ5ID0gZ2xvYmFsQ2FjaGUuZmluZChlbnRyeSA9PiBzaGFsbG93RXF1YWxBcnJheXMoa2V5cywgZW50cnkua2V5cywgZW50cnkuZXF1YWwpKTtcbiAgICBpZiAoZW50cnkpIGVudHJ5LnJlbW92ZSgpO1xuICB9XG59O1xuXG5leHBvcnQgeyBjbGVhciwgcGVlaywgcHJlbG9hZCwgc3VzcGVuZCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/suspend-react/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/tailwind-merge/dist/bundle-mjs.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTailwindMerge: () => (/* binding */ createTailwindMerge),\n/* harmony export */   extendTailwindMerge: () => (/* binding */ extendTailwindMerge),\n/* harmony export */   fromTheme: () => (/* binding */ fromTheme),\n/* harmony export */   getDefaultConfig: () => (/* binding */ getDefaultConfig),\n/* harmony export */   mergeConfigs: () => (/* binding */ mergeConfigs),\n/* harmony export */   twJoin: () => (/* binding */ twJoin),\n/* harmony export */   twMerge: () => (/* binding */ twMerge),\n/* harmony export */   validators: () => (/* binding */ validators)\n/* harmony export */ });\nconst CLASS_PART_SEPARATOR = '-';\nconst createClassGroupUtils = config => {\n  const classMap = createClassMap(config);\n  const {\n    conflictingClassGroups,\n    conflictingClassGroupModifiers\n  } = config;\n  const getClassGroupId = className => {\n    const classParts = className.split(CLASS_PART_SEPARATOR);\n    // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.\n    if (classParts[0] === '' && classParts.length !== 1) {\n      classParts.shift();\n    }\n    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);\n  };\n  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {\n    const conflicts = conflictingClassGroups[classGroupId] || [];\n    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {\n      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];\n    }\n    return conflicts;\n  };\n  return {\n    getClassGroupId,\n    getConflictingClassGroupIds\n  };\n};\nconst getGroupRecursive = (classParts, classPartObject) => {\n  if (classParts.length === 0) {\n    return classPartObject.classGroupId;\n  }\n  const currentClassPart = classParts[0];\n  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);\n  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;\n  if (classGroupFromNextClassPart) {\n    return classGroupFromNextClassPart;\n  }\n  if (classPartObject.validators.length === 0) {\n    return undefined;\n  }\n  const classRest = classParts.join(CLASS_PART_SEPARATOR);\n  return classPartObject.validators.find(({\n    validator\n  }) => validator(classRest))?.classGroupId;\n};\nconst arbitraryPropertyRegex = /^\\[(.+)\\]$/;\nconst getGroupIdForArbitraryProperty = className => {\n  if (arbitraryPropertyRegex.test(className)) {\n    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];\n    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(':'));\n    if (property) {\n      // I use two dots here because one dot is used as prefix for class groups in plugins\n      return 'arbitrary..' + property;\n    }\n  }\n};\n/**\n * Exported for testing only\n */\nconst createClassMap = config => {\n  const {\n    theme,\n    classGroups\n  } = config;\n  const classMap = {\n    nextPart: new Map(),\n    validators: []\n  };\n  for (const classGroupId in classGroups) {\n    processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);\n  }\n  return classMap;\n};\nconst processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {\n  classGroup.forEach(classDefinition => {\n    if (typeof classDefinition === 'string') {\n      const classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);\n      classPartObjectToEdit.classGroupId = classGroupId;\n      return;\n    }\n    if (typeof classDefinition === 'function') {\n      if (isThemeGetter(classDefinition)) {\n        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);\n        return;\n      }\n      classPartObject.validators.push({\n        validator: classDefinition,\n        classGroupId\n      });\n      return;\n    }\n    Object.entries(classDefinition).forEach(([key, classGroup]) => {\n      processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);\n    });\n  });\n};\nconst getPart = (classPartObject, path) => {\n  let currentClassPartObject = classPartObject;\n  path.split(CLASS_PART_SEPARATOR).forEach(pathPart => {\n    if (!currentClassPartObject.nextPart.has(pathPart)) {\n      currentClassPartObject.nextPart.set(pathPart, {\n        nextPart: new Map(),\n        validators: []\n      });\n    }\n    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);\n  });\n  return currentClassPartObject;\n};\nconst isThemeGetter = func => func.isThemeGetter;\n\n// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance\nconst createLruCache = maxCacheSize => {\n  if (maxCacheSize < 1) {\n    return {\n      get: () => undefined,\n      set: () => {}\n    };\n  }\n  let cacheSize = 0;\n  let cache = new Map();\n  let previousCache = new Map();\n  const update = (key, value) => {\n    cache.set(key, value);\n    cacheSize++;\n    if (cacheSize > maxCacheSize) {\n      cacheSize = 0;\n      previousCache = cache;\n      cache = new Map();\n    }\n  };\n  return {\n    get(key) {\n      let value = cache.get(key);\n      if (value !== undefined) {\n        return value;\n      }\n      if ((value = previousCache.get(key)) !== undefined) {\n        update(key, value);\n        return value;\n      }\n    },\n    set(key, value) {\n      if (cache.has(key)) {\n        cache.set(key, value);\n      } else {\n        update(key, value);\n      }\n    }\n  };\n};\nconst IMPORTANT_MODIFIER = '!';\nconst MODIFIER_SEPARATOR = ':';\nconst MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;\nconst createParseClassName = config => {\n  const {\n    prefix,\n    experimentalParseClassName\n  } = config;\n  /**\n   * Parse class name into parts.\n   *\n   * Inspired by `splitAtTopLevelOnly` used in Tailwind CSS\n   * @see https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js\n   */\n  let parseClassName = className => {\n    const modifiers = [];\n    let bracketDepth = 0;\n    let parenDepth = 0;\n    let modifierStart = 0;\n    let postfixModifierPosition;\n    for (let index = 0; index < className.length; index++) {\n      let currentCharacter = className[index];\n      if (bracketDepth === 0 && parenDepth === 0) {\n        if (currentCharacter === MODIFIER_SEPARATOR) {\n          modifiers.push(className.slice(modifierStart, index));\n          modifierStart = index + MODIFIER_SEPARATOR_LENGTH;\n          continue;\n        }\n        if (currentCharacter === '/') {\n          postfixModifierPosition = index;\n          continue;\n        }\n      }\n      if (currentCharacter === '[') {\n        bracketDepth++;\n      } else if (currentCharacter === ']') {\n        bracketDepth--;\n      } else if (currentCharacter === '(') {\n        parenDepth++;\n      } else if (currentCharacter === ')') {\n        parenDepth--;\n      }\n    }\n    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);\n    const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);\n    const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;\n    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;\n    return {\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    };\n  };\n  if (prefix) {\n    const fullPrefix = prefix + MODIFIER_SEPARATOR;\n    const parseClassNameOriginal = parseClassName;\n    parseClassName = className => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {\n      isExternal: true,\n      modifiers: [],\n      hasImportantModifier: false,\n      baseClassName: className,\n      maybePostfixModifierPosition: undefined\n    };\n  }\n  if (experimentalParseClassName) {\n    const parseClassNameOriginal = parseClassName;\n    parseClassName = className => experimentalParseClassName({\n      className,\n      parseClassName: parseClassNameOriginal\n    });\n  }\n  return parseClassName;\n};\nconst stripImportantModifier = baseClassName => {\n  if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {\n    return baseClassName.substring(0, baseClassName.length - 1);\n  }\n  /**\n   * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.\n   * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864\n   */\n  if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {\n    return baseClassName.substring(1);\n  }\n  return baseClassName;\n};\n\n/**\n * Sorts modifiers according to following schema:\n * - Predefined modifiers are sorted alphabetically\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\n */\nconst createSortModifiers = config => {\n  const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map(modifier => [modifier, true]));\n  const sortModifiers = modifiers => {\n    if (modifiers.length <= 1) {\n      return modifiers;\n    }\n    const sortedModifiers = [];\n    let unsortedModifiers = [];\n    modifiers.forEach(modifier => {\n      const isPositionSensitive = modifier[0] === '[' || orderSensitiveModifiers[modifier];\n      if (isPositionSensitive) {\n        sortedModifiers.push(...unsortedModifiers.sort(), modifier);\n        unsortedModifiers = [];\n      } else {\n        unsortedModifiers.push(modifier);\n      }\n    });\n    sortedModifiers.push(...unsortedModifiers.sort());\n    return sortedModifiers;\n  };\n  return sortModifiers;\n};\nconst createConfigUtils = config => ({\n  cache: createLruCache(config.cacheSize),\n  parseClassName: createParseClassName(config),\n  sortModifiers: createSortModifiers(config),\n  ...createClassGroupUtils(config)\n});\nconst SPLIT_CLASSES_REGEX = /\\s+/;\nconst mergeClassList = (classList, configUtils) => {\n  const {\n    parseClassName,\n    getClassGroupId,\n    getConflictingClassGroupIds,\n    sortModifiers\n  } = configUtils;\n  /**\n   * Set of classGroupIds in following format:\n   * `{importantModifier}{variantModifiers}{classGroupId}`\n   * @example 'float'\n   * @example 'hover:focus:bg-color'\n   * @example 'md:!pr'\n   */\n  const classGroupsInConflict = [];\n  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);\n  let result = '';\n  for (let index = classNames.length - 1; index >= 0; index -= 1) {\n    const originalClassName = classNames[index];\n    const {\n      isExternal,\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    } = parseClassName(originalClassName);\n    if (isExternal) {\n      result = originalClassName + (result.length > 0 ? ' ' + result : result);\n      continue;\n    }\n    let hasPostfixModifier = !!maybePostfixModifierPosition;\n    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);\n    if (!classGroupId) {\n      if (!hasPostfixModifier) {\n        // Not a Tailwind class\n        result = originalClassName + (result.length > 0 ? ' ' + result : result);\n        continue;\n      }\n      classGroupId = getClassGroupId(baseClassName);\n      if (!classGroupId) {\n        // Not a Tailwind class\n        result = originalClassName + (result.length > 0 ? ' ' + result : result);\n        continue;\n      }\n      hasPostfixModifier = false;\n    }\n    const variantModifier = sortModifiers(modifiers).join(':');\n    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;\n    const classId = modifierId + classGroupId;\n    if (classGroupsInConflict.includes(classId)) {\n      // Tailwind class omitted due to conflict\n      continue;\n    }\n    classGroupsInConflict.push(classId);\n    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);\n    for (let i = 0; i < conflictGroups.length; ++i) {\n      const group = conflictGroups[i];\n      classGroupsInConflict.push(modifierId + group);\n    }\n    // Tailwind class not in conflict\n    result = originalClassName + (result.length > 0 ? ' ' + result : result);\n  }\n  return result;\n};\n\n/**\n * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.\n *\n * Specifically:\n * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js\n * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts\n *\n * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)\n */\nfunction twJoin() {\n  let index = 0;\n  let argument;\n  let resolvedValue;\n  let string = '';\n  while (index < arguments.length) {\n    if (argument = arguments[index++]) {\n      if (resolvedValue = toValue(argument)) {\n        string && (string += ' ');\n        string += resolvedValue;\n      }\n    }\n  }\n  return string;\n}\nconst toValue = mix => {\n  if (typeof mix === 'string') {\n    return mix;\n  }\n  let resolvedValue;\n  let string = '';\n  for (let k = 0; k < mix.length; k++) {\n    if (mix[k]) {\n      if (resolvedValue = toValue(mix[k])) {\n        string && (string += ' ');\n        string += resolvedValue;\n      }\n    }\n  }\n  return string;\n};\nfunction createTailwindMerge(createConfigFirst, ...createConfigRest) {\n  let configUtils;\n  let cacheGet;\n  let cacheSet;\n  let functionToCall = initTailwindMerge;\n  function initTailwindMerge(classList) {\n    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());\n    configUtils = createConfigUtils(config);\n    cacheGet = configUtils.cache.get;\n    cacheSet = configUtils.cache.set;\n    functionToCall = tailwindMerge;\n    return tailwindMerge(classList);\n  }\n  function tailwindMerge(classList) {\n    const cachedResult = cacheGet(classList);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    const result = mergeClassList(classList, configUtils);\n    cacheSet(classList, result);\n    return result;\n  }\n  return function callTailwindMerge() {\n    return functionToCall(twJoin.apply(null, arguments));\n  };\n}\nconst fromTheme = key => {\n  const themeGetter = theme => theme[key] || [];\n  themeGetter.isThemeGetter = true;\n  return themeGetter;\n};\nconst arbitraryValueRegex = /^\\[(?:(\\w[\\w-]*):)?(.+)\\]$/i;\nconst arbitraryVariableRegex = /^\\((?:(\\w[\\w-]*):)?(.+)\\)$/i;\nconst fractionRegex = /^\\d+\\/\\d+$/;\nconst tshirtUnitRegex = /^(\\d+(\\.\\d+)?)?(xs|sm|md|lg|xl)$/;\nconst lengthUnitRegex = /\\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\\b(calc|min|max|clamp)\\(.+\\)|^0$/;\nconst colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\\(.+\\)$/;\n// Shadow always begins with x and y offset separated by underscore optionally prepended by inset\nconst shadowRegex = /^(inset_)?-?((\\d+)?\\.?(\\d+)[a-z]+|0)_-?((\\d+)?\\.?(\\d+)[a-z]+|0)/;\nconst imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\\(.+\\)$/;\nconst isFraction = value => fractionRegex.test(value);\nconst isNumber = value => !!value && !Number.isNaN(Number(value));\nconst isInteger = value => !!value && Number.isInteger(Number(value));\nconst isPercent = value => value.endsWith('%') && isNumber(value.slice(0, -1));\nconst isTshirtSize = value => tshirtUnitRegex.test(value);\nconst isAny = () => true;\nconst isLengthOnly = value =>\n// `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.\n// For example, `hsl(0 0% 0%)` would be classified as a length without this check.\n// I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.\nlengthUnitRegex.test(value) && !colorFunctionRegex.test(value);\nconst isNever = () => false;\nconst isShadow = value => shadowRegex.test(value);\nconst isImage = value => imageRegex.test(value);\nconst isAnyNonArbitrary = value => !isArbitraryValue(value) && !isArbitraryVariable(value);\nconst isArbitrarySize = value => getIsArbitraryValue(value, isLabelSize, isNever);\nconst isArbitraryValue = value => arbitraryValueRegex.test(value);\nconst isArbitraryLength = value => getIsArbitraryValue(value, isLabelLength, isLengthOnly);\nconst isArbitraryNumber = value => getIsArbitraryValue(value, isLabelNumber, isNumber);\nconst isArbitraryPosition = value => getIsArbitraryValue(value, isLabelPosition, isNever);\nconst isArbitraryImage = value => getIsArbitraryValue(value, isLabelImage, isImage);\nconst isArbitraryShadow = value => getIsArbitraryValue(value, isLabelShadow, isShadow);\nconst isArbitraryVariable = value => arbitraryVariableRegex.test(value);\nconst isArbitraryVariableLength = value => getIsArbitraryVariable(value, isLabelLength);\nconst isArbitraryVariableFamilyName = value => getIsArbitraryVariable(value, isLabelFamilyName);\nconst isArbitraryVariablePosition = value => getIsArbitraryVariable(value, isLabelPosition);\nconst isArbitraryVariableSize = value => getIsArbitraryVariable(value, isLabelSize);\nconst isArbitraryVariableImage = value => getIsArbitraryVariable(value, isLabelImage);\nconst isArbitraryVariableShadow = value => getIsArbitraryVariable(value, isLabelShadow, true);\n// Helpers\nconst getIsArbitraryValue = (value, testLabel, testValue) => {\n  const result = arbitraryValueRegex.exec(value);\n  if (result) {\n    if (result[1]) {\n      return testLabel(result[1]);\n    }\n    return testValue(result[2]);\n  }\n  return false;\n};\nconst getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {\n  const result = arbitraryVariableRegex.exec(value);\n  if (result) {\n    if (result[1]) {\n      return testLabel(result[1]);\n    }\n    return shouldMatchNoLabel;\n  }\n  return false;\n};\n// Labels\nconst isLabelPosition = label => label === 'position' || label === 'percentage';\nconst isLabelImage = label => label === 'image' || label === 'url';\nconst isLabelSize = label => label === 'length' || label === 'size' || label === 'bg-size';\nconst isLabelLength = label => label === 'length';\nconst isLabelNumber = label => label === 'number';\nconst isLabelFamilyName = label => label === 'family-name';\nconst isLabelShadow = label => label === 'shadow';\nconst validators = /*#__PURE__*/Object.defineProperty({\n  __proto__: null,\n  isAny,\n  isAnyNonArbitrary,\n  isArbitraryImage,\n  isArbitraryLength,\n  isArbitraryNumber,\n  isArbitraryPosition,\n  isArbitraryShadow,\n  isArbitrarySize,\n  isArbitraryValue,\n  isArbitraryVariable,\n  isArbitraryVariableFamilyName,\n  isArbitraryVariableImage,\n  isArbitraryVariableLength,\n  isArbitraryVariablePosition,\n  isArbitraryVariableShadow,\n  isArbitraryVariableSize,\n  isFraction,\n  isInteger,\n  isNumber,\n  isPercent,\n  isTshirtSize\n}, Symbol.toStringTag, {\n  value: 'Module'\n});\nconst getDefaultConfig = () => {\n  /**\n   * Theme getters for theme variable namespaces\n   * @see https://tailwindcss.com/docs/theme#theme-variable-namespaces\n   */\n  /***/\n  const themeColor = fromTheme('color');\n  const themeFont = fromTheme('font');\n  const themeText = fromTheme('text');\n  const themeFontWeight = fromTheme('font-weight');\n  const themeTracking = fromTheme('tracking');\n  const themeLeading = fromTheme('leading');\n  const themeBreakpoint = fromTheme('breakpoint');\n  const themeContainer = fromTheme('container');\n  const themeSpacing = fromTheme('spacing');\n  const themeRadius = fromTheme('radius');\n  const themeShadow = fromTheme('shadow');\n  const themeInsetShadow = fromTheme('inset-shadow');\n  const themeTextShadow = fromTheme('text-shadow');\n  const themeDropShadow = fromTheme('drop-shadow');\n  const themeBlur = fromTheme('blur');\n  const themePerspective = fromTheme('perspective');\n  const themeAspect = fromTheme('aspect');\n  const themeEase = fromTheme('ease');\n  const themeAnimate = fromTheme('animate');\n  /**\n   * Helpers to avoid repeating the same scales\n   *\n   * We use functions that create a new array every time they're called instead of static arrays.\n   * This ensures that users who modify any scale by mutating the array (e.g. with `array.push(element)`) don't accidentally mutate arrays in other parts of the config.\n   */\n  /***/\n  const scaleBreak = () => ['auto', 'avoid', 'all', 'avoid-page', 'page', 'left', 'right', 'column'];\n  const scalePosition = () => ['center', 'top', 'bottom', 'left', 'right', 'top-left',\n  // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378\n  'left-top', 'top-right',\n  // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378\n  'right-top', 'bottom-right',\n  // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378\n  'right-bottom', 'bottom-left',\n  // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378\n  'left-bottom'];\n  const scalePositionWithArbitrary = () => [...scalePosition(), isArbitraryVariable, isArbitraryValue];\n  const scaleOverflow = () => ['auto', 'hidden', 'clip', 'visible', 'scroll'];\n  const scaleOverscroll = () => ['auto', 'contain', 'none'];\n  const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];\n  const scaleInset = () => [isFraction, 'full', 'auto', ...scaleUnambiguousSpacing()];\n  const scaleGridTemplateColsRows = () => [isInteger, 'none', 'subgrid', isArbitraryVariable, isArbitraryValue];\n  const scaleGridColRowStartAndEnd = () => ['auto', {\n    span: ['full', isInteger, isArbitraryVariable, isArbitraryValue]\n  }, isInteger, isArbitraryVariable, isArbitraryValue];\n  const scaleGridColRowStartOrEnd = () => [isInteger, 'auto', isArbitraryVariable, isArbitraryValue];\n  const scaleGridAutoColsRows = () => ['auto', 'min', 'max', 'fr', isArbitraryVariable, isArbitraryValue];\n  const scaleAlignPrimaryAxis = () => ['start', 'end', 'center', 'between', 'around', 'evenly', 'stretch', 'baseline', 'center-safe', 'end-safe'];\n  const scaleAlignSecondaryAxis = () => ['start', 'end', 'center', 'stretch', 'center-safe', 'end-safe'];\n  const scaleMargin = () => ['auto', ...scaleUnambiguousSpacing()];\n  const scaleSizing = () => [isFraction, 'auto', 'full', 'dvw', 'dvh', 'lvw', 'lvh', 'svw', 'svh', 'min', 'max', 'fit', ...scaleUnambiguousSpacing()];\n  const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];\n  const scaleBgPosition = () => [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition, {\n    position: [isArbitraryVariable, isArbitraryValue]\n  }];\n  const scaleBgRepeat = () => ['no-repeat', {\n    repeat: ['', 'x', 'y', 'space', 'round']\n  }];\n  const scaleBgSize = () => ['auto', 'cover', 'contain', isArbitraryVariableSize, isArbitrarySize, {\n    size: [isArbitraryVariable, isArbitraryValue]\n  }];\n  const scaleGradientStopPosition = () => [isPercent, isArbitraryVariableLength, isArbitraryLength];\n  const scaleRadius = () => [\n  // Deprecated since Tailwind CSS v4.0.0\n  '', 'none', 'full', themeRadius, isArbitraryVariable, isArbitraryValue];\n  const scaleBorderWidth = () => ['', isNumber, isArbitraryVariableLength, isArbitraryLength];\n  const scaleLineStyle = () => ['solid', 'dashed', 'dotted', 'double'];\n  const scaleBlendMode = () => ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'];\n  const scaleMaskImagePosition = () => [isNumber, isPercent, isArbitraryVariablePosition, isArbitraryPosition];\n  const scaleBlur = () => [\n  // Deprecated since Tailwind CSS v4.0.0\n  '', 'none', themeBlur, isArbitraryVariable, isArbitraryValue];\n  const scaleRotate = () => ['none', isNumber, isArbitraryVariable, isArbitraryValue];\n  const scaleScale = () => ['none', isNumber, isArbitraryVariable, isArbitraryValue];\n  const scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue];\n  const scaleTranslate = () => [isFraction, 'full', ...scaleUnambiguousSpacing()];\n  return {\n    cacheSize: 500,\n    theme: {\n      animate: ['spin', 'ping', 'pulse', 'bounce'],\n      aspect: ['video'],\n      blur: [isTshirtSize],\n      breakpoint: [isTshirtSize],\n      color: [isAny],\n      container: [isTshirtSize],\n      'drop-shadow': [isTshirtSize],\n      ease: ['in', 'out', 'in-out'],\n      font: [isAnyNonArbitrary],\n      'font-weight': ['thin', 'extralight', 'light', 'normal', 'medium', 'semibold', 'bold', 'extrabold', 'black'],\n      'inset-shadow': [isTshirtSize],\n      leading: ['none', 'tight', 'snug', 'normal', 'relaxed', 'loose'],\n      perspective: ['dramatic', 'near', 'normal', 'midrange', 'distant', 'none'],\n      radius: [isTshirtSize],\n      shadow: [isTshirtSize],\n      spacing: ['px', isNumber],\n      text: [isTshirtSize],\n      'text-shadow': [isTshirtSize],\n      tracking: ['tighter', 'tight', 'normal', 'wide', 'wider', 'widest']\n    },\n    classGroups: {\n      // --------------\n      // --- Layout ---\n      // --------------\n      /**\n       * Aspect Ratio\n       * @see https://tailwindcss.com/docs/aspect-ratio\n       */\n      aspect: [{\n        aspect: ['auto', 'square', isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]\n      }],\n      /**\n       * Container\n       * @see https://tailwindcss.com/docs/container\n       * @deprecated since Tailwind CSS v4.0.0\n       */\n      container: ['container'],\n      /**\n       * Columns\n       * @see https://tailwindcss.com/docs/columns\n       */\n      columns: [{\n        columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer]\n      }],\n      /**\n       * Break After\n       * @see https://tailwindcss.com/docs/break-after\n       */\n      'break-after': [{\n        'break-after': scaleBreak()\n      }],\n      /**\n       * Break Before\n       * @see https://tailwindcss.com/docs/break-before\n       */\n      'break-before': [{\n        'break-before': scaleBreak()\n      }],\n      /**\n       * Break Inside\n       * @see https://tailwindcss.com/docs/break-inside\n       */\n      'break-inside': [{\n        'break-inside': ['auto', 'avoid', 'avoid-page', 'avoid-column']\n      }],\n      /**\n       * Box Decoration Break\n       * @see https://tailwindcss.com/docs/box-decoration-break\n       */\n      'box-decoration': [{\n        'box-decoration': ['slice', 'clone']\n      }],\n      /**\n       * Box Sizing\n       * @see https://tailwindcss.com/docs/box-sizing\n       */\n      box: [{\n        box: ['border', 'content']\n      }],\n      /**\n       * Display\n       * @see https://tailwindcss.com/docs/display\n       */\n      display: ['block', 'inline-block', 'inline', 'flex', 'inline-flex', 'table', 'inline-table', 'table-caption', 'table-cell', 'table-column', 'table-column-group', 'table-footer-group', 'table-header-group', 'table-row-group', 'table-row', 'flow-root', 'grid', 'inline-grid', 'contents', 'list-item', 'hidden'],\n      /**\n       * Screen Reader Only\n       * @see https://tailwindcss.com/docs/display#screen-reader-only\n       */\n      sr: ['sr-only', 'not-sr-only'],\n      /**\n       * Floats\n       * @see https://tailwindcss.com/docs/float\n       */\n      float: [{\n        float: ['right', 'left', 'none', 'start', 'end']\n      }],\n      /**\n       * Clear\n       * @see https://tailwindcss.com/docs/clear\n       */\n      clear: [{\n        clear: ['left', 'right', 'both', 'none', 'start', 'end']\n      }],\n      /**\n       * Isolation\n       * @see https://tailwindcss.com/docs/isolation\n       */\n      isolation: ['isolate', 'isolation-auto'],\n      /**\n       * Object Fit\n       * @see https://tailwindcss.com/docs/object-fit\n       */\n      'object-fit': [{\n        object: ['contain', 'cover', 'fill', 'none', 'scale-down']\n      }],\n      /**\n       * Object Position\n       * @see https://tailwindcss.com/docs/object-position\n       */\n      'object-position': [{\n        object: scalePositionWithArbitrary()\n      }],\n      /**\n       * Overflow\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      overflow: [{\n        overflow: scaleOverflow()\n      }],\n      /**\n       * Overflow X\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      'overflow-x': [{\n        'overflow-x': scaleOverflow()\n      }],\n      /**\n       * Overflow Y\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      'overflow-y': [{\n        'overflow-y': scaleOverflow()\n      }],\n      /**\n       * Overscroll Behavior\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      overscroll: [{\n        overscroll: scaleOverscroll()\n      }],\n      /**\n       * Overscroll Behavior X\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      'overscroll-x': [{\n        'overscroll-x': scaleOverscroll()\n      }],\n      /**\n       * Overscroll Behavior Y\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      'overscroll-y': [{\n        'overscroll-y': scaleOverscroll()\n      }],\n      /**\n       * Position\n       * @see https://tailwindcss.com/docs/position\n       */\n      position: ['static', 'fixed', 'absolute', 'relative', 'sticky'],\n      /**\n       * Top / Right / Bottom / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      inset: [{\n        inset: scaleInset()\n      }],\n      /**\n       * Right / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      'inset-x': [{\n        'inset-x': scaleInset()\n      }],\n      /**\n       * Top / Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      'inset-y': [{\n        'inset-y': scaleInset()\n      }],\n      /**\n       * Start\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      start: [{\n        start: scaleInset()\n      }],\n      /**\n       * End\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      end: [{\n        end: scaleInset()\n      }],\n      /**\n       * Top\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      top: [{\n        top: scaleInset()\n      }],\n      /**\n       * Right\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      right: [{\n        right: scaleInset()\n      }],\n      /**\n       * Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      bottom: [{\n        bottom: scaleInset()\n      }],\n      /**\n       * Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      left: [{\n        left: scaleInset()\n      }],\n      /**\n       * Visibility\n       * @see https://tailwindcss.com/docs/visibility\n       */\n      visibility: ['visible', 'invisible', 'collapse'],\n      /**\n       * Z-Index\n       * @see https://tailwindcss.com/docs/z-index\n       */\n      z: [{\n        z: [isInteger, 'auto', isArbitraryVariable, isArbitraryValue]\n      }],\n      // ------------------------\n      // --- Flexbox and Grid ---\n      // ------------------------\n      /**\n       * Flex Basis\n       * @see https://tailwindcss.com/docs/flex-basis\n       */\n      basis: [{\n        basis: [isFraction, 'full', 'auto', themeContainer, ...scaleUnambiguousSpacing()]\n      }],\n      /**\n       * Flex Direction\n       * @see https://tailwindcss.com/docs/flex-direction\n       */\n      'flex-direction': [{\n        flex: ['row', 'row-reverse', 'col', 'col-reverse']\n      }],\n      /**\n       * Flex Wrap\n       * @see https://tailwindcss.com/docs/flex-wrap\n       */\n      'flex-wrap': [{\n        flex: ['nowrap', 'wrap', 'wrap-reverse']\n      }],\n      /**\n       * Flex\n       * @see https://tailwindcss.com/docs/flex\n       */\n      flex: [{\n        flex: [isNumber, isFraction, 'auto', 'initial', 'none', isArbitraryValue]\n      }],\n      /**\n       * Flex Grow\n       * @see https://tailwindcss.com/docs/flex-grow\n       */\n      grow: [{\n        grow: ['', isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Flex Shrink\n       * @see https://tailwindcss.com/docs/flex-shrink\n       */\n      shrink: [{\n        shrink: ['', isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Order\n       * @see https://tailwindcss.com/docs/order\n       */\n      order: [{\n        order: [isInteger, 'first', 'last', 'none', isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Grid Template Columns\n       * @see https://tailwindcss.com/docs/grid-template-columns\n       */\n      'grid-cols': [{\n        'grid-cols': scaleGridTemplateColsRows()\n      }],\n      /**\n       * Grid Column Start / End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-start-end': [{\n        col: scaleGridColRowStartAndEnd()\n      }],\n      /**\n       * Grid Column Start\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-start': [{\n        'col-start': scaleGridColRowStartOrEnd()\n      }],\n      /**\n       * Grid Column End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-end': [{\n        'col-end': scaleGridColRowStartOrEnd()\n      }],\n      /**\n       * Grid Template Rows\n       * @see https://tailwindcss.com/docs/grid-template-rows\n       */\n      'grid-rows': [{\n        'grid-rows': scaleGridTemplateColsRows()\n      }],\n      /**\n       * Grid Row Start / End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-start-end': [{\n        row: scaleGridColRowStartAndEnd()\n      }],\n      /**\n       * Grid Row Start\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-start': [{\n        'row-start': scaleGridColRowStartOrEnd()\n      }],\n      /**\n       * Grid Row End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-end': [{\n        'row-end': scaleGridColRowStartOrEnd()\n      }],\n      /**\n       * Grid Auto Flow\n       * @see https://tailwindcss.com/docs/grid-auto-flow\n       */\n      'grid-flow': [{\n        'grid-flow': ['row', 'col', 'dense', 'row-dense', 'col-dense']\n      }],\n      /**\n       * Grid Auto Columns\n       * @see https://tailwindcss.com/docs/grid-auto-columns\n       */\n      'auto-cols': [{\n        'auto-cols': scaleGridAutoColsRows()\n      }],\n      /**\n       * Grid Auto Rows\n       * @see https://tailwindcss.com/docs/grid-auto-rows\n       */\n      'auto-rows': [{\n        'auto-rows': scaleGridAutoColsRows()\n      }],\n      /**\n       * Gap\n       * @see https://tailwindcss.com/docs/gap\n       */\n      gap: [{\n        gap: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Gap X\n       * @see https://tailwindcss.com/docs/gap\n       */\n      'gap-x': [{\n        'gap-x': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Gap Y\n       * @see https://tailwindcss.com/docs/gap\n       */\n      'gap-y': [{\n        'gap-y': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Justify Content\n       * @see https://tailwindcss.com/docs/justify-content\n       */\n      'justify-content': [{\n        justify: [...scaleAlignPrimaryAxis(), 'normal']\n      }],\n      /**\n       * Justify Items\n       * @see https://tailwindcss.com/docs/justify-items\n       */\n      'justify-items': [{\n        'justify-items': [...scaleAlignSecondaryAxis(), 'normal']\n      }],\n      /**\n       * Justify Self\n       * @see https://tailwindcss.com/docs/justify-self\n       */\n      'justify-self': [{\n        'justify-self': ['auto', ...scaleAlignSecondaryAxis()]\n      }],\n      /**\n       * Align Content\n       * @see https://tailwindcss.com/docs/align-content\n       */\n      'align-content': [{\n        content: ['normal', ...scaleAlignPrimaryAxis()]\n      }],\n      /**\n       * Align Items\n       * @see https://tailwindcss.com/docs/align-items\n       */\n      'align-items': [{\n        items: [...scaleAlignSecondaryAxis(), {\n          baseline: ['', 'last']\n        }]\n      }],\n      /**\n       * Align Self\n       * @see https://tailwindcss.com/docs/align-self\n       */\n      'align-self': [{\n        self: ['auto', ...scaleAlignSecondaryAxis(), {\n          baseline: ['', 'last']\n        }]\n      }],\n      /**\n       * Place Content\n       * @see https://tailwindcss.com/docs/place-content\n       */\n      'place-content': [{\n        'place-content': scaleAlignPrimaryAxis()\n      }],\n      /**\n       * Place Items\n       * @see https://tailwindcss.com/docs/place-items\n       */\n      'place-items': [{\n        'place-items': [...scaleAlignSecondaryAxis(), 'baseline']\n      }],\n      /**\n       * Place Self\n       * @see https://tailwindcss.com/docs/place-self\n       */\n      'place-self': [{\n        'place-self': ['auto', ...scaleAlignSecondaryAxis()]\n      }],\n      // Spacing\n      /**\n       * Padding\n       * @see https://tailwindcss.com/docs/padding\n       */\n      p: [{\n        p: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding X\n       * @see https://tailwindcss.com/docs/padding\n       */\n      px: [{\n        px: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Y\n       * @see https://tailwindcss.com/docs/padding\n       */\n      py: [{\n        py: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Start\n       * @see https://tailwindcss.com/docs/padding\n       */\n      ps: [{\n        ps: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding End\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pe: [{\n        pe: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Top\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pt: [{\n        pt: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Right\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pr: [{\n        pr: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Bottom\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pb: [{\n        pb: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Left\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pl: [{\n        pl: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Margin\n       * @see https://tailwindcss.com/docs/margin\n       */\n      m: [{\n        m: scaleMargin()\n      }],\n      /**\n       * Margin X\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mx: [{\n        mx: scaleMargin()\n      }],\n      /**\n       * Margin Y\n       * @see https://tailwindcss.com/docs/margin\n       */\n      my: [{\n        my: scaleMargin()\n      }],\n      /**\n       * Margin Start\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ms: [{\n        ms: scaleMargin()\n      }],\n      /**\n       * Margin End\n       * @see https://tailwindcss.com/docs/margin\n       */\n      me: [{\n        me: scaleMargin()\n      }],\n      /**\n       * Margin Top\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mt: [{\n        mt: scaleMargin()\n      }],\n      /**\n       * Margin Right\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mr: [{\n        mr: scaleMargin()\n      }],\n      /**\n       * Margin Bottom\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mb: [{\n        mb: scaleMargin()\n      }],\n      /**\n       * Margin Left\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ml: [{\n        ml: scaleMargin()\n      }],\n      /**\n       * Space Between X\n       * @see https://tailwindcss.com/docs/margin#adding-space-between-children\n       */\n      'space-x': [{\n        'space-x': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Space Between X Reverse\n       * @see https://tailwindcss.com/docs/margin#adding-space-between-children\n       */\n      'space-x-reverse': ['space-x-reverse'],\n      /**\n       * Space Between Y\n       * @see https://tailwindcss.com/docs/margin#adding-space-between-children\n       */\n      'space-y': [{\n        'space-y': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Space Between Y Reverse\n       * @see https://tailwindcss.com/docs/margin#adding-space-between-children\n       */\n      'space-y-reverse': ['space-y-reverse'],\n      // --------------\n      // --- Sizing ---\n      // --------------\n      /**\n       * Size\n       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height\n       */\n      size: [{\n        size: scaleSizing()\n      }],\n      /**\n       * Width\n       * @see https://tailwindcss.com/docs/width\n       */\n      w: [{\n        w: [themeContainer, 'screen', ...scaleSizing()]\n      }],\n      /**\n       * Min-Width\n       * @see https://tailwindcss.com/docs/min-width\n       */\n      'min-w': [{\n        'min-w': [themeContainer, 'screen', /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */\n        'none', ...scaleSizing()]\n      }],\n      /**\n       * Max-Width\n       * @see https://tailwindcss.com/docs/max-width\n       */\n      'max-w': [{\n        'max-w': [themeContainer, 'screen', 'none', /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */\n        'prose', /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */\n        {\n          screen: [themeBreakpoint]\n        }, ...scaleSizing()]\n      }],\n      /**\n       * Height\n       * @see https://tailwindcss.com/docs/height\n       */\n      h: [{\n        h: ['screen', 'lh', ...scaleSizing()]\n      }],\n      /**\n       * Min-Height\n       * @see https://tailwindcss.com/docs/min-height\n       */\n      'min-h': [{\n        'min-h': ['screen', 'lh', 'none', ...scaleSizing()]\n      }],\n      /**\n       * Max-Height\n       * @see https://tailwindcss.com/docs/max-height\n       */\n      'max-h': [{\n        'max-h': ['screen', 'lh', ...scaleSizing()]\n      }],\n      // ------------------\n      // --- Typography ---\n      // ------------------\n      /**\n       * Font Size\n       * @see https://tailwindcss.com/docs/font-size\n       */\n      'font-size': [{\n        text: ['base', themeText, isArbitraryVariableLength, isArbitraryLength]\n      }],\n      /**\n       * Font Smoothing\n       * @see https://tailwindcss.com/docs/font-smoothing\n       */\n      'font-smoothing': ['antialiased', 'subpixel-antialiased'],\n      /**\n       * Font Style\n       * @see https://tailwindcss.com/docs/font-style\n       */\n      'font-style': ['italic', 'not-italic'],\n      /**\n       * Font Weight\n       * @see https://tailwindcss.com/docs/font-weight\n       */\n      'font-weight': [{\n        font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]\n      }],\n      /**\n       * Font Stretch\n       * @see https://tailwindcss.com/docs/font-stretch\n       */\n      'font-stretch': [{\n        'font-stretch': ['ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'normal', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded', isPercent, isArbitraryValue]\n      }],\n      /**\n       * Font Family\n       * @see https://tailwindcss.com/docs/font-family\n       */\n      'font-family': [{\n        font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]\n      }],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-normal': ['normal-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-ordinal': ['ordinal'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-slashed-zero': ['slashed-zero'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-figure': ['lining-nums', 'oldstyle-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-spacing': ['proportional-nums', 'tabular-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-fraction': ['diagonal-fractions', 'stacked-fractions'],\n      /**\n       * Letter Spacing\n       * @see https://tailwindcss.com/docs/letter-spacing\n       */\n      tracking: [{\n        tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Line Clamp\n       * @see https://tailwindcss.com/docs/line-clamp\n       */\n      'line-clamp': [{\n        'line-clamp': [isNumber, 'none', isArbitraryVariable, isArbitraryNumber]\n      }],\n      /**\n       * Line Height\n       * @see https://tailwindcss.com/docs/line-height\n       */\n      leading: [{\n        leading: [/** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */\n        themeLeading, ...scaleUnambiguousSpacing()]\n      }],\n      /**\n       * List Style Image\n       * @see https://tailwindcss.com/docs/list-style-image\n       */\n      'list-image': [{\n        'list-image': ['none', isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * List Style Position\n       * @see https://tailwindcss.com/docs/list-style-position\n       */\n      'list-style-position': [{\n        list: ['inside', 'outside']\n      }],\n      /**\n       * List Style Type\n       * @see https://tailwindcss.com/docs/list-style-type\n       */\n      'list-style-type': [{\n        list: ['disc', 'decimal', 'none', isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Text Alignment\n       * @see https://tailwindcss.com/docs/text-align\n       */\n      'text-alignment': [{\n        text: ['left', 'center', 'right', 'justify', 'start', 'end']\n      }],\n      /**\n       * Placeholder Color\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://v3.tailwindcss.com/docs/placeholder-color\n       */\n      'placeholder-color': [{\n        placeholder: scaleColor()\n      }],\n      /**\n       * Text Color\n       * @see https://tailwindcss.com/docs/text-color\n       */\n      'text-color': [{\n        text: scaleColor()\n      }],\n      /**\n       * Text Decoration\n       * @see https://tailwindcss.com/docs/text-decoration\n       */\n      'text-decoration': ['underline', 'overline', 'line-through', 'no-underline'],\n      /**\n       * Text Decoration Style\n       * @see https://tailwindcss.com/docs/text-decoration-style\n       */\n      'text-decoration-style': [{\n        decoration: [...scaleLineStyle(), 'wavy']\n      }],\n      /**\n       * Text Decoration Thickness\n       * @see https://tailwindcss.com/docs/text-decoration-thickness\n       */\n      'text-decoration-thickness': [{\n        decoration: [isNumber, 'from-font', 'auto', isArbitraryVariable, isArbitraryLength]\n      }],\n      /**\n       * Text Decoration Color\n       * @see https://tailwindcss.com/docs/text-decoration-color\n       */\n      'text-decoration-color': [{\n        decoration: scaleColor()\n      }],\n      /**\n       * Text Underline Offset\n       * @see https://tailwindcss.com/docs/text-underline-offset\n       */\n      'underline-offset': [{\n        'underline-offset': [isNumber, 'auto', isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Text Transform\n       * @see https://tailwindcss.com/docs/text-transform\n       */\n      'text-transform': ['uppercase', 'lowercase', 'capitalize', 'normal-case'],\n      /**\n       * Text Overflow\n       * @see https://tailwindcss.com/docs/text-overflow\n       */\n      'text-overflow': ['truncate', 'text-ellipsis', 'text-clip'],\n      /**\n       * Text Wrap\n       * @see https://tailwindcss.com/docs/text-wrap\n       */\n      'text-wrap': [{\n        text: ['wrap', 'nowrap', 'balance', 'pretty']\n      }],\n      /**\n       * Text Indent\n       * @see https://tailwindcss.com/docs/text-indent\n       */\n      indent: [{\n        indent: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Vertical Alignment\n       * @see https://tailwindcss.com/docs/vertical-align\n       */\n      'vertical-align': [{\n        align: ['baseline', 'top', 'middle', 'bottom', 'text-top', 'text-bottom', 'sub', 'super', isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Whitespace\n       * @see https://tailwindcss.com/docs/whitespace\n       */\n      whitespace: [{\n        whitespace: ['normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'break-spaces']\n      }],\n      /**\n       * Word Break\n       * @see https://tailwindcss.com/docs/word-break\n       */\n      break: [{\n        break: ['normal', 'words', 'all', 'keep']\n      }],\n      /**\n       * Overflow Wrap\n       * @see https://tailwindcss.com/docs/overflow-wrap\n       */\n      wrap: [{\n        wrap: ['break-word', 'anywhere', 'normal']\n      }],\n      /**\n       * Hyphens\n       * @see https://tailwindcss.com/docs/hyphens\n       */\n      hyphens: [{\n        hyphens: ['none', 'manual', 'auto']\n      }],\n      /**\n       * Content\n       * @see https://tailwindcss.com/docs/content\n       */\n      content: [{\n        content: ['none', isArbitraryVariable, isArbitraryValue]\n      }],\n      // -------------------\n      // --- Backgrounds ---\n      // -------------------\n      /**\n       * Background Attachment\n       * @see https://tailwindcss.com/docs/background-attachment\n       */\n      'bg-attachment': [{\n        bg: ['fixed', 'local', 'scroll']\n      }],\n      /**\n       * Background Clip\n       * @see https://tailwindcss.com/docs/background-clip\n       */\n      'bg-clip': [{\n        'bg-clip': ['border', 'padding', 'content', 'text']\n      }],\n      /**\n       * Background Origin\n       * @see https://tailwindcss.com/docs/background-origin\n       */\n      'bg-origin': [{\n        'bg-origin': ['border', 'padding', 'content']\n      }],\n      /**\n       * Background Position\n       * @see https://tailwindcss.com/docs/background-position\n       */\n      'bg-position': [{\n        bg: scaleBgPosition()\n      }],\n      /**\n       * Background Repeat\n       * @see https://tailwindcss.com/docs/background-repeat\n       */\n      'bg-repeat': [{\n        bg: scaleBgRepeat()\n      }],\n      /**\n       * Background Size\n       * @see https://tailwindcss.com/docs/background-size\n       */\n      'bg-size': [{\n        bg: scaleBgSize()\n      }],\n      /**\n       * Background Image\n       * @see https://tailwindcss.com/docs/background-image\n       */\n      'bg-image': [{\n        bg: ['none', {\n          linear: [{\n            to: ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl']\n          }, isInteger, isArbitraryVariable, isArbitraryValue],\n          radial: ['', isArbitraryVariable, isArbitraryValue],\n          conic: [isInteger, isArbitraryVariable, isArbitraryValue]\n        }, isArbitraryVariableImage, isArbitraryImage]\n      }],\n      /**\n       * Background Color\n       * @see https://tailwindcss.com/docs/background-color\n       */\n      'bg-color': [{\n        bg: scaleColor()\n      }],\n      /**\n       * Gradient Color Stops From Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-from-pos': [{\n        from: scaleGradientStopPosition()\n      }],\n      /**\n       * Gradient Color Stops Via Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-via-pos': [{\n        via: scaleGradientStopPosition()\n      }],\n      /**\n       * Gradient Color Stops To Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-to-pos': [{\n        to: scaleGradientStopPosition()\n      }],\n      /**\n       * Gradient Color Stops From\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-from': [{\n        from: scaleColor()\n      }],\n      /**\n       * Gradient Color Stops Via\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-via': [{\n        via: scaleColor()\n      }],\n      /**\n       * Gradient Color Stops To\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-to': [{\n        to: scaleColor()\n      }],\n      // ---------------\n      // --- Borders ---\n      // ---------------\n      /**\n       * Border Radius\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      rounded: [{\n        rounded: scaleRadius()\n      }],\n      /**\n       * Border Radius Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-s': [{\n        'rounded-s': scaleRadius()\n      }],\n      /**\n       * Border Radius End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-e': [{\n        'rounded-e': scaleRadius()\n      }],\n      /**\n       * Border Radius Top\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-t': [{\n        'rounded-t': scaleRadius()\n      }],\n      /**\n       * Border Radius Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-r': [{\n        'rounded-r': scaleRadius()\n      }],\n      /**\n       * Border Radius Bottom\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-b': [{\n        'rounded-b': scaleRadius()\n      }],\n      /**\n       * Border Radius Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-l': [{\n        'rounded-l': scaleRadius()\n      }],\n      /**\n       * Border Radius Start Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-ss': [{\n        'rounded-ss': scaleRadius()\n      }],\n      /**\n       * Border Radius Start End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-se': [{\n        'rounded-se': scaleRadius()\n      }],\n      /**\n       * Border Radius End End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-ee': [{\n        'rounded-ee': scaleRadius()\n      }],\n      /**\n       * Border Radius End Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-es': [{\n        'rounded-es': scaleRadius()\n      }],\n      /**\n       * Border Radius Top Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-tl': [{\n        'rounded-tl': scaleRadius()\n      }],\n      /**\n       * Border Radius Top Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-tr': [{\n        'rounded-tr': scaleRadius()\n      }],\n      /**\n       * Border Radius Bottom Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-br': [{\n        'rounded-br': scaleRadius()\n      }],\n      /**\n       * Border Radius Bottom Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-bl': [{\n        'rounded-bl': scaleRadius()\n      }],\n      /**\n       * Border Width\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w': [{\n        border: scaleBorderWidth()\n      }],\n      /**\n       * Border Width X\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-x': [{\n        'border-x': scaleBorderWidth()\n      }],\n      /**\n       * Border Width Y\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-y': [{\n        'border-y': scaleBorderWidth()\n      }],\n      /**\n       * Border Width Start\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-s': [{\n        'border-s': scaleBorderWidth()\n      }],\n      /**\n       * Border Width End\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-e': [{\n        'border-e': scaleBorderWidth()\n      }],\n      /**\n       * Border Width Top\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-t': [{\n        'border-t': scaleBorderWidth()\n      }],\n      /**\n       * Border Width Right\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-r': [{\n        'border-r': scaleBorderWidth()\n      }],\n      /**\n       * Border Width Bottom\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-b': [{\n        'border-b': scaleBorderWidth()\n      }],\n      /**\n       * Border Width Left\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-l': [{\n        'border-l': scaleBorderWidth()\n      }],\n      /**\n       * Divide Width X\n       * @see https://tailwindcss.com/docs/border-width#between-children\n       */\n      'divide-x': [{\n        'divide-x': scaleBorderWidth()\n      }],\n      /**\n       * Divide Width X Reverse\n       * @see https://tailwindcss.com/docs/border-width#between-children\n       */\n      'divide-x-reverse': ['divide-x-reverse'],\n      /**\n       * Divide Width Y\n       * @see https://tailwindcss.com/docs/border-width#between-children\n       */\n      'divide-y': [{\n        'divide-y': scaleBorderWidth()\n      }],\n      /**\n       * Divide Width Y Reverse\n       * @see https://tailwindcss.com/docs/border-width#between-children\n       */\n      'divide-y-reverse': ['divide-y-reverse'],\n      /**\n       * Border Style\n       * @see https://tailwindcss.com/docs/border-style\n       */\n      'border-style': [{\n        border: [...scaleLineStyle(), 'hidden', 'none']\n      }],\n      /**\n       * Divide Style\n       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style\n       */\n      'divide-style': [{\n        divide: [...scaleLineStyle(), 'hidden', 'none']\n      }],\n      /**\n       * Border Color\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color': [{\n        border: scaleColor()\n      }],\n      /**\n       * Border Color X\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-x': [{\n        'border-x': scaleColor()\n      }],\n      /**\n       * Border Color Y\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-y': [{\n        'border-y': scaleColor()\n      }],\n      /**\n       * Border Color S\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-s': [{\n        'border-s': scaleColor()\n      }],\n      /**\n       * Border Color E\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-e': [{\n        'border-e': scaleColor()\n      }],\n      /**\n       * Border Color Top\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-t': [{\n        'border-t': scaleColor()\n      }],\n      /**\n       * Border Color Right\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-r': [{\n        'border-r': scaleColor()\n      }],\n      /**\n       * Border Color Bottom\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-b': [{\n        'border-b': scaleColor()\n      }],\n      /**\n       * Border Color Left\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-l': [{\n        'border-l': scaleColor()\n      }],\n      /**\n       * Divide Color\n       * @see https://tailwindcss.com/docs/divide-color\n       */\n      'divide-color': [{\n        divide: scaleColor()\n      }],\n      /**\n       * Outline Style\n       * @see https://tailwindcss.com/docs/outline-style\n       */\n      'outline-style': [{\n        outline: [...scaleLineStyle(), 'none', 'hidden']\n      }],\n      /**\n       * Outline Offset\n       * @see https://tailwindcss.com/docs/outline-offset\n       */\n      'outline-offset': [{\n        'outline-offset': [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Outline Width\n       * @see https://tailwindcss.com/docs/outline-width\n       */\n      'outline-w': [{\n        outline: ['', isNumber, isArbitraryVariableLength, isArbitraryLength]\n      }],\n      /**\n       * Outline Color\n       * @see https://tailwindcss.com/docs/outline-color\n       */\n      'outline-color': [{\n        outline: scaleColor()\n      }],\n      // ---------------\n      // --- Effects ---\n      // ---------------\n      /**\n       * Box Shadow\n       * @see https://tailwindcss.com/docs/box-shadow\n       */\n      shadow: [{\n        shadow: [\n        // Deprecated since Tailwind CSS v4.0.0\n        '', 'none', themeShadow, isArbitraryVariableShadow, isArbitraryShadow]\n      }],\n      /**\n       * Box Shadow Color\n       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color\n       */\n      'shadow-color': [{\n        shadow: scaleColor()\n      }],\n      /**\n       * Inset Box Shadow\n       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow\n       */\n      'inset-shadow': [{\n        'inset-shadow': ['none', themeInsetShadow, isArbitraryVariableShadow, isArbitraryShadow]\n      }],\n      /**\n       * Inset Box Shadow Color\n       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color\n       */\n      'inset-shadow-color': [{\n        'inset-shadow': scaleColor()\n      }],\n      /**\n       * Ring Width\n       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring\n       */\n      'ring-w': [{\n        ring: scaleBorderWidth()\n      }],\n      /**\n       * Ring Width Inset\n       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings\n       * @deprecated since Tailwind CSS v4.0.0\n       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158\n       */\n      'ring-w-inset': ['ring-inset'],\n      /**\n       * Ring Color\n       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color\n       */\n      'ring-color': [{\n        ring: scaleColor()\n      }],\n      /**\n       * Ring Offset Width\n       * @see https://v3.tailwindcss.com/docs/ring-offset-width\n       * @deprecated since Tailwind CSS v4.0.0\n       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158\n       */\n      'ring-offset-w': [{\n        'ring-offset': [isNumber, isArbitraryLength]\n      }],\n      /**\n       * Ring Offset Color\n       * @see https://v3.tailwindcss.com/docs/ring-offset-color\n       * @deprecated since Tailwind CSS v4.0.0\n       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158\n       */\n      'ring-offset-color': [{\n        'ring-offset': scaleColor()\n      }],\n      /**\n       * Inset Ring Width\n       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring\n       */\n      'inset-ring-w': [{\n        'inset-ring': scaleBorderWidth()\n      }],\n      /**\n       * Inset Ring Color\n       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color\n       */\n      'inset-ring-color': [{\n        'inset-ring': scaleColor()\n      }],\n      /**\n       * Text Shadow\n       * @see https://tailwindcss.com/docs/text-shadow\n       */\n      'text-shadow': [{\n        'text-shadow': ['none', themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow]\n      }],\n      /**\n       * Text Shadow Color\n       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color\n       */\n      'text-shadow-color': [{\n        'text-shadow': scaleColor()\n      }],\n      /**\n       * Opacity\n       * @see https://tailwindcss.com/docs/opacity\n       */\n      opacity: [{\n        opacity: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Mix Blend Mode\n       * @see https://tailwindcss.com/docs/mix-blend-mode\n       */\n      'mix-blend': [{\n        'mix-blend': [...scaleBlendMode(), 'plus-darker', 'plus-lighter']\n      }],\n      /**\n       * Background Blend Mode\n       * @see https://tailwindcss.com/docs/background-blend-mode\n       */\n      'bg-blend': [{\n        'bg-blend': scaleBlendMode()\n      }],\n      /**\n       * Mask Clip\n       * @see https://tailwindcss.com/docs/mask-clip\n       */\n      'mask-clip': [{\n        'mask-clip': ['border', 'padding', 'content', 'fill', 'stroke', 'view']\n      }, 'mask-no-clip'],\n      /**\n       * Mask Composite\n       * @see https://tailwindcss.com/docs/mask-composite\n       */\n      'mask-composite': [{\n        mask: ['add', 'subtract', 'intersect', 'exclude']\n      }],\n      /**\n       * Mask Image\n       * @see https://tailwindcss.com/docs/mask-image\n       */\n      'mask-image-linear-pos': [{\n        'mask-linear': [isNumber]\n      }],\n      'mask-image-linear-from-pos': [{\n        'mask-linear-from': scaleMaskImagePosition()\n      }],\n      'mask-image-linear-to-pos': [{\n        'mask-linear-to': scaleMaskImagePosition()\n      }],\n      'mask-image-linear-from-color': [{\n        'mask-linear-from': scaleColor()\n      }],\n      'mask-image-linear-to-color': [{\n        'mask-linear-to': scaleColor()\n      }],\n      'mask-image-t-from-pos': [{\n        'mask-t-from': scaleMaskImagePosition()\n      }],\n      'mask-image-t-to-pos': [{\n        'mask-t-to': scaleMaskImagePosition()\n      }],\n      'mask-image-t-from-color': [{\n        'mask-t-from': scaleColor()\n      }],\n      'mask-image-t-to-color': [{\n        'mask-t-to': scaleColor()\n      }],\n      'mask-image-r-from-pos': [{\n        'mask-r-from': scaleMaskImagePosition()\n      }],\n      'mask-image-r-to-pos': [{\n        'mask-r-to': scaleMaskImagePosition()\n      }],\n      'mask-image-r-from-color': [{\n        'mask-r-from': scaleColor()\n      }],\n      'mask-image-r-to-color': [{\n        'mask-r-to': scaleColor()\n      }],\n      'mask-image-b-from-pos': [{\n        'mask-b-from': scaleMaskImagePosition()\n      }],\n      'mask-image-b-to-pos': [{\n        'mask-b-to': scaleMaskImagePosition()\n      }],\n      'mask-image-b-from-color': [{\n        'mask-b-from': scaleColor()\n      }],\n      'mask-image-b-to-color': [{\n        'mask-b-to': scaleColor()\n      }],\n      'mask-image-l-from-pos': [{\n        'mask-l-from': scaleMaskImagePosition()\n      }],\n      'mask-image-l-to-pos': [{\n        'mask-l-to': scaleMaskImagePosition()\n      }],\n      'mask-image-l-from-color': [{\n        'mask-l-from': scaleColor()\n      }],\n      'mask-image-l-to-color': [{\n        'mask-l-to': scaleColor()\n      }],\n      'mask-image-x-from-pos': [{\n        'mask-x-from': scaleMaskImagePosition()\n      }],\n      'mask-image-x-to-pos': [{\n        'mask-x-to': scaleMaskImagePosition()\n      }],\n      'mask-image-x-from-color': [{\n        'mask-x-from': scaleColor()\n      }],\n      'mask-image-x-to-color': [{\n        'mask-x-to': scaleColor()\n      }],\n      'mask-image-y-from-pos': [{\n        'mask-y-from': scaleMaskImagePosition()\n      }],\n      'mask-image-y-to-pos': [{\n        'mask-y-to': scaleMaskImagePosition()\n      }],\n      'mask-image-y-from-color': [{\n        'mask-y-from': scaleColor()\n      }],\n      'mask-image-y-to-color': [{\n        'mask-y-to': scaleColor()\n      }],\n      'mask-image-radial': [{\n        'mask-radial': [isArbitraryVariable, isArbitraryValue]\n      }],\n      'mask-image-radial-from-pos': [{\n        'mask-radial-from': scaleMaskImagePosition()\n      }],\n      'mask-image-radial-to-pos': [{\n        'mask-radial-to': scaleMaskImagePosition()\n      }],\n      'mask-image-radial-from-color': [{\n        'mask-radial-from': scaleColor()\n      }],\n      'mask-image-radial-to-color': [{\n        'mask-radial-to': scaleColor()\n      }],\n      'mask-image-radial-shape': [{\n        'mask-radial': ['circle', 'ellipse']\n      }],\n      'mask-image-radial-size': [{\n        'mask-radial': [{\n          closest: ['side', 'corner'],\n          farthest: ['side', 'corner']\n        }]\n      }],\n      'mask-image-radial-pos': [{\n        'mask-radial-at': scalePosition()\n      }],\n      'mask-image-conic-pos': [{\n        'mask-conic': [isNumber]\n      }],\n      'mask-image-conic-from-pos': [{\n        'mask-conic-from': scaleMaskImagePosition()\n      }],\n      'mask-image-conic-to-pos': [{\n        'mask-conic-to': scaleMaskImagePosition()\n      }],\n      'mask-image-conic-from-color': [{\n        'mask-conic-from': scaleColor()\n      }],\n      'mask-image-conic-to-color': [{\n        'mask-conic-to': scaleColor()\n      }],\n      /**\n       * Mask Mode\n       * @see https://tailwindcss.com/docs/mask-mode\n       */\n      'mask-mode': [{\n        mask: ['alpha', 'luminance', 'match']\n      }],\n      /**\n       * Mask Origin\n       * @see https://tailwindcss.com/docs/mask-origin\n       */\n      'mask-origin': [{\n        'mask-origin': ['border', 'padding', 'content', 'fill', 'stroke', 'view']\n      }],\n      /**\n       * Mask Position\n       * @see https://tailwindcss.com/docs/mask-position\n       */\n      'mask-position': [{\n        mask: scaleBgPosition()\n      }],\n      /**\n       * Mask Repeat\n       * @see https://tailwindcss.com/docs/mask-repeat\n       */\n      'mask-repeat': [{\n        mask: scaleBgRepeat()\n      }],\n      /**\n       * Mask Size\n       * @see https://tailwindcss.com/docs/mask-size\n       */\n      'mask-size': [{\n        mask: scaleBgSize()\n      }],\n      /**\n       * Mask Type\n       * @see https://tailwindcss.com/docs/mask-type\n       */\n      'mask-type': [{\n        'mask-type': ['alpha', 'luminance']\n      }],\n      /**\n       * Mask Image\n       * @see https://tailwindcss.com/docs/mask-image\n       */\n      'mask-image': [{\n        mask: ['none', isArbitraryVariable, isArbitraryValue]\n      }],\n      // ---------------\n      // --- Filters ---\n      // ---------------\n      /**\n       * Filter\n       * @see https://tailwindcss.com/docs/filter\n       */\n      filter: [{\n        filter: [\n        // Deprecated since Tailwind CSS v3.0.0\n        '', 'none', isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Blur\n       * @see https://tailwindcss.com/docs/blur\n       */\n      blur: [{\n        blur: scaleBlur()\n      }],\n      /**\n       * Brightness\n       * @see https://tailwindcss.com/docs/brightness\n       */\n      brightness: [{\n        brightness: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Contrast\n       * @see https://tailwindcss.com/docs/contrast\n       */\n      contrast: [{\n        contrast: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Drop Shadow\n       * @see https://tailwindcss.com/docs/drop-shadow\n       */\n      'drop-shadow': [{\n        'drop-shadow': [\n        // Deprecated since Tailwind CSS v4.0.0\n        '', 'none', themeDropShadow, isArbitraryVariableShadow, isArbitraryShadow]\n      }],\n      /**\n       * Drop Shadow Color\n       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color\n       */\n      'drop-shadow-color': [{\n        'drop-shadow': scaleColor()\n      }],\n      /**\n       * Grayscale\n       * @see https://tailwindcss.com/docs/grayscale\n       */\n      grayscale: [{\n        grayscale: ['', isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Hue Rotate\n       * @see https://tailwindcss.com/docs/hue-rotate\n       */\n      'hue-rotate': [{\n        'hue-rotate': [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Invert\n       * @see https://tailwindcss.com/docs/invert\n       */\n      invert: [{\n        invert: ['', isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Saturate\n       * @see https://tailwindcss.com/docs/saturate\n       */\n      saturate: [{\n        saturate: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Sepia\n       * @see https://tailwindcss.com/docs/sepia\n       */\n      sepia: [{\n        sepia: ['', isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Filter\n       * @see https://tailwindcss.com/docs/backdrop-filter\n       */\n      'backdrop-filter': [{\n        'backdrop-filter': [\n        // Deprecated since Tailwind CSS v3.0.0\n        '', 'none', isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Blur\n       * @see https://tailwindcss.com/docs/backdrop-blur\n       */\n      'backdrop-blur': [{\n        'backdrop-blur': scaleBlur()\n      }],\n      /**\n       * Backdrop Brightness\n       * @see https://tailwindcss.com/docs/backdrop-brightness\n       */\n      'backdrop-brightness': [{\n        'backdrop-brightness': [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Contrast\n       * @see https://tailwindcss.com/docs/backdrop-contrast\n       */\n      'backdrop-contrast': [{\n        'backdrop-contrast': [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Grayscale\n       * @see https://tailwindcss.com/docs/backdrop-grayscale\n       */\n      'backdrop-grayscale': [{\n        'backdrop-grayscale': ['', isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Hue Rotate\n       * @see https://tailwindcss.com/docs/backdrop-hue-rotate\n       */\n      'backdrop-hue-rotate': [{\n        'backdrop-hue-rotate': [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Invert\n       * @see https://tailwindcss.com/docs/backdrop-invert\n       */\n      'backdrop-invert': [{\n        'backdrop-invert': ['', isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Opacity\n       * @see https://tailwindcss.com/docs/backdrop-opacity\n       */\n      'backdrop-opacity': [{\n        'backdrop-opacity': [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Saturate\n       * @see https://tailwindcss.com/docs/backdrop-saturate\n       */\n      'backdrop-saturate': [{\n        'backdrop-saturate': [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Sepia\n       * @see https://tailwindcss.com/docs/backdrop-sepia\n       */\n      'backdrop-sepia': [{\n        'backdrop-sepia': ['', isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      // --------------\n      // --- Tables ---\n      // --------------\n      /**\n       * Border Collapse\n       * @see https://tailwindcss.com/docs/border-collapse\n       */\n      'border-collapse': [{\n        border: ['collapse', 'separate']\n      }],\n      /**\n       * Border Spacing\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing': [{\n        'border-spacing': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Border Spacing X\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing-x': [{\n        'border-spacing-x': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Border Spacing Y\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing-y': [{\n        'border-spacing-y': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Table Layout\n       * @see https://tailwindcss.com/docs/table-layout\n       */\n      'table-layout': [{\n        table: ['auto', 'fixed']\n      }],\n      /**\n       * Caption Side\n       * @see https://tailwindcss.com/docs/caption-side\n       */\n      caption: [{\n        caption: ['top', 'bottom']\n      }],\n      // ---------------------------------\n      // --- Transitions and Animation ---\n      // ---------------------------------\n      /**\n       * Transition Property\n       * @see https://tailwindcss.com/docs/transition-property\n       */\n      transition: [{\n        transition: ['', 'all', 'colors', 'opacity', 'shadow', 'transform', 'none', isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Transition Behavior\n       * @see https://tailwindcss.com/docs/transition-behavior\n       */\n      'transition-behavior': [{\n        transition: ['normal', 'discrete']\n      }],\n      /**\n       * Transition Duration\n       * @see https://tailwindcss.com/docs/transition-duration\n       */\n      duration: [{\n        duration: [isNumber, 'initial', isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Transition Timing Function\n       * @see https://tailwindcss.com/docs/transition-timing-function\n       */\n      ease: [{\n        ease: ['linear', 'initial', themeEase, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Transition Delay\n       * @see https://tailwindcss.com/docs/transition-delay\n       */\n      delay: [{\n        delay: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Animation\n       * @see https://tailwindcss.com/docs/animation\n       */\n      animate: [{\n        animate: ['none', themeAnimate, isArbitraryVariable, isArbitraryValue]\n      }],\n      // ------------------\n      // --- Transforms ---\n      // ------------------\n      /**\n       * Backface Visibility\n       * @see https://tailwindcss.com/docs/backface-visibility\n       */\n      backface: [{\n        backface: ['hidden', 'visible']\n      }],\n      /**\n       * Perspective\n       * @see https://tailwindcss.com/docs/perspective\n       */\n      perspective: [{\n        perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Perspective Origin\n       * @see https://tailwindcss.com/docs/perspective-origin\n       */\n      'perspective-origin': [{\n        'perspective-origin': scalePositionWithArbitrary()\n      }],\n      /**\n       * Rotate\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      rotate: [{\n        rotate: scaleRotate()\n      }],\n      /**\n       * Rotate X\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      'rotate-x': [{\n        'rotate-x': scaleRotate()\n      }],\n      /**\n       * Rotate Y\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      'rotate-y': [{\n        'rotate-y': scaleRotate()\n      }],\n      /**\n       * Rotate Z\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      'rotate-z': [{\n        'rotate-z': scaleRotate()\n      }],\n      /**\n       * Scale\n       * @see https://tailwindcss.com/docs/scale\n       */\n      scale: [{\n        scale: scaleScale()\n      }],\n      /**\n       * Scale X\n       * @see https://tailwindcss.com/docs/scale\n       */\n      'scale-x': [{\n        'scale-x': scaleScale()\n      }],\n      /**\n       * Scale Y\n       * @see https://tailwindcss.com/docs/scale\n       */\n      'scale-y': [{\n        'scale-y': scaleScale()\n      }],\n      /**\n       * Scale Z\n       * @see https://tailwindcss.com/docs/scale\n       */\n      'scale-z': [{\n        'scale-z': scaleScale()\n      }],\n      /**\n       * Scale 3D\n       * @see https://tailwindcss.com/docs/scale\n       */\n      'scale-3d': ['scale-3d'],\n      /**\n       * Skew\n       * @see https://tailwindcss.com/docs/skew\n       */\n      skew: [{\n        skew: scaleSkew()\n      }],\n      /**\n       * Skew X\n       * @see https://tailwindcss.com/docs/skew\n       */\n      'skew-x': [{\n        'skew-x': scaleSkew()\n      }],\n      /**\n       * Skew Y\n       * @see https://tailwindcss.com/docs/skew\n       */\n      'skew-y': [{\n        'skew-y': scaleSkew()\n      }],\n      /**\n       * Transform\n       * @see https://tailwindcss.com/docs/transform\n       */\n      transform: [{\n        transform: [isArbitraryVariable, isArbitraryValue, '', 'none', 'gpu', 'cpu']\n      }],\n      /**\n       * Transform Origin\n       * @see https://tailwindcss.com/docs/transform-origin\n       */\n      'transform-origin': [{\n        origin: scalePositionWithArbitrary()\n      }],\n      /**\n       * Transform Style\n       * @see https://tailwindcss.com/docs/transform-style\n       */\n      'transform-style': [{\n        transform: ['3d', 'flat']\n      }],\n      /**\n       * Translate\n       * @see https://tailwindcss.com/docs/translate\n       */\n      translate: [{\n        translate: scaleTranslate()\n      }],\n      /**\n       * Translate X\n       * @see https://tailwindcss.com/docs/translate\n       */\n      'translate-x': [{\n        'translate-x': scaleTranslate()\n      }],\n      /**\n       * Translate Y\n       * @see https://tailwindcss.com/docs/translate\n       */\n      'translate-y': [{\n        'translate-y': scaleTranslate()\n      }],\n      /**\n       * Translate Z\n       * @see https://tailwindcss.com/docs/translate\n       */\n      'translate-z': [{\n        'translate-z': scaleTranslate()\n      }],\n      /**\n       * Translate None\n       * @see https://tailwindcss.com/docs/translate\n       */\n      'translate-none': ['translate-none'],\n      // ---------------------\n      // --- Interactivity ---\n      // ---------------------\n      /**\n       * Accent Color\n       * @see https://tailwindcss.com/docs/accent-color\n       */\n      accent: [{\n        accent: scaleColor()\n      }],\n      /**\n       * Appearance\n       * @see https://tailwindcss.com/docs/appearance\n       */\n      appearance: [{\n        appearance: ['none', 'auto']\n      }],\n      /**\n       * Caret Color\n       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities\n       */\n      'caret-color': [{\n        caret: scaleColor()\n      }],\n      /**\n       * Color Scheme\n       * @see https://tailwindcss.com/docs/color-scheme\n       */\n      'color-scheme': [{\n        scheme: ['normal', 'dark', 'light', 'light-dark', 'only-dark', 'only-light']\n      }],\n      /**\n       * Cursor\n       * @see https://tailwindcss.com/docs/cursor\n       */\n      cursor: [{\n        cursor: ['auto', 'default', 'pointer', 'wait', 'text', 'move', 'help', 'not-allowed', 'none', 'context-menu', 'progress', 'cell', 'crosshair', 'vertical-text', 'alias', 'copy', 'no-drop', 'grab', 'grabbing', 'all-scroll', 'col-resize', 'row-resize', 'n-resize', 'e-resize', 's-resize', 'w-resize', 'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'ew-resize', 'ns-resize', 'nesw-resize', 'nwse-resize', 'zoom-in', 'zoom-out', isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Field Sizing\n       * @see https://tailwindcss.com/docs/field-sizing\n       */\n      'field-sizing': [{\n        'field-sizing': ['fixed', 'content']\n      }],\n      /**\n       * Pointer Events\n       * @see https://tailwindcss.com/docs/pointer-events\n       */\n      'pointer-events': [{\n        'pointer-events': ['auto', 'none']\n      }],\n      /**\n       * Resize\n       * @see https://tailwindcss.com/docs/resize\n       */\n      resize: [{\n        resize: ['none', '', 'y', 'x']\n      }],\n      /**\n       * Scroll Behavior\n       * @see https://tailwindcss.com/docs/scroll-behavior\n       */\n      'scroll-behavior': [{\n        scroll: ['auto', 'smooth']\n      }],\n      /**\n       * Scroll Margin\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-m': [{\n        'scroll-m': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin X\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mx': [{\n        'scroll-mx': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Y\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-my': [{\n        'scroll-my': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Start\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-ms': [{\n        'scroll-ms': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin End\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-me': [{\n        'scroll-me': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Top\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mt': [{\n        'scroll-mt': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Right\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mr': [{\n        'scroll-mr': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Bottom\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mb': [{\n        'scroll-mb': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Left\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-ml': [{\n        'scroll-ml': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-p': [{\n        'scroll-p': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding X\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-px': [{\n        'scroll-px': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Y\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-py': [{\n        'scroll-py': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Start\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-ps': [{\n        'scroll-ps': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding End\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pe': [{\n        'scroll-pe': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Top\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pt': [{\n        'scroll-pt': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Right\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pr': [{\n        'scroll-pr': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Bottom\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pb': [{\n        'scroll-pb': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Left\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pl': [{\n        'scroll-pl': scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Snap Align\n       * @see https://tailwindcss.com/docs/scroll-snap-align\n       */\n      'snap-align': [{\n        snap: ['start', 'end', 'center', 'align-none']\n      }],\n      /**\n       * Scroll Snap Stop\n       * @see https://tailwindcss.com/docs/scroll-snap-stop\n       */\n      'snap-stop': [{\n        snap: ['normal', 'always']\n      }],\n      /**\n       * Scroll Snap Type\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      'snap-type': [{\n        snap: ['none', 'x', 'y', 'both']\n      }],\n      /**\n       * Scroll Snap Type Strictness\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      'snap-strictness': [{\n        snap: ['mandatory', 'proximity']\n      }],\n      /**\n       * Touch Action\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      touch: [{\n        touch: ['auto', 'none', 'manipulation']\n      }],\n      /**\n       * Touch Action X\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-x': [{\n        'touch-pan': ['x', 'left', 'right']\n      }],\n      /**\n       * Touch Action Y\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-y': [{\n        'touch-pan': ['y', 'up', 'down']\n      }],\n      /**\n       * Touch Action Pinch Zoom\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-pz': ['touch-pinch-zoom'],\n      /**\n       * User Select\n       * @see https://tailwindcss.com/docs/user-select\n       */\n      select: [{\n        select: ['none', 'text', 'all', 'auto']\n      }],\n      /**\n       * Will Change\n       * @see https://tailwindcss.com/docs/will-change\n       */\n      'will-change': [{\n        'will-change': ['auto', 'scroll', 'contents', 'transform', isArbitraryVariable, isArbitraryValue]\n      }],\n      // -----------\n      // --- SVG ---\n      // -----------\n      /**\n       * Fill\n       * @see https://tailwindcss.com/docs/fill\n       */\n      fill: [{\n        fill: ['none', ...scaleColor()]\n      }],\n      /**\n       * Stroke Width\n       * @see https://tailwindcss.com/docs/stroke-width\n       */\n      'stroke-w': [{\n        stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]\n      }],\n      /**\n       * Stroke\n       * @see https://tailwindcss.com/docs/stroke\n       */\n      stroke: [{\n        stroke: ['none', ...scaleColor()]\n      }],\n      // ---------------------\n      // --- Accessibility ---\n      // ---------------------\n      /**\n       * Forced Color Adjust\n       * @see https://tailwindcss.com/docs/forced-color-adjust\n       */\n      'forced-color-adjust': [{\n        'forced-color-adjust': ['auto', 'none']\n      }]\n    },\n    conflictingClassGroups: {\n      overflow: ['overflow-x', 'overflow-y'],\n      overscroll: ['overscroll-x', 'overscroll-y'],\n      inset: ['inset-x', 'inset-y', 'start', 'end', 'top', 'right', 'bottom', 'left'],\n      'inset-x': ['right', 'left'],\n      'inset-y': ['top', 'bottom'],\n      flex: ['basis', 'grow', 'shrink'],\n      gap: ['gap-x', 'gap-y'],\n      p: ['px', 'py', 'ps', 'pe', 'pt', 'pr', 'pb', 'pl'],\n      px: ['pr', 'pl'],\n      py: ['pt', 'pb'],\n      m: ['mx', 'my', 'ms', 'me', 'mt', 'mr', 'mb', 'ml'],\n      mx: ['mr', 'ml'],\n      my: ['mt', 'mb'],\n      size: ['w', 'h'],\n      'font-size': ['leading'],\n      'fvn-normal': ['fvn-ordinal', 'fvn-slashed-zero', 'fvn-figure', 'fvn-spacing', 'fvn-fraction'],\n      'fvn-ordinal': ['fvn-normal'],\n      'fvn-slashed-zero': ['fvn-normal'],\n      'fvn-figure': ['fvn-normal'],\n      'fvn-spacing': ['fvn-normal'],\n      'fvn-fraction': ['fvn-normal'],\n      'line-clamp': ['display', 'overflow'],\n      rounded: ['rounded-s', 'rounded-e', 'rounded-t', 'rounded-r', 'rounded-b', 'rounded-l', 'rounded-ss', 'rounded-se', 'rounded-ee', 'rounded-es', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'],\n      'rounded-s': ['rounded-ss', 'rounded-es'],\n      'rounded-e': ['rounded-se', 'rounded-ee'],\n      'rounded-t': ['rounded-tl', 'rounded-tr'],\n      'rounded-r': ['rounded-tr', 'rounded-br'],\n      'rounded-b': ['rounded-br', 'rounded-bl'],\n      'rounded-l': ['rounded-tl', 'rounded-bl'],\n      'border-spacing': ['border-spacing-x', 'border-spacing-y'],\n      'border-w': ['border-w-x', 'border-w-y', 'border-w-s', 'border-w-e', 'border-w-t', 'border-w-r', 'border-w-b', 'border-w-l'],\n      'border-w-x': ['border-w-r', 'border-w-l'],\n      'border-w-y': ['border-w-t', 'border-w-b'],\n      'border-color': ['border-color-x', 'border-color-y', 'border-color-s', 'border-color-e', 'border-color-t', 'border-color-r', 'border-color-b', 'border-color-l'],\n      'border-color-x': ['border-color-r', 'border-color-l'],\n      'border-color-y': ['border-color-t', 'border-color-b'],\n      translate: ['translate-x', 'translate-y', 'translate-none'],\n      'translate-none': ['translate', 'translate-x', 'translate-y', 'translate-z'],\n      'scroll-m': ['scroll-mx', 'scroll-my', 'scroll-ms', 'scroll-me', 'scroll-mt', 'scroll-mr', 'scroll-mb', 'scroll-ml'],\n      'scroll-mx': ['scroll-mr', 'scroll-ml'],\n      'scroll-my': ['scroll-mt', 'scroll-mb'],\n      'scroll-p': ['scroll-px', 'scroll-py', 'scroll-ps', 'scroll-pe', 'scroll-pt', 'scroll-pr', 'scroll-pb', 'scroll-pl'],\n      'scroll-px': ['scroll-pr', 'scroll-pl'],\n      'scroll-py': ['scroll-pt', 'scroll-pb'],\n      touch: ['touch-x', 'touch-y', 'touch-pz'],\n      'touch-x': ['touch'],\n      'touch-y': ['touch'],\n      'touch-pz': ['touch']\n    },\n    conflictingClassGroupModifiers: {\n      'font-size': ['leading']\n    },\n    orderSensitiveModifiers: ['*', '**', 'after', 'backdrop', 'before', 'details-content', 'file', 'first-letter', 'first-line', 'marker', 'placeholder', 'selection']\n  };\n};\n\n/**\n * @param baseConfig Config where other config will be merged into. This object will be mutated.\n * @param configExtension Partial config to merge into the `baseConfig`.\n */\nconst mergeConfigs = (baseConfig, {\n  cacheSize,\n  prefix,\n  experimentalParseClassName,\n  extend = {},\n  override = {}\n}) => {\n  overrideProperty(baseConfig, 'cacheSize', cacheSize);\n  overrideProperty(baseConfig, 'prefix', prefix);\n  overrideProperty(baseConfig, 'experimentalParseClassName', experimentalParseClassName);\n  overrideConfigProperties(baseConfig.theme, override.theme);\n  overrideConfigProperties(baseConfig.classGroups, override.classGroups);\n  overrideConfigProperties(baseConfig.conflictingClassGroups, override.conflictingClassGroups);\n  overrideConfigProperties(baseConfig.conflictingClassGroupModifiers, override.conflictingClassGroupModifiers);\n  overrideProperty(baseConfig, 'orderSensitiveModifiers', override.orderSensitiveModifiers);\n  mergeConfigProperties(baseConfig.theme, extend.theme);\n  mergeConfigProperties(baseConfig.classGroups, extend.classGroups);\n  mergeConfigProperties(baseConfig.conflictingClassGroups, extend.conflictingClassGroups);\n  mergeConfigProperties(baseConfig.conflictingClassGroupModifiers, extend.conflictingClassGroupModifiers);\n  mergeArrayProperties(baseConfig, extend, 'orderSensitiveModifiers');\n  return baseConfig;\n};\nconst overrideProperty = (baseObject, overrideKey, overrideValue) => {\n  if (overrideValue !== undefined) {\n    baseObject[overrideKey] = overrideValue;\n  }\n};\nconst overrideConfigProperties = (baseObject, overrideObject) => {\n  if (overrideObject) {\n    for (const key in overrideObject) {\n      overrideProperty(baseObject, key, overrideObject[key]);\n    }\n  }\n};\nconst mergeConfigProperties = (baseObject, mergeObject) => {\n  if (mergeObject) {\n    for (const key in mergeObject) {\n      mergeArrayProperties(baseObject, mergeObject, key);\n    }\n  }\n};\nconst mergeArrayProperties = (baseObject, mergeObject, key) => {\n  const mergeValue = mergeObject[key];\n  if (mergeValue !== undefined) {\n    baseObject[key] = baseObject[key] ? baseObject[key].concat(mergeValue) : mergeValue;\n  }\n};\nconst extendTailwindMerge = (configExtension, ...createConfig) => typeof configExtension === 'function' ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);\nconst twMerge = /*#__PURE__*/createTailwindMerge(getDefaultConfig);\n\n//# sourceMappingURL=bundle-mjs.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9kaXN0L2J1bmRsZS1tanMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsT0FBTyxtQkFBbUIsa0JBQWtCLGFBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0SDtBQUM1SCIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL3RhaWx3aW5kLW1lcmdlL2Rpc3QvYnVuZGxlLW1qcy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ0xBU1NfUEFSVF9TRVBBUkFUT1IgPSAnLSc7XG5jb25zdCBjcmVhdGVDbGFzc0dyb3VwVXRpbHMgPSBjb25maWcgPT4ge1xuICBjb25zdCBjbGFzc01hcCA9IGNyZWF0ZUNsYXNzTWFwKGNvbmZpZyk7XG4gIGNvbnN0IHtcbiAgICBjb25mbGljdGluZ0NsYXNzR3JvdXBzLFxuICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVyc1xuICB9ID0gY29uZmlnO1xuICBjb25zdCBnZXRDbGFzc0dyb3VwSWQgPSBjbGFzc05hbWUgPT4ge1xuICAgIGNvbnN0IGNsYXNzUGFydHMgPSBjbGFzc05hbWUuc3BsaXQoQ0xBU1NfUEFSVF9TRVBBUkFUT1IpO1xuICAgIC8vIENsYXNzZXMgbGlrZSBgLWluc2V0LTFgIHByb2R1Y2UgYW4gZW1wdHkgc3RyaW5nIGFzIGZpcnN0IGNsYXNzUGFydC4gV2UgYXNzdW1lIHRoYXQgY2xhc3NlcyBmb3IgbmVnYXRpdmUgdmFsdWVzIGFyZSB1c2VkIGNvcnJlY3RseSBhbmQgcmVtb3ZlIGl0IGZyb20gY2xhc3NQYXJ0cy5cbiAgICBpZiAoY2xhc3NQYXJ0c1swXSA9PT0gJycgJiYgY2xhc3NQYXJ0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIGNsYXNzUGFydHMuc2hpZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEdyb3VwUmVjdXJzaXZlKGNsYXNzUGFydHMsIGNsYXNzTWFwKSB8fCBnZXRHcm91cElkRm9yQXJiaXRyYXJ5UHJvcGVydHkoY2xhc3NOYW1lKTtcbiAgfTtcbiAgY29uc3QgZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzID0gKGNsYXNzR3JvdXBJZCwgaGFzUG9zdGZpeE1vZGlmaWVyKSA9PiB7XG4gICAgY29uc3QgY29uZmxpY3RzID0gY29uZmxpY3RpbmdDbGFzc0dyb3Vwc1tjbGFzc0dyb3VwSWRdIHx8IFtdO1xuICAgIGlmIChoYXNQb3N0Zml4TW9kaWZpZXIgJiYgY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzW2NsYXNzR3JvdXBJZF0pIHtcbiAgICAgIHJldHVybiBbLi4uY29uZmxpY3RzLCAuLi5jb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnNbY2xhc3NHcm91cElkXV07XG4gICAgfVxuICAgIHJldHVybiBjb25mbGljdHM7XG4gIH07XG4gIHJldHVybiB7XG4gICAgZ2V0Q2xhc3NHcm91cElkLFxuICAgIGdldENvbmZsaWN0aW5nQ2xhc3NHcm91cElkc1xuICB9O1xufTtcbmNvbnN0IGdldEdyb3VwUmVjdXJzaXZlID0gKGNsYXNzUGFydHMsIGNsYXNzUGFydE9iamVjdCkgPT4ge1xuICBpZiAoY2xhc3NQYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY2xhc3NQYXJ0T2JqZWN0LmNsYXNzR3JvdXBJZDtcbiAgfVxuICBjb25zdCBjdXJyZW50Q2xhc3NQYXJ0ID0gY2xhc3NQYXJ0c1swXTtcbiAgY29uc3QgbmV4dENsYXNzUGFydE9iamVjdCA9IGNsYXNzUGFydE9iamVjdC5uZXh0UGFydC5nZXQoY3VycmVudENsYXNzUGFydCk7XG4gIGNvbnN0IGNsYXNzR3JvdXBGcm9tTmV4dENsYXNzUGFydCA9IG5leHRDbGFzc1BhcnRPYmplY3QgPyBnZXRHcm91cFJlY3Vyc2l2ZShjbGFzc1BhcnRzLnNsaWNlKDEpLCBuZXh0Q2xhc3NQYXJ0T2JqZWN0KSA6IHVuZGVmaW5lZDtcbiAgaWYgKGNsYXNzR3JvdXBGcm9tTmV4dENsYXNzUGFydCkge1xuICAgIHJldHVybiBjbGFzc0dyb3VwRnJvbU5leHRDbGFzc1BhcnQ7XG4gIH1cbiAgaWYgKGNsYXNzUGFydE9iamVjdC52YWxpZGF0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgY2xhc3NSZXN0ID0gY2xhc3NQYXJ0cy5qb2luKENMQVNTX1BBUlRfU0VQQVJBVE9SKTtcbiAgcmV0dXJuIGNsYXNzUGFydE9iamVjdC52YWxpZGF0b3JzLmZpbmQoKHtcbiAgICB2YWxpZGF0b3JcbiAgfSkgPT4gdmFsaWRhdG9yKGNsYXNzUmVzdCkpPy5jbGFzc0dyb3VwSWQ7XG59O1xuY29uc3QgYXJiaXRyYXJ5UHJvcGVydHlSZWdleCA9IC9eXFxbKC4rKVxcXSQvO1xuY29uc3QgZ2V0R3JvdXBJZEZvckFyYml0cmFyeVByb3BlcnR5ID0gY2xhc3NOYW1lID0+IHtcbiAgaWYgKGFyYml0cmFyeVByb3BlcnR5UmVnZXgudGVzdChjbGFzc05hbWUpKSB7XG4gICAgY29uc3QgYXJiaXRyYXJ5UHJvcGVydHlDbGFzc05hbWUgPSBhcmJpdHJhcnlQcm9wZXJ0eVJlZ2V4LmV4ZWMoY2xhc3NOYW1lKVsxXTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IGFyYml0cmFyeVByb3BlcnR5Q2xhc3NOYW1lPy5zdWJzdHJpbmcoMCwgYXJiaXRyYXJ5UHJvcGVydHlDbGFzc05hbWUuaW5kZXhPZignOicpKTtcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIC8vIEkgdXNlIHR3byBkb3RzIGhlcmUgYmVjYXVzZSBvbmUgZG90IGlzIHVzZWQgYXMgcHJlZml4IGZvciBjbGFzcyBncm91cHMgaW4gcGx1Z2luc1xuICAgICAgcmV0dXJuICdhcmJpdHJhcnkuLicgKyBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nIG9ubHlcbiAqL1xuY29uc3QgY3JlYXRlQ2xhc3NNYXAgPSBjb25maWcgPT4ge1xuICBjb25zdCB7XG4gICAgdGhlbWUsXG4gICAgY2xhc3NHcm91cHNcbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgY2xhc3NNYXAgPSB7XG4gICAgbmV4dFBhcnQ6IG5ldyBNYXAoKSxcbiAgICB2YWxpZGF0b3JzOiBbXVxuICB9O1xuICBmb3IgKGNvbnN0IGNsYXNzR3JvdXBJZCBpbiBjbGFzc0dyb3Vwcykge1xuICAgIHByb2Nlc3NDbGFzc2VzUmVjdXJzaXZlbHkoY2xhc3NHcm91cHNbY2xhc3NHcm91cElkXSwgY2xhc3NNYXAsIGNsYXNzR3JvdXBJZCwgdGhlbWUpO1xuICB9XG4gIHJldHVybiBjbGFzc01hcDtcbn07XG5jb25zdCBwcm9jZXNzQ2xhc3Nlc1JlY3Vyc2l2ZWx5ID0gKGNsYXNzR3JvdXAsIGNsYXNzUGFydE9iamVjdCwgY2xhc3NHcm91cElkLCB0aGVtZSkgPT4ge1xuICBjbGFzc0dyb3VwLmZvckVhY2goY2xhc3NEZWZpbml0aW9uID0+IHtcbiAgICBpZiAodHlwZW9mIGNsYXNzRGVmaW5pdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGNsYXNzUGFydE9iamVjdFRvRWRpdCA9IGNsYXNzRGVmaW5pdGlvbiA9PT0gJycgPyBjbGFzc1BhcnRPYmplY3QgOiBnZXRQYXJ0KGNsYXNzUGFydE9iamVjdCwgY2xhc3NEZWZpbml0aW9uKTtcbiAgICAgIGNsYXNzUGFydE9iamVjdFRvRWRpdC5jbGFzc0dyb3VwSWQgPSBjbGFzc0dyb3VwSWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2xhc3NEZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoaXNUaGVtZUdldHRlcihjbGFzc0RlZmluaXRpb24pKSB7XG4gICAgICAgIHByb2Nlc3NDbGFzc2VzUmVjdXJzaXZlbHkoY2xhc3NEZWZpbml0aW9uKHRoZW1lKSwgY2xhc3NQYXJ0T2JqZWN0LCBjbGFzc0dyb3VwSWQsIHRoZW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2xhc3NQYXJ0T2JqZWN0LnZhbGlkYXRvcnMucHVzaCh7XG4gICAgICAgIHZhbGlkYXRvcjogY2xhc3NEZWZpbml0aW9uLFxuICAgICAgICBjbGFzc0dyb3VwSWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuZW50cmllcyhjbGFzc0RlZmluaXRpb24pLmZvckVhY2goKFtrZXksIGNsYXNzR3JvdXBdKSA9PiB7XG4gICAgICBwcm9jZXNzQ2xhc3Nlc1JlY3Vyc2l2ZWx5KGNsYXNzR3JvdXAsIGdldFBhcnQoY2xhc3NQYXJ0T2JqZWN0LCBrZXkpLCBjbGFzc0dyb3VwSWQsIHRoZW1lKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuY29uc3QgZ2V0UGFydCA9IChjbGFzc1BhcnRPYmplY3QsIHBhdGgpID0+IHtcbiAgbGV0IGN1cnJlbnRDbGFzc1BhcnRPYmplY3QgPSBjbGFzc1BhcnRPYmplY3Q7XG4gIHBhdGguc3BsaXQoQ0xBU1NfUEFSVF9TRVBBUkFUT1IpLmZvckVhY2gocGF0aFBhcnQgPT4ge1xuICAgIGlmICghY3VycmVudENsYXNzUGFydE9iamVjdC5uZXh0UGFydC5oYXMocGF0aFBhcnQpKSB7XG4gICAgICBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0Lm5leHRQYXJ0LnNldChwYXRoUGFydCwge1xuICAgICAgICBuZXh0UGFydDogbmV3IE1hcCgpLFxuICAgICAgICB2YWxpZGF0b3JzOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICAgIGN1cnJlbnRDbGFzc1BhcnRPYmplY3QgPSBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0Lm5leHRQYXJ0LmdldChwYXRoUGFydCk7XG4gIH0pO1xuICByZXR1cm4gY3VycmVudENsYXNzUGFydE9iamVjdDtcbn07XG5jb25zdCBpc1RoZW1lR2V0dGVyID0gZnVuYyA9PiBmdW5jLmlzVGhlbWVHZXR0ZXI7XG5cbi8vIExSVSBjYWNoZSBpbnNwaXJlZCBmcm9tIGhhc2hscnUgKGh0dHBzOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9oYXNobHJ1L2Jsb2IvdjEuMC40L2luZGV4LmpzKSBidXQgb2JqZWN0IHJlcGxhY2VkIHdpdGggTWFwIHRvIGltcHJvdmUgcGVyZm9ybWFuY2VcbmNvbnN0IGNyZWF0ZUxydUNhY2hlID0gbWF4Q2FjaGVTaXplID0+IHtcbiAgaWYgKG1heENhY2hlU2l6ZSA8IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICBzZXQ6ICgpID0+IHt9XG4gICAgfTtcbiAgfVxuICBsZXQgY2FjaGVTaXplID0gMDtcbiAgbGV0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBsZXQgcHJldmlvdXNDYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgdXBkYXRlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgY2FjaGVTaXplKys7XG4gICAgaWYgKGNhY2hlU2l6ZSA+IG1heENhY2hlU2l6ZSkge1xuICAgICAgY2FjaGVTaXplID0gMDtcbiAgICAgIHByZXZpb3VzQ2FjaGUgPSBjYWNoZTtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICBsZXQgdmFsdWUgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICgodmFsdWUgPSBwcmV2aW91c0NhY2hlLmdldChrZXkpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbmNvbnN0IElNUE9SVEFOVF9NT0RJRklFUiA9ICchJztcbmNvbnN0IE1PRElGSUVSX1NFUEFSQVRPUiA9ICc6JztcbmNvbnN0IE1PRElGSUVSX1NFUEFSQVRPUl9MRU5HVEggPSBNT0RJRklFUl9TRVBBUkFUT1IubGVuZ3RoO1xuY29uc3QgY3JlYXRlUGFyc2VDbGFzc05hbWUgPSBjb25maWcgPT4ge1xuICBjb25zdCB7XG4gICAgcHJlZml4LFxuICAgIGV4cGVyaW1lbnRhbFBhcnNlQ2xhc3NOYW1lXG4gIH0gPSBjb25maWc7XG4gIC8qKlxuICAgKiBQYXJzZSBjbGFzcyBuYW1lIGludG8gcGFydHMuXG4gICAqXG4gICAqIEluc3BpcmVkIGJ5IGBzcGxpdEF0VG9wTGV2ZWxPbmx5YCB1c2VkIGluIFRhaWx3aW5kIENTU1xuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvYmxvYi92My4yLjIvc3JjL3V0aWwvc3BsaXRBdFRvcExldmVsT25seS5qc1xuICAgKi9cbiAgbGV0IHBhcnNlQ2xhc3NOYW1lID0gY2xhc3NOYW1lID0+IHtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBbXTtcbiAgICBsZXQgYnJhY2tldERlcHRoID0gMDtcbiAgICBsZXQgcGFyZW5EZXB0aCA9IDA7XG4gICAgbGV0IG1vZGlmaWVyU3RhcnQgPSAwO1xuICAgIGxldCBwb3N0Zml4TW9kaWZpZXJQb3NpdGlvbjtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY2xhc3NOYW1lLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgbGV0IGN1cnJlbnRDaGFyYWN0ZXIgPSBjbGFzc05hbWVbaW5kZXhdO1xuICAgICAgaWYgKGJyYWNrZXREZXB0aCA9PT0gMCAmJiBwYXJlbkRlcHRoID09PSAwKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVyID09PSBNT0RJRklFUl9TRVBBUkFUT1IpIHtcbiAgICAgICAgICBtb2RpZmllcnMucHVzaChjbGFzc05hbWUuc2xpY2UobW9kaWZpZXJTdGFydCwgaW5kZXgpKTtcbiAgICAgICAgICBtb2RpZmllclN0YXJ0ID0gaW5kZXggKyBNT0RJRklFUl9TRVBBUkFUT1JfTEVOR1RIO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVyID09PSAnLycpIHtcbiAgICAgICAgICBwb3N0Zml4TW9kaWZpZXJQb3NpdGlvbiA9IGluZGV4O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudENoYXJhY3RlciA9PT0gJ1snKSB7XG4gICAgICAgIGJyYWNrZXREZXB0aCsrO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhcmFjdGVyID09PSAnXScpIHtcbiAgICAgICAgYnJhY2tldERlcHRoLS07XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyYWN0ZXIgPT09ICcoJykge1xuICAgICAgICBwYXJlbkRlcHRoKys7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyYWN0ZXIgPT09ICcpJykge1xuICAgICAgICBwYXJlbkRlcHRoLS07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJhc2VDbGFzc05hbWVXaXRoSW1wb3J0YW50TW9kaWZpZXIgPSBtb2RpZmllcnMubGVuZ3RoID09PSAwID8gY2xhc3NOYW1lIDogY2xhc3NOYW1lLnN1YnN0cmluZyhtb2RpZmllclN0YXJ0KTtcbiAgICBjb25zdCBiYXNlQ2xhc3NOYW1lID0gc3RyaXBJbXBvcnRhbnRNb2RpZmllcihiYXNlQ2xhc3NOYW1lV2l0aEltcG9ydGFudE1vZGlmaWVyKTtcbiAgICBjb25zdCBoYXNJbXBvcnRhbnRNb2RpZmllciA9IGJhc2VDbGFzc05hbWUgIT09IGJhc2VDbGFzc05hbWVXaXRoSW1wb3J0YW50TW9kaWZpZXI7XG4gICAgY29uc3QgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbiA9IHBvc3RmaXhNb2RpZmllclBvc2l0aW9uICYmIHBvc3RmaXhNb2RpZmllclBvc2l0aW9uID4gbW9kaWZpZXJTdGFydCA/IHBvc3RmaXhNb2RpZmllclBvc2l0aW9uIC0gbW9kaWZpZXJTdGFydCA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZXJzLFxuICAgICAgaGFzSW1wb3J0YW50TW9kaWZpZXIsXG4gICAgICBiYXNlQ2xhc3NOYW1lLFxuICAgICAgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvblxuICAgIH07XG4gIH07XG4gIGlmIChwcmVmaXgpIHtcbiAgICBjb25zdCBmdWxsUHJlZml4ID0gcHJlZml4ICsgTU9ESUZJRVJfU0VQQVJBVE9SO1xuICAgIGNvbnN0IHBhcnNlQ2xhc3NOYW1lT3JpZ2luYWwgPSBwYXJzZUNsYXNzTmFtZTtcbiAgICBwYXJzZUNsYXNzTmFtZSA9IGNsYXNzTmFtZSA9PiBjbGFzc05hbWUuc3RhcnRzV2l0aChmdWxsUHJlZml4KSA/IHBhcnNlQ2xhc3NOYW1lT3JpZ2luYWwoY2xhc3NOYW1lLnN1YnN0cmluZyhmdWxsUHJlZml4Lmxlbmd0aCkpIDoge1xuICAgICAgaXNFeHRlcm5hbDogdHJ1ZSxcbiAgICAgIG1vZGlmaWVyczogW10sXG4gICAgICBoYXNJbXBvcnRhbnRNb2RpZmllcjogZmFsc2UsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICBtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG4gIGlmIChleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZSkge1xuICAgIGNvbnN0IHBhcnNlQ2xhc3NOYW1lT3JpZ2luYWwgPSBwYXJzZUNsYXNzTmFtZTtcbiAgICBwYXJzZUNsYXNzTmFtZSA9IGNsYXNzTmFtZSA9PiBleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZSh7XG4gICAgICBjbGFzc05hbWUsXG4gICAgICBwYXJzZUNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWVPcmlnaW5hbFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXJzZUNsYXNzTmFtZTtcbn07XG5jb25zdCBzdHJpcEltcG9ydGFudE1vZGlmaWVyID0gYmFzZUNsYXNzTmFtZSA9PiB7XG4gIGlmIChiYXNlQ2xhc3NOYW1lLmVuZHNXaXRoKElNUE9SVEFOVF9NT0RJRklFUikpIHtcbiAgICByZXR1cm4gYmFzZUNsYXNzTmFtZS5zdWJzdHJpbmcoMCwgYmFzZUNsYXNzTmFtZS5sZW5ndGggLSAxKTtcbiAgfVxuICAvKipcbiAgICogSW4gVGFpbHdpbmQgQ1NTIHYzIHRoZSBpbXBvcnRhbnQgbW9kaWZpZXIgd2FzIGF0IHRoZSBzdGFydCBvZiB0aGUgYmFzZSBjbGFzcyBuYW1lLiBUaGlzIGlzIHN0aWxsIHN1cHBvcnRlZCBmb3IgbGVnYWN5IHJlYXNvbnMuXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RjYXN0aWwvdGFpbHdpbmQtbWVyZ2UvaXNzdWVzLzUxMyNpc3N1ZWNvbW1lbnQtMjYxNDAyOTg2NFxuICAgKi9cbiAgaWYgKGJhc2VDbGFzc05hbWUuc3RhcnRzV2l0aChJTVBPUlRBTlRfTU9ESUZJRVIpKSB7XG4gICAgcmV0dXJuIGJhc2VDbGFzc05hbWUuc3Vic3RyaW5nKDEpO1xuICB9XG4gIHJldHVybiBiYXNlQ2xhc3NOYW1lO1xufTtcblxuLyoqXG4gKiBTb3J0cyBtb2RpZmllcnMgYWNjb3JkaW5nIHRvIGZvbGxvd2luZyBzY2hlbWE6XG4gKiAtIFByZWRlZmluZWQgbW9kaWZpZXJzIGFyZSBzb3J0ZWQgYWxwaGFiZXRpY2FsbHlcbiAqIC0gV2hlbiBhbiBhcmJpdHJhcnkgdmFyaWFudCBhcHBlYXJzLCBpdCBtdXN0IGJlIHByZXNlcnZlZCB3aGljaCBtb2RpZmllcnMgYXJlIGJlZm9yZSBhbmQgYWZ0ZXIgaXRcbiAqL1xuY29uc3QgY3JlYXRlU29ydE1vZGlmaWVycyA9IGNvbmZpZyA9PiB7XG4gIGNvbnN0IG9yZGVyU2Vuc2l0aXZlTW9kaWZpZXJzID0gT2JqZWN0LmZyb21FbnRyaWVzKGNvbmZpZy5vcmRlclNlbnNpdGl2ZU1vZGlmaWVycy5tYXAobW9kaWZpZXIgPT4gW21vZGlmaWVyLCB0cnVlXSkpO1xuICBjb25zdCBzb3J0TW9kaWZpZXJzID0gbW9kaWZpZXJzID0+IHtcbiAgICBpZiAobW9kaWZpZXJzLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXJzO1xuICAgIH1cbiAgICBjb25zdCBzb3J0ZWRNb2RpZmllcnMgPSBbXTtcbiAgICBsZXQgdW5zb3J0ZWRNb2RpZmllcnMgPSBbXTtcbiAgICBtb2RpZmllcnMuZm9yRWFjaChtb2RpZmllciA9PiB7XG4gICAgICBjb25zdCBpc1Bvc2l0aW9uU2Vuc2l0aXZlID0gbW9kaWZpZXJbMF0gPT09ICdbJyB8fCBvcmRlclNlbnNpdGl2ZU1vZGlmaWVyc1ttb2RpZmllcl07XG4gICAgICBpZiAoaXNQb3NpdGlvblNlbnNpdGl2ZSkge1xuICAgICAgICBzb3J0ZWRNb2RpZmllcnMucHVzaCguLi51bnNvcnRlZE1vZGlmaWVycy5zb3J0KCksIG1vZGlmaWVyKTtcbiAgICAgICAgdW5zb3J0ZWRNb2RpZmllcnMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuc29ydGVkTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNvcnRlZE1vZGlmaWVycy5wdXNoKC4uLnVuc29ydGVkTW9kaWZpZXJzLnNvcnQoKSk7XG4gICAgcmV0dXJuIHNvcnRlZE1vZGlmaWVycztcbiAgfTtcbiAgcmV0dXJuIHNvcnRNb2RpZmllcnM7XG59O1xuY29uc3QgY3JlYXRlQ29uZmlnVXRpbHMgPSBjb25maWcgPT4gKHtcbiAgY2FjaGU6IGNyZWF0ZUxydUNhY2hlKGNvbmZpZy5jYWNoZVNpemUpLFxuICBwYXJzZUNsYXNzTmFtZTogY3JlYXRlUGFyc2VDbGFzc05hbWUoY29uZmlnKSxcbiAgc29ydE1vZGlmaWVyczogY3JlYXRlU29ydE1vZGlmaWVycyhjb25maWcpLFxuICAuLi5jcmVhdGVDbGFzc0dyb3VwVXRpbHMoY29uZmlnKVxufSk7XG5jb25zdCBTUExJVF9DTEFTU0VTX1JFR0VYID0gL1xccysvO1xuY29uc3QgbWVyZ2VDbGFzc0xpc3QgPSAoY2xhc3NMaXN0LCBjb25maWdVdGlscykgPT4ge1xuICBjb25zdCB7XG4gICAgcGFyc2VDbGFzc05hbWUsXG4gICAgZ2V0Q2xhc3NHcm91cElkLFxuICAgIGdldENvbmZsaWN0aW5nQ2xhc3NHcm91cElkcyxcbiAgICBzb3J0TW9kaWZpZXJzXG4gIH0gPSBjb25maWdVdGlscztcbiAgLyoqXG4gICAqIFNldCBvZiBjbGFzc0dyb3VwSWRzIGluIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAqIGB7aW1wb3J0YW50TW9kaWZpZXJ9e3ZhcmlhbnRNb2RpZmllcnN9e2NsYXNzR3JvdXBJZH1gXG4gICAqIEBleGFtcGxlICdmbG9hdCdcbiAgICogQGV4YW1wbGUgJ2hvdmVyOmZvY3VzOmJnLWNvbG9yJ1xuICAgKiBAZXhhbXBsZSAnbWQ6IXByJ1xuICAgKi9cbiAgY29uc3QgY2xhc3NHcm91cHNJbkNvbmZsaWN0ID0gW107XG4gIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc0xpc3QudHJpbSgpLnNwbGl0KFNQTElUX0NMQVNTRVNfUkVHRVgpO1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAobGV0IGluZGV4ID0gY2xhc3NOYW1lcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleCAtPSAxKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxDbGFzc05hbWUgPSBjbGFzc05hbWVzW2luZGV4XTtcbiAgICBjb25zdCB7XG4gICAgICBpc0V4dGVybmFsLFxuICAgICAgbW9kaWZpZXJzLFxuICAgICAgaGFzSW1wb3J0YW50TW9kaWZpZXIsXG4gICAgICBiYXNlQ2xhc3NOYW1lLFxuICAgICAgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvblxuICAgIH0gPSBwYXJzZUNsYXNzTmFtZShvcmlnaW5hbENsYXNzTmFtZSk7XG4gICAgaWYgKGlzRXh0ZXJuYWwpIHtcbiAgICAgIHJlc3VsdCA9IG9yaWdpbmFsQ2xhc3NOYW1lICsgKHJlc3VsdC5sZW5ndGggPiAwID8gJyAnICsgcmVzdWx0IDogcmVzdWx0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgaGFzUG9zdGZpeE1vZGlmaWVyID0gISFtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uO1xuICAgIGxldCBjbGFzc0dyb3VwSWQgPSBnZXRDbGFzc0dyb3VwSWQoaGFzUG9zdGZpeE1vZGlmaWVyID8gYmFzZUNsYXNzTmFtZS5zdWJzdHJpbmcoMCwgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbikgOiBiYXNlQ2xhc3NOYW1lKTtcbiAgICBpZiAoIWNsYXNzR3JvdXBJZCkge1xuICAgICAgaWYgKCFoYXNQb3N0Zml4TW9kaWZpZXIpIHtcbiAgICAgICAgLy8gTm90IGEgVGFpbHdpbmQgY2xhc3NcbiAgICAgICAgcmVzdWx0ID0gb3JpZ2luYWxDbGFzc05hbWUgKyAocmVzdWx0Lmxlbmd0aCA+IDAgPyAnICcgKyByZXN1bHQgOiByZXN1bHQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNsYXNzR3JvdXBJZCA9IGdldENsYXNzR3JvdXBJZChiYXNlQ2xhc3NOYW1lKTtcbiAgICAgIGlmICghY2xhc3NHcm91cElkKSB7XG4gICAgICAgIC8vIE5vdCBhIFRhaWx3aW5kIGNsYXNzXG4gICAgICAgIHJlc3VsdCA9IG9yaWdpbmFsQ2xhc3NOYW1lICsgKHJlc3VsdC5sZW5ndGggPiAwID8gJyAnICsgcmVzdWx0IDogcmVzdWx0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBoYXNQb3N0Zml4TW9kaWZpZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdmFyaWFudE1vZGlmaWVyID0gc29ydE1vZGlmaWVycyhtb2RpZmllcnMpLmpvaW4oJzonKTtcbiAgICBjb25zdCBtb2RpZmllcklkID0gaGFzSW1wb3J0YW50TW9kaWZpZXIgPyB2YXJpYW50TW9kaWZpZXIgKyBJTVBPUlRBTlRfTU9ESUZJRVIgOiB2YXJpYW50TW9kaWZpZXI7XG4gICAgY29uc3QgY2xhc3NJZCA9IG1vZGlmaWVySWQgKyBjbGFzc0dyb3VwSWQ7XG4gICAgaWYgKGNsYXNzR3JvdXBzSW5Db25mbGljdC5pbmNsdWRlcyhjbGFzc0lkKSkge1xuICAgICAgLy8gVGFpbHdpbmQgY2xhc3Mgb21pdHRlZCBkdWUgdG8gY29uZmxpY3RcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjbGFzc0dyb3Vwc0luQ29uZmxpY3QucHVzaChjbGFzc0lkKTtcbiAgICBjb25zdCBjb25mbGljdEdyb3VwcyA9IGdldENvbmZsaWN0aW5nQ2xhc3NHcm91cElkcyhjbGFzc0dyb3VwSWQsIGhhc1Bvc3RmaXhNb2RpZmllcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25mbGljdEdyb3Vwcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZ3JvdXAgPSBjb25mbGljdEdyb3Vwc1tpXTtcbiAgICAgIGNsYXNzR3JvdXBzSW5Db25mbGljdC5wdXNoKG1vZGlmaWVySWQgKyBncm91cCk7XG4gICAgfVxuICAgIC8vIFRhaWx3aW5kIGNsYXNzIG5vdCBpbiBjb25mbGljdFxuICAgIHJlc3VsdCA9IG9yaWdpbmFsQ2xhc3NOYW1lICsgKHJlc3VsdC5sZW5ndGggPiAwID8gJyAnICsgcmVzdWx0IDogcmVzdWx0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2x1a2VlZC9jbHN4IGFuZCBtb2RpZmllZCB0byBzdWl0IHRoZSBuZWVkcyBvZiB0YWlsd2luZC1tZXJnZSBiZXR0ZXIuXG4gKlxuICogU3BlY2lmaWNhbGx5OlxuICogLSBSdW50aW1lIGNvZGUgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbHVrZWVkL2Nsc3gvYmxvYi92MS4yLjEvc3JjL2luZGV4LmpzXG4gKiAtIFR5cGVTY3JpcHQgdHlwZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbHVrZWVkL2Nsc3gvYmxvYi92MS4yLjEvY2xzeC5kLnRzXG4gKlxuICogT3JpZ2luYWwgY29kZSBoYXMgTUlUIGxpY2Vuc2U6IENvcHlyaWdodCAoYykgTHVrZSBFZHdhcmRzIDxsdWtlLmVkd2FyZHMwNUBnbWFpbC5jb20+IChsdWtlZWQuY29tKVxuICovXG5mdW5jdGlvbiB0d0pvaW4oKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBhcmd1bWVudDtcbiAgbGV0IHJlc29sdmVkVmFsdWU7XG4gIGxldCBzdHJpbmcgPSAnJztcbiAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGlmIChhcmd1bWVudCA9IGFyZ3VtZW50c1tpbmRleCsrXSkge1xuICAgICAgaWYgKHJlc29sdmVkVmFsdWUgPSB0b1ZhbHVlKGFyZ3VtZW50KSkge1xuICAgICAgICBzdHJpbmcgJiYgKHN0cmluZyArPSAnICcpO1xuICAgICAgICBzdHJpbmcgKz0gcmVzb2x2ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZztcbn1cbmNvbnN0IHRvVmFsdWUgPSBtaXggPT4ge1xuICBpZiAodHlwZW9mIG1peCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbWl4O1xuICB9XG4gIGxldCByZXNvbHZlZFZhbHVlO1xuICBsZXQgc3RyaW5nID0gJyc7XG4gIGZvciAobGV0IGsgPSAwOyBrIDwgbWl4Lmxlbmd0aDsgaysrKSB7XG4gICAgaWYgKG1peFtrXSkge1xuICAgICAgaWYgKHJlc29sdmVkVmFsdWUgPSB0b1ZhbHVlKG1peFtrXSkpIHtcbiAgICAgICAgc3RyaW5nICYmIChzdHJpbmcgKz0gJyAnKTtcbiAgICAgICAgc3RyaW5nICs9IHJlc29sdmVkVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmc7XG59O1xuZnVuY3Rpb24gY3JlYXRlVGFpbHdpbmRNZXJnZShjcmVhdGVDb25maWdGaXJzdCwgLi4uY3JlYXRlQ29uZmlnUmVzdCkge1xuICBsZXQgY29uZmlnVXRpbHM7XG4gIGxldCBjYWNoZUdldDtcbiAgbGV0IGNhY2hlU2V0O1xuICBsZXQgZnVuY3Rpb25Ub0NhbGwgPSBpbml0VGFpbHdpbmRNZXJnZTtcbiAgZnVuY3Rpb24gaW5pdFRhaWx3aW5kTWVyZ2UoY2xhc3NMaXN0KSB7XG4gICAgY29uc3QgY29uZmlnID0gY3JlYXRlQ29uZmlnUmVzdC5yZWR1Y2UoKHByZXZpb3VzQ29uZmlnLCBjcmVhdGVDb25maWdDdXJyZW50KSA9PiBjcmVhdGVDb25maWdDdXJyZW50KHByZXZpb3VzQ29uZmlnKSwgY3JlYXRlQ29uZmlnRmlyc3QoKSk7XG4gICAgY29uZmlnVXRpbHMgPSBjcmVhdGVDb25maWdVdGlscyhjb25maWcpO1xuICAgIGNhY2hlR2V0ID0gY29uZmlnVXRpbHMuY2FjaGUuZ2V0O1xuICAgIGNhY2hlU2V0ID0gY29uZmlnVXRpbHMuY2FjaGUuc2V0O1xuICAgIGZ1bmN0aW9uVG9DYWxsID0gdGFpbHdpbmRNZXJnZTtcbiAgICByZXR1cm4gdGFpbHdpbmRNZXJnZShjbGFzc0xpc3QpO1xuICB9XG4gIGZ1bmN0aW9uIHRhaWx3aW5kTWVyZ2UoY2xhc3NMaXN0KSB7XG4gICAgY29uc3QgY2FjaGVkUmVzdWx0ID0gY2FjaGVHZXQoY2xhc3NMaXN0KTtcbiAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBtZXJnZUNsYXNzTGlzdChjbGFzc0xpc3QsIGNvbmZpZ1V0aWxzKTtcbiAgICBjYWNoZVNldChjbGFzc0xpc3QsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gY2FsbFRhaWx3aW5kTWVyZ2UoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9DYWxsKHR3Sm9pbi5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cbmNvbnN0IGZyb21UaGVtZSA9IGtleSA9PiB7XG4gIGNvbnN0IHRoZW1lR2V0dGVyID0gdGhlbWUgPT4gdGhlbWVba2V5XSB8fCBbXTtcbiAgdGhlbWVHZXR0ZXIuaXNUaGVtZUdldHRlciA9IHRydWU7XG4gIHJldHVybiB0aGVtZUdldHRlcjtcbn07XG5jb25zdCBhcmJpdHJhcnlWYWx1ZVJlZ2V4ID0gL15cXFsoPzooXFx3W1xcdy1dKik6KT8oLispXFxdJC9pO1xuY29uc3QgYXJiaXRyYXJ5VmFyaWFibGVSZWdleCA9IC9eXFwoKD86KFxcd1tcXHctXSopOik/KC4rKVxcKSQvaTtcbmNvbnN0IGZyYWN0aW9uUmVnZXggPSAvXlxcZCtcXC9cXGQrJC87XG5jb25zdCB0c2hpcnRVbml0UmVnZXggPSAvXihcXGQrKFxcLlxcZCspPyk/KHhzfHNtfG1kfGxnfHhsKSQvO1xuY29uc3QgbGVuZ3RoVW5pdFJlZ2V4ID0gL1xcZCsoJXxweHxyP2VtfFtzZGxdP3YoW2h3aWJdfG1pbnxtYXgpfHB0fHBjfGlufGNtfG1tfGNhcHxjaHxleHxyP2xofGNxKHd8aHxpfGJ8bWlufG1heCkpfFxcYihjYWxjfG1pbnxtYXh8Y2xhbXApXFwoLitcXCl8XjAkLztcbmNvbnN0IGNvbG9yRnVuY3Rpb25SZWdleCA9IC9eKHJnYmE/fGhzbGE/fGh3Ynwob2spPyhsYWJ8bGNoKXxjb2xvci1taXgpXFwoLitcXCkkLztcbi8vIFNoYWRvdyBhbHdheXMgYmVnaW5zIHdpdGggeCBhbmQgeSBvZmZzZXQgc2VwYXJhdGVkIGJ5IHVuZGVyc2NvcmUgb3B0aW9uYWxseSBwcmVwZW5kZWQgYnkgaW5zZXRcbmNvbnN0IHNoYWRvd1JlZ2V4ID0gL14oaW5zZXRfKT8tPygoXFxkKyk/XFwuPyhcXGQrKVthLXpdK3wwKV8tPygoXFxkKyk/XFwuPyhcXGQrKVthLXpdK3wwKS87XG5jb25zdCBpbWFnZVJlZ2V4ID0gL14odXJsfGltYWdlfGltYWdlLXNldHxjcm9zcy1mYWRlfGVsZW1lbnR8KHJlcGVhdGluZy0pPyhsaW5lYXJ8cmFkaWFsfGNvbmljKS1ncmFkaWVudClcXCguK1xcKSQvO1xuY29uc3QgaXNGcmFjdGlvbiA9IHZhbHVlID0+IGZyYWN0aW9uUmVnZXgudGVzdCh2YWx1ZSk7XG5jb25zdCBpc051bWJlciA9IHZhbHVlID0+ICEhdmFsdWUgJiYgIU51bWJlci5pc05hTihOdW1iZXIodmFsdWUpKTtcbmNvbnN0IGlzSW50ZWdlciA9IHZhbHVlID0+ICEhdmFsdWUgJiYgTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodmFsdWUpKTtcbmNvbnN0IGlzUGVyY2VudCA9IHZhbHVlID0+IHZhbHVlLmVuZHNXaXRoKCclJykgJiYgaXNOdW1iZXIodmFsdWUuc2xpY2UoMCwgLTEpKTtcbmNvbnN0IGlzVHNoaXJ0U2l6ZSA9IHZhbHVlID0+IHRzaGlydFVuaXRSZWdleC50ZXN0KHZhbHVlKTtcbmNvbnN0IGlzQW55ID0gKCkgPT4gdHJ1ZTtcbmNvbnN0IGlzTGVuZ3RoT25seSA9IHZhbHVlID0+XG4vLyBgY29sb3JGdW5jdGlvblJlZ2V4YCBjaGVjayBpcyBuZWNlc3NhcnkgYmVjYXVzZSBjb2xvciBmdW5jdGlvbnMgY2FuIGhhdmUgcGVyY2VudGFnZXMgaW4gdGhlbSB3aGljaCB3aGljaCB3b3VsZCBiZSBpbmNvcnJlY3RseSBjbGFzc2lmaWVkIGFzIGxlbmd0aHMuXG4vLyBGb3IgZXhhbXBsZSwgYGhzbCgwIDAlIDAlKWAgd291bGQgYmUgY2xhc3NpZmllZCBhcyBhIGxlbmd0aCB3aXRob3V0IHRoaXMgY2hlY2suXG4vLyBJIGNvdWxkIGFsc28gdXNlIGxvb2tiZWhpbmQgYXNzZXJ0aW9uIGluIGBsZW5ndGhVbml0UmVnZXhgIGJ1dCB0aGF0IGlzbid0IHN1cHBvcnRlZCB3aWRlbHkgZW5vdWdoLlxubGVuZ3RoVW5pdFJlZ2V4LnRlc3QodmFsdWUpICYmICFjb2xvckZ1bmN0aW9uUmVnZXgudGVzdCh2YWx1ZSk7XG5jb25zdCBpc05ldmVyID0gKCkgPT4gZmFsc2U7XG5jb25zdCBpc1NoYWRvdyA9IHZhbHVlID0+IHNoYWRvd1JlZ2V4LnRlc3QodmFsdWUpO1xuY29uc3QgaXNJbWFnZSA9IHZhbHVlID0+IGltYWdlUmVnZXgudGVzdCh2YWx1ZSk7XG5jb25zdCBpc0FueU5vbkFyYml0cmFyeSA9IHZhbHVlID0+ICFpc0FyYml0cmFyeVZhbHVlKHZhbHVlKSAmJiAhaXNBcmJpdHJhcnlWYXJpYWJsZSh2YWx1ZSk7XG5jb25zdCBpc0FyYml0cmFyeVNpemUgPSB2YWx1ZSA9PiBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCBpc0xhYmVsU2l6ZSwgaXNOZXZlcik7XG5jb25zdCBpc0FyYml0cmFyeVZhbHVlID0gdmFsdWUgPT4gYXJiaXRyYXJ5VmFsdWVSZWdleC50ZXN0KHZhbHVlKTtcbmNvbnN0IGlzQXJiaXRyYXJ5TGVuZ3RoID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgaXNMYWJlbExlbmd0aCwgaXNMZW5ndGhPbmx5KTtcbmNvbnN0IGlzQXJiaXRyYXJ5TnVtYmVyID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgaXNMYWJlbE51bWJlciwgaXNOdW1iZXIpO1xuY29uc3QgaXNBcmJpdHJhcnlQb3NpdGlvbiA9IHZhbHVlID0+IGdldElzQXJiaXRyYXJ5VmFsdWUodmFsdWUsIGlzTGFiZWxQb3NpdGlvbiwgaXNOZXZlcik7XG5jb25zdCBpc0FyYml0cmFyeUltYWdlID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgaXNMYWJlbEltYWdlLCBpc0ltYWdlKTtcbmNvbnN0IGlzQXJiaXRyYXJ5U2hhZG93ID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgaXNMYWJlbFNoYWRvdywgaXNTaGFkb3cpO1xuY29uc3QgaXNBcmJpdHJhcnlWYXJpYWJsZSA9IHZhbHVlID0+IGFyYml0cmFyeVZhcmlhYmxlUmVnZXgudGVzdCh2YWx1ZSk7XG5jb25zdCBpc0FyYml0cmFyeVZhcmlhYmxlTGVuZ3RoID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYXJpYWJsZSh2YWx1ZSwgaXNMYWJlbExlbmd0aCk7XG5jb25zdCBpc0FyYml0cmFyeVZhcmlhYmxlRmFtaWx5TmFtZSA9IHZhbHVlID0+IGdldElzQXJiaXRyYXJ5VmFyaWFibGUodmFsdWUsIGlzTGFiZWxGYW1pbHlOYW1lKTtcbmNvbnN0IGlzQXJiaXRyYXJ5VmFyaWFibGVQb3NpdGlvbiA9IHZhbHVlID0+IGdldElzQXJiaXRyYXJ5VmFyaWFibGUodmFsdWUsIGlzTGFiZWxQb3NpdGlvbik7XG5jb25zdCBpc0FyYml0cmFyeVZhcmlhYmxlU2l6ZSA9IHZhbHVlID0+IGdldElzQXJiaXRyYXJ5VmFyaWFibGUodmFsdWUsIGlzTGFiZWxTaXplKTtcbmNvbnN0IGlzQXJiaXRyYXJ5VmFyaWFibGVJbWFnZSA9IHZhbHVlID0+IGdldElzQXJiaXRyYXJ5VmFyaWFibGUodmFsdWUsIGlzTGFiZWxJbWFnZSk7XG5jb25zdCBpc0FyYml0cmFyeVZhcmlhYmxlU2hhZG93ID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYXJpYWJsZSh2YWx1ZSwgaXNMYWJlbFNoYWRvdywgdHJ1ZSk7XG4vLyBIZWxwZXJzXG5jb25zdCBnZXRJc0FyYml0cmFyeVZhbHVlID0gKHZhbHVlLCB0ZXN0TGFiZWwsIHRlc3RWYWx1ZSkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBhcmJpdHJhcnlWYWx1ZVJlZ2V4LmV4ZWModmFsdWUpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdFsxXSkge1xuICAgICAgcmV0dXJuIHRlc3RMYWJlbChyZXN1bHRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGVzdFZhbHVlKHJlc3VsdFsyXSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGdldElzQXJiaXRyYXJ5VmFyaWFibGUgPSAodmFsdWUsIHRlc3RMYWJlbCwgc2hvdWxkTWF0Y2hOb0xhYmVsID0gZmFsc2UpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gYXJiaXRyYXJ5VmFyaWFibGVSZWdleC5leGVjKHZhbHVlKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHRbMV0pIHtcbiAgICAgIHJldHVybiB0ZXN0TGFiZWwocmVzdWx0WzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZE1hdGNoTm9MYWJlbDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuLy8gTGFiZWxzXG5jb25zdCBpc0xhYmVsUG9zaXRpb24gPSBsYWJlbCA9PiBsYWJlbCA9PT0gJ3Bvc2l0aW9uJyB8fCBsYWJlbCA9PT0gJ3BlcmNlbnRhZ2UnO1xuY29uc3QgaXNMYWJlbEltYWdlID0gbGFiZWwgPT4gbGFiZWwgPT09ICdpbWFnZScgfHwgbGFiZWwgPT09ICd1cmwnO1xuY29uc3QgaXNMYWJlbFNpemUgPSBsYWJlbCA9PiBsYWJlbCA9PT0gJ2xlbmd0aCcgfHwgbGFiZWwgPT09ICdzaXplJyB8fCBsYWJlbCA9PT0gJ2JnLXNpemUnO1xuY29uc3QgaXNMYWJlbExlbmd0aCA9IGxhYmVsID0+IGxhYmVsID09PSAnbGVuZ3RoJztcbmNvbnN0IGlzTGFiZWxOdW1iZXIgPSBsYWJlbCA9PiBsYWJlbCA9PT0gJ251bWJlcic7XG5jb25zdCBpc0xhYmVsRmFtaWx5TmFtZSA9IGxhYmVsID0+IGxhYmVsID09PSAnZmFtaWx5LW5hbWUnO1xuY29uc3QgaXNMYWJlbFNoYWRvdyA9IGxhYmVsID0+IGxhYmVsID09PSAnc2hhZG93JztcbmNvbnN0IHZhbGlkYXRvcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBpc0FueSxcbiAgaXNBbnlOb25BcmJpdHJhcnksXG4gIGlzQXJiaXRyYXJ5SW1hZ2UsXG4gIGlzQXJiaXRyYXJ5TGVuZ3RoLFxuICBpc0FyYml0cmFyeU51bWJlcixcbiAgaXNBcmJpdHJhcnlQb3NpdGlvbixcbiAgaXNBcmJpdHJhcnlTaGFkb3csXG4gIGlzQXJiaXRyYXJ5U2l6ZSxcbiAgaXNBcmJpdHJhcnlWYWx1ZSxcbiAgaXNBcmJpdHJhcnlWYXJpYWJsZSxcbiAgaXNBcmJpdHJhcnlWYXJpYWJsZUZhbWlseU5hbWUsXG4gIGlzQXJiaXRyYXJ5VmFyaWFibGVJbWFnZSxcbiAgaXNBcmJpdHJhcnlWYXJpYWJsZUxlbmd0aCxcbiAgaXNBcmJpdHJhcnlWYXJpYWJsZVBvc2l0aW9uLFxuICBpc0FyYml0cmFyeVZhcmlhYmxlU2hhZG93LFxuICBpc0FyYml0cmFyeVZhcmlhYmxlU2l6ZSxcbiAgaXNGcmFjdGlvbixcbiAgaXNJbnRlZ2VyLFxuICBpc051bWJlcixcbiAgaXNQZXJjZW50LFxuICBpc1RzaGlydFNpemVcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICB2YWx1ZTogJ01vZHVsZSdcbn0pO1xuY29uc3QgZ2V0RGVmYXVsdENvbmZpZyA9ICgpID0+IHtcbiAgLyoqXG4gICAqIFRoZW1lIGdldHRlcnMgZm9yIHRoZW1lIHZhcmlhYmxlIG5hbWVzcGFjZXNcbiAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RoZW1lI3RoZW1lLXZhcmlhYmxlLW5hbWVzcGFjZXNcbiAgICovXG4gIC8qKiovXG4gIGNvbnN0IHRoZW1lQ29sb3IgPSBmcm9tVGhlbWUoJ2NvbG9yJyk7XG4gIGNvbnN0IHRoZW1lRm9udCA9IGZyb21UaGVtZSgnZm9udCcpO1xuICBjb25zdCB0aGVtZVRleHQgPSBmcm9tVGhlbWUoJ3RleHQnKTtcbiAgY29uc3QgdGhlbWVGb250V2VpZ2h0ID0gZnJvbVRoZW1lKCdmb250LXdlaWdodCcpO1xuICBjb25zdCB0aGVtZVRyYWNraW5nID0gZnJvbVRoZW1lKCd0cmFja2luZycpO1xuICBjb25zdCB0aGVtZUxlYWRpbmcgPSBmcm9tVGhlbWUoJ2xlYWRpbmcnKTtcbiAgY29uc3QgdGhlbWVCcmVha3BvaW50ID0gZnJvbVRoZW1lKCdicmVha3BvaW50Jyk7XG4gIGNvbnN0IHRoZW1lQ29udGFpbmVyID0gZnJvbVRoZW1lKCdjb250YWluZXInKTtcbiAgY29uc3QgdGhlbWVTcGFjaW5nID0gZnJvbVRoZW1lKCdzcGFjaW5nJyk7XG4gIGNvbnN0IHRoZW1lUmFkaXVzID0gZnJvbVRoZW1lKCdyYWRpdXMnKTtcbiAgY29uc3QgdGhlbWVTaGFkb3cgPSBmcm9tVGhlbWUoJ3NoYWRvdycpO1xuICBjb25zdCB0aGVtZUluc2V0U2hhZG93ID0gZnJvbVRoZW1lKCdpbnNldC1zaGFkb3cnKTtcbiAgY29uc3QgdGhlbWVUZXh0U2hhZG93ID0gZnJvbVRoZW1lKCd0ZXh0LXNoYWRvdycpO1xuICBjb25zdCB0aGVtZURyb3BTaGFkb3cgPSBmcm9tVGhlbWUoJ2Ryb3Atc2hhZG93Jyk7XG4gIGNvbnN0IHRoZW1lQmx1ciA9IGZyb21UaGVtZSgnYmx1cicpO1xuICBjb25zdCB0aGVtZVBlcnNwZWN0aXZlID0gZnJvbVRoZW1lKCdwZXJzcGVjdGl2ZScpO1xuICBjb25zdCB0aGVtZUFzcGVjdCA9IGZyb21UaGVtZSgnYXNwZWN0Jyk7XG4gIGNvbnN0IHRoZW1lRWFzZSA9IGZyb21UaGVtZSgnZWFzZScpO1xuICBjb25zdCB0aGVtZUFuaW1hdGUgPSBmcm9tVGhlbWUoJ2FuaW1hdGUnKTtcbiAgLyoqXG4gICAqIEhlbHBlcnMgdG8gYXZvaWQgcmVwZWF0aW5nIHRoZSBzYW1lIHNjYWxlc1xuICAgKlxuICAgKiBXZSB1c2UgZnVuY3Rpb25zIHRoYXQgY3JlYXRlIGEgbmV3IGFycmF5IGV2ZXJ5IHRpbWUgdGhleSdyZSBjYWxsZWQgaW5zdGVhZCBvZiBzdGF0aWMgYXJyYXlzLlxuICAgKiBUaGlzIGVuc3VyZXMgdGhhdCB1c2VycyB3aG8gbW9kaWZ5IGFueSBzY2FsZSBieSBtdXRhdGluZyB0aGUgYXJyYXkgKGUuZy4gd2l0aCBgYXJyYXkucHVzaChlbGVtZW50KWApIGRvbid0IGFjY2lkZW50YWxseSBtdXRhdGUgYXJyYXlzIGluIG90aGVyIHBhcnRzIG9mIHRoZSBjb25maWcuXG4gICAqL1xuICAvKioqL1xuICBjb25zdCBzY2FsZUJyZWFrID0gKCkgPT4gWydhdXRvJywgJ2F2b2lkJywgJ2FsbCcsICdhdm9pZC1wYWdlJywgJ3BhZ2UnLCAnbGVmdCcsICdyaWdodCcsICdjb2x1bW4nXTtcbiAgY29uc3Qgc2NhbGVQb3NpdGlvbiA9ICgpID0+IFsnY2VudGVyJywgJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICd0b3AtbGVmdCcsXG4gIC8vIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjEuMCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvcHVsbC8xNzM3OFxuICAnbGVmdC10b3AnLCAndG9wLXJpZ2h0JyxcbiAgLy8gRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMS4wLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9wdWxsLzE3Mzc4XG4gICdyaWdodC10b3AnLCAnYm90dG9tLXJpZ2h0JyxcbiAgLy8gRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMS4wLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9wdWxsLzE3Mzc4XG4gICdyaWdodC1ib3R0b20nLCAnYm90dG9tLWxlZnQnLFxuICAvLyBEZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4xLjAsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL3B1bGwvMTczNzhcbiAgJ2xlZnQtYm90dG9tJ107XG4gIGNvbnN0IHNjYWxlUG9zaXRpb25XaXRoQXJiaXRyYXJ5ID0gKCkgPT4gWy4uLnNjYWxlUG9zaXRpb24oKSwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV07XG4gIGNvbnN0IHNjYWxlT3ZlcmZsb3cgPSAoKSA9PiBbJ2F1dG8nLCAnaGlkZGVuJywgJ2NsaXAnLCAndmlzaWJsZScsICdzY3JvbGwnXTtcbiAgY29uc3Qgc2NhbGVPdmVyc2Nyb2xsID0gKCkgPT4gWydhdXRvJywgJ2NvbnRhaW4nLCAnbm9uZSddO1xuICBjb25zdCBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZyA9ICgpID0+IFtpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlLCB0aGVtZVNwYWNpbmddO1xuICBjb25zdCBzY2FsZUluc2V0ID0gKCkgPT4gW2lzRnJhY3Rpb24sICdmdWxsJywgJ2F1dG8nLCAuLi5zY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXTtcbiAgY29uc3Qgc2NhbGVHcmlkVGVtcGxhdGVDb2xzUm93cyA9ICgpID0+IFtpc0ludGVnZXIsICdub25lJywgJ3N1YmdyaWQnLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXTtcbiAgY29uc3Qgc2NhbGVHcmlkQ29sUm93U3RhcnRBbmRFbmQgPSAoKSA9PiBbJ2F1dG8nLCB7XG4gICAgc3BhbjogWydmdWxsJywgaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICB9LCBpc0ludGVnZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdO1xuICBjb25zdCBzY2FsZUdyaWRDb2xSb3dTdGFydE9yRW5kID0gKCkgPT4gW2lzSW50ZWdlciwgJ2F1dG8nLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXTtcbiAgY29uc3Qgc2NhbGVHcmlkQXV0b0NvbHNSb3dzID0gKCkgPT4gWydhdXRvJywgJ21pbicsICdtYXgnLCAnZnInLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXTtcbiAgY29uc3Qgc2NhbGVBbGlnblByaW1hcnlBeGlzID0gKCkgPT4gWydzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ2JldHdlZW4nLCAnYXJvdW5kJywgJ2V2ZW5seScsICdzdHJldGNoJywgJ2Jhc2VsaW5lJywgJ2NlbnRlci1zYWZlJywgJ2VuZC1zYWZlJ107XG4gIGNvbnN0IHNjYWxlQWxpZ25TZWNvbmRhcnlBeGlzID0gKCkgPT4gWydzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ3N0cmV0Y2gnLCAnY2VudGVyLXNhZmUnLCAnZW5kLXNhZmUnXTtcbiAgY29uc3Qgc2NhbGVNYXJnaW4gPSAoKSA9PiBbJ2F1dG8nLCAuLi5zY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXTtcbiAgY29uc3Qgc2NhbGVTaXppbmcgPSAoKSA9PiBbaXNGcmFjdGlvbiwgJ2F1dG8nLCAnZnVsbCcsICdkdncnLCAnZHZoJywgJ2x2dycsICdsdmgnLCAnc3Z3JywgJ3N2aCcsICdtaW4nLCAnbWF4JywgJ2ZpdCcsIC4uLnNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKCldO1xuICBjb25zdCBzY2FsZUNvbG9yID0gKCkgPT4gW3RoZW1lQ29sb3IsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdO1xuICBjb25zdCBzY2FsZUJnUG9zaXRpb24gPSAoKSA9PiBbLi4uc2NhbGVQb3NpdGlvbigpLCBpc0FyYml0cmFyeVZhcmlhYmxlUG9zaXRpb24sIGlzQXJiaXRyYXJ5UG9zaXRpb24sIHtcbiAgICBwb3NpdGlvbjogW2lzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gIH1dO1xuICBjb25zdCBzY2FsZUJnUmVwZWF0ID0gKCkgPT4gWyduby1yZXBlYXQnLCB7XG4gICAgcmVwZWF0OiBbJycsICd4JywgJ3knLCAnc3BhY2UnLCAncm91bmQnXVxuICB9XTtcbiAgY29uc3Qgc2NhbGVCZ1NpemUgPSAoKSA9PiBbJ2F1dG8nLCAnY292ZXInLCAnY29udGFpbicsIGlzQXJiaXRyYXJ5VmFyaWFibGVTaXplLCBpc0FyYml0cmFyeVNpemUsIHtcbiAgICBzaXplOiBbaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgfV07XG4gIGNvbnN0IHNjYWxlR3JhZGllbnRTdG9wUG9zaXRpb24gPSAoKSA9PiBbaXNQZXJjZW50LCBpc0FyYml0cmFyeVZhcmlhYmxlTGVuZ3RoLCBpc0FyYml0cmFyeUxlbmd0aF07XG4gIGNvbnN0IHNjYWxlUmFkaXVzID0gKCkgPT4gW1xuICAvLyBEZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4wLjBcbiAgJycsICdub25lJywgJ2Z1bGwnLCB0aGVtZVJhZGl1cywgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV07XG4gIGNvbnN0IHNjYWxlQm9yZGVyV2lkdGggPSAoKSA9PiBbJycsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlTGVuZ3RoLCBpc0FyYml0cmFyeUxlbmd0aF07XG4gIGNvbnN0IHNjYWxlTGluZVN0eWxlID0gKCkgPT4gWydzb2xpZCcsICdkYXNoZWQnLCAnZG90dGVkJywgJ2RvdWJsZSddO1xuICBjb25zdCBzY2FsZUJsZW5kTW9kZSA9ICgpID0+IFsnbm9ybWFsJywgJ211bHRpcGx5JywgJ3NjcmVlbicsICdvdmVybGF5JywgJ2RhcmtlbicsICdsaWdodGVuJywgJ2NvbG9yLWRvZGdlJywgJ2NvbG9yLWJ1cm4nLCAnaGFyZC1saWdodCcsICdzb2Z0LWxpZ2h0JywgJ2RpZmZlcmVuY2UnLCAnZXhjbHVzaW9uJywgJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2NvbG9yJywgJ2x1bWlub3NpdHknXTtcbiAgY29uc3Qgc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbiA9ICgpID0+IFtpc051bWJlciwgaXNQZXJjZW50LCBpc0FyYml0cmFyeVZhcmlhYmxlUG9zaXRpb24sIGlzQXJiaXRyYXJ5UG9zaXRpb25dO1xuICBjb25zdCBzY2FsZUJsdXIgPSAoKSA9PiBbXG4gIC8vIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjAuMFxuICAnJywgJ25vbmUnLCB0aGVtZUJsdXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdO1xuICBjb25zdCBzY2FsZVJvdGF0ZSA9ICgpID0+IFsnbm9uZScsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXTtcbiAgY29uc3Qgc2NhbGVTY2FsZSA9ICgpID0+IFsnbm9uZScsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXTtcbiAgY29uc3Qgc2NhbGVTa2V3ID0gKCkgPT4gW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXTtcbiAgY29uc3Qgc2NhbGVUcmFuc2xhdGUgPSAoKSA9PiBbaXNGcmFjdGlvbiwgJ2Z1bGwnLCAuLi5zY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXTtcbiAgcmV0dXJuIHtcbiAgICBjYWNoZVNpemU6IDUwMCxcbiAgICB0aGVtZToge1xuICAgICAgYW5pbWF0ZTogWydzcGluJywgJ3BpbmcnLCAncHVsc2UnLCAnYm91bmNlJ10sXG4gICAgICBhc3BlY3Q6IFsndmlkZW8nXSxcbiAgICAgIGJsdXI6IFtpc1RzaGlydFNpemVdLFxuICAgICAgYnJlYWtwb2ludDogW2lzVHNoaXJ0U2l6ZV0sXG4gICAgICBjb2xvcjogW2lzQW55XSxcbiAgICAgIGNvbnRhaW5lcjogW2lzVHNoaXJ0U2l6ZV0sXG4gICAgICAnZHJvcC1zaGFkb3cnOiBbaXNUc2hpcnRTaXplXSxcbiAgICAgIGVhc2U6IFsnaW4nLCAnb3V0JywgJ2luLW91dCddLFxuICAgICAgZm9udDogW2lzQW55Tm9uQXJiaXRyYXJ5XSxcbiAgICAgICdmb250LXdlaWdodCc6IFsndGhpbicsICdleHRyYWxpZ2h0JywgJ2xpZ2h0JywgJ25vcm1hbCcsICdtZWRpdW0nLCAnc2VtaWJvbGQnLCAnYm9sZCcsICdleHRyYWJvbGQnLCAnYmxhY2snXSxcbiAgICAgICdpbnNldC1zaGFkb3cnOiBbaXNUc2hpcnRTaXplXSxcbiAgICAgIGxlYWRpbmc6IFsnbm9uZScsICd0aWdodCcsICdzbnVnJywgJ25vcm1hbCcsICdyZWxheGVkJywgJ2xvb3NlJ10sXG4gICAgICBwZXJzcGVjdGl2ZTogWydkcmFtYXRpYycsICduZWFyJywgJ25vcm1hbCcsICdtaWRyYW5nZScsICdkaXN0YW50JywgJ25vbmUnXSxcbiAgICAgIHJhZGl1czogW2lzVHNoaXJ0U2l6ZV0sXG4gICAgICBzaGFkb3c6IFtpc1RzaGlydFNpemVdLFxuICAgICAgc3BhY2luZzogWydweCcsIGlzTnVtYmVyXSxcbiAgICAgIHRleHQ6IFtpc1RzaGlydFNpemVdLFxuICAgICAgJ3RleHQtc2hhZG93JzogW2lzVHNoaXJ0U2l6ZV0sXG4gICAgICB0cmFja2luZzogWyd0aWdodGVyJywgJ3RpZ2h0JywgJ25vcm1hbCcsICd3aWRlJywgJ3dpZGVyJywgJ3dpZGVzdCddXG4gICAgfSxcbiAgICBjbGFzc0dyb3Vwczoge1xuICAgICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIC0tLSBMYXlvdXQgLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLVxuICAgICAgLyoqXG4gICAgICAgKiBBc3BlY3QgUmF0aW9cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hc3BlY3QtcmF0aW9cbiAgICAgICAqL1xuICAgICAgYXNwZWN0OiBbe1xuICAgICAgICBhc3BlY3Q6IFsnYXV0bycsICdzcXVhcmUnLCBpc0ZyYWN0aW9uLCBpc0FyYml0cmFyeVZhbHVlLCBpc0FyYml0cmFyeVZhcmlhYmxlLCB0aGVtZUFzcGVjdF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDb250YWluZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jb250YWluZXJcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4wLjBcbiAgICAgICAqL1xuICAgICAgY29udGFpbmVyOiBbJ2NvbnRhaW5lciddLFxuICAgICAgLyoqXG4gICAgICAgKiBDb2x1bW5zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29sdW1uc1xuICAgICAgICovXG4gICAgICBjb2x1bW5zOiBbe1xuICAgICAgICBjb2x1bW5zOiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFsdWUsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIHRoZW1lQ29udGFpbmVyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyZWFrIEFmdGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJlYWstYWZ0ZXJcbiAgICAgICAqL1xuICAgICAgJ2JyZWFrLWFmdGVyJzogW3tcbiAgICAgICAgJ2JyZWFrLWFmdGVyJzogc2NhbGVCcmVhaygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJlYWsgQmVmb3JlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJlYWstYmVmb3JlXG4gICAgICAgKi9cbiAgICAgICdicmVhay1iZWZvcmUnOiBbe1xuICAgICAgICAnYnJlYWstYmVmb3JlJzogc2NhbGVCcmVhaygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJlYWsgSW5zaWRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJlYWstaW5zaWRlXG4gICAgICAgKi9cbiAgICAgICdicmVhay1pbnNpZGUnOiBbe1xuICAgICAgICAnYnJlYWstaW5zaWRlJzogWydhdXRvJywgJ2F2b2lkJywgJ2F2b2lkLXBhZ2UnLCAnYXZvaWQtY29sdW1uJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3ggRGVjb3JhdGlvbiBCcmVha1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1kZWNvcmF0aW9uLWJyZWFrXG4gICAgICAgKi9cbiAgICAgICdib3gtZGVjb3JhdGlvbic6IFt7XG4gICAgICAgICdib3gtZGVjb3JhdGlvbic6IFsnc2xpY2UnLCAnY2xvbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJveCBTaXppbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2l6aW5nXG4gICAgICAgKi9cbiAgICAgIGJveDogW3tcbiAgICAgICAgYm94OiBbJ2JvcmRlcicsICdjb250ZW50J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXNwbGF5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGlzcGxheVxuICAgICAgICovXG4gICAgICBkaXNwbGF5OiBbJ2Jsb2NrJywgJ2lubGluZS1ibG9jaycsICdpbmxpbmUnLCAnZmxleCcsICdpbmxpbmUtZmxleCcsICd0YWJsZScsICdpbmxpbmUtdGFibGUnLCAndGFibGUtY2FwdGlvbicsICd0YWJsZS1jZWxsJywgJ3RhYmxlLWNvbHVtbicsICd0YWJsZS1jb2x1bW4tZ3JvdXAnLCAndGFibGUtZm9vdGVyLWdyb3VwJywgJ3RhYmxlLWhlYWRlci1ncm91cCcsICd0YWJsZS1yb3ctZ3JvdXAnLCAndGFibGUtcm93JywgJ2Zsb3ctcm9vdCcsICdncmlkJywgJ2lubGluZS1ncmlkJywgJ2NvbnRlbnRzJywgJ2xpc3QtaXRlbScsICdoaWRkZW4nXSxcbiAgICAgIC8qKlxuICAgICAgICogU2NyZWVuIFJlYWRlciBPbmx5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGlzcGxheSNzY3JlZW4tcmVhZGVyLW9ubHlcbiAgICAgICAqL1xuICAgICAgc3I6IFsnc3Itb25seScsICdub3Qtc3Itb25seSddLFxuICAgICAgLyoqXG4gICAgICAgKiBGbG9hdHNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbG9hdFxuICAgICAgICovXG4gICAgICBmbG9hdDogW3tcbiAgICAgICAgZmxvYXQ6IFsncmlnaHQnLCAnbGVmdCcsICdub25lJywgJ3N0YXJ0JywgJ2VuZCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ2xlYXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jbGVhclxuICAgICAgICovXG4gICAgICBjbGVhcjogW3tcbiAgICAgICAgY2xlYXI6IFsnbGVmdCcsICdyaWdodCcsICdib3RoJywgJ25vbmUnLCAnc3RhcnQnLCAnZW5kJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBJc29sYXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9pc29sYXRpb25cbiAgICAgICAqL1xuICAgICAgaXNvbGF0aW9uOiBbJ2lzb2xhdGUnLCAnaXNvbGF0aW9uLWF1dG8nXSxcbiAgICAgIC8qKlxuICAgICAgICogT2JqZWN0IEZpdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL29iamVjdC1maXRcbiAgICAgICAqL1xuICAgICAgJ29iamVjdC1maXQnOiBbe1xuICAgICAgICBvYmplY3Q6IFsnY29udGFpbicsICdjb3ZlcicsICdmaWxsJywgJ25vbmUnLCAnc2NhbGUtZG93biddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT2JqZWN0IFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb2JqZWN0LXBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgICdvYmplY3QtcG9zaXRpb24nOiBbe1xuICAgICAgICBvYmplY3Q6IHNjYWxlUG9zaXRpb25XaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyZmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgKi9cbiAgICAgIG92ZXJmbG93OiBbe1xuICAgICAgICBvdmVyZmxvdzogc2NhbGVPdmVyZmxvdygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcmZsb3cgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgKi9cbiAgICAgICdvdmVyZmxvdy14JzogW3tcbiAgICAgICAgJ292ZXJmbG93LXgnOiBzY2FsZU92ZXJmbG93KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyZmxvdyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgJ292ZXJmbG93LXknOiBbe1xuICAgICAgICAnb3ZlcmZsb3cteSc6IHNjYWxlT3ZlcmZsb3coKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJzY3JvbGwgQmVoYXZpb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyc2Nyb2xsLWJlaGF2aW9yXG4gICAgICAgKi9cbiAgICAgIG92ZXJzY3JvbGw6IFt7XG4gICAgICAgIG92ZXJzY3JvbGw6IHNjYWxlT3ZlcnNjcm9sbCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvciBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICovXG4gICAgICAnb3ZlcnNjcm9sbC14JzogW3tcbiAgICAgICAgJ292ZXJzY3JvbGwteCc6IHNjYWxlT3ZlcnNjcm9sbCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvciBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICovXG4gICAgICAnb3ZlcnNjcm9sbC15JzogW3tcbiAgICAgICAgJ292ZXJzY3JvbGwteSc6IHNjYWxlT3ZlcnNjcm9sbCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wb3NpdGlvblxuICAgICAgICovXG4gICAgICBwb3NpdGlvbjogWydzdGF0aWMnLCAnZml4ZWQnLCAnYWJzb2x1dGUnLCAncmVsYXRpdmUnLCAnc3RpY2t5J10sXG4gICAgICAvKipcbiAgICAgICAqIFRvcCAvIFJpZ2h0IC8gQm90dG9tIC8gTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBpbnNldDogW3tcbiAgICAgICAgaW5zZXQ6IHNjYWxlSW5zZXQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpZ2h0IC8gTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICAnaW5zZXQteCc6IFt7XG4gICAgICAgICdpbnNldC14Jzogc2NhbGVJbnNldCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wIC8gQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgICdpbnNldC15JzogW3tcbiAgICAgICAgJ2luc2V0LXknOiBzY2FsZUluc2V0KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBzdGFydDogW3tcbiAgICAgICAgc3RhcnQ6IHNjYWxlSW5zZXQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBlbmQ6IFt7XG4gICAgICAgIGVuZDogc2NhbGVJbnNldCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIHRvcDogW3tcbiAgICAgICAgdG9wOiBzY2FsZUluc2V0KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICByaWdodDogW3tcbiAgICAgICAgcmlnaHQ6IHNjYWxlSW5zZXQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBib3R0b206IFt7XG4gICAgICAgIGJvdHRvbTogc2NhbGVJbnNldCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBsZWZ0OiBbe1xuICAgICAgICBsZWZ0OiBzY2FsZUluc2V0KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBWaXNpYmlsaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdmlzaWJpbGl0eVxuICAgICAgICovXG4gICAgICB2aXNpYmlsaXR5OiBbJ3Zpc2libGUnLCAnaW52aXNpYmxlJywgJ2NvbGxhcHNlJ10sXG4gICAgICAvKipcbiAgICAgICAqIFotSW5kZXhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy96LWluZGV4XG4gICAgICAgKi9cbiAgICAgIHo6IFt7XG4gICAgICAgIHo6IFtpc0ludGVnZXIsICdhdXRvJywgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyAtLS0gRmxleGJveCBhbmQgR3JpZCAtLS1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IEJhc2lzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC1iYXNpc1xuICAgICAgICovXG4gICAgICBiYXNpczogW3tcbiAgICAgICAgYmFzaXM6IFtpc0ZyYWN0aW9uLCAnZnVsbCcsICdhdXRvJywgdGhlbWVDb250YWluZXIsIC4uLnNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKCldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRmxleCBEaXJlY3Rpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LWRpcmVjdGlvblxuICAgICAgICovXG4gICAgICAnZmxleC1kaXJlY3Rpb24nOiBbe1xuICAgICAgICBmbGV4OiBbJ3JvdycsICdyb3ctcmV2ZXJzZScsICdjb2wnLCAnY29sLXJldmVyc2UnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggV3JhcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtd3JhcFxuICAgICAgICovXG4gICAgICAnZmxleC13cmFwJzogW3tcbiAgICAgICAgZmxleDogWydub3dyYXAnLCAnd3JhcCcsICd3cmFwLXJldmVyc2UnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZsZXhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4XG4gICAgICAgKi9cbiAgICAgIGZsZXg6IFt7XG4gICAgICAgIGZsZXg6IFtpc051bWJlciwgaXNGcmFjdGlvbiwgJ2F1dG8nLCAnaW5pdGlhbCcsICdub25lJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IEdyb3dcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LWdyb3dcbiAgICAgICAqL1xuICAgICAgZ3JvdzogW3tcbiAgICAgICAgZ3JvdzogWycnLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IFNocmlua1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtc2hyaW5rXG4gICAgICAgKi9cbiAgICAgIHNocmluazogW3tcbiAgICAgICAgc2hyaW5rOiBbJycsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE9yZGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3JkZXJcbiAgICAgICAqL1xuICAgICAgb3JkZXI6IFt7XG4gICAgICAgIG9yZGVyOiBbaXNJbnRlZ2VyLCAnZmlyc3QnLCAnbGFzdCcsICdub25lJywgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIFRlbXBsYXRlIENvbHVtbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXRlbXBsYXRlLWNvbHVtbnNcbiAgICAgICAqL1xuICAgICAgJ2dyaWQtY29scyc6IFt7XG4gICAgICAgICdncmlkLWNvbHMnOiBzY2FsZUdyaWRUZW1wbGF0ZUNvbHNSb3dzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIENvbHVtbiBTdGFydCAvIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgICdjb2wtc3RhcnQtZW5kJzogW3tcbiAgICAgICAgY29sOiBzY2FsZUdyaWRDb2xSb3dTdGFydEFuZEVuZCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBDb2x1bW4gU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWNvbHVtblxuICAgICAgICovXG4gICAgICAnY29sLXN0YXJ0JzogW3tcbiAgICAgICAgJ2NvbC1zdGFydCc6IHNjYWxlR3JpZENvbFJvd1N0YXJ0T3JFbmQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQ29sdW1uIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgICdjb2wtZW5kJzogW3tcbiAgICAgICAgJ2NvbC1lbmQnOiBzY2FsZUdyaWRDb2xSb3dTdGFydE9yRW5kKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIFRlbXBsYXRlIFJvd3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXRlbXBsYXRlLXJvd3NcbiAgICAgICAqL1xuICAgICAgJ2dyaWQtcm93cyc6IFt7XG4gICAgICAgICdncmlkLXJvd3MnOiBzY2FsZUdyaWRUZW1wbGF0ZUNvbHNSb3dzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIFJvdyBTdGFydCAvIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtcm93XG4gICAgICAgKi9cbiAgICAgICdyb3ctc3RhcnQtZW5kJzogW3tcbiAgICAgICAgcm93OiBzY2FsZUdyaWRDb2xSb3dTdGFydEFuZEVuZCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBSb3cgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXJvd1xuICAgICAgICovXG4gICAgICAncm93LXN0YXJ0JzogW3tcbiAgICAgICAgJ3Jvdy1zdGFydCc6IHNjYWxlR3JpZENvbFJvd1N0YXJ0T3JFbmQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgUm93IEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtcm93XG4gICAgICAgKi9cbiAgICAgICdyb3ctZW5kJzogW3tcbiAgICAgICAgJ3Jvdy1lbmQnOiBzY2FsZUdyaWRDb2xSb3dTdGFydE9yRW5kKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIEF1dG8gRmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtYXV0by1mbG93XG4gICAgICAgKi9cbiAgICAgICdncmlkLWZsb3cnOiBbe1xuICAgICAgICAnZ3JpZC1mbG93JzogWydyb3cnLCAnY29sJywgJ2RlbnNlJywgJ3Jvdy1kZW5zZScsICdjb2wtZGVuc2UnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQXV0byBDb2x1bW5zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1hdXRvLWNvbHVtbnNcbiAgICAgICAqL1xuICAgICAgJ2F1dG8tY29scyc6IFt7XG4gICAgICAgICdhdXRvLWNvbHMnOiBzY2FsZUdyaWRBdXRvQ29sc1Jvd3MoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQXV0byBSb3dzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1hdXRvLXJvd3NcbiAgICAgICAqL1xuICAgICAgJ2F1dG8tcm93cyc6IFt7XG4gICAgICAgICdhdXRvLXJvd3MnOiBzY2FsZUdyaWRBdXRvQ29sc1Jvd3MoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdhcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dhcFxuICAgICAgICovXG4gICAgICBnYXA6IFt7XG4gICAgICAgIGdhcDogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdhcCBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ2FwXG4gICAgICAgKi9cbiAgICAgICdnYXAteCc6IFt7XG4gICAgICAgICdnYXAteCc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHYXAgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dhcFxuICAgICAgICovXG4gICAgICAnZ2FwLXknOiBbe1xuICAgICAgICAnZ2FwLXknOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSnVzdGlmeSBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdGlmeS1jb250ZW50XG4gICAgICAgKi9cbiAgICAgICdqdXN0aWZ5LWNvbnRlbnQnOiBbe1xuICAgICAgICBqdXN0aWZ5OiBbLi4uc2NhbGVBbGlnblByaW1hcnlBeGlzKCksICdub3JtYWwnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEp1c3RpZnkgSXRlbXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9qdXN0aWZ5LWl0ZW1zXG4gICAgICAgKi9cbiAgICAgICdqdXN0aWZ5LWl0ZW1zJzogW3tcbiAgICAgICAgJ2p1c3RpZnktaXRlbXMnOiBbLi4uc2NhbGVBbGlnblNlY29uZGFyeUF4aXMoKSwgJ25vcm1hbCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSnVzdGlmeSBTZWxmXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdGlmeS1zZWxmXG4gICAgICAgKi9cbiAgICAgICdqdXN0aWZ5LXNlbGYnOiBbe1xuICAgICAgICAnanVzdGlmeS1zZWxmJzogWydhdXRvJywgLi4uc2NhbGVBbGlnblNlY29uZGFyeUF4aXMoKV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbGlnbiBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWxpZ24tY29udGVudFxuICAgICAgICovXG4gICAgICAnYWxpZ24tY29udGVudCc6IFt7XG4gICAgICAgIGNvbnRlbnQ6IFsnbm9ybWFsJywgLi4uc2NhbGVBbGlnblByaW1hcnlBeGlzKCldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQWxpZ24gSXRlbXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hbGlnbi1pdGVtc1xuICAgICAgICovXG4gICAgICAnYWxpZ24taXRlbXMnOiBbe1xuICAgICAgICBpdGVtczogWy4uLnNjYWxlQWxpZ25TZWNvbmRhcnlBeGlzKCksIHtcbiAgICAgICAgICBiYXNlbGluZTogWycnLCAnbGFzdCddXG4gICAgICAgIH1dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQWxpZ24gU2VsZlxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLXNlbGZcbiAgICAgICAqL1xuICAgICAgJ2FsaWduLXNlbGYnOiBbe1xuICAgICAgICBzZWxmOiBbJ2F1dG8nLCAuLi5zY2FsZUFsaWduU2Vjb25kYXJ5QXhpcygpLCB7XG4gICAgICAgICAgYmFzZWxpbmU6IFsnJywgJ2xhc3QnXVxuICAgICAgICB9XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlIENvbnRlbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZS1jb250ZW50XG4gICAgICAgKi9cbiAgICAgICdwbGFjZS1jb250ZW50JzogW3tcbiAgICAgICAgJ3BsYWNlLWNvbnRlbnQnOiBzY2FsZUFsaWduUHJpbWFyeUF4aXMoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlIEl0ZW1zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2UtaXRlbXNcbiAgICAgICAqL1xuICAgICAgJ3BsYWNlLWl0ZW1zJzogW3tcbiAgICAgICAgJ3BsYWNlLWl0ZW1zJzogWy4uLnNjYWxlQWxpZ25TZWNvbmRhcnlBeGlzKCksICdiYXNlbGluZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2UgU2VsZlxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlLXNlbGZcbiAgICAgICAqL1xuICAgICAgJ3BsYWNlLXNlbGYnOiBbe1xuICAgICAgICAncGxhY2Utc2VsZic6IFsnYXV0bycsIC4uLnNjYWxlQWxpZ25TZWNvbmRhcnlBeGlzKCldXG4gICAgICB9XSxcbiAgICAgIC8vIFNwYWNpbmdcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZ1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcDogW3tcbiAgICAgICAgcDogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHg6IFt7XG4gICAgICAgIHB4OiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBweTogW3tcbiAgICAgICAgcHk6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwczogW3tcbiAgICAgICAgcHM6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcGU6IFt7XG4gICAgICAgIHBlOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHB0OiBbe1xuICAgICAgICBwdDogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHByOiBbe1xuICAgICAgICBwcjogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwYjogW3tcbiAgICAgICAgcGI6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBsOiBbe1xuICAgICAgICBwbDogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtOiBbe1xuICAgICAgICBtOiBzY2FsZU1hcmdpbigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXg6IFt7XG4gICAgICAgIG14OiBzY2FsZU1hcmdpbigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXk6IFt7XG4gICAgICAgIG15OiBzY2FsZU1hcmdpbigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG1zOiBbe1xuICAgICAgICBtczogc2NhbGVNYXJnaW4oKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbWU6IFt7XG4gICAgICAgIG1lOiBzY2FsZU1hcmdpbigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtdDogW3tcbiAgICAgICAgbXQ6IHNjYWxlTWFyZ2luKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXI6IFt7XG4gICAgICAgIG1yOiBzY2FsZU1hcmdpbigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtYjogW3tcbiAgICAgICAgbWI6IHNjYWxlTWFyZ2luKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtbDogW3tcbiAgICAgICAgbWw6IHNjYWxlTWFyZ2luKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGFjZSBCZXR3ZWVuIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW4jYWRkaW5nLXNwYWNlLWJldHdlZW4tY2hpbGRyZW5cbiAgICAgICAqL1xuICAgICAgJ3NwYWNlLXgnOiBbe1xuICAgICAgICAnc3BhY2UteCc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGFjZSBCZXR3ZWVuIFggUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpbiNhZGRpbmctc3BhY2UtYmV0d2Vlbi1jaGlsZHJlblxuICAgICAgICovXG4gICAgICAnc3BhY2UteC1yZXZlcnNlJzogWydzcGFjZS14LXJldmVyc2UnXSxcbiAgICAgIC8qKlxuICAgICAgICogU3BhY2UgQmV0d2VlbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luI2FkZGluZy1zcGFjZS1iZXR3ZWVuLWNoaWxkcmVuXG4gICAgICAgKi9cbiAgICAgICdzcGFjZS15JzogW3tcbiAgICAgICAgJ3NwYWNlLXknOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3BhY2UgQmV0d2VlbiBZIFJldmVyc2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW4jYWRkaW5nLXNwYWNlLWJldHdlZW4tY2hpbGRyZW5cbiAgICAgICAqL1xuICAgICAgJ3NwYWNlLXktcmV2ZXJzZSc6IFsnc3BhY2UteS1yZXZlcnNlJ10sXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIFNpemluZyAtLS1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tXG4gICAgICAvKipcbiAgICAgICAqIFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93aWR0aCNzZXR0aW5nLWJvdGgtd2lkdGgtYW5kLWhlaWdodFxuICAgICAgICovXG4gICAgICBzaXplOiBbe1xuICAgICAgICBzaXplOiBzY2FsZVNpemluZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93aWR0aFxuICAgICAgICovXG4gICAgICB3OiBbe1xuICAgICAgICB3OiBbdGhlbWVDb250YWluZXIsICdzY3JlZW4nLCAuLi5zY2FsZVNpemluZygpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1pbi1XaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21pbi13aWR0aFxuICAgICAgICovXG4gICAgICAnbWluLXcnOiBbe1xuICAgICAgICAnbWluLXcnOiBbdGhlbWVDb250YWluZXIsICdzY3JlZW4nLCAvKiogRGVwcmVjYXRlZC4gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzLmNvbS9pc3N1ZXMvMjAyNyNpc3N1ZWNvbW1lbnQtMjYyMDE1Mjc1NyAqL1xuICAgICAgICAnbm9uZScsIC4uLnNjYWxlU2l6aW5nKCldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWF4LVdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWF4LXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdtYXgtdyc6IFt7XG4gICAgICAgICdtYXgtdyc6IFt0aGVtZUNvbnRhaW5lciwgJ3NjcmVlbicsICdub25lJywgLyoqIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjAuMC4gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzLmNvbS9pc3N1ZXMvMjAyNyNpc3N1ZWNvbW1lbnQtMjYyMDE1Mjc1NyAqL1xuICAgICAgICAncHJvc2UnLCAvKiogRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMC4wLiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MuY29tL2lzc3Vlcy8yMDI3I2lzc3VlY29tbWVudC0yNjIwMTUyNzU3ICovXG4gICAgICAgIHtcbiAgICAgICAgICBzY3JlZW46IFt0aGVtZUJyZWFrcG9pbnRdXG4gICAgICAgIH0sIC4uLnNjYWxlU2l6aW5nKCldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSGVpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaGVpZ2h0XG4gICAgICAgKi9cbiAgICAgIGg6IFt7XG4gICAgICAgIGg6IFsnc2NyZWVuJywgJ2xoJywgLi4uc2NhbGVTaXppbmcoKV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNaW4tSGVpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWluLWhlaWdodFxuICAgICAgICovXG4gICAgICAnbWluLWgnOiBbe1xuICAgICAgICAnbWluLWgnOiBbJ3NjcmVlbicsICdsaCcsICdub25lJywgLi4uc2NhbGVTaXppbmcoKV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXgtSGVpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWF4LWhlaWdodFxuICAgICAgICovXG4gICAgICAnbWF4LWgnOiBbe1xuICAgICAgICAnbWF4LWgnOiBbJ3NjcmVlbicsICdsaCcsIC4uLnNjYWxlU2l6aW5nKCldXG4gICAgICB9XSxcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIFR5cG9ncmFwaHkgLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8qKlxuICAgICAgICogRm9udCBTaXplXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zaXplXG4gICAgICAgKi9cbiAgICAgICdmb250LXNpemUnOiBbe1xuICAgICAgICB0ZXh0OiBbJ2Jhc2UnLCB0aGVtZVRleHQsIGlzQXJiaXRyYXJ5VmFyaWFibGVMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgU21vb3RoaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zbW9vdGhpbmdcbiAgICAgICAqL1xuICAgICAgJ2ZvbnQtc21vb3RoaW5nJzogWydhbnRpYWxpYXNlZCcsICdzdWJwaXhlbC1hbnRpYWxpYXNlZCddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zdHlsZVxuICAgICAgICovXG4gICAgICAnZm9udC1zdHlsZSc6IFsnaXRhbGljJywgJ25vdC1pdGFsaWMnXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBXZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXdlaWdodFxuICAgICAgICovXG4gICAgICAnZm9udC13ZWlnaHQnOiBbe1xuICAgICAgICBmb250OiBbdGhlbWVGb250V2VpZ2h0LCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeU51bWJlcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFN0cmV0Y2hcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXN0cmV0Y2hcbiAgICAgICAqL1xuICAgICAgJ2ZvbnQtc3RyZXRjaCc6IFt7XG4gICAgICAgICdmb250LXN0cmV0Y2gnOiBbJ3VsdHJhLWNvbmRlbnNlZCcsICdleHRyYS1jb25kZW5zZWQnLCAnY29uZGVuc2VkJywgJ3NlbWktY29uZGVuc2VkJywgJ25vcm1hbCcsICdzZW1pLWV4cGFuZGVkJywgJ2V4cGFuZGVkJywgJ2V4dHJhLWV4cGFuZGVkJywgJ3VsdHJhLWV4cGFuZGVkJywgaXNQZXJjZW50LCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgRmFtaWx5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1mYW1pbHlcbiAgICAgICAqL1xuICAgICAgJ2ZvbnQtZmFtaWx5JzogW3tcbiAgICAgICAgZm9udDogW2lzQXJiaXRyYXJ5VmFyaWFibGVGYW1pbHlOYW1lLCBpc0FyYml0cmFyeVZhbHVlLCB0aGVtZUZvbnRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLW5vcm1hbCc6IFsnbm9ybWFsLW51bXMnXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLW9yZGluYWwnOiBbJ29yZGluYWwnXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLXNsYXNoZWQtemVybyc6IFsnc2xhc2hlZC16ZXJvJ10sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAqL1xuICAgICAgJ2Z2bi1maWd1cmUnOiBbJ2xpbmluZy1udW1zJywgJ29sZHN0eWxlLW51bXMnXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLXNwYWNpbmcnOiBbJ3Byb3BvcnRpb25hbC1udW1zJywgJ3RhYnVsYXItbnVtcyddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgICdmdm4tZnJhY3Rpb24nOiBbJ2RpYWdvbmFsLWZyYWN0aW9ucycsICdzdGFja2VkLWZyYWN0aW9ucyddLFxuICAgICAgLyoqXG4gICAgICAgKiBMZXR0ZXIgU3BhY2luZ1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2xldHRlci1zcGFjaW5nXG4gICAgICAgKi9cbiAgICAgIHRyYWNraW5nOiBbe1xuICAgICAgICB0cmFja2luZzogW3RoZW1lVHJhY2tpbmcsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTGluZSBDbGFtcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2xpbmUtY2xhbXBcbiAgICAgICAqL1xuICAgICAgJ2xpbmUtY2xhbXAnOiBbe1xuICAgICAgICAnbGluZS1jbGFtcCc6IFtpc051bWJlciwgJ25vbmUnLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeU51bWJlcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaW5lIEhlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2xpbmUtaGVpZ2h0XG4gICAgICAgKi9cbiAgICAgIGxlYWRpbmc6IFt7XG4gICAgICAgIGxlYWRpbmc6IFsvKiogRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMC4wLiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MuY29tL2lzc3Vlcy8yMDI3I2lzc3VlY29tbWVudC0yNjIwMTUyNzU3ICovXG4gICAgICAgIHRoZW1lTGVhZGluZywgLi4uc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIEltYWdlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGlzdC1zdHlsZS1pbWFnZVxuICAgICAgICovXG4gICAgICAnbGlzdC1pbWFnZSc6IFt7XG4gICAgICAgICdsaXN0LWltYWdlJzogWydub25lJywgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGlzdC1zdHlsZS1wb3NpdGlvblxuICAgICAgICovXG4gICAgICAnbGlzdC1zdHlsZS1wb3NpdGlvbic6IFt7XG4gICAgICAgIGxpc3Q6IFsnaW5zaWRlJywgJ291dHNpZGUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpc3QgU3R5bGUgVHlwZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2xpc3Qtc3R5bGUtdHlwZVxuICAgICAgICovXG4gICAgICAnbGlzdC1zdHlsZS10eXBlJzogW3tcbiAgICAgICAgbGlzdDogWydkaXNjJywgJ2RlY2ltYWwnLCAnbm9uZScsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBBbGlnbm1lbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWFsaWduXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWFsaWdubWVudCc6IFt7XG4gICAgICAgIHRleHQ6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnLCAnanVzdGlmeScsICdzdGFydCcsICdlbmQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlaG9sZGVyIENvbG9yXG4gICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjMuMC4wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdjMudGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2Vob2xkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ3BsYWNlaG9sZGVyLWNvbG9yJzogW3tcbiAgICAgICAgcGxhY2Vob2xkZXI6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWNvbG9yXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWNvbG9yJzogW3tcbiAgICAgICAgdGV4dDogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWRlY29yYXRpb24nOiBbJ3VuZGVybGluZScsICdvdmVybGluZScsICdsaW5lLXRocm91Z2gnLCAnbm8tdW5kZXJsaW5lJ10sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgRGVjb3JhdGlvbiBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvbi1zdHlsZVxuICAgICAgICovXG4gICAgICAndGV4dC1kZWNvcmF0aW9uLXN0eWxlJzogW3tcbiAgICAgICAgZGVjb3JhdGlvbjogWy4uLnNjYWxlTGluZVN0eWxlKCksICd3YXZ5J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IERlY29yYXRpb24gVGhpY2tuZXNzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uLXRoaWNrbmVzc1xuICAgICAgICovXG4gICAgICAndGV4dC1kZWNvcmF0aW9uLXRoaWNrbmVzcyc6IFt7XG4gICAgICAgIGRlY29yYXRpb246IFtpc051bWJlciwgJ2Zyb20tZm9udCcsICdhdXRvJywgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlMZW5ndGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LWRlY29yYXRpb24tY29sb3InOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IFVuZGVybGluZSBPZmZzZXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LXVuZGVybGluZS1vZmZzZXRcbiAgICAgICAqL1xuICAgICAgJ3VuZGVybGluZS1vZmZzZXQnOiBbe1xuICAgICAgICAndW5kZXJsaW5lLW9mZnNldCc6IFtpc051bWJlciwgJ2F1dG8nLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgVHJhbnNmb3JtXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC10cmFuc2Zvcm1cbiAgICAgICAqL1xuICAgICAgJ3RleHQtdHJhbnNmb3JtJzogWyd1cHBlcmNhc2UnLCAnbG93ZXJjYXNlJywgJ2NhcGl0YWxpemUnLCAnbm9ybWFsLWNhc2UnXSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBPdmVyZmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgJ3RleHQtb3ZlcmZsb3cnOiBbJ3RydW5jYXRlJywgJ3RleHQtZWxsaXBzaXMnLCAndGV4dC1jbGlwJ10sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgV3JhcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtd3JhcFxuICAgICAgICovXG4gICAgICAndGV4dC13cmFwJzogW3tcbiAgICAgICAgdGV4dDogWyd3cmFwJywgJ25vd3JhcCcsICdiYWxhbmNlJywgJ3ByZXR0eSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBJbmRlbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWluZGVudFxuICAgICAgICovXG4gICAgICBpbmRlbnQ6IFt7XG4gICAgICAgIGluZGVudDogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFZlcnRpY2FsIEFsaWdubWVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3ZlcnRpY2FsLWFsaWduXG4gICAgICAgKi9cbiAgICAgICd2ZXJ0aWNhbC1hbGlnbic6IFt7XG4gICAgICAgIGFsaWduOiBbJ2Jhc2VsaW5lJywgJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJywgJ3RleHQtdG9wJywgJ3RleHQtYm90dG9tJywgJ3N1YicsICdzdXBlcicsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogV2hpdGVzcGFjZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3doaXRlc3BhY2VcbiAgICAgICAqL1xuICAgICAgd2hpdGVzcGFjZTogW3tcbiAgICAgICAgd2hpdGVzcGFjZTogWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZScsICdwcmUtbGluZScsICdwcmUtd3JhcCcsICdicmVhay1zcGFjZXMnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFdvcmQgQnJlYWtcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93b3JkLWJyZWFrXG4gICAgICAgKi9cbiAgICAgIGJyZWFrOiBbe1xuICAgICAgICBicmVhazogWydub3JtYWwnLCAnd29yZHMnLCAnYWxsJywgJ2tlZXAnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJmbG93IFdyYXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyZmxvdy13cmFwXG4gICAgICAgKi9cbiAgICAgIHdyYXA6IFt7XG4gICAgICAgIHdyYXA6IFsnYnJlYWstd29yZCcsICdhbnl3aGVyZScsICdub3JtYWwnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEh5cGhlbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9oeXBoZW5zXG4gICAgICAgKi9cbiAgICAgIGh5cGhlbnM6IFt7XG4gICAgICAgIGh5cGhlbnM6IFsnbm9uZScsICdtYW51YWwnLCAnYXV0byddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbnRlbnRcbiAgICAgICAqL1xuICAgICAgY29udGVudDogW3tcbiAgICAgICAgY29udGVudDogWydub25lJywgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIEJhY2tncm91bmRzIC0tLVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIEF0dGFjaG1lbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWF0dGFjaG1lbnRcbiAgICAgICAqL1xuICAgICAgJ2JnLWF0dGFjaG1lbnQnOiBbe1xuICAgICAgICBiZzogWydmaXhlZCcsICdsb2NhbCcsICdzY3JvbGwnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgQ2xpcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtY2xpcFxuICAgICAgICovXG4gICAgICAnYmctY2xpcCc6IFt7XG4gICAgICAgICdiZy1jbGlwJzogWydib3JkZXInLCAncGFkZGluZycsICdjb250ZW50JywgJ3RleHQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgT3JpZ2luXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1vcmlnaW5cbiAgICAgICAqL1xuICAgICAgJ2JnLW9yaWdpbic6IFt7XG4gICAgICAgICdiZy1vcmlnaW4nOiBbJ2JvcmRlcicsICdwYWRkaW5nJywgJ2NvbnRlbnQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgICdiZy1wb3NpdGlvbic6IFt7XG4gICAgICAgIGJnOiBzY2FsZUJnUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgUmVwZWF0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1yZXBlYXRcbiAgICAgICAqL1xuICAgICAgJ2JnLXJlcGVhdCc6IFt7XG4gICAgICAgIGJnOiBzY2FsZUJnUmVwZWF0KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXNpemVcbiAgICAgICAqL1xuICAgICAgJ2JnLXNpemUnOiBbe1xuICAgICAgICBiZzogc2NhbGVCZ1NpemUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgSW1hZ2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWltYWdlXG4gICAgICAgKi9cbiAgICAgICdiZy1pbWFnZSc6IFt7XG4gICAgICAgIGJnOiBbJ25vbmUnLCB7XG4gICAgICAgICAgbGluZWFyOiBbe1xuICAgICAgICAgICAgdG86IFsndCcsICd0cicsICdyJywgJ2JyJywgJ2InLCAnYmwnLCAnbCcsICd0bCddXG4gICAgICAgICAgfSwgaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSxcbiAgICAgICAgICByYWRpYWw6IFsnJywgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0sXG4gICAgICAgICAgY29uaWM6IFtpc0ludGVnZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICAgIH0sIGlzQXJiaXRyYXJ5VmFyaWFibGVJbWFnZSwgaXNBcmJpdHJhcnlJbWFnZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1jb2xvclxuICAgICAgICovXG4gICAgICAnYmctY29sb3InOiBbe1xuICAgICAgICBiZzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgRnJvbSBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgICdncmFkaWVudC1mcm9tLXBvcyc6IFt7XG4gICAgICAgIGZyb206IHNjYWxlR3JhZGllbnRTdG9wUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIFZpYSBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgICdncmFkaWVudC12aWEtcG9zJzogW3tcbiAgICAgICAgdmlhOiBzY2FsZUdyYWRpZW50U3RvcFBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBUbyBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgICdncmFkaWVudC10by1wb3MnOiBbe1xuICAgICAgICB0bzogc2NhbGVHcmFkaWVudFN0b3BQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgRnJvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgICdncmFkaWVudC1mcm9tJzogW3tcbiAgICAgICAgZnJvbTogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVmlhXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgJ2dyYWRpZW50LXZpYSc6IFt7XG4gICAgICAgIHZpYTogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVG9cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICAnZ3JhZGllbnQtdG8nOiBbe1xuICAgICAgICB0bzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIEJvcmRlcnMgLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgcm91bmRlZDogW3tcbiAgICAgICAgcm91bmRlZDogc2NhbGVSYWRpdXMoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLXMnOiBbe1xuICAgICAgICAncm91bmRlZC1zJzogc2NhbGVSYWRpdXMoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1lJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtZSc6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtdCc6IFt7XG4gICAgICAgICdyb3VuZGVkLXQnOiBzY2FsZVJhZGl1cygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtcic6IFt7XG4gICAgICAgICdyb3VuZGVkLXInOiBzY2FsZVJhZGl1cygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWInOiBbe1xuICAgICAgICAncm91bmRlZC1iJzogc2NhbGVSYWRpdXMoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtbCc6IFt7XG4gICAgICAgICdyb3VuZGVkLWwnOiBzY2FsZVJhZGl1cygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBTdGFydCBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtc3MnOiBbe1xuICAgICAgICAncm91bmRlZC1zcyc6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0IEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtc2UnOiBbe1xuICAgICAgICAncm91bmRlZC1zZSc6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEVuZCBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWVlJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtZWUnOiBzY2FsZVJhZGl1cygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBFbmQgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWVzJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtZXMnOiBzY2FsZVJhZGl1cygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3AgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtdGwnOiBbe1xuICAgICAgICAncm91bmRlZC10bCc6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFRvcCBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtdHInOiBbe1xuICAgICAgICAncm91bmRlZC10cic6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEJvdHRvbSBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtYnInOiBbe1xuICAgICAgICAncm91bmRlZC1icic6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEJvdHRvbSBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1ibCc6IFt7XG4gICAgICAgICdyb3VuZGVkLWJsJzogc2NhbGVSYWRpdXMoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXcnOiBbe1xuICAgICAgICBib3JkZXI6IHNjYWxlQm9yZGVyV2lkdGgoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItdy14JzogW3tcbiAgICAgICAgJ2JvcmRlci14Jzogc2NhbGVCb3JkZXJXaWR0aCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LXknOiBbe1xuICAgICAgICAnYm9yZGVyLXknOiBzY2FsZUJvcmRlcldpZHRoKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LXMnOiBbe1xuICAgICAgICAnYm9yZGVyLXMnOiBzY2FsZUJvcmRlcldpZHRoKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItdy1lJzogW3tcbiAgICAgICAgJ2JvcmRlci1lJzogc2NhbGVCb3JkZXJXaWR0aCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctdCc6IFt7XG4gICAgICAgICdib3JkZXItdCc6IHNjYWxlQm9yZGVyV2lkdGgoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctcic6IFt7XG4gICAgICAgICdib3JkZXItcic6IHNjYWxlQm9yZGVyV2lkdGgoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LWInOiBbe1xuICAgICAgICAnYm9yZGVyLWInOiBzY2FsZUJvcmRlcldpZHRoKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctbCc6IFt7XG4gICAgICAgICdib3JkZXItbCc6IHNjYWxlQm9yZGVyV2lkdGgoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBXaWR0aCBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoI2JldHdlZW4tY2hpbGRyZW5cbiAgICAgICAqL1xuICAgICAgJ2RpdmlkZS14JzogW3tcbiAgICAgICAgJ2RpdmlkZS14Jzogc2NhbGVCb3JkZXJXaWR0aCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFggUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aCNiZXR3ZWVuLWNoaWxkcmVuXG4gICAgICAgKi9cbiAgICAgICdkaXZpZGUteC1yZXZlcnNlJzogWydkaXZpZGUteC1yZXZlcnNlJ10sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBXaWR0aCBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoI2JldHdlZW4tY2hpbGRyZW5cbiAgICAgICAqL1xuICAgICAgJ2RpdmlkZS15JzogW3tcbiAgICAgICAgJ2RpdmlkZS15Jzogc2NhbGVCb3JkZXJXaWR0aCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFkgUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aCNiZXR3ZWVuLWNoaWxkcmVuXG4gICAgICAgKi9cbiAgICAgICdkaXZpZGUteS1yZXZlcnNlJzogWydkaXZpZGUteS1yZXZlcnNlJ10sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1zdHlsZVxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXN0eWxlJzogW3tcbiAgICAgICAgYm9yZGVyOiBbLi4uc2NhbGVMaW5lU3R5bGUoKSwgJ2hpZGRlbicsICdub25lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgU3R5bGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3R5bGUjc2V0dGluZy10aGUtZGl2aWRlci1zdHlsZVxuICAgICAgICovXG4gICAgICAnZGl2aWRlLXN0eWxlJzogW3tcbiAgICAgICAgZGl2aWRlOiBbLi4uc2NhbGVMaW5lU3R5bGUoKSwgJ2hpZGRlbicsICdub25lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvcic6IFt7XG4gICAgICAgIGJvcmRlcjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvci14JzogW3tcbiAgICAgICAgJ2JvcmRlci14Jzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvci15JzogW3tcbiAgICAgICAgJ2JvcmRlci15Jzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvci1zJzogW3tcbiAgICAgICAgJ2JvcmRlci1zJzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIEVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvci1lJzogW3tcbiAgICAgICAgJ2JvcmRlci1lJzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLXQnOiBbe1xuICAgICAgICAnYm9yZGVyLXQnOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvci1yJzogW3tcbiAgICAgICAgJ2JvcmRlci1yJzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLWInOiBbe1xuICAgICAgICAnYm9yZGVyLWInOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLWwnOiBbe1xuICAgICAgICAnYm9yZGVyLWwnOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9kaXZpZGUtY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2RpdmlkZS1jb2xvcic6IFt7XG4gICAgICAgIGRpdmlkZTogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3V0bGluZSBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtc3R5bGVcbiAgICAgICAqL1xuICAgICAgJ291dGxpbmUtc3R5bGUnOiBbe1xuICAgICAgICBvdXRsaW5lOiBbLi4uc2NhbGVMaW5lU3R5bGUoKSwgJ25vbmUnLCAnaGlkZGVuJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdXRsaW5lIE9mZnNldFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtb2Zmc2V0XG4gICAgICAgKi9cbiAgICAgICdvdXRsaW5lLW9mZnNldCc6IFt7XG4gICAgICAgICdvdXRsaW5lLW9mZnNldCc6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdXRsaW5lIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3V0bGluZS13aWR0aFxuICAgICAgICovXG4gICAgICAnb3V0bGluZS13JzogW3tcbiAgICAgICAgb3V0bGluZTogWycnLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZUxlbmd0aCwgaXNBcmJpdHJhcnlMZW5ndGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3V0bGluZSBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtY29sb3JcbiAgICAgICAqL1xuICAgICAgJ291dGxpbmUtY29sb3InOiBbe1xuICAgICAgICBvdXRsaW5lOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyAtLS0gRWZmZWN0cyAtLS1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAgICAgLyoqXG4gICAgICAgKiBCb3ggU2hhZG93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNoYWRvd1xuICAgICAgICovXG4gICAgICBzaGFkb3c6IFt7XG4gICAgICAgIHNoYWRvdzogW1xuICAgICAgICAvLyBEZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4wLjBcbiAgICAgICAgJycsICdub25lJywgdGhlbWVTaGFkb3csIGlzQXJiaXRyYXJ5VmFyaWFibGVTaGFkb3csIGlzQXJiaXRyYXJ5U2hhZG93XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJveCBTaGFkb3cgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2hhZG93I3NldHRpbmctdGhlLXNoYWRvdy1jb2xvclxuICAgICAgICovXG4gICAgICAnc2hhZG93LWNvbG9yJzogW3tcbiAgICAgICAgc2hhZG93OiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBJbnNldCBCb3ggU2hhZG93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNoYWRvdyNhZGRpbmctYW4taW5zZXQtc2hhZG93XG4gICAgICAgKi9cbiAgICAgICdpbnNldC1zaGFkb3cnOiBbe1xuICAgICAgICAnaW5zZXQtc2hhZG93JzogWydub25lJywgdGhlbWVJbnNldFNoYWRvdywgaXNBcmJpdHJhcnlWYXJpYWJsZVNoYWRvdywgaXNBcmJpdHJhcnlTaGFkb3ddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSW5zZXQgQm94IFNoYWRvdyBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3cjc2V0dGluZy10aGUtaW5zZXQtc2hhZG93LWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdpbnNldC1zaGFkb3ctY29sb3InOiBbe1xuICAgICAgICAnaW5zZXQtc2hhZG93Jzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3cjYWRkaW5nLWEtcmluZ1xuICAgICAgICovXG4gICAgICAncmluZy13JzogW3tcbiAgICAgICAgcmluZzogc2NhbGVCb3JkZXJXaWR0aCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBXaWR0aCBJbnNldFxuICAgICAgICogQHNlZSBodHRwczovL3YzLnRhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctd2lkdGgjaW5zZXQtcmluZ3NcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9ibG9iL3Y0LjAuMC9wYWNrYWdlcy90YWlsd2luZGNzcy9zcmMvdXRpbGl0aWVzLnRzI0w0MTU4XG4gICAgICAgKi9cbiAgICAgICdyaW5nLXctaW5zZXQnOiBbJ3JpbmctaW5zZXQnXSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3cjc2V0dGluZy10aGUtcmluZy1jb2xvclxuICAgICAgICovXG4gICAgICAncmluZy1jb2xvcic6IFt7XG4gICAgICAgIHJpbmc6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpbmcgT2Zmc2V0IFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdjMudGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy1vZmZzZXQtd2lkdGhcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9ibG9iL3Y0LjAuMC9wYWNrYWdlcy90YWlsd2luZGNzcy9zcmMvdXRpbGl0aWVzLnRzI0w0MTU4XG4gICAgICAgKi9cbiAgICAgICdyaW5nLW9mZnNldC13JzogW3tcbiAgICAgICAgJ3Jpbmctb2Zmc2V0JzogW2lzTnVtYmVyLCBpc0FyYml0cmFyeUxlbmd0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIE9mZnNldCBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3YzLnRhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctb2Zmc2V0LWNvbG9yXG4gICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMC4wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvYmxvYi92NC4wLjAvcGFja2FnZXMvdGFpbHdpbmRjc3Mvc3JjL3V0aWxpdGllcy50cyNMNDE1OFxuICAgICAgICovXG4gICAgICAncmluZy1vZmZzZXQtY29sb3InOiBbe1xuICAgICAgICAncmluZy1vZmZzZXQnOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBJbnNldCBSaW5nIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNoYWRvdyNhZGRpbmctYW4taW5zZXQtcmluZ1xuICAgICAgICovXG4gICAgICAnaW5zZXQtcmluZy13JzogW3tcbiAgICAgICAgJ2luc2V0LXJpbmcnOiBzY2FsZUJvcmRlcldpZHRoKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBJbnNldCBSaW5nIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNoYWRvdyNzZXR0aW5nLXRoZS1pbnNldC1yaW5nLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdpbnNldC1yaW5nLWNvbG9yJzogW3tcbiAgICAgICAgJ2luc2V0LXJpbmcnOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IFNoYWRvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtc2hhZG93XG4gICAgICAgKi9cbiAgICAgICd0ZXh0LXNoYWRvdyc6IFt7XG4gICAgICAgICd0ZXh0LXNoYWRvdyc6IFsnbm9uZScsIHRoZW1lVGV4dFNoYWRvdywgaXNBcmJpdHJhcnlWYXJpYWJsZVNoYWRvdywgaXNBcmJpdHJhcnlTaGFkb3ddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBTaGFkb3cgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LXNoYWRvdyNzZXR0aW5nLXRoZS1zaGFkb3ctY29sb3JcbiAgICAgICAqL1xuICAgICAgJ3RleHQtc2hhZG93LWNvbG9yJzogW3tcbiAgICAgICAgJ3RleHQtc2hhZG93Jzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL29wYWNpdHlcbiAgICAgICAqL1xuICAgICAgb3BhY2l0eTogW3tcbiAgICAgICAgb3BhY2l0eTogW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1peCBCbGVuZCBNb2RlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWl4LWJsZW5kLW1vZGVcbiAgICAgICAqL1xuICAgICAgJ21peC1ibGVuZCc6IFt7XG4gICAgICAgICdtaXgtYmxlbmQnOiBbLi4uc2NhbGVCbGVuZE1vZGUoKSwgJ3BsdXMtZGFya2VyJywgJ3BsdXMtbGlnaHRlciddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBCbGVuZCBNb2RlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1ibGVuZC1tb2RlXG4gICAgICAgKi9cbiAgICAgICdiZy1ibGVuZCc6IFt7XG4gICAgICAgICdiZy1ibGVuZCc6IHNjYWxlQmxlbmRNb2RlKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXNrIENsaXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXNrLWNsaXBcbiAgICAgICAqL1xuICAgICAgJ21hc2stY2xpcCc6IFt7XG4gICAgICAgICdtYXNrLWNsaXAnOiBbJ2JvcmRlcicsICdwYWRkaW5nJywgJ2NvbnRlbnQnLCAnZmlsbCcsICdzdHJva2UnLCAndmlldyddXG4gICAgICB9LCAnbWFzay1uby1jbGlwJ10sXG4gICAgICAvKipcbiAgICAgICAqIE1hc2sgQ29tcG9zaXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFzay1jb21wb3NpdGVcbiAgICAgICAqL1xuICAgICAgJ21hc2stY29tcG9zaXRlJzogW3tcbiAgICAgICAgbWFzazogWydhZGQnLCAnc3VidHJhY3QnLCAnaW50ZXJzZWN0JywgJ2V4Y2x1ZGUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hc2sgSW1hZ2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXNrLWltYWdlXG4gICAgICAgKi9cbiAgICAgICdtYXNrLWltYWdlLWxpbmVhci1wb3MnOiBbe1xuICAgICAgICAnbWFzay1saW5lYXInOiBbaXNOdW1iZXJdXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLWxpbmVhci1mcm9tLXBvcyc6IFt7XG4gICAgICAgICdtYXNrLWxpbmVhci1mcm9tJzogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLWxpbmVhci10by1wb3MnOiBbe1xuICAgICAgICAnbWFzay1saW5lYXItdG8nOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UtbGluZWFyLWZyb20tY29sb3InOiBbe1xuICAgICAgICAnbWFzay1saW5lYXItZnJvbSc6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAnbWFzay1pbWFnZS1saW5lYXItdG8tY29sb3InOiBbe1xuICAgICAgICAnbWFzay1saW5lYXItdG8nOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UtdC1mcm9tLXBvcyc6IFt7XG4gICAgICAgICdtYXNrLXQtZnJvbSc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICAnbWFzay1pbWFnZS10LXRvLXBvcyc6IFt7XG4gICAgICAgICdtYXNrLXQtdG8nOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UtdC1mcm9tLWNvbG9yJzogW3tcbiAgICAgICAgJ21hc2stdC1mcm9tJzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLXQtdG8tY29sb3InOiBbe1xuICAgICAgICAnbWFzay10LXRvJzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLXItZnJvbS1wb3MnOiBbe1xuICAgICAgICAnbWFzay1yLWZyb20nOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2Utci10by1wb3MnOiBbe1xuICAgICAgICAnbWFzay1yLXRvJzogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLXItZnJvbS1jb2xvcic6IFt7XG4gICAgICAgICdtYXNrLXItZnJvbSc6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAnbWFzay1pbWFnZS1yLXRvLWNvbG9yJzogW3tcbiAgICAgICAgJ21hc2stci10byc6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAnbWFzay1pbWFnZS1iLWZyb20tcG9zJzogW3tcbiAgICAgICAgJ21hc2stYi1mcm9tJzogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLWItdG8tcG9zJzogW3tcbiAgICAgICAgJ21hc2stYi10byc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICAnbWFzay1pbWFnZS1iLWZyb20tY29sb3InOiBbe1xuICAgICAgICAnbWFzay1iLWZyb20nOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UtYi10by1jb2xvcic6IFt7XG4gICAgICAgICdtYXNrLWItdG8nOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UtbC1mcm9tLXBvcyc6IFt7XG4gICAgICAgICdtYXNrLWwtZnJvbSc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICAnbWFzay1pbWFnZS1sLXRvLXBvcyc6IFt7XG4gICAgICAgICdtYXNrLWwtdG8nOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UtbC1mcm9tLWNvbG9yJzogW3tcbiAgICAgICAgJ21hc2stbC1mcm9tJzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLWwtdG8tY29sb3InOiBbe1xuICAgICAgICAnbWFzay1sLXRvJzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLXgtZnJvbS1wb3MnOiBbe1xuICAgICAgICAnbWFzay14LWZyb20nOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UteC10by1wb3MnOiBbe1xuICAgICAgICAnbWFzay14LXRvJzogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLXgtZnJvbS1jb2xvcic6IFt7XG4gICAgICAgICdtYXNrLXgtZnJvbSc6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAnbWFzay1pbWFnZS14LXRvLWNvbG9yJzogW3tcbiAgICAgICAgJ21hc2steC10byc6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAnbWFzay1pbWFnZS15LWZyb20tcG9zJzogW3tcbiAgICAgICAgJ21hc2steS1mcm9tJzogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLXktdG8tcG9zJzogW3tcbiAgICAgICAgJ21hc2steS10byc6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICAnbWFzay1pbWFnZS15LWZyb20tY29sb3InOiBbe1xuICAgICAgICAnbWFzay15LWZyb20nOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UteS10by1jb2xvcic6IFt7XG4gICAgICAgICdtYXNrLXktdG8nOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UtcmFkaWFsJzogW3tcbiAgICAgICAgJ21hc2stcmFkaWFsJzogW2lzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLXJhZGlhbC1mcm9tLXBvcyc6IFt7XG4gICAgICAgICdtYXNrLXJhZGlhbC1mcm9tJzogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLXJhZGlhbC10by1wb3MnOiBbe1xuICAgICAgICAnbWFzay1yYWRpYWwtdG8nOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UtcmFkaWFsLWZyb20tY29sb3InOiBbe1xuICAgICAgICAnbWFzay1yYWRpYWwtZnJvbSc6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAnbWFzay1pbWFnZS1yYWRpYWwtdG8tY29sb3InOiBbe1xuICAgICAgICAnbWFzay1yYWRpYWwtdG8nOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UtcmFkaWFsLXNoYXBlJzogW3tcbiAgICAgICAgJ21hc2stcmFkaWFsJzogWydjaXJjbGUnLCAnZWxsaXBzZSddXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLXJhZGlhbC1zaXplJzogW3tcbiAgICAgICAgJ21hc2stcmFkaWFsJzogW3tcbiAgICAgICAgICBjbG9zZXN0OiBbJ3NpZGUnLCAnY29ybmVyJ10sXG4gICAgICAgICAgZmFydGhlc3Q6IFsnc2lkZScsICdjb3JuZXInXVxuICAgICAgICB9XVxuICAgICAgfV0sXG4gICAgICAnbWFzay1pbWFnZS1yYWRpYWwtcG9zJzogW3tcbiAgICAgICAgJ21hc2stcmFkaWFsLWF0Jzogc2NhbGVQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgICdtYXNrLWltYWdlLWNvbmljLXBvcyc6IFt7XG4gICAgICAgICdtYXNrLWNvbmljJzogW2lzTnVtYmVyXVxuICAgICAgfV0sXG4gICAgICAnbWFzay1pbWFnZS1jb25pYy1mcm9tLXBvcyc6IFt7XG4gICAgICAgICdtYXNrLWNvbmljLWZyb20nOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UtY29uaWMtdG8tcG9zJzogW3tcbiAgICAgICAgJ21hc2stY29uaWMtdG8nOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UtY29uaWMtZnJvbS1jb2xvcic6IFt7XG4gICAgICAgICdtYXNrLWNvbmljLWZyb20nOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgJ21hc2staW1hZ2UtY29uaWMtdG8tY29sb3InOiBbe1xuICAgICAgICAnbWFzay1jb25pYy10byc6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hc2sgTW9kZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2stbW9kZVxuICAgICAgICovXG4gICAgICAnbWFzay1tb2RlJzogW3tcbiAgICAgICAgbWFzazogWydhbHBoYScsICdsdW1pbmFuY2UnLCAnbWF0Y2gnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hc2sgT3JpZ2luXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFzay1vcmlnaW5cbiAgICAgICAqL1xuICAgICAgJ21hc2stb3JpZ2luJzogW3tcbiAgICAgICAgJ21hc2stb3JpZ2luJzogWydib3JkZXInLCAncGFkZGluZycsICdjb250ZW50JywgJ2ZpbGwnLCAnc3Ryb2tlJywgJ3ZpZXcnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hc2sgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXNrLXBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgICdtYXNrLXBvc2l0aW9uJzogW3tcbiAgICAgICAgbWFzazogc2NhbGVCZ1Bvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXNrIFJlcGVhdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2stcmVwZWF0XG4gICAgICAgKi9cbiAgICAgICdtYXNrLXJlcGVhdCc6IFt7XG4gICAgICAgIG1hc2s6IHNjYWxlQmdSZXBlYXQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hc2sgU2l6ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2stc2l6ZVxuICAgICAgICovXG4gICAgICAnbWFzay1zaXplJzogW3tcbiAgICAgICAgbWFzazogc2NhbGVCZ1NpemUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hc2sgVHlwZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2stdHlwZVxuICAgICAgICovXG4gICAgICAnbWFzay10eXBlJzogW3tcbiAgICAgICAgJ21hc2stdHlwZSc6IFsnYWxwaGEnLCAnbHVtaW5hbmNlJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXNrIEltYWdlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFzay1pbWFnZVxuICAgICAgICovXG4gICAgICAnbWFzay1pbWFnZSc6IFt7XG4gICAgICAgIG1hc2s6IFsnbm9uZScsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIEZpbHRlcnMgLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8qKlxuICAgICAgICogRmlsdGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmlsdGVyXG4gICAgICAgKi9cbiAgICAgIGZpbHRlcjogW3tcbiAgICAgICAgZmlsdGVyOiBbXG4gICAgICAgIC8vIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHYzLjAuMFxuICAgICAgICAnJywgJ25vbmUnLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJsdXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ibHVyXG4gICAgICAgKi9cbiAgICAgIGJsdXI6IFt7XG4gICAgICAgIGJsdXI6IHNjYWxlQmx1cigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJpZ2h0bmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JyaWdodG5lc3NcbiAgICAgICAqL1xuICAgICAgYnJpZ2h0bmVzczogW3tcbiAgICAgICAgYnJpZ2h0bmVzczogW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENvbnRyYXN0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29udHJhc3RcbiAgICAgICAqL1xuICAgICAgY29udHJhc3Q6IFt7XG4gICAgICAgIGNvbnRyYXN0OiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRHJvcCBTaGFkb3dcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9kcm9wLXNoYWRvd1xuICAgICAgICovXG4gICAgICAnZHJvcC1zaGFkb3cnOiBbe1xuICAgICAgICAnZHJvcC1zaGFkb3cnOiBbXG4gICAgICAgIC8vIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjAuMFxuICAgICAgICAnJywgJ25vbmUnLCB0aGVtZURyb3BTaGFkb3csIGlzQXJiaXRyYXJ5VmFyaWFibGVTaGFkb3csIGlzQXJiaXRyYXJ5U2hhZG93XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERyb3AgU2hhZG93IENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmlsdGVyLWRyb3Atc2hhZG93I3NldHRpbmctdGhlLXNoYWRvdy1jb2xvclxuICAgICAgICovXG4gICAgICAnZHJvcC1zaGFkb3ctY29sb3InOiBbe1xuICAgICAgICAnZHJvcC1zaGFkb3cnOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmF5c2NhbGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmF5c2NhbGVcbiAgICAgICAqL1xuICAgICAgZ3JheXNjYWxlOiBbe1xuICAgICAgICBncmF5c2NhbGU6IFsnJywgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSHVlIFJvdGF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2h1ZS1yb3RhdGVcbiAgICAgICAqL1xuICAgICAgJ2h1ZS1yb3RhdGUnOiBbe1xuICAgICAgICAnaHVlLXJvdGF0ZSc6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBJbnZlcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9pbnZlcnRcbiAgICAgICAqL1xuICAgICAgaW52ZXJ0OiBbe1xuICAgICAgICBpbnZlcnQ6IFsnJywgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2F0dXJhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zYXR1cmF0ZVxuICAgICAgICovXG4gICAgICBzYXR1cmF0ZTogW3tcbiAgICAgICAgc2F0dXJhdGU6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTZXBpYVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NlcGlhXG4gICAgICAgKi9cbiAgICAgIHNlcGlhOiBbe1xuICAgICAgICBzZXBpYTogWycnLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBGaWx0ZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1maWx0ZXJcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLWZpbHRlcic6IFt7XG4gICAgICAgICdiYWNrZHJvcC1maWx0ZXInOiBbXG4gICAgICAgIC8vIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHYzLjAuMFxuICAgICAgICAnJywgJ25vbmUnLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEJsdXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1ibHVyXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1ibHVyJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWJsdXInOiBzY2FsZUJsdXIoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEJyaWdodG5lc3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1icmlnaHRuZXNzXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1icmlnaHRuZXNzJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWJyaWdodG5lc3MnOiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgQ29udHJhc3RcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1jb250cmFzdFxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3AtY29udHJhc3QnOiBbe1xuICAgICAgICAnYmFja2Ryb3AtY29udHJhc3QnOiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgR3JheXNjYWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtZ3JheXNjYWxlXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1ncmF5c2NhbGUnOiBbe1xuICAgICAgICAnYmFja2Ryb3AtZ3JheXNjYWxlJzogWycnLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBIdWUgUm90YXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtaHVlLXJvdGF0ZVxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3AtaHVlLXJvdGF0ZSc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1odWUtcm90YXRlJzogW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEludmVydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWludmVydFxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3AtaW52ZXJ0JzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWludmVydCc6IFsnJywgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLW9wYWNpdHknOiBbe1xuICAgICAgICAnYmFja2Ryb3Atb3BhY2l0eSc6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBTYXR1cmF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLXNhdHVyYXRlXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1zYXR1cmF0ZSc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1zYXR1cmF0ZSc6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBTZXBpYVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLXNlcGlhXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1zZXBpYSc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1zZXBpYSc6IFsnJywgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyAtLS0gVGFibGVzIC0tLVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbGxhcHNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbGxhcHNlXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sbGFwc2UnOiBbe1xuICAgICAgICBib3JkZXI6IFsnY29sbGFwc2UnLCAnc2VwYXJhdGUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTcGFjaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1zcGFjaW5nJzogW3tcbiAgICAgICAgJ2JvcmRlci1zcGFjaW5nJzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTcGFjaW5nIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3BhY2luZ1xuICAgICAgICovXG4gICAgICAnYm9yZGVyLXNwYWNpbmcteCc6IFt7XG4gICAgICAgICdib3JkZXItc3BhY2luZy14Jzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTcGFjaW5nIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3BhY2luZ1xuICAgICAgICovXG4gICAgICAnYm9yZGVyLXNwYWNpbmcteSc6IFt7XG4gICAgICAgICdib3JkZXItc3BhY2luZy15Jzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRhYmxlIExheW91dFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RhYmxlLWxheW91dFxuICAgICAgICovXG4gICAgICAndGFibGUtbGF5b3V0JzogW3tcbiAgICAgICAgdGFibGU6IFsnYXV0bycsICdmaXhlZCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FwdGlvbiBTaWRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY2FwdGlvbi1zaWRlXG4gICAgICAgKi9cbiAgICAgIGNhcHRpb246IFt7XG4gICAgICAgIGNhcHRpb246IFsndG9wJywgJ2JvdHRvbSddXG4gICAgICB9XSxcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIFRyYW5zaXRpb25zIGFuZCBBbmltYXRpb24gLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbiBQcm9wZXJ0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tcHJvcGVydHlcbiAgICAgICAqL1xuICAgICAgdHJhbnNpdGlvbjogW3tcbiAgICAgICAgdHJhbnNpdGlvbjogWycnLCAnYWxsJywgJ2NvbG9ycycsICdvcGFjaXR5JywgJ3NoYWRvdycsICd0cmFuc2Zvcm0nLCAnbm9uZScsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbiBCZWhhdmlvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tYmVoYXZpb3JcbiAgICAgICAqL1xuICAgICAgJ3RyYW5zaXRpb24tYmVoYXZpb3InOiBbe1xuICAgICAgICB0cmFuc2l0aW9uOiBbJ25vcm1hbCcsICdkaXNjcmV0ZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbiBEdXJhdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tZHVyYXRpb25cbiAgICAgICAqL1xuICAgICAgZHVyYXRpb246IFt7XG4gICAgICAgIGR1cmF0aW9uOiBbaXNOdW1iZXIsICdpbml0aWFsJywgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2l0aW9uIFRpbWluZyBGdW5jdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIGVhc2U6IFt7XG4gICAgICAgIGVhc2U6IFsnbGluZWFyJywgJ2luaXRpYWwnLCB0aGVtZUVhc2UsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbiBEZWxheVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tZGVsYXlcbiAgICAgICAqL1xuICAgICAgZGVsYXk6IFt7XG4gICAgICAgIGRlbGF5OiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQW5pbWF0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYW5pbWF0aW9uXG4gICAgICAgKi9cbiAgICAgIGFuaW1hdGU6IFt7XG4gICAgICAgIGFuaW1hdGU6IFsnbm9uZScsIHRoZW1lQW5pbWF0ZSwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyAtLS0gVHJhbnNmb3JtcyAtLS1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZmFjZSBWaXNpYmlsaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2ZhY2UtdmlzaWJpbGl0eVxuICAgICAgICovXG4gICAgICBiYWNrZmFjZTogW3tcbiAgICAgICAgYmFja2ZhY2U6IFsnaGlkZGVuJywgJ3Zpc2libGUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBlcnNwZWN0aXZlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGVyc3BlY3RpdmVcbiAgICAgICAqL1xuICAgICAgcGVyc3BlY3RpdmU6IFt7XG4gICAgICAgIHBlcnNwZWN0aXZlOiBbdGhlbWVQZXJzcGVjdGl2ZSwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQZXJzcGVjdGl2ZSBPcmlnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wZXJzcGVjdGl2ZS1vcmlnaW5cbiAgICAgICAqL1xuICAgICAgJ3BlcnNwZWN0aXZlLW9yaWdpbic6IFt7XG4gICAgICAgICdwZXJzcGVjdGl2ZS1vcmlnaW4nOiBzY2FsZVBvc2l0aW9uV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUm90YXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvcm90YXRlXG4gICAgICAgKi9cbiAgICAgIHJvdGF0ZTogW3tcbiAgICAgICAgcm90YXRlOiBzY2FsZVJvdGF0ZSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUm90YXRlIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yb3RhdGVcbiAgICAgICAqL1xuICAgICAgJ3JvdGF0ZS14JzogW3tcbiAgICAgICAgJ3JvdGF0ZS14Jzogc2NhbGVSb3RhdGUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJvdGF0ZSBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvcm90YXRlXG4gICAgICAgKi9cbiAgICAgICdyb3RhdGUteSc6IFt7XG4gICAgICAgICdyb3RhdGUteSc6IHNjYWxlUm90YXRlKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSb3RhdGUgWlxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3JvdGF0ZVxuICAgICAgICovXG4gICAgICAncm90YXRlLXonOiBbe1xuICAgICAgICAncm90YXRlLXonOiBzY2FsZVJvdGF0ZSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2NhbGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY2FsZVxuICAgICAgICovXG4gICAgICBzY2FsZTogW3tcbiAgICAgICAgc2NhbGU6IHNjYWxlU2NhbGUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjYWxlIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY2FsZVxuICAgICAgICovXG4gICAgICAnc2NhbGUteCc6IFt7XG4gICAgICAgICdzY2FsZS14Jzogc2NhbGVTY2FsZSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2NhbGUgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NjYWxlXG4gICAgICAgKi9cbiAgICAgICdzY2FsZS15JzogW3tcbiAgICAgICAgJ3NjYWxlLXknOiBzY2FsZVNjYWxlKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY2FsZSBaXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAqL1xuICAgICAgJ3NjYWxlLXonOiBbe1xuICAgICAgICAnc2NhbGUteic6IHNjYWxlU2NhbGUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjYWxlIDNEXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAqL1xuICAgICAgJ3NjYWxlLTNkJzogWydzY2FsZS0zZCddLFxuICAgICAgLyoqXG4gICAgICAgKiBTa2V3XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2tld1xuICAgICAgICovXG4gICAgICBza2V3OiBbe1xuICAgICAgICBza2V3OiBzY2FsZVNrZXcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNrZXcgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NrZXdcbiAgICAgICAqL1xuICAgICAgJ3NrZXcteCc6IFt7XG4gICAgICAgICdza2V3LXgnOiBzY2FsZVNrZXcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNrZXcgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NrZXdcbiAgICAgICAqL1xuICAgICAgJ3NrZXcteSc6IFt7XG4gICAgICAgICdza2V3LXknOiBzY2FsZVNrZXcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zZm9ybVxuICAgICAgICovXG4gICAgICB0cmFuc2Zvcm06IFt7XG4gICAgICAgIHRyYW5zZm9ybTogW2lzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWUsICcnLCAnbm9uZScsICdncHUnLCAnY3B1J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gT3JpZ2luXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNmb3JtLW9yaWdpblxuICAgICAgICovXG4gICAgICAndHJhbnNmb3JtLW9yaWdpbic6IFt7XG4gICAgICAgIG9yaWdpbjogc2NhbGVQb3NpdGlvbldpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zZm9ybS1zdHlsZVxuICAgICAgICovXG4gICAgICAndHJhbnNmb3JtLXN0eWxlJzogW3tcbiAgICAgICAgdHJhbnNmb3JtOiBbJzNkJywgJ2ZsYXQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zbGF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zbGF0ZVxuICAgICAgICovXG4gICAgICB0cmFuc2xhdGU6IFt7XG4gICAgICAgIHRyYW5zbGF0ZTogc2NhbGVUcmFuc2xhdGUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zbGF0ZSBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNsYXRlXG4gICAgICAgKi9cbiAgICAgICd0cmFuc2xhdGUteCc6IFt7XG4gICAgICAgICd0cmFuc2xhdGUteCc6IHNjYWxlVHJhbnNsYXRlKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2xhdGUgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zbGF0ZVxuICAgICAgICovXG4gICAgICAndHJhbnNsYXRlLXknOiBbe1xuICAgICAgICAndHJhbnNsYXRlLXknOiBzY2FsZVRyYW5zbGF0ZSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNsYXRlIFpcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2xhdGVcbiAgICAgICAqL1xuICAgICAgJ3RyYW5zbGF0ZS16JzogW3tcbiAgICAgICAgJ3RyYW5zbGF0ZS16Jzogc2NhbGVUcmFuc2xhdGUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zbGF0ZSBOb25lXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNsYXRlXG4gICAgICAgKi9cbiAgICAgICd0cmFuc2xhdGUtbm9uZSc6IFsndHJhbnNsYXRlLW5vbmUnXSxcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIEludGVyYWN0aXZpdHkgLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8qKlxuICAgICAgICogQWNjZW50IENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWNjZW50LWNvbG9yXG4gICAgICAgKi9cbiAgICAgIGFjY2VudDogW3tcbiAgICAgICAgYWNjZW50OiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBcHBlYXJhbmNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYXBwZWFyYW5jZVxuICAgICAgICovXG4gICAgICBhcHBlYXJhbmNlOiBbe1xuICAgICAgICBhcHBlYXJhbmNlOiBbJ25vbmUnLCAnYXV0byddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FyZXQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9qdXN0LWluLXRpbWUtbW9kZSNjYXJldC1jb2xvci11dGlsaXRpZXNcbiAgICAgICAqL1xuICAgICAgJ2NhcmV0LWNvbG9yJzogW3tcbiAgICAgICAgY2FyZXQ6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENvbG9yIFNjaGVtZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbG9yLXNjaGVtZVxuICAgICAgICovXG4gICAgICAnY29sb3Itc2NoZW1lJzogW3tcbiAgICAgICAgc2NoZW1lOiBbJ25vcm1hbCcsICdkYXJrJywgJ2xpZ2h0JywgJ2xpZ2h0LWRhcmsnLCAnb25seS1kYXJrJywgJ29ubHktbGlnaHQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEN1cnNvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2N1cnNvclxuICAgICAgICovXG4gICAgICBjdXJzb3I6IFt7XG4gICAgICAgIGN1cnNvcjogWydhdXRvJywgJ2RlZmF1bHQnLCAncG9pbnRlcicsICd3YWl0JywgJ3RleHQnLCAnbW92ZScsICdoZWxwJywgJ25vdC1hbGxvd2VkJywgJ25vbmUnLCAnY29udGV4dC1tZW51JywgJ3Byb2dyZXNzJywgJ2NlbGwnLCAnY3Jvc3NoYWlyJywgJ3ZlcnRpY2FsLXRleHQnLCAnYWxpYXMnLCAnY29weScsICduby1kcm9wJywgJ2dyYWInLCAnZ3JhYmJpbmcnLCAnYWxsLXNjcm9sbCcsICdjb2wtcmVzaXplJywgJ3Jvdy1yZXNpemUnLCAnbi1yZXNpemUnLCAnZS1yZXNpemUnLCAncy1yZXNpemUnLCAndy1yZXNpemUnLCAnbmUtcmVzaXplJywgJ253LXJlc2l6ZScsICdzZS1yZXNpemUnLCAnc3ctcmVzaXplJywgJ2V3LXJlc2l6ZScsICducy1yZXNpemUnLCAnbmVzdy1yZXNpemUnLCAnbndzZS1yZXNpemUnLCAnem9vbS1pbicsICd6b29tLW91dCcsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRmllbGQgU2l6aW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmllbGQtc2l6aW5nXG4gICAgICAgKi9cbiAgICAgICdmaWVsZC1zaXppbmcnOiBbe1xuICAgICAgICAnZmllbGQtc2l6aW5nJzogWydmaXhlZCcsICdjb250ZW50J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQb2ludGVyIEV2ZW50c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BvaW50ZXItZXZlbnRzXG4gICAgICAgKi9cbiAgICAgICdwb2ludGVyLWV2ZW50cyc6IFt7XG4gICAgICAgICdwb2ludGVyLWV2ZW50cyc6IFsnYXV0bycsICdub25lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSZXNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yZXNpemVcbiAgICAgICAqL1xuICAgICAgcmVzaXplOiBbe1xuICAgICAgICByZXNpemU6IFsnbm9uZScsICcnLCAneScsICd4J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgQmVoYXZpb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtYmVoYXZpb3JcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1iZWhhdmlvcic6IFt7XG4gICAgICAgIHNjcm9sbDogWydhdXRvJywgJ3Ntb290aCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1tJzogW3tcbiAgICAgICAgJ3Njcm9sbC1tJzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1teCc6IFt7XG4gICAgICAgICdzY3JvbGwtbXgnOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW15JzogW3tcbiAgICAgICAgJ3Njcm9sbC1teSc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW1zJzogW3tcbiAgICAgICAgJ3Njcm9sbC1tcyc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1tZSc6IFt7XG4gICAgICAgICdzY3JvbGwtbWUnOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbXQnOiBbe1xuICAgICAgICAnc2Nyb2xsLW10Jzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbXInOiBbe1xuICAgICAgICAnc2Nyb2xsLW1yJzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW1iJzogW3tcbiAgICAgICAgJ3Njcm9sbC1tYic6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbWwnOiBbe1xuICAgICAgICAnc2Nyb2xsLW1sJzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1wJzogW3tcbiAgICAgICAgJ3Njcm9sbC1wJzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXB4JzogW3tcbiAgICAgICAgJ3Njcm9sbC1weCc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1weSc6IFt7XG4gICAgICAgICdzY3JvbGwtcHknOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXBzJzogW3tcbiAgICAgICAgJ3Njcm9sbC1wcyc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXBlJzogW3tcbiAgICAgICAgJ3Njcm9sbC1wZSc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXB0JzogW3tcbiAgICAgICAgJ3Njcm9sbC1wdCc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcHInOiBbe1xuICAgICAgICAnc2Nyb2xsLXByJzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcGInOiBbe1xuICAgICAgICAnc2Nyb2xsLXBiJzogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXBsJzogW3tcbiAgICAgICAgJ3Njcm9sbC1wbCc6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgU25hcCBBbGlnblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLWFsaWduXG4gICAgICAgKi9cbiAgICAgICdzbmFwLWFsaWduJzogW3tcbiAgICAgICAgc25hcDogWydzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ2FsaWduLW5vbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBTbmFwIFN0b3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtc25hcC1zdG9wXG4gICAgICAgKi9cbiAgICAgICdzbmFwLXN0b3AnOiBbe1xuICAgICAgICBzbmFwOiBbJ25vcm1hbCcsICdhbHdheXMnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBTbmFwIFR5cGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtc25hcC10eXBlXG4gICAgICAgKi9cbiAgICAgICdzbmFwLXR5cGUnOiBbe1xuICAgICAgICBzbmFwOiBbJ25vbmUnLCAneCcsICd5JywgJ2JvdGgnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBTbmFwIFR5cGUgU3RyaWN0bmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLXR5cGVcbiAgICAgICAqL1xuICAgICAgJ3NuYXAtc3RyaWN0bmVzcyc6IFt7XG4gICAgICAgIHNuYXA6IFsnbWFuZGF0b3J5JywgJ3Byb3hpbWl0eSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG91Y2ggQWN0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG91Y2gtYWN0aW9uXG4gICAgICAgKi9cbiAgICAgIHRvdWNoOiBbe1xuICAgICAgICB0b3VjaDogWydhdXRvJywgJ25vbmUnLCAnbWFuaXB1bGF0aW9uJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3VjaCBBY3Rpb24gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICovXG4gICAgICAndG91Y2gteCc6IFt7XG4gICAgICAgICd0b3VjaC1wYW4nOiBbJ3gnLCAnbGVmdCcsICdyaWdodCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG91Y2ggQWN0aW9uIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3VjaC1hY3Rpb25cbiAgICAgICAqL1xuICAgICAgJ3RvdWNoLXknOiBbe1xuICAgICAgICAndG91Y2gtcGFuJzogWyd5JywgJ3VwJywgJ2Rvd24nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvdWNoIEFjdGlvbiBQaW5jaCBab29tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG91Y2gtYWN0aW9uXG4gICAgICAgKi9cbiAgICAgICd0b3VjaC1weic6IFsndG91Y2gtcGluY2gtem9vbSddLFxuICAgICAgLyoqXG4gICAgICAgKiBVc2VyIFNlbGVjdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3VzZXItc2VsZWN0XG4gICAgICAgKi9cbiAgICAgIHNlbGVjdDogW3tcbiAgICAgICAgc2VsZWN0OiBbJ25vbmUnLCAndGV4dCcsICdhbGwnLCAnYXV0byddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogV2lsbCBDaGFuZ2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93aWxsLWNoYW5nZVxuICAgICAgICovXG4gICAgICAnd2lsbC1jaGFuZ2UnOiBbe1xuICAgICAgICAnd2lsbC1jaGFuZ2UnOiBbJ2F1dG8nLCAnc2Nyb2xsJywgJ2NvbnRlbnRzJywgJ3RyYW5zZm9ybScsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8vIC0tLS0tLS0tLS0tXG4gICAgICAvLyAtLS0gU1ZHIC0tLVxuICAgICAgLy8gLS0tLS0tLS0tLS1cbiAgICAgIC8qKlxuICAgICAgICogRmlsbFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZpbGxcbiAgICAgICAqL1xuICAgICAgZmlsbDogW3tcbiAgICAgICAgZmlsbDogWydub25lJywgLi4uc2NhbGVDb2xvcigpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFN0cm9rZSBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3N0cm9rZS13aWR0aFxuICAgICAgICovXG4gICAgICAnc3Ryb2tlLXcnOiBbe1xuICAgICAgICBzdHJva2U6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZUxlbmd0aCwgaXNBcmJpdHJhcnlMZW5ndGgsIGlzQXJiaXRyYXJ5TnVtYmVyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFN0cm9rZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3N0cm9rZVxuICAgICAgICovXG4gICAgICBzdHJva2U6IFt7XG4gICAgICAgIHN0cm9rZTogWydub25lJywgLi4uc2NhbGVDb2xvcigpXVxuICAgICAgfV0sXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIC0tLSBBY2Nlc3NpYmlsaXR5IC0tLVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvKipcbiAgICAgICAqIEZvcmNlZCBDb2xvciBBZGp1c3RcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb3JjZWQtY29sb3ItYWRqdXN0XG4gICAgICAgKi9cbiAgICAgICdmb3JjZWQtY29sb3ItYWRqdXN0JzogW3tcbiAgICAgICAgJ2ZvcmNlZC1jb2xvci1hZGp1c3QnOiBbJ2F1dG8nLCAnbm9uZSddXG4gICAgICB9XVxuICAgIH0sXG4gICAgY29uZmxpY3RpbmdDbGFzc0dyb3Vwczoge1xuICAgICAgb3ZlcmZsb3c6IFsnb3ZlcmZsb3cteCcsICdvdmVyZmxvdy15J10sXG4gICAgICBvdmVyc2Nyb2xsOiBbJ292ZXJzY3JvbGwteCcsICdvdmVyc2Nyb2xsLXknXSxcbiAgICAgIGluc2V0OiBbJ2luc2V0LXgnLCAnaW5zZXQteScsICdzdGFydCcsICdlbmQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10sXG4gICAgICAnaW5zZXQteCc6IFsncmlnaHQnLCAnbGVmdCddLFxuICAgICAgJ2luc2V0LXknOiBbJ3RvcCcsICdib3R0b20nXSxcbiAgICAgIGZsZXg6IFsnYmFzaXMnLCAnZ3JvdycsICdzaHJpbmsnXSxcbiAgICAgIGdhcDogWydnYXAteCcsICdnYXAteSddLFxuICAgICAgcDogWydweCcsICdweScsICdwcycsICdwZScsICdwdCcsICdwcicsICdwYicsICdwbCddLFxuICAgICAgcHg6IFsncHInLCAncGwnXSxcbiAgICAgIHB5OiBbJ3B0JywgJ3BiJ10sXG4gICAgICBtOiBbJ214JywgJ215JywgJ21zJywgJ21lJywgJ210JywgJ21yJywgJ21iJywgJ21sJ10sXG4gICAgICBteDogWydtcicsICdtbCddLFxuICAgICAgbXk6IFsnbXQnLCAnbWInXSxcbiAgICAgIHNpemU6IFsndycsICdoJ10sXG4gICAgICAnZm9udC1zaXplJzogWydsZWFkaW5nJ10sXG4gICAgICAnZnZuLW5vcm1hbCc6IFsnZnZuLW9yZGluYWwnLCAnZnZuLXNsYXNoZWQtemVybycsICdmdm4tZmlndXJlJywgJ2Z2bi1zcGFjaW5nJywgJ2Z2bi1mcmFjdGlvbiddLFxuICAgICAgJ2Z2bi1vcmRpbmFsJzogWydmdm4tbm9ybWFsJ10sXG4gICAgICAnZnZuLXNsYXNoZWQtemVybyc6IFsnZnZuLW5vcm1hbCddLFxuICAgICAgJ2Z2bi1maWd1cmUnOiBbJ2Z2bi1ub3JtYWwnXSxcbiAgICAgICdmdm4tc3BhY2luZyc6IFsnZnZuLW5vcm1hbCddLFxuICAgICAgJ2Z2bi1mcmFjdGlvbic6IFsnZnZuLW5vcm1hbCddLFxuICAgICAgJ2xpbmUtY2xhbXAnOiBbJ2Rpc3BsYXknLCAnb3ZlcmZsb3cnXSxcbiAgICAgIHJvdW5kZWQ6IFsncm91bmRlZC1zJywgJ3JvdW5kZWQtZScsICdyb3VuZGVkLXQnLCAncm91bmRlZC1yJywgJ3JvdW5kZWQtYicsICdyb3VuZGVkLWwnLCAncm91bmRlZC1zcycsICdyb3VuZGVkLXNlJywgJ3JvdW5kZWQtZWUnLCAncm91bmRlZC1lcycsICdyb3VuZGVkLXRsJywgJ3JvdW5kZWQtdHInLCAncm91bmRlZC1icicsICdyb3VuZGVkLWJsJ10sXG4gICAgICAncm91bmRlZC1zJzogWydyb3VuZGVkLXNzJywgJ3JvdW5kZWQtZXMnXSxcbiAgICAgICdyb3VuZGVkLWUnOiBbJ3JvdW5kZWQtc2UnLCAncm91bmRlZC1lZSddLFxuICAgICAgJ3JvdW5kZWQtdCc6IFsncm91bmRlZC10bCcsICdyb3VuZGVkLXRyJ10sXG4gICAgICAncm91bmRlZC1yJzogWydyb3VuZGVkLXRyJywgJ3JvdW5kZWQtYnInXSxcbiAgICAgICdyb3VuZGVkLWInOiBbJ3JvdW5kZWQtYnInLCAncm91bmRlZC1ibCddLFxuICAgICAgJ3JvdW5kZWQtbCc6IFsncm91bmRlZC10bCcsICdyb3VuZGVkLWJsJ10sXG4gICAgICAnYm9yZGVyLXNwYWNpbmcnOiBbJ2JvcmRlci1zcGFjaW5nLXgnLCAnYm9yZGVyLXNwYWNpbmcteSddLFxuICAgICAgJ2JvcmRlci13JzogWydib3JkZXItdy14JywgJ2JvcmRlci13LXknLCAnYm9yZGVyLXctcycsICdib3JkZXItdy1lJywgJ2JvcmRlci13LXQnLCAnYm9yZGVyLXctcicsICdib3JkZXItdy1iJywgJ2JvcmRlci13LWwnXSxcbiAgICAgICdib3JkZXItdy14JzogWydib3JkZXItdy1yJywgJ2JvcmRlci13LWwnXSxcbiAgICAgICdib3JkZXItdy15JzogWydib3JkZXItdy10JywgJ2JvcmRlci13LWInXSxcbiAgICAgICdib3JkZXItY29sb3InOiBbJ2JvcmRlci1jb2xvci14JywgJ2JvcmRlci1jb2xvci15JywgJ2JvcmRlci1jb2xvci1zJywgJ2JvcmRlci1jb2xvci1lJywgJ2JvcmRlci1jb2xvci10JywgJ2JvcmRlci1jb2xvci1yJywgJ2JvcmRlci1jb2xvci1iJywgJ2JvcmRlci1jb2xvci1sJ10sXG4gICAgICAnYm9yZGVyLWNvbG9yLXgnOiBbJ2JvcmRlci1jb2xvci1yJywgJ2JvcmRlci1jb2xvci1sJ10sXG4gICAgICAnYm9yZGVyLWNvbG9yLXknOiBbJ2JvcmRlci1jb2xvci10JywgJ2JvcmRlci1jb2xvci1iJ10sXG4gICAgICB0cmFuc2xhdGU6IFsndHJhbnNsYXRlLXgnLCAndHJhbnNsYXRlLXknLCAndHJhbnNsYXRlLW5vbmUnXSxcbiAgICAgICd0cmFuc2xhdGUtbm9uZSc6IFsndHJhbnNsYXRlJywgJ3RyYW5zbGF0ZS14JywgJ3RyYW5zbGF0ZS15JywgJ3RyYW5zbGF0ZS16J10sXG4gICAgICAnc2Nyb2xsLW0nOiBbJ3Njcm9sbC1teCcsICdzY3JvbGwtbXknLCAnc2Nyb2xsLW1zJywgJ3Njcm9sbC1tZScsICdzY3JvbGwtbXQnLCAnc2Nyb2xsLW1yJywgJ3Njcm9sbC1tYicsICdzY3JvbGwtbWwnXSxcbiAgICAgICdzY3JvbGwtbXgnOiBbJ3Njcm9sbC1tcicsICdzY3JvbGwtbWwnXSxcbiAgICAgICdzY3JvbGwtbXknOiBbJ3Njcm9sbC1tdCcsICdzY3JvbGwtbWInXSxcbiAgICAgICdzY3JvbGwtcCc6IFsnc2Nyb2xsLXB4JywgJ3Njcm9sbC1weScsICdzY3JvbGwtcHMnLCAnc2Nyb2xsLXBlJywgJ3Njcm9sbC1wdCcsICdzY3JvbGwtcHInLCAnc2Nyb2xsLXBiJywgJ3Njcm9sbC1wbCddLFxuICAgICAgJ3Njcm9sbC1weCc6IFsnc2Nyb2xsLXByJywgJ3Njcm9sbC1wbCddLFxuICAgICAgJ3Njcm9sbC1weSc6IFsnc2Nyb2xsLXB0JywgJ3Njcm9sbC1wYiddLFxuICAgICAgdG91Y2g6IFsndG91Y2gteCcsICd0b3VjaC15JywgJ3RvdWNoLXB6J10sXG4gICAgICAndG91Y2gteCc6IFsndG91Y2gnXSxcbiAgICAgICd0b3VjaC15JzogWyd0b3VjaCddLFxuICAgICAgJ3RvdWNoLXB6JzogWyd0b3VjaCddXG4gICAgfSxcbiAgICBjb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnM6IHtcbiAgICAgICdmb250LXNpemUnOiBbJ2xlYWRpbmcnXVxuICAgIH0sXG4gICAgb3JkZXJTZW5zaXRpdmVNb2RpZmllcnM6IFsnKicsICcqKicsICdhZnRlcicsICdiYWNrZHJvcCcsICdiZWZvcmUnLCAnZGV0YWlscy1jb250ZW50JywgJ2ZpbGUnLCAnZmlyc3QtbGV0dGVyJywgJ2ZpcnN0LWxpbmUnLCAnbWFya2VyJywgJ3BsYWNlaG9sZGVyJywgJ3NlbGVjdGlvbiddXG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSBiYXNlQ29uZmlnIENvbmZpZyB3aGVyZSBvdGhlciBjb25maWcgd2lsbCBiZSBtZXJnZWQgaW50by4gVGhpcyBvYmplY3Qgd2lsbCBiZSBtdXRhdGVkLlxuICogQHBhcmFtIGNvbmZpZ0V4dGVuc2lvbiBQYXJ0aWFsIGNvbmZpZyB0byBtZXJnZSBpbnRvIHRoZSBgYmFzZUNvbmZpZ2AuXG4gKi9cbmNvbnN0IG1lcmdlQ29uZmlncyA9IChiYXNlQ29uZmlnLCB7XG4gIGNhY2hlU2l6ZSxcbiAgcHJlZml4LFxuICBleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZSxcbiAgZXh0ZW5kID0ge30sXG4gIG92ZXJyaWRlID0ge31cbn0pID0+IHtcbiAgb3ZlcnJpZGVQcm9wZXJ0eShiYXNlQ29uZmlnLCAnY2FjaGVTaXplJywgY2FjaGVTaXplKTtcbiAgb3ZlcnJpZGVQcm9wZXJ0eShiYXNlQ29uZmlnLCAncHJlZml4JywgcHJlZml4KTtcbiAgb3ZlcnJpZGVQcm9wZXJ0eShiYXNlQ29uZmlnLCAnZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWUnLCBleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZSk7XG4gIG92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnLnRoZW1lLCBvdmVycmlkZS50aGVtZSk7XG4gIG92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnLmNsYXNzR3JvdXBzLCBvdmVycmlkZS5jbGFzc0dyb3Vwcyk7XG4gIG92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnLmNvbmZsaWN0aW5nQ2xhc3NHcm91cHMsIG92ZXJyaWRlLmNvbmZsaWN0aW5nQ2xhc3NHcm91cHMpO1xuICBvdmVycmlkZUNvbmZpZ1Byb3BlcnRpZXMoYmFzZUNvbmZpZy5jb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnMsIG92ZXJyaWRlLmNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVycyk7XG4gIG92ZXJyaWRlUHJvcGVydHkoYmFzZUNvbmZpZywgJ29yZGVyU2Vuc2l0aXZlTW9kaWZpZXJzJywgb3ZlcnJpZGUub3JkZXJTZW5zaXRpdmVNb2RpZmllcnMpO1xuICBtZXJnZUNvbmZpZ1Byb3BlcnRpZXMoYmFzZUNvbmZpZy50aGVtZSwgZXh0ZW5kLnRoZW1lKTtcbiAgbWVyZ2VDb25maWdQcm9wZXJ0aWVzKGJhc2VDb25maWcuY2xhc3NHcm91cHMsIGV4dGVuZC5jbGFzc0dyb3Vwcyk7XG4gIG1lcmdlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnLmNvbmZsaWN0aW5nQ2xhc3NHcm91cHMsIGV4dGVuZC5jb25mbGljdGluZ0NsYXNzR3JvdXBzKTtcbiAgbWVyZ2VDb25maWdQcm9wZXJ0aWVzKGJhc2VDb25maWcuY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzLCBleHRlbmQuY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzKTtcbiAgbWVyZ2VBcnJheVByb3BlcnRpZXMoYmFzZUNvbmZpZywgZXh0ZW5kLCAnb3JkZXJTZW5zaXRpdmVNb2RpZmllcnMnKTtcbiAgcmV0dXJuIGJhc2VDb25maWc7XG59O1xuY29uc3Qgb3ZlcnJpZGVQcm9wZXJ0eSA9IChiYXNlT2JqZWN0LCBvdmVycmlkZUtleSwgb3ZlcnJpZGVWYWx1ZSkgPT4ge1xuICBpZiAob3ZlcnJpZGVWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYmFzZU9iamVjdFtvdmVycmlkZUtleV0gPSBvdmVycmlkZVZhbHVlO1xuICB9XG59O1xuY29uc3Qgb3ZlcnJpZGVDb25maWdQcm9wZXJ0aWVzID0gKGJhc2VPYmplY3QsIG92ZXJyaWRlT2JqZWN0KSA9PiB7XG4gIGlmIChvdmVycmlkZU9iamVjdCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG92ZXJyaWRlT2JqZWN0KSB7XG4gICAgICBvdmVycmlkZVByb3BlcnR5KGJhc2VPYmplY3QsIGtleSwgb3ZlcnJpZGVPYmplY3Rba2V5XSk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgbWVyZ2VDb25maWdQcm9wZXJ0aWVzID0gKGJhc2VPYmplY3QsIG1lcmdlT2JqZWN0KSA9PiB7XG4gIGlmIChtZXJnZU9iamVjdCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1lcmdlT2JqZWN0KSB7XG4gICAgICBtZXJnZUFycmF5UHJvcGVydGllcyhiYXNlT2JqZWN0LCBtZXJnZU9iamVjdCwga2V5KTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBtZXJnZUFycmF5UHJvcGVydGllcyA9IChiYXNlT2JqZWN0LCBtZXJnZU9iamVjdCwga2V5KSA9PiB7XG4gIGNvbnN0IG1lcmdlVmFsdWUgPSBtZXJnZU9iamVjdFtrZXldO1xuICBpZiAobWVyZ2VWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYmFzZU9iamVjdFtrZXldID0gYmFzZU9iamVjdFtrZXldID8gYmFzZU9iamVjdFtrZXldLmNvbmNhdChtZXJnZVZhbHVlKSA6IG1lcmdlVmFsdWU7XG4gIH1cbn07XG5jb25zdCBleHRlbmRUYWlsd2luZE1lcmdlID0gKGNvbmZpZ0V4dGVuc2lvbiwgLi4uY3JlYXRlQ29uZmlnKSA9PiB0eXBlb2YgY29uZmlnRXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nID8gY3JlYXRlVGFpbHdpbmRNZXJnZShnZXREZWZhdWx0Q29uZmlnLCBjb25maWdFeHRlbnNpb24sIC4uLmNyZWF0ZUNvbmZpZykgOiBjcmVhdGVUYWlsd2luZE1lcmdlKCgpID0+IG1lcmdlQ29uZmlncyhnZXREZWZhdWx0Q29uZmlnKCksIGNvbmZpZ0V4dGVuc2lvbiksIC4uLmNyZWF0ZUNvbmZpZyk7XG5jb25zdCB0d01lcmdlID0gLyojX19QVVJFX18qL2NyZWF0ZVRhaWx3aW5kTWVyZ2UoZ2V0RGVmYXVsdENvbmZpZyk7XG5leHBvcnQgeyBjcmVhdGVUYWlsd2luZE1lcmdlLCBleHRlbmRUYWlsd2luZE1lcmdlLCBmcm9tVGhlbWUsIGdldERlZmF1bHRDb25maWcsIG1lcmdlQ29uZmlncywgdHdKb2luLCB0d01lcmdlLCB2YWxpZGF0b3JzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUtbWpzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-stdlib/controls/EventDispatcher.js":
/*!***************************************************************!*\
  !*** ./node_modules/three-stdlib/controls/EventDispatcher.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventDispatcher: () => (/* binding */ EventDispatcher)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass EventDispatcher {\n  constructor() {\n    // not defined in @types/three\n    __publicField(this, \"_listeners\");\n  }\n  /**\n   * Adds a listener to an event type.\n   * @param type The type of event to listen to.\n   * @param listener The function that gets called when the event is fired.\n   */\n  addEventListener(type, listener) {\n    if (this._listeners === void 0)\n      this._listeners = {};\n    const listeners = this._listeners;\n    if (listeners[type] === void 0) {\n      listeners[type] = [];\n    }\n    if (listeners[type].indexOf(listener) === -1) {\n      listeners[type].push(listener);\n    }\n  }\n  /**\n      * Checks if listener is added to an event type.\n      * @param type The type of event to listen to.\n      * @param listener The function that gets called when the event is fired.\n      */\n  hasEventListener(type, listener) {\n    if (this._listeners === void 0)\n      return false;\n    const listeners = this._listeners;\n    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n  }\n  /**\n      * Removes a listener from an event type.\n      * @param type The type of the listener that gets removed.\n      * @param listener The listener function that gets removed.\n      */\n  removeEventListener(type, listener) {\n    if (this._listeners === void 0)\n      return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[type];\n    if (listenerArray !== void 0) {\n      const index = listenerArray.indexOf(listener);\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n  }\n  /**\n      * Fire an event type.\n      * @param event The event that gets fired.\n      */\n  dispatchEvent(event) {\n    if (this._listeners === void 0)\n      return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[event.type];\n    if (listenerArray !== void 0) {\n      event.target = this;\n      const array = listenerArray.slice(0);\n      for (let i = 0, l = array.length; i < l; i++) {\n        array[i].call(this, event);\n      }\n      event.target = null;\n    }\n  }\n}\n\n//# sourceMappingURL=EventDispatcher.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvY29udHJvbHMvRXZlbnREaXNwYXRjaGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvY29udHJvbHMvRXZlbnREaXNwYXRjaGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIEV2ZW50RGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIG5vdCBkZWZpbmVkIGluIEB0eXBlcy90aHJlZVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbGlzdGVuZXJzXCIpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gYW4gZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIHRvLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdm9pZCAwKVxuICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0gPT09IHZvaWQgMCkge1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgICAgKiBDaGVja3MgaWYgbGlzdGVuZXIgaXMgYWRkZWQgdG8gYW4gZXZlbnQgdHlwZS5cbiAgICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIHRvLlxuICAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gICAgICAqL1xuICBoYXNFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICByZXR1cm4gbGlzdGVuZXJzW3R5cGVdICE9PSB2b2lkIDAgJiYgbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpICE9PSAtMTtcbiAgfVxuICAvKipcbiAgICAgICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZyb20gYW4gZXZlbnQgdHlwZS5cbiAgICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIGxpc3RlbmVyIHRoYXQgZ2V0cyByZW1vdmVkLlxuICAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRoYXQgZ2V0cyByZW1vdmVkLlxuICAgICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgY29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1t0eXBlXTtcbiAgICBpZiAobGlzdGVuZXJBcnJheSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGxpc3RlbmVyQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAgICAqIEZpcmUgYW4gZXZlbnQgdHlwZS5cbiAgICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0aGF0IGdldHMgZmlyZWQuXG4gICAgICAqL1xuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBjb25zdCBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzW2V2ZW50LnR5cGVdO1xuICAgIGlmIChsaXN0ZW5lckFycmF5ICE9PSB2b2lkIDApIHtcbiAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgICBjb25zdCBhcnJheSA9IGxpc3RlbmVyQXJyYXkuc2xpY2UoMCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBhcnJheVtpXS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnRhcmdldCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBFdmVudERpc3BhdGNoZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudERpc3BhdGNoZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-stdlib/controls/EventDispatcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-stdlib/controls/OrbitControls.js":
/*!*************************************************************!*\
  !*** ./node_modules/three-stdlib/controls/OrbitControls.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapControls: () => (/* binding */ MapControls),\n/* harmony export */   OrbitControls: () => (/* binding */ OrbitControls)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher.js */ \"(app-pages-browser)/./node_modules/three-stdlib/controls/EventDispatcher.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n\nconst _ray = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Ray();\nconst _plane = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Plane();\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180));\nconst moduloWrapAround = (offset, capacity) => (offset % capacity + capacity) % capacity;\nclass OrbitControls extends _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher {\n  constructor(object, domElement) {\n    super();\n    __publicField(this, \"object\");\n    __publicField(this, \"domElement\");\n    // Set to false to disable this control\n    __publicField(this, \"enabled\", true);\n    // \"target\" sets the location of focus, where the object orbits around\n    __publicField(this, \"target\", new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n    // How far you can dolly in and out ( PerspectiveCamera only )\n    __publicField(this, \"minDistance\", 0);\n    __publicField(this, \"maxDistance\", Infinity);\n    // How far you can zoom in and out ( OrthographicCamera only )\n    __publicField(this, \"minZoom\", 0);\n    __publicField(this, \"maxZoom\", Infinity);\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    __publicField(this, \"minPolarAngle\", 0);\n    // radians\n    __publicField(this, \"maxPolarAngle\", Math.PI);\n    // radians\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n    __publicField(this, \"minAzimuthAngle\", -Infinity);\n    // radians\n    __publicField(this, \"maxAzimuthAngle\", Infinity);\n    // radians\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n    __publicField(this, \"enableDamping\", false);\n    __publicField(this, \"dampingFactor\", 0.05);\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n    // Set to false to disable zooming\n    __publicField(this, \"enableZoom\", true);\n    __publicField(this, \"zoomSpeed\", 1);\n    // Set to false to disable rotating\n    __publicField(this, \"enableRotate\", true);\n    __publicField(this, \"rotateSpeed\", 1);\n    // Set to false to disable panning\n    __publicField(this, \"enablePan\", true);\n    __publicField(this, \"panSpeed\", 1);\n    __publicField(this, \"screenSpacePanning\", true);\n    // if false, pan orthogonal to world-space direction camera.up\n    __publicField(this, \"keyPanSpeed\", 7);\n    // pixels moved per arrow key push\n    __publicField(this, \"zoomToCursor\", false);\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n    __publicField(this, \"autoRotate\", false);\n    __publicField(this, \"autoRotateSpeed\", 2);\n    // 30 seconds per orbit when fps is 60\n    __publicField(this, \"reverseOrbit\", false);\n    // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n    __publicField(this, \"reverseHorizontalOrbit\", false);\n    // true if you want to reverse the horizontal orbit direction\n    __publicField(this, \"reverseVerticalOrbit\", false);\n    // true if you want to reverse the vertical orbit direction\n    // The four arrow keys\n    __publicField(this, \"keys\", { LEFT: \"ArrowLeft\", UP: \"ArrowUp\", RIGHT: \"ArrowRight\", BOTTOM: \"ArrowDown\" });\n    // Mouse buttons\n    __publicField(this, \"mouseButtons\", {\n      LEFT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE,\n      MIDDLE: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY,\n      RIGHT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN\n    });\n    // Touch fingers\n    __publicField(this, \"touches\", { ONE: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE, TWO: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN });\n    __publicField(this, \"target0\");\n    __publicField(this, \"position0\");\n    __publicField(this, \"zoom0\");\n    // the target DOM element for key events\n    __publicField(this, \"_domElementKeyEvents\", null);\n    __publicField(this, \"getPolarAngle\");\n    __publicField(this, \"getAzimuthalAngle\");\n    __publicField(this, \"setPolarAngle\");\n    __publicField(this, \"setAzimuthalAngle\");\n    __publicField(this, \"getDistance\");\n    // Not used in most scenarios, however they can be useful for specific use cases\n    __publicField(this, \"getZoomScale\");\n    __publicField(this, \"listenToKeyEvents\");\n    __publicField(this, \"stopListenToKeyEvents\");\n    __publicField(this, \"saveState\");\n    __publicField(this, \"reset\");\n    __publicField(this, \"update\");\n    __publicField(this, \"connect\");\n    __publicField(this, \"dispose\");\n    // Dolly in programmatically\n    __publicField(this, \"dollyIn\");\n    // Dolly out programmatically\n    __publicField(this, \"dollyOut\");\n    // Get the current scale\n    __publicField(this, \"getScale\");\n    // Set the current scale (these are not used in most scenarios, however they can be useful for specific use cases)\n    __publicField(this, \"setScale\");\n    this.object = object;\n    this.domElement = domElement;\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom;\n    this.getPolarAngle = () => spherical.phi;\n    this.getAzimuthalAngle = () => spherical.theta;\n    this.setPolarAngle = (value) => {\n      let phi = moduloWrapAround(value, 2 * Math.PI);\n      let currentPhi = spherical.phi;\n      if (currentPhi < 0)\n        currentPhi += 2 * Math.PI;\n      if (phi < 0)\n        phi += 2 * Math.PI;\n      let phiDist = Math.abs(phi - currentPhi);\n      if (2 * Math.PI - phiDist < phiDist) {\n        if (phi < currentPhi) {\n          phi += 2 * Math.PI;\n        } else {\n          currentPhi += 2 * Math.PI;\n        }\n      }\n      sphericalDelta.phi = phi - currentPhi;\n      scope.update();\n    };\n    this.setAzimuthalAngle = (value) => {\n      let theta = moduloWrapAround(value, 2 * Math.PI);\n      let currentTheta = spherical.theta;\n      if (currentTheta < 0)\n        currentTheta += 2 * Math.PI;\n      if (theta < 0)\n        theta += 2 * Math.PI;\n      let thetaDist = Math.abs(theta - currentTheta);\n      if (2 * Math.PI - thetaDist < thetaDist) {\n        if (theta < currentTheta) {\n          theta += 2 * Math.PI;\n        } else {\n          currentTheta += 2 * Math.PI;\n        }\n      }\n      sphericalDelta.theta = theta - currentTheta;\n      scope.update();\n    };\n    this.getDistance = () => scope.object.position.distanceTo(scope.target);\n    this.listenToKeyEvents = (domElement2) => {\n      domElement2.addEventListener(\"keydown\", onKeyDown);\n      this._domElementKeyEvents = domElement2;\n    };\n    this.stopListenToKeyEvents = () => {\n      this._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n      this._domElementKeyEvents = null;\n    };\n    this.saveState = () => {\n      scope.target0.copy(scope.target);\n      scope.position0.copy(scope.object.position);\n      scope.zoom0 = scope.object.zoom;\n    };\n    this.reset = () => {\n      scope.target.copy(scope.target0);\n      scope.object.position.copy(scope.position0);\n      scope.object.zoom = scope.zoom0;\n      scope.object.updateProjectionMatrix();\n      scope.dispatchEvent(changeEvent);\n      scope.update();\n      state = STATE.NONE;\n    };\n    this.update = (() => {\n      const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      const up = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n      const quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion().setFromUnitVectors(object.up, up);\n      const quatInverse = quat.clone().invert();\n      const lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      const lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n      const twoPI = 2 * Math.PI;\n      return function update() {\n        const position = scope.object.position;\n        quat.setFromUnitVectors(object.up, up);\n        quatInverse.copy(quat).invert();\n        offset.copy(position).sub(scope.target);\n        offset.applyQuaternion(quat);\n        spherical.setFromVector3(offset);\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle());\n        }\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n        } else {\n          spherical.theta += sphericalDelta.theta;\n          spherical.phi += sphericalDelta.phi;\n        }\n        let min = scope.minAzimuthAngle;\n        let max = scope.maxAzimuthAngle;\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI)\n            min += twoPI;\n          else if (min > Math.PI)\n            min -= twoPI;\n          if (max < -Math.PI)\n            max += twoPI;\n          else if (max > Math.PI)\n            max -= twoPI;\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n          } else {\n            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);\n          }\n        }\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n        spherical.makeSafe();\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor);\n        } else {\n          scope.target.add(panOffset);\n        }\n        if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {\n          spherical.radius = clampDistance(spherical.radius);\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale);\n        }\n        offset.setFromSpherical(spherical);\n        offset.applyQuaternion(quatInverse);\n        position.copy(scope.target).add(offset);\n        if (!scope.object.matrixAutoUpdate)\n          scope.object.updateMatrix();\n        scope.object.lookAt(scope.target);\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor;\n          sphericalDelta.phi *= 1 - scope.dampingFactor;\n          panOffset.multiplyScalar(1 - scope.dampingFactor);\n        } else {\n          sphericalDelta.set(0, 0, 0);\n          panOffset.set(0, 0, 0);\n        }\n        let zoomChanged = false;\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null;\n          if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera) {\n            const prevRadius = offset.length();\n            newRadius = clampDistance(prevRadius * scale);\n            const radiusDelta = prevRadius - newRadius;\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta);\n            scope.object.updateMatrixWorld();\n          } else if (scope.object.isOrthographicCamera) {\n            const mouseBefore = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);\n            mouseBefore.unproject(scope.object);\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n            scope.object.updateProjectionMatrix();\n            zoomChanged = true;\n            const mouseAfter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);\n            mouseAfter.unproject(scope.object);\n            scope.object.position.sub(mouseAfter).add(mouseBefore);\n            scope.object.updateMatrixWorld();\n            newRadius = offset.length();\n          } else {\n            console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.\");\n            scope.zoomToCursor = false;\n          }\n          if (newRadius !== null) {\n            if (scope.screenSpacePanning) {\n              scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);\n            } else {\n              _ray.origin.copy(scope.object.position);\n              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix);\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target);\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);\n                _ray.intersectPlane(_plane, scope.target);\n              }\n            }\n          }\n        } else if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n          zoomChanged = scale !== 1;\n          if (zoomChanged) {\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n            scope.object.updateProjectionMatrix();\n          }\n        }\n        scale = 1;\n        performCursorZoom = false;\n        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n          scope.dispatchEvent(changeEvent);\n          lastPosition.copy(scope.object.position);\n          lastQuaternion.copy(scope.object.quaternion);\n          zoomChanged = false;\n          return true;\n        }\n        return false;\n      };\n    })();\n    this.connect = (domElement2) => {\n      scope.domElement = domElement2;\n      scope.domElement.style.touchAction = \"none\";\n      scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n      scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n      scope.domElement.addEventListener(\"pointercancel\", onPointerUp);\n      scope.domElement.addEventListener(\"wheel\", onMouseWheel);\n    };\n    this.dispose = () => {\n      var _a, _b, _c, _d, _e, _f;\n      if (scope.domElement) {\n        scope.domElement.style.touchAction = \"auto\";\n      }\n      (_a = scope.domElement) == null ? void 0 : _a.removeEventListener(\"contextmenu\", onContextMenu);\n      (_b = scope.domElement) == null ? void 0 : _b.removeEventListener(\"pointerdown\", onPointerDown);\n      (_c = scope.domElement) == null ? void 0 : _c.removeEventListener(\"pointercancel\", onPointerUp);\n      (_d = scope.domElement) == null ? void 0 : _d.removeEventListener(\"wheel\", onMouseWheel);\n      (_e = scope.domElement) == null ? void 0 : _e.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n      (_f = scope.domElement) == null ? void 0 : _f.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n      }\n    };\n    const scope = this;\n    const changeEvent = { type: \"change\" };\n    const startEvent = { type: \"start\" };\n    const endEvent = { type: \"end\" };\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6\n    };\n    let state = STATE.NONE;\n    const EPS = 1e-6;\n    const spherical = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n    const sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n    let scale = 1;\n    const panOffset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const panStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const panEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const panDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const dollyDirection = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const mouse = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    let performCursorZoom = false;\n    const pointers = [];\n    const pointerPositions = {};\n    function getAutoRotationAngle() {\n      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n    }\n    function getZoomScale() {\n      return Math.pow(0.95, scope.zoomSpeed);\n    }\n    function rotateLeft(angle) {\n      if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n        sphericalDelta.theta += angle;\n      } else {\n        sphericalDelta.theta -= angle;\n      }\n    }\n    function rotateUp(angle) {\n      if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n        sphericalDelta.phi += angle;\n      } else {\n        sphericalDelta.phi -= angle;\n      }\n    }\n    const panLeft = (() => {\n      const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      return function panLeft2(distance, objectMatrix) {\n        v.setFromMatrixColumn(objectMatrix, 0);\n        v.multiplyScalar(-distance);\n        panOffset.add(v);\n      };\n    })();\n    const panUp = (() => {\n      const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      return function panUp2(distance, objectMatrix) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1);\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0);\n          v.crossVectors(scope.object.up, v);\n        }\n        v.multiplyScalar(distance);\n        panOffset.add(v);\n      };\n    })();\n    const pan = (() => {\n      const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      return function pan2(deltaX, deltaY) {\n        const element = scope.domElement;\n        if (element && scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera) {\n          const position = scope.object.position;\n          offset.copy(position).sub(scope.target);\n          let targetDistance = offset.length();\n          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);\n          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n        } else if (element && scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n          panLeft(\n            deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth,\n            scope.object.matrix\n          );\n          panUp(\n            deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight,\n            scope.object.matrix\n          );\n        } else {\n          console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n          scope.enablePan = false;\n        }\n      };\n    })();\n    function setScale(newScale) {\n      if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera || scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n        scale = newScale;\n      } else {\n        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n        scope.enableZoom = false;\n      }\n    }\n    function dollyOut(dollyScale) {\n      setScale(scale / dollyScale);\n    }\n    function dollyIn(dollyScale) {\n      setScale(scale * dollyScale);\n    }\n    function updateMouseParameters(event) {\n      if (!scope.zoomToCursor || !scope.domElement) {\n        return;\n      }\n      performCursorZoom = true;\n      const rect = scope.domElement.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      const w = rect.width;\n      const h = rect.height;\n      mouse.x = x / w * 2 - 1;\n      mouse.y = -(y / h) * 2 + 1;\n      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();\n    }\n    function clampDistance(dist) {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));\n    }\n    function handleMouseDownRotate(event) {\n      rotateStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseDownDolly(event) {\n      updateMouseParameters(event);\n      dollyStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseDownPan(event) {\n      panStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseMoveRotate(event) {\n      rotateEnd.set(event.clientX, event.clientY);\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      const element = scope.domElement;\n      if (element) {\n        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      }\n      rotateStart.copy(rotateEnd);\n      scope.update();\n    }\n    function handleMouseMoveDolly(event) {\n      dollyEnd.set(event.clientX, event.clientY);\n      dollyDelta.subVectors(dollyEnd, dollyStart);\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale());\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale());\n      }\n      dollyStart.copy(dollyEnd);\n      scope.update();\n    }\n    function handleMouseMovePan(event) {\n      panEnd.set(event.clientX, event.clientY);\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n      scope.update();\n    }\n    function handleMouseWheel(event) {\n      updateMouseParameters(event);\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale());\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale());\n      }\n      scope.update();\n    }\n    function handleKeyDown(event) {\n      let needsUpdate = false;\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n      }\n      if (needsUpdate) {\n        event.preventDefault();\n        scope.update();\n      }\n    }\n    function handleTouchStartRotate() {\n      if (pointers.length == 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n        rotateStart.set(x, y);\n      }\n    }\n    function handleTouchStartPan() {\n      if (pointers.length == 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n        panStart.set(x, y);\n      }\n    }\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX;\n      const dy = pointers[0].pageY - pointers[1].pageY;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      dollyStart.set(0, distance);\n    }\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom)\n        handleTouchStartDolly();\n      if (scope.enablePan)\n        handleTouchStartPan();\n    }\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom)\n        handleTouchStartDolly();\n      if (scope.enableRotate)\n        handleTouchStartRotate();\n    }\n    function handleTouchMoveRotate(event) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n        rotateEnd.set(x, y);\n      }\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      const element = scope.domElement;\n      if (element) {\n        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      }\n      rotateStart.copy(rotateEnd);\n    }\n    function handleTouchMovePan(event) {\n      if (pointers.length == 1) {\n        panEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n        panEnd.set(x, y);\n      }\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n    }\n    function handleTouchMoveDolly(event) {\n      const position = getSecondPointerPosition(event);\n      const dx = event.pageX - position.x;\n      const dy = event.pageY - position.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      dollyEnd.set(0, distance);\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n      dollyOut(dollyDelta.y);\n      dollyStart.copy(dollyEnd);\n    }\n    function handleTouchMoveDollyPan(event) {\n      if (scope.enableZoom)\n        handleTouchMoveDolly(event);\n      if (scope.enablePan)\n        handleTouchMovePan(event);\n    }\n    function handleTouchMoveDollyRotate(event) {\n      if (scope.enableZoom)\n        handleTouchMoveDolly(event);\n      if (scope.enableRotate)\n        handleTouchMoveRotate(event);\n    }\n    function onPointerDown(event) {\n      var _a, _b;\n      if (scope.enabled === false)\n        return;\n      if (pointers.length === 0) {\n        (_a = scope.domElement) == null ? void 0 : _a.ownerDocument.addEventListener(\"pointermove\", onPointerMove);\n        (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.addEventListener(\"pointerup\", onPointerUp);\n      }\n      addPointer(event);\n      if (event.pointerType === \"touch\") {\n        onTouchStart(event);\n      } else {\n        onMouseDown(event);\n      }\n    }\n    function onPointerMove(event) {\n      if (scope.enabled === false)\n        return;\n      if (event.pointerType === \"touch\") {\n        onTouchMove(event);\n      } else {\n        onMouseMove(event);\n      }\n    }\n    function onPointerUp(event) {\n      var _a, _b, _c;\n      removePointer(event);\n      if (pointers.length === 0) {\n        (_a = scope.domElement) == null ? void 0 : _a.releasePointerCapture(event.pointerId);\n        (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n        (_c = scope.domElement) == null ? void 0 : _c.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n      }\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n    }\n    function onMouseDown(event) {\n      let mouseAction;\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT;\n          break;\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE;\n          break;\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT;\n          break;\n        default:\n          mouseAction = -1;\n      }\n      switch (mouseAction) {\n        case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY:\n          if (scope.enableZoom === false)\n            return;\n          handleMouseDownDolly(event);\n          state = STATE.DOLLY;\n          break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false)\n              return;\n            handleMouseDownPan(event);\n            state = STATE.PAN;\n          } else {\n            if (scope.enableRotate === false)\n              return;\n            handleMouseDownRotate(event);\n            state = STATE.ROTATE;\n          }\n          break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false)\n              return;\n            handleMouseDownRotate(event);\n            state = STATE.ROTATE;\n          } else {\n            if (scope.enablePan === false)\n              return;\n            handleMouseDownPan(event);\n            state = STATE.PAN;\n          }\n          break;\n        default:\n          state = STATE.NONE;\n      }\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(startEvent);\n      }\n    }\n    function onMouseMove(event) {\n      if (scope.enabled === false)\n        return;\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false)\n            return;\n          handleMouseMoveRotate(event);\n          break;\n        case STATE.DOLLY:\n          if (scope.enableZoom === false)\n            return;\n          handleMouseMoveDolly(event);\n          break;\n        case STATE.PAN:\n          if (scope.enablePan === false)\n            return;\n          handleMouseMovePan(event);\n          break;\n      }\n    }\n    function onMouseWheel(event) {\n      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) {\n        return;\n      }\n      event.preventDefault();\n      scope.dispatchEvent(startEvent);\n      handleMouseWheel(event);\n      scope.dispatchEvent(endEvent);\n    }\n    function onKeyDown(event) {\n      if (scope.enabled === false || scope.enablePan === false)\n        return;\n      handleKeyDown(event);\n    }\n    function onTouchStart(event) {\n      trackPointer(event);\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE:\n              if (scope.enableRotate === false)\n                return;\n              handleTouchStartRotate();\n              state = STATE.TOUCH_ROTATE;\n              break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN:\n              if (scope.enablePan === false)\n                return;\n              handleTouchStartPan();\n              state = STATE.TOUCH_PAN;\n              break;\n            default:\n              state = STATE.NONE;\n          }\n          break;\n        case 2:\n          switch (scope.touches.TWO) {\n            case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false)\n                return;\n              handleTouchStartDollyPan();\n              state = STATE.TOUCH_DOLLY_PAN;\n              break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false)\n                return;\n              handleTouchStartDollyRotate();\n              state = STATE.TOUCH_DOLLY_ROTATE;\n              break;\n            default:\n              state = STATE.NONE;\n          }\n          break;\n        default:\n          state = STATE.NONE;\n      }\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(startEvent);\n      }\n    }\n    function onTouchMove(event) {\n      trackPointer(event);\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false)\n            return;\n          handleTouchMoveRotate(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false)\n            return;\n          handleTouchMovePan(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false)\n            return;\n          handleTouchMoveDollyPan(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false)\n            return;\n          handleTouchMoveDollyRotate(event);\n          scope.update();\n          break;\n        default:\n          state = STATE.NONE;\n      }\n    }\n    function onContextMenu(event) {\n      if (scope.enabled === false)\n        return;\n      event.preventDefault();\n    }\n    function addPointer(event) {\n      pointers.push(event);\n    }\n    function removePointer(event) {\n      delete pointerPositions[event.pointerId];\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1);\n          return;\n        }\n      }\n    }\n    function trackPointer(event) {\n      let position = pointerPositions[event.pointerId];\n      if (position === void 0) {\n        position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        pointerPositions[event.pointerId] = position;\n      }\n      position.set(event.pageX, event.pageY);\n    }\n    function getSecondPointerPosition(event) {\n      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];\n      return pointerPositions[pointer.pointerId];\n    }\n    this.dollyIn = (dollyScale = getZoomScale()) => {\n      dollyIn(dollyScale);\n      scope.update();\n    };\n    this.dollyOut = (dollyScale = getZoomScale()) => {\n      dollyOut(dollyScale);\n      scope.update();\n    };\n    this.getScale = () => {\n      return scale;\n    };\n    this.setScale = (newScale) => {\n      setScale(newScale);\n      scope.update();\n    };\n    this.getZoomScale = () => {\n      return getZoomScale();\n    };\n    if (domElement !== void 0)\n      this.connect(domElement);\n    this.update();\n  }\n}\nclass MapControls extends OrbitControls {\n  constructor(object, domElement) {\n    super(object, domElement);\n    this.screenSpacePanning = false;\n    this.mouseButtons.LEFT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN;\n    this.mouseButtons.RIGHT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE;\n    this.touches.ONE = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN;\n    this.touches.TWO = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE;\n  }\n}\n\n//# sourceMappingURL=OrbitControls.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvY29udHJvbHMvT3JiaXRDb250cm9scy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ2lJO0FBQzFFO0FBQ3ZELGlDQUFpQyxzQ0FBRztBQUNwQyxtQ0FBbUMsd0NBQUs7QUFDeEM7QUFDQTtBQUNBLDRCQUE0QixnRUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQ0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRFQUE0RTtBQUM5RztBQUNBO0FBQ0EsWUFBWSx3Q0FBSztBQUNqQixjQUFjLHdDQUFLO0FBQ25CLGFBQWEsd0NBQUs7QUFDbEIsS0FBSztBQUNMO0FBQ0EscUNBQXFDLEtBQUssd0NBQUssY0FBYyx3Q0FBSyxZQUFZO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3Q0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3Q0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0NBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3Q0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0NBQUs7QUFDbEMsOEJBQThCLHdDQUFLO0FBQ25DLHVCQUF1Qix3Q0FBSztBQUM1Qix1QkFBdUIsd0NBQUs7QUFDNUI7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvY29udHJvbHMvT3JiaXRDb250cm9scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5pbXBvcnQgeyBWZWN0b3IzLCBNT1VTRSwgVE9VQ0gsIFF1YXRlcm5pb24sIFBlcnNwZWN0aXZlQ2FtZXJhLCBPcnRob2dyYXBoaWNDYW1lcmEsIFNwaGVyaWNhbCwgVmVjdG9yMiwgUmF5LCBQbGFuZSB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcIi4vRXZlbnREaXNwYXRjaGVyLmpzXCI7XG5jb25zdCBfcmF5ID0gLyogQF9fUFVSRV9fICovIG5ldyBSYXkoKTtcbmNvbnN0IF9wbGFuZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUGxhbmUoKTtcbmNvbnN0IFRJTFRfTElNSVQgPSBNYXRoLmNvcyg3MCAqIChNYXRoLlBJIC8gMTgwKSk7XG5jb25zdCBtb2R1bG9XcmFwQXJvdW5kID0gKG9mZnNldCwgY2FwYWNpdHkpID0+IChvZmZzZXQgJSBjYXBhY2l0eSArIGNhcGFjaXR5KSAlIGNhcGFjaXR5O1xuY2xhc3MgT3JiaXRDb250cm9scyBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKG9iamVjdCwgZG9tRWxlbWVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9iamVjdFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZG9tRWxlbWVudFwiKTtcbiAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZW5hYmxlZFwiLCB0cnVlKTtcbiAgICAvLyBcInRhcmdldFwiIHNldHMgdGhlIGxvY2F0aW9uIG9mIGZvY3VzLCB3aGVyZSB0aGUgb2JqZWN0IG9yYml0cyBhcm91bmRcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGFyZ2V0XCIsIG5ldyBWZWN0b3IzKCkpO1xuICAgIC8vIEhvdyBmYXIgeW91IGNhbiBkb2xseSBpbiBhbmQgb3V0ICggUGVyc3BlY3RpdmVDYW1lcmEgb25seSApXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1pbkRpc3RhbmNlXCIsIDApO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXhEaXN0YW5jZVwiLCBJbmZpbml0eSk7XG4gICAgLy8gSG93IGZhciB5b3UgY2FuIHpvb20gaW4gYW5kIG91dCAoIE9ydGhvZ3JhcGhpY0NhbWVyYSBvbmx5IClcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWluWm9vbVwiLCAwKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWF4Wm9vbVwiLCBJbmZpbml0eSk7XG4gICAgLy8gSG93IGZhciB5b3UgY2FuIG9yYml0IHZlcnRpY2FsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG4gICAgLy8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1pblBvbGFyQW5nbGVcIiwgMCk7XG4gICAgLy8gcmFkaWFuc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXhQb2xhckFuZ2xlXCIsIE1hdGguUEkpO1xuICAgIC8vIHJhZGlhbnNcbiAgICAvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgaG9yaXpvbnRhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuICAgIC8vIElmIHNldCwgdGhlIGludGVydmFsIFsgbWluLCBtYXggXSBtdXN0IGJlIGEgc3ViLWludGVydmFsIG9mIFsgLSAyIFBJLCAyIFBJIF0sIHdpdGggKCBtYXggLSBtaW4gPCAyIFBJIClcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWluQXppbXV0aEFuZ2xlXCIsIC1JbmZpbml0eSk7XG4gICAgLy8gcmFkaWFuc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXhBemltdXRoQW5nbGVcIiwgSW5maW5pdHkpO1xuICAgIC8vIHJhZGlhbnNcbiAgICAvLyBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgZGFtcGluZyAoaW5lcnRpYSlcbiAgICAvLyBJZiBkYW1waW5nIGlzIGVuYWJsZWQsIHlvdSBtdXN0IGNhbGwgY29udHJvbHMudXBkYXRlKCkgaW4geW91ciBhbmltYXRpb24gbG9vcFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbmFibGVEYW1waW5nXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGFtcGluZ0ZhY3RvclwiLCAwLjA1KTtcbiAgICAvLyBUaGlzIG9wdGlvbiBhY3R1YWxseSBlbmFibGVzIGRvbGx5aW5nIGluIGFuZCBvdXQ7IGxlZnQgYXMgXCJ6b29tXCIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHpvb21pbmdcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZW5hYmxlWm9vbVwiLCB0cnVlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiem9vbVNwZWVkXCIsIDEpO1xuICAgIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHJvdGF0aW5nXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVuYWJsZVJvdGF0ZVwiLCB0cnVlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicm90YXRlU3BlZWRcIiwgMSk7XG4gICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcGFubmluZ1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbmFibGVQYW5cIiwgdHJ1ZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBhblNwZWVkXCIsIDEpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzY3JlZW5TcGFjZVBhbm5pbmdcIiwgdHJ1ZSk7XG4gICAgLy8gaWYgZmFsc2UsIHBhbiBvcnRob2dvbmFsIHRvIHdvcmxkLXNwYWNlIGRpcmVjdGlvbiBjYW1lcmEudXBcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2V5UGFuU3BlZWRcIiwgNyk7XG4gICAgLy8gcGl4ZWxzIG1vdmVkIHBlciBhcnJvdyBrZXkgcHVzaFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ6b29tVG9DdXJzb3JcIiwgZmFsc2UpO1xuICAgIC8vIFNldCB0byB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgcm90YXRlIGFyb3VuZCB0aGUgdGFyZ2V0XG4gICAgLy8gSWYgYXV0by1yb3RhdGUgaXMgZW5hYmxlZCwgeW91IG11c3QgY2FsbCBjb250cm9scy51cGRhdGUoKSBpbiB5b3VyIGFuaW1hdGlvbiBsb29wXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImF1dG9Sb3RhdGVcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhdXRvUm90YXRlU3BlZWRcIiwgMik7XG4gICAgLy8gMzAgc2Vjb25kcyBwZXIgb3JiaXQgd2hlbiBmcHMgaXMgNjBcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmV2ZXJzZU9yYml0XCIsIGZhbHNlKTtcbiAgICAvLyB0cnVlIGlmIHlvdSB3YW50IHRvIHJldmVyc2UgdGhlIG9yYml0IHRvIG1vdXNlIGRyYWcgZnJvbSBsZWZ0IHRvIHJpZ2h0ID0gb3JiaXRzIGxlZnRcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmV2ZXJzZUhvcml6b250YWxPcmJpdFwiLCBmYWxzZSk7XG4gICAgLy8gdHJ1ZSBpZiB5b3Ugd2FudCB0byByZXZlcnNlIHRoZSBob3Jpem9udGFsIG9yYml0IGRpcmVjdGlvblxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXZlcnNlVmVydGljYWxPcmJpdFwiLCBmYWxzZSk7XG4gICAgLy8gdHJ1ZSBpZiB5b3Ugd2FudCB0byByZXZlcnNlIHRoZSB2ZXJ0aWNhbCBvcmJpdCBkaXJlY3Rpb25cbiAgICAvLyBUaGUgZm91ciBhcnJvdyBrZXlzXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtleXNcIiwgeyBMRUZUOiBcIkFycm93TGVmdFwiLCBVUDogXCJBcnJvd1VwXCIsIFJJR0hUOiBcIkFycm93UmlnaHRcIiwgQk9UVE9NOiBcIkFycm93RG93blwiIH0pO1xuICAgIC8vIE1vdXNlIGJ1dHRvbnNcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibW91c2VCdXR0b25zXCIsIHtcbiAgICAgIExFRlQ6IE1PVVNFLlJPVEFURSxcbiAgICAgIE1JRERMRTogTU9VU0UuRE9MTFksXG4gICAgICBSSUdIVDogTU9VU0UuUEFOXG4gICAgfSk7XG4gICAgLy8gVG91Y2ggZmluZ2Vyc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0b3VjaGVzXCIsIHsgT05FOiBUT1VDSC5ST1RBVEUsIFRXTzogVE9VQ0guRE9MTFlfUEFOIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0YXJnZXQwXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwb3NpdGlvbjBcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInpvb20wXCIpO1xuICAgIC8vIHRoZSB0YXJnZXQgRE9NIGVsZW1lbnQgZm9yIGtleSBldmVudHNcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2RvbUVsZW1lbnRLZXlFdmVudHNcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldFBvbGFyQW5nbGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldEF6aW11dGhhbEFuZ2xlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRQb2xhckFuZ2xlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRBemltdXRoYWxBbmdsZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0RGlzdGFuY2VcIik7XG4gICAgLy8gTm90IHVzZWQgaW4gbW9zdCBzY2VuYXJpb3MsIGhvd2V2ZXIgdGhleSBjYW4gYmUgdXNlZnVsIGZvciBzcGVjaWZpYyB1c2UgY2FzZXNcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0Wm9vbVNjYWxlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsaXN0ZW5Ub0tleUV2ZW50c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RvcExpc3RlblRvS2V5RXZlbnRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzYXZlU3RhdGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlc2V0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1cGRhdGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbm5lY3RcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRpc3Bvc2VcIik7XG4gICAgLy8gRG9sbHkgaW4gcHJvZ3JhbW1hdGljYWxseVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkb2xseUluXCIpO1xuICAgIC8vIERvbGx5IG91dCBwcm9ncmFtbWF0aWNhbGx5XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRvbGx5T3V0XCIpO1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBzY2FsZVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRTY2FsZVwiKTtcbiAgICAvLyBTZXQgdGhlIGN1cnJlbnQgc2NhbGUgKHRoZXNlIGFyZSBub3QgdXNlZCBpbiBtb3N0IHNjZW5hcmlvcywgaG93ZXZlciB0aGV5IGNhbiBiZSB1c2VmdWwgZm9yIHNwZWNpZmljIHVzZSBjYXNlcylcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2V0U2NhbGVcIik7XG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcbiAgICB0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuICAgIHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnpvb20wID0gdGhpcy5vYmplY3Quem9vbTtcbiAgICB0aGlzLmdldFBvbGFyQW5nbGUgPSAoKSA9PiBzcGhlcmljYWwucGhpO1xuICAgIHRoaXMuZ2V0QXppbXV0aGFsQW5nbGUgPSAoKSA9PiBzcGhlcmljYWwudGhldGE7XG4gICAgdGhpcy5zZXRQb2xhckFuZ2xlID0gKHZhbHVlKSA9PiB7XG4gICAgICBsZXQgcGhpID0gbW9kdWxvV3JhcEFyb3VuZCh2YWx1ZSwgMiAqIE1hdGguUEkpO1xuICAgICAgbGV0IGN1cnJlbnRQaGkgPSBzcGhlcmljYWwucGhpO1xuICAgICAgaWYgKGN1cnJlbnRQaGkgPCAwKVxuICAgICAgICBjdXJyZW50UGhpICs9IDIgKiBNYXRoLlBJO1xuICAgICAgaWYgKHBoaSA8IDApXG4gICAgICAgIHBoaSArPSAyICogTWF0aC5QSTtcbiAgICAgIGxldCBwaGlEaXN0ID0gTWF0aC5hYnMocGhpIC0gY3VycmVudFBoaSk7XG4gICAgICBpZiAoMiAqIE1hdGguUEkgLSBwaGlEaXN0IDwgcGhpRGlzdCkge1xuICAgICAgICBpZiAocGhpIDwgY3VycmVudFBoaSkge1xuICAgICAgICAgIHBoaSArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UGhpICs9IDIgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcGhlcmljYWxEZWx0YS5waGkgPSBwaGkgLSBjdXJyZW50UGhpO1xuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLnNldEF6aW11dGhhbEFuZ2xlID0gKHZhbHVlKSA9PiB7XG4gICAgICBsZXQgdGhldGEgPSBtb2R1bG9XcmFwQXJvdW5kKHZhbHVlLCAyICogTWF0aC5QSSk7XG4gICAgICBsZXQgY3VycmVudFRoZXRhID0gc3BoZXJpY2FsLnRoZXRhO1xuICAgICAgaWYgKGN1cnJlbnRUaGV0YSA8IDApXG4gICAgICAgIGN1cnJlbnRUaGV0YSArPSAyICogTWF0aC5QSTtcbiAgICAgIGlmICh0aGV0YSA8IDApXG4gICAgICAgIHRoZXRhICs9IDIgKiBNYXRoLlBJO1xuICAgICAgbGV0IHRoZXRhRGlzdCA9IE1hdGguYWJzKHRoZXRhIC0gY3VycmVudFRoZXRhKTtcbiAgICAgIGlmICgyICogTWF0aC5QSSAtIHRoZXRhRGlzdCA8IHRoZXRhRGlzdCkge1xuICAgICAgICBpZiAodGhldGEgPCBjdXJyZW50VGhldGEpIHtcbiAgICAgICAgICB0aGV0YSArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50VGhldGEgKz0gMiAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNwaGVyaWNhbERlbHRhLnRoZXRhID0gdGhldGEgLSBjdXJyZW50VGhldGE7XG4gICAgICBzY29wZS51cGRhdGUoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0RGlzdGFuY2UgPSAoKSA9PiBzY29wZS5vYmplY3QucG9zaXRpb24uZGlzdGFuY2VUbyhzY29wZS50YXJnZXQpO1xuICAgIHRoaXMubGlzdGVuVG9LZXlFdmVudHMgPSAoZG9tRWxlbWVudDIpID0+IHtcbiAgICAgIGRvbUVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICB0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzID0gZG9tRWxlbWVudDI7XG4gICAgfTtcbiAgICB0aGlzLnN0b3BMaXN0ZW5Ub0tleUV2ZW50cyA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2RvbUVsZW1lbnRLZXlFdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgIHRoaXMuX2RvbUVsZW1lbnRLZXlFdmVudHMgPSBudWxsO1xuICAgIH07XG4gICAgdGhpcy5zYXZlU3RhdGUgPSAoKSA9PiB7XG4gICAgICBzY29wZS50YXJnZXQwLmNvcHkoc2NvcGUudGFyZ2V0KTtcbiAgICAgIHNjb3BlLnBvc2l0aW9uMC5jb3B5KHNjb3BlLm9iamVjdC5wb3NpdGlvbik7XG4gICAgICBzY29wZS56b29tMCA9IHNjb3BlLm9iamVjdC56b29tO1xuICAgIH07XG4gICAgdGhpcy5yZXNldCA9ICgpID0+IHtcbiAgICAgIHNjb3BlLnRhcmdldC5jb3B5KHNjb3BlLnRhcmdldDApO1xuICAgICAgc2NvcGUub2JqZWN0LnBvc2l0aW9uLmNvcHkoc2NvcGUucG9zaXRpb24wKTtcbiAgICAgIHNjb3BlLm9iamVjdC56b29tID0gc2NvcGUuem9vbTA7XG4gICAgICBzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChjaGFuZ2VFdmVudCk7XG4gICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBjb25zdCB1cCA9IG5ldyBWZWN0b3IzKDAsIDEsIDApO1xuICAgICAgY29uc3QgcXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKG9iamVjdC51cCwgdXApO1xuICAgICAgY29uc3QgcXVhdEludmVyc2UgPSBxdWF0LmNsb25lKCkuaW52ZXJ0KCk7XG4gICAgICBjb25zdCBsYXN0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgY29uc3QgbGFzdFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgICAgY29uc3QgdHdvUEkgPSAyICogTWF0aC5QSTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuICAgICAgICBxdWF0LnNldEZyb21Vbml0VmVjdG9ycyhvYmplY3QudXAsIHVwKTtcbiAgICAgICAgcXVhdEludmVyc2UuY29weShxdWF0KS5pbnZlcnQoKTtcbiAgICAgICAgb2Zmc2V0LmNvcHkocG9zaXRpb24pLnN1YihzY29wZS50YXJnZXQpO1xuICAgICAgICBvZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKHF1YXQpO1xuICAgICAgICBzcGhlcmljYWwuc2V0RnJvbVZlY3RvcjMob2Zmc2V0KTtcbiAgICAgICAgaWYgKHNjb3BlLmF1dG9Sb3RhdGUgJiYgc3RhdGUgPT09IFNUQVRFLk5PTkUpIHtcbiAgICAgICAgICByb3RhdGVMZWZ0KGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY29wZS5lbmFibGVEYW1waW5nKSB7XG4gICAgICAgICAgc3BoZXJpY2FsLnRoZXRhICs9IHNwaGVyaWNhbERlbHRhLnRoZXRhICogc2NvcGUuZGFtcGluZ0ZhY3RvcjtcbiAgICAgICAgICBzcGhlcmljYWwucGhpICs9IHNwaGVyaWNhbERlbHRhLnBoaSAqIHNjb3BlLmRhbXBpbmdGYWN0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BoZXJpY2FsLnRoZXRhICs9IHNwaGVyaWNhbERlbHRhLnRoZXRhO1xuICAgICAgICAgIHNwaGVyaWNhbC5waGkgKz0gc3BoZXJpY2FsRGVsdGEucGhpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtaW4gPSBzY29wZS5taW5BemltdXRoQW5nbGU7XG4gICAgICAgIGxldCBtYXggPSBzY29wZS5tYXhBemltdXRoQW5nbGU7XG4gICAgICAgIGlmIChpc0Zpbml0ZShtaW4pICYmIGlzRmluaXRlKG1heCkpIHtcbiAgICAgICAgICBpZiAobWluIDwgLU1hdGguUEkpXG4gICAgICAgICAgICBtaW4gKz0gdHdvUEk7XG4gICAgICAgICAgZWxzZSBpZiAobWluID4gTWF0aC5QSSlcbiAgICAgICAgICAgIG1pbiAtPSB0d29QSTtcbiAgICAgICAgICBpZiAobWF4IDwgLU1hdGguUEkpXG4gICAgICAgICAgICBtYXggKz0gdHdvUEk7XG4gICAgICAgICAgZWxzZSBpZiAobWF4ID4gTWF0aC5QSSlcbiAgICAgICAgICAgIG1heCAtPSB0d29QSTtcbiAgICAgICAgICBpZiAobWluIDw9IG1heCkge1xuICAgICAgICAgICAgc3BoZXJpY2FsLnRoZXRhID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHNwaGVyaWNhbC50aGV0YSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGhlcmljYWwudGhldGEgPSBzcGhlcmljYWwudGhldGEgPiAobWluICsgbWF4KSAvIDIgPyBNYXRoLm1heChtaW4sIHNwaGVyaWNhbC50aGV0YSkgOiBNYXRoLm1pbihtYXgsIHNwaGVyaWNhbC50aGV0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNwaGVyaWNhbC5waGkgPSBNYXRoLm1heChzY29wZS5taW5Qb2xhckFuZ2xlLCBNYXRoLm1pbihzY29wZS5tYXhQb2xhckFuZ2xlLCBzcGhlcmljYWwucGhpKSk7XG4gICAgICAgIHNwaGVyaWNhbC5tYWtlU2FmZSgpO1xuICAgICAgICBpZiAoc2NvcGUuZW5hYmxlRGFtcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNjb3BlLnRhcmdldC5hZGRTY2FsZWRWZWN0b3IocGFuT2Zmc2V0LCBzY29wZS5kYW1waW5nRmFjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY29wZS50YXJnZXQuYWRkKHBhbk9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3BlLnpvb21Ub0N1cnNvciAmJiBwZXJmb3JtQ3Vyc29yWm9vbSB8fCBzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEpIHtcbiAgICAgICAgICBzcGhlcmljYWwucmFkaXVzID0gY2xhbXBEaXN0YW5jZShzcGhlcmljYWwucmFkaXVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGhlcmljYWwucmFkaXVzID0gY2xhbXBEaXN0YW5jZShzcGhlcmljYWwucmFkaXVzICogc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldC5zZXRGcm9tU3BoZXJpY2FsKHNwaGVyaWNhbCk7XG4gICAgICAgIG9mZnNldC5hcHBseVF1YXRlcm5pb24ocXVhdEludmVyc2UpO1xuICAgICAgICBwb3NpdGlvbi5jb3B5KHNjb3BlLnRhcmdldCkuYWRkKG9mZnNldCk7XG4gICAgICAgIGlmICghc2NvcGUub2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUpXG4gICAgICAgICAgc2NvcGUub2JqZWN0LnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICBzY29wZS5vYmplY3QubG9va0F0KHNjb3BlLnRhcmdldCk7XG4gICAgICAgIGlmIChzY29wZS5lbmFibGVEYW1waW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgc3BoZXJpY2FsRGVsdGEudGhldGEgKj0gMSAtIHNjb3BlLmRhbXBpbmdGYWN0b3I7XG4gICAgICAgICAgc3BoZXJpY2FsRGVsdGEucGhpICo9IDEgLSBzY29wZS5kYW1waW5nRmFjdG9yO1xuICAgICAgICAgIHBhbk9mZnNldC5tdWx0aXBseVNjYWxhcigxIC0gc2NvcGUuZGFtcGluZ0ZhY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BoZXJpY2FsRGVsdGEuc2V0KDAsIDAsIDApO1xuICAgICAgICAgIHBhbk9mZnNldC5zZXQoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHpvb21DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChzY29wZS56b29tVG9DdXJzb3IgJiYgcGVyZm9ybUN1cnNvclpvb20pIHtcbiAgICAgICAgICBsZXQgbmV3UmFkaXVzID0gbnVsbDtcbiAgICAgICAgICBpZiAoc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgUGVyc3BlY3RpdmVDYW1lcmEgJiYgc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZSYWRpdXMgPSBvZmZzZXQubGVuZ3RoKCk7XG4gICAgICAgICAgICBuZXdSYWRpdXMgPSBjbGFtcERpc3RhbmNlKHByZXZSYWRpdXMgKiBzY2FsZSk7XG4gICAgICAgICAgICBjb25zdCByYWRpdXNEZWx0YSA9IHByZXZSYWRpdXMgLSBuZXdSYWRpdXM7XG4gICAgICAgICAgICBzY29wZS5vYmplY3QucG9zaXRpb24uYWRkU2NhbGVkVmVjdG9yKGRvbGx5RGlyZWN0aW9uLCByYWRpdXNEZWx0YSk7XG4gICAgICAgICAgICBzY29wZS5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgICAgICAgICAgY29uc3QgbW91c2VCZWZvcmUgPSBuZXcgVmVjdG9yMyhtb3VzZS54LCBtb3VzZS55LCAwKTtcbiAgICAgICAgICAgIG1vdXNlQmVmb3JlLnVucHJvamVjdChzY29wZS5vYmplY3QpO1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heChzY29wZS5taW5ab29tLCBNYXRoLm1pbihzY29wZS5tYXhab29tLCBzY29wZS5vYmplY3Quem9vbSAvIHNjYWxlKSk7XG4gICAgICAgICAgICBzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAgICAgem9vbUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgbW91c2VBZnRlciA9IG5ldyBWZWN0b3IzKG1vdXNlLngsIG1vdXNlLnksIDApO1xuICAgICAgICAgICAgbW91c2VBZnRlci51bnByb2plY3Qoc2NvcGUub2JqZWN0KTtcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC5wb3NpdGlvbi5zdWIobW91c2VBZnRlcikuYWRkKG1vdXNlQmVmb3JlKTtcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgICAgICAgbmV3UmFkaXVzID0gb2Zmc2V0Lmxlbmd0aCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSB6b29tIHRvIGN1cnNvciBkaXNhYmxlZC5cIik7XG4gICAgICAgICAgICBzY29wZS56b29tVG9DdXJzb3IgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5ld1JhZGl1cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNjb3BlLnNjcmVlblNwYWNlUGFubmluZykge1xuICAgICAgICAgICAgICBzY29wZS50YXJnZXQuc2V0KDAsIDAsIC0xKS50cmFuc2Zvcm1EaXJlY3Rpb24oc2NvcGUub2JqZWN0Lm1hdHJpeCkubXVsdGlwbHlTY2FsYXIobmV3UmFkaXVzKS5hZGQoc2NvcGUub2JqZWN0LnBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9yYXkub3JpZ2luLmNvcHkoc2NvcGUub2JqZWN0LnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgX3JheS5kaXJlY3Rpb24uc2V0KDAsIDAsIC0xKS50cmFuc2Zvcm1EaXJlY3Rpb24oc2NvcGUub2JqZWN0Lm1hdHJpeCk7XG4gICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzY29wZS5vYmplY3QudXAuZG90KF9yYXkuZGlyZWN0aW9uKSkgPCBUSUxUX0xJTUlUKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lmxvb2tBdChzY29wZS50YXJnZXQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wbGFuZS5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludChzY29wZS5vYmplY3QudXAsIHNjb3BlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgX3JheS5pbnRlcnNlY3RQbGFuZShfcGxhbmUsIHNjb3BlLnRhcmdldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgT3J0aG9ncmFwaGljQ2FtZXJhICYmIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgICAgICAgIHpvb21DaGFuZ2VkID0gc2NhbGUgIT09IDE7XG4gICAgICAgICAgaWYgKHpvb21DaGFuZ2VkKSB7XG4gICAgICAgICAgICBzY29wZS5vYmplY3Quem9vbSA9IE1hdGgubWF4KHNjb3BlLm1pblpvb20sIE1hdGgubWluKHNjb3BlLm1heFpvb20sIHNjb3BlLm9iamVjdC56b29tIC8gc2NhbGUpKTtcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjYWxlID0gMTtcbiAgICAgICAgcGVyZm9ybUN1cnNvclpvb20gPSBmYWxzZTtcbiAgICAgICAgaWYgKHpvb21DaGFuZ2VkIHx8IGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZChzY29wZS5vYmplY3QucG9zaXRpb24pID4gRVBTIHx8IDggKiAoMSAtIGxhc3RRdWF0ZXJuaW9uLmRvdChzY29wZS5vYmplY3QucXVhdGVybmlvbikpID4gRVBTKSB7XG4gICAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChjaGFuZ2VFdmVudCk7XG4gICAgICAgICAgbGFzdFBvc2l0aW9uLmNvcHkoc2NvcGUub2JqZWN0LnBvc2l0aW9uKTtcbiAgICAgICAgICBsYXN0UXVhdGVybmlvbi5jb3B5KHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uKTtcbiAgICAgICAgICB6b29tQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICB0aGlzLmNvbm5lY3QgPSAoZG9tRWxlbWVudDIpID0+IHtcbiAgICAgIHNjb3BlLmRvbUVsZW1lbnQgPSBkb21FbGVtZW50MjtcbiAgICAgIHNjb3BlLmRvbUVsZW1lbnQuc3R5bGUudG91Y2hBY3Rpb24gPSBcIm5vbmVcIjtcbiAgICAgIHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnUpO1xuICAgICAgc2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgb25Qb2ludGVyRG93bik7XG4gICAgICBzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlclVwKTtcbiAgICAgIHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIG9uTW91c2VXaGVlbCk7XG4gICAgfTtcbiAgICB0aGlzLmRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgIGlmIChzY29wZS5kb21FbGVtZW50KSB7XG4gICAgICAgIHNjb3BlLmRvbUVsZW1lbnQuc3R5bGUudG91Y2hBY3Rpb24gPSBcImF1dG9cIjtcbiAgICAgIH1cbiAgICAgIChfYSA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgb25Db250ZXh0TWVudSk7XG4gICAgICAoX2IgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIG9uUG9pbnRlckRvd24pO1xuICAgICAgKF9jID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlclVwKTtcbiAgICAgIChfZCA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgb25Nb3VzZVdoZWVsKTtcbiAgICAgIChfZSA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZS5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgIChfZiA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZi5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgb25Qb2ludGVyVXApO1xuICAgICAgaWYgKHNjb3BlLl9kb21FbGVtZW50S2V5RXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgIHNjb3BlLl9kb21FbGVtZW50S2V5RXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlRXZlbnQgPSB7IHR5cGU6IFwiY2hhbmdlXCIgfTtcbiAgICBjb25zdCBzdGFydEV2ZW50ID0geyB0eXBlOiBcInN0YXJ0XCIgfTtcbiAgICBjb25zdCBlbmRFdmVudCA9IHsgdHlwZTogXCJlbmRcIiB9O1xuICAgIGNvbnN0IFNUQVRFID0ge1xuICAgICAgTk9ORTogLTEsXG4gICAgICBST1RBVEU6IDAsXG4gICAgICBET0xMWTogMSxcbiAgICAgIFBBTjogMixcbiAgICAgIFRPVUNIX1JPVEFURTogMyxcbiAgICAgIFRPVUNIX1BBTjogNCxcbiAgICAgIFRPVUNIX0RPTExZX1BBTjogNSxcbiAgICAgIFRPVUNIX0RPTExZX1JPVEFURTogNlxuICAgIH07XG4gICAgbGV0IHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICBjb25zdCBFUFMgPSAxZS02O1xuICAgIGNvbnN0IHNwaGVyaWNhbCA9IG5ldyBTcGhlcmljYWwoKTtcbiAgICBjb25zdCBzcGhlcmljYWxEZWx0YSA9IG5ldyBTcGhlcmljYWwoKTtcbiAgICBsZXQgc2NhbGUgPSAxO1xuICAgIGNvbnN0IHBhbk9mZnNldCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY29uc3Qgcm90YXRlU3RhcnQgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IHJvdGF0ZUVuZCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3Qgcm90YXRlRGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IHBhblN0YXJ0ID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCBwYW5FbmQgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IHBhbkRlbHRhID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCBkb2xseVN0YXJ0ID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCBkb2xseUVuZCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgZG9sbHlEZWx0YSA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgZG9sbHlEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIGNvbnN0IG1vdXNlID0gbmV3IFZlY3RvcjIoKTtcbiAgICBsZXQgcGVyZm9ybUN1cnNvclpvb20gPSBmYWxzZTtcbiAgICBjb25zdCBwb2ludGVycyA9IFtdO1xuICAgIGNvbnN0IHBvaW50ZXJQb3NpdGlvbnMgPSB7fTtcbiAgICBmdW5jdGlvbiBnZXRBdXRvUm90YXRpb25BbmdsZSgpIHtcbiAgICAgIHJldHVybiAyICogTWF0aC5QSSAvIDYwIC8gNjAgKiBzY29wZS5hdXRvUm90YXRlU3BlZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFpvb21TY2FsZSgpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygwLjk1LCBzY29wZS56b29tU3BlZWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByb3RhdGVMZWZ0KGFuZ2xlKSB7XG4gICAgICBpZiAoc2NvcGUucmV2ZXJzZU9yYml0IHx8IHNjb3BlLnJldmVyc2VIb3Jpem9udGFsT3JiaXQpIHtcbiAgICAgICAgc3BoZXJpY2FsRGVsdGEudGhldGEgKz0gYW5nbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGhlcmljYWxEZWx0YS50aGV0YSAtPSBhbmdsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcm90YXRlVXAoYW5nbGUpIHtcbiAgICAgIGlmIChzY29wZS5yZXZlcnNlT3JiaXQgfHwgc2NvcGUucmV2ZXJzZVZlcnRpY2FsT3JiaXQpIHtcbiAgICAgICAgc3BoZXJpY2FsRGVsdGEucGhpICs9IGFuZ2xlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BoZXJpY2FsRGVsdGEucGhpIC09IGFuZ2xlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYW5MZWZ0ID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IHYgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhbkxlZnQyKGRpc3RhbmNlLCBvYmplY3RNYXRyaXgpIHtcbiAgICAgICAgdi5zZXRGcm9tTWF0cml4Q29sdW1uKG9iamVjdE1hdHJpeCwgMCk7XG4gICAgICAgIHYubXVsdGlwbHlTY2FsYXIoLWRpc3RhbmNlKTtcbiAgICAgICAgcGFuT2Zmc2V0LmFkZCh2KTtcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICBjb25zdCBwYW5VcCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCB2ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBwYW5VcDIoZGlzdGFuY2UsIG9iamVjdE1hdHJpeCkge1xuICAgICAgICBpZiAoc2NvcGUuc2NyZWVuU3BhY2VQYW5uaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgdi5zZXRGcm9tTWF0cml4Q29sdW1uKG9iamVjdE1hdHJpeCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdi5zZXRGcm9tTWF0cml4Q29sdW1uKG9iamVjdE1hdHJpeCwgMCk7XG4gICAgICAgICAgdi5jcm9zc1ZlY3RvcnMoc2NvcGUub2JqZWN0LnVwLCB2KTtcbiAgICAgICAgfVxuICAgICAgICB2Lm11bHRpcGx5U2NhbGFyKGRpc3RhbmNlKTtcbiAgICAgICAgcGFuT2Zmc2V0LmFkZCh2KTtcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICBjb25zdCBwYW4gPSAoKCkgPT4ge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBwYW4yKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50O1xuICAgICAgICBpZiAoZWxlbWVudCAmJiBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSAmJiBzY29wZS5vYmplY3QuaXNQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuICAgICAgICAgIG9mZnNldC5jb3B5KHBvc2l0aW9uKS5zdWIoc2NvcGUudGFyZ2V0KTtcbiAgICAgICAgICBsZXQgdGFyZ2V0RGlzdGFuY2UgPSBvZmZzZXQubGVuZ3RoKCk7XG4gICAgICAgICAgdGFyZ2V0RGlzdGFuY2UgKj0gTWF0aC50YW4oc2NvcGUub2JqZWN0LmZvdiAvIDIgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgICBwYW5MZWZ0KDIgKiBkZWx0YVggKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4KTtcbiAgICAgICAgICBwYW5VcCgyICogZGVsdGFZICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAmJiBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBPcnRob2dyYXBoaWNDYW1lcmEgJiYgc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgICAgICAgcGFuTGVmdChcbiAgICAgICAgICAgIGRlbHRhWCAqIChzY29wZS5vYmplY3QucmlnaHQgLSBzY29wZS5vYmplY3QubGVmdCkgLyBzY29wZS5vYmplY3Quem9vbSAvIGVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBzY29wZS5vYmplY3QubWF0cml4XG4gICAgICAgICAgKTtcbiAgICAgICAgICBwYW5VcChcbiAgICAgICAgICAgIGRlbHRhWSAqIChzY29wZS5vYmplY3QudG9wIC0gc2NvcGUub2JqZWN0LmJvdHRvbSkgLyBzY29wZS5vYmplY3Quem9vbSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgc2NvcGUub2JqZWN0Lm1hdHJpeFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gcGFuIGRpc2FibGVkLlwiKTtcbiAgICAgICAgICBzY29wZS5lbmFibGVQYW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGZ1bmN0aW9uIHNldFNjYWxlKG5ld1NjYWxlKSB7XG4gICAgICBpZiAoc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgUGVyc3BlY3RpdmVDYW1lcmEgJiYgc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgfHwgc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgT3J0aG9ncmFwaGljQ2FtZXJhICYmIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgICAgICBzY2FsZSA9IG5ld1NjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC5cIik7XG4gICAgICAgIHNjb3BlLmVuYWJsZVpvb20gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZG9sbHlPdXQoZG9sbHlTY2FsZSkge1xuICAgICAgc2V0U2NhbGUoc2NhbGUgLyBkb2xseVNjYWxlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZG9sbHlJbihkb2xseVNjYWxlKSB7XG4gICAgICBzZXRTY2FsZShzY2FsZSAqIGRvbGx5U2NhbGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVNb3VzZVBhcmFtZXRlcnMoZXZlbnQpIHtcbiAgICAgIGlmICghc2NvcGUuem9vbVRvQ3Vyc29yIHx8ICFzY29wZS5kb21FbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBlcmZvcm1DdXJzb3Jab29tID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHJlY3QgPSBzY29wZS5kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICBjb25zdCB5ID0gZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgY29uc3QgdyA9IHJlY3Qud2lkdGg7XG4gICAgICBjb25zdCBoID0gcmVjdC5oZWlnaHQ7XG4gICAgICBtb3VzZS54ID0geCAvIHcgKiAyIC0gMTtcbiAgICAgIG1vdXNlLnkgPSAtKHkgLyBoKSAqIDIgKyAxO1xuICAgICAgZG9sbHlEaXJlY3Rpb24uc2V0KG1vdXNlLngsIG1vdXNlLnksIDEpLnVucHJvamVjdChzY29wZS5vYmplY3QpLnN1YihzY29wZS5vYmplY3QucG9zaXRpb24pLm5vcm1hbGl6ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFtcERpc3RhbmNlKGRpc3QpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChzY29wZS5taW5EaXN0YW5jZSwgTWF0aC5taW4oc2NvcGUubWF4RGlzdGFuY2UsIGRpc3QpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duUm90YXRlKGV2ZW50KSB7XG4gICAgICByb3RhdGVTdGFydC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bkRvbGx5KGV2ZW50KSB7XG4gICAgICB1cGRhdGVNb3VzZVBhcmFtZXRlcnMoZXZlbnQpO1xuICAgICAgZG9sbHlTdGFydC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93blBhbihldmVudCkge1xuICAgICAgcGFuU3RhcnQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVSb3RhdGUoZXZlbnQpIHtcbiAgICAgIHJvdGF0ZUVuZC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICByb3RhdGVEZWx0YS5zdWJWZWN0b3JzKHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQpLm11bHRpcGx5U2NhbGFyKHNjb3BlLnJvdGF0ZVNwZWVkKTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50O1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgcm90YXRlTGVmdCgyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICAgIHJvdGF0ZVVwKDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHJvdGF0ZVN0YXJ0LmNvcHkocm90YXRlRW5kKTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVEb2xseShldmVudCkge1xuICAgICAgZG9sbHlFbmQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgZG9sbHlEZWx0YS5zdWJWZWN0b3JzKGRvbGx5RW5kLCBkb2xseVN0YXJ0KTtcbiAgICAgIGlmIChkb2xseURlbHRhLnkgPiAwKSB7XG4gICAgICAgIGRvbGx5T3V0KGdldFpvb21TY2FsZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9sbHlEZWx0YS55IDwgMCkge1xuICAgICAgICBkb2xseUluKGdldFpvb21TY2FsZSgpKTtcbiAgICAgIH1cbiAgICAgIGRvbGx5U3RhcnQuY29weShkb2xseUVuZCk7XG4gICAgICBzY29wZS51cGRhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlUGFuKGV2ZW50KSB7XG4gICAgICBwYW5FbmQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgcGFuRGVsdGEuc3ViVmVjdG9ycyhwYW5FbmQsIHBhblN0YXJ0KS5tdWx0aXBseVNjYWxhcihzY29wZS5wYW5TcGVlZCk7XG4gICAgICBwYW4ocGFuRGVsdGEueCwgcGFuRGVsdGEueSk7XG4gICAgICBwYW5TdGFydC5jb3B5KHBhbkVuZCk7XG4gICAgICBzY29wZS51cGRhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VXaGVlbChldmVudCkge1xuICAgICAgdXBkYXRlTW91c2VQYXJhbWV0ZXJzKGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5kZWx0YVkgPCAwKSB7XG4gICAgICAgIGRvbGx5SW4oZ2V0Wm9vbVNjYWxlKCkpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5kZWx0YVkgPiAwKSB7XG4gICAgICAgIGRvbGx5T3V0KGdldFpvb21TY2FsZSgpKTtcbiAgICAgIH1cbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICBsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHN3aXRjaCAoZXZlbnQuY29kZSkge1xuICAgICAgICBjYXNlIHNjb3BlLmtleXMuVVA6XG4gICAgICAgICAgcGFuKDAsIHNjb3BlLmtleVBhblNwZWVkKTtcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugc2NvcGUua2V5cy5CT1RUT006XG4gICAgICAgICAgcGFuKDAsIC1zY29wZS5rZXlQYW5TcGVlZCk7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHNjb3BlLmtleXMuTEVGVDpcbiAgICAgICAgICBwYW4oc2NvcGUua2V5UGFuU3BlZWQsIDApO1xuICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBzY29wZS5rZXlzLlJJR0hUOlxuICAgICAgICAgIHBhbigtc2NvcGUua2V5UGFuU3BlZWQsIDApO1xuICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydFJvdGF0ZSgpIHtcbiAgICAgIGlmIChwb2ludGVycy5sZW5ndGggPT0gMSkge1xuICAgICAgICByb3RhdGVTdGFydC5zZXQocG9pbnRlcnNbMF0ucGFnZVgsIHBvaW50ZXJzWzBdLnBhZ2VZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHggPSAwLjUgKiAocG9pbnRlcnNbMF0ucGFnZVggKyBwb2ludGVyc1sxXS5wYWdlWCk7XG4gICAgICAgIGNvbnN0IHkgPSAwLjUgKiAocG9pbnRlcnNbMF0ucGFnZVkgKyBwb2ludGVyc1sxXS5wYWdlWSk7XG4gICAgICAgIHJvdGF0ZVN0YXJ0LnNldCh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydFBhbigpIHtcbiAgICAgIGlmIChwb2ludGVycy5sZW5ndGggPT0gMSkge1xuICAgICAgICBwYW5TdGFydC5zZXQocG9pbnRlcnNbMF0ucGFnZVgsIHBvaW50ZXJzWzBdLnBhZ2VZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHggPSAwLjUgKiAocG9pbnRlcnNbMF0ucGFnZVggKyBwb2ludGVyc1sxXS5wYWdlWCk7XG4gICAgICAgIGNvbnN0IHkgPSAwLjUgKiAocG9pbnRlcnNbMF0ucGFnZVkgKyBwb2ludGVyc1sxXS5wYWdlWSk7XG4gICAgICAgIHBhblN0YXJ0LnNldCh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5KCkge1xuICAgICAgY29uc3QgZHggPSBwb2ludGVyc1swXS5wYWdlWCAtIHBvaW50ZXJzWzFdLnBhZ2VYO1xuICAgICAgY29uc3QgZHkgPSBwb2ludGVyc1swXS5wYWdlWSAtIHBvaW50ZXJzWzFdLnBhZ2VZO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgZG9sbHlTdGFydC5zZXQoMCwgZGlzdGFuY2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0RG9sbHlQYW4oKSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSlcbiAgICAgICAgaGFuZGxlVG91Y2hTdGFydERvbGx5KCk7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlUGFuKVxuICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0UGFuKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnREb2xseVJvdGF0ZSgpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVab29tKVxuICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoKTtcbiAgICAgIGlmIChzY29wZS5lbmFibGVSb3RhdGUpXG4gICAgICAgIGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUm90YXRlKGV2ZW50KSB7XG4gICAgICBpZiAocG9pbnRlcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcm90YXRlRW5kLnNldChldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oZXZlbnQpO1xuICAgICAgICBjb25zdCB4ID0gMC41ICogKGV2ZW50LnBhZ2VYICsgcG9zaXRpb24ueCk7XG4gICAgICAgIGNvbnN0IHkgPSAwLjUgKiAoZXZlbnQucGFnZVkgKyBwb3NpdGlvbi55KTtcbiAgICAgICAgcm90YXRlRW5kLnNldCh4LCB5KTtcbiAgICAgIH1cbiAgICAgIHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMocm90YXRlRW5kLCByb3RhdGVTdGFydCkubXVsdGlwbHlTY2FsYXIoc2NvcGUucm90YXRlU3BlZWQpO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQ7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICByb3RhdGVMZWZ0KDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgcm90YXRlVXAoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgfVxuICAgICAgcm90YXRlU3RhcnQuY29weShyb3RhdGVFbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVQYW4oZXZlbnQpIHtcbiAgICAgIGlmIChwb2ludGVycy5sZW5ndGggPT0gMSkge1xuICAgICAgICBwYW5FbmQuc2V0KGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFNlY29uZFBvaW50ZXJQb3NpdGlvbihldmVudCk7XG4gICAgICAgIGNvbnN0IHggPSAwLjUgKiAoZXZlbnQucGFnZVggKyBwb3NpdGlvbi54KTtcbiAgICAgICAgY29uc3QgeSA9IDAuNSAqIChldmVudC5wYWdlWSArIHBvc2l0aW9uLnkpO1xuICAgICAgICBwYW5FbmQuc2V0KHgsIHkpO1xuICAgICAgfVxuICAgICAgcGFuRGVsdGEuc3ViVmVjdG9ycyhwYW5FbmQsIHBhblN0YXJ0KS5tdWx0aXBseVNjYWxhcihzY29wZS5wYW5TcGVlZCk7XG4gICAgICBwYW4ocGFuRGVsdGEueCwgcGFuRGVsdGEueSk7XG4gICAgICBwYW5TdGFydC5jb3B5KHBhbkVuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZURvbGx5KGV2ZW50KSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFNlY29uZFBvaW50ZXJQb3NpdGlvbihldmVudCk7XG4gICAgICBjb25zdCBkeCA9IGV2ZW50LnBhZ2VYIC0gcG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IGR5ID0gZXZlbnQucGFnZVkgLSBwb3NpdGlvbi55O1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgZG9sbHlFbmQuc2V0KDAsIGRpc3RhbmNlKTtcbiAgICAgIGRvbGx5RGVsdGEuc2V0KDAsIE1hdGgucG93KGRvbGx5RW5kLnkgLyBkb2xseVN0YXJ0LnksIHNjb3BlLnpvb21TcGVlZCkpO1xuICAgICAgZG9sbHlPdXQoZG9sbHlEZWx0YS55KTtcbiAgICAgIGRvbGx5U3RhcnQuY29weShkb2xseUVuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZURvbGx5UGFuKGV2ZW50KSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSlcbiAgICAgICAgaGFuZGxlVG91Y2hNb3ZlRG9sbHkoZXZlbnQpO1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZVBhbilcbiAgICAgICAgaGFuZGxlVG91Y2hNb3ZlUGFuKGV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlRG9sbHlSb3RhdGUoZXZlbnQpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVab29tKVxuICAgICAgICBoYW5kbGVUb3VjaE1vdmVEb2xseShldmVudCk7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlKVxuICAgICAgICBoYW5kbGVUb3VjaE1vdmVSb3RhdGUoZXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAocG9pbnRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIChfYSA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgKF9iID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCk7XG4gICAgICB9XG4gICAgICBhZGRQb2ludGVyKGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgIG9uVG91Y2hTdGFydChldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbk1vdXNlRG93bihldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgb25Ub3VjaE1vdmUoZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25Nb3VzZU1vdmUoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICByZW1vdmVQb2ludGVyKGV2ZW50KTtcbiAgICAgIGlmIChwb2ludGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgKF9hID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlbGVhc2VQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICAoX2IgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgb25Qb2ludGVyTW92ZSk7XG4gICAgICAgIChfYyA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgb25Qb2ludGVyVXApO1xuICAgICAgfVxuICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICBsZXQgbW91c2VBY3Rpb247XG4gICAgICBzd2l0Y2ggKGV2ZW50LmJ1dHRvbikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgbW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuTEVGVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1vdXNlQWN0aW9uID0gc2NvcGUubW91c2VCdXR0b25zLk1JRERMRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG1vdXNlQWN0aW9uID0gc2NvcGUubW91c2VCdXR0b25zLlJJR0hUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG1vdXNlQWN0aW9uID0gLTE7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG1vdXNlQWN0aW9uKSB7XG4gICAgICAgIGNhc2UgTU9VU0UuRE9MTFk6XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGhhbmRsZU1vdXNlRG93bkRvbGx5KGV2ZW50KTtcbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLkRPTExZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1PVVNFLlJPVEFURTpcbiAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaGFuZGxlTW91c2VEb3duUGFuKGV2ZW50KTtcbiAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUEFOO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaGFuZGxlTW91c2VEb3duUm90YXRlKGV2ZW50KTtcbiAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNT1VTRS5QQU46XG4gICAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRG93blJvdGF0ZShldmVudCk7XG4gICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlJPVEFURTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRG93blBhbihldmVudCk7XG4gICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlBBTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlICE9PSBTVEFURS5OT05FKSB7XG4gICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTVEFURS5ST1RBVEU6XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFuZGxlTW91c2VNb3ZlUm90YXRlKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTVEFURS5ET0xMWTpcbiAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFuZGxlTW91c2VNb3ZlRG9sbHkoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFLlBBTjpcbiAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBoYW5kbGVNb3VzZU1vdmVQYW4oZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlV2hlZWwoZXZlbnQpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSB8fCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSAmJiBzdGF0ZSAhPT0gU1RBVEUuUk9UQVRFKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xuICAgICAgaGFuZGxlTW91c2VXaGVlbChldmVudCk7XG4gICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaGFuZGxlS2V5RG93bihldmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChldmVudCkge1xuICAgICAgdHJhY2tQb2ludGVyKGV2ZW50KTtcbiAgICAgIHN3aXRjaCAocG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBzd2l0Y2ggKHNjb3BlLnRvdWNoZXMuT05FKSB7XG4gICAgICAgICAgICBjYXNlIFRPVUNILlJPVEFURTpcbiAgICAgICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCk7XG4gICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVE9VQ0guUEFOOlxuICAgICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGhhbmRsZVRvdWNoU3RhcnRQYW4oKTtcbiAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9QQU47XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHN3aXRjaCAoc2NvcGUudG91Y2hlcy5UV08pIHtcbiAgICAgICAgICAgIGNhc2UgVE9VQ0guRE9MTFlfUEFOOlxuICAgICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgJiYgc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGhhbmRsZVRvdWNoU3RhcnREb2xseVBhbigpO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlRPVUNIX0RPTExZX1BBTjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRPVUNILkRPTExZX1JPVEFURTpcbiAgICAgICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0RG9sbHlSb3RhdGUoKTtcbiAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9ET0xMWV9ST1RBVEU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgIT09IFNUQVRFLk5PTkUpIHtcbiAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoZXZlbnQpIHtcbiAgICAgIHRyYWNrUG9pbnRlcihldmVudCk7XG4gICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgU1RBVEUuVE9VQ0hfUk9UQVRFOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGhhbmRsZVRvdWNoTW92ZVJvdGF0ZShldmVudCk7XG4gICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEUuVE9VQ0hfUEFOOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGhhbmRsZVRvdWNoTW92ZVBhbihldmVudCk7XG4gICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEUuVE9VQ0hfRE9MTFlfUEFOOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGhhbmRsZVRvdWNoTW92ZURvbGx5UGFuKGV2ZW50KTtcbiAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTVEFURS5UT1VDSF9ET0xMWV9ST1RBVEU6XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFuZGxlVG91Y2hNb3ZlRG9sbHlSb3RhdGUoZXZlbnQpO1xuICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Db250ZXh0TWVudShldmVudCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRQb2ludGVyKGV2ZW50KSB7XG4gICAgICBwb2ludGVycy5wdXNoKGV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlUG9pbnRlcihldmVudCkge1xuICAgICAgZGVsZXRlIHBvaW50ZXJQb3NpdGlvbnNbZXZlbnQucG9pbnRlcklkXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBvaW50ZXJzW2ldLnBvaW50ZXJJZCA9PSBldmVudC5wb2ludGVySWQpIHtcbiAgICAgICAgICBwb2ludGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNrUG9pbnRlcihldmVudCkge1xuICAgICAgbGV0IHBvc2l0aW9uID0gcG9pbnRlclBvc2l0aW9uc1tldmVudC5wb2ludGVySWRdO1xuICAgICAgaWYgKHBvc2l0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgcG9zaXRpb24gPSBuZXcgVmVjdG9yMigpO1xuICAgICAgICBwb2ludGVyUG9zaXRpb25zW2V2ZW50LnBvaW50ZXJJZF0gPSBwb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHBvc2l0aW9uLnNldChldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oZXZlbnQpIHtcbiAgICAgIGNvbnN0IHBvaW50ZXIgPSBldmVudC5wb2ludGVySWQgPT09IHBvaW50ZXJzWzBdLnBvaW50ZXJJZCA/IHBvaW50ZXJzWzFdIDogcG9pbnRlcnNbMF07XG4gICAgICByZXR1cm4gcG9pbnRlclBvc2l0aW9uc1twb2ludGVyLnBvaW50ZXJJZF07XG4gICAgfVxuICAgIHRoaXMuZG9sbHlJbiA9IChkb2xseVNjYWxlID0gZ2V0Wm9vbVNjYWxlKCkpID0+IHtcbiAgICAgIGRvbGx5SW4oZG9sbHlTY2FsZSk7XG4gICAgICBzY29wZS51cGRhdGUoKTtcbiAgICB9O1xuICAgIHRoaXMuZG9sbHlPdXQgPSAoZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpKSA9PiB7XG4gICAgICBkb2xseU91dChkb2xseVNjYWxlKTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5nZXRTY2FsZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHRoaXMuc2V0U2NhbGUgPSAobmV3U2NhbGUpID0+IHtcbiAgICAgIHNldFNjYWxlKG5ld1NjYWxlKTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5nZXRab29tU2NhbGUgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZ2V0Wm9vbVNjYWxlKCk7XG4gICAgfTtcbiAgICBpZiAoZG9tRWxlbWVudCAhPT0gdm9pZCAwKVxuICAgICAgdGhpcy5jb25uZWN0KGRvbUVsZW1lbnQpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbn1cbmNsYXNzIE1hcENvbnRyb2xzIGV4dGVuZHMgT3JiaXRDb250cm9scyB7XG4gIGNvbnN0cnVjdG9yKG9iamVjdCwgZG9tRWxlbWVudCkge1xuICAgIHN1cGVyKG9iamVjdCwgZG9tRWxlbWVudCk7XG4gICAgdGhpcy5zY3JlZW5TcGFjZVBhbm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5MRUZUID0gTU9VU0UuUEFOO1xuICAgIHRoaXMubW91c2VCdXR0b25zLlJJR0hUID0gTU9VU0UuUk9UQVRFO1xuICAgIHRoaXMudG91Y2hlcy5PTkUgPSBUT1VDSC5QQU47XG4gICAgdGhpcy50b3VjaGVzLlRXTyA9IFRPVUNILkRPTExZX1JPVEFURTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgTWFwQ29udHJvbHMsXG4gIE9yYml0Q29udHJvbHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PcmJpdENvbnRyb2xzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-stdlib/controls/OrbitControls.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0EsMERBQTBELFlBQVk7QUFDdEUsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgICAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQyKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpIHtcbiAgICAgIGRpZFdhcm5PbGQxOEFscGhhIHx8XG4gICAgICAgIHZvaWQgMCA9PT0gUmVhY3Quc3RhcnRUcmFuc2l0aW9uIHx8XG4gICAgICAgICgoZGlkV2Fybk9sZDE4QWxwaGEgPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdXNlU3luY0V4dGVybmFsU3RvcmUuIFRoZSB1c2Utc3luYy1leHRlcm5hbC1zdG9yZSBzaGltIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5LiBVcGdyYWRlIHRvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuICAgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgICB2YXIgY2FjaGVkVmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuICAgICAgICBvYmplY3RJcyh2YWx1ZSwgY2FjaGVkVmFsdWUpIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjYWNoZWRWYWx1ZSA9IHVzZVN0YXRlKHtcbiAgICAgICAgaW5zdDogeyB2YWx1ZTogdmFsdWUsIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9XG4gICAgICB9KTtcbiAgICAgIHZhciBpbnN0ID0gY2FjaGVkVmFsdWVbMF0uaW5zdCxcbiAgICAgICAgZm9yY2VVcGRhdGUgPSBjYWNoZWRWYWx1ZVsxXTtcbiAgICAgIHVzZUxheW91dEVmZmVjdChcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBpbnN0LmdldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7XG4gICAgICAgICAgY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSAmJiBmb3JjZVVwZGF0ZSh7IGluc3Q6IGluc3QgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFtzdWJzY3JpYmUsIHZhbHVlLCBnZXRTbmFwc2hvdF1cbiAgICAgICk7XG4gICAgICB1c2VFZmZlY3QoXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpICYmIGZvcmNlVXBkYXRlKHsgaW5zdDogaW5zdCB9KTtcbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VVcGRhdGUoeyBpbnN0OiBpbnN0IH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBbc3Vic2NyaWJlXVxuICAgICAgKTtcbiAgICAgIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgICAgIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG4gICAgICBpbnN0ID0gaW5zdC52YWx1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBsYXRlc3RHZXRTbmFwc2hvdCgpO1xuICAgICAgICByZXR1cm4gIW9iamVjdElzKGluc3QsIG5leHRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCkge1xuICAgICAgcmV0dXJuIGdldFNuYXBzaG90KCk7XG4gICAgfVxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQoRXJyb3IoKSk7XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgb2JqZWN0SXMgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBpcyxcbiAgICAgIHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUsXG4gICAgICB1c2VFZmZlY3QgPSBSZWFjdC51c2VFZmZlY3QsXG4gICAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdC51c2VMYXlvdXRFZmZlY3QsXG4gICAgICB1c2VEZWJ1Z1ZhbHVlID0gUmVhY3QudXNlRGVidWdWYWx1ZSxcbiAgICAgIGRpZFdhcm5PbGQxOEFscGhhID0gITEsXG4gICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9ICExLFxuICAgICAgc2hpbSA9XG4gICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB3aW5kb3cgfHxcbiAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHdpbmRvdy5kb2N1bWVudCB8fFxuICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcbiAgICAgICAgICA/IHVzZVN5bmNFeHRlcm5hbFN0b3JlJDFcbiAgICAgICAgICA6IHVzZVN5bmNFeHRlcm5hbFN0b3JlJDI7XG4gICAgZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9XG4gICAgICB2b2lkIDAgIT09IFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlID8gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgOiBzaGltO1xuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKEVycm9yKCkpO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      shim = __webpack_require__(/*! use-sync-external-store/shim */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useSyncExternalStore = shim.useSyncExternalStore,\n      useRef = React.useRef,\n      useEffect = React.useEffect,\n      useMemo = React.useMemo,\n      useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector,\n      isEqual\n    ) {\n      var instRef = useRef(null);\n      if (null === instRef.current) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo(\n        function () {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              hasMemo = !0;\n              memoizedSnapshot = nextSnapshot;\n              nextSnapshot = selector(nextSnapshot);\n              if (void 0 !== isEqual && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return (memoizedSelection = currentSelection);\n              }\n              return (memoizedSelection = nextSnapshot);\n            }\n            currentSelection = memoizedSelection;\n            if (objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n              return (memoizedSnapshot = nextSnapshot), currentSelection;\n            memoizedSnapshot = nextSnapshot;\n            return (memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1,\n            memoizedSnapshot,\n            memoizedSelection,\n            maybeGetServerSnapshot =\n              void 0 === getServerSnapshot ? null : getServerSnapshot;\n          return [\n            function () {\n              return memoizedSelector(getSnapshot());\n            },\n            null === maybeGetServerSnapshot\n              ? void 0\n              : function () {\n                  return memoizedSelector(maybeGetServerSnapshot());\n                }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n      useEffect(\n        function () {\n          inst.hasValue = !0;\n          inst.value = value;\n        },\n        [value]\n      );\n      useDebugValue(value);\n      return value;\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBTztBQUMvQixhQUFhLG1CQUFPLENBQUMsOEdBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0NBQXdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgICByZXR1cm4gKHggPT09IHkgJiYgKDAgIT09IHggfHwgMSAvIHggPT09IDEgLyB5KSkgfHwgKHggIT09IHggJiYgeSAhPT0geSk7XG4gICAgfVxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQoRXJyb3IoKSk7XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgc2hpbSA9IHJlcXVpcmUoXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltXCIpLFxuICAgICAgb2JqZWN0SXMgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBpcyxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gc2hpbS51c2VTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgICAgIHVzZVJlZiA9IFJlYWN0LnVzZVJlZixcbiAgICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICAgIHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vLFxuICAgICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG4gICAgZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciA9IGZ1bmN0aW9uIChcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGdldFNuYXBzaG90LFxuICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApIHtcbiAgICAgIHZhciBpbnN0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgICAgaWYgKG51bGwgPT09IGluc3RSZWYuY3VycmVudCkge1xuICAgICAgICB2YXIgaW5zdCA9IHsgaGFzVmFsdWU6ICExLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICBpbnN0UmVmLmN1cnJlbnQgPSBpbnN0O1xuICAgICAgfSBlbHNlIGluc3QgPSBpbnN0UmVmLmN1cnJlbnQ7XG4gICAgICBpbnN0UmVmID0gdXNlTWVtbyhcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIG1lbW9pemVkU2VsZWN0b3IobmV4dFNuYXBzaG90KSB7XG4gICAgICAgICAgICBpZiAoIWhhc01lbW8pIHtcbiAgICAgICAgICAgICAgaGFzTWVtbyA9ICEwO1xuICAgICAgICAgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgICAgICAgICBuZXh0U25hcHNob3QgPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBpc0VxdWFsICYmIGluc3QuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGluc3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXF1YWwoY3VycmVudFNlbGVjdGlvbiwgbmV4dFNuYXBzaG90KSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiAobWVtb2l6ZWRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNuYXBzaG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSBtZW1vaXplZFNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChvYmplY3RJcyhtZW1vaXplZFNuYXBzaG90LCBuZXh0U25hcHNob3QpKVxuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciBuZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGlzRXF1YWwgJiYgaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgcmV0dXJuIChtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90KSwgY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG4gICAgICAgICAgICByZXR1cm4gKG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNlbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBoYXNNZW1vID0gITEsXG4gICAgICAgICAgICBtZW1vaXplZFNuYXBzaG90LFxuICAgICAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICBtYXliZUdldFNlcnZlclNuYXBzaG90ID1cbiAgICAgICAgICAgICAgdm9pZCAwID09PSBnZXRTZXJ2ZXJTbmFwc2hvdCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihnZXRTbmFwc2hvdCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudWxsID09PSBtYXliZUdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IobWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWxdXG4gICAgICApO1xuICAgICAgdmFyIHZhbHVlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBpbnN0UmVmWzBdLCBpbnN0UmVmWzFdKTtcbiAgICAgIHVzZUVmZmVjdChcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGluc3QuaGFzVmFsdWUgPSAhMDtcbiAgICAgICAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIFt2YWx1ZV1cbiAgICAgICk7XG4gICAgICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKEVycm9yKCkpO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js":
/*!************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw0TUFBOEU7QUFDaEYiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js":
/*!********************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/with-selector.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim/with-selector.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHdPQUE0RjtBQUM5RiIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/zustand/esm/traditional.mjs":
/*!**************************************************!*\
  !*** ./node_modules/zustand/esm/traditional.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createWithEqualityFn: () => (/* binding */ createWithEqualityFn),\n/* harmony export */   useStoreWithEqualityFn: () => (/* binding */ useStoreWithEqualityFn)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/vanilla */ \"(app-pages-browser)/./node_modules/zustand/esm/vanilla.mjs\");\nvar _s = $RefreshSig$();\n\n\n\nconst { useSyncExternalStoreWithSelector } = use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__;\nconst identity = (arg)=>arg;\nfunction useStoreWithEqualityFn(api) {\n    let selector = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : identity, equalityFn = arguments.length > 2 ? arguments[2] : void 0;\n    _s();\n    const slice = useSyncExternalStoreWithSelector(api.subscribe, api.getState, api.getInitialState, selector, equalityFn);\n    react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(slice);\n    return slice;\n}\n_s(useStoreWithEqualityFn, \"fBHg3RP1RTzE8Uht4y5QQ3lLDzA=\", false, function() {\n    return [\n        useSyncExternalStoreWithSelector\n    ];\n});\nconst createWithEqualityFnImpl = (createState, defaultEqualityFn)=>{\n    var _s = $RefreshSig$();\n    const api = (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_2__.createStore)(createState);\n    const useBoundStoreWithEqualityFn = function(selector) {\n        let equalityFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultEqualityFn;\n        _s();\n        return useStoreWithEqualityFn(api, selector, equalityFn);\n    };\n    _s(useBoundStoreWithEqualityFn, \"2eIM+9+MfKF7Uyo/qapDVfqJXkg=\", false, function() {\n        return [\n            useStoreWithEqualityFn\n        ];\n    });\n    Object.assign(useBoundStoreWithEqualityFn, api);\n    return useBoundStoreWithEqualityFn;\n};\nconst createWithEqualityFn = (createState, defaultEqualityFn)=>createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS90cmFkaXRpb25hbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTBCO0FBQzhEO0FBQzFDO0FBRTlDLE1BQU0sRUFBRUcsZ0NBQWdDLEVBQUUsR0FBR0YsMEVBQTJCQTtBQUN4RSxNQUFNRyxXQUFXLENBQUNDLE1BQVFBO0FBQzFCLFNBQVNDLHVCQUF1QkMsR0FBRztRQUFFQyxXQUFBQSxpRUFBV0osVUFBVUs7O0lBQ3hELE1BQU1DLFFBQVFQLGlDQUNaSSxJQUFJSSxTQUFTLEVBQ2JKLElBQUlLLFFBQVEsRUFDWkwsSUFBSU0sZUFBZSxFQUNuQkwsVUFDQUM7SUFFRlQsZ0RBQW1CLENBQUNVO0lBQ3BCLE9BQU9BO0FBQ1Q7R0FWU0o7O1FBQ09IOzs7QUFVaEIsTUFBTVksMkJBQTJCLENBQUNDLGFBQWFDOztJQUM3QyxNQUFNVixNQUFNTCw0REFBV0EsQ0FBQ2M7SUFDeEIsTUFBTUUsOEJBQThCLFNBQUNWO1lBQVVDLDhFQUFhUTs7UUFBc0JYLE9BQUFBLHVCQUF1QkMsS0FBS0MsVUFBVUM7SUFBVTtPQUE1SFM7O1lBQTRFWjs7O0lBQ2xGYSxPQUFPQyxNQUFNLENBQUNGLDZCQUE2Qlg7SUFDM0MsT0FBT1c7QUFDVDtBQUNBLE1BQU1HLHVCQUF1QixDQUFDTCxhQUFhQyxvQkFBc0JELGNBQWNELHlCQUF5QkMsYUFBYUMscUJBQXFCRjtBQUVsRiIsInNvdXJjZXMiOlsiL1VzZXJzL2J5cm9ud2FkZS9jb3NtaWMvbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL3RyYWRpdGlvbmFsLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVN5bmNFeHRlcm5hbFN0b3JlRXhwb3J0cyBmcm9tICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RvcmUgfSBmcm9tICd6dXN0YW5kL3ZhbmlsbGEnO1xuXG5jb25zdCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZUV4cG9ydHM7XG5jb25zdCBpZGVudGl0eSA9IChhcmcpID0+IGFyZztcbmZ1bmN0aW9uIHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4oYXBpLCBzZWxlY3RvciA9IGlkZW50aXR5LCBlcXVhbGl0eUZuKSB7XG4gIGNvbnN0IHNsaWNlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgYXBpLnN1YnNjcmliZSxcbiAgICBhcGkuZ2V0U3RhdGUsXG4gICAgYXBpLmdldEluaXRpYWxTdGF0ZSxcbiAgICBzZWxlY3RvcixcbiAgICBlcXVhbGl0eUZuXG4gICk7XG4gIFJlYWN0LnVzZURlYnVnVmFsdWUoc2xpY2UpO1xuICByZXR1cm4gc2xpY2U7XG59XG5jb25zdCBjcmVhdGVXaXRoRXF1YWxpdHlGbkltcGwgPSAoY3JlYXRlU3RhdGUsIGRlZmF1bHRFcXVhbGl0eUZuKSA9PiB7XG4gIGNvbnN0IGFwaSA9IGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKTtcbiAgY29uc3QgdXNlQm91bmRTdG9yZVdpdGhFcXVhbGl0eUZuID0gKHNlbGVjdG9yLCBlcXVhbGl0eUZuID0gZGVmYXVsdEVxdWFsaXR5Rm4pID0+IHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4oYXBpLCBzZWxlY3RvciwgZXF1YWxpdHlGbik7XG4gIE9iamVjdC5hc3NpZ24odXNlQm91bmRTdG9yZVdpdGhFcXVhbGl0eUZuLCBhcGkpO1xuICByZXR1cm4gdXNlQm91bmRTdG9yZVdpdGhFcXVhbGl0eUZuO1xufTtcbmNvbnN0IGNyZWF0ZVdpdGhFcXVhbGl0eUZuID0gKGNyZWF0ZVN0YXRlLCBkZWZhdWx0RXF1YWxpdHlGbikgPT4gY3JlYXRlU3RhdGUgPyBjcmVhdGVXaXRoRXF1YWxpdHlGbkltcGwoY3JlYXRlU3RhdGUsIGRlZmF1bHRFcXVhbGl0eUZuKSA6IGNyZWF0ZVdpdGhFcXVhbGl0eUZuSW1wbDtcblxuZXhwb3J0IHsgY3JlYXRlV2l0aEVxdWFsaXR5Rm4sIHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4gfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlRXhwb3J0cyIsImNyZWF0ZVN0b3JlIiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IiLCJpZGVudGl0eSIsImFyZyIsInVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4iLCJhcGkiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJzbGljZSIsInN1YnNjcmliZSIsImdldFN0YXRlIiwiZ2V0SW5pdGlhbFN0YXRlIiwidXNlRGVidWdWYWx1ZSIsImNyZWF0ZVdpdGhFcXVhbGl0eUZuSW1wbCIsImNyZWF0ZVN0YXRlIiwiZGVmYXVsdEVxdWFsaXR5Rm4iLCJ1c2VCb3VuZFN0b3JlV2l0aEVxdWFsaXR5Rm4iLCJPYmplY3QiLCJhc3NpZ24iLCJjcmVhdGVXaXRoRXF1YWxpdHlGbiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/zustand/esm/traditional.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/zustand/esm/vanilla.mjs":
/*!**********************************************!*\
  !*** ./node_modules/zustand/esm/vanilla.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStore: () => (/* binding */ createStore)\n/* harmony export */ });\nconst createStoreImpl = (createState)=>{\n    let state;\n    const listeners = /* @__PURE__ */ new Set();\n    const setState = (partial, replace)=>{\n        const nextState = typeof partial === \"function\" ? partial(state) : partial;\n        if (!Object.is(nextState, state)) {\n            const previousState = state;\n            state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n            listeners.forEach((listener)=>listener(state, previousState));\n        }\n    };\n    const getState = ()=>state;\n    const getInitialState = ()=>initialState;\n    const subscribe = (listener)=>{\n        listeners.add(listener);\n        return ()=>listeners.delete(listener);\n    };\n    const api = {\n        setState,\n        getState,\n        getInitialState,\n        subscribe\n    };\n    const initialState = state = createState(setState, getState, api);\n    return api;\n};\nconst createStore = (createState)=>createState ? createStoreImpl(createState) : createStoreImpl;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS92YW5pbGxhLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsa0JBQWtCLENBQUNDO0lBQ3ZCLElBQUlDO0lBQ0osTUFBTUMsWUFBWSxhQUFhLEdBQUcsSUFBSUM7SUFDdEMsTUFBTUMsV0FBVyxDQUFDQyxTQUFTQztRQUN6QixNQUFNQyxZQUFZLE9BQU9GLFlBQVksYUFBYUEsUUFBUUosU0FBU0k7UUFDbkUsSUFBSSxDQUFDRyxPQUFPQyxFQUFFLENBQUNGLFdBQVdOLFFBQVE7WUFDaEMsTUFBTVMsZ0JBQWdCVDtZQUN0QkEsUUFBUSxDQUFDSyxXQUFXLE9BQU9BLFVBQVUsT0FBT0MsY0FBYyxZQUFZQSxjQUFjLElBQUcsSUFBS0EsWUFBWUMsT0FBT0csTUFBTSxDQUFDLENBQUMsR0FBR1YsT0FBT007WUFDaklMLFVBQVVVLE9BQU8sQ0FBQyxDQUFDQyxXQUFhQSxTQUFTWixPQUFPUztRQUNsRDtJQUNGO0lBQ0EsTUFBTUksV0FBVyxJQUFNYjtJQUN2QixNQUFNYyxrQkFBa0IsSUFBTUM7SUFDOUIsTUFBTUMsWUFBWSxDQUFDSjtRQUNqQlgsVUFBVWdCLEdBQUcsQ0FBQ0w7UUFDZCxPQUFPLElBQU1YLFVBQVVpQixNQUFNLENBQUNOO0lBQ2hDO0lBQ0EsTUFBTU8sTUFBTTtRQUFFaEI7UUFBVVU7UUFBVUM7UUFBaUJFO0lBQVU7SUFDN0QsTUFBTUQsZUFBZWYsUUFBUUQsWUFBWUksVUFBVVUsVUFBVU07SUFDN0QsT0FBT0E7QUFDVDtBQUNBLE1BQU1DLGNBQWMsQ0FBQ3JCLGNBQWdCQSxjQUFjRCxnQkFBZ0JDLGVBQWVEO0FBRTNEIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vdmFuaWxsYS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY3JlYXRlU3RvcmVJbXBsID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGxldCBzdGF0ZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgc2V0U3RhdGUgPSAocGFydGlhbCwgcmVwbGFjZSkgPT4ge1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSBcImZ1bmN0aW9uXCIgPyBwYXJ0aWFsKHN0YXRlKSA6IHBhcnRpYWw7XG4gICAgaWYgKCFPYmplY3QuaXMobmV4dFN0YXRlLCBzdGF0ZSkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcbiAgICAgIHN0YXRlID0gKHJlcGxhY2UgIT0gbnVsbCA/IHJlcGxhY2UgOiB0eXBlb2YgbmV4dFN0YXRlICE9PSBcIm9iamVjdFwiIHx8IG5leHRTdGF0ZSA9PT0gbnVsbCkgPyBuZXh0U3RhdGUgOiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoc3RhdGUsIHByZXZpb3VzU3RhdGUpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdldFN0YXRlID0gKCkgPT4gc3RhdGU7XG4gIGNvbnN0IGdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGluaXRpYWxTdGF0ZTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gKGxpc3RlbmVyKSA9PiB7XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9O1xuICBjb25zdCBhcGkgPSB7IHNldFN0YXRlLCBnZXRTdGF0ZSwgZ2V0SW5pdGlhbFN0YXRlLCBzdWJzY3JpYmUgfTtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gc3RhdGUgPSBjcmVhdGVTdGF0ZShzZXRTdGF0ZSwgZ2V0U3RhdGUsIGFwaSk7XG4gIHJldHVybiBhcGk7XG59O1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoY3JlYXRlU3RhdGUpID0+IGNyZWF0ZVN0YXRlID8gY3JlYXRlU3RvcmVJbXBsKGNyZWF0ZVN0YXRlKSA6IGNyZWF0ZVN0b3JlSW1wbDtcblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUgfTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVTdG9yZUltcGwiLCJjcmVhdGVTdGF0ZSIsInN0YXRlIiwibGlzdGVuZXJzIiwiU2V0Iiwic2V0U3RhdGUiLCJwYXJ0aWFsIiwicmVwbGFjZSIsIm5leHRTdGF0ZSIsIk9iamVjdCIsImlzIiwicHJldmlvdXNTdGF0ZSIsImFzc2lnbiIsImZvckVhY2giLCJsaXN0ZW5lciIsImdldFN0YXRlIiwiZ2V0SW5pdGlhbFN0YXRlIiwiaW5pdGlhbFN0YXRlIiwic3Vic2NyaWJlIiwiYWRkIiwiZGVsZXRlIiwiYXBpIiwiY3JlYXRlU3RvcmUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/zustand/esm/vanilla.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/generators/planet-renderer-3d.tsx":
/*!**********************************************************!*\
  !*** ./src/components/generators/planet-renderer-3d.tsx ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlanetRenderer3D: () => (/* binding */ PlanetRenderer3D)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/Stars.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/OrbitControls.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _shared_procgen_planet_planet_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/shared/procgen/planet/planet-types */ \"(app-pages-browser)/./src/shared/procgen/planet/planet-types.ts\");\n/* harmony import */ var _components_ui_PlanetInfoCard3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/ui/PlanetInfoCard3D */ \"(app-pages-browser)/./src/components/ui/PlanetInfoCard3D.tsx\");\n/* harmony import */ var _components_ui_Card3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/ui/Card3D */ \"(app-pages-browser)/./src/components/ui/Card3D.tsx\");\n/**\n * @file planet-renderer-3d.tsx\n * @description Enhanced planet renderer with React Three Fiber and 3D UI\n * @version 2.0.0\n * @author Galactic Clans Development Team\n */ /* __next_internal_client_entry_do_not_use__ PlanetRenderer3D auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\n\n\n\n\n\n\n// Planet Mesh Component with hover interactions\nfunction PlanetMesh(param) {\n    let { config, onHover, onHoverExit } = param;\n    _s();\n    const meshRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [planetMesh, setPlanetMesh] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Generate planet using enhanced renderer\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"PlanetMesh.useEffect\": ()=>{\n            const generatePlanet = {\n                \"PlanetMesh.useEffect.generatePlanet\": async ()=>{\n                    try {\n                        // Import the enhanced planet renderer\n                        const { PlanetRenderer } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_shared_procgen_planet_planet-renderer_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/shared/procgen/planet/planet-renderer */ \"(app-pages-browser)/./src/shared/procgen/planet/planet-renderer.ts\"));\n                        const renderer = new PlanetRenderer();\n                        // Convert simple config to enhanced config\n                        const enhancedConfig = {\n                            planetClass: config.planetClass,\n                            radius: config.radius,\n                            enableAtmosphere: config.hasAtmosphere,\n                            enableRings: config.hasRings,\n                            enableMoons: config.hasMoons,\n                            enableSurfaceDetails: config.enableVegetation,\n                            enableVegetation: config.enableVegetation,\n                            treeCount: config.treeCount,\n                            terrainDetail: config.surfaceDetail\n                        };\n                        // Generate planet with enhanced renderer\n                        const result = await renderer.renderPlanetByType(config.planetClass, enhancedConfig);\n                        if (result && result.mesh) {\n                            setPlanetMesh(result.mesh);\n                            console.log(\"🌍 [PLANET] Generated with vegetation:\", result.metadata);\n                        } else {\n                            // Fallback to basic generation\n                            console.warn(\"🌍 [PLANET] Using fallback generation\");\n                            generateBasicPlanet();\n                        }\n                    } catch (error) {\n                        console.error(\"🌍 [PLANET] Error generating planet:\", error);\n                        generateBasicPlanet();\n                    }\n                }\n            }[\"PlanetMesh.useEffect.generatePlanet\"];\n            const generateBasicPlanet = {\n                \"PlanetMesh.useEffect.generateBasicPlanet\": ()=>{\n                    const planetGroup = new three__WEBPACK_IMPORTED_MODULE_5__.Group();\n                    // Main planet\n                    const geometry = new three__WEBPACK_IMPORTED_MODULE_5__.SphereGeometry(config.radius, 64, 64);\n                    const material = new three__WEBPACK_IMPORTED_MODULE_5__.MeshLambertMaterial({\n                        color: config.color\n                    });\n                    const planet = new three__WEBPACK_IMPORTED_MODULE_5__.Mesh(geometry, material);\n                    planet.castShadow = true;\n                    planet.receiveShadow = true;\n                    planetGroup.add(planet);\n                    // Add atmosphere\n                    if (config.hasAtmosphere) {\n                        const atmosphereGeometry = new three__WEBPACK_IMPORTED_MODULE_5__.SphereGeometry(config.radius * 1.05, 32, 32);\n                        const atmosphereMaterial = new three__WEBPACK_IMPORTED_MODULE_5__.MeshBasicMaterial({\n                            color: 0x87ceeb,\n                            transparent: true,\n                            opacity: 0.2,\n                            side: three__WEBPACK_IMPORTED_MODULE_5__.BackSide\n                        });\n                        const atmosphere = new three__WEBPACK_IMPORTED_MODULE_5__.Mesh(atmosphereGeometry, atmosphereMaterial);\n                        planetGroup.add(atmosphere);\n                    }\n                    setPlanetMesh(planetGroup);\n                }\n            }[\"PlanetMesh.useEffect.generateBasicPlanet\"];\n            generatePlanet();\n        }\n    }[\"PlanetMesh.useEffect\"], [\n        config\n    ]);\n    // Add the planet mesh to the scene\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"PlanetMesh.useEffect\": ()=>{\n            if (meshRef.current && planetMesh) {\n                // Clear existing children\n                while(meshRef.current.children.length > 0){\n                    meshRef.current.remove(meshRef.current.children[0]);\n                }\n                // Add the new planet mesh\n                meshRef.current.add(planetMesh);\n            }\n        }\n    }[\"PlanetMesh.useEffect\"], [\n        planetMesh\n    ]);\n    // Rotation animation\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_6__.D)({\n        \"PlanetMesh.useFrame\": ()=>{\n            if (meshRef.current) {\n                meshRef.current.rotation.y += 0.005;\n            }\n        }\n    }[\"PlanetMesh.useFrame\"]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n        ref: meshRef,\n        onPointerEnter: onHover,\n        onPointerLeave: onHoverExit\n    }, void 0, false, {\n        fileName: \"/Users/byronwade/cosmic/src/components/generators/planet-renderer-3d.tsx\",\n        lineNumber: 129,\n        columnNumber: 9\n    }, this);\n}\n_s(PlanetMesh, \"33J0rprgyzYEzYG+kdsmguywu2s=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_6__.D\n    ];\n});\n_c = PlanetMesh;\n// Scene Component\nfunction PlanetScene(param) {\n    let { config } = param;\n    _s1();\n    const [isHovering, setIsHovering] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [hoverPosition, setHoverPosition] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        0,\n        0,\n        0\n    ]);\n    const handleHover = (event)=>{\n        setIsHovering(true);\n        // Position the info card above the planet\n        setHoverPosition([\n            config.radius + 2,\n            config.radius + 1,\n            0\n        ]);\n    };\n    const handleHoverExit = ()=>{\n        setIsHovering(false);\n    };\n    // Get planet type for info card\n    const planetType = (0,_shared_procgen_planet_planet_types__WEBPACK_IMPORTED_MODULE_2__.getPlanetTypeByClass)(config.planetClass);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ambientLight\", {\n                intensity: 0.4\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/planet-renderer-3d.tsx\",\n                lineNumber: 153,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"directionalLight\", {\n                position: [\n                    5,\n                    5,\n                    5\n                ],\n                intensity: 1,\n                castShadow: true\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/planet-renderer-3d.tsx\",\n                lineNumber: 154,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PlanetMesh, {\n                config: config,\n                onHover: handleHover,\n                onHoverExit: handleHoverExit\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/planet-renderer-3d.tsx\",\n                lineNumber: 157,\n                columnNumber: 4\n            }, this),\n            planetType && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_PlanetInfoCard3D__WEBPACK_IMPORTED_MODULE_3__.PlanetInfoCard3D, {\n                planetType: planetType,\n                position: hoverPosition,\n                visible: isHovering,\n                planetConfig: {\n                    radius: config.radius,\n                    treeCount: config.enableVegetation ? config.treeCount : undefined,\n                    enableVegetation: config.enableVegetation\n                }\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/planet-renderer-3d.tsx\",\n                lineNumber: 161,\n                columnNumber: 5\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_7__.Stars, {\n                radius: 50,\n                depth: 50,\n                count: 5000,\n                factor: 4,\n                saturation: 0,\n                fade: true\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/planet-renderer-3d.tsx\",\n                lineNumber: 174,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s1(PlanetScene, \"C/kJeQvy1tx3Fe6bw95Zw5YAgig=\");\n_c1 = PlanetScene;\nfunction PlanetRenderer3D(param) {\n    let { config, isLoading, onLoadingChange } = param;\n    _s2();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"PlanetRenderer3D.useEffect\": ()=>{\n            // Simulate loading\n            onLoadingChange(true);\n            const timer = setTimeout({\n                \"PlanetRenderer3D.useEffect.timer\": ()=>{\n                    onLoadingChange(false);\n                }\n            }[\"PlanetRenderer3D.useEffect.timer\"], 1000);\n            return ({\n                \"PlanetRenderer3D.useEffect\": ()=>clearTimeout(timer)\n            })[\"PlanetRenderer3D.useEffect\"];\n        }\n    }[\"PlanetRenderer3D.useEffect\"], [\n        config,\n        onLoadingChange\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"absolute inset-0 pt-16\",\n        style: {\n            position: \"relative\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_Card3D__WEBPACK_IMPORTED_MODULE_4__.HolographicStyle, {}, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/planet-renderer-3d.tsx\",\n                lineNumber: 191,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_fiber__WEBPACK_IMPORTED_MODULE_8__.Canvas, {\n                camera: {\n                    position: [\n                        0,\n                        0,\n                        8\n                    ],\n                    fov: 75\n                },\n                shadows: true,\n                style: {\n                    position: \"absolute\",\n                    top: 0,\n                    left: 0,\n                    width: \"100%\",\n                    height: \"100%\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n                    fallback: null,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PlanetScene, {\n                            config: config\n                        }, void 0, false, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/generators/planet-renderer-3d.tsx\",\n                            lineNumber: 204,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_9__.OrbitControls, {\n                            enablePan: true,\n                            enableZoom: true,\n                            enableRotate: true,\n                            minDistance: 3,\n                            maxDistance: 20\n                        }, void 0, false, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/generators/planet-renderer-3d.tsx\",\n                            lineNumber: 205,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/byronwade/cosmic/src/components/generators/planet-renderer-3d.tsx\",\n                    lineNumber: 203,\n                    columnNumber: 5\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/byronwade/cosmic/src/components/generators/planet-renderer-3d.tsx\",\n                lineNumber: 192,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/byronwade/cosmic/src/components/generators/planet-renderer-3d.tsx\",\n        lineNumber: 190,\n        columnNumber: 3\n    }, this);\n}\n_s2(PlanetRenderer3D, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c2 = PlanetRenderer3D;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"PlanetMesh\");\n$RefreshReg$(_c1, \"PlanetScene\");\n$RefreshReg$(_c2, \"PlanetRenderer3D\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2dlbmVyYXRvcnMvcGxhbmV0LXJlbmRlcmVyLTNkLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQzs7QUFJb0U7QUFDTDtBQUNQO0FBQzFCO0FBQzBEO0FBQ3JCO0FBQ1Y7QUFxQjFELGdEQUFnRDtBQUNoRCxTQUFTYSxXQUFXLEtBQXdIO1FBQXhILEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxXQUFXLEVBQTBGLEdBQXhIOztJQUNuQixNQUFNQyxVQUFVaEIsNkNBQU1BLENBQWM7SUFDcEMsTUFBTSxDQUFDaUIsWUFBWUMsY0FBYyxHQUFHakIsK0NBQVFBLENBQXFCO0lBRWpFLDBDQUEwQztJQUMxQ0MsZ0RBQVNBO2dDQUFDO1lBQ1QsTUFBTWlCO3VEQUFpQjtvQkFDdEIsSUFBSTt3QkFDSCxzQ0FBc0M7d0JBQ3RDLE1BQU0sRUFBRUMsY0FBYyxFQUFFLEdBQUcsTUFBTSxpUkFBaUQ7d0JBQ2xGLE1BQU1DLFdBQVcsSUFBSUQ7d0JBRXJCLDJDQUEyQzt3QkFDM0MsTUFBTUUsaUJBQWlCOzRCQUN0QkMsYUFBYVYsT0FBT1UsV0FBVzs0QkFDL0JDLFFBQVFYLE9BQU9XLE1BQU07NEJBQ3JCQyxrQkFBa0JaLE9BQU9hLGFBQWE7NEJBQ3RDQyxhQUFhZCxPQUFPZSxRQUFROzRCQUM1QkMsYUFBYWhCLE9BQU9pQixRQUFROzRCQUM1QkMsc0JBQXNCbEIsT0FBT21CLGdCQUFnQjs0QkFDN0NBLGtCQUFrQm5CLE9BQU9tQixnQkFBZ0I7NEJBQ3pDQyxXQUFXcEIsT0FBT29CLFNBQVM7NEJBQzNCQyxlQUFlckIsT0FBT3NCLGFBQWE7d0JBQ3BDO3dCQUVBLHlDQUF5Qzt3QkFDekMsTUFBTUMsU0FBUyxNQUFNZixTQUFTZ0Isa0JBQWtCLENBQUN4QixPQUFPVSxXQUFXLEVBQUVEO3dCQUVyRSxJQUFJYyxVQUFVQSxPQUFPRSxJQUFJLEVBQUU7NEJBQzFCcEIsY0FBY2tC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dkNDLE9BQU87Z0JBQ1BILE9BQU87b0JBQ05qQixVQUFVO29CQUNWcUIsS0FBSztvQkFDTEMsTUFBTTtvQkFDTkMsT0FBTztvQkFDUEMsUUFBUTtnQkFDVDswQkFFQSw0RUFBQzVHLDJDQUFRQTtvQkFBQzZHLFVBQVU7O3NDQUNuQiw4REFBQ3JDOzRCQUFZOUQsUUFBUUE7Ozs7OztzQ0FDckIsOERBQUNQLDREQUFhQTs0QkFBQzJHLFdBQVc7NEJBQU1DLFlBQVk7NEJBQU1DLGNBQWM7NEJBQU1DLGFBQWE7NEJBQUdDLGFBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS3hHO0lBL0JnQnJCO01BQUFBIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9zcmMvY29tcG9uZW50cy9nZW5lcmF0b3JzL3BsYW5ldC1yZW5kZXJlci0zZC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBwbGFuZXQtcmVuZGVyZXItM2QudHN4XG4gKiBAZGVzY3JpcHRpb24gRW5oYW5jZWQgcGxhbmV0IHJlbmRlcmVyIHdpdGggUmVhY3QgVGhyZWUgRmliZXIgYW5kIDNEIFVJXG4gKiBAdmVyc2lvbiAyLjAuMFxuICogQGF1dGhvciBHYWxhY3RpYyBDbGFucyBEZXZlbG9wbWVudCBUZWFtXG4gKi9cblxuXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIFN1c3BlbnNlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBDYW52YXMsIHVzZUZyYW1lLCB1c2VUaHJlZSB9IGZyb20gXCJAcmVhY3QtdGhyZWUvZmliZXJcIjtcbmltcG9ydCB7IE9yYml0Q29udHJvbHMsIFN0YXJzIH0gZnJvbSBcIkByZWFjdC10aHJlZS9kcmVpXCI7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IFBsYW5ldENsYXNzLCBnZXRQbGFuZXRUeXBlQnlDbGFzcyB9IGZyb20gXCJAL3NoYXJlZC9wcm9jZ2VuL3BsYW5ldC9wbGFuZXQtdHlwZXNcIjtcbmltcG9ydCB7IFBsYW5ldEluZm9DYXJkM0QgfSBmcm9tIFwiQC9jb21wb25lbnRzL3VpL1BsYW5ldEluZm9DYXJkM0RcIjtcbmltcG9ydCB7IEhvbG9ncmFwaGljU3R5bGUgfSBmcm9tIFwiQC9jb21wb25lbnRzL3VpL0NhcmQzRFwiO1xuXG5pbnRlcmZhY2UgU2ltcGxlUGxhbmV0Q29uZmlnIHtcblx0cGxhbmV0Q2xhc3M6IFBsYW5ldENsYXNzO1xuXHRyYWRpdXM6IG51bWJlcjtcblx0Y29sb3I6IHN0cmluZztcblx0aGFzUmluZ3M6IGJvb2xlYW47XG5cdGhhc01vb25zOiBib29sZWFuO1xuXHRoYXNBdG1vc3BoZXJlOiBib29sZWFuO1xuXHQvLyBTdXJmYWNlIERldGFpbHMgKE5FVylcblx0ZW5hYmxlVmVnZXRhdGlvbjogYm9vbGVhbjtcblx0dHJlZUNvdW50OiBudW1iZXI7XG5cdHN1cmZhY2VEZXRhaWw6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFBsYW5ldFJlbmRlcmVyM0RQcm9wcyB7XG5cdGNvbmZpZzogU2ltcGxlUGxhbmV0Q29uZmlnO1xuXHRpc0xvYWRpbmc6IGJvb2xlYW47XG5cdG9uTG9hZGluZ0NoYW5nZTogKGxvYWRpbmc6IGJvb2xlYW4pID0+IHZvaWQ7XG59XG5cbi8vIFBsYW5ldCBNZXNoIENvbXBvbmVudCB3aXRoIGhvdmVyIGludGVyYWN0aW9uc1xuZnVuY3Rpb24gUGxhbmV0TWVzaCh7IGNvbmZpZywgb25Ib3Zlciwgb25Ib3ZlckV4aXQgfTogeyBjb25maWc6IFNpbXBsZVBsYW5ldENvbmZpZzsgb25Ib3ZlcjogKGV2ZW50OiBhbnkpID0+IHZvaWQ7IG9uSG92ZXJFeGl0OiAoKSA9PiB2b2lkIH0pIHtcblx0Y29uc3QgbWVzaFJlZiA9IHVzZVJlZjxUSFJFRS5Hcm91cD4obnVsbCk7XG5cdGNvbnN0IFtwbGFuZXRNZXNoLCBzZXRQbGFuZXRNZXNoXSA9IHVzZVN0YXRlPFRIUkVFLkdyb3VwIHwgbnVsbD4obnVsbCk7XG5cblx0Ly8gR2VuZXJhdGUgcGxhbmV0IHVzaW5nIGVuaGFuY2VkIHJlbmRlcmVyXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0Y29uc3QgZ2VuZXJhdGVQbGFuZXQgPSBhc3luYyAoKSA9PiB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJbXBvcnQgdGhlIGVuaGFuY2VkIHBsYW5ldCByZW5kZXJlclxuXHRcdFx0XHRjb25zdCB7IFBsYW5ldFJlbmRlcmVyIH0gPSBhd2FpdCBpbXBvcnQoXCJAL3NoYXJlZC9wcm9jZ2VuL3BsYW5ldC9wbGFuZXQtcmVuZGVyZXJcIik7XG5cdFx0XHRcdGNvbnN0IHJlbmRlcmVyID0gbmV3IFBsYW5ldFJlbmRlcmVyKCk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBzaW1wbGUgY29uZmlnIHRvIGVuaGFuY2VkIGNvbmZpZ1xuXHRcdFx0XHRjb25zdCBlbmhhbmNlZENvbmZpZyA9IHtcblx0XHRcdFx0XHRwbGFuZXRDbGFzczogY29uZmlnLnBsYW5ldENsYXNzLFxuXHRcdFx0XHRcdHJhZGl1czogY29uZmlnLnJhZGl1cyxcblx0XHRcdFx0XHRlbmFibGVBdG1vc3BoZXJlOiBjb25maWcuaGFzQXRtb3NwaGVyZSxcblx0XHRcdFx0XHRlbmFibGVSaW5nczogY29uZmlnLmhhc1JpbmdzLFxuXHRcdFx0XHRcdGVuYWJsZU1vb25zOiBjb25maWcuaGFzTW9vbnMsXG5cdFx0XHRcdFx0ZW5hYmxlU3VyZmFjZURldGFpbHM6IGNvbmZpZy5lbmFibGVWZWdldGF0aW9uLFxuXHRcdFx0XHRcdGVuYWJsZVZlZ2V0YXRpb246IGNvbmZpZy5lbmFibGVWZWdldGF0aW9uLFxuXHRcdFx0XHRcdHRyZWVDb3VudDogY29uZmlnLnRyZWVDb3VudCxcblx0XHRcdFx0XHR0ZXJyYWluRGV0YWlsOiBjb25maWcuc3VyZmFjZURldGFpbCxcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBHZW5lcmF0ZSBwbGFuZXQgd2l0aCBlbmhhbmNlZCByZW5kZXJlclxuXHRcdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCByZW5kZXJlci5yZW5kZXJQbGFuZXRCeVR5cGUoY29uZmlnLnBsYW5ldENsYXNzLCBlbmhhbmNlZENvbmZpZyk7XG5cblx0XHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQubWVzaCkge1xuXHRcdFx0XHRcdHNldFBsYW5ldE1lc2gocmVzdWx0Lm1lc2gpO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwi8J+MjSBbUExBTkVUXSBHZW5lcmF0ZWQgd2l0aCB2ZWdldGF0aW9uOlwiLCByZXN1bHQubWV0YWRhdGEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIGJhc2ljIGdlbmVyYXRpb25cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCLwn4yNIFtQTEFORVRdIFVzaW5nIGZhbGxiYWNrIGdlbmVyYXRpb25cIik7XG5cdFx0XHRcdFx0Z2VuZXJhdGVCYXNpY1BsYW5ldCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwi8J+MjSBbUExBTkVUXSBFcnJvciBnZW5lcmF0aW5nIHBsYW5ldDpcIiwgZXJyb3IpO1xuXHRcdFx0XHRnZW5lcmF0ZUJhc2ljUGxhbmV0KCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGNvbnN0IGdlbmVyYXRlQmFzaWNQbGFuZXQgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBwbGFuZXRHcm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuXG5cdFx0XHQvLyBNYWluIHBsYW5ldFxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoY29uZmlnLnJhZGl1cywgNjQsIDY0KTtcblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoeyBjb2xvcjogY29uZmlnLmNvbG9yIH0pO1xuXHRcdFx0Y29uc3QgcGxhbmV0ID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHBsYW5ldC5jYXN0U2hhZG93ID0gdHJ1ZTtcblx0XHRcdHBsYW5ldC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcblx0XHRcdHBsYW5ldEdyb3VwLmFkZChwbGFuZXQpO1xuXG5cdFx0XHQvLyBBZGQgYXRtb3NwaGVyZVxuXHRcdFx0aWYgKGNvbmZpZy5oYXNBdG1vc3BoZXJlKSB7XG5cdFx0XHRcdGNvbnN0IGF0bW9zcGhlcmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShjb25maWcucmFkaXVzICogMS4wNSwgMzIsIDMyKTtcblx0XHRcdFx0Y29uc3QgYXRtb3NwaGVyZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0XHRjb2xvcjogMHg4N2NlZWIsXG5cdFx0XHRcdFx0dHJhbnNwYXJlbnQ6IHRydWUsXG5cdFx0XHRcdFx0b3BhY2l0eTogMC4yLFxuXHRcdFx0XHRcdHNpZGU6IFRIUkVFLkJhY2tTaWRlLFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y29uc3QgYXRtb3NwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKGF0bW9zcGhlcmVHZW9tZXRyeSwgYXRtb3NwaGVyZU1hdGVyaWFsKTtcblx0XHRcdFx0cGxhbmV0R3JvdXAuYWRkKGF0bW9zcGhlcmUpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXRQbGFuZXRNZXNoKHBsYW5ldEdyb3VwKTtcblx0XHR9O1xuXG5cdFx0Z2VuZXJhdGVQbGFuZXQoKTtcblx0fSwgW2NvbmZpZ10pO1xuXG5cdC8vIEFkZCB0aGUgcGxhbmV0IG1lc2ggdG8gdGhlIHNjZW5lXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKG1lc2hSZWYuY3VycmVudCAmJiBwbGFuZXRNZXNoKSB7XG5cdFx0XHQvLyBDbGVhciBleGlzdGluZyBjaGlsZHJlblxuXHRcdFx0d2hpbGUgKG1lc2hSZWYuY3VycmVudC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdG1lc2hSZWYuY3VycmVudC5yZW1vdmUobWVzaFJlZi5jdXJyZW50LmNoaWxkcmVuWzBdKTtcblx0XHRcdH1cblx0XHRcdC8vIEFkZCB0aGUgbmV3IHBsYW5ldCBtZXNoXG5cdFx0XHRtZXNoUmVmLmN1cnJlbnQuYWRkKHBsYW5ldE1lc2gpO1xuXHRcdH1cblx0fSwgW3BsYW5ldE1lc2hdKTtcblxuXHQvLyBSb3RhdGlvbiBhbmltYXRpb25cblx0dXNlRnJhbWUoKCkgPT4ge1xuXHRcdGlmIChtZXNoUmVmLmN1cnJlbnQpIHtcblx0XHRcdG1lc2hSZWYuY3VycmVudC5yb3RhdGlvbi55ICs9IDAuMDA1O1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIDxncm91cCByZWY9e21lc2hSZWZ9IG9uUG9pbnRlckVudGVyPXtvbkhvdmVyfSBvblBvaW50ZXJMZWF2ZT17b25Ib3ZlckV4aXR9IC8+O1xufVxuXG4vLyBTY2VuZSBDb21wb25lbnRcbmZ1bmN0aW9uIFBsYW5ldFNjZW5lKHsgY29uZmlnIH06IHsgY29uZmlnOiBTaW1wbGVQbGFuZXRDb25maWcgfSkge1xuXHRjb25zdCBbaXNIb3ZlcmluZywgc2V0SXNIb3ZlcmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cdGNvbnN0IFtob3ZlclBvc2l0aW9uLCBzZXRIb3ZlclBvc2l0aW9uXSA9IHVzZVN0YXRlPFtudW1iZXIsIG51bWJlciwgbnVtYmVyXT4oWzAsIDAsIDBdKTtcblxuXHRjb25zdCBoYW5kbGVIb3ZlciA9IChldmVudDogYW55KSA9PiB7XG5cdFx0c2V0SXNIb3ZlcmluZyh0cnVlKTtcblx0XHQvLyBQb3NpdGlvbiB0aGUgaW5mbyBjYXJkIGFib3ZlIHRoZSBwbGFuZXRcblx0XHRzZXRIb3ZlclBvc2l0aW9uKFtjb25maWcucmFkaXVzICsgMiwgY29uZmlnLnJhZGl1cyArIDEsIDBdKTtcblx0fTtcblxuXHRjb25zdCBoYW5kbGVIb3ZlckV4aXQgPSAoKSA9PiB7XG5cdFx0c2V0SXNIb3ZlcmluZyhmYWxzZSk7XG5cdH07XG5cblx0Ly8gR2V0IHBsYW5ldCB0eXBlIGZvciBpbmZvIGNhcmRcblx0Y29uc3QgcGxhbmV0VHlwZSA9IGdldFBsYW5ldFR5cGVCeUNsYXNzKGNvbmZpZy5wbGFuZXRDbGFzcyk7XG5cblx0cmV0dXJuIChcblx0XHQ8PlxuXHRcdFx0ey8qIExpZ2h0aW5nICovfVxuXHRcdFx0PGFtYmllbnRMaWdodCBpbnRlbnNpdHk9ezAuNH0gLz5cblx0XHRcdDxkaXJlY3Rpb25hbExpZ2h0IHBvc2l0aW9uPXtbNSwgNSwgNV19IGludGVuc2l0eT17MX0gY2FzdFNoYWRvdyAvPlxuXG5cdFx0XHR7LyogUGxhbmV0IHdpdGggaG92ZXIgaW50ZXJhY3Rpb25zICovfVxuXHRcdFx0PFBsYW5ldE1lc2ggY29uZmlnPXtjb25maWd9IG9uSG92ZXI9e2hhbmRsZUhvdmVyfSBvbkhvdmVyRXhpdD17aGFuZGxlSG92ZXJFeGl0fSAvPlxuXG5cdFx0XHR7LyogM0QgSW5mbyBDYXJkIC0gc2hvd3Mgb24gaG92ZXIgKi99XG5cdFx0XHR7cGxhbmV0VHlwZSAmJiAoXG5cdFx0XHRcdDxQbGFuZXRJbmZvQ2FyZDNEXG5cdFx0XHRcdFx0cGxhbmV0VHlwZT17cGxhbmV0VHlwZX1cblx0XHRcdFx0XHRwb3NpdGlvbj17aG92ZXJQb3NpdGlvbn1cblx0XHRcdFx0XHR2aXNpYmxlPXtpc0hvdmVyaW5nfVxuXHRcdFx0XHRcdHBsYW5ldENvbmZpZz17e1xuXHRcdFx0XHRcdFx0cmFkaXVzOiBjb25maWcucmFkaXVzLFxuXHRcdFx0XHRcdFx0dHJlZUNvdW50OiBjb25maWcuZW5hYmxlVmVnZXRhdGlvbiA/IGNvbmZpZy50cmVlQ291bnQgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRlbmFibGVWZWdldGF0aW9uOiBjb25maWcuZW5hYmxlVmVnZXRhdGlvbixcblx0XHRcdFx0XHR9fVxuXHRcdFx0XHQvPlxuXHRcdFx0KX1cblxuXHRcdFx0ey8qIEJhY2tncm91bmQgc3RhcnMgKi99XG5cdFx0XHQ8U3RhcnMgcmFkaXVzPXs1MH0gZGVwdGg9ezUwfSBjb3VudD17NTAwMH0gZmFjdG9yPXs0fSBzYXR1cmF0aW9uPXswfSBmYWRlPXt0cnVlfSAvPlxuXHRcdDwvPlxuXHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUGxhbmV0UmVuZGVyZXIzRCh7IGNvbmZpZywgaXNMb2FkaW5nLCBvbkxvYWRpbmdDaGFuZ2UgfTogUGxhbmV0UmVuZGVyZXIzRFByb3BzKSB7XG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0Ly8gU2ltdWxhdGUgbG9hZGluZ1xuXHRcdG9uTG9hZGluZ0NoYW5nZSh0cnVlKTtcblx0XHRjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0b25Mb2FkaW5nQ2hhbmdlKGZhbHNlKTtcblx0XHR9LCAxMDAwKTtcblx0XHRyZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0fSwgW2NvbmZpZywgb25Mb2FkaW5nQ2hhbmdlXSk7XG5cblx0cmV0dXJuIChcblx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgcHQtMTZcIiBzdHlsZT17eyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH19PlxuXHRcdFx0PEhvbG9ncmFwaGljU3R5bGUgLz5cblx0XHRcdDxDYW52YXNcblx0XHRcdFx0Y2FtZXJhPXt7IHBvc2l0aW9uOiBbMCwgMCwgOF0sIGZvdjogNzUgfX1cblx0XHRcdFx0c2hhZG93c1xuXHRcdFx0XHRzdHlsZT17e1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG5cdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0d2lkdGg6IFwiMTAwJVwiLFxuXHRcdFx0XHRcdGhlaWdodDogXCIxMDAlXCIsXG5cdFx0XHRcdH19XG5cdFx0XHQ+XG5cdFx0XHRcdDxTdXNwZW5zZSBmYWxsYmFjaz17bnVsbH0+XG5cdFx0XHRcdFx0PFBsYW5ldFNjZW5lIGNvbmZpZz17Y29uZmlnfSAvPlxuXHRcdFx0XHRcdDxPcmJpdENvbnRyb2xzIGVuYWJsZVBhbj17dHJ1ZX0gZW5hYmxlWm9vbT17dHJ1ZX0gZW5hYmxlUm90YXRlPXt0cnVlfSBtaW5EaXN0YW5jZT17M30gbWF4RGlzdGFuY2U9ezIwfSAvPlxuXHRcdFx0XHQ8L1N1c3BlbnNlPlxuXHRcdFx0PC9DYW52YXM+XG5cdFx0PC9kaXY+XG5cdCk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIlN1c3BlbnNlIiwiQ2FudmFzIiwidXNlRnJhbWUiLCJPcmJpdENvbnRyb2xzIiwiU3RhcnMiLCJUSFJFRSIsImdldFBsYW5ldFR5cGVCeUNsYXNzIiwiUGxhbmV0SW5mb0NhcmQzRCIsIkhvbG9ncmFwaGljU3R5bGUiLCJQbGFuZXRNZXNoIiwiY29uZmlnIiwib25Ib3ZlciIsIm9uSG92ZXJFeGl0IiwibWVzaFJlZiIsInBsYW5ldE1lc2giLCJzZXRQbGFuZXRNZXNoIiwiZ2VuZXJhdGVQbGFuZXQiLCJQbGFuZXRSZW5kZXJlciIsInJlbmRlcmVyIiwiZW5oYW5jZWRDb25maWciLCJwbGFuZXRDbGFzcyIsInJhZGl1cyIsImVuYWJsZUF0bW9zcGhlcmUiLCJoYXNBdG1vc3BoZXJlIiwiZW5hYmxlUmluZ3MiLCJoYXNSaW5ncyIsImVuYWJsZU1vb25zIiwiaGFzTW9vbnMiLCJlbmFibGVTdXJmYWNlRGV0YWlscyIsImVuYWJsZVZlZ2V0YXRpb24iLCJ0cmVlQ291bnQiLCJ0ZXJyYWluRGV0YWlsIiwic3VyZmFjZURldGFpbCIsInJlc3VsdCIsInJlbmRlclBsYW5ldEJ5VHlwZSIsIm1lc2giLCJjb25zb2xlIiwibG9nIiwibWV0YWRhdGEiLCJ3YXJuIiwiZ2VuZXJhdGVCYXNpY1BsYW5ldCIsImVycm9yIiwicGxhbmV0R3JvdXAiLCJHcm91cCIsImdlb21ldHJ5IiwiU3BoZXJlR2VvbWV0cnkiLCJtYXRlcmlhbCIsIk1lc2hMYW1iZXJ0TWF0ZXJpYWwiLCJjb2xvciIsInBsYW5ldCIsIk1lc2giLCJjYXN0U2hhZG93IiwicmVjZWl2ZVNoYWRvdyIsImFkZCIsImF0bW9zcGhlcmVHZW9tZXRyeSIsImF0bW9zcGhlcmVNYXRlcmlhbCIsIk1lc2hCYXNpY01hdGVyaWFsIiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5Iiwic2lkZSIsIkJhY2tTaWRlIiwiYXRtb3NwaGVyZSIsImN1cnJlbnQiLCJjaGlsZHJlbiIsImxlbmd0aCIsInJlbW92ZSIsInJvdGF0aW9uIiwieSIsImdyb3VwIiwicmVmIiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsIlBsYW5ldFNjZW5lIiwiaXNIb3ZlcmluZyIsInNldElzSG92ZXJpbmciLCJob3ZlclBvc2l0aW9uIiwic2V0SG92ZXJQb3NpdGlvbiIsImhhbmRsZUhvdmVyIiwiZXZlbnQiLCJoYW5kbGVIb3ZlckV4aXQiLCJwbGFuZXRUeXBlIiwiYW1iaWVudExpZ2h0IiwiaW50ZW5zaXR5IiwiZGlyZWN0aW9uYWxMaWdodCIsInBvc2l0aW9uIiwidmlzaWJsZSIsInBsYW5ldENvbmZpZyIsInVuZGVmaW5lZCIsImRlcHRoIiwiY291bnQiLCJmYWN0b3IiLCJzYXR1cmF0aW9uIiwiZmFkZSIsIlBsYW5ldFJlbmRlcmVyM0QiLCJpc0xvYWRpbmciLCJvbkxvYWRpbmdDaGFuZ2UiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJkaXYiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNhbWVyYSIsImZvdiIsInNoYWRvd3MiLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJmYWxsYmFjayIsImVuYWJsZVBhbiIsImVuYWJsZVpvb20iLCJlbmFibGVSb3RhdGUiLCJtaW5EaXN0YW5jZSIsIm1heERpc3RhbmNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/generators/planet-renderer-3d.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/Card3D.tsx":
/*!**************************************!*\
  !*** ./src/components/ui/Card3D.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Card3D: () => (/* binding */ Card3D),\n/* harmony export */   HolographicStyle: () => (/* binding */ HolographicStyle)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-jsx/style */ \"(app-pages-browser)/./node_modules/styled-jsx/style.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/web/Html.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/utils */ \"(app-pages-browser)/./src/utils/utils.ts\");\n/**\n * @file Card3D.tsx\n * @description Immersive 3D UI card component inspired by Tom Clancy's The Division\n * @version 1.0.0\n * @author Galactic Clans Development Team\n */ /* __next_internal_client_entry_do_not_use__ Card3D,HolographicStyle auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n// Simple Card components for 3D UI\nconst Card = (param)=>{\n    let { children, className, style, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_3__.cn)(\"rounded-lg border bg-card text-card-foreground shadow-sm\", className),\n        style: style,\n        ...props,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/byronwade/cosmic/src/components/ui/Card3D.tsx\",\n        lineNumber: 18,\n        columnNumber: 2\n    }, undefined);\n};\n_c = Card;\nconst CardHeader = (param)=>{\n    let { children, className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_3__.cn)(\"flex flex-col space-y-1.5 p-6\", className),\n        ...props,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/byronwade/cosmic/src/components/ui/Card3D.tsx\",\n        lineNumber: 24,\n        columnNumber: 2\n    }, undefined);\n};\n_c1 = CardHeader;\nconst CardTitle = (param)=>{\n    let { children, className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n        className: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_3__.cn)(\"text-2xl font-semibold leading-none tracking-tight\", className),\n        ...props,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/byronwade/cosmic/src/components/ui/Card3D.tsx\",\n        lineNumber: 30,\n        columnNumber: 2\n    }, undefined);\n};\n_c2 = CardTitle;\nconst CardContent = (param)=>{\n    let { children, className, ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_3__.cn)(\"p-6 pt-0\", className),\n        ...props,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/byronwade/cosmic/src/components/ui/Card3D.tsx\",\n        lineNumber: 36,\n        columnNumber: 2\n    }, undefined);\n};\n_c3 = CardContent;\nfunction Card3D(param) {\n    let { position = [\n        0,\n        0,\n        0\n    ], lookAtCamera = true, followCamera = false, trigger = \"hover\", visible = trigger === \"always\", onEnter, onExit, onClick, className = \"\", holographic = true, glowColor = \"#00ff88\", title, children, occlusionAware = false, distanceFade = true, maxDistance = 10 } = param;\n    _s();\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const htmlRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const [isVisible, setIsVisible] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(visible);\n    const [opacity, setOpacity] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(visible ? 1 : 0);\n    const { camera } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C)();\n    // Handle visibility state\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Card3D.useEffect\": ()=>{\n            if (trigger === \"always\") {\n                setIsVisible(true);\n                setOpacity(1);\n            } else {\n                setIsVisible(visible);\n                setOpacity(visible ? 1 : 0);\n            }\n        }\n    }[\"Card3D.useEffect\"], [\n        visible,\n        trigger\n    ]);\n    // Animation frame updates\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D)({\n        \"Card3D.useFrame\": (state)=>{\n            if (!groupRef.current) return;\n            // Billboard behavior - look at camera\n            if (lookAtCamera) {\n                groupRef.current.lookAt(camera.position);\n            }\n            // Follow camera behavior\n            if (followCamera) {\n                const targetPosition = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(...position);\n                const cameraDirection = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n                camera.getWorldDirection(cameraDirection);\n                targetPosition.add(cameraDirection.multiplyScalar(-2));\n                groupRef.current.position.lerp(targetPosition, 0.05);\n            }\n            // Distance-based fade\n            if (distanceFade) {\n                const distance = camera.position.distanceTo(groupRef.current.position);\n                const fadeOpacity = Math.max(0, 1 - distance / maxDistance);\n                setOpacity({\n                    \"Card3D.useFrame\": (prev)=>isVisible ? fadeOpacity : 0\n                }[\"Card3D.useFrame\"]);\n            }\n            // Smooth opacity animation\n            if (htmlRef.current && htmlRef.current.style) {\n                const targetOpacity = isVisible ? distanceFade ? opacity : 1 : 0;\n                const currentOpacity = parseFloat(htmlRef.current.style.opacity || \"0\");\n                const newOpacity = three__WEBPACK_IMPORTED_MODULE_5__.MathUtils.lerp(currentOpacity, targetOpacity, 0.1);\n                htmlRef.current.style.opacity = newOpacity.toString();\n                // Handle visibility for performance\n                if (newOpacity < 0.01) {\n                    htmlRef.current.style.display = \"none\";\n                } else {\n                    htmlRef.current.style.display = \"block\";\n                }\n            }\n        }\n    }[\"Card3D.useFrame\"]);\n    // Handle mouse interactions\n    const handlePointerEnter = ()=>{\n        if (trigger === \"hover\") {\n            setIsVisible(true);\n            onEnter === null || onEnter === void 0 ? void 0 : onEnter();\n        }\n    };\n    const handlePointerLeave = ()=>{\n        if (trigger === \"hover\") {\n            setIsVisible(false);\n            onExit === null || onExit === void 0 ? void 0 : onExit();\n        }\n    };\n    const handleClick = ()=>{\n        if (trigger === \"click\") {\n            setIsVisible(!isVisible);\n        }\n        onClick === null || onClick === void 0 ? void 0 : onClick();\n    };\n    // Build holographic styles\n    const holographicStyles = holographic ? {\n        background: \"linear-gradient(135deg, \\n\t\t\trgba(0, 255, 136, 0.1) 0%, \\n\t\t\trgba(0, 191, 255, 0.1) 50%, \\n\t\t\trgba(138, 43, 226, 0.1) 100%)\",\n        backdropFilter: \"blur(16px)\",\n        border: \"1px solid \".concat(glowColor, \"40\"),\n        boxShadow: \"\\n\t\t\t0 0 20px \".concat(glowColor, \"40,\\n\t\t\t0 0 40px \").concat(glowColor, \"20,\\n\t\t\tinset 0 0 20px rgba(255, 255, 255, 0.1)\\n\t\t\")\n    } : {};\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n        ref: groupRef,\n        position: position,\n        onPointerEnter: handlePointerEnter,\n        onPointerLeave: handlePointerLeave,\n        onClick: handleClick,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_6__.Html, {\n            ref: htmlRef,\n            center: true,\n            transform: true,\n            sprite: true,\n            style: {\n                pointerEvents: isVisible ? \"auto\" : \"none\",\n                transition: \"all 0.3s cubic-bezier(0.4, 0, 0.2, 1)\",\n                ...holographicStyles\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Card, {\n                className: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_3__.cn)(\"w-80 min-h-32 transition-all duration-300\", \"bg-slate-900/90 border-cyan-400/50 text-white\", \"backdrop-blur-xl shadow-2xl\", isVisible ? \"scale-100 opacity-100\" : \"scale-95 opacity-0\", holographic && \"animate-pulse-glow\", className),\n                style: {\n                    transform: isVisible ? \"translateY(0) scale(1)\" : \"translateY(10px) scale(0.95)\",\n                    ...holographicStyles\n                },\n                children: [\n                    title && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CardHeader, {\n                        className: \"pb-3\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CardTitle, {\n                            className: \"text-cyan-400 font-bold text-lg flex items-center space-x-2\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-2 h-2 bg-cyan-400 rounded-full animate-pulse\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/Card3D.tsx\",\n                                    lineNumber: 190,\n                                    columnNumber: 9\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    children: title\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/Card3D.tsx\",\n                                    lineNumber: 191,\n                                    columnNumber: 9\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/Card3D.tsx\",\n                            lineNumber: 189,\n                            columnNumber: 8\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/ui/Card3D.tsx\",\n                        lineNumber: 188,\n                        columnNumber: 7\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CardContent, {\n                        className: \"pt-0\",\n                        children: children\n                    }, void 0, false, {\n                        fileName: \"/Users/byronwade/cosmic/src/components/ui/Card3D.tsx\",\n                        lineNumber: 195,\n                        columnNumber: 6\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/byronwade/cosmic/src/components/ui/Card3D.tsx\",\n                lineNumber: 180,\n                columnNumber: 5\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/byronwade/cosmic/src/components/ui/Card3D.tsx\",\n            lineNumber: 169,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/byronwade/cosmic/src/components/ui/Card3D.tsx\",\n        lineNumber: 168,\n        columnNumber: 3\n    }, this);\n}\n_s(Card3D, \"LPKknwsvUm2QN651ox3cgtod7bw=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.D\n    ];\n});\n_c4 = Card3D;\n// Additional styling component for holographic effects\nconst HolographicStyle = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default()), {\n        id: \"fb985dcf79b14b4\",\n        children: \"@keyframes pulse-glow{0%,100%{box-shadow:0 0 20px rgba(0,255,136,.4),0 0 40px rgba(0,255,136,.2),inset 0 0 20px rgba(255,255,255,.1)}50%{box-shadow:0 0 30px rgba(0,255,136,.6),0 0 60px rgba(0,255,136,.3),inset 0 0 30px rgba(255,255,255,.15)}}.animate-pulse-glow{animation:pulse-glow 2s ease-in-out infinite}\"\n    }, void 0, false, void 0, undefined);\n_c5 = HolographicStyle;\nvar _c, _c1, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"Card\");\n$RefreshReg$(_c1, \"CardHeader\");\n$RefreshReg$(_c2, \"CardTitle\");\n$RefreshReg$(_c3, \"CardContent\");\n$RefreshReg$(_c4, \"Card3D\");\n$RefreshReg$(_c5, \"HolographicStyle\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL0NhcmQzRC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQzs7O0FBSTBEO0FBQ2xCO0FBQ2U7QUFDekI7QUFDSTtBQUVuQyxtQ0FBbUM7QUFDbkMsTUFBTVMsT0FBTztRQUFDLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxLQUFLLEVBQUUsR0FBR0MsT0FBWTt5QkFDMUQsOERBQUNDO1FBQUlILFdBQVdILGdEQUFFQSxDQUFDLDREQUE0REc7UUFBWUMsT0FBT0E7UUFBUSxHQUFHQyxLQUFLO2tCQUNoSEg7Ozs7Ozs7S0FGR0Q7QUFNTixNQUFNTSxhQUFhO1FBQUMsRUFBRUwsUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBR0UsT0FBWTt5QkFDekQsOERBQUNDO1FBQUlILFdBQVdILGdEQUFFQSxDQUFDLGlDQUFpQ0c7UUFBYSxHQUFHRSxLQUFLO2tCQUN2RUg7Ozs7Ozs7TUFGR0s7QUFNTixNQUFNQyxZQUFZO1FBQUMsRUFBRU4sUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBR0UsT0FBWTt5QkFDeEQsOERBQUNJO1FBQUdOLFdBQVdILGdEQUFFQSxDQUFDLHNEQUFzREc7UUFBYSxHQUFHRSxLQUFLO2tCQUMzRkg7Ozs7Ozs7TUFGR007QUFNTixNQUFNRSxjQUFjO1FBQUMsRUFBRVIsUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBR0UsT0FBWTt5QkFDMUQsOERBQUNDO1FBQUlILFdBQVdILGdEQUFFQSxDQUFDLFlBQVlHO1FBQWEsR0FBR0UsS0FBSztrQkFDbERIOzs7Ozs7O01BRkdRO0FBa0NDLFNBQVNDLE9BQU8sS0FBd1M7UUFBeFMsRUFBRUMsV0FBVztRQUFDO1FBQUc7UUFBRztLQUFFLEVBQUVDLGVBQWUsSUFBSSxFQUFFQyxlQUFlLEtBQUssRUFBRUMsVUFBVSxPQUFPLEVBQUVDLFVBQVVELFlBQVksUUFBUSxFQUFFRSxPQUFPLEVBQUVDLE1BQU0sRUFBRUMs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QldBIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9zcmMvY29tcG9uZW50cy91aS9DYXJkM0QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgQ2FyZDNELnRzeFxuICogQGRlc2NyaXB0aW9uIEltbWVyc2l2ZSAzRCBVSSBjYXJkIGNvbXBvbmVudCBpbnNwaXJlZCBieSBUb20gQ2xhbmN5J3MgVGhlIERpdmlzaW9uXG4gKiBAdmVyc2lvbiAxLjAuMFxuICogQGF1dGhvciBHYWxhY3RpYyBDbGFucyBEZXZlbG9wbWVudCBUZWFtXG4gKi9cblxuXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEh0bWwgfSBmcm9tIFwiQHJlYWN0LXRocmVlL2RyZWlcIjtcbmltcG9ydCB7IHVzZUZyYW1lLCB1c2VUaHJlZSB9IGZyb20gXCJAcmVhY3QtdGhyZWUvZmliZXJcIjtcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgY24gfSBmcm9tIFwiQC91dGlscy91dGlsc1wiO1xuXG4vLyBTaW1wbGUgQ2FyZCBjb21wb25lbnRzIGZvciAzRCBVSVxuY29uc3QgQ2FyZCA9ICh7IGNoaWxkcmVuLCBjbGFzc05hbWUsIHN0eWxlLCAuLi5wcm9wcyB9OiBhbnkpID0+IChcblx0PGRpdiBjbGFzc05hbWU9e2NuKFwicm91bmRlZC1sZyBib3JkZXIgYmctY2FyZCB0ZXh0LWNhcmQtZm9yZWdyb3VuZCBzaGFkb3ctc21cIiwgY2xhc3NOYW1lKX0gc3R5bGU9e3N0eWxlfSB7Li4ucHJvcHN9PlxuXHRcdHtjaGlsZHJlbn1cblx0PC9kaXY+XG4pO1xuXG5jb25zdCBDYXJkSGVhZGVyID0gKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucHJvcHMgfTogYW55KSA9PiAoXG5cdDxkaXYgY2xhc3NOYW1lPXtjbihcImZsZXggZmxleC1jb2wgc3BhY2UteS0xLjUgcC02XCIsIGNsYXNzTmFtZSl9IHsuLi5wcm9wc30+XG5cdFx0e2NoaWxkcmVufVxuXHQ8L2Rpdj5cbik7XG5cbmNvbnN0IENhcmRUaXRsZSA9ICh7IGNoaWxkcmVuLCBjbGFzc05hbWUsIC4uLnByb3BzIH06IGFueSkgPT4gKFxuXHQ8aDMgY2xhc3NOYW1lPXtjbihcInRleHQtMnhsIGZvbnQtc2VtaWJvbGQgbGVhZGluZy1ub25lIHRyYWNraW5nLXRpZ2h0XCIsIGNsYXNzTmFtZSl9IHsuLi5wcm9wc30+XG5cdFx0e2NoaWxkcmVufVxuXHQ8L2gzPlxuKTtcblxuY29uc3QgQ2FyZENvbnRlbnQgPSAoeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9OiBhbnkpID0+IChcblx0PGRpdiBjbGFzc05hbWU9e2NuKFwicC02IHB0LTBcIiwgY2xhc3NOYW1lKX0gey4uLnByb3BzfT5cblx0XHR7Y2hpbGRyZW59XG5cdDwvZGl2PlxuKTtcblxuaW50ZXJmYWNlIENhcmQzRFByb3BzIHtcblx0Ly8gM0QgUG9zaXRpb25pbmdcblx0cG9zaXRpb24/OiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5cdGxvb2tBdENhbWVyYT86IGJvb2xlYW47XG5cdGZvbGxvd0NhbWVyYT86IGJvb2xlYW47XG5cblx0Ly8gSW50ZXJhY3Rpb25cblx0dHJpZ2dlcj86IFwiaG92ZXJcIiB8IFwiY2xpY2tcIiB8IFwiYWx3YXlzXCI7XG5cdHZpc2libGU/OiBib29sZWFuO1xuXHRvbkVudGVyPzogKCkgPT4gdm9pZDtcblx0b25FeGl0PzogKCkgPT4gdm9pZDtcblx0b25DbGljaz86ICgpID0+IHZvaWQ7XG5cblx0Ly8gU3R5bGluZ1xuXHRjbGFzc05hbWU/OiBzdHJpbmc7XG5cdGhvbG9ncmFwaGljPzogYm9vbGVhbjtcblx0Z2xvd0NvbG9yPzogc3RyaW5nO1xuXG5cdC8vIENvbnRlbnRcblx0dGl0bGU/OiBzdHJpbmc7XG5cdGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG5cblx0Ly8gUGVyZm9ybWFuY2Vcblx0b2NjbHVzaW9uQXdhcmU/OiBib29sZWFuO1xuXHRkaXN0YW5jZUZhZGU/OiBib29sZWFuO1xuXHRtYXhEaXN0YW5jZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENhcmQzRCh7IHBvc2l0aW9uID0gWzAsIDAsIDBdLCBsb29rQXRDYW1lcmEgPSB0cnVlLCBmb2xsb3dDYW1lcmEgPSBmYWxzZSwgdHJpZ2dlciA9IFwiaG92ZXJcIiwgdmlzaWJsZSA9IHRyaWdnZXIgPT09IFwiYWx3YXlzXCIsIG9uRW50ZXIsIG9uRXhpdCwgb25DbGljaywgY2xhc3NOYW1lID0gXCJcIiwgaG9sb2dyYXBoaWMgPSB0cnVlLCBnbG93Q29sb3IgPSBcIiMwMGZmODhcIiwgdGl0bGUsIGNoaWxkcmVuLCBvY2NsdXNpb25Bd2FyZSA9IGZhbHNlLCBkaXN0YW5jZUZhZGUgPSB0cnVlLCBtYXhEaXN0YW5jZSA9IDEwIH06IENhcmQzRFByb3BzKSB7XG5cdGNvbnN0IGdyb3VwUmVmID0gdXNlUmVmPFRIUkVFLkdyb3VwPihudWxsKTtcblx0Y29uc3QgaHRtbFJlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xuXHRjb25zdCBbaXNWaXNpYmxlLCBzZXRJc1Zpc2libGVdID0gdXNlU3RhdGUodmlzaWJsZSk7XG5cdGNvbnN0IFtvcGFjaXR5LCBzZXRPcGFjaXR5XSA9IHVzZVN0YXRlKHZpc2libGUgPyAxIDogMCk7XG5cdGNvbnN0IHsgY2FtZXJhIH0gPSB1c2VUaHJlZSgpO1xuXG5cdC8vIEhhbmRsZSB2aXNpYmlsaXR5IHN0YXRlXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKHRyaWdnZXIgPT09IFwiYWx3YXlzXCIpIHtcblx0XHRcdHNldElzVmlzaWJsZSh0cnVlKTtcblx0XHRcdHNldE9wYWNpdHkoMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldElzVmlzaWJsZSh2aXNpYmxlKTtcblx0XHRcdHNldE9wYWNpdHkodmlzaWJsZSA/IDEgOiAwKTtcblx0XHR9XG5cdH0sIFt2aXNpYmxlLCB0cmlnZ2VyXSk7XG5cblx0Ly8gQW5pbWF0aW9uIGZyYW1lIHVwZGF0ZXNcblx0dXNlRnJhbWUoKHN0YXRlKSA9PiB7XG5cdFx0aWYgKCFncm91cFJlZi5jdXJyZW50KSByZXR1cm47XG5cblx0XHQvLyBCaWxsYm9hcmQgYmVoYXZpb3IgLSBsb29rIGF0IGNhbWVyYVxuXHRcdGlmIChsb29rQXRDYW1lcmEpIHtcblx0XHRcdGdyb3VwUmVmLmN1cnJlbnQubG9va0F0KGNhbWVyYS5wb3NpdGlvbik7XG5cdFx0fVxuXG5cdFx0Ly8gRm9sbG93IGNhbWVyYSBiZWhhdmlvclxuXHRcdGlmIChmb2xsb3dDYW1lcmEpIHtcblx0XHRcdGNvbnN0IHRhcmdldFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoLi4ucG9zaXRpb24pO1xuXHRcdFx0Y29uc3QgY2FtZXJhRGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdGNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihjYW1lcmFEaXJlY3Rpb24pO1xuXHRcdFx0dGFyZ2V0UG9zaXRpb24uYWRkKGNhbWVyYURpcmVjdGlvbi5tdWx0aXBseVNjYWxhcigtMikpO1xuXHRcdFx0Z3JvdXBSZWYuY3VycmVudC5wb3NpdGlvbi5sZXJwKHRhcmdldFBvc2l0aW9uLCAwLjA1KTtcblx0XHR9XG5cblx0XHQvLyBEaXN0YW5jZS1iYXNlZCBmYWRlXG5cdFx0aWYgKGRpc3RhbmNlRmFkZSkge1xuXHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBjYW1lcmEucG9zaXRpb24uZGlzdGFuY2VUbyhncm91cFJlZi5jdXJyZW50LnBvc2l0aW9uKTtcblx0XHRcdGNvbnN0IGZhZGVPcGFjaXR5ID0gTWF0aC5tYXgoMCwgMSAtIGRpc3RhbmNlIC8gbWF4RGlzdGFuY2UpO1xuXHRcdFx0c2V0T3BhY2l0eSgocHJldikgPT4gKGlzVmlzaWJsZSA/IGZhZGVPcGFjaXR5IDogMCkpO1xuXHRcdH1cblxuXHRcdC8vIFNtb290aCBvcGFjaXR5IGFuaW1hdGlvblxuXHRcdGlmIChodG1sUmVmLmN1cnJlbnQgJiYgaHRtbFJlZi5jdXJyZW50LnN0eWxlKSB7XG5cdFx0XHRjb25zdCB0YXJnZXRPcGFjaXR5ID0gaXNWaXNpYmxlID8gKGRpc3RhbmNlRmFkZSA/IG9wYWNpdHkgOiAxKSA6IDA7XG5cdFx0XHRjb25zdCBjdXJyZW50T3BhY2l0eSA9IHBhcnNlRmxvYXQoaHRtbFJlZi5jdXJyZW50LnN0eWxlLm9wYWNpdHkgfHwgXCIwXCIpO1xuXHRcdFx0Y29uc3QgbmV3T3BhY2l0eSA9IFRIUkVFLk1hdGhVdGlscy5sZXJwKGN1cnJlbnRPcGFjaXR5LCB0YXJnZXRPcGFjaXR5LCAwLjEpO1xuXHRcdFx0aHRtbFJlZi5jdXJyZW50LnN0eWxlLm9wYWNpdHkgPSBuZXdPcGFjaXR5LnRvU3RyaW5nKCk7XG5cblx0XHRcdC8vIEhhbmRsZSB2aXNpYmlsaXR5IGZvciBwZXJmb3JtYW5jZVxuXHRcdFx0aWYgKG5ld09wYWNpdHkgPCAwLjAxKSB7XG5cdFx0XHRcdGh0bWxSZWYuY3VycmVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRodG1sUmVmLmN1cnJlbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8vIEhhbmRsZSBtb3VzZSBpbnRlcmFjdGlvbnNcblx0Y29uc3QgaGFuZGxlUG9pbnRlckVudGVyID0gKCkgPT4ge1xuXHRcdGlmICh0cmlnZ2VyID09PSBcImhvdmVyXCIpIHtcblx0XHRcdHNldElzVmlzaWJsZSh0cnVlKTtcblx0XHRcdG9uRW50ZXI/LigpO1xuXHRcdH1cblx0fTtcblxuXHRjb25zdCBoYW5kbGVQb2ludGVyTGVhdmUgPSAoKSA9PiB7XG5cdFx0aWYgKHRyaWdnZXIgPT09IFwiaG92ZXJcIikge1xuXHRcdFx0c2V0SXNWaXNpYmxlKGZhbHNlKTtcblx0XHRcdG9uRXhpdD8uKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IGhhbmRsZUNsaWNrID0gKCkgPT4ge1xuXHRcdGlmICh0cmlnZ2VyID09PSBcImNsaWNrXCIpIHtcblx0XHRcdHNldElzVmlzaWJsZSghaXNWaXNpYmxlKTtcblx0XHR9XG5cdFx0b25DbGljaz8uKCk7XG5cdH07XG5cblx0Ly8gQnVpbGQgaG9sb2dyYXBoaWMgc3R5bGVzXG5cdGNvbnN0IGhvbG9ncmFwaGljU3R5bGVzID0gaG9sb2dyYXBoaWNcblx0XHQ/IHtcblx0XHRcdFx0YmFja2dyb3VuZDogYGxpbmVhci1ncmFkaWVudCgxMzVkZWcsIFxuXHRcdFx0cmdiYSgwLCAyNTUsIDEzNiwgMC4xKSAwJSwgXG5cdFx0XHRyZ2JhKDAsIDE5MSwgMjU1LCAwLjEpIDUwJSwgXG5cdFx0XHRyZ2JhKDEzOCwgNDMsIDIyNiwgMC4xKSAxMDAlKWAsXG5cdFx0XHRcdGJhY2tkcm9wRmlsdGVyOiBcImJsdXIoMTZweClcIixcblx0XHRcdFx0Ym9yZGVyOiBgMXB4IHNvbGlkICR7Z2xvd0NvbG9yfTQwYCxcblx0XHRcdFx0Ym94U2hhZG93OiBgXG5cdFx0XHQwIDAgMjBweCAke2dsb3dDb2xvcn00MCxcblx0XHRcdDAgMCA0MHB4ICR7Z2xvd0NvbG9yfTIwLFxuXHRcdFx0aW5zZXQgMCAwIDIwcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpXG5cdFx0YCxcblx0XHQgIH1cblx0XHQ6IHt9O1xuXG5cdHJldHVybiAoXG5cdFx0PGdyb3VwIHJlZj17Z3JvdXBSZWZ9IHBvc2l0aW9uPXtwb3NpdGlvbn0gb25Qb2ludGVyRW50ZXI9e2hhbmRsZVBvaW50ZXJFbnRlcn0gb25Qb2ludGVyTGVhdmU9e2hhbmRsZVBvaW50ZXJMZWF2ZX0gb25DbGljaz17aGFuZGxlQ2xpY2t9PlxuXHRcdFx0PEh0bWxcblx0XHRcdFx0cmVmPXtodG1sUmVmfVxuXHRcdFx0XHRjZW50ZXJcblx0XHRcdFx0dHJhbnNmb3JtXG5cdFx0XHRcdHNwcml0ZVxuXHRcdFx0XHRzdHlsZT17e1xuXHRcdFx0XHRcdHBvaW50ZXJFdmVudHM6IGlzVmlzaWJsZSA/IFwiYXV0b1wiIDogXCJub25lXCIsXG5cdFx0XHRcdFx0dHJhbnNpdGlvbjogXCJhbGwgMC4zcyBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpXCIsXG5cdFx0XHRcdFx0Li4uaG9sb2dyYXBoaWNTdHlsZXMsXG5cdFx0XHRcdH19XG5cdFx0XHQ+XG5cdFx0XHRcdDxDYXJkXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbihcInctODAgbWluLWgtMzIgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwXCIsIFwiYmctc2xhdGUtOTAwLzkwIGJvcmRlci1jeWFuLTQwMC81MCB0ZXh0LXdoaXRlXCIsIFwiYmFja2Ryb3AtYmx1ci14bCBzaGFkb3ctMnhsXCIsIGlzVmlzaWJsZSA/IFwic2NhbGUtMTAwIG9wYWNpdHktMTAwXCIgOiBcInNjYWxlLTk1IG9wYWNpdHktMFwiLCBob2xvZ3JhcGhpYyAmJiBcImFuaW1hdGUtcHVsc2UtZ2xvd1wiLCBjbGFzc05hbWUpfVxuXHRcdFx0XHRcdHN0eWxlPXt7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm06IGlzVmlzaWJsZSA/IFwidHJhbnNsYXRlWSgwKSBzY2FsZSgxKVwiIDogXCJ0cmFuc2xhdGVZKDEwcHgpIHNjYWxlKDAuOTUpXCIsXG5cdFx0XHRcdFx0XHQuLi5ob2xvZ3JhcGhpY1N0eWxlcyxcblx0XHRcdFx0XHR9fVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0e3RpdGxlICYmIChcblx0XHRcdFx0XHRcdDxDYXJkSGVhZGVyIGNsYXNzTmFtZT1cInBiLTNcIj5cblx0XHRcdFx0XHRcdFx0PENhcmRUaXRsZSBjbGFzc05hbWU9XCJ0ZXh0LWN5YW4tNDAwIGZvbnQtYm9sZCB0ZXh0LWxnIGZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMlwiPlxuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwidy0yIGgtMiBiZy1jeWFuLTQwMCByb3VuZGVkLWZ1bGwgYW5pbWF0ZS1wdWxzZVwiPjwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuPnt0aXRsZX08L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDwvQ2FyZFRpdGxlPlxuXHRcdFx0XHRcdFx0PC9DYXJkSGVhZGVyPlxuXHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0PENhcmRDb250ZW50IGNsYXNzTmFtZT1cInB0LTBcIj57Y2hpbGRyZW59PC9DYXJkQ29udGVudD5cblx0XHRcdFx0PC9DYXJkPlxuXHRcdFx0PC9IdG1sPlxuXHRcdDwvZ3JvdXA+XG5cdCk7XG59XG5cbi8vIEFkZGl0aW9uYWwgc3R5bGluZyBjb21wb25lbnQgZm9yIGhvbG9ncmFwaGljIGVmZmVjdHNcbmV4cG9ydCBjb25zdCBIb2xvZ3JhcGhpY1N0eWxlID0gKCkgPT4gKFxuXHQ8c3R5bGUganN4IGdsb2JhbD57YFxuXHRcdEBrZXlmcmFtZXMgcHVsc2UtZ2xvdyB7XG5cdFx0XHQwJSxcblx0XHRcdDEwMCUge1xuXHRcdFx0XHRib3gtc2hhZG93OiAwIDAgMjBweCByZ2JhKDAsIDI1NSwgMTM2LCAwLjQpLCAwIDAgNDBweCByZ2JhKDAsIDI1NSwgMTM2LCAwLjIpLCBpbnNldCAwIDAgMjBweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7XG5cdFx0XHR9XG5cdFx0XHQ1MCUge1xuXHRcdFx0XHRib3gtc2hhZG93OiAwIDAgMzBweCByZ2JhKDAsIDI1NSwgMTM2LCAwLjYpLCAwIDAgNjBweCByZ2JhKDAsIDI1NSwgMTM2LCAwLjMpLCBpbnNldCAwIDAgMzBweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5hbmltYXRlLXB1bHNlLWdsb3cge1xuXHRcdFx0YW5pbWF0aW9uOiBwdWxzZS1nbG93IDJzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xuXHRcdH1cblx0YH08L3N0eWxlPlxuKTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiSHRtbCIsInVzZUZyYW1lIiwidXNlVGhyZWUiLCJUSFJFRSIsImNuIiwiQ2FyZCIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJwcm9wcyIsImRpdiIsIkNhcmRIZWFkZXIiLCJDYXJkVGl0bGUiLCJoMyIsIkNhcmRDb250ZW50IiwiQ2FyZDNEIiwicG9zaXRpb24iLCJsb29rQXRDYW1lcmEiLCJmb2xsb3dDYW1lcmEiLCJ0cmlnZ2VyIiwidmlzaWJsZSIsIm9uRW50ZXIiLCJvbkV4aXQiLCJvbkNsaWNrIiwiaG9sb2dyYXBoaWMiLCJnbG93Q29sb3IiLCJ0aXRsZSIsIm9jY2x1c2lvbkF3YXJlIiwiZGlzdGFuY2VGYWRlIiwibWF4RGlzdGFuY2UiLCJncm91cFJlZiIsImh0bWxSZWYiLCJpc1Zpc2libGUiLCJzZXRJc1Zpc2libGUiLCJvcGFjaXR5Iiwic2V0T3BhY2l0eSIsImNhbWVyYSIsInN0YXRlIiwiY3VycmVudCIsImxvb2tBdCIsInRhcmdldFBvc2l0aW9uIiwiVmVjdG9yMyIsImNhbWVyYURpcmVjdGlvbiIsImdldFdvcmxkRGlyZWN0aW9uIiwiYWRkIiwibXVsdGlwbHlTY2FsYXIiLCJsZXJwIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiZmFkZU9wYWNpdHkiLCJNYXRoIiwibWF4IiwicHJldiIsInRhcmdldE9wYWNpdHkiLCJjdXJyZW50T3BhY2l0eSIsInBhcnNlRmxvYXQiLCJuZXdPcGFjaXR5IiwiTWF0aFV0aWxzIiwidG9TdHJpbmciLCJkaXNwbGF5IiwiaGFuZGxlUG9pbnRlckVudGVyIiwiaGFuZGxlUG9pbnRlckxlYXZlIiwiaGFuZGxlQ2xpY2siLCJob2xvZ3JhcGhpY1N0eWxlcyIsImJhY2tncm91bmQiLCJiYWNrZHJvcEZpbHRlciIsImJvcmRlciIsImJveFNoYWRvdyIsImdyb3VwIiwicmVmIiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsImNlbnRlciIsInRyYW5zZm9ybSIsInNwcml0ZSIsInBvaW50ZXJFdmVudHMiLCJ0cmFuc2l0aW9uIiwic3BhbiIsIkhvbG9ncmFwaGljU3R5bGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/Card3D.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/PlanetInfoCard3D.tsx":
/*!************************************************!*\
  !*** ./src/components/ui/PlanetInfoCard3D.tsx ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlanetInfoCard3D: () => (/* binding */ PlanetInfoCard3D)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Card3D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Card3D */ \"(app-pages-browser)/./src/components/ui/Card3D.tsx\");\n/* harmony import */ var _barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=Atom,Droplets,Gauge,Globe,Mountain,Thermometer,TreePine,Wind,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/globe.js\");\n/* harmony import */ var _barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=Atom,Droplets,Gauge,Globe,Mountain,Thermometer,TreePine,Wind,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/gauge.js\");\n/* harmony import */ var _barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=Atom,Droplets,Gauge,Globe,Mountain,Thermometer,TreePine,Wind,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/mountain.js\");\n/* harmony import */ var _barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=Atom,Droplets,Gauge,Globe,Mountain,Thermometer,TreePine,Wind,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/thermometer.js\");\n/* harmony import */ var _barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=Atom,Droplets,Gauge,Globe,Mountain,Thermometer,TreePine,Wind,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/wind.js\");\n/* harmony import */ var _barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Atom,Droplets,Gauge,Globe,Mountain,Thermometer,TreePine,Wind,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/atom.js\");\n/* harmony import */ var _barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=Atom,Droplets,Gauge,Globe,Mountain,Thermometer,TreePine,Wind,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/tree-pine.js\");\n/* harmony import */ var _barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! __barrel_optimize__?names=Atom,Droplets,Gauge,Globe,Mountain,Thermometer,TreePine,Wind,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/droplets.js\");\n/* harmony import */ var _barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! __barrel_optimize__?names=Atom,Droplets,Gauge,Globe,Mountain,Thermometer,TreePine,Wind,Zap!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/zap.js\");\n/**\n * @file PlanetInfoCard3D.tsx\n * @description Immersive 3D planet information card for hover interactions\n * @version 1.0.0\n * @author Galactic Clans Development Team\n */ /* __next_internal_client_entry_do_not_use__ PlanetInfoCard3D auto */ \n\n\n// Simple Badge component for 3D UI\nconst Badge = (param)=>{\n    let { children, variant = \"default\", className = \"\", ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n        className: \"inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium \".concat(variant === \"outline\" ? \"border border-current bg-transparent\" : \"bg-gray-800 text-gray-200\", \" \").concat(className),\n        ...props,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n        lineNumber: 16,\n        columnNumber: 2\n    }, undefined);\n};\n_c = Badge;\n\nfunction PlanetInfoCard3D(param) {\n    let { planetType, position, visible, onEnter, onExit, planetConfig } = param;\n    // Generate atmospheric analysis\n    const getAtmosphericData = ()=>{\n        const composition = planetType.atmosphereComposition.slice(0, 3);\n        return composition.map((gas, index)=>({\n                gas,\n                percentage: index === 0 ? 60 + Math.random() * 20 : 10 + Math.random() * 15\n            }));\n    };\n    // Get threat assessment color\n    const getThreatColor = ()=>{\n        const danger = planetType.dangerLevel;\n        if (danger <= 3) return \"text-green-400\";\n        if (danger <= 6) return \"text-yellow-400\";\n        return \"text-red-400\";\n    };\n    // Get habitability assessment\n    const getHabitabilityStatus = ()=>{\n        const score = planetType.baseHabitability.overallScore;\n        if (score >= 80) return {\n            status: \"OPTIMAL\",\n            color: \"text-green-400\",\n            icon: \"🌍\"\n        };\n        if (score >= 60) return {\n            status: \"HABITABLE\",\n            color: \"text-blue-400\",\n            icon: \"🌎\"\n        };\n        if (score >= 40) return {\n            status: \"MARGINAL\",\n            color: \"text-yellow-400\",\n            icon: \"🌕\"\n        };\n        return {\n            status: \"HOSTILE\",\n            color: \"text-red-400\",\n            icon: \"☠️\"\n        };\n    };\n    const atmosphericData = getAtmosphericData();\n    const habitabilityStatus = getHabitabilityStatus();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Card3D__WEBPACK_IMPORTED_MODULE_2__.Card3D, {\n        position: position,\n        visible: visible,\n        trigger: \"hover\",\n        title: planetType.name,\n        glowColor: \"#00ff88\",\n        onEnter: onEnter,\n        onExit: onExit,\n        className: \"w-96\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"space-y-4\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-between\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-2\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                    className: \"w-4 h-4 text-cyan-400\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 71,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-sm text-slate-300\",\n                                    children: \"Classification\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 72,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 70,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Badge, {\n                            variant: \"outline\",\n                            className: \"bg-cyan-500/20 border-cyan-400/50 text-cyan-300\",\n                            children: planetType.class.replace(\"_\", \" \").toUpperCase()\n                        }, void 0, false, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 74,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                    lineNumber: 69,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-between\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-2\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-xl\",\n                                    children: habitabilityStatus.icon\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 82,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-sm text-slate-300\",\n                                    children: \"Habitability\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 83,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 81,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-2\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-sm font-bold \".concat(habitabilityStatus.color),\n                                    children: habitabilityStatus.status\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 86,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-xs text-slate-400\",\n                                    children: [\n                                        \"(\",\n                                        planetType.baseHabitability.overallScore,\n                                        \"%)\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 87,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 85,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                    lineNumber: 80,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"grid grid-cols-2 gap-3 py-2 border-t border-slate-700/50\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"space-y-2\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex items-center space-x-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                            className: \"w-3 h-3 text-blue-400\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                            lineNumber: 95,\n                                            columnNumber: 8\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-xs text-slate-400\",\n                                            children: \"Mass Range\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                            lineNumber: 96,\n                                            columnNumber: 8\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 94,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-sm text-white font-mono\",\n                                    children: [\n                                        planetType.massRange[0],\n                                        \"-\",\n                                        planetType.massRange[1],\n                                        \" M⊕\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 98,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 93,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"space-y-2\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex items-center space-x-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                            className: \"w-3 h-3 text-orange-400\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                            lineNumber: 105,\n                                            columnNumber: 8\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-xs text-slate-400\",\n                                            children: \"Radius Range\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                            lineNumber: 106,\n                                            columnNumber: 8\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 104,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-sm text-white font-mono\",\n                                    children: [\n                                        planetType.radiusRange[0],\n                                        \"-\",\n                                        planetType.radiusRange[1],\n                                        \" R⊕\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 108,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 103,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                    lineNumber: 92,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-between\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-2\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                                    className: \"w-4 h-4 text-red-400\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 117,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-sm text-slate-300\",\n                                    children: \"Temperature\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 118,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 116,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"text-sm text-white font-mono\",\n                            children: [\n                                planetType.temperatureRange[0],\n                                \"-\",\n                                planetType.temperatureRange[1],\n                                \"K\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 120,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                    lineNumber: 115,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"space-y-2\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-2\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                    className: \"w-4 h-4 text-purple-400\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 128,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-sm text-slate-300\",\n                                    children: \"Atmosphere\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 129,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 127,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"space-y-1\",\n                            children: atmosphericData.map((component, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex justify-between items-center\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-xs text-slate-400 capitalize\",\n                                            children: component.gas.replace(\"_\", \" \")\n                                        }, void 0, false, {\n                                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                            lineNumber: 134,\n                                            columnNumber: 9\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-xs text-cyan-300 font-mono\",\n                                            children: [\n                                                component.percentage.toFixed(1),\n                                                \"%\"\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                            lineNumber: 135,\n                                            columnNumber: 9\n                                        }, this)\n                                    ]\n                                }, index, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 133,\n                                    columnNumber: 8\n                                }, this))\n                        }, void 0, false, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 131,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                    lineNumber: 126,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"space-y-2 border-t border-slate-700/50 pt-3\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-2\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                    className: \"w-4 h-4 text-green-400\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 144,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-sm text-slate-300\",\n                                    children: \"Key Features\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 145,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 143,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex flex-wrap gap-1\",\n                            children: [\n                                planetType.features.forests && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Badge, {\n                                    variant: \"outline\",\n                                    className: \"text-xs bg-green-500/20 border-green-400/50 text-green-300\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                            className: \"w-3 h-3 mr-1\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                            lineNumber: 150,\n                                            columnNumber: 9\n                                        }, this),\n                                        \"Forests\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 149,\n                                    columnNumber: 8\n                                }, this),\n                                planetType.features.oceans && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Badge, {\n                                    variant: \"outline\",\n                                    className: \"text-xs bg-blue-500/20 border-blue-400/50 text-blue-300\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                            className: \"w-3 h-3 mr-1\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                            lineNumber: 156,\n                                            columnNumber: 9\n                                        }, this),\n                                        \"Oceans\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 155,\n                                    columnNumber: 8\n                                }, this),\n                                planetType.features.atmosphericGlow && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Badge, {\n                                    variant: \"outline\",\n                                    className: \"text-xs bg-purple-500/20 border-purple-400/50 text-purple-300\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                                            className: \"w-3 h-3 mr-1\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                            lineNumber: 162,\n                                            columnNumber: 9\n                                        }, this),\n                                        \"Aurora\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 161,\n                                    columnNumber: 8\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 147,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                    lineNumber: 142,\n                    columnNumber: 5\n                }, this),\n                (planetConfig === null || planetConfig === void 0 ? void 0 : planetConfig.enableVegetation) && planetConfig.treeCount && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"bg-green-500/10 border border-green-400/30 rounded-lg p-3\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center justify-between\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex items-center space-x-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Atom_Droplets_Gauge_Globe_Mountain_Thermometer_TreePine_Wind_Zap_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                            className: \"w-4 h-4 text-green-400\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                            lineNumber: 174,\n                                            columnNumber: 9\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-sm text-green-300 font-medium\",\n                                            children: \"Surface Vegetation\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                            lineNumber: 175,\n                                            columnNumber: 9\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 173,\n                                    columnNumber: 8\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-xs text-green-400 font-mono\",\n                                    children: [\n                                        planetConfig.treeCount.toLocaleString(),\n                                        \" trees\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 177,\n                                    columnNumber: 8\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 172,\n                            columnNumber: 7\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-xs text-green-200 mt-1\",\n                            children: \"Biome-specific flora detected. Biodiversity index: HIGH\"\n                        }, void 0, false, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 179,\n                            columnNumber: 7\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                    lineNumber: 171,\n                    columnNumber: 6\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"bg-slate-800/50 border border-slate-600/50 rounded-lg p-3 mt-4\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center justify-between\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-xs text-slate-400\",\n                                    children: \"Threat Level\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 186,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-sm font-bold \".concat(getThreatColor()),\n                                    children: [\n                                        planetType.dangerLevel,\n                                        \"/10\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 187,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 185,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center justify-between mt-1\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-xs text-slate-400\",\n                                    children: \"Scientific Value\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 190,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-sm text-cyan-400 font-bold\",\n                                    children: [\n                                        planetType.scientificValue,\n                                        \"/10\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                                    lineNumber: 191,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                            lineNumber: 189,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                    lineNumber: 184,\n                    columnNumber: 5\n                }, this),\n                planetType.realWorldExample && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-xs text-slate-500 italic border-t border-slate-700/30 pt-2\",\n                    children: [\n                        \"Similar to: \",\n                        planetType.realWorldExample\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n                    lineNumber: 196,\n                    columnNumber: 37\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n            lineNumber: 67,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/byronwade/cosmic/src/components/ui/PlanetInfoCard3D.tsx\",\n        lineNumber: 66,\n        columnNumber: 3\n    }, this);\n}\n_c1 = PlanetInfoCard3D;\nvar _c, _c1;\n$RefreshReg$(_c, \"Badge\");\n$RefreshReg$(_c1, \"PlanetInfoCard3D\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL1BsYW5ldEluZm9DYXJkM0QudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0M7QUFJeUI7QUFDUTtBQUdsQyxtQ0FBbUM7QUFDbkMsTUFBTUUsUUFBUTtRQUFDLEVBQUVDLFFBQVEsRUFBRUMsVUFBVSxTQUFTLEVBQUVDLFlBQVksRUFBRSxFQUFFLEdBQUdDLE9BQVk7eUJBQzlFLDhEQUFDQztRQUFLRixXQUFXLDJFQUEyS0EsT0FBaEdELFlBQVksWUFBWSx5Q0FBeUMsNkJBQTRCLEtBQWEsT0FBVkM7UUFBYyxHQUFHQyxLQUFLO2tCQUNoTkg7Ozs7Ozs7S0FGR0Q7QUFLa0c7QUFlakcsU0FBU2UsaUJBQWlCLEtBQXVGO1FBQXZGLEVBQUVDLFVBQVUsRUFBRUMsUUFBUSxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxZQUFZLEVBQXlCLEdBQXZGO0lBQ2hDLGdDQUFnQztJQUNoQyxNQUFNQyxxQkFBcUI7UUFDMUIsTUFBTUMsY0FBY1AsV0FBV1EscUJBQXFCLENBQUNDLEtBQUssQ0FBQyxHQUFHO1FBQzlELE9BQU9GLFlBQVlHLEdBQUcsQ0FBQyxDQUFDQyxLQUFLQyxRQUFXO2dCQUN2Q0Q7Z0JBQ0FFLFlBQVlELFVBQVUsSUFBSSxLQUFLRSxLQUFLQyxNQUFNLEtBQUssS0FBSyxLQUFLRCxLQUFLQyxNQUFNLEtBQUs7WUFDMUU7SUFDRDtJQUVBLDhCQUE4QjtJQUM5QixNQUFNQyxpQkFBaUI7UUFDdEIsTUFBTUMsU0FBU2pCLFdBQVdrQixXQUFXO1FBQ3JDLElBQUlELFVBQVUsR0FBRyxPQUFPO1FBQ3hCLElBQUlBLFVBQVUsR0FBRyxPQUFPO1FBQ3hCLE9BQU87SUFDUjtJQUVBLDhCQUE4QjtJQUM5QixNQUFNRSx3QkFBd0I7UUFDN0IsTUFBTUMsUUFBUXBCLFdBQVdxQixnQkFBZ0IsQ0FBQ0MsWUFBWTtRQUN0RCxJQUFJRixTQUFT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QVU7O3NEQUNsQyw4REFBQ1csNklBQUdBOzRDQUFDWCxXQUFVOzs7Ozs7d0NBQWlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQVFuQ2tCLENBQUFBLHlCQUFBQSxtQ0FBQUEsYUFBY3dDLGdCQUFnQixLQUFJeEMsYUFBYXlDLFNBQVMsa0JBQ3hELDhEQUFDZDtvQkFBSTdDLFdBQVU7O3NDQUNkLDhEQUFDNkM7NEJBQUk3QyxXQUFVOzs4Q0FDZCw4REFBQzZDO29DQUFJN0MsV0FBVTs7c0RBQ2QsOERBQUNVLDRJQUFRQTs0Q0FBQ1YsV0FBVTs7Ozs7O3NEQUNwQiw4REFBQ0U7NENBQUtGLFdBQVU7c0RBQXFDOzs7Ozs7Ozs7Ozs7OENBRXRELDhEQUFDRTtvQ0FBS0YsV0FBVTs7d0NBQW9Da0IsYUFBYXlDLFNBQVMsQ0FBQ0MsY0FBYzt3Q0FBRzs7Ozs7Ozs7Ozs7OztzQ0FFN0YsOERBQUNDOzRCQUFFN0QsV0FBVTtzQ0FBOEI7Ozs7Ozs7Ozs7Ozs4QkFLN0MsOERBQUM2QztvQkFBSTdDLFdBQVU7O3NDQUNkLDhEQUFDNkM7NEJBQUk3QyxXQUFVOzs4Q0FDZCw4REFBQ0U7b0NBQUtGLFdBQVU7OENBQXlCOzs7Ozs7OENBQ3pDLDhEQUFDRTtvQ0FBS0YsV0FBVyxxQkFBc0MsT0FBakI2Qjs7d0NBQXFCaEIsV0FBV2tCLFdBQVc7d0NBQUM7Ozs7Ozs7Ozs7Ozs7c0NBRW5GLDhEQUFDYzs0QkFBSTdDLFdBQVU7OzhDQUNkLDhEQUFDRTtvQ0FBS0YsV0FBVTs4Q0FBeUI7Ozs7Ozs4Q0FDekMsOERBQUNFO29DQUFLRixXQUFVOzt3Q0FBbUNhLFdBQVdpRCxlQUFlO3dDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQUsvRWpELFdBQVdrRCxnQkFBZ0Isa0JBQUksOERBQUNsQjtvQkFBSTdDLFdBQVU7O3dCQUFrRTt3QkFBYWEsV0FBV2tELGdCQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSTdKO01BcktnQm5EIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9zcmMvY29tcG9uZW50cy91aS9QbGFuZXRJbmZvQ2FyZDNELnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIFBsYW5ldEluZm9DYXJkM0QudHN4XG4gKiBAZGVzY3JpcHRpb24gSW1tZXJzaXZlIDNEIHBsYW5ldCBpbmZvcm1hdGlvbiBjYXJkIGZvciBob3ZlciBpbnRlcmFjdGlvbnNcbiAqIEB2ZXJzaW9uIDEuMC4wXG4gKiBAYXV0aG9yIEdhbGFjdGljIENsYW5zIERldmVsb3BtZW50IFRlYW1cbiAqL1xuXG5cInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgQ2FyZDNEIH0gZnJvbSBcIi4vQ2FyZDNEXCI7XG5pbXBvcnQgdHlwZSB7IFBsYW5ldFR5cGVEZWZpbml0aW9uIH0gZnJvbSBcIkAvc2hhcmVkL3Byb2NnZW4vcGxhbmV0L3BsYW5ldC10eXBlc1wiO1xuXG4vLyBTaW1wbGUgQmFkZ2UgY29tcG9uZW50IGZvciAzRCBVSVxuY29uc3QgQmFkZ2UgPSAoeyBjaGlsZHJlbiwgdmFyaWFudCA9IFwiZGVmYXVsdFwiLCBjbGFzc05hbWUgPSBcIlwiLCAuLi5wcm9wcyB9OiBhbnkpID0+IChcblx0PHNwYW4gY2xhc3NOYW1lPXtgaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIHJvdW5kZWQtZnVsbCBweC0yLjUgcHktMC41IHRleHQteHMgZm9udC1tZWRpdW0gJHt2YXJpYW50ID09PSBcIm91dGxpbmVcIiA/IFwiYm9yZGVyIGJvcmRlci1jdXJyZW50IGJnLXRyYW5zcGFyZW50XCIgOiBcImJnLWdyYXktODAwIHRleHQtZ3JheS0yMDBcIn0gJHtjbGFzc05hbWV9YH0gey4uLnByb3BzfT5cblx0XHR7Y2hpbGRyZW59XG5cdDwvc3Bhbj5cbik7XG5pbXBvcnQgeyBUaGVybW9tZXRlciwgRHJvcGxldHMsIFdpbmQsIE1vdW50YWluLCBHYXVnZSwgR2xvYmUsIEF0b20sIFRyZWVQaW5lLCBaYXAgfSBmcm9tIFwibHVjaWRlLXJlYWN0XCI7XG5cbmludGVyZmFjZSBQbGFuZXRJbmZvQ2FyZDNEUHJvcHMge1xuXHRwbGFuZXRUeXBlOiBQbGFuZXRUeXBlRGVmaW5pdGlvbjtcblx0cG9zaXRpb246IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblx0dmlzaWJsZTogYm9vbGVhbjtcblx0b25FbnRlcj86ICgpID0+IHZvaWQ7XG5cdG9uRXhpdD86ICgpID0+IHZvaWQ7XG5cdHBsYW5ldENvbmZpZz86IHtcblx0XHRyYWRpdXM6IG51bWJlcjtcblx0XHR0cmVlQ291bnQ/OiBudW1iZXI7XG5cdFx0ZW5hYmxlVmVnZXRhdGlvbj86IGJvb2xlYW47XG5cdH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQbGFuZXRJbmZvQ2FyZDNEKHsgcGxhbmV0VHlwZSwgcG9zaXRpb24sIHZpc2libGUsIG9uRW50ZXIsIG9uRXhpdCwgcGxhbmV0Q29uZmlnIH06IFBsYW5ldEluZm9DYXJkM0RQcm9wcykge1xuXHQvLyBHZW5lcmF0ZSBhdG1vc3BoZXJpYyBhbmFseXNpc1xuXHRjb25zdCBnZXRBdG1vc3BoZXJpY0RhdGEgPSAoKSA9PiB7XG5cdFx0Y29uc3QgY29tcG9zaXRpb24gPSBwbGFuZXRUeXBlLmF0bW9zcGhlcmVDb21wb3NpdGlvbi5zbGljZSgwLCAzKTtcblx0XHRyZXR1cm4gY29tcG9zaXRpb24ubWFwKChnYXMsIGluZGV4KSA9PiAoe1xuXHRcdFx0Z2FzLFxuXHRcdFx0cGVyY2VudGFnZTogaW5kZXggPT09IDAgPyA2MCArIE1hdGgucmFuZG9tKCkgKiAyMCA6IDEwICsgTWF0aC5yYW5kb20oKSAqIDE1LFxuXHRcdH0pKTtcblx0fTtcblxuXHQvLyBHZXQgdGhyZWF0IGFzc2Vzc21lbnQgY29sb3Jcblx0Y29uc3QgZ2V0VGhyZWF0Q29sb3IgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZGFuZ2VyID0gcGxhbmV0VHlwZS5kYW5nZXJMZXZlbDtcblx0XHRpZiAoZGFuZ2VyIDw9IDMpIHJldHVybiBcInRleHQtZ3JlZW4tNDAwXCI7XG5cdFx0aWYgKGRhbmdlciA8PSA2KSByZXR1cm4gXCJ0ZXh0LXllbGxvdy00MDBcIjtcblx0XHRyZXR1cm4gXCJ0ZXh0LXJlZC00MDBcIjtcblx0fTtcblxuXHQvLyBHZXQgaGFiaXRhYmlsaXR5IGFzc2Vzc21lbnRcblx0Y29uc3QgZ2V0SGFiaXRhYmlsaXR5U3RhdHVzID0gKCkgPT4ge1xuXHRcdGNvbnN0IHNjb3JlID0gcGxhbmV0VHlwZS5iYXNlSGFiaXRhYmlsaXR5Lm92ZXJhbGxTY29yZTtcblx0XHRpZiAoc2NvcmUgPj0gODApIHJldHVybiB7IHN0YXR1czogXCJPUFRJTUFMXCIsIGNvbG9yOiBcInRleHQtZ3JlZW4tNDAwXCIsIGljb246IFwi8J+MjVwiIH07XG5cdFx0aWYgKHNjb3JlID49IDYwKSByZXR1cm4geyBzdGF0dXM6IFwiSEFCSVRBQkxFXCIsIGNvbG9yOiBcInRleHQtYmx1ZS00MDBcIiwgaWNvbjogXCLwn4yOXCIgfTtcblx0XHRpZiAoc2NvcmUgPj0gNDApIHJldHVybiB7IHN0YXR1czogXCJNQVJHSU5BTFwiLCBjb2xvcjogXCJ0ZXh0LXllbGxvdy00MDBcIiwgaWNvbjogXCLwn4yVXCIgfTtcblx0XHRyZXR1cm4geyBzdGF0dXM6IFwiSE9TVElMRVwiLCBjb2xvcjogXCJ0ZXh0LXJlZC00MDBcIiwgaWNvbjogXCLimKDvuI9cIiB9O1xuXHR9O1xuXG5cdGNvbnN0IGF0bW9zcGhlcmljRGF0YSA9IGdldEF0bW9zcGhlcmljRGF0YSgpO1xuXHRjb25zdCBoYWJpdGFiaWxpdHlTdGF0dXMgPSBnZXRIYWJpdGFiaWxpdHlTdGF0dXMoKTtcblxuXHRyZXR1cm4gKFxuXHRcdDxDYXJkM0QgcG9zaXRpb249e3Bvc2l0aW9ufSB2aXNpYmxlPXt2aXNpYmxlfSB0cmlnZ2VyPVwiaG92ZXJcIiB0aXRsZT17cGxhbmV0VHlwZS5uYW1lfSBnbG93Q29sb3I9XCIjMDBmZjg4XCIgb25FbnRlcj17b25FbnRlcn0gb25FeGl0PXtvbkV4aXR9IGNsYXNzTmFtZT1cInctOTZcIj5cblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS00XCI+XG5cdFx0XHRcdHsvKiBQbGFuZXQgQ2xhc3NpZmljYXRpb24gKi99XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTJcIj5cblx0XHRcdFx0XHRcdDxHbG9iZSBjbGFzc05hbWU9XCJ3LTQgaC00IHRleHQtY3lhbi00MDBcIiAvPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXNsYXRlLTMwMFwiPkNsYXNzaWZpY2F0aW9uPC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxCYWRnZSB2YXJpYW50PVwib3V0bGluZVwiIGNsYXNzTmFtZT1cImJnLWN5YW4tNTAwLzIwIGJvcmRlci1jeWFuLTQwMC81MCB0ZXh0LWN5YW4tMzAwXCI+XG5cdFx0XHRcdFx0XHR7cGxhbmV0VHlwZS5jbGFzcy5yZXBsYWNlKFwiX1wiLCBcIiBcIikudG9VcHBlckNhc2UoKX1cblx0XHRcdFx0XHQ8L0JhZGdlPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHR7LyogSGFiaXRhYmlsaXR5IFN0YXR1cyAqL31cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMlwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwidGV4dC14bFwiPntoYWJpdGFiaWxpdHlTdGF0dXMuaWNvbn08L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtc2xhdGUtMzAwXCI+SGFiaXRhYmlsaXR5PC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0yXCI+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9e2B0ZXh0LXNtIGZvbnQtYm9sZCAke2hhYml0YWJpbGl0eVN0YXR1cy5jb2xvcn1gfT57aGFiaXRhYmlsaXR5U3RhdHVzLnN0YXR1c308L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtc2xhdGUtNDAwXCI+KHtwbGFuZXRUeXBlLmJhc2VIYWJpdGFiaWxpdHkub3ZlcmFsbFNjb3JlfSUpPC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHR7LyogUGh5c2ljYWwgUHJvcGVydGllcyAqL31cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0yIGdhcC0zIHB5LTIgYm9yZGVyLXQgYm9yZGVyLXNsYXRlLTcwMC81MFwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMlwiPlxuXHRcdFx0XHRcdFx0XHQ8R2F1Z2UgY2xhc3NOYW1lPVwidy0zIGgtMyB0ZXh0LWJsdWUtNDAwXCIgLz5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LXNsYXRlLTQwMFwiPk1hc3MgUmFuZ2U8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC13aGl0ZSBmb250LW1vbm9cIj5cblx0XHRcdFx0XHRcdFx0e3BsYW5ldFR5cGUubWFzc1JhbmdlWzBdfS17cGxhbmV0VHlwZS5tYXNzUmFuZ2VbMV19IE3iipVcblx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMlwiPlxuXHRcdFx0XHRcdFx0XHQ8TW91bnRhaW4gY2xhc3NOYW1lPVwidy0zIGgtMyB0ZXh0LW9yYW5nZS00MDBcIiAvPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtc2xhdGUtNDAwXCI+UmFkaXVzIFJhbmdlPC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtd2hpdGUgZm9udC1tb25vXCI+XG5cdFx0XHRcdFx0XHRcdHtwbGFuZXRUeXBlLnJhZGl1c1JhbmdlWzBdfS17cGxhbmV0VHlwZS5yYWRpdXNSYW5nZVsxXX0gUuKKlVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHR7LyogVGVtcGVyYXR1cmUgUmFuZ2UgKi99XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTJcIj5cblx0XHRcdFx0XHRcdDxUaGVybW9tZXRlciBjbGFzc05hbWU9XCJ3LTQgaC00IHRleHQtcmVkLTQwMFwiIC8+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtc2xhdGUtMzAwXCI+VGVtcGVyYXR1cmU8L3NwYW4+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXdoaXRlIGZvbnQtbW9ub1wiPlxuXHRcdFx0XHRcdFx0e3BsYW5ldFR5cGUudGVtcGVyYXR1cmVSYW5nZVswXX0te3BsYW5ldFR5cGUudGVtcGVyYXR1cmVSYW5nZVsxXX1LXG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHR7LyogQXRtb3NwaGVyaWMgQ29tcG9zaXRpb24gKi99XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTJcIj5cblx0XHRcdFx0XHRcdDxXaW5kIGNsYXNzTmFtZT1cInctNCBoLTQgdGV4dC1wdXJwbGUtNDAwXCIgLz5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1zbGF0ZS0zMDBcIj5BdG1vc3BoZXJlPC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0xXCI+XG5cdFx0XHRcdFx0XHR7YXRtb3NwaGVyaWNEYXRhLm1hcCgoY29tcG9uZW50LCBpbmRleCkgPT4gKFxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGtleT17aW5kZXh9IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlclwiPlxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1zbGF0ZS00MDAgY2FwaXRhbGl6ZVwiPntjb21wb25lbnQuZ2FzLnJlcGxhY2UoXCJfXCIsIFwiIFwiKX08L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWN5YW4tMzAwIGZvbnQtbW9ub1wiPntjb21wb25lbnQucGVyY2VudGFnZS50b0ZpeGVkKDEpfSU8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0KSl9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdHsvKiBSZXNvdXJjZXMgJiBGZWF0dXJlcyAqL31cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTIgYm9yZGVyLXQgYm9yZGVyLXNsYXRlLTcwMC81MCBwdC0zXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTJcIj5cblx0XHRcdFx0XHRcdDxBdG9tIGNsYXNzTmFtZT1cInctNCBoLTQgdGV4dC1ncmVlbi00MDBcIiAvPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXNsYXRlLTMwMFwiPktleSBGZWF0dXJlczwvc3Bhbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC13cmFwIGdhcC0xXCI+XG5cdFx0XHRcdFx0XHR7cGxhbmV0VHlwZS5mZWF0dXJlcy5mb3Jlc3RzICYmIChcblx0XHRcdFx0XHRcdFx0PEJhZGdlIHZhcmlhbnQ9XCJvdXRsaW5lXCIgY2xhc3NOYW1lPVwidGV4dC14cyBiZy1ncmVlbi01MDAvMjAgYm9yZGVyLWdyZWVuLTQwMC81MCB0ZXh0LWdyZWVuLTMwMFwiPlxuXHRcdFx0XHRcdFx0XHRcdDxUcmVlUGluZSBjbGFzc05hbWU9XCJ3LTMgaC0zIG1yLTFcIiAvPlxuXHRcdFx0XHRcdFx0XHRcdEZvcmVzdHNcblx0XHRcdFx0XHRcdFx0PC9CYWRnZT5cblx0XHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0XHR7cGxhbmV0VHlwZS5mZWF0dXJlcy5vY2VhbnMgJiYgKFxuXHRcdFx0XHRcdFx0XHQ8QmFkZ2UgdmFyaWFudD1cIm91dGxpbmVcIiBjbGFzc05hbWU9XCJ0ZXh0LXhzIGJnLWJsdWUtNTAwLzIwIGJvcmRlci1ibHVlLTQwMC81MCB0ZXh0LWJsdWUtMzAwXCI+XG5cdFx0XHRcdFx0XHRcdFx0PERyb3BsZXRzIGNsYXNzTmFtZT1cInctMyBoLTMgbXItMVwiIC8+XG5cdFx0XHRcdFx0XHRcdFx0T2NlYW5zXG5cdFx0XHRcdFx0XHRcdDwvQmFkZ2U+XG5cdFx0XHRcdFx0XHQpfVxuXHRcdFx0XHRcdFx0e3BsYW5ldFR5cGUuZmVhdHVyZXMuYXRtb3NwaGVyaWNHbG93ICYmIChcblx0XHRcdFx0XHRcdFx0PEJhZGdlIHZhcmlhbnQ9XCJvdXRsaW5lXCIgY2xhc3NOYW1lPVwidGV4dC14cyBiZy1wdXJwbGUtNTAwLzIwIGJvcmRlci1wdXJwbGUtNDAwLzUwIHRleHQtcHVycGxlLTMwMFwiPlxuXHRcdFx0XHRcdFx0XHRcdDxaYXAgY2xhc3NOYW1lPVwidy0zIGgtMyBtci0xXCIgLz5cblx0XHRcdFx0XHRcdFx0XHRBdXJvcmFcblx0XHRcdFx0XHRcdFx0PC9CYWRnZT5cblx0XHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdHsvKiBTdXJmYWNlIERldGFpbHMgKGlmIHZlZ2V0YXRpb24gZW5hYmxlZCkgKi99XG5cdFx0XHRcdHtwbGFuZXRDb25maWc/LmVuYWJsZVZlZ2V0YXRpb24gJiYgcGxhbmV0Q29uZmlnLnRyZWVDb3VudCAmJiAoXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJiZy1ncmVlbi01MDAvMTAgYm9yZGVyIGJvcmRlci1ncmVlbi00MDAvMzAgcm91bmRlZC1sZyBwLTNcIj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0yXCI+XG5cdFx0XHRcdFx0XHRcdFx0PFRyZWVQaW5lIGNsYXNzTmFtZT1cInctNCBoLTQgdGV4dC1ncmVlbi00MDBcIiAvPlxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmVlbi0zMDAgZm9udC1tZWRpdW1cIj5TdXJmYWNlIFZlZ2V0YXRpb248L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JlZW4tNDAwIGZvbnQtbW9ub1wiPntwbGFuZXRDb25maWcudHJlZUNvdW50LnRvTG9jYWxlU3RyaW5nKCl9IHRyZWVzPC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8cCBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JlZW4tMjAwIG10LTFcIj5CaW9tZS1zcGVjaWZpYyBmbG9yYSBkZXRlY3RlZC4gQmlvZGl2ZXJzaXR5IGluZGV4OiBISUdIPC9wPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQpfVxuXG5cdFx0XHRcdHsvKiBFeHBsb3JhdGlvbiBTdGF0dXMgKi99XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYmctc2xhdGUtODAwLzUwIGJvcmRlciBib3JkZXItc2xhdGUtNjAwLzUwIHJvdW5kZWQtbGcgcC0zIG10LTRcIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlblwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LXNsYXRlLTQwMFwiPlRocmVhdCBMZXZlbDwvc3Bhbj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT17YHRleHQtc20gZm9udC1ib2xkICR7Z2V0VGhyZWF0Q29sb3IoKX1gfT57cGxhbmV0VHlwZS5kYW5nZXJMZXZlbH0vMTA8L3NwYW4+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gbXQtMVwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LXNsYXRlLTQwMFwiPlNjaWVudGlmaWMgVmFsdWU8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtY3lhbi00MDAgZm9udC1ib2xkXCI+e3BsYW5ldFR5cGUuc2NpZW50aWZpY1ZhbHVlfS8xMDwvc3Bhbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0ey8qIFJlYWwgV29ybGQgRXhhbXBsZSAqL31cblx0XHRcdFx0e3BsYW5ldFR5cGUucmVhbFdvcmxkRXhhbXBsZSAmJiA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1zbGF0ZS01MDAgaXRhbGljIGJvcmRlci10IGJvcmRlci1zbGF0ZS03MDAvMzAgcHQtMlwiPlNpbWlsYXIgdG86IHtwbGFuZXRUeXBlLnJlYWxXb3JsZEV4YW1wbGV9PC9kaXY+fVxuXHRcdFx0PC9kaXY+XG5cdFx0PC9DYXJkM0Q+XG5cdCk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJDYXJkM0QiLCJCYWRnZSIsImNoaWxkcmVuIiwidmFyaWFudCIsImNsYXNzTmFtZSIsInByb3BzIiwic3BhbiIsIlRoZXJtb21ldGVyIiwiRHJvcGxldHMiLCJXaW5kIiwiTW91bnRhaW4iLCJHYXVnZSIsIkdsb2JlIiwiQXRvbSIsIlRyZWVQaW5lIiwiWmFwIiwiUGxhbmV0SW5mb0NhcmQzRCIsInBsYW5ldFR5cGUiLCJwb3NpdGlvbiIsInZpc2libGUiLCJvbkVudGVyIiwib25FeGl0IiwicGxhbmV0Q29uZmlnIiwiZ2V0QXRtb3NwaGVyaWNEYXRhIiwiY29tcG9zaXRpb24iLCJhdG1vc3BoZXJlQ29tcG9zaXRpb24iLCJzbGljZSIsIm1hcCIsImdhcyIsImluZGV4IiwicGVyY2VudGFnZSIsIk1hdGgiLCJyYW5kb20iLCJnZXRUaHJlYXRDb2xvciIsImRhbmdlciIsImRhbmdlckxldmVsIiwiZ2V0SGFiaXRhYmlsaXR5U3RhdHVzIiwic2NvcmUiLCJiYXNlSGFiaXRhYmlsaXR5Iiwib3ZlcmFsbFNjb3JlIiwic3RhdHVzIiwiY29sb3IiLCJpY29uIiwiYXRtb3NwaGVyaWNEYXRhIiwiaGFiaXRhYmlsaXR5U3RhdHVzIiwidHJpZ2dlciIsInRpdGxlIiwibmFtZSIsImdsb3dDb2xvciIsImRpdiIsImNsYXNzIiwicmVwbGFjZSIsInRvVXBwZXJDYXNlIiwibWFzc1JhbmdlIiwicmFkaXVzUmFuZ2UiLCJ0ZW1wZXJhdHVyZVJhbmdlIiwiY29tcG9uZW50IiwidG9GaXhlZCIsImZlYXR1cmVzIiwiZm9yZXN0cyIsIm9jZWFucyIsImF0bW9zcGhlcmljR2xvdyIsImVuYWJsZVZlZ2V0YXRpb24iLCJ0cmVlQ291bnQiLCJ0b0xvY2FsZVN0cmluZyIsInAiLCJzY2llbnRpZmljVmFsdWUiLCJyZWFsV29ybGRFeGFtcGxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/PlanetInfoCard3D.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/utils.ts":
/*!****************************!*\
  !*** ./src/utils/utils.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cn: () => (/* binding */ cn)\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tailwind_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tailwind-merge */ \"(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs\");\n\n\nfunction cn() {\n    for(var _len = arguments.length, inputs = new Array(_len), _key = 0; _key < _len; _key++){\n        inputs[_key] = arguments[_key];\n    }\n    return (0,tailwind_merge__WEBPACK_IMPORTED_MODULE_1__.twMerge)((0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(inputs));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy91dGlscy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkM7QUFDSjtBQUVsQyxTQUFTRTtJQUFHO1FBQUdDLE9BQUgsdUJBQXVCOztJQUN6QyxPQUFPRix1REFBT0EsQ0FBQ0QsMENBQUlBLENBQUNHO0FBQ3JCIiwic291cmNlcyI6WyIvVXNlcnMvYnlyb253YWRlL2Nvc21pYy9zcmMvdXRpbHMvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHlwZSBDbGFzc1ZhbHVlLCBjbHN4IH0gZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IHR3TWVyZ2UgfSBmcm9tIFwidGFpbHdpbmQtbWVyZ2VcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNuKC4uLmlucHV0czogQ2xhc3NWYWx1ZVtdKSB7XG5cdHJldHVybiB0d01lcmdlKGNsc3goaW5wdXRzKSk7XG59XG4iXSwibmFtZXMiOlsiY2xzeCIsInR3TWVyZ2UiLCJjbiIsImlucHV0cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/utils.ts\n"));

/***/ })

});
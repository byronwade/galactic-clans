"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_shared_procgen_planet_planet-renderer_ts"],{

/***/ "(app-pages-browser)/./src/shared/procgen/planet/planet-renderer.ts":
/*!******************************************************!*\
  !*** ./src/shared/procgen/planet/planet-renderer.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlanetRenderer: () => (/* binding */ PlanetRenderer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _planet_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./planet-types */ \"(app-pages-browser)/./src/shared/procgen/planet/planet-types.ts\");\n/**\n * @file planet-renderer.ts\n * @description Unified planet renderer with comprehensive planet type support and surface details\n * @version 6.0.0\n * @author Galactic Clans Development Team\n *\n * @purpose Renders scientifically accurate planets using the comprehensive planet type\n * system with enhanced visual features, surface details, trees, and zoom capabilities.\n */ \n\n// Biome-specific tree types\nconst TREE_SPECIES_BY_BIOME = new Map([\n    [\n        _planet_types__WEBPACK_IMPORTED_MODULE_0__.BiomeType.TEMPERATE_FOREST,\n        [\n            {\n                species: \"Oak\",\n                height: 15,\n                trunkRadius: 0.8,\n                crownRadius: 8,\n                branchCount: 12,\n                leafDensity: 0.8,\n                seasonalColor: new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x228b22),\n                biomeSuitability: 1.0\n            },\n            {\n                species: \"Pine\",\n                height: 25,\n                trunkRadius: 0.6,\n                crownRadius: 4,\n                branchCount: 8,\n                leafDensity: 0.9,\n                seasonalColor: new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x006400),\n                biomeSuitability: 0.9\n            },\n            {\n                species: \"Birch\",\n                height: 12,\n                trunkRadius: 0.4,\n                crownRadius: 6,\n                branchCount: 10,\n                leafDensity: 0.7,\n                seasonalColor: new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x90ee90),\n                biomeSuitability: 0.8\n            }\n        ]\n    ],\n    [\n        _planet_types__WEBPACK_IMPORTED_MODULE_0__.BiomeType.TROPICAL_JUNGLE,\n        [\n            {\n                species: \"Mahogany\",\n                height: 35,\n                trunkRadius: 1.2,\n                crownRadius: 12,\n                branchCount: 15,\n                leafDensity: 0.95,\n                seasonalColor: new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x006400),\n                biomeSuitability: 1.0\n            },\n            {\n                species: \"Kapok\",\n                height: 40,\n                trunkRadius: 1.5,\n                crownRadius: 15,\n                branchCount: 20,\n                leafDensity: 0.9,\n                seasonalColor: new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x228b22),\n                biomeSuitability: 0.95\n            },\n            {\n                species: \"Palm\",\n                height: 20,\n                trunkRadius: 0.5,\n                crownRadius: 8,\n                branchCount: 6,\n                leafDensity: 0.8,\n                seasonalColor: new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x32cd32),\n                biomeSuitability: 0.9\n            }\n        ]\n    ]\n]);\n// Default configuration\nconst DEFAULT_CONFIG = {\n    radius: 3.0,\n    seed: Date.now(),\n    starDistance: 1.0,\n    starType: \"G\",\n    detailLevel: 2,\n    featureDensity: 0.7,\n    colorVariation: 0.8,\n    enableLOD: true,\n    maxFeatures: 50,\n    renderDistance: 100,\n    enableAtmosphere: true,\n    enableRings: true,\n    enableMoons: true,\n    enableSpecialEffects: true,\n    enableSurfaceDetails: true,\n    enableVegetation: true,\n    treeCount: 500,\n    terrainDetail: 0.8,\n    surfaceZoomLevel: 1.0,\n    enableAdvancedLighting: true,\n    ambientIntensity: 0.4,\n    sunIntensity: 1.5\n};\nclass PlanetRenderer {\n    /**\n\t * Render a planet with the specified configuration\n\t */ async renderPlanetByType(planetClass) {\n        let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const startTime = performance.now();\n        const finalConfig = {\n            ...DEFAULT_CONFIG,\n            ...config\n        };\n        // Get planet type definition\n        const planetType = (0,_planet_types__WEBPACK_IMPORTED_MODULE_0__.getPlanetTypeByClass)(planetClass);\n        if (!planetType) {\n            throw new Error(\"Unknown planet class: \".concat(planetClass));\n        }\n        // Check cache first\n        const cacheKey = this.generateCacheKey(finalConfig);\n        if (this.renderCache.has(cacheKey)) {\n            const cachedMesh = this.renderCache.get(cacheKey);\n            return this.createCachedResult(cachedMesh, finalConfig, startTime);\n        }\n        try {\n            // Generate planet mesh\n            const mesh = await this.generatePlanetMesh(planetType, finalConfig);\n            // Apply effects based on configuration\n            if (finalConfig.enableAtmosphere) {\n                this.addAtmosphere(mesh, planetType);\n            }\n            if (finalConfig.enableRings && planetType.features.rings) {\n                this.addRings(mesh, planetType);\n            }\n            if (finalConfig.enableMoons && planetType.features.moons > 0) {\n                this.addMoons(mesh, planetType);\n            }\n            if (finalConfig.enableSpecialEffects) {\n                this.addSpecialEffects(mesh, planetType);\n            }\n            if (finalConfig.enableAdvancedLighting) {\n                this.setupAdvancedLighting(mesh, finalConfig);\n            }\n            // Generate surface vegetation for habitable planets\n            if (finalConfig.enableSurfaceDetails) {\n                this.generateVegetation(mesh, planetType, finalConfig);\n            }\n            // Cache the result\n            this.renderCache.set(cacheKey, mesh);\n            // Calculate metadata\n            const metadata = this.calculateRenderMetadata(mesh, startTime);\n            return {\n                mesh,\n                config: finalConfig,\n                planetType,\n                statistics: {\n                    vertexCount: this.calculatePolyCount(mesh),\n                    featureCount: this.countFeatures(mesh)\n                },\n                metadata\n            };\n        } catch (error) {\n            console.error(\"Planet rendering failed:\", error);\n            return this.renderFallbackPlanet(finalConfig, startTime);\n        }\n    }\n    /**\n\t * Generate a simple planet mesh based on planet type\n\t */ async generatePlanetMesh(planetType, config) {\n        const group = new three__WEBPACK_IMPORTED_MODULE_1__.Group();\n        // Create basic sphere geometry\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry(config.radius || 3.0, 32, 32);\n        // Create material based on planet type\n        const material = this.createPlanetMaterial(planetType, config);\n        // Create mesh\n        const mesh = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(geometry, material);\n        group.add(mesh);\n        // Add basic rotation\n        mesh.rotation.x = Math.PI * 0.1; // Slight tilt\n        return group;\n    }\n    /**\n\t * Create planet material based on type\n\t */ createPlanetMaterial(planetType, config) {\n        // Use primary colors from planet type\n        const primaryColor = planetType.primaryColors[0] || new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x4a7c59);\n        // Create basic material\n        const material = new three__WEBPACK_IMPORTED_MODULE_1__.MeshLambertMaterial({\n            color: primaryColor,\n            emissive: new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x111111),\n            emissiveIntensity: 0.1\n        });\n        return material;\n    }\n    /**\n\t * Get radius from mesh geometry\n\t */ getMeshRadius(mesh) {\n        const firstMesh = mesh.children[0];\n        if (firstMesh && firstMesh.geometry instanceof three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry) {\n            return firstMesh.geometry.parameters.radius;\n        }\n        return 3.0; // Default radius\n    }\n    /**\n\t * Add atmosphere effect\n\t */ addAtmosphere(mesh, planetType) {\n        if (!planetType.features.clouds) return;\n        const radius = this.getMeshRadius(mesh);\n        const atmosphereGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry(radius * 1.1, 32, 32);\n        const atmosphereMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            color: 0x87ceeb,\n            transparent: true,\n            opacity: 0.3,\n            side: three__WEBPACK_IMPORTED_MODULE_1__.BackSide\n        });\n        const atmosphere = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(atmosphereGeometry, atmosphereMaterial);\n        mesh.add(atmosphere);\n    }\n    /**\n\t * Add ring system\n\t */ addRings(mesh, planetType) {\n        const radius = this.getMeshRadius(mesh);\n        const ringGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.RingGeometry(radius * 1.5, radius * 2.5, 64);\n        const ringMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            color: 0xcccccc,\n            transparent: true,\n            opacity: 0.6,\n            side: three__WEBPACK_IMPORTED_MODULE_1__.DoubleSide\n        });\n        const rings = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(ringGeometry, ringMaterial);\n        rings.rotation.x = Math.PI * 0.5; // Rotate to be horizontal\n        mesh.add(rings);\n    }\n    /**\n\t * Add moons\n\t */ addMoons(mesh, planetType) {\n        const moonCount = Math.min(planetType.features.moons, 3); // Limit to 3 for performance\n        for(let i = 0; i < moonCount; i++){\n            const moonGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry(0.3, 16, 16);\n            const moonMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshLambertMaterial({\n                color: 0x888888\n            });\n            const moon = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(moonGeometry, moonMaterial);\n            // Position moons in orbit\n            const angle = i / moonCount * Math.PI * 2;\n            const distance = 4 + i * 0.5;\n            moon.position.set(Math.cos(angle) * distance, Math.sin(angle) * distance * 0.3, Math.sin(angle) * distance * 0.7);\n            mesh.add(moon);\n        }\n    }\n    /**\n\t * Add special effects based on planet type\n\t */ addSpecialEffects(mesh, planetType) {\n        // Add lava particles for lava worlds\n        if (planetType.class === _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.LAVA_WORLD) {\n            this.addLavaParticles(mesh);\n        }\n        // Add ice shimmers for ice giants\n        if (planetType.class === _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.ICE_GIANT) {\n            this.addIceShimmers(mesh);\n        }\n        // Add aurora for planets with magnetosphere\n        if (planetType.features.aurorae) {\n            this.addAuroraEffect(mesh);\n        }\n    }\n    /**\n\t * Add lava particle effect\n\t */ addLavaParticles(mesh) {\n        const particleCount = 50;\n        const particles = new three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry();\n        const positions = new Float32Array(particleCount * 3);\n        for(let i = 0; i < particleCount * 3; i += 3){\n            positions[i] = (Math.random() - 0.5) * 6;\n            positions[i + 1] = (Math.random() - 0.5) * 6;\n            positions[i + 2] = (Math.random() - 0.5) * 6;\n        }\n        particles.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_1__.BufferAttribute(positions, 3));\n        const particleMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.PointsMaterial({\n            color: 0xff4500,\n            size: 0.1,\n            transparent: true,\n            opacity: 0.8\n        });\n        const particleSystem = new three__WEBPACK_IMPORTED_MODULE_1__.Points(particles, particleMaterial);\n        mesh.add(particleSystem);\n    }\n    /**\n\t * Add ice shimmer effect\n\t */ addIceShimmers(mesh) {\n        const radius = this.getMeshRadius(mesh);\n        const shimmerGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry(radius * 1.05, 32, 32);\n        const shimmerMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            color: 0x87ceeb,\n            transparent: true,\n            opacity: 0.2,\n            side: three__WEBPACK_IMPORTED_MODULE_1__.BackSide\n        });\n        const shimmer = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(shimmerGeometry, shimmerMaterial);\n        mesh.add(shimmer);\n    }\n    /**\n\t * Add aurora effect\n\t */ addAuroraEffect(mesh) {\n        const radius = this.getMeshRadius(mesh);\n        const auroraGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry(radius * 1.2, 32, 32);\n        const auroraMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            color: 0x00ff00,\n            transparent: true,\n            opacity: 0.1,\n            side: three__WEBPACK_IMPORTED_MODULE_1__.BackSide\n        });\n        const aurora = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(auroraGeometry, auroraMaterial);\n        mesh.add(aurora);\n    }\n    /**\n\t * Generate surface vegetation for habitable planets\n\t */ generateVegetation(mesh, planetType, config) {\n        // Only generate vegetation for habitable planets with forests\n        if (!planetType.features.forests || !config.enableVegetation) {\n            return;\n        }\n        // Check if planet is habitable enough for trees (habitability > 70)\n        if (planetType.baseHabitability.overallScore < 70) {\n            return;\n        }\n        console.log(\"\\uD83C\\uDF32 [PLANET] Generating vegetation for \".concat(planetType.name));\n        const vegetationGroup = new three__WEBPACK_IMPORTED_MODULE_1__.Group();\n        vegetationGroup.name = \"vegetation\";\n        // Determine primary biome for tree selection\n        const primaryBiome = this.getPrimaryBiome(planetType);\n        const treeSpecies = TREE_SPECIES_BY_BIOME.get(primaryBiome) || TREE_SPECIES_BY_BIOME.get(_planet_types__WEBPACK_IMPORTED_MODULE_0__.BiomeType.TEMPERATE_FOREST);\n        if (!treeSpecies) return;\n        const treeCount = Math.min(config.treeCount || 500, 1000); // Cap at 1000 for performance\n        const radius = config.radius || 3.0;\n        // Generate trees using Poisson disk sampling for realistic distribution\n        const treePositions = this.generateTreePositions(treeCount, radius);\n        for(let i = 0; i < treePositions.length; i++){\n            const position = treePositions[i];\n            if (!position) continue; // Skip if no position available\n            // Select random tree species\n            const speciesIndex = Math.floor(Math.random() * treeSpecies.length);\n            const species = treeSpecies[speciesIndex];\n            if (!species) continue; // Skip if no species available\n            // Generate individual tree\n            const tree = this.generateTree(species, position, radius);\n            if (tree) {\n                vegetationGroup.add(tree);\n            }\n            // Performance check - don't generate too many trees per frame\n            if (i % 50 === 0) {\n            // Could yield control here in a real implementation\n            }\n        }\n        mesh.add(vegetationGroup);\n        console.log(\"\\uD83C\\uDF32 [PLANET] Generated \".concat(vegetationGroup.children.length, \" trees\"));\n    }\n    /**\n\t * Generate realistic tree positions using Poisson disk sampling\n\t */ generateTreePositions(count, planetRadius) {\n        const positions = [];\n        const minDistance = 0.1; // Minimum distance between trees\n        const maxAttempts = 30;\n        for(let i = 0; i < count; i++){\n            let attempts = 0;\n            let validPosition = false;\n            while(!validPosition && attempts < maxAttempts){\n                // Generate random point on sphere surface\n                const theta = Math.random() * Math.PI * 2;\n                const phi = Math.acos(2 * Math.random() - 1);\n                const x = planetRadius * Math.sin(phi) * Math.cos(theta);\n                const y = planetRadius * Math.sin(phi) * Math.sin(theta);\n                const z = planetRadius * Math.cos(phi);\n                const position = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(x, y, z);\n                // Check minimum distance to existing trees\n                validPosition = true;\n                for (const existingPos of positions){\n                    if (position.distanceTo(existingPos) < minDistance) {\n                        validPosition = false;\n                        break;\n                    }\n                }\n                if (validPosition) {\n                    positions.push(position);\n                }\n                attempts++;\n            }\n        }\n        return positions;\n    }\n    /**\n\t * Generate a single realistic tree\n\t */ generateTree(species, position, planetRadius) {\n        const treeGroup = new three__WEBPACK_IMPORTED_MODULE_1__.Group();\n        // Scale tree based on planet size and random variation\n        const scale = planetRadius / 3.0 * (0.8 + Math.random() * 0.4);\n        const height = species.height * scale * 0.01; // Scale down for planet surface\n        const trunkRadius = species.trunkRadius * scale * 0.01;\n        const crownRadius = species.crownRadius * scale * 0.01;\n        // Generate trunk\n        const trunk = this.generateTrunk(height, trunkRadius);\n        if (trunk) {\n            treeGroup.add(trunk);\n        }\n        // Generate crown/foliage\n        const crown = this.generateCrown(species, height, crownRadius);\n        if (crown) {\n            crown.position.y = height * 0.7; // Position crown above trunk\n            treeGroup.add(crown);\n        }\n        // Position tree on planet surface\n        const surfaceNormal = position.clone().normalize();\n        treeGroup.position.copy(position);\n        treeGroup.lookAt(position.clone().add(surfaceNormal));\n        // Add slight random rotation\n        treeGroup.rotateY(Math.random() * Math.PI * 2);\n        return treeGroup;\n    }\n    /**\n\t * Generate tree trunk\n\t */ generateTrunk(height, radius) {\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_1__.CylinderGeometry(radius * 0.8, radius, height, 8);\n        const material = new three__WEBPACK_IMPORTED_MODULE_1__.MeshLambertMaterial({\n            color: new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x4a4a4a).lerp(new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x8b4513), 0.7)\n        });\n        const trunk = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(geometry, material);\n        trunk.position.y = height / 2;\n        trunk.castShadow = true;\n        trunk.receiveShadow = true;\n        return trunk;\n    }\n    /**\n\t * Generate tree crown/foliage\n\t */ generateCrown(species, trunkHeight, radius) {\n        const crownGroup = new three__WEBPACK_IMPORTED_MODULE_1__.Group();\n        // Create multiple foliage spheres for realistic appearance\n        const foliageCount = 3 + Math.floor(Math.random() * 3);\n        for(let i = 0; i < foliageCount; i++){\n            const foliageRadius = radius * (0.6 + Math.random() * 0.4);\n            const geometry = new three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry(foliageRadius, 8, 6);\n            // Create realistic leaf material\n            const leafColor = species.seasonalColor.clone();\n            leafColor.lerp(new three__WEBPACK_IMPORTED_MODULE_1__.Color(0x2f4f2f), Math.random() * 0.3); // Add variation\n            const material = new three__WEBPACK_IMPORTED_MODULE_1__.MeshLambertMaterial({\n                color: leafColor,\n                transparent: true,\n                opacity: 0.8 + Math.random() * 0.2\n            });\n            const foliage = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(geometry, material);\n            // Position foliage spheres randomly within crown area\n            foliage.position.set((Math.random() - 0.5) * radius * 0.5, (Math.random() - 0.5) * trunkHeight * 0.3, (Math.random() - 0.5) * radius * 0.5);\n            foliage.castShadow = true;\n            foliage.receiveShadow = true;\n            crownGroup.add(foliage);\n        }\n        return crownGroup;\n    }\n    /**\n\t * Determine primary biome for a planet type\n\t */ getPrimaryBiome(planetType) {\n        if (planetType.possibleBiomes && planetType.possibleBiomes.length > 0) {\n            // Return the first biome that has tree species defined\n            for (const biome of planetType.possibleBiomes){\n                if (TREE_SPECIES_BY_BIOME.has(biome)) {\n                    return biome;\n                }\n            }\n        }\n        // Default to temperate forest for habitable planets\n        return _planet_types__WEBPACK_IMPORTED_MODULE_0__.BiomeType.TEMPERATE_FOREST;\n    }\n    /**\n\t * Setup advanced lighting\n\t */ setupAdvancedLighting(mesh, config) {\n        // Add ambient light\n        const ambientLight = new three__WEBPACK_IMPORTED_MODULE_1__.AmbientLight(0x404040, config.ambientIntensity || 0.4);\n        mesh.add(ambientLight);\n        // Add directional light (sun)\n        const sunLight = new three__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(0xffffff, config.sunIntensity || 1.5);\n        sunLight.position.set(10, 10, 5);\n        mesh.add(sunLight);\n    }\n    /**\n\t * Get available planet types\n\t */ getAvailablePlanetTypes() {\n        return Array.from(_planet_types__WEBPACK_IMPORTED_MODULE_0__.PLANET_TYPES.keys());\n    }\n    /**\n\t * Get planet type information\n\t */ getPlanetTypeInfo(planetClass) {\n        return (0,_planet_types__WEBPACK_IMPORTED_MODULE_0__.getPlanetTypeByClass)(planetClass);\n    }\n    /**\n\t * Update quality settings\n\t */ updateQuality(qualityLevel) {\n        // Adjust detail level based on quality\n        const detailLevel = Math.max(1, Math.min(5, qualityLevel));\n        // Clear cache to force regeneration with new quality\n        this.clearCache();\n        console.log(\"\\uD83C\\uDF0D [PLANET] Quality updated to level \".concat(detailLevel));\n    }\n    /**\n\t * Dispose of resources\n\t */ dispose() {\n        if (this.isDisposed) return;\n        // Clear cache\n        this.clearCache();\n        this.isDisposed = true;\n        console.log(\"üåç [PLANET] Renderer disposed\");\n    }\n    /**\n\t * Generate cache key for configuration\n\t */ generateCacheKey(config) {\n        return \"\".concat(config.planetClass, \"-\").concat(config.radius, \"-\").concat(config.seed, \"-\").concat(config.detailLevel);\n    }\n    /**\n\t * Create cached result\n\t */ createCachedResult(mesh, config, startTime) {\n        const planetType = (0,_planet_types__WEBPACK_IMPORTED_MODULE_0__.getPlanetTypeByClass)(config.planetClass || _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.TERRESTRIAL);\n        const metadata = this.calculateRenderMetadata(mesh, startTime);\n        return {\n            mesh: mesh.clone(),\n            config,\n            planetType,\n            statistics: {\n                vertexCount: this.calculatePolyCount(mesh),\n                featureCount: this.countFeatures(mesh)\n            },\n            metadata\n        };\n    }\n    /**\n\t * Calculate render metadata\n\t */ calculateRenderMetadata(mesh, startTime) {\n        const renderTime = performance.now() - startTime;\n        const polyCount = this.calculatePolyCount(mesh);\n        const featureCount = this.countFeatures(mesh);\n        return {\n            renderTime,\n            polyCount,\n            textureCount: 1,\n            featureCount,\n            memoryUsage: polyCount * 32,\n            qualityLevel: this.determineQualityLevel(polyCount, 1)\n        };\n    }\n    /**\n\t * Calculate polygon count\n\t */ calculatePolyCount(mesh) {\n        let count = 0;\n        mesh.traverse((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_1__.Mesh && child.geometry) {\n                const geometry = child.geometry;\n                if (geometry.attributes.position) {\n                    count += geometry.attributes.position.count / 3;\n                }\n            }\n        });\n        return count;\n    }\n    /**\n\t * Count features in mesh\n\t */ countFeatures(mesh) {\n        let count = 0;\n        mesh.traverse((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_1__.Mesh) {\n                count++;\n            }\n        });\n        return count;\n    }\n    /**\n\t * Determine quality level\n\t */ determineQualityLevel(polyCount, textureCount) {\n        if (polyCount > 10000) return \"Ultra\";\n        if (polyCount > 5000) return \"High\";\n        if (polyCount > 2000) return \"Medium\";\n        return \"Low\";\n    }\n    /**\n\t * Render fallback planet\n\t */ renderFallbackPlanet(config, startTime) {\n        console.warn(\"üåç [PLANET] Using fallback planet renderer\");\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry(config.radius || 3.0, 16, 16);\n        const material = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            color: 0x808080\n        });\n        const mesh = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(geometry, material);\n        const group = new three__WEBPACK_IMPORTED_MODULE_1__.Group();\n        group.add(mesh);\n        const planetType = (0,_planet_types__WEBPACK_IMPORTED_MODULE_0__.getPlanetTypeByClass)(_planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.TERRESTRIAL);\n        const metadata = this.calculateRenderMetadata(group, startTime);\n        return {\n            mesh: group,\n            config,\n            planetType,\n            statistics: {\n                vertexCount: 256,\n                featureCount: 1\n            },\n            metadata\n        };\n    }\n    /**\n\t * Get performance statistics\n\t */ getPerformanceStats() {\n        return {\n            lastRenderTime: this.lastRenderTime,\n            cacheSize: this.renderCache.size\n        };\n    }\n    /**\n\t * Clear render cache\n\t */ clearCache() {\n        this.renderCache.forEach((mesh)=>{\n            this.disposeMesh(mesh);\n        });\n        this.renderCache.clear();\n        console.log(\"üåç [PLANET] Cache cleared\");\n    }\n    /**\n\t * Dispose of mesh resources\n\t */ disposeMesh(object) {\n        object.traverse((child)=>{\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_1__.Mesh) {\n                if (child.geometry) {\n                    child.geometry.dispose();\n                }\n                if (child.material) {\n                    if (Array.isArray(child.material)) {\n                        child.material.forEach((material)=>material.dispose());\n                    } else {\n                        child.material.dispose();\n                    }\n                }\n            }\n        });\n    }\n    /**\n\t * Preload common planet types\n\t */ async preloadCommonTypes() {\n        const commonTypes = [\n            _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.TERRESTRIAL,\n            _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.GAS_GIANT,\n            _planet_types__WEBPACK_IMPORTED_MODULE_0__.PlanetClass.ICE_GIANT\n        ];\n        console.log(\"üåç [PLANET] Preloading common planet types...\");\n        for (const planetClass of commonTypes){\n            try {\n                await this.renderPlanetByType(planetClass, {\n                    detailLevel: 1\n                });\n            } catch (error) {\n                console.warn(\"\\uD83C\\uDF0D [PLANET] Failed to preload \".concat(planetClass, \":\"), error);\n            }\n        }\n        console.log(\"üåç [PLANET] Preloading complete\");\n    }\n    constructor(){\n        this.isDisposed = false;\n        this.renderCache = new Map();\n        this.lastRenderTime = 0;\n    // Initialize renderer\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zaGFyZWQvcHJvY2dlbi9wbGFuZXQvcGxhbmV0LXJlbmRlcmVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7OztDQVFDLEdBRThCO0FBQ2tGO0FBdURqSCw0QkFBNEI7QUFDNUIsTUFBTUssd0JBQXdCLElBQUlDLElBQTZCO0lBQzlEO1FBQ0NKLG9EQUFTQSxDQUFDSyxnQkFBZ0I7UUFDMUI7WUFDQztnQkFDQ0MsU0FBUztnQkFDVEMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsYUFBYTtnQkFDYkMsYUFBYTtnQkFDYkMsYUFBYTtnQkFDYkMsZUFBZSxJQUFJZCx3Q0FBVyxDQUFDO2dCQUMvQmdCLGtCQUFrQjtZQUNuQjtZQUNBO2dCQUNDUixTQUFTO2dCQUNUQyxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxhQUFhO2dCQUNiQyxhQUFhO2dCQUNiQyxhQUFhO2dCQUNiQyxlQUFlLElBQUlkLHdDQUFXLENBQUM7Z0JBQy9CZ0Isa0JBQWtCO1lBQ25CO1lBQ0E7Z0JBQ0NSLFNBQVM7Z0JBQ1RDLFFBQVE7Z0JBQ1JDLGFBQWE7Z0JBQ2JDLGFBQWE7Z0JBQ2JDLGFBQWE7Z0JBQ2JDLGFBQWE7Z0JBQ2JDLGVBQWUsSUFBSWQsd0NBQVcsQ0FBQztnQkFDL0JnQixrQkFBa0I7WUFDbkI7U0FDQTtLQUNEO0lBQ0Q7UUFDQ2Qsb0RBQVNBLENBQUNlLGVBQWU7UUFDekI7WUFDQztnQkFDQ1QsU0FBUztnQkFDVEMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsYUFBYTtnQkFDYkMsYUFBYTtnQkFDYkMsYUFBYTtnQkFDYkMsZUFBZSxJQUFJZCx3Q0FBVyxDQUFDO2dCQUMvQmdCLGtCQUFrQjtZQUNuQjtZQUNBO2dCQUNDUixTQUFTO2dCQUNUQyxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxhQUFhO2dCQUNiQyxhQUFhO2dCQUNiQyxhQUFhO2dCQUNiQyxlQUFlLElBQUlkLHdDQUFXLENBQUM7Z0JBQy9CZ0Isa0JBQWtCO1lB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QSxDQUFDa1AsU0FBUztZQUFFbFAsc0RBQVdBLENBQUNpSSxTQUFTO1NBQUM7UUFFM0ZuRCxRQUFRNkUsR0FBRyxDQUFDO1FBRVosS0FBSyxNQUFNL0csZUFBZXFNLFlBQWE7WUFDdEMsSUFBSTtnQkFDSCxNQUFNLElBQUksQ0FBQ3RNLGtCQUFrQixDQUFDQyxhQUFhO29CQUFFcEIsYUFBYTtnQkFBRTtZQUM3RCxFQUFFLE9BQU9xRCxPQUFPO2dCQUNmQyxRQUFReUosSUFBSSxDQUFDLDJDQUE2QyxPQUFaM0wsYUFBWSxNQUFJaUM7WUFDL0Q7UUFDRDtRQUVBQyxRQUFRNkUsR0FBRyxDQUFDO0lBQ2I7SUF6ckJBLGFBQWM7YUFKTmtFLGFBQXNCO2FBQ3RCeEssY0FBd0MsSUFBSWhEO2FBQzVDb08saUJBQXlCO0lBR2hDLHNCQUFzQjtJQUN2QjtBQXdyQkQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ieXJvbndhZGUvY29zbWljL3NyYy9zaGFyZWQvcHJvY2dlbi9wbGFuZXQvcGxhbmV0LXJlbmRlcmVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgcGxhbmV0LXJlbmRlcmVyLnRzXG4gKiBAZGVzY3JpcHRpb24gVW5pZmllZCBwbGFuZXQgcmVuZGVyZXIgd2l0aCBjb21wcmVoZW5zaXZlIHBsYW5ldCB0eXBlIHN1cHBvcnQgYW5kIHN1cmZhY2UgZGV0YWlsc1xuICogQHZlcnNpb24gNi4wLjBcbiAqIEBhdXRob3IgR2FsYWN0aWMgQ2xhbnMgRGV2ZWxvcG1lbnQgVGVhbVxuICpcbiAqIEBwdXJwb3NlIFJlbmRlcnMgc2NpZW50aWZpY2FsbHkgYWNjdXJhdGUgcGxhbmV0cyB1c2luZyB0aGUgY29tcHJlaGVuc2l2ZSBwbGFuZXQgdHlwZVxuICogc3lzdGVtIHdpdGggZW5oYW5jZWQgdmlzdWFsIGZlYXR1cmVzLCBzdXJmYWNlIGRldGFpbHMsIHRyZWVzLCBhbmQgem9vbSBjYXBhYmlsaXRpZXMuXG4gKi9cblxuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyBQbGFuZXRDbGFzcywgQmlvbWVUeXBlLCBnZXRQbGFuZXRUeXBlQnlDbGFzcywgZ2V0UmFuZG9tUGxhbmV0VHlwZSwgUExBTkVUX1RZUEVTIH0gZnJvbSBcIi4vcGxhbmV0LXR5cGVzXCI7XG5pbXBvcnQgdHlwZSB7IFBsYW5ldFR5cGVEZWZpbml0aW9uIH0gZnJvbSBcIi4vcGxhbmV0LXR5cGVzXCI7XG5cbi8vIFBsYW5ldCBSZW5kZXJpbmcgQ29uZmlndXJhdGlvblxuZXhwb3J0IGludGVyZmFjZSBQbGFuZXRSZW5kZXJDb25maWcge1xuXHQvLyBCYXNpYyBQcm9wZXJ0aWVzXG5cdHBsYW5ldENsYXNzPzogUGxhbmV0Q2xhc3M7XG5cdHJhZGl1cz86IG51bWJlcjtcblx0c2VlZD86IG51bWJlcjtcblxuXHQvLyBPcmJpdGFsIFByb3BlcnRpZXNcblx0c3RhckRpc3RhbmNlPzogbnVtYmVyO1xuXHRzdGFyVHlwZT86IHN0cmluZztcblxuXHQvLyBWaXN1YWwgUXVhbGl0eVxuXHRkZXRhaWxMZXZlbD86IG51bWJlcjtcblx0ZmVhdHVyZURlbnNpdHk/OiBudW1iZXI7XG5cdGNvbG9yVmFyaWF0aW9uPzogbnVtYmVyO1xuXG5cdC8vIFBlcmZvcm1hbmNlIE9wdGlvbnNcblx0ZW5hYmxlTE9EPzogYm9vbGVhbjtcblx0bWF4RmVhdHVyZXM/OiBudW1iZXI7XG5cdHJlbmRlckRpc3RhbmNlPzogbnVtYmVyO1xuXG5cdC8vIFNwZWNpYWwgRmVhdHVyZXNcblx0ZW5hYmxlQXRtb3NwaGVyZT86IGJvb2xlYW47XG5cdGVuYWJsZVJpbmdzPzogYm9vbGVhbjtcblx0ZW5hYmxlTW9vbnM/OiBib29sZWFuO1xuXHRlbmFibGVTcGVjaWFsRWZmZWN0cz86IGJvb2xlYW47XG5cblx0Ly8gU3VyZmFjZSBEZXRhaWxzIChORVcpXG5cdGVuYWJsZVN1cmZhY2VEZXRhaWxzPzogYm9vbGVhbjtcblx0ZW5hYmxlVmVnZXRhdGlvbj86IGJvb2xlYW47XG5cdHRyZWVDb3VudD86IG51bWJlcjtcblx0dGVycmFpbkRldGFpbD86IG51bWJlcjtcblx0c3VyZmFjZVpvb21MZXZlbD86IG51bWJlcjsgLy8gMS4wID0gbm9ybWFsLCAyLjArID0gc3VyZmFjZSBkZXRhaWxcblxuXHQvLyBMaWdodGluZ1xuXHRlbmFibGVBZHZhbmNlZExpZ2h0aW5nPzogYm9vbGVhbjtcblx0YW1iaWVudEludGVuc2l0eT86IG51bWJlcjtcblx0c3VuSW50ZW5zaXR5PzogbnVtYmVyO1xufVxuXG4vLyBUcmVlIEdlbmVyYXRpb24gQ29uZmlndXJhdGlvblxuaW50ZXJmYWNlIFRyZWVDb25maWcge1xuXHRzcGVjaWVzOiBzdHJpbmc7XG5cdGhlaWdodDogbnVtYmVyO1xuXHR0cnVua1JhZGl1czogbnVtYmVyO1xuXHRjcm93blJhZGl1czogbnVtYmVyO1xuXHRicmFuY2hDb3VudDogbnVtYmVyO1xuXHRsZWFmRGVuc2l0eTogbnVtYmVyO1xuXHRzZWFzb25hbENvbG9yOiBUSFJFRS5Db2xvcjtcblx0YmlvbWVTdWl0YWJpbGl0eTogbnVtYmVyO1xufVxuXG4vLyBCaW9tZS1zcGVjaWZpYyB0cmVlIHR5cGVzXG5jb25zdCBUUkVFX1NQRUNJRVNfQllfQklPTUUgPSBuZXcgTWFwPEJpb21lVHlwZSwgVHJlZUNvbmZpZ1tdPihbXG5cdFtcblx0XHRCaW9tZVR5cGUuVEVNUEVSQVRFX0ZPUkVTVCxcblx0XHRbXG5cdFx0XHR7XG5cdFx0XHRcdHNwZWNpZXM6IFwiT2FrXCIsXG5cdFx0XHRcdGhlaWdodDogMTUsXG5cdFx0XHRcdHRydW5rUmFkaXVzOiAwLjgsXG5cdFx0XHRcdGNyb3duUmFkaXVzOiA4LFxuXHRcdFx0XHRicmFuY2hDb3VudDogMTIsXG5cdFx0XHRcdGxlYWZEZW5zaXR5OiAwLjgsXG5cdFx0XHRcdHNlYXNvbmFsQ29sb3I6IG5ldyBUSFJFRS5Db2xvcigweDIyOGIyMiksXG5cdFx0XHRcdGJpb21lU3VpdGFiaWxpdHk6IDEuMCxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHNwZWNpZXM6IFwiUGluZVwiLFxuXHRcdFx0XHRoZWlnaHQ6IDI1LFxuXHRcdFx0XHR0cnVua1JhZGl1czogMC42LFxuXHRcdFx0XHRjcm93blJhZGl1czogNCxcblx0XHRcdFx0YnJhbmNoQ291bnQ6IDgsXG5cdFx0XHRcdGxlYWZEZW5zaXR5OiAwLjksXG5cdFx0XHRcdHNlYXNvbmFsQ29sb3I6IG5ldyBUSFJFRS5Db2xvcigweDAwNjQwMCksXG5cdFx0XHRcdGJpb21lU3VpdGFiaWxpdHk6IDAuOSxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHNwZWNpZXM6IFwiQmlyY2hcIixcblx0XHRcdFx0aGVpZ2h0OiAxMixcblx0XHRcdFx0dHJ1bmtSYWRpdXM6IDAuNCxcblx0XHRcdFx0Y3Jvd25SYWRpdXM6IDYsXG5cdFx0XHRcdGJyYW5jaENvdW50OiAxMCxcblx0XHRcdFx0bGVhZkRlbnNpdHk6IDAuNyxcblx0XHRcdFx0c2Vhc29uYWxDb2xvcjogbmV3IFRIUkVFLkNvbG9yKDB4OTBlZTkwKSxcblx0XHRcdFx0YmlvbWVTdWl0YWJpbGl0eTogMC44LFxuXHRcdFx0fSxcblx0XHRdLFxuXHRdLFxuXHRbXG5cdFx0QmlvbWVUeXBlLlRST1BJQ0FMX0pVTkdMRSxcblx0XHRbXG5cdFx0XHR7XG5cdFx0XHRcdHNwZWNpZXM6IFwiTWFob2dhbnlcIixcblx0XHRcdFx0aGVpZ2h0OiAzNSxcblx0XHRcdFx0dHJ1bmtSYWRpdXM6IDEuMixcblx0XHRcdFx0Y3Jvd25SYWRpdXM6IDEyLFxuXHRcdFx0XHRicmFuY2hDb3VudDogMTUsXG5cdFx0XHRcdGxlYWZEZW5zaXR5OiAwLjk1LFxuXHRcdFx0XHRzZWFzb25hbENvbG9yOiBuZXcgVEhSRUUuQ29sb3IoMHgwMDY0MDApLFxuXHRcdFx0XHRiaW9tZVN1aXRhYmlsaXR5OiAxLjAsXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRzcGVjaWVzOiBcIkthcG9rXCIsXG5cdFx0XHRcdGhlaWdodDogNDAsXG5cdFx0XHRcdHRydW5rUmFkaXVzOiAxLjUsXG5cdFx0XHRcdGNyb3duUmFkaXVzOiAxNSxcblx0XHRcdFx0YnJhbmNoQ291bnQ6IDIwLFxuXHRcdFx0XHRsZWFmRGVuc2l0eTogMC45LFxuXHRcdFx0XHRzZWFzb25hbENvbG9yOiBuZXcgVEhSRUUuQ29sb3IoMHgyMjhiMjIpLFxuXHRcdFx0XHRiaW9tZVN1aXRhYmlsaXR5OiAwLjk1LFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0c3BlY2llczogXCJQYWxtXCIsXG5cdFx0XHRcdGhlaWdodDogMjAsXG5cdFx0XHRcdHRydW5rUmFkaXVzOiAwLjUsXG5cdFx0XHRcdGNyb3duUmFkaXVzOiA4LFxuXHRcdFx0XHRicmFuY2hDb3VudDogNixcblx0XHRcdFx0bGVhZkRlbnNpdHk6IDAuOCxcblx0XHRcdFx0c2Vhc29uYWxDb2xvcjogbmV3IFRIUkVFLkNvbG9yKDB4MzJjZDMyKSxcblx0XHRcdFx0YmlvbWVTdWl0YWJpbGl0eTogMC45LFxuXHRcdFx0fSxcblx0XHRdLFxuXHRdLFxuXSk7XG5cbi8vIERlZmF1bHQgY29uZmlndXJhdGlvblxuY29uc3QgREVGQVVMVF9DT05GSUc6IFBsYW5ldFJlbmRlckNvbmZpZyA9IHtcblx0cmFkaXVzOiAzLjAsXG5cdHNlZWQ6IERhdGUubm93KCksXG5cdHN0YXJEaXN0YW5jZTogMS4wLFxuXHRzdGFyVHlwZTogXCJHXCIsXG5cdGRldGFpbExldmVsOiAyLFxuXHRmZWF0dXJlRGVuc2l0eTogMC43LFxuXHRjb2xvclZhcmlhdGlvbjogMC44LFxuXHRlbmFibGVMT0Q6IHRydWUsXG5cdG1heEZlYXR1cmVzOiA1MCxcblx0cmVuZGVyRGlzdGFuY2U6IDEwMCxcblx0ZW5hYmxlQXRtb3NwaGVyZTogdHJ1ZSxcblx0ZW5hYmxlUmluZ3M6IHRydWUsXG5cdGVuYWJsZU1vb25zOiB0cnVlLFxuXHRlbmFibGVTcGVjaWFsRWZmZWN0czogdHJ1ZSxcblx0ZW5hYmxlU3VyZmFjZURldGFpbHM6IHRydWUsXG5cdGVuYWJsZVZlZ2V0YXRpb246IHRydWUsXG5cdHRyZWVDb3VudDogNTAwLFxuXHR0ZXJyYWluRGV0YWlsOiAwLjgsXG5cdHN1cmZhY2Vab29tTGV2ZWw6IDEuMCxcblx0ZW5hYmxlQWR2YW5jZWRMaWdodGluZzogdHJ1ZSxcblx0YW1iaWVudEludGVuc2l0eTogMC40LFxuXHRzdW5JbnRlbnNpdHk6IDEuNSxcbn07XG5cbi8vIFBsYW5ldCBSZW5kZXIgUmVzdWx0XG5leHBvcnQgaW50ZXJmYWNlIFBsYW5ldFJlbmRlclJlc3VsdCB7XG5cdG1lc2g6IFRIUkVFLkdyb3VwO1xuXHRjb25maWc6IFBsYW5ldFJlbmRlckNvbmZpZztcblx0cGxhbmV0VHlwZTogUGxhbmV0VHlwZURlZmluaXRpb247XG5cdHN0YXRpc3RpY3M6IGFueTtcblx0bWV0YWRhdGE6IFBsYW5ldFJlbmRlck1ldGFkYXRhO1xufVxuXG4vLyBSZW5kZXIgTWV0YWRhdGFcbmV4cG9ydCBpbnRlcmZhY2UgUGxhbmV0UmVuZGVyTWV0YWRhdGEge1xuXHRyZW5kZXJUaW1lOiBudW1iZXI7XG5cdHBvbHlDb3VudDogbnVtYmVyO1xuXHR0ZXh0dXJlQ291bnQ6IG51bWJlcjtcblx0ZmVhdHVyZUNvdW50OiBudW1iZXI7XG5cdG1lbW9yeVVzYWdlOiBudW1iZXI7XG5cdHF1YWxpdHlMZXZlbDogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgUGxhbmV0UmVuZGVyZXIge1xuXHRwcml2YXRlIGlzRGlzcG9zZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblx0cHJpdmF0ZSByZW5kZXJDYWNoZTogTWFwPHN0cmluZywgVEhSRUUuR3JvdXA+ID0gbmV3IE1hcCgpO1xuXHRwcml2YXRlIGxhc3RSZW5kZXJUaW1lOiBudW1iZXIgPSAwO1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdC8vIEluaXRpYWxpemUgcmVuZGVyZXJcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXIgYSBwbGFuZXQgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZ3VyYXRpb25cblx0ICovXG5cdHB1YmxpYyBhc3luYyByZW5kZXJQbGFuZXRCeVR5cGUocGxhbmV0Q2xhc3M6IFBsYW5ldENsYXNzLCBjb25maWc6IFBsYW5ldFJlbmRlckNvbmZpZyA9IHt9KTogUHJvbWlzZTxQbGFuZXRSZW5kZXJSZXN1bHQ+IHtcblx0XHRjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRjb25zdCBmaW5hbENvbmZpZyA9IHsgLi4uREVGQVVMVF9DT05GSUcsIC4uLmNvbmZpZyB9O1xuXG5cdFx0Ly8gR2V0IHBsYW5ldCB0eXBlIGRlZmluaXRpb25cblx0XHRjb25zdCBwbGFuZXRUeXBlID0gZ2V0UGxhbmV0VHlwZUJ5Q2xhc3MocGxhbmV0Q2xhc3MpO1xuXHRcdGlmICghcGxhbmV0VHlwZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBsYW5ldCBjbGFzczogJHtwbGFuZXRDbGFzc31gKTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBjYWNoZSBmaXJzdFxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5nZW5lcmF0ZUNhY2hlS2V5KGZpbmFsQ29uZmlnKTtcblx0XHRpZiAodGhpcy5yZW5kZXJDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG5cdFx0XHRjb25zdCBjYWNoZWRNZXNoID0gdGhpcy5yZW5kZXJDYWNoZS5nZXQoY2FjaGVLZXkpITtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUNhY2hlZFJlc3VsdChjYWNoZWRNZXNoLCBmaW5hbENvbmZpZywgc3RhcnRUaW1lKTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gR2VuZXJhdGUgcGxhbmV0IG1lc2hcblx0XHRcdGNvbnN0IG1lc2ggPSBhd2FpdCB0aGlzLmdlbmVyYXRlUGxhbmV0TWVzaChwbGFuZXRUeXBlLCBmaW5hbENvbmZpZyk7XG5cblx0XHRcdC8vIEFwcGx5IGVmZmVjdHMgYmFzZWQgb24gY29uZmlndXJhdGlvblxuXHRcdFx0aWYgKGZpbmFsQ29uZmlnLmVuYWJsZUF0bW9zcGhlcmUpIHtcblx0XHRcdFx0dGhpcy5hZGRBdG1vc3BoZXJlKG1lc2gsIHBsYW5ldFR5cGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZmluYWxDb25maWcuZW5hYmxlUmluZ3MgJiYgcGxhbmV0VHlwZS5mZWF0dXJlcy5yaW5ncykge1xuXHRcdFx0XHR0aGlzLmFkZFJpbmdzKG1lc2gsIHBsYW5ldFR5cGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZmluYWxDb25maWcuZW5hYmxlTW9vbnMgJiYgcGxhbmV0VHlwZS5mZWF0dXJlcy5tb29ucyA+IDApIHtcblx0XHRcdFx0dGhpcy5hZGRNb29ucyhtZXNoLCBwbGFuZXRUeXBlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGZpbmFsQ29uZmlnLmVuYWJsZVNwZWNpYWxFZmZlY3RzKSB7XG5cdFx0XHRcdHRoaXMuYWRkU3BlY2lhbEVmZmVjdHMobWVzaCwgcGxhbmV0VHlwZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmaW5hbENvbmZpZy5lbmFibGVBZHZhbmNlZExpZ2h0aW5nKSB7XG5cdFx0XHRcdHRoaXMuc2V0dXBBZHZhbmNlZExpZ2h0aW5nKG1lc2gsIGZpbmFsQ29uZmlnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2VuZXJhdGUgc3VyZmFjZSB2ZWdldGF0aW9uIGZvciBoYWJpdGFibGUgcGxhbmV0c1xuXHRcdFx0aWYgKGZpbmFsQ29uZmlnLmVuYWJsZVN1cmZhY2VEZXRhaWxzKSB7XG5cdFx0XHRcdHRoaXMuZ2VuZXJhdGVWZWdldGF0aW9uKG1lc2gsIHBsYW5ldFR5cGUsIGZpbmFsQ29uZmlnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHJlc3VsdFxuXHRcdFx0dGhpcy5yZW5kZXJDYWNoZS5zZXQoY2FjaGVLZXksIG1lc2gpO1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgbWV0YWRhdGFcblx0XHRcdGNvbnN0IG1ldGFkYXRhID0gdGhpcy5jYWxjdWxhdGVSZW5kZXJNZXRhZGF0YShtZXNoLCBzdGFydFRpbWUpO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRtZXNoLFxuXHRcdFx0XHRjb25maWc6IGZpbmFsQ29uZmlnLFxuXHRcdFx0XHRwbGFuZXRUeXBlLFxuXHRcdFx0XHRzdGF0aXN0aWNzOiB7XG5cdFx0XHRcdFx0dmVydGV4Q291bnQ6IHRoaXMuY2FsY3VsYXRlUG9seUNvdW50KG1lc2gpLFxuXHRcdFx0XHRcdGZlYXR1cmVDb3VudDogdGhpcy5jb3VudEZlYXR1cmVzKG1lc2gpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRtZXRhZGF0YSxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJQbGFuZXQgcmVuZGVyaW5nIGZhaWxlZDpcIiwgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIHRoaXMucmVuZGVyRmFsbGJhY2tQbGFuZXQoZmluYWxDb25maWcsIHN0YXJ0VGltZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGEgc2ltcGxlIHBsYW5ldCBtZXNoIGJhc2VkIG9uIHBsYW5ldCB0eXBlXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIGdlbmVyYXRlUGxhbmV0TWVzaChwbGFuZXRUeXBlOiBQbGFuZXRUeXBlRGVmaW5pdGlvbiwgY29uZmlnOiBQbGFuZXRSZW5kZXJDb25maWcpOiBQcm9taXNlPFRIUkVFLkdyb3VwPiB7XG5cdFx0Y29uc3QgZ3JvdXAgPSBuZXcgVEhSRUUuR3JvdXAoKTtcblxuXHRcdC8vIENyZWF0ZSBiYXNpYyBzcGhlcmUgZ2VvbWV0cnlcblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShjb25maWcucmFkaXVzIHx8IDMuMCwgMzIsIDMyKTtcblxuXHRcdC8vIENyZWF0ZSBtYXRlcmlhbCBiYXNlZCBvbiBwbGFuZXQgdHlwZVxuXHRcdGNvbnN0IG1hdGVyaWFsID0gdGhpcy5jcmVhdGVQbGFuZXRNYXRlcmlhbChwbGFuZXRUeXBlLCBjb25maWcpO1xuXG5cdFx0Ly8gQ3JlYXRlIG1lc2hcblx0XHRjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRncm91cC5hZGQobWVzaCk7XG5cblx0XHQvLyBBZGQgYmFzaWMgcm90YXRpb25cblx0XHRtZXNoLnJvdGF0aW9uLnggPSBNYXRoLlBJICogMC4xOyAvLyBTbGlnaHQgdGlsdFxuXG5cdFx0cmV0dXJuIGdyb3VwO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBwbGFuZXQgbWF0ZXJpYWwgYmFzZWQgb24gdHlwZVxuXHQgKi9cblx0cHJpdmF0ZSBjcmVhdGVQbGFuZXRNYXRlcmlhbChwbGFuZXRUeXBlOiBQbGFuZXRUeXBlRGVmaW5pdGlvbiwgY29uZmlnOiBQbGFuZXRSZW5kZXJDb25maWcpOiBUSFJFRS5NYXRlcmlhbCB7XG5cdFx0Ly8gVXNlIHByaW1hcnkgY29sb3JzIGZyb20gcGxhbmV0IHR5cGVcblx0XHRjb25zdCBwcmltYXJ5Q29sb3IgPSBwbGFuZXRUeXBlLnByaW1hcnlDb2xvcnNbMF0gfHwgbmV3IFRIUkVFLkNvbG9yKDB4NGE3YzU5KTtcblxuXHRcdC8vIENyZWF0ZSBiYXNpYyBtYXRlcmlhbFxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuXHRcdFx0Y29sb3I6IHByaW1hcnlDb2xvcixcblx0XHRcdGVtaXNzaXZlOiBuZXcgVEhSRUUuQ29sb3IoMHgxMTExMTEpLFxuXHRcdFx0ZW1pc3NpdmVJbnRlbnNpdHk6IDAuMSxcblx0XHR9KTtcblxuXHRcdHJldHVybiBtYXRlcmlhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgcmFkaXVzIGZyb20gbWVzaCBnZW9tZXRyeVxuXHQgKi9cblx0cHJpdmF0ZSBnZXRNZXNoUmFkaXVzKG1lc2g6IFRIUkVFLkdyb3VwKTogbnVtYmVyIHtcblx0XHRjb25zdCBmaXJzdE1lc2ggPSBtZXNoLmNoaWxkcmVuWzBdIGFzIFRIUkVFLk1lc2g7XG5cdFx0aWYgKGZpcnN0TWVzaCAmJiBmaXJzdE1lc2guZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5TcGhlcmVHZW9tZXRyeSkge1xuXHRcdFx0cmV0dXJuIChmaXJzdE1lc2guZ2VvbWV0cnkgYXMgVEhSRUUuU3BoZXJlR2VvbWV0cnkpLnBhcmFtZXRlcnMucmFkaXVzO1xuXHRcdH1cblx0XHRyZXR1cm4gMy4wOyAvLyBEZWZhdWx0IHJhZGl1c1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhdG1vc3BoZXJlIGVmZmVjdFxuXHQgKi9cblx0cHJpdmF0ZSBhZGRBdG1vc3BoZXJlKG1lc2g6IFRIUkVFLkdyb3VwLCBwbGFuZXRUeXBlOiBQbGFuZXRUeXBlRGVmaW5pdGlvbik6IHZvaWQge1xuXHRcdGlmICghcGxhbmV0VHlwZS5mZWF0dXJlcy5jbG91ZHMpIHJldHVybjtcblxuXHRcdGNvbnN0IHJhZGl1cyA9IHRoaXMuZ2V0TWVzaFJhZGl1cyhtZXNoKTtcblx0XHRjb25zdCBhdG1vc3BoZXJlR2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkocmFkaXVzICogMS4xLCAzMiwgMzIpO1xuXG5cdFx0Y29uc3QgYXRtb3NwaGVyZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdGNvbG9yOiAweDg3Y2VlYixcblx0XHRcdHRyYW5zcGFyZW50OiB0cnVlLFxuXHRcdFx0b3BhY2l0eTogMC4zLFxuXHRcdFx0c2lkZTogVEhSRUUuQmFja1NpZGUsXG5cdFx0fSk7XG5cblx0XHRjb25zdCBhdG1vc3BoZXJlID0gbmV3IFRIUkVFLk1lc2goYXRtb3NwaGVyZUdlb21ldHJ5LCBhdG1vc3BoZXJlTWF0ZXJpYWwpO1xuXHRcdG1lc2guYWRkKGF0bW9zcGhlcmUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCByaW5nIHN5c3RlbVxuXHQgKi9cblx0cHJpdmF0ZSBhZGRSaW5ncyhtZXNoOiBUSFJFRS5Hcm91cCwgcGxhbmV0VHlwZTogUGxhbmV0VHlwZURlZmluaXRpb24pOiB2b2lkIHtcblx0XHRjb25zdCByYWRpdXMgPSB0aGlzLmdldE1lc2hSYWRpdXMobWVzaCk7XG5cdFx0Y29uc3QgcmluZ0dlb21ldHJ5ID0gbmV3IFRIUkVFLlJpbmdHZW9tZXRyeShyYWRpdXMgKiAxLjUsIHJhZGl1cyAqIDIuNSwgNjQpO1xuXG5cdFx0Y29uc3QgcmluZ01hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdGNvbG9yOiAweGNjY2NjYyxcblx0XHRcdHRyYW5zcGFyZW50OiB0cnVlLFxuXHRcdFx0b3BhY2l0eTogMC42LFxuXHRcdFx0c2lkZTogVEhSRUUuRG91YmxlU2lkZSxcblx0XHR9KTtcblxuXHRcdGNvbnN0IHJpbmdzID0gbmV3IFRIUkVFLk1lc2gocmluZ0dlb21ldHJ5LCByaW5nTWF0ZXJpYWwpO1xuXHRcdHJpbmdzLnJvdGF0aW9uLnggPSBNYXRoLlBJICogMC41OyAvLyBSb3RhdGUgdG8gYmUgaG9yaXpvbnRhbFxuXHRcdG1lc2guYWRkKHJpbmdzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgbW9vbnNcblx0ICovXG5cdHByaXZhdGUgYWRkTW9vbnMobWVzaDogVEhSRUUuR3JvdXAsIHBsYW5ldFR5cGU6IFBsYW5ldFR5cGVEZWZpbml0aW9uKTogdm9pZCB7XG5cdFx0Y29uc3QgbW9vbkNvdW50ID0gTWF0aC5taW4ocGxhbmV0VHlwZS5mZWF0dXJlcy5tb29ucywgMyk7IC8vIExpbWl0IHRvIDMgZm9yIHBlcmZvcm1hbmNlXG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG1vb25Db3VudDsgaSsrKSB7XG5cdFx0XHRjb25zdCBtb29uR2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC4zLCAxNiwgMTYpO1xuXHRcdFx0Y29uc3QgbW9vbk1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuXHRcdFx0XHRjb2xvcjogMHg4ODg4ODgsXG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgbW9vbiA9IG5ldyBUSFJFRS5NZXNoKG1vb25HZW9tZXRyeSwgbW9vbk1hdGVyaWFsKTtcblxuXHRcdFx0Ly8gUG9zaXRpb24gbW9vbnMgaW4gb3JiaXRcblx0XHRcdGNvbnN0IGFuZ2xlID0gKGkgLyBtb29uQ291bnQpICogTWF0aC5QSSAqIDI7XG5cdFx0XHRjb25zdCBkaXN0YW5jZSA9IDQgKyBpICogMC41O1xuXHRcdFx0bW9vbi5wb3NpdGlvbi5zZXQoTWF0aC5jb3MoYW5nbGUpICogZGlzdGFuY2UsIE1hdGguc2luKGFuZ2xlKSAqIGRpc3RhbmNlICogMC4zLCBNYXRoLnNpbihhbmdsZSkgKiBkaXN0YW5jZSAqIDAuNyk7XG5cblx0XHRcdG1lc2guYWRkKG1vb24pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgc3BlY2lhbCBlZmZlY3RzIGJhc2VkIG9uIHBsYW5ldCB0eXBlXG5cdCAqL1xuXHRwcml2YXRlIGFkZFNwZWNpYWxFZmZlY3RzKG1lc2g6IFRIUkVFLkdyb3VwLCBwbGFuZXRUeXBlOiBQbGFuZXRUeXBlRGVmaW5pdGlvbik6IHZvaWQge1xuXHRcdC8vIEFkZCBsYXZhIHBhcnRpY2xlcyBmb3IgbGF2YSB3b3JsZHNcblx0XHRpZiAocGxhbmV0VHlwZS5jbGFzcyA9PT0gUGxhbmV0Q2xhc3MuTEFWQV9XT1JMRCkge1xuXHRcdFx0dGhpcy5hZGRMYXZhUGFydGljbGVzKG1lc2gpO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBpY2Ugc2hpbW1lcnMgZm9yIGljZSBnaWFudHNcblx0XHRpZiAocGxhbmV0VHlwZS5jbGFzcyA9PT0gUGxhbmV0Q2xhc3MuSUNFX0dJQU5UKSB7XG5cdFx0XHR0aGlzLmFkZEljZVNoaW1tZXJzKG1lc2gpO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBhdXJvcmEgZm9yIHBsYW5ldHMgd2l0aCBtYWduZXRvc3BoZXJlXG5cdFx0aWYgKHBsYW5ldFR5cGUuZmVhdHVyZXMuYXVyb3JhZSkge1xuXHRcdFx0dGhpcy5hZGRBdXJvcmFFZmZlY3QobWVzaCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBsYXZhIHBhcnRpY2xlIGVmZmVjdFxuXHQgKi9cblx0cHJpdmF0ZSBhZGRMYXZhUGFydGljbGVzKG1lc2g6IFRIUkVFLkdyb3VwKTogdm9pZCB7XG5cdFx0Y29uc3QgcGFydGljbGVDb3VudCA9IDUwO1xuXHRcdGNvbnN0IHBhcnRpY2xlcyA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkocGFydGljbGVDb3VudCAqIDMpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNsZUNvdW50ICogMzsgaSArPSAzKSB7XG5cdFx0XHRwb3NpdGlvbnNbaV0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiA2O1xuXHRcdFx0cG9zaXRpb25zW2kgKyAxXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDY7XG5cdFx0XHRwb3NpdGlvbnNbaSArIDJdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogNjtcblx0XHR9XG5cblx0XHRwYXJ0aWNsZXMuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKTtcblxuXHRcdGNvbnN0IHBhcnRpY2xlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoe1xuXHRcdFx0Y29sb3I6IDB4ZmY0NTAwLFxuXHRcdFx0c2l6ZTogMC4xLFxuXHRcdFx0dHJhbnNwYXJlbnQ6IHRydWUsXG5cdFx0XHRvcGFjaXR5OiAwLjgsXG5cdFx0fSk7XG5cblx0XHRjb25zdCBwYXJ0aWNsZVN5c3RlbSA9IG5ldyBUSFJFRS5Qb2ludHMocGFydGljbGVzLCBwYXJ0aWNsZU1hdGVyaWFsKTtcblx0XHRtZXNoLmFkZChwYXJ0aWNsZVN5c3RlbSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkIGljZSBzaGltbWVyIGVmZmVjdFxuXHQgKi9cblx0cHJpdmF0ZSBhZGRJY2VTaGltbWVycyhtZXNoOiBUSFJFRS5Hcm91cCk6IHZvaWQge1xuXHRcdGNvbnN0IHJhZGl1cyA9IHRoaXMuZ2V0TWVzaFJhZGl1cyhtZXNoKTtcblx0XHRjb25zdCBzaGltbWVyR2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkocmFkaXVzICogMS4wNSwgMzIsIDMyKTtcblxuXHRcdGNvbnN0IHNoaW1tZXJNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRjb2xvcjogMHg4N2NlZWIsXG5cdFx0XHR0cmFuc3BhcmVudDogdHJ1ZSxcblx0XHRcdG9wYWNpdHk6IDAuMixcblx0XHRcdHNpZGU6IFRIUkVFLkJhY2tTaWRlLFxuXHRcdH0pO1xuXG5cdFx0Y29uc3Qgc2hpbW1lciA9IG5ldyBUSFJFRS5NZXNoKHNoaW1tZXJHZW9tZXRyeSwgc2hpbW1lck1hdGVyaWFsKTtcblx0XHRtZXNoLmFkZChzaGltbWVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgYXVyb3JhIGVmZmVjdFxuXHQgKi9cblx0cHJpdmF0ZSBhZGRBdXJvcmFFZmZlY3QobWVzaDogVEhSRUUuR3JvdXApOiB2b2lkIHtcblx0XHRjb25zdCByYWRpdXMgPSB0aGlzLmdldE1lc2hSYWRpdXMobWVzaCk7XG5cdFx0Y29uc3QgYXVyb3JhR2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkocmFkaXVzICogMS4yLCAzMiwgMzIpO1xuXG5cdFx0Y29uc3QgYXVyb3JhTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0Y29sb3I6IDB4MDBmZjAwLFxuXHRcdFx0dHJhbnNwYXJlbnQ6IHRydWUsXG5cdFx0XHRvcGFjaXR5OiAwLjEsXG5cdFx0XHRzaWRlOiBUSFJFRS5CYWNrU2lkZSxcblx0XHR9KTtcblxuXHRcdGNvbnN0IGF1cm9yYSA9IG5ldyBUSFJFRS5NZXNoKGF1cm9yYUdlb21ldHJ5LCBhdXJvcmFNYXRlcmlhbCk7XG5cdFx0bWVzaC5hZGQoYXVyb3JhKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBzdXJmYWNlIHZlZ2V0YXRpb24gZm9yIGhhYml0YWJsZSBwbGFuZXRzXG5cdCAqL1xuXHRwcml2YXRlIGdlbmVyYXRlVmVnZXRhdGlvbihtZXNoOiBUSFJFRS5Hcm91cCwgcGxhbmV0VHlwZTogUGxhbmV0VHlwZURlZmluaXRpb24sIGNvbmZpZzogUGxhbmV0UmVuZGVyQ29uZmlnKTogdm9pZCB7XG5cdFx0Ly8gT25seSBnZW5lcmF0ZSB2ZWdldGF0aW9uIGZvciBoYWJpdGFibGUgcGxhbmV0cyB3aXRoIGZvcmVzdHNcblx0XHRpZiAoIXBsYW5ldFR5cGUuZmVhdHVyZXMuZm9yZXN0cyB8fCAhY29uZmlnLmVuYWJsZVZlZ2V0YXRpb24pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiBwbGFuZXQgaXMgaGFiaXRhYmxlIGVub3VnaCBmb3IgdHJlZXMgKGhhYml0YWJpbGl0eSA+IDcwKVxuXHRcdGlmIChwbGFuZXRUeXBlLmJhc2VIYWJpdGFiaWxpdHkub3ZlcmFsbFNjb3JlIDwgNzApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZyhg8J+MsiBbUExBTkVUXSBHZW5lcmF0aW5nIHZlZ2V0YXRpb24gZm9yICR7cGxhbmV0VHlwZS5uYW1lfWApO1xuXG5cdFx0Y29uc3QgdmVnZXRhdGlvbkdyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cdFx0dmVnZXRhdGlvbkdyb3VwLm5hbWUgPSBcInZlZ2V0YXRpb25cIjtcblxuXHRcdC8vIERldGVybWluZSBwcmltYXJ5IGJpb21lIGZvciB0cmVlIHNlbGVjdGlvblxuXHRcdGNvbnN0IHByaW1hcnlCaW9tZSA9IHRoaXMuZ2V0UHJpbWFyeUJpb21lKHBsYW5ldFR5cGUpO1xuXHRcdGNvbnN0IHRyZWVTcGVjaWVzID0gVFJFRV9TUEVDSUVTX0JZX0JJT01FLmdldChwcmltYXJ5QmlvbWUpIHx8IFRSRUVfU1BFQ0lFU19CWV9CSU9NRS5nZXQoQmlvbWVUeXBlLlRFTVBFUkFURV9GT1JFU1QpO1xuXG5cdFx0aWYgKCF0cmVlU3BlY2llcykgcmV0dXJuO1xuXG5cdFx0Y29uc3QgdHJlZUNvdW50ID0gTWF0aC5taW4oY29uZmlnLnRyZWVDb3VudCB8fCA1MDAsIDEwMDApOyAvLyBDYXAgYXQgMTAwMCBmb3IgcGVyZm9ybWFuY2Vcblx0XHRjb25zdCByYWRpdXMgPSBjb25maWcucmFkaXVzIHx8IDMuMDtcblxuXHRcdC8vIEdlbmVyYXRlIHRyZWVzIHVzaW5nIFBvaXNzb24gZGlzayBzYW1wbGluZyBmb3IgcmVhbGlzdGljIGRpc3RyaWJ1dGlvblxuXHRcdGNvbnN0IHRyZWVQb3NpdGlvbnMgPSB0aGlzLmdlbmVyYXRlVHJlZVBvc2l0aW9ucyh0cmVlQ291bnQsIHJhZGl1cyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRyZWVQb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gdHJlZVBvc2l0aW9uc1tpXTtcblxuXHRcdFx0aWYgKCFwb3NpdGlvbikgY29udGludWU7IC8vIFNraXAgaWYgbm8gcG9zaXRpb24gYXZhaWxhYmxlXG5cblx0XHRcdC8vIFNlbGVjdCByYW5kb20gdHJlZSBzcGVjaWVzXG5cdFx0XHRjb25zdCBzcGVjaWVzSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0cmVlU3BlY2llcy5sZW5ndGgpO1xuXHRcdFx0Y29uc3Qgc3BlY2llcyA9IHRyZWVTcGVjaWVzW3NwZWNpZXNJbmRleF07XG5cblx0XHRcdGlmICghc3BlY2llcykgY29udGludWU7IC8vIFNraXAgaWYgbm8gc3BlY2llcyBhdmFpbGFibGVcblxuXHRcdFx0Ly8gR2VuZXJhdGUgaW5kaXZpZHVhbCB0cmVlXG5cdFx0XHRjb25zdCB0cmVlID0gdGhpcy5nZW5lcmF0ZVRyZWUoc3BlY2llcywgcG9zaXRpb24sIHJhZGl1cyk7XG5cdFx0XHRpZiAodHJlZSkge1xuXHRcdFx0XHR2ZWdldGF0aW9uR3JvdXAuYWRkKHRyZWUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQZXJmb3JtYW5jZSBjaGVjayAtIGRvbid0IGdlbmVyYXRlIHRvbyBtYW55IHRyZWVzIHBlciBmcmFtZVxuXHRcdFx0aWYgKGkgJSA1MCA9PT0gMCkge1xuXHRcdFx0XHQvLyBDb3VsZCB5aWVsZCBjb250cm9sIGhlcmUgaW4gYSByZWFsIGltcGxlbWVudGF0aW9uXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWVzaC5hZGQodmVnZXRhdGlvbkdyb3VwKTtcblx0XHRjb25zb2xlLmxvZyhg8J+MsiBbUExBTkVUXSBHZW5lcmF0ZWQgJHt2ZWdldGF0aW9uR3JvdXAuY2hpbGRyZW4ubGVuZ3RofSB0cmVlc2ApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIHJlYWxpc3RpYyB0cmVlIHBvc2l0aW9ucyB1c2luZyBQb2lzc29uIGRpc2sgc2FtcGxpbmdcblx0ICovXG5cdHByaXZhdGUgZ2VuZXJhdGVUcmVlUG9zaXRpb25zKGNvdW50OiBudW1iZXIsIHBsYW5ldFJhZGl1czogbnVtYmVyKTogVEhSRUUuVmVjdG9yM1tdIHtcblx0XHRjb25zdCBwb3NpdGlvbnM6IFRIUkVFLlZlY3RvcjNbXSA9IFtdO1xuXHRcdGNvbnN0IG1pbkRpc3RhbmNlID0gMC4xOyAvLyBNaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdHJlZXNcblx0XHRjb25zdCBtYXhBdHRlbXB0cyA9IDMwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHRsZXQgYXR0ZW1wdHMgPSAwO1xuXHRcdFx0bGV0IHZhbGlkUG9zaXRpb24gPSBmYWxzZTtcblxuXHRcdFx0d2hpbGUgKCF2YWxpZFBvc2l0aW9uICYmIGF0dGVtcHRzIDwgbWF4QXR0ZW1wdHMpIHtcblx0XHRcdFx0Ly8gR2VuZXJhdGUgcmFuZG9tIHBvaW50IG9uIHNwaGVyZSBzdXJmYWNlXG5cdFx0XHRcdGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuXHRcdFx0XHRjb25zdCBwaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcblxuXHRcdFx0XHRjb25zdCB4ID0gcGxhbmV0UmFkaXVzICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKTtcblx0XHRcdFx0Y29uc3QgeSA9IHBsYW5ldFJhZGl1cyAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSk7XG5cdFx0XHRcdGNvbnN0IHogPSBwbGFuZXRSYWRpdXMgKiBNYXRoLmNvcyhwaGkpO1xuXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoeCwgeSwgeik7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgbWluaW11bSBkaXN0YW5jZSB0byBleGlzdGluZyB0cmVlc1xuXHRcdFx0XHR2YWxpZFBvc2l0aW9uID0gdHJ1ZTtcblx0XHRcdFx0Zm9yIChjb25zdCBleGlzdGluZ1BvcyBvZiBwb3NpdGlvbnMpIHtcblx0XHRcdFx0XHRpZiAocG9zaXRpb24uZGlzdGFuY2VUbyhleGlzdGluZ1BvcykgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0dmFsaWRQb3NpdGlvbiA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHZhbGlkUG9zaXRpb24pIHtcblx0XHRcdFx0XHRwb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhdHRlbXB0cysrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBwb3NpdGlvbnM7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGUgYSBzaW5nbGUgcmVhbGlzdGljIHRyZWVcblx0ICovXG5cdHByaXZhdGUgZ2VuZXJhdGVUcmVlKHNwZWNpZXM6IFRyZWVDb25maWcsIHBvc2l0aW9uOiBUSFJFRS5WZWN0b3IzLCBwbGFuZXRSYWRpdXM6IG51bWJlcik6IFRIUkVFLkdyb3VwIHwgbnVsbCB7XG5cdFx0Y29uc3QgdHJlZUdyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cblx0XHQvLyBTY2FsZSB0cmVlIGJhc2VkIG9uIHBsYW5ldCBzaXplIGFuZCByYW5kb20gdmFyaWF0aW9uXG5cdFx0Y29uc3Qgc2NhbGUgPSAocGxhbmV0UmFkaXVzIC8gMy4wKSAqICgwLjggKyBNYXRoLnJhbmRvbSgpICogMC40KTtcblx0XHRjb25zdCBoZWlnaHQgPSBzcGVjaWVzLmhlaWdodCAqIHNjYWxlICogMC4wMTsgLy8gU2NhbGUgZG93biBmb3IgcGxhbmV0IHN1cmZhY2Vcblx0XHRjb25zdCB0cnVua1JhZGl1cyA9IHNwZWNpZXMudHJ1bmtSYWRpdXMgKiBzY2FsZSAqIDAuMDE7XG5cdFx0Y29uc3QgY3Jvd25SYWRpdXMgPSBzcGVjaWVzLmNyb3duUmFkaXVzICogc2NhbGUgKiAwLjAxO1xuXG5cdFx0Ly8gR2VuZXJhdGUgdHJ1bmtcblx0XHRjb25zdCB0cnVuayA9IHRoaXMuZ2VuZXJhdGVUcnVuayhoZWlnaHQsIHRydW5rUmFkaXVzKTtcblx0XHRpZiAodHJ1bmspIHtcblx0XHRcdHRyZWVHcm91cC5hZGQodHJ1bmspO1xuXHRcdH1cblxuXHRcdC8vIEdlbmVyYXRlIGNyb3duL2ZvbGlhZ2Vcblx0XHRjb25zdCBjcm93biA9IHRoaXMuZ2VuZXJhdGVDcm93bihzcGVjaWVzLCBoZWlnaHQsIGNyb3duUmFkaXVzKTtcblx0XHRpZiAoY3Jvd24pIHtcblx0XHRcdGNyb3duLnBvc2l0aW9uLnkgPSBoZWlnaHQgKiAwLjc7IC8vIFBvc2l0aW9uIGNyb3duIGFib3ZlIHRydW5rXG5cdFx0XHR0cmVlR3JvdXAuYWRkKGNyb3duKTtcblx0XHR9XG5cblx0XHQvLyBQb3NpdGlvbiB0cmVlIG9uIHBsYW5ldCBzdXJmYWNlXG5cdFx0Y29uc3Qgc3VyZmFjZU5vcm1hbCA9IHBvc2l0aW9uLmNsb25lKCkubm9ybWFsaXplKCk7XG5cdFx0dHJlZUdyb3VwLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuXHRcdHRyZWVHcm91cC5sb29rQXQocG9zaXRpb24uY2xvbmUoKS5hZGQoc3VyZmFjZU5vcm1hbCkpO1xuXG5cdFx0Ly8gQWRkIHNsaWdodCByYW5kb20gcm90YXRpb25cblx0XHR0cmVlR3JvdXAucm90YXRlWShNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIpO1xuXG5cdFx0cmV0dXJuIHRyZWVHcm91cDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0cmVlIHRydW5rXG5cdCAqL1xuXHRwcml2YXRlIGdlbmVyYXRlVHJ1bmsoaGVpZ2h0OiBudW1iZXIsIHJhZGl1czogbnVtYmVyKTogVEhSRUUuTWVzaCB7XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeShyYWRpdXMgKiAwLjgsIHJhZGl1cywgaGVpZ2h0LCA4KTtcblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHtcblx0XHRcdGNvbG9yOiBuZXcgVEhSRUUuQ29sb3IoMHg0YTRhNGEpLmxlcnAobmV3IFRIUkVFLkNvbG9yKDB4OGI0NTEzKSwgMC43KSxcblx0XHR9KTtcblxuXHRcdGNvbnN0IHRydW5rID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHR0cnVuay5wb3NpdGlvbi55ID0gaGVpZ2h0IC8gMjtcblx0XHR0cnVuay5jYXN0U2hhZG93ID0gdHJ1ZTtcblx0XHR0cnVuay5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0cnVuaztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0cmVlIGNyb3duL2ZvbGlhZ2Vcblx0ICovXG5cdHByaXZhdGUgZ2VuZXJhdGVDcm93bihzcGVjaWVzOiBUcmVlQ29uZmlnLCB0cnVua0hlaWdodDogbnVtYmVyLCByYWRpdXM6IG51bWJlcik6IFRIUkVFLkdyb3VwIHtcblx0XHRjb25zdCBjcm93bkdyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cblx0XHQvLyBDcmVhdGUgbXVsdGlwbGUgZm9saWFnZSBzcGhlcmVzIGZvciByZWFsaXN0aWMgYXBwZWFyYW5jZVxuXHRcdGNvbnN0IGZvbGlhZ2VDb3VudCA9IDMgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZm9saWFnZUNvdW50OyBpKyspIHtcblx0XHRcdGNvbnN0IGZvbGlhZ2VSYWRpdXMgPSByYWRpdXMgKiAoMC42ICsgTWF0aC5yYW5kb20oKSAqIDAuNCk7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShmb2xpYWdlUmFkaXVzLCA4LCA2KTtcblxuXHRcdFx0Ly8gQ3JlYXRlIHJlYWxpc3RpYyBsZWFmIG1hdGVyaWFsXG5cdFx0XHRjb25zdCBsZWFmQ29sb3IgPSBzcGVjaWVzLnNlYXNvbmFsQ29sb3IuY2xvbmUoKTtcblx0XHRcdGxlYWZDb2xvci5sZXJwKG5ldyBUSFJFRS5Db2xvcigweDJmNGYyZiksIE1hdGgucmFuZG9tKCkgKiAwLjMpOyAvLyBBZGQgdmFyaWF0aW9uXG5cblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuXHRcdFx0XHRjb2xvcjogbGVhZkNvbG9yLFxuXHRcdFx0XHR0cmFuc3BhcmVudDogdHJ1ZSxcblx0XHRcdFx0b3BhY2l0eTogMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuMixcblx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBmb2xpYWdlID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcblxuXHRcdFx0Ly8gUG9zaXRpb24gZm9saWFnZSBzcGhlcmVzIHJhbmRvbWx5IHdpdGhpbiBjcm93biBhcmVhXG5cdFx0XHRmb2xpYWdlLnBvc2l0aW9uLnNldCgoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiByYWRpdXMgKiAwLjUsIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRydW5rSGVpZ2h0ICogMC4zLCAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiByYWRpdXMgKiAwLjUpO1xuXG5cdFx0XHRmb2xpYWdlLmNhc3RTaGFkb3cgPSB0cnVlO1xuXHRcdFx0Zm9saWFnZS5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcblx0XHRcdGNyb3duR3JvdXAuYWRkKGZvbGlhZ2UpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjcm93bkdyb3VwO1xuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBwcmltYXJ5IGJpb21lIGZvciBhIHBsYW5ldCB0eXBlXG5cdCAqL1xuXHRwcml2YXRlIGdldFByaW1hcnlCaW9tZShwbGFuZXRUeXBlOiBQbGFuZXRUeXBlRGVmaW5pdGlvbik6IEJpb21lVHlwZSB7XG5cdFx0aWYgKHBsYW5ldFR5cGUucG9zc2libGVCaW9tZXMgJiYgcGxhbmV0VHlwZS5wb3NzaWJsZUJpb21lcy5sZW5ndGggPiAwKSB7XG5cdFx0XHQvLyBSZXR1cm4gdGhlIGZpcnN0IGJpb21lIHRoYXQgaGFzIHRyZWUgc3BlY2llcyBkZWZpbmVkXG5cdFx0XHRmb3IgKGNvbnN0IGJpb21lIG9mIHBsYW5ldFR5cGUucG9zc2libGVCaW9tZXMpIHtcblx0XHRcdFx0aWYgKFRSRUVfU1BFQ0lFU19CWV9CSU9NRS5oYXMoYmlvbWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJpb21lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRGVmYXVsdCB0byB0ZW1wZXJhdGUgZm9yZXN0IGZvciBoYWJpdGFibGUgcGxhbmV0c1xuXHRcdHJldHVybiBCaW9tZVR5cGUuVEVNUEVSQVRFX0ZPUkVTVDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXR1cCBhZHZhbmNlZCBsaWdodGluZ1xuXHQgKi9cblx0cHJpdmF0ZSBzZXR1cEFkdmFuY2VkTGlnaHRpbmcobWVzaDogVEhSRUUuR3JvdXAsIGNvbmZpZzogUGxhbmV0UmVuZGVyQ29uZmlnKTogdm9pZCB7XG5cdFx0Ly8gQWRkIGFtYmllbnQgbGlnaHRcblx0XHRjb25zdCBhbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4NDA0MDQwLCBjb25maWcuYW1iaWVudEludGVuc2l0eSB8fCAwLjQpO1xuXHRcdG1lc2guYWRkKGFtYmllbnRMaWdodCk7XG5cblx0XHQvLyBBZGQgZGlyZWN0aW9uYWwgbGlnaHQgKHN1bilcblx0XHRjb25zdCBzdW5MaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCBjb25maWcuc3VuSW50ZW5zaXR5IHx8IDEuNSk7XG5cdFx0c3VuTGlnaHQucG9zaXRpb24uc2V0KDEwLCAxMCwgNSk7XG5cdFx0bWVzaC5hZGQoc3VuTGlnaHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBhdmFpbGFibGUgcGxhbmV0IHR5cGVzXG5cdCAqL1xuXHRwdWJsaWMgZ2V0QXZhaWxhYmxlUGxhbmV0VHlwZXMoKTogUGxhbmV0Q2xhc3NbXSB7XG5cdFx0cmV0dXJuIEFycmF5LmZyb20oUExBTkVUX1RZUEVTLmtleXMoKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHBsYW5ldCB0eXBlIGluZm9ybWF0aW9uXG5cdCAqL1xuXHRwdWJsaWMgZ2V0UGxhbmV0VHlwZUluZm8ocGxhbmV0Q2xhc3M6IFBsYW5ldENsYXNzKTogUGxhbmV0VHlwZURlZmluaXRpb24gfCB1bmRlZmluZWQge1xuXHRcdHJldHVybiBnZXRQbGFuZXRUeXBlQnlDbGFzcyhwbGFuZXRDbGFzcyk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHF1YWxpdHkgc2V0dGluZ3Ncblx0ICovXG5cdHB1YmxpYyB1cGRhdGVRdWFsaXR5KHF1YWxpdHlMZXZlbDogbnVtYmVyKTogdm9pZCB7XG5cdFx0Ly8gQWRqdXN0IGRldGFpbCBsZXZlbCBiYXNlZCBvbiBxdWFsaXR5XG5cdFx0Y29uc3QgZGV0YWlsTGV2ZWwgPSBNYXRoLm1heCgxLCBNYXRoLm1pbig1LCBxdWFsaXR5TGV2ZWwpKTtcblxuXHRcdC8vIENsZWFyIGNhY2hlIHRvIGZvcmNlIHJlZ2VuZXJhdGlvbiB3aXRoIG5ldyBxdWFsaXR5XG5cdFx0dGhpcy5jbGVhckNhY2hlKCk7XG5cblx0XHRjb25zb2xlLmxvZyhg8J+MjSBbUExBTkVUXSBRdWFsaXR5IHVwZGF0ZWQgdG8gbGV2ZWwgJHtkZXRhaWxMZXZlbH1gKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNwb3NlIG9mIHJlc291cmNlc1xuXHQgKi9cblx0cHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XG5cdFx0aWYgKHRoaXMuaXNEaXNwb3NlZCkgcmV0dXJuO1xuXG5cdFx0Ly8gQ2xlYXIgY2FjaGVcblx0XHR0aGlzLmNsZWFyQ2FjaGUoKTtcblxuXHRcdHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG5cdFx0Y29uc29sZS5sb2coXCLwn4yNIFtQTEFORVRdIFJlbmRlcmVyIGRpc3Bvc2VkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGNhY2hlIGtleSBmb3IgY29uZmlndXJhdGlvblxuXHQgKi9cblx0cHJpdmF0ZSBnZW5lcmF0ZUNhY2hlS2V5KGNvbmZpZzogUGxhbmV0UmVuZGVyQ29uZmlnKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gYCR7Y29uZmlnLnBsYW5ldENsYXNzfS0ke2NvbmZpZy5yYWRpdXN9LSR7Y29uZmlnLnNlZWR9LSR7Y29uZmlnLmRldGFpbExldmVsfWA7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGNhY2hlZCByZXN1bHRcblx0ICovXG5cdHByaXZhdGUgY3JlYXRlQ2FjaGVkUmVzdWx0KG1lc2g6IFRIUkVFLkdyb3VwLCBjb25maWc6IFBsYW5ldFJlbmRlckNvbmZpZywgc3RhcnRUaW1lOiBudW1iZXIpOiBQbGFuZXRSZW5kZXJSZXN1bHQge1xuXHRcdGNvbnN0IHBsYW5ldFR5cGUgPSBnZXRQbGFuZXRUeXBlQnlDbGFzcyhjb25maWcucGxhbmV0Q2xhc3MgfHwgUGxhbmV0Q2xhc3MuVEVSUkVTVFJJQUwpITtcblx0XHRjb25zdCBtZXRhZGF0YSA9IHRoaXMuY2FsY3VsYXRlUmVuZGVyTWV0YWRhdGEobWVzaCwgc3RhcnRUaW1lKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRtZXNoOiBtZXNoLmNsb25lKCksXG5cdFx0XHRjb25maWcsXG5cdFx0XHRwbGFuZXRUeXBlLFxuXHRcdFx0c3RhdGlzdGljczoge1xuXHRcdFx0XHR2ZXJ0ZXhDb3VudDogdGhpcy5jYWxjdWxhdGVQb2x5Q291bnQobWVzaCksXG5cdFx0XHRcdGZlYXR1cmVDb3VudDogdGhpcy5jb3VudEZlYXR1cmVzKG1lc2gpLFxuXHRcdFx0fSxcblx0XHRcdG1ldGFkYXRhLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlIHJlbmRlciBtZXRhZGF0YVxuXHQgKi9cblx0cHJpdmF0ZSBjYWxjdWxhdGVSZW5kZXJNZXRhZGF0YShtZXNoOiBUSFJFRS5Hcm91cCwgc3RhcnRUaW1lOiBudW1iZXIpOiBQbGFuZXRSZW5kZXJNZXRhZGF0YSB7XG5cdFx0Y29uc3QgcmVuZGVyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXHRcdGNvbnN0IHBvbHlDb3VudCA9IHRoaXMuY2FsY3VsYXRlUG9seUNvdW50KG1lc2gpO1xuXHRcdGNvbnN0IGZlYXR1cmVDb3VudCA9IHRoaXMuY291bnRGZWF0dXJlcyhtZXNoKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRyZW5kZXJUaW1lLFxuXHRcdFx0cG9seUNvdW50LFxuXHRcdFx0dGV4dHVyZUNvdW50OiAxLCAvLyBTaW1wbGlmaWVkXG5cdFx0XHRmZWF0dXJlQ291bnQsXG5cdFx0XHRtZW1vcnlVc2FnZTogcG9seUNvdW50ICogMzIsIC8vIFJvdWdoIGVzdGltYXRlXG5cdFx0XHRxdWFsaXR5TGV2ZWw6IHRoaXMuZGV0ZXJtaW5lUXVhbGl0eUxldmVsKHBvbHlDb3VudCwgMSksXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgcG9seWdvbiBjb3VudFxuXHQgKi9cblx0cHJpdmF0ZSBjYWxjdWxhdGVQb2x5Q291bnQobWVzaDogVEhSRUUuR3JvdXApOiBudW1iZXIge1xuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0bWVzaC50cmF2ZXJzZSgoY2hpbGQpID0+IHtcblx0XHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggJiYgY2hpbGQuZ2VvbWV0cnkpIHtcblx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBjaGlsZC5nZW9tZXRyeTtcblx0XHRcdFx0aWYgKGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24pIHtcblx0XHRcdFx0XHRjb3VudCArPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50IC8gMztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBjb3VudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb3VudCBmZWF0dXJlcyBpbiBtZXNoXG5cdCAqL1xuXHRwcml2YXRlIGNvdW50RmVhdHVyZXMobWVzaDogVEhSRUUuR3JvdXApOiBudW1iZXIge1xuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0bWVzaC50cmF2ZXJzZSgoY2hpbGQpID0+IHtcblx0XHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gY291bnQ7XG5cdH1cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHF1YWxpdHkgbGV2ZWxcblx0ICovXG5cdHByaXZhdGUgZGV0ZXJtaW5lUXVhbGl0eUxldmVsKHBvbHlDb3VudDogbnVtYmVyLCB0ZXh0dXJlQ291bnQ6IG51bWJlcik6IHN0cmluZyB7XG5cdFx0aWYgKHBvbHlDb3VudCA+IDEwMDAwKSByZXR1cm4gXCJVbHRyYVwiO1xuXHRcdGlmIChwb2x5Q291bnQgPiA1MDAwKSByZXR1cm4gXCJIaWdoXCI7XG5cdFx0aWYgKHBvbHlDb3VudCA+IDIwMDApIHJldHVybiBcIk1lZGl1bVwiO1xuXHRcdHJldHVybiBcIkxvd1wiO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbmRlciBmYWxsYmFjayBwbGFuZXRcblx0ICovXG5cdHByaXZhdGUgcmVuZGVyRmFsbGJhY2tQbGFuZXQoY29uZmlnOiBQbGFuZXRSZW5kZXJDb25maWcsIHN0YXJ0VGltZTogbnVtYmVyKTogUGxhbmV0UmVuZGVyUmVzdWx0IHtcblx0XHRjb25zb2xlLndhcm4oXCLwn4yNIFtQTEFORVRdIFVzaW5nIGZhbGxiYWNrIHBsYW5ldCByZW5kZXJlclwiKTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KGNvbmZpZy5yYWRpdXMgfHwgMy4wLCAxNiwgMTYpO1xuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ODA4MDgwIH0pO1xuXHRcdGNvbnN0IG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdGNvbnN0IGdyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cdFx0Z3JvdXAuYWRkKG1lc2gpO1xuXG5cdFx0Y29uc3QgcGxhbmV0VHlwZSA9IGdldFBsYW5ldFR5cGVCeUNsYXNzKFBsYW5ldENsYXNzLlRFUlJFU1RSSUFMKSE7XG5cdFx0Y29uc3QgbWV0YWRhdGEgPSB0aGlzLmNhbGN1bGF0ZVJlbmRlck1ldGFkYXRhKGdyb3VwLCBzdGFydFRpbWUpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG1lc2g6IGdyb3VwLFxuXHRcdFx0Y29uZmlnLFxuXHRcdFx0cGxhbmV0VHlwZSxcblx0XHRcdHN0YXRpc3RpY3M6IHsgdmVydGV4Q291bnQ6IDI1NiwgZmVhdHVyZUNvdW50OiAxIH0sXG5cdFx0XHRtZXRhZGF0YSxcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBwZXJmb3JtYW5jZSBzdGF0aXN0aWNzXG5cdCAqL1xuXHRwdWJsaWMgZ2V0UGVyZm9ybWFuY2VTdGF0cygpOiB7IGxhc3RSZW5kZXJUaW1lOiBudW1iZXI7IGNhY2hlU2l6ZTogbnVtYmVyIH0ge1xuXHRcdHJldHVybiB7XG5cdFx0XHRsYXN0UmVuZGVyVGltZTogdGhpcy5sYXN0UmVuZGVyVGltZSxcblx0XHRcdGNhY2hlU2l6ZTogdGhpcy5yZW5kZXJDYWNoZS5zaXplLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXIgcmVuZGVyIGNhY2hlXG5cdCAqL1xuXHRwdWJsaWMgY2xlYXJDYWNoZSgpOiB2b2lkIHtcblx0XHR0aGlzLnJlbmRlckNhY2hlLmZvckVhY2goKG1lc2gpID0+IHtcblx0XHRcdHRoaXMuZGlzcG9zZU1lc2gobWVzaCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5yZW5kZXJDYWNoZS5jbGVhcigpO1xuXHRcdGNvbnNvbGUubG9nKFwi8J+MjSBbUExBTkVUXSBDYWNoZSBjbGVhcmVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc3Bvc2Ugb2YgbWVzaCByZXNvdXJjZXNcblx0ICovXG5cdHByaXZhdGUgZGlzcG9zZU1lc2gob2JqZWN0OiBUSFJFRS5PYmplY3QzRCk6IHZvaWQge1xuXHRcdG9iamVjdC50cmF2ZXJzZSgoY2hpbGQpID0+IHtcblx0XHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcblx0XHRcdFx0aWYgKGNoaWxkLmdlb21ldHJ5KSB7XG5cdFx0XHRcdFx0Y2hpbGQuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjaGlsZC5tYXRlcmlhbCkge1xuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkLm1hdGVyaWFsKSkge1xuXHRcdFx0XHRcdFx0Y2hpbGQubWF0ZXJpYWwuZm9yRWFjaCgobWF0ZXJpYWwpID0+IG1hdGVyaWFsLmRpc3Bvc2UoKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNoaWxkLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQcmVsb2FkIGNvbW1vbiBwbGFuZXQgdHlwZXNcblx0ICovXG5cdHB1YmxpYyBhc3luYyBwcmVsb2FkQ29tbW9uVHlwZXMoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgY29tbW9uVHlwZXMgPSBbUGxhbmV0Q2xhc3MuVEVSUkVTVFJJQUwsIFBsYW5ldENsYXNzLkdBU19HSUFOVCwgUGxhbmV0Q2xhc3MuSUNFX0dJQU5UXTtcblxuXHRcdGNvbnNvbGUubG9nKFwi8J+MjSBbUExBTkVUXSBQcmVsb2FkaW5nIGNvbW1vbiBwbGFuZXQgdHlwZXMuLi5cIik7XG5cblx0XHRmb3IgKGNvbnN0IHBsYW5ldENsYXNzIG9mIGNvbW1vblR5cGVzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlbmRlclBsYW5ldEJ5VHlwZShwbGFuZXRDbGFzcywgeyBkZXRhaWxMZXZlbDogMSB9KTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUud2Fybihg8J+MjSBbUExBTkVUXSBGYWlsZWQgdG8gcHJlbG9hZCAke3BsYW5ldENsYXNzfTpgLCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc29sZS5sb2coXCLwn4yNIFtQTEFORVRdIFByZWxvYWRpbmcgY29tcGxldGVcIik7XG5cdH1cbn1cbiJdLCJuYW1lcyI6WyJUSFJFRSIsIlBsYW5ldENsYXNzIiwiQmlvbWVUeXBlIiwiZ2V0UGxhbmV0VHlwZUJ5Q2xhc3MiLCJQTEFORVRfVFlQRVMiLCJUUkVFX1NQRUNJRVNfQllfQklPTUUiLCJNYXAiLCJURU1QRVJBVEVfRk9SRVNUIiwic3BlY2llcyIsImhlaWdodCIsInRydW5rUmFkaXVzIiwiY3Jvd25SYWRpdXMiLCJicmFuY2hDb3VudCIsImxlYWZEZW5zaXR5Iiwic2Vhc29uYWxDb2xvciIsIkNvbG9yIiwiYmlvbWVTdWl0YWJpbGl0eSIsIlRST1BJQ0FMX0pVTkdMRSIsIkRFRkFVTFRfQ09ORklHIiwicmFkaXVzIiwic2VlZCIsIkRhdGUiLCJub3ciLCJzdGFyRGlzdGFuY2UiLCJzdGFyVHlwZSIsImRldGFpbExldmVsIiwiZmVhdHVyZURlbnNpdHkiLCJjb2xvclZhcmlhdGlvbiIsImVuYWJsZUxPRCIsIm1heEZlYXR1cmVzIiwicmVuZGVyRGlzdGFuY2UiLCJlbmFibGVBdG1vc3BoZXJlIiwiZW5hYmxlUmluZ3MiLCJlbmFibGVNb29ucyIsImVuYWJsZVNwZWNpYWxFZmZlY3RzIiwiZW5hYmxlU3VyZmFjZURldGFpbHMiLCJlbmFibGVWZWdldGF0aW9uIiwidHJlZUNvdW50IiwidGVycmFpbkRldGFpbCIsInN1cmZhY2Vab29tTGV2ZWwiLCJlbmFibGVBZHZhbmNlZExpZ2h0aW5nIiwiYW1iaWVudEludGVuc2l0eSIsInN1bkludGVuc2l0eSIsIlBsYW5ldFJlbmRlcmVyIiwicmVuZGVyUGxhbmV0QnlUeXBlIiwicGxhbmV0Q2xhc3MiLCJjb25maWciLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsImZpbmFsQ29uZmlnIiwicGxhbmV0VHlwZSIsIkVycm9yIiwiY2FjaGVLZXkiLCJnZW5lcmF0ZUNhY2hlS2V5IiwicmVuZGVyQ2FjaGUiLCJoYXMiLCJjYWNoZWRNZXNoIiwiZ2V0IiwiY3JlYXRlQ2FjaGVkUmVzdWx0IiwibWVzaCIsImdlbmVyYXRlUGxhbmV0TWVzaCIsImFkZEF0bW9zcGhlcmUiLCJmZWF0dXJlcyIsInJpbmdzIiwiYWRkUmluZ3MiLCJtb29ucyIsImFkZE1vb25zIiwiYWRkU3BlY2lhbEVmZmVjdHMiLCJzZXR1cEFkdmFuY2VkTGlnaHRpbmciLCJnZW5lcmF0ZVZlZ2V0YXRpb24iLCJzZXQiLCJtZXRhZGF0YSIsImNhbGN1bGF0ZVJlbmRlck1ldGFkYXRhIiwic3RhdGlzdGljcyIsInZlcnRleENvdW50IiwiY2FsY3VsYXRlUG9seUNvdW50IiwiZmVhdHVyZUNvdW50IiwiY291bnRGZWF0dXJlcyIsImVycm9yIiwiY29uc29sZSIsInJlbmRlckZhbGxiYWNrUGxhbmV0IiwiZ3JvdXAiLCJHcm91cCIsImdlb21ldHJ5IiwiU3BoZXJlR2VvbWV0cnkiLCJtYXRlcmlhbCIsImNyZWF0ZVBsYW5ldE1hdGVyaWFsIiwiTWVzaCIsImFkZCIsInJvdGF0aW9uIiwieCIsIk1hdGgiLCJQSSIsInByaW1hcnlDb2xvciIsInByaW1hcnlDb2xvcnMiLCJNZXNoTGFtYmVydE1hdGVyaWFsIiwiY29sb3IiLCJlbWlzc2l2ZSIsImVtaXNzaXZlSW50ZW5zaXR5IiwiZ2V0TWVzaFJhZGl1cyIsImZpcnN0TWVzaCIsImNoaWxkcmVuIiwicGFyYW1ldGVycyIsImNsb3VkcyIsImF0bW9zcGhlcmVHZW9tZXRyeSIsImF0bW9zcGhlcmVNYXRlcmlhbCIsIk1lc2hCYXNpY01hdGVyaWFsIiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5Iiwic2lkZSIsIkJhY2tTaWRlIiwiYXRtb3NwaGVyZSIsInJpbmdHZW9tZXRyeSIsIlJpbmdHZW9tZXRyeSIsInJpbmdNYXRlcmlhbCIsIkRvdWJsZVNpZGUiLCJtb29uQ291bnQiLCJtaW4iLCJpIiwibW9vbkdlb21ldHJ5IiwibW9vbk1hdGVyaWFsIiwibW9vbiIsImFuZ2xlIiwiZGlzdGFuY2UiLCJwb3NpdGlvbiIsImNvcyIsInNpbiIsImNsYXNzIiwiTEFWQV9XT1JMRCIsImFkZExhdmFQYXJ0aWNsZXMiLCJJQ0VfR0lBTlQiLCJhZGRJY2VTaGltbWVycyIsImF1cm9yYWUiLCJhZGRBdXJvcmFFZmZlY3QiLCJwYXJ0aWNsZUNvdW50IiwicGFydGljbGVzIiwiQnVmZmVyR2VvbWV0cnkiLCJwb3NpdGlvbnMiLCJGbG9hdDMyQXJyYXkiLCJyYW5kb20iLCJzZXRBdHRyaWJ1dGUiLCJCdWZmZXJBdHRyaWJ1dGUiLCJwYXJ0aWNsZU1hdGVyaWFsIiwiUG9pbnRzTWF0ZXJpYWwiLCJzaXplIiwicGFydGljbGVTeXN0ZW0iLCJQb2ludHMiLCJzaGltbWVyR2VvbWV0cnkiLCJzaGltbWVyTWF0ZXJpYWwiLCJzaGltbWVyIiwiYXVyb3JhR2VvbWV0cnkiLCJhdXJvcmFNYXRlcmlhbCIsImF1cm9yYSIsImZvcmVzdHMiLCJiYXNlSGFiaXRhYmlsaXR5Iiwib3ZlcmFsbFNjb3JlIiwibG9nIiwibmFtZSIsInZlZ2V0YXRpb25Hcm91cCIsInByaW1hcnlCaW9tZSIsImdldFByaW1hcnlCaW9tZSIsInRyZWVTcGVjaWVzIiwidHJlZVBvc2l0aW9ucyIsImdlbmVyYXRlVHJlZVBvc2l0aW9ucyIsImxlbmd0aCIsInNwZWNpZXNJbmRleCIsImZsb29yIiwidHJlZSIsImdlbmVyYXRlVHJlZSIsImNvdW50IiwicGxhbmV0UmFkaXVzIiwibWluRGlzdGFuY2UiLCJtYXhBdHRlbXB0cyIsImF0dGVtcHRzIiwidmFsaWRQb3NpdGlvbiIsInRoZXRhIiwicGhpIiwiYWNvcyIsInkiLCJ6IiwiVmVjdG9yMyIsImV4aXN0aW5nUG9zIiwiZGlzdGFuY2VUbyIsInB1c2giLCJ0cmVlR3JvdXAiLCJzY2FsZSIsInRydW5rIiwiZ2VuZXJhdGVUcnVuayIsImNyb3duIiwiZ2VuZXJhdGVDcm93biIsInN1cmZhY2VOb3JtYWwiLCJjbG9uZSIsIm5vcm1hbGl6ZSIsImNvcHkiLCJsb29rQXQiLCJyb3RhdGVZIiwiQ3lsaW5kZXJHZW9tZXRyeSIsImxlcnAiLCJjYXN0U2hhZG93IiwicmVjZWl2ZVNoYWRvdyIsInRydW5rSGVpZ2h0IiwiY3Jvd25Hcm91cCIsImZvbGlhZ2VDb3VudCIsImZvbGlhZ2VSYWRpdXMiLCJsZWFmQ29sb3IiLCJmb2xpYWdlIiwicG9zc2libGVCaW9tZXMiLCJiaW9tZSIsImFtYmllbnRMaWdodCIsIkFtYmllbnRMaWdodCIsInN1bkxpZ2h0IiwiRGlyZWN0aW9uYWxMaWdodCIsImdldEF2YWlsYWJsZVBsYW5ldFR5cGVzIiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsImdldFBsYW5ldFR5cGVJbmZvIiwidXBkYXRlUXVhbGl0eSIsInF1YWxpdHlMZXZlbCIsIm1heCIsImNsZWFyQ2FjaGUiLCJkaXNwb3NlIiwiaXNEaXNwb3NlZCIsIlRFUlJFU1RSSUFMIiwicmVuZGVyVGltZSIsInBvbHlDb3VudCIsInRleHR1cmVDb3VudCIsIm1lbW9yeVVzYWdlIiwiZGV0ZXJtaW5lUXVhbGl0eUxldmVsIiwidHJhdmVyc2UiLCJjaGlsZCIsImF0dHJpYnV0ZXMiLCJ3YXJuIiwiZ2V0UGVyZm9ybWFuY2VTdGF0cyIsImxhc3RSZW5kZXJUaW1lIiwiY2FjaGVTaXplIiwiZm9yRWFjaCIsImRpc3Bvc2VNZXNoIiwiY2xlYXIiLCJvYmplY3QiLCJpc0FycmF5IiwicHJlbG9hZENvbW1vblR5cGVzIiwiY29tbW9uVHlwZXMiLCJHQVNfR0lBTlQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/shared/procgen/planet/planet-renderer.ts\n"));

/***/ })

}]);
"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9101],{381:(e,t,r)=>{r.d(t,{A:()=>a});let a=(0,r(9946).A)("settings",[["path",{d:"M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",key:"1qme2f"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]])},446:(e,t,r)=>{r.d(t,{A:()=>a});let a=(0,r(9946).A)("bug",[["path",{d:"m8 2 1.88 1.88",key:"fmnt4t"}],["path",{d:"M14.12 3.88 16 2",key:"qol33r"}],["path",{d:"M9 7.13v-1a3.003 3.003 0 1 1 6 0v1",key:"d7y7pr"}],["path",{d:"M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6",key:"xs1cw7"}],["path",{d:"M12 20v-9",key:"1qisl0"}],["path",{d:"M6.53 9C4.6 8.8 3 7.1 3 5",key:"32zzws"}],["path",{d:"M6 13H2",key:"82j7cp"}],["path",{d:"M3 21c0-2.1 1.7-3.9 3.8-4",key:"4p0ekp"}],["path",{d:"M20.97 5c0 2.1-1.6 3.8-3.5 4",key:"18gb23"}],["path",{d:"M22 13h-4",key:"1jl80f"}],["path",{d:"M17.2 17c2.1.1 3.8 1.9 3.8 4",key:"k3fwyw"}]])},1177:(e,t,r)=>{r.d(t,{A:()=>a});let a=(0,r(9946).A)("memory-stick",[["path",{d:"M6 19v-3",key:"1nvgqn"}],["path",{d:"M10 19v-3",key:"iu8nkm"}],["path",{d:"M14 19v-3",key:"kcehxu"}],["path",{d:"M18 19v-3",key:"1vh91z"}],["path",{d:"M8 11V9",key:"63erz4"}],["path",{d:"M16 11V9",key:"fru6f3"}],["path",{d:"M12 11V9",key:"ha00sb"}],["path",{d:"M2 15h20",key:"16ne18"}],["path",{d:"M2 7a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v1.1a2 2 0 0 0 0 3.837V17a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-5.1a2 2 0 0 0 0-3.837Z",key:"lhddv3"}]])},1243:(e,t,r)=>{r.d(t,{A:()=>a});let a=(0,r(9946).A)("triangle-alert",[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]])},1284:(e,t,r)=>{r.d(t,{A:()=>a});let a=(0,r(9946).A)("info",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"M12 16v-4",key:"1dtifu"}],["path",{d:"M12 8h.01",key:"e9boi3"}]])},1539:(e,t,r)=>{r.d(t,{A:()=>a});let a=(0,r(9946).A)("zap",[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]])},3904:(e,t,r)=>{r.d(t,{A:()=>a});let a=(0,r(9946).A)("refresh-cw",[["path",{d:"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",key:"v9h5vc"}],["path",{d:"M21 3v5h-5",key:"1q7to0"}],["path",{d:"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",key:"3uifl3"}],["path",{d:"M8 16H3v5",key:"1cv678"}]])},4186:(e,t,r)=>{r.d(t,{A:()=>a});let a=(0,r(9946).A)("clock",[["path",{d:"M12 6v6l4 2",key:"mmk7yg"}],["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}]])},4738:(e,t,r)=>{r.d(t,{A:()=>a});let a=(0,r(9946).A)("monitor",[["rect",{width:"20",height:"14",x:"2",y:"3",rx:"2",key:"48i651"}],["line",{x1:"8",x2:"16",y1:"21",y2:"21",key:"1svkeh"}],["line",{x1:"12",x2:"12",y1:"17",y2:"21",key:"vw1qmm"}]])},4869:(e,t,r)=>{r.d(t,{A:()=>a});let a=(0,r(9946).A)("globe",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20",key:"13o1zl"}],["path",{d:"M2 12h20",key:"9i4pu4"}]])},6898:(e,t,r)=>{r.d(t,{A:()=>c});var a=r(2115),n=r(1991),i=r(7431);let l=parseInt(i.REVISION.replace(/\D+/g,""));class o extends i.ShaderMaterial{constructor(){super({uniforms:{time:{value:0},fade:{value:1}},vertexShader:`
      uniform float time;
      attribute float size;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
        gl_Position = projectionMatrix * mvPosition;
      }`,fragmentShader:`
      uniform sampler2D pointTexture;
      uniform float fade;
      varying vec3 vColor;
      void main() {
        float opacity = 1.0;
        if (fade == 1.0) {
          float d = distance(gl_PointCoord, vec2(0.5, 0.5));
          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
        }
        gl_FragColor = vec4(vColor, opacity);

        #include <tonemapping_fragment>
	      #include <${l>=154?"colorspace_fragment":"encodings_fragment"}>
      }`})}}let s=e=>new i.Vector3().setFromSpherical(new i.Spherical(e,Math.acos(1-2*Math.random()),2*Math.random()*Math.PI)),c=a.forwardRef(({radius:e=100,depth:t=50,count:r=5e3,saturation:l=0,factor:c=4,fade:d=!1,speed:u=1},h)=>{let m=a.useRef(null),[p,f,y]=a.useMemo(()=>{let a=[],n=[],o=Array.from({length:r},()=>(.5+.5*Math.random())*c),d=new i.Color,u=e+t,h=t/r;for(let e=0;e<r;e++)u-=h*Math.random(),a.push(...s(u).toArray()),d.setHSL(e/r,l,.9),n.push(d.r,d.g,d.b);return[new Float32Array(a),new Float32Array(n),new Float32Array(o)]},[r,t,c,e,l]);(0,n.D)(e=>m.current&&(m.current.uniforms.time.value=e.clock.elapsedTime*u));let[v]=a.useState(()=>new o);return a.createElement("points",{ref:h},a.createElement("bufferGeometry",null,a.createElement("bufferAttribute",{attach:"attributes-position",args:[p,3]}),a.createElement("bufferAttribute",{attach:"attributes-color",args:[f,3]}),a.createElement("bufferAttribute",{attach:"attributes-size",args:[y,1]})),a.createElement("primitive",{ref:m,object:v,attach:"material",blending:i.AdditiveBlending,"uniforms-fade-value":d,depthWrite:!1,transparent:!0,vertexColors:!0}))})},7340:(e,t,r)=>{r.d(t,{A:()=>a});let a=(0,r(9946).A)("house",[["path",{d:"M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8",key:"5wwlr5"}],["path",{d:"M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",key:"1d0kgt"}]])},8611:(e,t,r)=>{r.d(t,{A:()=>a});let a=(0,r(9946).A)("gauge",[["path",{d:"m12 14 4-4",key:"9kzdfg"}],["path",{d:"M3.34 19a10 10 0 1 1 17.32 0",key:"19p75a"}]])},9957:(e,t,r)=>{let a,n;r.d(t,{E:()=>M});var i=r(9630),l=r(2115),o=r(2669),s=r(7431),c=r(1991);let d=new s.Vector3,u=new s.Vector3,h=new s.Vector3,m=new s.Vector2;function p(e,t,r){let a=d.setFromMatrixPosition(e.matrixWorld);a.project(t);let n=r.width/2,i=r.height/2;return[a.x*n+n,-(a.y*i)+i]}let f=e=>1e-10>Math.abs(e)?0:e;function y(e,t,r=""){let a="matrix3d(";for(let r=0;16!==r;r++)a+=f(t[r]*e.elements[r])+(15!==r?",":")");return r+a}let v=(a=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>y(e,a)),x=(n=e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1],(e,t)=>y(e,n(t),"translate(-50%,-50%)")),M=l.forwardRef(({children:e,eps:t=.001,style:r,className:a,prepend:n,center:y,fullscreen:M,portal:g,distanceFactor:k,sprite:A=!1,transform:b=!1,occlude:w,onOcclude:P,castShadow:E,receiveShadow:z,material:S,geometry:W,zIndexRange:C=[0x1000037,0],calculatePosition:$=p,as:F="div",wrapperClass:R,pointerEvents:V="auto",..._},j)=>{let{gl:I,camera:T,scene:H,size:q,raycaster:N,events:L,viewport:D}=(0,c.C)(),[O]=l.useState(()=>document.createElement(F)),G=l.useRef(null),Z=l.useRef(null),B=l.useRef(0),J=l.useRef([0,0]),K=l.useRef(null),Q=l.useRef(null),U=(null==g?void 0:g.current)||L.connected||I.domElement.parentNode,X=l.useRef(null),Y=l.useRef(!1),ee=l.useMemo(()=>w&&"blending"!==w||Array.isArray(w)&&w.length&&function(e){return e&&"object"==typeof e&&"current"in e}(w[0]),[w]);l.useLayoutEffect(()=>{let e=I.domElement;w&&"blending"===w?(e.style.zIndex=`${Math.floor(C[0]/2)}`,e.style.position="absolute",e.style.pointerEvents="none"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)},[w]),l.useLayoutEffect(()=>{if(Z.current){let e=G.current=o.createRoot(O);if(H.updateMatrixWorld(),b)O.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{let e=$(Z.current,T,q);O.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;`}return U&&(n?U.prepend(O):U.appendChild(O)),()=>{U&&U.removeChild(O),e.unmount()}}},[U,b]),l.useLayoutEffect(()=>{R&&(O.className=R)},[R]);let et=l.useMemo(()=>b?{position:"absolute",top:0,left:0,width:q.width,height:q.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:y?"translate3d(-50%,-50%,0)":"none",...M&&{top:-q.height/2,left:-q.width/2,width:q.width,height:q.height},...r},[r,y,M,q,b]),er=l.useMemo(()=>({position:"absolute",pointerEvents:V}),[V]);l.useLayoutEffect(()=>{var t,n;Y.current=!1,b?null==(t=G.current)||t.render(l.createElement("div",{ref:K,style:et},l.createElement("div",{ref:Q,style:er},l.createElement("div",{ref:j,className:a,style:r,children:e})))):null==(n=G.current)||n.render(l.createElement("div",{ref:j,style:et,className:a,children:e}))});let ea=l.useRef(!0);(0,c.D)(e=>{if(Z.current){T.updateMatrixWorld(),Z.current.updateWorldMatrix(!0,!1);let e=b?J.current:$(Z.current,T,q);if(b||Math.abs(B.current-T.zoom)>t||Math.abs(J.current[0]-e[0])>t||Math.abs(J.current[1]-e[1])>t){let t=function(e,t){let r=d.setFromMatrixPosition(e.matrixWorld),a=u.setFromMatrixPosition(t.matrixWorld),n=r.sub(a),i=t.getWorldDirection(h);return n.angleTo(i)>Math.PI/2}(Z.current,T),r=!1;ee&&(Array.isArray(w)?r=w.map(e=>e.current):"blending"!==w&&(r=[H]));let a=ea.current;r?ea.current=function(e,t,r,a){let n=d.setFromMatrixPosition(e.matrixWorld),i=n.clone();i.project(t),m.set(i.x,i.y),r.setFromCamera(m,t);let l=r.intersectObjects(a,!0);if(l.length){let e=l[0].distance;return n.distanceTo(r.ray.origin)<e}return!0}(Z.current,T,N,r)&&!t:ea.current=!t,a!==ea.current&&(P?P(!ea.current):O.style.display=ea.current?"block":"none");let n=Math.floor(C[0]/2),i=w?ee?[C[0],n]:[n-1,0]:C;if(O.style.zIndex=`${function(e,t,r){if(t instanceof s.PerspectiveCamera||t instanceof s.OrthographicCamera){let a=d.setFromMatrixPosition(e.matrixWorld),n=u.setFromMatrixPosition(t.matrixWorld),i=a.distanceTo(n),l=(r[1]-r[0])/(t.far-t.near),o=r[1]-l*t.far;return Math.round(l*i+o)}}(Z.current,T,i)}`,b){let[e,t]=[q.width/2,q.height/2],r=T.projectionMatrix.elements[5]*t,{isOrthographicCamera:a,top:n,left:i,bottom:l,right:o}=T,s=v(T.matrixWorldInverse),c=a?`scale(${r})translate(${f(-(o+i)/2)}px,${f((n+l)/2)}px)`:`translateZ(${r}px)`,d=Z.current.matrixWorld;A&&((d=T.matrixWorldInverse.clone().transpose().copyPosition(d).scale(Z.current.scale)).elements[3]=d.elements[7]=d.elements[11]=0,d.elements[15]=1),O.style.width=q.width+"px",O.style.height=q.height+"px",O.style.perspective=a?"":`${r}px`,K.current&&Q.current&&(K.current.style.transform=`${c}${s}translate(${e}px,${t}px)`,Q.current.style.transform=x(d,1/((k||10)/400)))}else{let t=void 0===k?1:function(e,t){if(t instanceof s.OrthographicCamera)return t.zoom;if(!(t instanceof s.PerspectiveCamera))return 1;{let r=d.setFromMatrixPosition(e.matrixWorld),a=u.setFromMatrixPosition(t.matrixWorld);return 1/(2*Math.tan(t.fov*Math.PI/180/2)*r.distanceTo(a))}}(Z.current,T)*k;O.style.transform=`translate3d(${e[0]}px,${e[1]}px,0) scale(${t})`}J.current=e,B.current=T.zoom}}if(!ee&&X.current&&!Y.current)if(b){if(K.current){let e=K.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){let{isOrthographicCamera:t}=T;if(t||W)_.scale&&(Array.isArray(_.scale)?_.scale instanceof s.Vector3?X.current.scale.copy(_.scale.clone().divideScalar(1)):X.current.scale.set(1/_.scale[0],1/_.scale[1],1/_.scale[2]):X.current.scale.setScalar(1/_.scale));else{let t=(k||10)/400,r=e.clientWidth*t,a=e.clientHeight*t;X.current.scale.set(r,a,1)}Y.current=!0}}}else{let t=O.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){let e=1/D.factor,r=t.clientWidth*e,a=t.clientHeight*e;X.current.scale.set(r,a,1),Y.current=!0}X.current.lookAt(e.camera.position)}});let en=l.useMemo(()=>({vertexShader:b?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[b]);return l.createElement("group",(0,i.A)({},_,{ref:Z}),w&&!ee&&l.createElement("mesh",{castShadow:E,receiveShadow:z,ref:X},W||l.createElement("planeGeometry",null),S||l.createElement("shaderMaterial",{side:s.DoubleSide,vertexShader:en.vertexShader,fragmentShader:en.fragmentShader})))})}}]);